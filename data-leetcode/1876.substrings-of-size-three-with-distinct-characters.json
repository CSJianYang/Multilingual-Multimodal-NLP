[
    {
        "title": "Substrings of Size Three with Distinct Characters",
        "question_content": "A string is good if there are no repeated characters.\nGiven a string s​​​​​, return the number of good substrings of length three in s​​​​​​.\nNote that if there are multiple occurrences of the same substring, every occurrence should be counted.\nA substring is a contiguous sequence of characters in a string.\n&nbsp;\nExample 1:\n\nInput: s = \"xyzzaz\"\nOutput: 1\nExplanation: There are 4 substrings of size 3: \"xyz\", \"yzz\", \"zza\", and \"zaz\". \nThe only good substring of length 3 is \"xyz\".\n\nExample 2:\n\nInput: s = \"aababcabc\"\nOutput: 4\nExplanation: There are 7 substrings of size 3: \"aab\", \"aba\", \"bab\", \"abc\", \"bca\", \"cab\", and \"abc\".\nThe good substrings are \"abc\", \"bca\", \"cab\", and \"abc\".\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 100\n\ts​​​​​​ consists of lowercase English letters.",
        "solutions": [
            {
                "id": 1238665,
                "title": "easy-solution-o-n-approach",
                "content": "Here we are using sliding window technique with a window size of 3\\nWith every iteration new element is pushed into the window and the last element of window is pushed out.\\nWith in every window we check if there is any repetition of elements using if loop\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3)return 0;\\n        char a=s[0],b=s[1],c=s[2];\\n        int res=0;\\n        for(int i=3;i<=s.size()-1;i++)\\n        {\\n            if(a!=b and b!=c and c!=a)res++;\\n            a=b;\\n            b=c;\\n            c=s[i];\\n        }\\n        if(a!=b and b!=c and c!=a)res++;\\n        return res;\\n    }\\n};\\n```\\n**Do upvote and keep supporting..!**",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3)return 0;\\n        char a=s[0],b=s[1],c=s[2];\\n        int res=0;\\n        for(int i=3;i<=s.size()-1;i++)\\n        {\\n            if(a!=b and b!=c and c!=a)res++;\\n            a=b;\\n            b=c;\\n            c=s[i];\\n        }\\n        if(a!=b and b!=c and c!=a)res++;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399854,
                "title": "c-never-under-estimate-an-easy-qn-it-can-teach-you-many-things",
                "content": "```\\n//Approach-1 (That comes to your mind in one go)\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count = 0;\\n        if(s.length() < 3) return 0;\\n        for(int i = 0; i<=s.length()-3; i++) {\\n            if(s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2])\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Using siding window - It can be used to solve the generalized version of the question ( k sized substring))\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count = 0;\\n        int dup   = 0;\\n        if(s.length() < 3) return 0;\\n        int mp[26] = {0};\\n        \\n        for(int i = 0; i<s.length(); i++) {\\n            mp[s[i]-\\'a\\']++;\\n            \\n            if(mp[s[i]-\\'a\\'] == 2)\\n                dup++;\\n            \\n            if(i < 2) continue;\\n            \\n            if(dup == 0) count++;\\n            \\n            //now shift right (so, (i-2)th character\\'s frequency in current window is decreased)\\n            mp[s[i-2]-\\'a\\']--;\\n            \\n            if(mp[s[i-2]-\\'a\\'] == 1) //it means it had increased dup (dup++)\\n                dup--;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (That comes to your mind in one go)\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count = 0;\\n        if(s.length() < 3) return 0;\\n        for(int i = 0; i<=s.length()-3; i++) {\\n            if(s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2])\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\n//Approach-2 (Using siding window - It can be used to solve the generalized version of the question ( k sized substring))\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count = 0;\\n        int dup   = 0;\\n        if(s.length() < 3) return 0;\\n        int mp[26] = {0};\\n        \\n        for(int i = 0; i<s.length(); i++) {\\n            mp[s[i]-\\'a\\']++;\\n            \\n            if(mp[s[i]-\\'a\\'] == 2)\\n                dup++;\\n            \\n            if(i < 2) continue;\\n            \\n            if(dup == 0) count++;\\n            \\n            //now shift right (so, (i-2)th character\\'s frequency in current window is decreased)\\n            mp[s[i-2]-\\'a\\']--;\\n            \\n            if(mp[s[i-2]-\\'a\\'] == 1) //it means it had increased dup (dup++)\\n                dup--;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485329,
                "title": "classic-sliding-window-beats-100-beginner-friendly-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\t/* \\n\\t * This is classic sliding window problem with fixed window length 3 here \\n\\t * we will always maintain the window len 3(fixed length)  by adjusting i and j \\n\\t * in all similar problems\\n\\t */\\n        /* i is LHS of the window */\\n        int i = 0;\\n       /* j is RHS of window */\\n        int j = 0;\\n        int n = s.size();\\n\\t\\t\\n\\t\\t/* Map to keep track of occurance of each char */\\n        unordered_map<char, int>mp;\\n\\t\\t\\n\\t\\t/* Variable keeping track of answer/result */\\n        int ans = 0;\\n        \\n        while (i < n && j < n) {\\n            /* Increment the count in map each time you iterate through any character */\\n            mp[s[j]]++;\\n            \\n           \\n            if (j - i + 1 < 3) {\\n            /* Case 1:\\n             *  Keep incrementing the RHS till you  make substring of exactly length 3(fixed length). \\n             */\\n                j++;\\n            } else if (mp.size() == 3) {\\n              /* Case 2: \\n\\t\\t\\t   * If the map size is exact 3 we have found the sub string with 3 unique \\n               * chars(here window len 3 we are mainting always) ,\\n\\t\\t\\t   * increment the answer, Also shift the LHS and RHS of the current window for which result is calulated\\n\\t\\t\\t   * and remove the entry from map for the LHS(Note the RHS will still be part of new shifted window).\\n\\t\\t\\t   */\\n                ans++;\\n                mp.erase(s[i]);\\n                i++;\\n                j++;\\n            } else {\\n               /*\\n\\t\\t\\t    * Case 3: \\n\\t\\t\\t    * If map size is not equal to 3 (sliding window len here will always be 3)then we surely have some\\n\\t\\t\\t    * repeating chars so we need to slide the window again.\\n\\t\\t\\t    * For LHS Decrement the count from map and if its zero then erase it as we are using \\n\\t\\t\\t    * size of map to calucate number of unique elements present(Note the RHS will  still be part of new shifted window) \\n\\t\\t\\t    */\\n                mp[s[i]]--;\\n                if (mp[s[i]] == 0) {\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n                \\n            }\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\nIts my first post, please upvote if you find this helpful :)",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\t/* \\n\\t * This is classic sliding window problem with fixed window length 3 here \\n\\t * we will always maintain the window len 3(fixed length)  by adjusting i and j \\n\\t * in all similar problems\\n\\t */\\n        /* i is LHS of the window */\\n        int i = 0;\\n       /* j is RHS of window */\\n        int j = 0;\\n        int n = s.size();\\n\\t\\t\\n\\t\\t/* Map to keep track of occurance of each char */\\n        unordered_map<char, int>mp;\\n\\t\\t\\n\\t\\t/* Variable keeping track of answer/result */\\n        int ans = 0;\\n        \\n        while (i < n && j < n) {\\n            /* Increment the count in map each time you iterate through any character */\\n            mp[s[j]]++;\\n            \\n           \\n            if (j - i + 1 < 3) {\\n            /* Case 1:\\n             *  Keep incrementing the RHS till you  make substring of exactly length 3(fixed length). \\n             */\\n                j++;\\n            } else if (mp.size() == 3) {\\n              /* Case 2: \\n\\t\\t\\t   * If the map size is exact 3 we have found the sub string with 3 unique \\n               * chars(here window len 3 we are mainting always) ,\\n\\t\\t\\t   * increment the answer, Also shift the LHS and RHS of the current window for which result is calulated\\n\\t\\t\\t   * and remove the entry from map for the LHS(Note the RHS will still be part of new shifted window).\\n\\t\\t\\t   */\\n                ans++;\\n                mp.erase(s[i]);\\n                i++;\\n                j++;\\n            } else {\\n               /*\\n\\t\\t\\t    * Case 3: \\n\\t\\t\\t    * If map size is not equal to 3 (sliding window len here will always be 3)then we surely have some\\n\\t\\t\\t    * repeating chars so we need to slide the window again.\\n\\t\\t\\t    * For LHS Decrement the count from map and if its zero then erase it as we are using \\n\\t\\t\\t    * size of map to calucate number of unique elements present(Note the RHS will  still be part of new shifted window) \\n\\t\\t\\t    */\\n                mp[s[i]]--;\\n                if (mp[s[i]] == 0) {\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n                \\n            }\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238721,
                "title": "java-5-liner-o-n",
                "content": "```\\npublic int countGoodSubstrings(String s) {\\n\\tint result = 0;\\n\\tfor(int i=1;i<s.length()-1;i++)\\n\\t\\tif(s.charAt(i-1) != s.charAt(i) && s.charAt(i+1) != s.charAt(i) && s.charAt(i+1) != s.charAt(i-1))\\n\\t\\t\\tresult++;\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countGoodSubstrings(String s) {\\n\\tint result = 0;\\n\\tfor(int i=1;i<s.length()-1;i++)\\n\\t\\tif(s.charAt(i-1) != s.charAt(i) && s.charAt(i+1) != s.charAt(i) && s.charAt(i+1) != s.charAt(i-1))\\n\\t\\t\\tresult++;\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240095,
                "title": "python-3-simple-and-linear-time",
                "content": "Iterative over string and increase the counter if all characters of length 3 string are different.\\n\\n```\\n def countGoodSubstrings(self, s: str) -> int:\\n        ans=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3:\\n                ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n def countGoodSubstrings(self, s: str) -> int:\\n        ans=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3:\\n                ans+=1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1238687,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        for(int i = 0; i < n - 2; i++) {\\n            char c1 = s.charAt(i);\\n            char c2 = s.charAt(i + 1);\\n            char c3 = s.charAt(i + 2);\\n            if(c1 == c2 || c2 == c3 || c1 == c3) continue;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        for(int i = 0; i < n - 2; i++) {\\n            char c1 = s.charAt(i);\\n            char c2 = s.charAt(i + 1);\\n            char c3 = s.charAt(i + 2);\\n            if(c1 == c2 || c2 == c3 || c1 == c3) continue;\\n            ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1238676,
                "title": "sliding-window",
                "content": "A standard approach to count repeated characters in a sliding window.\\n\\n**C++**\\n```cpp\\nint countGoodSubstrings(string s) {\\n    int cnt[123] = {}, repeat = 0, res = 0;\\n    for(int i = 0; i < s.size(); ++i) {\\n        repeat += cnt[s[i]]++ == 1;\\n        repeat -= i >= 3 && cnt[s[i - 3]]-- == 2;\\n        res += i >= 2 && repeat == 0;\\n    }\\n    return res;\\n}\\n```\\n**Java**\\n```java\\npublic int countGoodSubstrings(String s) {\\n    int cnt[] = new int[123], repeat = 0, res = 0;\\n    for(int i = 0; i < s.length(); ++i) {\\n        repeat += cnt[s.charAt(i)]++ == 1 ? 1 : 0;\\n        repeat -= i >= 3 && cnt[s.charAt(i - 3)]-- == 2 ? 1 : 0;\\n        res += i >= 2 && repeat == 0 ? 1 : 0;\\n    }    \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint countGoodSubstrings(string s) {\\n    int cnt[123] = {}, repeat = 0, res = 0;\\n    for(int i = 0; i < s.size(); ++i) {\\n        repeat += cnt[s[i]]++ == 1;\\n        repeat -= i >= 3 && cnt[s[i - 3]]-- == 2;\\n        res += i >= 2 && repeat == 0;\\n    }\\n    return res;\\n}\\n```\n```java\\npublic int countGoodSubstrings(String s) {\\n    int cnt[] = new int[123], repeat = 0, res = 0;\\n    for(int i = 0; i < s.length(); ++i) {\\n        repeat += cnt[s.charAt(i)]++ == 1 ? 1 : 0;\\n        repeat -= i >= 3 && cnt[s.charAt(i - 3)]-- == 2 ? 1 : 0;\\n        res += i >= 2 && repeat == 0 ? 1 : 0;\\n    }    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1429825,
                "title": "java-simple-o-n-100",
                "content": "if you like it pls upvote\\n\\nJava\\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int res = 0;\\n        \\n        for(int i = 2 ; i< s.length();i++)\\n            if(s.charAt(i) != s.charAt(i-1) && s.charAt(i) != s.charAt(i-2)  && s.charAt(i-1) != s.charAt(i-2))\\n                res++;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int res = 0;\\n        \\n        for(int i = 2 ; i< s.length();i++)\\n            if(s.charAt(i) != s.charAt(i-1) && s.charAt(i) != s.charAt(i-2)  && s.charAt(i-1) != s.charAt(i-2))\\n                res++;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904752,
                "title": "sliding-window-simplest-approach-c",
                "content": "**AN UPVOTE WOUULD BE HIGHLY APPERICIATED**\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0;int j=0;\\n        map<char,int> ans;\\n        int a=0;\\n        while(j<s.size()){\\n            ans[s[j]]++;\\n            if(j-i+1<3) {j++;}\\n            else if(j-i+1==3){\\n                if(ans.size()==3) a++;\\n                if(ans[s[i]]==1) ans.erase(s[i]);\\n                else ans[s[i]]--;\\n                i++;j++;}\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0;int j=0;\\n        map<char,int> ans;\\n        int a=0;\\n        while(j<s.size()){\\n            ans[s[j]]++;\\n            if(j-i+1<3) {j++;}\\n            else if(j-i+1==3){\\n                if(ans.size()==3) a++;\\n                if(ans[s[i]]==1) ans.erase(s[i]);\\n                else ans[s[i]]--;\\n                i++;j++;}\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356591,
                "title": "easy-python-solution-98-80",
                "content": "Runtime: 24 ms, faster than 98.80% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\nMemory Usage: 14.3 MB, less than 42.54% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if(s[i]!=s[i+1] and s[i]!=s[i+2] and s[i+1]!=s[i+2]):\\n                count+=1\\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 24 ms, faster than 98.80% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\nMemory Usage: 14.3 MB, less than 42.54% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if(s[i]!=s[i+1] and s[i]!=s[i+2] and s[i+1]!=s[i+2]):\\n                count+=1\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1238685,
                "title": "c-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int cnt=0,n=s.size();\\n        unordered_map<char,int> map;\\n        for(int i=0;i<n;i++){\\n            if(i>2 and --map[s[i-3]] == 0) map.erase(s[i-3]);\\n            map[s[i]]++;\\n            if(map.size() == 3) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int cnt=0,n=s.size();\\n        unordered_map<char,int> map;\\n        for(int i=0;i<n;i++){\\n            if(i>2 and --map[s[i-3]] == 0) map.erase(s[i-3]);\\n            map[s[i]]++;\\n            if(map.size() == 3) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455895,
                "title": "easy-and-well-explained-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    //we can solve this problem by using sliding window technique\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0; //k is the size of window\\n        int count=0,n = s.length();\\n        map<char,int>mp; //we create map to store the frequency of each character \\n        while(j<n){\\n            mp[s[j]]++; //push the element into map\\n            if(j-i+1 < k){ //since we want length of substring three so till that point we will just add character\\n                j++;\\n            }else{\\n                if(mp.size() == 3){ //we check that all three entries are unique or not..\\n                    count++;\\n                }\\n                mp[s[i]]--; //this is the step where we slide our window\\n                if(mp[s[i]] == 0){ //if at any step our frquency of that character becomes zero then we have to remove it from our map\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++; //to slide our window we move our both pointers\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //we can solve this problem by using sliding window technique\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0; //k is the size of window\\n        int count=0,n = s.length();\\n        map<char,int>mp; //we create map to store the frequency of each character \\n        while(j<n){\\n            mp[s[j]]++; //push the element into map\\n            if(j-i+1 < k){ //since we want length of substring three so till that point we will just add character\\n                j++;\\n            }else{\\n                if(mp.size() == 3){ //we check that all three entries are unique or not..\\n                    count++;\\n                }\\n                mp[s[i]]--; //this is the step where we slide our window\\n                if(mp[s[i]] == 0){ //if at any step our frquency of that character becomes zero then we have to remove it from our map\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++; //to slide our window we move our both pointers\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155417,
                "title": "java-beats-90-sliding-window-with-detailed-explanation",
                "content": "![image.png](https://assets.leetcode.com/users/images/b6852eab-4964-47ac-9e70-d7996cd86176_1675767633.4297187.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis problem is being approached by Sliding Windows Algorithm. We take two pointers for determining the window and then checking our condition of uniqueness.\\n\\n![WhatsApp Image 2023-02-07 at 4.28.52 PM.jpeg](https://assets.leetcode.com/users/images/ed778d99-d6d2-4a5b-9c35-00443b1aebbb_1675767797.020403.jpeg)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0, j=0, count=0;\\n        while(j<s.length()){\\n            if(j-i+1==3){\\n                if(s.charAt(i) != s.charAt(i+1) && s.charAt(i+1) != s.charAt(i+2) \\n                && s.charAt(i+2) != s.charAt(i)){\\n                    count++;\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n# Do give this solution an Upvote if you find it helpful:)\\n![emojipng.com-12080000.png](https://assets.leetcode.com/users/images/8ecfc048-081b-4b5d-8acb-277a9d817b57_1675768050.9240546.png)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0, j=0, count=0;\\n        while(j<s.length()){\\n            if(j-i+1==3){\\n                if(s.charAt(i) != s.charAt(i+1) && s.charAt(i+1) != s.charAt(i+2) \\n                && s.charAt(i+2) != s.charAt(i)){\\n                    count++;\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458854,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar countGoodSubstrings = function(s) {\\n\\t\\tlet good = 0;\\n\\n\\t\\tfor (let index = 0; index < s.length - 2; index++) {\\n\\t\\t\\tconst subStr = s.slice(index, index + 3);\\n\\t\\t\\tconst set = new Set(subStr);\\n\\n\\t\\t\\tset.size === 3 && (good += 1);\\n\\t\\t}\\n\\t\\treturn good;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar countGoodSubstrings = function(s) {\\n\\t\\tlet good = 0;\\n\\n\\t\\tfor (let index = 0; index < s.length - 2; index++) {\\n\\t\\t\\tconst subStr = s.slice(index, index + 3);\\n\\t\\t\\tconst set = new Set(subStr);\\n\\n\\t\\t\\tset.size === 3 && (good += 1);\\n\\t\\t}\\n\\t\\treturn good;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 3971421,
                "title": "java-10000-beats-0-n-2-solution-hashset-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n           if(s.length()<=2) return 0;\\n           int ans = 0;   //  Please UPVOTE ME....\\n           for(int i=0; i<s.length()-2; i++){\\n               if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2)) ans++;\\n           }\\n           return ans;\\n\\n\\n//                   Another solution (Using HashSet<>) --> try this one\\n\\n        // char temp[] = s.toCharArray();\\n        // int count = 0 , low = 0 , ans = 0 , i = 0;\\n        // Set<Character> set = new HashSet<>();\\n        // if(temp.length<=2) return 0;\\n        // while(low!=temp.length-2){\\n        //        set.add(temp[i]); i++; count++;\\n        //        if(count==3){\\n        //            if(set.size()==3){\\n        //                ans++; count = 0;\\n        //            }else  count = 0;\\n        //            low++; set.clear(); i = low;\\n        //        }\\n        // }\\n        // return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n           if(s.length()<=2) return 0;\\n           int ans = 0;   //  Please UPVOTE ME....\\n           for(int i=0; i<s.length()-2; i++){\\n               if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2)) ans++;\\n           }\\n           return ans;\\n\\n\\n//                   Another solution (Using HashSet<>) --> try this one\\n\\n        // char temp[] = s.toCharArray();\\n        // int count = 0 , low = 0 , ans = 0 , i = 0;\\n        // Set<Character> set = new HashSet<>();\\n        // if(temp.length<=2) return 0;\\n        // while(low!=temp.length-2){\\n        //        set.add(temp[i]); i++; count++;\\n        //        if(count==3){\\n        //            if(set.size()==3){\\n        //                ans++; count = 0;\\n        //            }else  count = 0;\\n        //            low++; set.clear(); i = low;\\n        //        }\\n        // }\\n        // return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238647,
                "title": "clean-python-3-straightforward",
                "content": "Time: `O(N)`\\nSpace: `O(1)`\\n\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        if len(s) < 3: return 0 # it still can work if we remove this line (credit to @Silvia42)\\n        return sum(s[i] != s[i-1] != s[i-2] != s[i] for i in range(2, len(s)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        if len(s) < 3: return 0 # it still can work if we remove this line (credit to @Silvia42)\\n        return sum(s[i] != s[i-1] != s[i-2] != s[i] for i in range(2, len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314718,
                "title": "java-easy-solution-sliding-window",
                "content": "//please ask if have any doubt\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0,j=0,count=0;\\n        HashMap<Character,Integer>map=new HashMap<>();\\n        while(j<s.length())\\n        {\\n            map.put(s.charAt(j),map.getOrDefault(s.charAt(j),0)+1);\\n            if(j-i+1<3)\\n            {\\n                j++;\\n            }else if(j-i+1==3)\\n            {\\n                if(map.size()==3)\\n                {\\n                    count++;\\n                    //System.out.println(map);\\n                }\\n                int val=map.get(s.charAt(i));\\n                val=val-1;\\n                if(val==0){\\n                    map.remove(s.charAt(i));\\n                }else{\\n                    map.put(s.charAt(i),val);\\n                }\\n                \\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0,j=0,count=0;\\n        HashMap<Character,Integer>map=new HashMap<>();\\n        while(j<s.length())\\n        {\\n            map.put(s.charAt(j),map.getOrDefault(s.charAt(j),0)+1);\\n            if(j-i+1<3)\\n            {\\n                j++;\\n            }else if(j-i+1==3)\\n            {\\n                if(map.size()==3)\\n                {\\n                    count++;\\n                    //System.out.println(map);\\n                }\\n                int val=map.get(s.charAt(i));\\n                val=val-1;\\n                if(val==0){\\n                    map.remove(s.charAt(i));\\n                }else{\\n                    map.put(s.charAt(i),val);\\n                }\\n                \\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108020,
                "title": "aditya-verma-approach-sliding-window-with-fixed-size-window",
                "content": "# Intuition\\nSliding window with fixed size window.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0;\\n        int i=0,j=0,n=s.length(),k=3;\\n        unordered_map<char,int>mp;\\n        while(j<n){\\n            mp[s[j]]++;\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                if(mp.size()==k){\\n                    ans++;\\n                }\\n                mp[s[i]]--;\\n                if(mp[s[i]]==0){\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0;\\n        int i=0,j=0,n=s.length(),k=3;\\n        unordered_map<char,int>mp;\\n        while(j<n){\\n            mp[s[j]]++;\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                if(mp.size()==k){\\n                    ans++;\\n                }\\n                mp[s[i]]--;\\n                if(mp[s[i]]==0){\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803519,
                "title": "java-hashset-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        Set<Character> set;\\n\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            set = new HashSet<>();\\n\\n            set.add(s.charAt(i));\\n            set.add(s.charAt(i + 1));\\n            set.add(s.charAt(i + 2));\\n\\n            if (set.size() == 3) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        Set<Character> set;\\n\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            set = new HashSet<>();\\n\\n            set.add(s.charAt(i));\\n            set.add(s.charAt(i + 1));\\n            set.add(s.charAt(i + 2));\\n\\n            if (set.size() == 3) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441121,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countGoodSubstrings(string s) {\\n\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\twhile(j < n){\\n\\n\\t\\t\\t\\tif(j-i+1 == 3){\\n\\n\\t\\t\\t\\t\\tstring temp = s.substr(i, 3);\\n\\n\\t\\t\\t\\t\\tmap<int, int> mp;\\n\\t\\t\\t\\t\\tfor(auto i : temp){\\n\\t\\t\\t\\t\\t\\tmp[i]++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif(mp.size() == 3){\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countGoodSubstrings(string s) {\\n\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\twhile(j < n){\\n\\n\\t\\t\\t\\tif(j-i+1 == 3){\\n\\n\\t\\t\\t\\t\\tstring temp = s.substr(i, 3);\\n\\n\\t\\t\\t\\t\\tmap<int, int> mp;\\n\\t\\t\\t\\t\\tfor(auto i : temp){\\n\\t\\t\\t\\t\\t\\tmp[i]++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3560950,
                "title": "easiest-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n- map is of size 3 at once\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i,j,k,c=0;\\n        unordered_map<char,int>map;\\n\\n        for(i=0;i<3;i++)\\n        map[s[i]]++;\\n\\n        for(i=3;i<s.size();i++){\\n            if(map.size()==3)\\n            c++;\\n\\n            if(map[s[i-3]]>1)\\n            map[s[i-3]]--;\\n            else\\n            map.erase(s[i-3]);\\n            map[s[i]]++;\\n        }\\n\\n        if(map.size()==3)\\n            c++;\\n            \\n        return c;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i,j,k,c=0;\\n        unordered_map<char,int>map;\\n\\n        for(i=0;i<3;i++)\\n        map[s[i]]++;\\n\\n        for(i=3;i<s.size();i++){\\n            if(map.size()==3)\\n            c++;\\n\\n            if(map[s[i-3]]>1)\\n            map[s[i-3]]--;\\n            else\\n            map.erase(s[i-3]);\\n            map[s[i]]++;\\n        }\\n\\n        if(map.size()==3)\\n            c++;\\n            \\n        return c;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496933,
                "title": "c-c-javascript-very-easy-solution",
                "content": "# We have to obtain every three character and check whether one of them is the same with other one.If it is not,then we increase total number to 1;\\n\\n```javascript []\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countGoodSubstrings = function(s) {\\n    let res=0;\\n         for(let i=1;i<s.length-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;\\n};\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int res=0;\\n         for(int i=1;i<s.size()-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n      int res=0;\\n         for(int i=1;i<s.Length-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;  \\n    }\\n}\\n```\\n\\n![Vote.png](https://assets.leetcode.com/users/images/cfa28b29-b04a-43fc-8262-144616116687_1683465999.863679.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "JavaScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countGoodSubstrings = function(s) {\\n    let res=0;\\n         for(let i=1;i<s.length-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int res=0;\\n         for(int i=1;i<s.size()-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n      int res=0;\\n         for(int i=1;i<s.Length-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652821,
                "title": "sliding-window-set-o-n-time-o-1-space",
                "content": "<iframe src=\"https://leetcode.com/playground/hq4zYSic/shared\" frameBorder=\"0\" width=\"100%\" height=\"475\"></iframe>",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/hq4zYSic/shared\" frameBorder=\"0\" width=\"100%\" height=\"475\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1815788,
                "title": "python-2-lines-solution",
                "content": "**Python:**\\n\\n```\\ndef countGoodSubstrings(self, s: str) -> int:\\n\\tsubstr = [s[x:y] for x, y in itertools.combinations(range(len(s) + 1), r = 2) if len(s[x:y]) == 3 ]\\n\\treturn len([s for s in substr if len(set(s)) == len(s)])\\n```\\n\\n**Like it ? please upvote !**\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countGoodSubstrings(self, s: str) -> int:\\n\\tsubstr = [s[x:y] for x, y in itertools.combinations(range(len(s) + 1), r = 2) if len(s[x:y]) == 3 ]\\n\\treturn len([s for s in substr if len(set(s)) == len(s)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1581918,
                "title": "python-sliding-window-solution",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        k = 3\\n        if k > len(s):\\n            return 0\\n        \\n        letter_frequency = {}\\n        count, windowStart = 0, 0\\n        for windowEnd in range(len(s)):\\n            if s[windowEnd] not in letter_frequency:\\n                letter_frequency[s[windowEnd]] = 0\\n            letter_frequency[s[windowEnd]] += 1\\n            \\n            if windowEnd >= k - 1:\\n                if len(letter_frequency) == k:\\n                    count+=1\\n                letter_frequency[s[windowStart]] -= 1\\n                if letter_frequency[s[windowStart]] ==0:\\n                    del letter_frequency[s[windowStart]]\\n                windowStart += 1\\n        return count\\n                \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        k = 3\\n        if k > len(s):\\n            return 0\\n        \\n        letter_frequency = {}\\n        count, windowStart = 0, 0\\n        for windowEnd in range(len(s)):\\n            if s[windowEnd] not in letter_frequency:\\n                letter_frequency[s[windowEnd]] = 0\\n            letter_frequency[s[windowEnd]] += 1\\n            \\n            if windowEnd >= k - 1:\\n                if len(letter_frequency) == k:\\n                    count+=1\\n                letter_frequency[s[windowStart]] -= 1\\n                if letter_frequency[s[windowStart]] ==0:\\n                    del letter_frequency[s[windowStart]]\\n                windowStart += 1\\n        return count\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434368,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0,j=0,count=0;\\n        while(j<s.size()){\\n            if(j-i+1 < 3)\\n                j++;\\n            else if(j-i+1 == 3){\\n               if((s[i]!=s[i+1] && s[i]!=s[i+2]) && (s[i+1]!=s[i] && s[i+1]!=s[i+2]) && (s[i+2]!=s[i+1] && s[i+2]!=s[i])) \\n                   count++;\\n                i++;j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0,j=0,count=0;\\n        while(j<s.size()){\\n            if(j-i+1 < 3)\\n                j++;\\n            else if(j-i+1 == 3){\\n               if((s[i]!=s[i+1] && s[i]!=s[i+2]) && (s[i+1]!=s[i] && s[i+1]!=s[i+2]) && (s[i+2]!=s[i+1] && s[i+2]!=s[i])) \\n                   count++;\\n                i++;j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697724,
                "title": "beats-100-can-be-extended-to-any-number-of-characters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncalculate the no of unique characters for first k characters. traverse through the string , if removed character has freq 0 reduce unique by 1, if added character has freq 1 increment unique by 1. if unique is k increment count. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.length() <3) return 0; \\n        int count = 0; int k = 3; int u = 0; vector<int> t(26, 0); \\n        for(int i=0; i<k; i++) {t[s[i] - \\'a\\']++; if(t[s[i] - \\'a\\'] == 1) u++; }\\n        if(u == k) count++; \\n        for(int i=k; i<s.length(); i++){\\n            t[s[i-k] - \\'a\\']--;  if(t[s[i-k] - \\'a\\'] == 0) u--;   t[s[i] - \\'a\\']++; if(t[s[i] - \\'a\\'] == 1) u++; \\n            if(u == k) count++; \\n        }\\n\\n            return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.length() <3) return 0; \\n        int count = 0; int k = 3; int u = 0; vector<int> t(26, 0); \\n        for(int i=0; i<k; i++) {t[s[i] - \\'a\\']++; if(t[s[i] - \\'a\\'] == 1) u++; }\\n        if(u == k) count++; \\n        for(int i=k; i<s.length(); i++){\\n            t[s[i-k] - \\'a\\']--;  if(t[s[i-k] - \\'a\\'] == 0) u--;   t[s[i] - \\'a\\']++; if(t[s[i] - \\'a\\'] == 1) u++; \\n            if(u == k) count++; \\n        }\\n\\n            return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526377,
                "title": "java-beats-100-oms-easiest-3-liner",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int n = s.length();\\n        if(n<3) return 0;\\n        int c=0;\\n        System.out.print(s.charAt(0));\\n        for(int i =0;i<n-2;i++){\\n            if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2)){\\n                c++;\\n            }  \\n        }\\n        return c;\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int n = s.length();\\n        if(n<3) return 0;\\n        int c=0;\\n        System.out.print(s.charAt(0));\\n        for(int i =0;i<n-2;i++){\\n            if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2)){\\n                c++;\\n            }  \\n        }\\n        return c;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142344,
                "title": "python-4-lines-1-liner-beginners-friendly-solution",
                "content": "class Solution:\\n\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3: # taking a window of 3\\n                count+=1\\n        return count\\n# Python One-Liner\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\t\\n        return sum(len(set(s[i:i+3]))==3 for i in range(len(s)-2))\\n                \\n\\t\\t\\n\\t\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "class Solution:\\n\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3: # taking a window of 3\\n                count+=1\\n        return count\\n# Python One-Liner\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\t\\n        return sum(len(set(s[i:i+3]))==3 for i in range(len(s)-2))\\n                \\n\\t\\t\\n\\t\\n\\t\\t\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1813742,
                "title": "java-easy-solution-sliding-window",
                "content": "First we will find the Window. So till size we do J++.\\nAfter that we will slide it so i++ and j++. \\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int l=s.length();\\n        int i=0,j=0,k=3,count=0;\\n        while(j<l)\\n        {\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                if(s.charAt(i)!=s.charAt(j) && s.charAt(j)!=s.charAt(i+1) && s.charAt(i)!=s.charAt(i+1))             \\n                    count++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int l=s.length();\\n        int i=0,j=0,k=3,count=0;\\n        while(j<l)\\n        {\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                if(s.charAt(i)!=s.charAt(j) && s.charAt(j)!=s.charAt(i+1) && s.charAt(i)!=s.charAt(i+1))             \\n                    count++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643675,
                "title": "succinct-python-solution-o-n",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        def match(t):\\n            return len(set(t)) == 3\\n        \\n        return sum(map(match, zip(s, s[1:], s[2:])))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        def match(t):\\n            return len(set(t)) == 3\\n        \\n        return sum(map(match, zip(s, s[1:], s[2:])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436379,
                "title": "java-solution-easy-to-understand",
                "content": "```\\npublic int countGoodSubstrings(String s) {\\n        Set<Character> set = new HashSet();\\n        int count = 0;\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            String subStr = s.substring(i, i + 3);\\n            for (char ch : subStr.toCharArray()) {\\n                set.add(ch);\\n            }            \\n            if (set.size() == 3) {\\n                count++;\\n            }\\n            set.clear();\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countGoodSubstrings(String s) {\\n        Set<Character> set = new HashSet();\\n        int count = 0;\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            String subStr = s.substring(i, i + 3);\\n            for (char ch : subStr.toCharArray()) {\\n                set.add(ch);\\n            }            \\n            if (set.size() == 3) {\\n                count++;\\n            }\\n            set.clear();\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238883,
                "title": "1876-set-sliding-window",
                "content": "---\\n\\nCool, felt good use of programming language construct `Set()`\\nNOTE: This is an easy problem, so I create many `Set()`s knowingly. We could always compare 3 vals directly.\\n\\nAlgo\\n\\n- If <3 chars, we can\\'t make a good string, return 0\\n- Take 1st 3 chars, add them into `Set()`, duplicates will be deleted\\n  - After that if size is 3 then there are 3 distinct chars in this substring, increment count\\n- Delete front char, add next char - repeat above until we reach end of string\\n- Return the count\\n\\nHope it is simple to understand\\n\\n---\\n\\n    var countGoodSubstrings = function (s) {\\n        let n = s.length;\\n        if (n < 3) return 0;          // minimum 3 chars needed for good substring\\n\\n        let count = 0;\\n\\n        let A = [s[0], s[1]];\\n        for (let i = 2; i < n; i++) {\\n            A.push(s[i]);                            // add 1 char to the back\\n            if (new Set(A).size === 3) {\\n                count++;                             // if distinct, set size will be 3, if so increment counter\\n            }\\n            A.shift();                               // remove 1 char from the front\\n        }\\n\\n        return count;\\n    };\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "---\\n\\nCool, felt good use of programming language construct `Set()`\\nNOTE: This is an easy problem, so I create many `Set()`s knowingly. We could always compare 3 vals directly.\\n\\nAlgo\\n\\n- If <3 chars, we can\\'t make a good string, return 0\\n- Take 1st 3 chars, add them into `Set()`, duplicates will be deleted\\n  - After that if size is 3 then there are 3 distinct chars in this substring, increment count\\n- Delete front char, add next char - repeat above until we reach end of string\\n- Return the count\\n\\nHope it is simple to understand\\n\\n---\\n\\n    var countGoodSubstrings = function (s) {\\n        let n = s.length;\\n        if (n < 3) return 0;          // minimum 3 chars needed for good substring\\n\\n        let count = 0;\\n\\n        let A = [s[0], s[1]];\\n        for (let i = 2; i < n; i++) {\\n            A.push(s[i]);                            // add 1 char to the back\\n            if (new Set(A).size === 3) {\\n                count++;                             // if distinct, set size will be 3, if so increment counter\\n            }\\n            A.shift();                               // remove 1 char from the front\\n        }\\n\\n        return count;\\n    };\\n\\n---\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1238814,
                "title": "c-concise-and-straightforward-solution-beats-100-with-python-1-liner",
                "content": "C++ solution\\n```\\nint countGoodSubstrings(string s) \\n{\\n\\tint result=0,n=s.length();\\n\\tfor(int i=0;i<n-2;i++)\\n\\t\\tif(s[i]!=s[i+1]&&s[i]!=s[i+2]&&s[i+1]!=s[i+2]) result++;\\n\\n\\treturn result;\\n}\\n```\\nPython 1 liner:\\n```\\ndef countGoodSubstrings(self, s):\\n\\treturn sum([s[i]!=s[i+1]!=s[i+2]!=s[i] for i in range(len(s)-2)])\\n```",
                "solutionTags": [],
                "code": "```\\nint countGoodSubstrings(string s) \\n{\\n\\tint result=0,n=s.length();\\n\\tfor(int i=0;i<n-2;i++)\\n\\t\\tif(s[i]!=s[i+1]&&s[i]!=s[i+2]&&s[i+1]!=s[i+2]) result++;\\n\\n\\treturn result;\\n}\\n```\n```\\ndef countGoodSubstrings(self, s):\\n\\treturn sum([s[i]!=s[i+1]!=s[i+2]!=s[i] for i in range(len(s)-2)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4088642,
                "title": "beats-100-easiest-explanation-clean-code-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The idea is so simple.\\n- Have a window of size 3, slide it and increment count if unique elements.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count=0, n = s.size();\\n        for(int i=0; i<=n-3; i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1] != s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count=0, n = s.size();\\n        for(int i=0; i<=n-3; i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1] != s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930431,
                "title": "slliding-window-o-n-t-c-proper-intuition-explained",
                "content": "# Intuition\\u2705\\nThis Easy question is good.I have solved this question using sliding window O(N) solution. i have used map to store frequency of each window. here window size will be 3 becaue we have to find good substrings of length three.\\n\\n# Approach\\u2705\\u2705\\n1. we will insert element till we hit window size 3. \\n2. After complete 3 size window, we will check all three character of particular window is **unique or not**.\\n3. if we find **all three character unique in window**( **if(mp.size() == 3)**)then increase cnt.\\n\\n4. Now we will slide window to right side for further investigation in right sides all window.\\n5. Important point is, before slide window we will decrease frequency of **s[i]** element in map. then we do i++.\\n6. [ ****if(mp[s[i]] == 0) mp.erase(s[i])**** ]  if we find any mapping of character equal to 0 then we have to erase that key from map other wise map keep it as size 1 . whenever we check condition for **(mp.size() == 3)** it increase size by 1 , which will be wrong.\\n\\n# Complexity\\n- Time complexity:\\n   O(N)\\n\\n- Space complexity:\\n\\n  O(N)\\n              \\n     ****\\uD83D\\uDE80\\uD83D\\uDE80Kindly upvote if you find helpful\\uD83D\\uDE80\\uD83D\\uDE80****\\n\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n = s.size();\\n        unordered_map<char,int>mp;\\n        int i = 0, j=0;\\n        int cnt=0;\\n        while(j<n){\\n            mp[s[j]]++;\\n            if((j-i+1) < 3) j++;\\n           else{\\n               if(mp.size() == 3){\\n                   cnt++;\\n               }\\n               mp[s[i]]--;\\n               if(mp[s[i]] == 0) mp.erase(s[i]);\\n               i++;\\n               j++;\\n           }   \\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n = s.size();\\n        unordered_map<char,int>mp;\\n        int i = 0, j=0;\\n        int cnt=0;\\n        while(j<n){\\n            mp[s[j]]++;\\n            if((j-i+1) < 3) j++;\\n           else{\\n               if(mp.size() == 3){\\n                   cnt++;\\n               }\\n               mp[s[i]]--;\\n               if(mp[s[i]] == 0) mp.erase(s[i]);\\n               i++;\\n               j++;\\n           }   \\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106591,
                "title": "c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0, j=0;\\n        int cnt=0;\\n        \\n        unordered_map<char,int> mpp;\\n        while(j< s.size()) {\\n            mpp[s[j]]++;\\n            \\n            if(j-i+1==3) {\\n                if(mpp.size()==3) cnt++;\\n                 mpp[s[i]]--;\\n                if(mpp[s[i]]==0) mpp.erase(s[i]);\\n                i++;\\n            }\\n        j++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0, j=0;\\n        int cnt=0;\\n        \\n        unordered_map<char,int> mpp;\\n        while(j< s.size()) {\\n            mpp[s[j]]++;\\n            \\n            if(j-i+1==3) {\\n                if(mpp.size()==3) cnt++;\\n                 mpp[s[i]]--;\\n                if(mpp[s[i]]==0) mpp.erase(s[i]);\\n                i++;\\n            }\\n        j++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070161,
                "title": "idiomatic-kotlin",
                "content": "# Explanation\\nDivide the input by a substrings of three (by default increments of 1). Obtained substrings of size are still the same size after they are added to a set, we can conclude that the characters are unique\\n# Code\\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        return s.windowed(3).count { it.toSet().size == 3}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        return s.windowed(3).count { it.toSet().size == 3}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053190,
                "title": "c-o-n-solution-beats-100-o-1-space",
                "content": "\\n\\n# Approach : Sliding Window\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i = 0;\\n        int count = 0;\\n        unordered_map<char, int> ump;\\n        for(int j=0;j<s.size();j++) {\\n            ump[s[j]]++;\\n            if(j - i + 1 == 3) {\\n                if(ump.size() == 3) count++;\\n                ump[s[i]]--;\\n                if(ump[s[i]] == 0) ump.erase(s[i]);\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i = 0;\\n        int count = 0;\\n        unordered_map<char, int> ump;\\n        for(int j=0;j<s.size();j++) {\\n            ump[s[j]]++;\\n            if(j - i + 1 == 3) {\\n                if(ump.size() == 3) count++;\\n                ump[s[i]]--;\\n                if(ump[s[i]] == 0) ump.erase(s[i]);\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810964,
                "title": "python-sliding-window-95-01-faster-5-lines",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        c,n=0,len(s)\\n        for i in range(n-2):\\n            t=set(s[i:i+3])\\n            if len(t)==3:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        c,n=0,len(s)\\n        for i in range(n-2):\\n            t=set(s[i:i+3])\\n            if len(t)==3:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677301,
                "title": "java-simple-sol-o-n",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int count=0;\\n\\n        for(int i=0;i<s.length()-2;i++){\\n\\n            char x=s.charAt(i);\\n            char y=s.charAt(i+1);\\n            char z=s.charAt(i+2);\\n\\n            if(x!=y && y!=z && z!=x) count++;\\n\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int count=0;\\n\\n        for(int i=0;i<s.length()-2;i++){\\n\\n            char x=s.charAt(i);\\n            char y=s.charAt(i+1);\\n            char z=s.charAt(i+2);\\n\\n            if(x!=y && y!=z && z!=x) count++;\\n\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664924,
                "title": "java-easy-solution-single-if-beginner-friendly",
                "content": "class Solution {\\n    public int countGoodSubstrings(String s) \\n    {\\n        //String res = s.substring(0,3);\\n        int c=0;\\n        \\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n                String res = s.substring(i,i+3);\\n                if(res.charAt(0)!=res.charAt(1) && res.charAt(1)!=res.charAt(2)&& res.charAt(0)!=res.charAt(2))\\n                    c++;\\n        }    \\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countGoodSubstrings(String s) \\n    {\\n        //String res = s.substring(0,3);\\n        int c=0;\\n        \\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n                String res = s.substring(i,i+3);\\n                if(res.charAt(0)!=res.charAt(1) && res.charAt(1)!=res.charAt(2)&& res.charAt(0)!=res.charAt(2))\\n                    c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2408328,
                "title": "c-solution-using-2-approaches",
                "content": "Approach 1 : This is basically a brute force, which gets accepted here for this question as the s.size() can be 100 at max and size of window is 3.\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0; //store count of GOOD (unique) substrings\\n        for(int i=1; i<s.size()-1; i++)\\n        {\\n            if(s[i]!=s[i+1] && s[i-1]!=s[i] && s[i-1]!=s[i+1]) //check whether the letter at s[i] is equal to its previous and next letter\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nApproach 2 : Classic Sliding Window (thanks to @sk58 for helping me in better understanding of this approach)\\nFor greater window sizes and greater length of string, we can use sliding window.\\nIntuition (how to check, if we can use sliding window here???) (NOTE : This is for general questions)\\n1. The data structure mentioned will be array/string.\\n2. The question asks for maximum or minimum of something, maybe count, sums or uniqueness; as we have here in the question.\\n3. The size of the window is mentioned in the question, here it is 3.\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0;  //stores the count of GOOD substrings\\n        int i=0, j=0; //initialize i as starting position of window & j as ending position of the window\\n        int n = s.size();\\n        unordered_map<char, int>freq; //to map the characters in the string to their frequency\\n        while(i<n && j<n)\\n        {\\n            freq[s[j]]++; //to get the count of characters\\n            if(j-i+1 < 3) // if we haven\\'t reached to the required size of window, just increment ending position\\n                j++;\\n            else if(freq.size()==3) //this means, we have reached the required window size along with GOOD substring\\n            {\\n                ans++;\\n                freq.erase(s[i]); //erase the character&its count, so that we can move forward with the window\\n                i++; //increment starting position\\n                j++; //increment ending position\\n\\t\\t\\t\\t//this maintains the size of the window\\n            }\\n            else // if the size of the freq != 3, this means there\\'s a repetition of characters, though the window size is still 3\\n            {\\n                freq[s[i]]--; //decrement the count of the character as we will be shifting the window\\n                if(freq[s[i]]==0)\\n                    freq.erase(s[i]); //just remove the entry of the character, as it is not needed\\n                i++;\\n                j++;\\n\\t\\t\\t\\t//increment the positions to shift the window\\n            } \\n        }       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0; //store count of GOOD (unique) substrings\\n        for(int i=1; i<s.size()-1; i++)\\n        {\\n            if(s[i]!=s[i+1] && s[i-1]!=s[i] && s[i-1]!=s[i+1]) //check whether the letter at s[i] is equal to its previous and next letter\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0;  //stores the count of GOOD substrings\\n        int i=0, j=0; //initialize i as starting position of window & j as ending position of the window\\n        int n = s.size();\\n        unordered_map<char, int>freq; //to map the characters in the string to their frequency\\n        while(i<n && j<n)\\n        {\\n            freq[s[j]]++; //to get the count of characters\\n            if(j-i+1 < 3) // if we haven\\'t reached to the required size of window, just increment ending position\\n                j++;\\n            else if(freq.size()==3) //this means, we have reached the required window size along with GOOD substring\\n            {\\n                ans++;\\n                freq.erase(s[i]); //erase the character&its count, so that we can move forward with the window\\n                i++; //increment starting position\\n                j++; //increment ending position\\n\\t\\t\\t\\t//this maintains the size of the window\\n            }\\n            else // if the size of the freq != 3, this means there\\'s a repetition of characters, though the window size is still 3\\n            {\\n                freq[s[i]]--; //decrement the count of the character as we will be shifting the window\\n                if(freq[s[i]]==0)\\n                    freq.erase(s[i]); //just remove the entry of the character, as it is not needed\\n                i++;\\n                j++;\\n\\t\\t\\t\\t//increment the positions to shift the window\\n            } \\n        }       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801123,
                "title": "easy-solution-0ms-solution",
                "content": "class Solution {\\npublic:\\n\\n    int countGoodSubstrings(string s) {\\n        int i=0;\\n        int j=1;\\n        int k=2;\\n        int count=0;\\n        while(k<s.size()){\\n            if(s[i]!=s[j] and s[j]!=s[k] and s[i]!=s[k]){\\n                count++;\\n                // i++;j++;k++;\\n            }\\n            i+=1;\\n            j+=1;\\n            k+=1;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countGoodSubstrings(string s) {\\n        int i=0;\\n        int j=1;\\n        int k=2;\\n        int count=0;\\n        while(k<s.size()){\\n            if(s[i]!=s[j] and s[j]!=s[k] and s[i]!=s[k]){\\n                count++;\\n                // i++;j++;k++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1797917,
                "title": "java-time-o-n-space-o-n-for-all-windows-size-substrings-of-length",
                "content": "I think it\\'s easy to solve the length three problem just using three variables for monitoring. However, how about the problem becomes checking length four or even a hundred lengths? \\n\\nI wrote an answer that only modifies the size of the window, but works with different lengths.\\n\\n```\\nclass Solution {\\n  /**\\n   * Time O(n)\\n   * Space O(n)\\n   */\\n  public int countGoodSubstrings(String s) {\\n    int sum = 0;\\n    int window = 3;\\n    // Space O(n)\\n    Map<Character, Integer> map = new HashMap<>();\\n    // Space O(n)\\n    Set<Character> dup = new HashSet<>();\\n    // Time O(n)\\n    for (int i = 0; i < s.length(); i++) {\\n      // Time O(1)\\n      int count = map.getOrDefault(s.charAt(i), 0);\\n      count++;\\n      // Time O(1)\\n      map.put(s.charAt(i), count);\\n      // Time O(1)\\n      if (count > 1 && !dup.contains(s.charAt(i))) {\\n        // Time O(1)\\n        dup.add(s.charAt(i));\\n      }\\n      if (i > (window - 1)) {\\n        // Time O(1)\\n        count = map.get(s.charAt(i - window)) - 1;\\n        // Time O(1)\\n        map.put(s.charAt(i - window), count);\\n        if (count < (window - 1)) {\\n          // Time O(1)\\n          dup.remove(s.charAt(i - window));\\n        }\\n      }\\n      // Time O(1)\\n      if (i > (window - 2) && dup.isEmpty()) {\\n        sum++;\\n      }\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  /**\\n   * Time O(n)\\n   * Space O(n)\\n   */\\n  public int countGoodSubstrings(String s) {\\n    int sum = 0;\\n    int window = 3;\\n    // Space O(n)\\n    Map<Character, Integer> map = new HashMap<>();\\n    // Space O(n)\\n    Set<Character> dup = new HashSet<>();\\n    // Time O(n)\\n    for (int i = 0; i < s.length(); i++) {\\n      // Time O(1)\\n      int count = map.getOrDefault(s.charAt(i), 0);\\n      count++;\\n      // Time O(1)\\n      map.put(s.charAt(i), count);\\n      // Time O(1)\\n      if (count > 1 && !dup.contains(s.charAt(i))) {\\n        // Time O(1)\\n        dup.add(s.charAt(i));\\n      }\\n      if (i > (window - 1)) {\\n        // Time O(1)\\n        count = map.get(s.charAt(i - window)) - 1;\\n        // Time O(1)\\n        map.put(s.charAt(i - window), count);\\n        if (count < (window - 1)) {\\n          // Time O(1)\\n          dup.remove(s.charAt(i - window));\\n        }\\n      }\\n      // Time O(1)\\n      if (i > (window - 2) && dup.isEmpty()) {\\n        sum++;\\n      }\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485706,
                "title": "c-100-faster",
                "content": "```\\nint countGoodSubstrings(string s) {\\n      if(s.size() < 3) return 0;\\n      int i=0, j=0, counter=0, ans=0;\\n      vector<int> map(128, 0);\\n\\t  \\n      while(j < s.size())\\n      {\\n        if(j-i+1 <= 3) {if(map[s[j++]]++ == 0) counter++;}\\n        else {\\n          if(counter == 3) ans++;\\n          if(map[s[i++]]-- == 1) counter--;\\n        }\\n        if(counter == 3 && j == s.size()) ans++;\\n      }\\n      return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint countGoodSubstrings(string s) {\\n      if(s.size() < 3) return 0;\\n      int i=0, j=0, counter=0, ans=0;\\n      vector<int> map(128, 0);\\n\\t  \\n      while(j < s.size())\\n      {\\n        if(j-i+1 <= 3) {if(map[s[j++]]++ == 0) counter++;}\\n        else {\\n          if(counter == 3) ans++;\\n          if(map[s[i++]]-- == 1) counter--;\\n        }\\n        if(counter == 3 && j == s.size()) ans++;\\n      }\\n      return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1299772,
                "title": "easy-java-solution-100-fast",
                "content": "```\\n/* check every substring of size 3, if all the letters in the substring are distinct, increment the count of good strings*/\\n public int countGoodSubstrings(String s) {\\n        int count=0;\\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n            char ch1=s.charAt(i);\\n            char ch2=s.charAt(i+1);\\n            char ch3=s.charAt(i+2);\\n            if(ch1!=ch2 && ch2!=ch3 && ch1!=ch3)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* check every substring of size 3, if all the letters in the substring are distinct, increment the count of good strings*/\\n public int countGoodSubstrings(String s) {\\n        int count=0;\\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n            char ch1=s.charAt(i);\\n            char ch2=s.charAt(i+1);\\n            char ch3=s.charAt(i+2);\\n            if(ch1!=ch2 && ch2!=ch3 && ch1!=ch3)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1285693,
                "title": "c-solution-100-faster",
                "content": "```\\nint countGoodSubstrings(string s) {\\n        int i=0;\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count = 0;\\n        while(i<s.size()-2){\\n            if(s[i]!=s[i+1]&&s[i+1]!=s[i+2]&&s[i+2]!=s[i]){\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint countGoodSubstrings(string s) {\\n        int i=0;\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count = 0;\\n        while(i<s.size()-2){\\n            if(s[i]!=s[i+1]&&s[i+1]!=s[i+2]&&s[i+2]!=s[i]){\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238901,
                "title": "easy-sliding-window-approach-in-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int countGoodSubstrings(string s) \\n    {\\n        int n=s.length();\\n        if(n<3)\\n        {\\n            return 0;\\n        }\\n        unordered_map<char,int>m;\\n        for(int i=0;i<3;i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        int i=0,j=2,sum=0;\\n        while(j<n)\\n        {\\n            if(m.size()==3)\\n            {\\n                sum++;\\n            }\\n            if(m[s[i]]==1)\\n            {\\n                m.erase(s[i]);\\n            }\\n            else\\n            {\\n                m[s[i]]--;\\n            }\\n            m[s[j+1]]++;\\n            i++;\\n            j++;   \\n        }\\n        return sum;\\n    }\\n};\\n```\\n**Please upvote if you have got any help from my code. Thank you.**",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countGoodSubstrings(string s) \\n    {\\n        int n=s.length();\\n        if(n<3)\\n        {\\n            return 0;\\n        }\\n        unordered_map<char,int>m;\\n        for(int i=0;i<3;i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        int i=0,j=2,sum=0;\\n        while(j<n)\\n        {\\n            if(m.size()==3)\\n            {\\n                sum++;\\n            }\\n            if(m[s[i]]==1)\\n            {\\n                m.erase(s[i]);\\n            }\\n            else\\n            {\\n                m[s[i]]--;\\n            }\\n            m[s[j+1]]++;\\n            i++;\\n            j++;   \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238768,
                "title": "java-easy-solution",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String str) {\\n        int count = 0;\\n        int counter;\\n        String s = \"\";\\n        for(int i = 0; i <= str.length() - 3; i++){\\n            Set<Character> set = new HashSet<Character>();\\n            s = str.substring(i, i + 3);\\n            counter = 0;\\n            for(char c : s.toCharArray()){\\n                if(set.add(c))\\n                    counter++;\\n                else\\n                    break;\\n            }\\n            if(counter == 3){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String str) {\\n        int count = 0;\\n        int counter;\\n        String s = \"\";\\n        for(int i = 0; i <= str.length() - 3; i++){\\n            Set<Character> set = new HashSet<Character>();\\n            s = str.substring(i, i + 3);\\n            counter = 0;\\n            for(char c : s.toCharArray()){\\n                if(set.add(c))\\n                    counter++;\\n                else\\n                    break;\\n            }\\n            if(counter == 3){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238638,
                "title": "a-few-solutions",
                "content": "**Brute-Force (Functional)**\\n\\nConsider each substring `t` of length `3` of the input string `s`.  Note: `t` is implied as the substring `s[i..i+3)` (ie. from `i` inclusive to `i + 3` non-inclusive).\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var countGoodSubstrings = { s: String -> s.toList().mapIndexed{ i, _ -> if (i + 3 <= s.length && s.substring(i, i + 3).toSet().size == 3) 1 else 0 }!!.sum() }\\n}\\n```\\n\\n*Javascript (note: `t` is the accumulator, ie. `t` is the total sum reduced thus far)*\\n```\\nlet countGoodSubstrings = s => s.split(\\'\\').reduce((t, _, i) => i + 3 <= s.length && new Set(s.substring(i, i + 3).split(\\'\\')).size == 3 ? 1 + t : t, 0);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        return sum(1 if i + 3 <= len(s) and len(set(list(s[i:i + 3]))) == 3 else 0 for i in range(len(s)))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        return count_if(s.begin(), s.end(), [i = -1, &s](auto _) mutable {\\n            ++i;\\n            if (s.size() < i + 3)\\n                return false;\\n            auto t = s.substr(i, 3);\\n            return Set{ t.begin(), t.end() }.size() == 3;\\n        });\\n    }\\n};\\n```\\n\\n---\\n\\n**Brute-Force (Procedural)**\\n\\nConsider each substring `t` of length `3` of the input string `s`.\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        for (i in 0 until s.length - 3 + 1)\\n            if (s.substring(i, i + 3).toSet().size == 3)\\n                ++cnt\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countGoodSubstrings = (s, cnt = 0) => {\\n    for (let i = 0; i + 3 <= s.length; ++i) {\\n        let t = s.substring(i, i + 3);\\n        cnt += new Set(t).size == 3;\\n    }\\n    return cnt;\\n}\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        for i in range(0, N - 3 + 1):\\n            t = s[i:i + 3]\\n            cnt += len(set(t)) == 3\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        int N = s.size();\\n        for (auto i{ 0 }; i + 3 <= N; ++i) {\\n            auto t = s.substr(i, 3);\\n            cnt += Set{ t.begin(), t.end() }.size() == 3;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n---\\n\\n**\\uD83D\\uDC48 Sliding Window ( a, b, c )**\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        var N = s.length\\n        if (N < 3)\\n            return 0\\n        var a = s[0]\\n        var b = s[1]\\n        var c = \\'*\\'\\n        for (i in 2 until N) {\\n            c = s[i]\\n            if (a != b && b != c && a != c)  // \\uD83C\\uDFAF 3 unique values\\n                ++cnt\\n            a = b; b = c                     // \\uD83D\\uDC48 slide window\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countGoodSubstrings = (s, cnt = 0) => {\\n    let N = s.length;\\n    if (N < 3)\\n        return 0;\\n    let a = s[0],\\n        b = s[1],\\n        c = \\'\\\\0\\';\\n    for (let i = 2; i < N; ++i) {\\n        c = s[i];\\n        cnt += a != b && b != c && a != c;  // \\uD83C\\uDFAF 3 unique values\\n        a = b, b = c;                       // \\uD83D\\uDC48 slide window\\n    }\\n    return cnt;\\n}\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        if N < 3:\\n            return 0\\n        a = s[0]\\n        b = s[1]\\n        c = \\'\\\\0\\'\\n        for i in range(2, N):\\n            c = s[i]; i += 1\\n            cnt += a != b and b != c and a != c  # \\uD83C\\uDFAF 3 unique values\\n            a = b; b = c                         # \\uD83D\\uDC48 slide window\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        int N = s.size();\\n        if (N < 3)\\n            return 0;\\n        auto a = s[0],\\n             b = s[1],\\n             c = \\'\\\\0\\';\\n        for (auto i{ 2 }; i < N; ++i) {\\n            c = s[i];\\n            cnt += c != b && b != a && c != a;  // \\uD83C\\uDFAF 3 unique values\\n            a = b, b = c;                       // \\uD83D\\uDC48 slide window\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n---\\n\\n**\\uD83D\\uDC49 Sliding Window [ i = j -2 .. i ] + \\uD83D\\uDDFA Map**\\n\\nUse a map `m` to track the count of each character in the window of size `3`.  Return the count `cnt` of unique substrings of length `3`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        var m = mutableMapOf<Char, Int>()\\n        var N = s.length\\n        var j = 0\\n        while (j < 2 && j < N) {\\n            m[s[j]] = 1 + m.getOrDefault(s[j], 0)\\n            ++j\\n        }\\n        while (j < N) {\\n            m[s[j]] = 1 + m.getOrDefault(s[j], 0)\\n            if (m.size == 3)\\n                ++cnt\\n            m[s[j - 2]] = -1 + m[s[j - 2]]!!\\n            if (m[s[j - 2]]!! == 0)\\n                m.remove(s[j - 2])\\n            ++j\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countGoodSubstrings = (s, m = new Map(), cnt = 0) => {\\n    let N = s.length,\\n        j = 0;\\n    while (j < 2) {\\n        m.set(s[j], 1 + (m.get(s[j]) || 0));\\n        ++j;\\n    }\\n    while (j < N) {\\n        m.set(s[j], 1 + (m.get(s[j]) || 0));\\n        cnt += m.size == 3;\\n        if (!m.set(s[j - 2], -1 + m.get(s[j - 2])).get(s[j - 2]))\\n            m.delete(s[j - 2]);\\n        ++j;\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        j = 2\\n        m = Counter(c for c in s[:2])\\n        while j < N:\\n            m[s[j]] = 1 + (m[s[j]] if s[j] in m else 0)\\n            if len(m) == 3:\\n                cnt += 1\\n            m[s[j - 2]] -= 1\\n            if m[s[j - 2]] == 0:\\n                del m[s[j - 2]]\\n            j += 1\\n        return cnt\\n```\\n        \\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    int countGoodSubstrings(string s, Map m = {}, int cnt = 0) {\\n        int N = s.size(),\\n            j = 0;\\n        while (j < min(2, N))\\n            ++m[s[j++]];\\n        while (j < N) {\\n            ++m[s[j]];\\n            cnt += m.size() == 3;\\n            if (!--m[s[j - 2]])\\n                m.erase(s[j - 2]);\\n            ++j;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n---",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var countGoodSubstrings = { s: String -> s.toList().mapIndexed{ i, _ -> if (i + 3 <= s.length && s.substring(i, i + 3).toSet().size == 3) 1 else 0 }!!.sum() }\\n}\\n```\n```\\nlet countGoodSubstrings = s => s.split(\\'\\').reduce((t, _, i) => i + 3 <= s.length && new Set(s.substring(i, i + 3).split(\\'\\')).size == 3 ? 1 + t : t, 0);\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        return sum(1 if i + 3 <= len(s) and len(set(list(s[i:i + 3]))) == 3 else 0 for i in range(len(s)))\\n```\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        return count_if(s.begin(), s.end(), [i = -1, &s](auto _) mutable {\\n            ++i;\\n            if (s.size() < i + 3)\\n                return false;\\n            auto t = s.substr(i, 3);\\n            return Set{ t.begin(), t.end() }.size() == 3;\\n        });\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        for (i in 0 until s.length - 3 + 1)\\n            if (s.substring(i, i + 3).toSet().size == 3)\\n                ++cnt\\n        return cnt\\n    }\\n}\\n```\n```\\nlet countGoodSubstrings = (s, cnt = 0) => {\\n    for (let i = 0; i + 3 <= s.length; ++i) {\\n        let t = s.substring(i, i + 3);\\n        cnt += new Set(t).size == 3;\\n    }\\n    return cnt;\\n}\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        for i in range(0, N - 3 + 1):\\n            t = s[i:i + 3]\\n            cnt += len(set(t)) == 3\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        int N = s.size();\\n        for (auto i{ 0 }; i + 3 <= N; ++i) {\\n            auto t = s.substr(i, 3);\\n            cnt += Set{ t.begin(), t.end() }.size() == 3;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        var N = s.length\\n        if (N < 3)\\n            return 0\\n        var a = s[0]\\n        var b = s[1]\\n        var c = \\'*\\'\\n        for (i in 2 until N) {\\n            c = s[i]\\n            if (a != b && b != c && a != c)  // \\uD83C\\uDFAF 3 unique values\\n                ++cnt\\n            a = b; b = c                     // \\uD83D\\uDC48 slide window\\n        }\\n        return cnt;\\n    }\\n}\\n```\n```\\nlet countGoodSubstrings = (s, cnt = 0) => {\\n    let N = s.length;\\n    if (N < 3)\\n        return 0;\\n    let a = s[0],\\n        b = s[1],\\n        c = \\'\\\\0\\';\\n    for (let i = 2; i < N; ++i) {\\n        c = s[i];\\n        cnt += a != b && b != c && a != c;  // \\uD83C\\uDFAF 3 unique values\\n        a = b, b = c;                       // \\uD83D\\uDC48 slide window\\n    }\\n    return cnt;\\n}\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        if N < 3:\\n            return 0\\n        a = s[0]\\n        b = s[1]\\n        c = \\'\\\\0\\'\\n        for i in range(2, N):\\n            c = s[i]; i += 1\\n            cnt += a != b and b != c and a != c  # \\uD83C\\uDFAF 3 unique values\\n            a = b; b = c                         # \\uD83D\\uDC48 slide window\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        int N = s.size();\\n        if (N < 3)\\n            return 0;\\n        auto a = s[0],\\n             b = s[1],\\n             c = \\'\\\\0\\';\\n        for (auto i{ 2 }; i < N; ++i) {\\n            c = s[i];\\n            cnt += c != b && b != a && c != a;  // \\uD83C\\uDFAF 3 unique values\\n            a = b, b = c;                       // \\uD83D\\uDC48 slide window\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        var m = mutableMapOf<Char, Int>()\\n        var N = s.length\\n        var j = 0\\n        while (j < 2 && j < N) {\\n            m[s[j]] = 1 + m.getOrDefault(s[j], 0)\\n            ++j\\n        }\\n        while (j < N) {\\n            m[s[j]] = 1 + m.getOrDefault(s[j], 0)\\n            if (m.size == 3)\\n                ++cnt\\n            m[s[j - 2]] = -1 + m[s[j - 2]]!!\\n            if (m[s[j - 2]]!! == 0)\\n                m.remove(s[j - 2])\\n            ++j\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet countGoodSubstrings = (s, m = new Map(), cnt = 0) => {\\n    let N = s.length,\\n        j = 0;\\n    while (j < 2) {\\n        m.set(s[j], 1 + (m.get(s[j]) || 0));\\n        ++j;\\n    }\\n    while (j < N) {\\n        m.set(s[j], 1 + (m.get(s[j]) || 0));\\n        cnt += m.size == 3;\\n        if (!m.set(s[j - 2], -1 + m.get(s[j - 2])).get(s[j - 2]))\\n            m.delete(s[j - 2]);\\n        ++j;\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        j = 2\\n        m = Counter(c for c in s[:2])\\n        while j < N:\\n            m[s[j]] = 1 + (m[s[j]] if s[j] in m else 0)\\n            if len(m) == 3:\\n                cnt += 1\\n            m[s[j - 2]] -= 1\\n            if m[s[j - 2]] == 0:\\n                del m[s[j - 2]]\\n            j += 1\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    int countGoodSubstrings(string s, Map m = {}, int cnt = 0) {\\n        int N = s.size(),\\n            j = 0;\\n        while (j < min(2, N))\\n            ++m[s[j++]];\\n        while (j < N) {\\n            ++m[s[j]];\\n            cnt += m.size() == 3;\\n            if (!--m[s[j - 2]])\\n                m.erase(s[j - 2]);\\n            ++j;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241425,
                "title": "unpredicted-logic-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:(i+3)]))==3:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:(i+3)]))==3:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240610,
                "title": "simple-and-easy-code-to-understand-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Consider upvoting if found helpful\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            x=s[i:i+3]\\n            if x.count(x[0])==1 and x.count(x[1])==1 and x.count(x[2])==1:\\n                count+=1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            x=s[i:i+3]\\n            if x.count(x[0])==1 and x.count(x[1])==1 and x.count(x[2])==1:\\n                count+=1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585357,
                "title": "sliding-window-python3-easy-undersatnding",
                "content": "This problem can be easily solved using Sliding Window pattern\\n\\n*Time: O(n)\\nSpace: O(1)*\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        windowStart = 0\\n        \\n        c = 0\\n        \\n\\t\\t# O(n)\\n        for windowEnd in range(len(s)):\\n            \\n            if windowEnd - windowStart + 1 == 3:\\n                \\n                valid = True\\n                \\n\\t\\t\\t\\t# Stores at most 3 letters => O(1) \\n                vis = {}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Runs for 3 times at most => O(1) \\n                for i in range(windowStart, windowEnd+1):\\n                    \\n                    if s[i] not in vis:\\n                        vis[s[i]] = 1\\n                    else:\\n                        valid = False\\n                        break\\n                \\n                if valid:\\n                    c += 1\\n                \\n                windowStart += 1\\n        \\n        return c\\n                \\n  \\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        windowStart = 0\\n        \\n        c = 0\\n        \\n\\t\\t# O(n)\\n        for windowEnd in range(len(s)):\\n            \\n            if windowEnd - windowStart + 1 == 3:\\n                \\n                valid = True\\n                \\n\\t\\t\\t\\t# Stores at most 3 letters => O(1) \\n                vis = {}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Runs for 3 times at most => O(1) \\n                for i in range(windowStart, windowEnd+1):\\n                    \\n                    if s[i] not in vis:\\n                        vis[s[i]] = 1\\n                    else:\\n                        valid = False\\n                        break\\n                \\n                if valid:\\n                    c += 1\\n                \\n                windowStart += 1\\n        \\n        return c\\n                \\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464237,
                "title": "go-solution",
                "content": "```\\nfunc countGoodSubstrings(s string) int {\\n    charSet, count, left := make([]byte, 26), 0, 0\\n    \\n    for right := 0; right < len(s); right++ {\\n        charSet[s[right] - \\'a\\']++\\n        \\n        for right - left + 1 > 3 {\\n            charSet[s[left] - \\'a\\']--\\n            left++\\n        }\\n        \\n        if right-left+1 == 3 {\\n            charCount := 0\\n            \\n            for i := 0; i < 26; i++ {\\n                if charSet[i] > 0 {\\n                    charCount++\\n                }    \\n            }\\n            \\n            if charCount == 3 {\\n                count++\\n            }\\n        }\\n    }\\n    \\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countGoodSubstrings(s string) int {\\n    charSet, count, left := make([]byte, 26), 0, 0\\n    \\n    for right := 0; right < len(s); right++ {\\n        charSet[s[right] - \\'a\\']++\\n        \\n        for right - left + 1 > 3 {\\n            charSet[s[left] - \\'a\\']--\\n            left++\\n        }\\n        \\n        if right-left+1 == 3 {\\n            charCount := 0\\n            \\n            for i := 0; i < 26; i++ {\\n                if charSet[i] > 0 {\\n                    charCount++\\n                }    \\n            }\\n            \\n            if charCount == 3 {\\n                count++\\n            }\\n        }\\n    }\\n    \\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2077347,
                "title": "js-sliding-window-solution-with-explanation",
                "content": "## Explanation\\n\\nPhase one: setup pointers to left and right of sliding window\\n```\\n// index           0 1 2 3 4 5 \\n//                 a b c b c a\\n// step 1:         ^              // map{a: 1},             left: 0, right: 0\\n// step 2:         ^ ^            // map{a: 1, b: 1},       left: 0, right: 1\\n// step 3:         ^   ^          // map{a: 1, b: 1, c: 1}, left: 0, right: 2\\n```\\nOn each step: we store characters to map (key: character; value: frequency).\\n\\nPhase two: moving sliding window until right pointer has reached the end of string.\\n```\\n// index           0 1 2 3 4 5\\n//                 a b c b c a\\n// step 4:           ^   ^            // map{b: 2, c: 1},  left: 1, right: 3\\n// step 5:             ^   ^          // map{b: 1, c: 2},  left: 2, right: 4\\n// etc\\u2026\\n```\\nOn each step:\\n 1) check size of map: if its equal windowSize then answer is updated.\\n 2) drop old left character from map\\n 3) add new right character to map\\n 4) move pointers of left and right of sliding window.\\n\\n\\n## Code:\\n```\\nvar countGoodSubstrings = function(s) {\\n    const lookup = new Map();\\n    const windowSize = 3;\\n    \\n    let answer = 0;\\n    let left = 0;\\n    let right = 0;\\n    \\n    while(right < s.length) {\\n        const rightChar = s[right];\\n        const val = lookup.get(rightChar) || 0;\\n        \\n        lookup.set(rightChar, val + 1);\\n        \\n        if (right - left + 1 < windowSize) {\\n            right += 1;\\n            \\n            continue;\\n        }\\n        \\n        if (lookup.size === windowSize) answer += 1;\\n        \\n        // update map\\n        const leftChar = s[left];\\n        lookup.set(leftChar, lookup.get(leftChar) - 1);\\n        if (lookup.get(leftChar) === 0) {\\n            lookup.delete(leftChar);\\n        }\\n        \\n        // move window\\n        left += 1;\\n        right += 1;\\n    }\\n    \\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n// index           0 1 2 3 4 5 \\n//                 a b c b c a\\n// step 1:         ^              // map{a: 1},             left: 0, right: 0\\n// step 2:         ^ ^            // map{a: 1, b: 1},       left: 0, right: 1\\n// step 3:         ^   ^          // map{a: 1, b: 1, c: 1}, left: 0, right: 2\\n```\n```\\n// index           0 1 2 3 4 5\\n//                 a b c b c a\\n// step 4:           ^   ^            // map{b: 2, c: 1},  left: 1, right: 3\\n// step 5:             ^   ^          // map{b: 1, c: 2},  left: 2, right: 4\\n// etc\\u2026\\n```\n```\\nvar countGoodSubstrings = function(s) {\\n    const lookup = new Map();\\n    const windowSize = 3;\\n    \\n    let answer = 0;\\n    let left = 0;\\n    let right = 0;\\n    \\n    while(right < s.length) {\\n        const rightChar = s[right];\\n        const val = lookup.get(rightChar) || 0;\\n        \\n        lookup.set(rightChar, val + 1);\\n        \\n        if (right - left + 1 < windowSize) {\\n            right += 1;\\n            \\n            continue;\\n        }\\n        \\n        if (lookup.size === windowSize) answer += 1;\\n        \\n        // update map\\n        const leftChar = s[left];\\n        lookup.set(leftChar, lookup.get(leftChar) - 1);\\n        if (lookup.get(leftChar) === 0) {\\n            lookup.delete(leftChar);\\n        }\\n        \\n        // move window\\n        left += 1;\\n        right += 1;\\n    }\\n    \\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1971665,
                "title": "easy-o-n-js-solution",
                "content": "var countGoodSubstrings = function(s) {\\n    let total = 0;\\n    let setArr;\\n    for(let i=0; i<=s.length - 3; i++){\\n        setArr = new Set(s.slice(i, i+3));\\n        \\n        if(setArr.size === 3){\\n            total++;\\n        }\\n    }\\n    \\n    return total;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var countGoodSubstrings = function(s) {\\n    let total = 0;\\n    let setArr;\\n    for(let i=0; i<=s.length - 3; i++){\\n        setArr = new Set(s.slice(i, i+3));\\n        \\n        if(setArr.size === 3){\\n            total++;\\n        }\\n    }\\n    \\n    return total;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1755929,
                "title": "java-o-n-solution",
                "content": "```\\npublic int countGoodSubstrings(String s) {\\n        int uniqueSubstrings = 0;\\n        int left = 0;\\n        int right = 2;\\n        \\n        for(int i = 1; i<s.length()-1; i++){\\n            \\n            if(s.charAt(i) != s.charAt(left) && s.charAt(i) != s.charAt(right) && s.charAt(right) != s.charAt(left)){\\n                uniqueSubstrings++;\\n            }\\n            left++;\\n            right++;\\n        }\\n        return uniqueSubstrings;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countGoodSubstrings(String s) {\\n        int uniqueSubstrings = 0;\\n        int left = 0;\\n        int right = 2;\\n        \\n        for(int i = 1; i<s.length()-1; i++){\\n            \\n            if(s.charAt(i) != s.charAt(left) && s.charAt(i) != s.charAt(right) && s.charAt(right) != s.charAt(left)){\\n                uniqueSubstrings++;\\n            }\\n            left++;\\n            right++;\\n        }\\n        return uniqueSubstrings;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1715117,
                "title": "sliding-window-using-map",
                "content": "\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3)\\n        {\\n            return 0; //edge case\\n        }\\n        map<char,int> mp;\\n        int i=0,j=0,ans=0;\\n\\t\\t\\n        while(j<s.size())\\n        {\\n            mp[s[j]]++;\\n\\t\\t\\t//if the window size is less than 3 slide j only\\n            if(j-i+1<3)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1==3)\\n            {\\n\\t\\t\\t    // when window size is hit check if there are 3 distinct elements or not in the map\\n                if(mp.size()==3)\\n                {\\n                    ans++;\\n                }\\n\\t\\t\\t\\t//after checking, slide the window \\n\\t\\t\\t\\t//decrement the value of the first element in the window in the map\\n                mp[s[i]]--;\\n\\t\\t\\t\\t//if the value becomes zero, remove the element from the map\\n                if(mp[s[i]]==0)\\n                {\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3)\\n        {\\n            return 0; //edge case\\n        }\\n        map<char,int> mp;\\n        int i=0,j=0,ans=0;\\n\\t\\t\\n        while(j<s.size())\\n        {\\n            mp[s[j]]++;\\n\\t\\t\\t//if the window size is less than 3 slide j only\\n            if(j-i+1<3)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1==3)\\n            {\\n\\t\\t\\t    // when window size is hit check if there are 3 distinct elements or not in the map\\n                if(mp.size()==3)\\n                {\\n                    ans++;\\n                }\\n\\t\\t\\t\\t//after checking, slide the window \\n\\t\\t\\t\\t//decrement the value of the first element in the window in the map\\n                mp[s[i]]--;\\n\\t\\t\\t\\t//if the value becomes zero, remove the element from the map\\n                if(mp[s[i]]==0)\\n                {\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1544118,
                "title": "c-sliding-window-easy-to-understand",
                "content": "\\nclass Solution {\\npublic:\\n\\n    int countGoodSubstrings(string s) \\n    {\\n        int i=0,j=0;\\n        map<int,int> mp;\\n        int ans=0;\\n        while(j<s.size())\\n        {\\n            while(j-i+1<=3)\\n            {\\n                mp[s[j]]++;\\n                j++;\\n            }\\n            if(mp.size()==3)\\n            {\\n                    ans++;\\n            }\\n            mp[s[i]]--;\\n            if(mp[s[i]]==0)\\n            {\\n                mp.erase(s[i]);\\n            }\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countGoodSubstrings(string s) \\n    {\\n        int i=0,j=0;\\n        map<int,int> mp;\\n        int ans=0;\\n        while(j<s.size())\\n        {\\n            while(j-i+1<=3)\\n            {\\n                mp[s[j]]++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1313305,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int c=0,n=s.size();\\n        for(int i=0;i<n-2;i++){\\n            if(s[i]!=s[i+1]&& s[i+1]!=s[i+2] && s[i]!=s[i+2])\\n                c++;\\n        } \\n        return c;\\n    }\\n };\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int c=0,n=s.size();\\n        for(int i=0;i<n-2;i++){\\n            if(s[i]!=s[i+1]&& s[i+1]!=s[i+2] && s[i]!=s[i+2])\\n                c++;\\n        } \\n        return c;\\n    }\\n };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283969,
                "title": "java-simple-sliding-window-and-substrings",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        if(s.length() < 3)\\n            return 0;\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            if(isGoodString(s.substring(i,i+3)))\\n                count++;\\n        }\\n    return count;\\n    }\\n    \\n    private static boolean isGoodString(String substring) {\\n        int[] intArray = new int[26];\\n        for (char c:substring.toCharArray()) {\\n            intArray[c - \\'a\\']++;\\n        }\\n        for (char c:substring.toCharArray()) {\\n            if(intArray[c - \\'a\\'] > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        if(s.length() < 3)\\n            return 0;\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            if(isGoodString(s.substring(i,i+3)))\\n                count++;\\n        }\\n    return count;\\n    }\\n    \\n    private static boolean isGoodString(String substring) {\\n        int[] intArray = new int[26];\\n        for (char c:substring.toCharArray()) {\\n            intArray[c - \\'a\\']++;\\n        }\\n        for (char c:substring.toCharArray()) {\\n            if(intArray[c - \\'a\\'] > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269999,
                "title": "python-sliding-window",
                "content": "If you are familiar with the sliding window technique, this problem is pretty straightforward:\\n\\n1. Maintain a dictionary that stores letters you\\'ve seen so far. The letters are the key, and hwo many times you\\'ve seen them is the value.\\n2. Have a static window of size 3 and at each increment, check if the dictionary is of length 3. If so, this means that there are 3 unique characters you\\'ve seen in this substring, so increment your result by 1.\\n3. Remove the character at the leftmost position from the dictionary, by decrementing it\\'s value in the dictionary by 1. If this value reaches 0, pop this element from the dictionary.\\n\\nSpace complexity is O(1) since our dictionary is always at or below size 3, and time complexity is O(n) since we process each character at most twice, once from the window_end, and once from windows_start. \\n\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        seen = {}\\n        window_start = 0\\n        res = 0\\n        for window_end in range(len(s)):\\n            if s[window_end] not in seen:\\n                seen[s[window_end]] = 0\\n            seen[s[window_end]] += 1\\n            if window_end < 2:\\n                continue\\n            elif window_end == 2:\\n                if len(seen) == 3:\\n                    res += 1\\n            else:\\n                seen[s[window_start]] -= 1\\n                if seen[s[window_start]] == 0:\\n                    seen.pop(s[window_start])\\n                if len(seen) == 3:\\n                    res += 1\\n                window_start += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        seen = {}\\n        window_start = 0\\n        res = 0\\n        for window_end in range(len(s)):\\n            if s[window_end] not in seen:\\n                seen[s[window_end]] = 0\\n            seen[s[window_end]] += 1\\n            if window_end < 2:\\n                continue\\n            elif window_end == 2:\\n                if len(seen) == 3:\\n                    res += 1\\n            else:\\n                seen[s[window_start]] -= 1\\n                if seen[s[window_start]] == 0:\\n                    seen.pop(s[window_start])\\n                if len(seen) == 3:\\n                    res += 1\\n                window_start += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266224,
                "title": "c-easy-solution-o-n-time-o-1-space-0ms-solution",
                "content": "```\\n//if we observe clearly if a character repeats then they must be either adjacent or they must be at the end of the substring of length 3\\n//we use this to check if characters are repeated and if not we will increment the count\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int res=0;\\n        int i=0;\\n        int j=0;\\n        while(j<s.length())\\n        {\\n            if(j-i+1==3)\\n            {\\n                //check if a char is repeated\\n                if(s[i]==s[i+1] || s[j]==s[j-1] || s[i]==s[j])\\n                {\\n                    //char repeated\\n                }\\n                else{\\n                    res++;\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Please upvote if this helps :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//if we observe clearly if a character repeats then they must be either adjacent or they must be at the end of the substring of length 3\\n//we use this to check if characters are repeated and if not we will increment the count\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int res=0;\\n        int i=0;\\n        int j=0;\\n        while(j<s.length())\\n        {\\n            if(j-i+1==3)\\n            {\\n                //check if a char is repeated\\n                if(s[i]==s[i+1] || s[j]==s[j-1] || s[i]==s[j])\\n                {\\n                    //char repeated\\n                }\\n                else{\\n                    res++;\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250624,
                "title": "using-queue-approach-in-c-100-beat",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        queue<int> q;\\n        int ct=0;\\n        for(int i=0;i<s.size();i++){\\n            if(q.empty()){\\n               q.push(s[i]);\\n            }else{\\n               if(q.back()==s[i]){\\n                   while(q.empty()==false) q.pop();\\n                   q.push(s[i]);\\n               }else{\\n                   q.push(s[i]);\\n               }\\n            }\\n            if(q.size()==3){\\n                if(q.front()!=q.back()) ct++;\\n                q.pop();\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        queue<int> q;\\n        int ct=0;\\n        for(int i=0;i<s.size();i++){\\n            if(q.empty()){\\n               q.push(s[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1248025,
                "title": "o-n-c-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\t\\n        int n=s.length(); // length of string\\n        bool m[26]={0}; //bool array to mark which letters are present\\n        int i,j,ans=0;\\n        \\n        for(i=0;i<n-2;i++)\\n        {\\n            for(j=0;j<26;j++)// re-initialising all the letters as absent\\n\\t\\t\\t\\tm[j]=false;\\n\\t\\t\\t\\n            for(j=0;j<3;j++)\\n            {\\n                char c=s[i+j]-\\'a\\';\\n                if(m[c])// if c has already occured\\n                    break;\\n                else\\n                    m[c]=1; // mark c as present in the substring s[i...i+2]\\n            }\\n\\t\\t\\tif(j==3)ans++; // if we successfully reach end of substring means no duplicate\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\t\\n        int n=s.length(); // length of string\\n        bool m[26]={0}; //bool array to mark which letters are present\\n        int i,j,ans=0;\\n        \\n        for(i=0;i<n-2;i++)\\n        {\\n            for(j=0;j<26;j++)// re-initialising all the letters as absent\\n\\t\\t\\t\\tm[j]=false;\\n\\t\\t\\t\\n            for(j=0;j<3;j++)\\n            {\\n                char c=s[i+j]-\\'a\\';\\n                if(m[c])// if c has already occured\\n                    break;\\n                else\\n                    m[c]=1; // mark c as present in the substring s[i...i+2]\\n            }\\n\\t\\t\\tif(j==3)ans++; // if we successfully reach end of substring means no duplicate\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245999,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:            \\n        return sum(s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2] for i in range(2, len(s)))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:            \\n        return sum(s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2] for i in range(2, len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238755,
                "title": "sliding-window-technique-java-explained-with-comments",
                "content": "\\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int windowStart = 0;\\n        int count = 0;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++) {\\n            char rightChar = s.charAt(windowEnd);\\n\\t\\t\\t// putting each character into map\\n            map.put(rightChar, map.getOrDefault(rightChar, 0) + 1);\\n\\t\\t\\t// if at any point in time, the size of map becomes greater than 3\\n            while(map.size() >= 3) {\\n\\t\\t\\t\\t/* first check, if the current length of our window is 3\\n\\t\\t\\t\\t   length is 3, we are going to increment count and break for the current window. */\\n                if ((windowEnd - windowStart + 1) == 3) {\\n                    count++;\\n                    break;\\n                }\\n                else {\\n\\t\\t\\t\\t\\t/* otherwise, take character from left side of the window and start decrementing its\\n\\t\\t\\t\\t\\tfrequency from the map. Decrementing means, we are not considering this element \\n\\t\\t\\t\\t\\tin our window. And, if its frequency becomes zero, we\\'ll remove it from the map. */\\n                    char leftChar = s.charAt(windowStart);\\n                    map.put(leftChar, map.get(leftChar) - 1);\\n                    if(map.get(leftChar) == 0) {\\n                        map.remove(leftChar);\\n                    }\\n                    windowStart++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        int windowStart = 0;\\n        int count = 0;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++) {\\n            char rightChar = s.charAt(windowEnd);\\n\\t\\t\\t// putting each character into map\\n            map.put(rightChar, map.getOrDefault(rightChar, 0) + 1);\\n\\t\\t\\t// if at any point in time, the size of map becomes greater than 3\\n            while(map.size() >= 3) {\\n\\t\\t\\t\\t/* first check, if the current length of our window is 3\\n\\t\\t\\t\\t   length is 3, we are going to increment count and break for the current window. */\\n                if ((windowEnd - windowStart + 1) == 3) {\\n                    count++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4041220,
                "title": "java-solution-tc-0ms-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n\\nint count = 0;\\n for(int i=2;i<s.length();i++){\\n                char a = s.charAt(i);\\n                char b = s.charAt(i-1);\\n                char c = s.charAt(i-2);\\n                if(a != b && a != c  && b != c)\\n                   count++;\\n }\\n return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n\\nint count = 0;\\n for(int i=2;i<s.length();i++){\\n                char a = s.charAt(i);\\n                char b = s.charAt(i-1);\\n                char c = s.charAt(i-2);\\n                if(a != b && a != c  && b != c)\\n                   count++;\\n }\\n return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808878,
                "title": "optimal-sliding-window-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        if len(s) < 3:\\n            return 0\\n        a = s[0]\\n        b = s[1]\\n        c = s[2]\\n        count = int(a != b and b !=c and c != a)\\n\\n        for i in range(3, len(s)):\\n            a = b\\n            b = c\\n            c = s[i]\\n            count += int(a != b and b !=c and c != a)\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        if len(s) < 3:\\n            return 0\\n        a = s[0]\\n        b = s[1]\\n        c = s[2]\\n        count = int(a != b and b !=c and c != a)\\n\\n        for i in range(3, len(s)):\\n            a = b\\n            b = c\\n            c = s[i]\\n            count += int(a != b and b !=c and c != a)\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421386,
                "title": "c",
                "content": "# Intuition\\nBecause I don\\'t know which character to remove from set when set length less than 3, so when it is greater than 3, i will re-check whole set \\nex : \"zyyyy\"\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nwhen set length greater than 3, i will re-check whole set \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n        {\\n            public int CountGoodSubstrings(string s)\\n            {\\n                if(s.Length < 3) return 0;\\n                int result = 0;\\n                HashSet<char> record = new HashSet<char>();                \\n\\n                for (int i = 0; i<s.Length ;i++)\\n                {\\n                    record.Add(s[i]);\\n                    if (record.Count >= 3)\\n                    {\\n                        record.Clear();\\n                        for (int j = i-2; j <= i; j++)\\n                            record.Add(s[j]);\\n                    }\\n\\n                    if (record.Count == 3)\\n                        result += 1;\\n                }\\n                return result;\\n            }\\n        }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n        {\\n            public int CountGoodSubstrings(string s)\\n            {\\n                if(s.Length < 3) return 0;\\n                int result = 0;\\n                HashSet<char> record = new HashSet<char>();                \\n\\n                for (int i = 0; i<s.Length ;i++)\\n                {\\n                    record.Add(s[i]);\\n                    if (record.Count >= 3)\\n                    {\\n                        record.Clear();\\n                        for (int j = i-2; j <= i; j++)\\n                            record.Add(s[j]);\\n                    }\\n\\n                    if (record.Count == 3)\\n                        result += 1;\\n                }\\n                return result;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311957,
                "title": "c-easy-brute-force-approach-for-loop-only-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\njai shree ram\\nupvote if you find it helpfull\\nif any problem ask it in comment section..\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n     int ans = 0;\\n      //check if the length is less than 3...\\n        if(s.length() < 3)\\n         return 0;\\n        //simple for loop check the 1 character with 2 and 1 with 3 and 2 with the 3 ..with if condition if it is true add it to ans..\\n        for(int i = 0; i<=s.length()-3; i++) {\\n            if(s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2])\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n     int ans = 0;\\n      //check if the length is less than 3...\\n        if(s.length() < 3)\\n         return 0;\\n        //simple for loop check the 1 character with 2 and 1 with 3 and 2 with the 3 ..with if condition if it is true add it to ans..\\n        for(int i = 0; i<=s.length()-3; i++) {\\n            if(s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2])\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034139,
                "title": "easiest-8-lines-beginner-friendly-solution",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\no(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n    int count=0;\\n\\n    for(int i=0;i<s.length()-2;i++){\\n\\n    String temp=s.substring(i,i+3);\\n\\n    if(temp.charAt(0)!=temp.charAt(1)&&temp.charAt(0)!=temp.charAt(2)&&temp.charAt(1)!=temp.charAt(2)){\\n        count++;\\n    }\\n\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n    int count=0;\\n\\n    for(int i=0;i<s.length()-2;i++){\\n\\n    String temp=s.substring(i,i+3);\\n\\n    if(temp.charAt(0)!=temp.charAt(1)&&temp.charAt(0)!=temp.charAt(2)&&temp.charAt(1)!=temp.charAt(2)){\\n        count++;\\n    }\\n\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744224,
                "title": "python-faster-than-94-of-submissions-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def countGoodSubstrings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(s)-2):\\n            q = s[i:i+4]\\n            if q[0] != q[1] and q[0] != q[2] and q[2] != q[1]:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countGoodSubstrings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(s)-2):\\n            q = s[i:i+4]\\n            if q[0] != q[1] and q[0] != q[2] and q[2] != q[1]:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742324,
                "title": "sliding-window-here-we-count-the-substrings-of-size-3-having-all-unique-characters",
                "content": "```\\nHere we have to calculate the number of substrings of size 3 having all unique characters .\\nSo this question basically uses the concept of sliding window of fixed size which we will slide over the string . \\nWe will use map to store the frequency of characters in the window . \\nAll the characaters are unique in the particular window if current map size is equal to window length (j-i+1) . here i denotes the starting index of window \\nand j denotes the ending index of window . \\n\\nint countGoodSubstrings(string s) \\n    {\\n        int n = s.size(); \\n        int k = 3; // Required window size \\n        \\n        unordered_map<char,int> mp;\\n        int i=0,j=0; // i is starting index of window and j is ending index of window\\n        int count = 0; // Subarrays count\\n        \\n        while(j<n)\\n        {\\n            mp[s[j]]++; // Adding the frequency of jth character in map\\n            \\n            if(j-i+1<3) // If window size of 3 is not achieved\\n                j++;\\n            \\n            else if(j-i+1==3)  // If window size of 3 is achieved\\n            {\\n                if(mp.size()==(j-i+1)) // Checking if all the characters in window are unique\\n                {\\n                    count += 1;\\n                    \\n                    mp[s[i]]--; // Before sliding the window make sure to decrease the count of starting index character of window \\n                    if(mp[s[i]]==0) \\n                        mp.erase(s[i]);\\n                    \\n\\t\\t\\t\\t\\t// Sliding the window\\n                    i++; \\n                    j++;\\n                    \\n                }\\n                \\n                else if(mp.size()<(j-i+1)) // // if all the characters in window are not unique\\n                {\\n                    while(mp.size()<(j-i+1) && i<=j) // Removing the ith character from window until we have removed all the duplicate characters\\n                    {\\n                        mp[s[i]]--;\\n                        if(mp[s[i]]==0)\\n                            mp.erase(s[i]);\\n                        i++;\\n                    }\\n                    j++;\\n                }                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nHere we have to calculate the number of substrings of size 3 having all unique characters .\\nSo this question basically uses the concept of sliding window of fixed size which we will slide over the string . \\nWe will use map to store the frequency of characters in the window . \\nAll the characaters are unique in the particular window if current map size is equal to window length (j-i+1) . here i denotes the starting index of window \\nand j denotes the ending index of window . \\n\\nint countGoodSubstrings(string s) \\n    {\\n        int n = s.size(); \\n        int k = 3; // Required window size \\n        \\n        unordered_map<char,int> mp;\\n        int i=0,j=0; // i is starting index of window and j is ending index of window\\n        int count = 0; // Subarrays count\\n        \\n        while(j<n)\\n        {\\n            mp[s[j]]++; // Adding the frequency of jth character in map\\n            \\n            if(j-i+1<3) // If window size of 3 is not achieved\\n                j++;\\n            \\n            else if(j-i+1==3)  // If window size of 3 is achieved\\n            {\\n                if(mp.size()==(j-i+1)) // Checking if all the characters in window are unique\\n                {\\n                    count += 1;\\n                    \\n                    mp[s[i]]--; // Before sliding the window make sure to decrease the count of starting index character of window \\n                    if(mp[s[i]]==0) \\n                        mp.erase(s[i]);\\n                    \\n\\t\\t\\t\\t\\t// Sliding the window\\n                    i++; \\n                    j++;\\n                    \\n                }\\n                \\n                else if(mp.size()<(j-i+1)) // // if all the characters in window are not unique\\n                {\\n                    while(mp.size()<(j-i+1) && i<=j) // Removing the ith character from window until we have removed all the duplicate characters\\n                    {\\n                        mp[s[i]]--;\\n                        if(mp[s[i]]==0)\\n                            mp.erase(s[i]);\\n                        i++;\\n                    }\\n                    j++;\\n                }                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2664467,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string n) {\\n        int s=n.size();\\n        int a=0;\\n        for(int i=1;i<s-1;i++)\\n        {\\n            if(n[i]!=n[i-1]&&n[i]!=n[i+1]&&n[i-1]!=n[i+1])\\n            {\\n                a++;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string n) {\\n        int s=n.size();\\n        int a=0;\\n        for(int i=1;i<s-1;i++)\\n        {\\n            if(n[i]!=n[i-1]&&n[i]!=n[i+1]&&n[i-1]!=n[i+1])\\n            {\\n                a++;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585933,
                "title": "c-sliding-window-approach-works-for-any-value-of-k",
                "content": "**For any value of k : **\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size(),count=0,k=3;\\n        if(n<k) return count;\\n        unordered_map<char,int>m;\\n        for(int i=0;i<k;i++){\\n            m[s[i]]++;\\n        }\\n        if(m.size()==k) count++;\\n        for(int j=k;j<n;j++){\\n            m[s[j-k]]--;\\n            m[s[j]]++;\\n            if(m[s[j-k]]==0) m.erase(s[j-k]);\\n            if(m.size()==k) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\nFor k=3;\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size(),count=0;\\n        if(n<3) return count;\\n        unordered_map<char,int>m;\\n        for(int i=0;i<3;i++){   //in this question k=3;\\n            m[s[i]]++;\\n        }\\n        if(m.size()==3) count++;\\n        for(int j=3;j<n;j++){\\n            m[s[j-3]]--;\\n            m[s[j]]++;\\n            if(m[s[j-3]]==0) m.erase(s[j-3]);\\n            if(m.size()==3) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size(),count=0,k=3;\\n        if(n<k) return count;\\n        unordered_map<char,int>m;\\n        for(int i=0;i<k;i++){\\n            m[s[i]]++;\\n        }\\n        if(m.size()==k) count++;\\n        for(int j=k;j<n;j++){\\n            m[s[j-k]]--;\\n            m[s[j]]++;\\n            if(m[s[j-k]]==0) m.erase(s[j-k]);\\n            if(m.size()==k) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size(),count=0;\\n        if(n<3) return count;\\n        unordered_map<char,int>m;\\n        for(int i=0;i<3;i++){   //in this question k=3;\\n            m[s[i]]++;\\n        }\\n        if(m.size()==3) count++;\\n        for(int j=3;j<n;j++){\\n            m[s[j-3]]--;\\n            m[s[j]]++;\\n            if(m[s[j-3]]==0) m.erase(s[j-3]);\\n            if(m.size()==3) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357175,
                "title": "short-javascript-solution-using-a-set-object-and-the-sliding-window-technique",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nconst countGoodSubstrings = s => {\\n    let count = 0;\\n\\n    for (let i = 0; i < s.length - 2; i++) {\\n        let window = s.substring(i, 3 + i)\\n        if (new Set(window.split(\\'\\')).size === 3) count++\\n    }\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nconst countGoodSubstrings = s => {\\n    let count = 0;\\n\\n    for (let i = 0; i < s.length - 2; i++) {\\n        let window = s.substring(i, 3 + i)\\n        if (new Set(window.split(\\'\\')).size === 3) count++\\n    }\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2258625,
                "title": "golang-easy-solution-0ms-100",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Substrings of Size Three with Distinct Characters.\\nMemory Usage: 1.9 MB, less than 58.82% of Go online submissions for Substrings of Size Three with Distinct Characters.\\n\\n```\\nfunc countGoodSubstrings(s string) int {\\n    if len(s) <= 2 {\\n        return 0\\n    }\\n    ans := 0\\n    for i := 0; i < len(s) - 2; i++ {\\n        tmp := s[i:i+3]\\n        if tmp[0] != tmp[1] && tmp[0] != tmp[2] && tmp[1] != tmp[2] {\\n            ans++\\n        }\\n    } \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countGoodSubstrings(s string) int {\\n    if len(s) <= 2 {\\n        return 0\\n    }\\n    ans := 0\\n    for i := 0; i < len(s) - 2; i++ {\\n        tmp := s[i:i+3]\\n        if tmp[0] != tmp[1] && tmp[0] != tmp[2] && tmp[1] != tmp[2] {\\n            ans++\\n        }\\n    } \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2114971,
                "title": "javascript-sliding-window",
                "content": "Sliding Window is a good solution for substring problems. In this solution the window or subset has a maximum length (3) but is dynamic in that it grows and shrinks.\\n\\nTwo pointers are used to define the boundary of the subset (window). The left and right pointers are `left` and `i`, respectively.\\n\\n`Set` is used to store the values of the subset so we can check if a charcater already exists. When a character exists in the `Set`, we remove all the characters from the left (using our left pointer) until the duplicate character has been removed. The left pointer will now be at the start of our new subset.\\n\\nWhen the `Set` reaches a size of 3, the `count` is incremented by one, the starting character in the subset is removed and the left pointer incremented by 1.\\n\\n``` js\\nvar countGoodSubstrings = function (s) {\\n  let left = 0,\\n    count = 0,\\n    set = new Set();\\n\\n  for (let i = 0; i < s.length; i++) {\\n    while (set.has(s[i])) {\\n      set.delete(s[left]);\\n      left++;\\n    }\\n\\n    set.add(s[i]);\\n\\n    if (set.size === 3) {\\n      count++;\\n      set.delete(s[left]);\\n      left++;\\n    }\\n  }\\n\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "``` js\\nvar countGoodSubstrings = function (s) {\\n  let left = 0,\\n    count = 0,\\n    set = new Set();\\n\\n  for (let i = 0; i < s.length; i++) {\\n    while (set.has(s[i])) {\\n      set.delete(s[left]);\\n      left++;\\n    }\\n\\n    set.add(s[i]);\\n\\n    if (set.size === 3) {\\n      count++;\\n      set.delete(s[left]);\\n      left++;\\n    }\\n  }\\n\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2106937,
                "title": "java-two-easy-solutions-with-explanation-o-n-brute-force",
                "content": "**Method 1:** **Brute Force Solution:**\\n1. Find the substring of length = 3\\n2. Store the substring in set -- set will eliminate duplicate characters --meaning 3 distinct characters in substring\\n3. If set.size() == 3, increase the count \\n4.  Return the count \\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n     int k = 3;\\n     int count = 0;   \\n     int kindex = k - 1;   \\n     String sub = new String();  \\n     for(int i = kindex; i < s.length(); i++){\\n        Set<Character> set = new HashSet<>(); \\n        sub = s.substring(i - kindex, i + 1);\\n        for(int j = 0 ; j < sub.length(); j++) \\n            set.add(sub.charAt(j));   \\n        if(set.size() == 3) count = count + 1; \\n     }  \\n       return count;     \\n    }\\n}\\n```\\n\\n**Method 2: O(N) solution using ArrayList - Approach - Sliding Window**\\n1. SlidingWindow length = 3\\n2. Add character in the list. If list size is greater than slidingwindow length, then remove the first element from the list\\n3. If list size is equal to 3, then check if all the elements are distinct, if yes increase the count\\n4. Return the count\\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n      ArrayList<Character> list = new ArrayList<>();\\n      int slidingWindowSize = 3;  \\n      int count = 0;  \\n      for(int i = 0; i < s.length(); i++){\\n          list.add(s.charAt(i));\\n          if(list.size() > slidingWindowSize){ \\n              list.remove(0);\\n          }   \\n          if(list.size() == 3) {\\n              if(list.get(0) != list.get(1) && list.get(0) != list.get(2) && list.get(1) != list.get(2)) \\n                  count = count + 1;\\n          }\\n      }\\n     return count;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n     int k = 3;\\n     int count = 0;   \\n     int kindex = k - 1;   \\n     String sub = new String();  \\n     for(int i = kindex; i < s.length(); i++){\\n        Set<Character> set = new HashSet<>(); \\n        sub = s.substring(i - kindex, i + 1);\\n        for(int j = 0 ; j < sub.length(); j++) \\n            set.add(sub.charAt(j));   \\n        if(set.size() == 3) count = count + 1; \\n     }  \\n       return count;     \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n      ArrayList<Character> list = new ArrayList<>();\\n      int slidingWindowSize = 3;  \\n      int count = 0;  \\n      for(int i = 0; i < s.length(); i++){\\n          list.add(s.charAt(i));\\n          if(list.size() > slidingWindowSize){ \\n              list.remove(0);\\n          }   \\n          if(list.size() == 3) {\\n              if(list.get(0) != list.get(1) && list.get(0) != list.get(2) && list.get(1) != list.get(2)) \\n                  count = count + 1;\\n          }\\n      }\\n     return count;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041906,
                "title": "1876-substrings-of-size-three-with-distinct-characters",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(int left, int right, string& s){\\n        unordered_set<int> st;\\n        for(int i=left; i<=right; i++){\\n            st.insert(s[i]);\\n        }\\n        if(st.size()==right-left+1)\\n            return 1;\\n        else\\n            return 0;\\n    }\\n    \\n    int countGoodSubstrings(string s) {\\n        if(s.length()<3)\\n            return 0;\\n        int count=0;\\n        int i=0;\\n        int k=3;\\n        int j=k-1;\\n        if(check(i,j,s))\\n            count++;\\n        while(j<s.length()-1)\\n        {\\n            i++;\\n            j++;\\n            if(check(i,j,s))\\n                    count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(int left, int right, string& s){\\n        unordered_set<int> st;\\n        for(int i=left; i<=right; i++){\\n            st.insert(s[i]);\\n        }\\n        if(st.size()==right-left+1)\\n            return 1;\\n        else\\n            return 0;\\n    }\\n    \\n    int countGoodSubstrings(string s) {\\n        if(s.length()<3)\\n            return 0;\\n        int count=0;\\n        int i=0;\\n        int k=3;\\n        int j=k-1;\\n        if(check(i,j,s))\\n            count++;\\n        while(j<s.length()-1)\\n        {\\n            i++;\\n            j++;\\n            if(check(i,j,s))\\n                    count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982289,
                "title": "c-solution-0ms",
                "content": "\\n        int goodStrCnt = 0, n = s.size();\\n        for(int i = 0; i < n-2 ; i++){\\n            if((s[i]^s[i+1]) == 0) continue;\\n            if((s[i+2]^s[i+1]) == 0)continue;\\n            if((s[i+2]^s[i]) == 0) continue;\\n            goodStrCnt++;\\n        }\\n        return goodStrCnt;\\n    }",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "\\n        int goodStrCnt = 0, n = s.size();\\n        for(int i = 0; i < n-2 ; i++){\\n            if((s[i]^s[i+1]) == 0) continue;\\n            if((s[i+2]^s[i+1]) == 0)continue;\\n            if((s[i+2]^s[i]) == 0) continue;\\n            goodStrCnt++;\\n        }\\n        return goodStrCnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1913754,
                "title": "c-faster-than-100",
                "content": "```\\n int n = s.size();\\n        int ans = 0 ;\\n        int i  ;\\n        for(i= 0 ; i < n-2 ; i++){\\n            if(s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\\n                continue;\\n            ans++;\\n        }\\n        return ans;",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n int n = s.size();\\n        int ans = 0 ;\\n        int i  ;\\n        for(i= 0 ; i < n-2 ; i++){\\n            if(s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\\n                continue;\\n            ans++;\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 1855886,
                "title": "c-easy-solution-sliding-window-with-comments-explained",
                "content": "\\tint check(int i,int j,string& s)\\n    {\\n        set<int>st;//checking whether the selected part of string is duplicate or not\\n        for(int k=i;k<=j;k++)\\n        {\\n            st.insert(s[k]);\\n        }\\n        if(st.size()==3)\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n    int countGoodSubstrings(string s)\\n    {\\n        int right=0;\\n        int left=0;\\n        int ans=0;\\n        while(right<s.length())\\n        {\\n            if(right-left==2)//taking the selected part of string\\n            {\\n                ans+=check(left,right,s);//sending the index to check\\n                left+=1;\\n            }\\n            right++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "\\tint check(int i,int j,string& s)\\n    {\\n        set<int>st;//checking whether the selected part of string is duplicate or not\\n        for(int k=i;k<=j;k++)\\n        {\\n            st.insert(s[k]);\\n        }\\n        if(st.size()==3)\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n    int countGoodSubstrings(string s)\\n    {\\n        int right=0;\\n        int left=0;\\n        int ans=0;\\n        while(right<s.length())\\n        {\\n            if(right-left==2)//taking the selected part of string\\n            {\\n                ans+=check(left,right,s);//sending the index to check\\n                left+=1;\\n            }\\n            right++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1815806,
                "title": "c-simple-and-clean-solution-o-n-tc-o-1-sc",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if (s.size() < 3) return 0;\\n        \\n        int res = 0;\\n        for (int i = 0; i < s.size()-2; i++) {\\n            if (s[i] != s[i+1] && s[i+1] != s[i+2] && s[i] != s[i+2]) res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if (s.size() < 3) return 0;\\n        \\n        int res = 0;\\n        for (int i = 0; i < s.size()-2; i++) {\\n            if (s[i] != s[i+1] && s[i+1] != s[i+2] && s[i] != s[i+2]) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742948,
                "title": "c-100-faster-solution",
                "content": "* j-i+1=window size\\n* \\n```\\nint countGoodSubstrings(string s) {\\n        unordered_map<char,int> mp;\\n        \\n        int i=0,j=0;\\n        int count=0;\\n        while(j<s.size())\\n        {\\n            mp[s[j]]++;\\n            \\n            if(j-i+1==3)\\n            {\\n                if(mp.size()==3)\\n                    count++;\\n                \\n                mp[s[i]]--;\\n                if(mp[s[i]]==0)\\n                    mp.erase(s[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nint countGoodSubstrings(string s) {\\n        unordered_map<char,int> mp;\\n        \\n        int i=0,j=0;\\n        int count=0;\\n        while(j<s.size())\\n        {\\n            mp[s[j]]++;\\n            \\n            if(j-i+1==3)\\n            {\\n                if(mp.size()==3)\\n                    count++;\\n                \\n                mp[s[i]]--;\\n                if(mp[s[i]]==0)\\n                    mp.erase(s[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1729504,
                "title": "c-sliding-window-with-clear-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int low=0,high=2,count=0;  // create the window size as 3\\n        unordered_set <char> ch;\\n        while(high<s.size())  // iterate till high<=size\\n        {\\n            for(int i=low;i<=high;++i)  //push the characters into set\\n                ch.insert(s[i]);\\n            if(ch.size()==3)    // unique elements only if set size == 3\\n                count++;\\n            ch.clear();    // clear the set\\n            low++; high++;  // change the window\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int low=0,high=2,count=0;  // create the window size as 3\\n        unordered_set <char> ch;\\n        while(high<s.size())  // iterate till high<=size\\n        {\\n            for(int i=low;i<=high;++i)  //push the characters into set\\n                ch.insert(s[i]);\\n            if(ch.size()==3)    // unique elements only if set size == 3\\n                count++;\\n            ch.clear();    // clear the set\\n            low++; high++;  // change the window\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706220,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        start=0\\n        end=start+3\\n        count=0\\n        while(end<=len(s)):\\n            if len(s[start:end])==len(set(s[start:end])):\\n                count+=1\\n            start+=1\\n            end+=1\\n        return count",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        start=0\\n        end=start+3\\n        count=0\\n        while(end<=len(s)):\\n            if len(s[start:end])==len(set(s[start:end])):\\n                count+=1\\n            start+=1\\n            end+=1\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1689404,
                "title": "c-o-n-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.length(), ans=0;\\n        for(int i=1;i<n-1;i++){\\n            set<char> st = {s[i],s[i-1],s[i+1]};\\n            if(st.size()==3)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.length(), ans=0;\\n        for(int i=1;i<n-1;i++){\\n            set<char> st = {s[i],s[i-1],s[i+1]};\\n            if(st.size()==3)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679788,
                "title": "c-simplest-solution-0ms",
                "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int l=s.size();int cnt=0;\\n        for(int i=0;i<l-2;i++)\\n        {\\n         if((s[i]!=s[i+1])&&(s[i+1]!=s[i+2])&&(s[i]!=s[i+2]))\\n             cnt++;\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int l=s.size();int cnt=0;\\n        for(int i=0;i<l-2;i++)\\n        {\\n         if((s[i]!=s[i+1])&&(s[i+1]!=s[i+2])&&(s[i]!=s[i+2]))\\n             cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1615243,
                "title": "100-fast-c-easy-understandable-solution-using-hash-and-sliding-window-technique",
                "content": "```\\nint countGoodSubstrings(string arr) {\\n        int i, j, count = 0,max_count = 0, k = 3;\\n        unordered_map<int, int> m;\\n\\t\\t// first taking an map with first three variable\\n        for (i = 0; i < k; i++)\\n        {\\n            if (m.find(arr[i]) == m.end())\\n                m[arr[i]] = 1;\\n            else\\n                m[arr[i]]++;\\n        }\\n        count = m.size();\\n        // then checking the size of the map if total size is 3 that means all elements are different  in that window\\n\\t\\tif(count == k){\\n            max_count++;\\n        }\\n        // sliding the window one by one removing the last element and its count and adding the very next element and again checking the count if its three then increasing our result .  \\n        for (i = k; i < (int)(arr.size()); i++)\\n        {\\n            if (m.find(arr[i]) == m.end())\\n                m[arr[i]] = 1;\\n            else\\n                m[arr[i]]++;\\n            if (m.find(arr[i - k]) != m.end())\\n            {\\n                if (m[arr[i - k]] == 1)\\n                    m.erase(arr[i - k]);\\n                else\\n                    m[arr[i - k]]--;\\n            }\\n            count = m.size();\\n            if(count == k){\\n                max_count++;\\n            }\\n        }\\n        return max_count;\\n    }\\n\\t// Hope it helps \\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint countGoodSubstrings(string arr) {\\n        int i, j, count = 0,max_count = 0, k = 3;\\n        unordered_map<int, int> m;\\n\\t\\t// first taking an map with first three variable\\n        for (i = 0; i < k; i++)\\n        {\\n            if (m.find(arr[i]) == m.end())\\n                m[arr[i]] = 1;\\n            else\\n                m[arr[i]]++;\\n        }\\n        count = m.size();\\n        // then checking the size of the map if total size is 3 that means all elements are different  in that window\\n\\t\\tif(count == k){\\n            max_count++;\\n        }\\n        // sliding the window one by one removing the last element and its count and adding the very next element and again checking the count if its three then increasing our result .  \\n        for (i = k; i < (int)(arr.size()); i++)\\n        {\\n            if (m.find(arr[i]) == m.end())\\n                m[arr[i]] = 1;\\n            else\\n                m[arr[i]]++;\\n            if (m.find(arr[i - k]) != m.end())\\n            {\\n                if (m[arr[i - k]] == 1)\\n                    m.erase(arr[i - k]);\\n                else\\n                    m[arr[i - k]]--;\\n            }\\n            count = m.size();\\n            if(count == k){\\n                max_count++;\\n            }\\n        }\\n        return max_count;\\n    }\\n\\t// Hope it helps \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1607378,
                "title": "easy-solution-in-c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) \\n    {\\n        int n = s.size();\\n        int result = 0;\\n        for (int i = 0; i < n-2; i++)\\n        {\\n            if (s[i] != s[i+1] and s[i] != s[i+2] and s[i+1] != s[i+2])\\n            {\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) \\n    {\\n        int n = s.size();\\n        int result = 0;\\n        for (int i = 0; i < n-2; i++)\\n        {\\n            if (s[i] != s[i+1] and s[i] != s[i+2] and s[i+1] != s[i+2])\\n            {\\n                result++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1596778,
                "title": "java-sliding-window-o-n",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int windowStart = 0;\\n        int goodSubStrCount = 0;\\n        \\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++) {\\n            char ch = s.charAt(windowEnd);\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n            if((windowEnd - windowStart + 1) == 3) {\\n                if(map.size() == 3)\\n                    goodSubStrCount++;\\n                \\n                char sch = s.charAt(windowStart++);\\n                map.put(sch, map.get(sch) - 1);\\n                if(map.get(sch) == 0)\\n                    map.remove(sch);\\n            }\\n        }\\n        \\n        return goodSubStrCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int windowStart = 0;\\n        int goodSubStrCount = 0;\\n        \\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++) {\\n            char ch = s.charAt(windowEnd);\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n            if((windowEnd - windowStart + 1) == 3) {\\n                if(map.size() == 3)\\n                    goodSubStrCount++;\\n                \\n                char sch = s.charAt(windowStart++);\\n                map.put(sch, map.get(sch) - 1);\\n                if(map.get(sch) == 0)\\n                    map.remove(sch);\\n            }\\n        }\\n        \\n        return goodSubStrCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443202,
                "title": "python-o-n-time-just-check-if-all-len-3-substrings-are-unique",
                "content": "Since we are only interested in substrings of length 3, iterate through the string and check if all characters\\nin adjacent substrings of length 3 are unique.\\n\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        ans = 0\\n        for i in range(len(s)-2):\\n            if s[i] != s[i+1] and s[i] != s[i+2] and s[i+1] != s[i+2]:\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        ans = 0\\n        for i in range(len(s)-2):\\n            if s[i] != s[i+1] and s[i] != s[i+2] and s[i+1] != s[i+2]:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421760,
                "title": "easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size();\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(j<n){\\n            if(j-i+1<3){\\n                j++;\\n            }\\n            else if(j-i+1==3){\\n                if(s[i]==s[i+1] || s[j]==s[j-1] || s[i]==s[j]){\\n                    //char repeated\\n                }\\n                else\\n                    ans++;\\n                j++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size();\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(j<n){\\n            if(j-i+1<3){\\n                j++;\\n            }\\n            else if(j-i+1==3){\\n                if(s[i]==s[i+1] || s[j]==s[j-1] || s[i]==s[j]){\\n                    //char repeated\\n                }\\n                else\\n                    ans++;\\n                j++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391491,
                "title": "simple-c-solution-with-0-ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.length();\\n        if(n<3){\\n            return 0;\\n        }\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        while(j<n-2){\\n            if(s[i]!=s[j+1] && s[i]!=s[j+2] && s[j+1]!=s[j+2]){\\n                count++;\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\nJust simply traverse over the string with window of size 3, let\\'s say you are at index i then check if element at index i-1 and i+1 are not equal or equal to element at index i.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.length();\\n        if(n<3){\\n            return 0;\\n        }\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        while(j<n-2){\\n            if(s[i]!=s[j+1] && s[i]!=s[j+2] && s[j+1]!=s[j+2]){\\n                count++;\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388272,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int countGoodSubstrings(String s) {\\n        if(s.length()<=2)\\n            return 0;\\n        int i,c=0;\\n        for(i=0;i<s.length()-2;i++)\\n        {\\n            if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(i+2)&&s.charAt(i)!=s.charAt(i+2))\\n                c++;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int countGoodSubstrings(String s) {\\n        if(s.length()<=2)\\n            return 0;\\n        int i,c=0;\\n        for(i=0;i<s.length()-2;i++)\\n        {\\n            if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(i+2)&&s.charAt(i)!=s.charAt(i+2))\\n                c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1379241,
                "title": "c-hashset-approach-72ms-23mb-o-n",
                "content": "```\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n        \\n        var strArray = s.ToCharArray(0, s.Length);\\n        var strSet = new HashSet<int>();\\n        var numOfGoodSubstring = 0;\\n        \\n        for (var i = 0; i < strArray.Count(); i++)\\n        {\\n            if (i+2 < strArray.Count())\\n            {\\n                strSet.Add(strArray[i]);\\n                strSet.Add(strArray[i+1]);\\n                strSet.Add(strArray[i+2]);\\n            }            \\n            \\n            if (strSet.Count == 3)\\n            {\\n                numOfGoodSubstring++;\\n            }\\n            strSet.Clear();\\n        }\\n        \\n        return numOfGoodSubstring;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n        \\n        var strArray = s.ToCharArray(0, s.Length);\\n        var strSet = new HashSet<int>();\\n        var numOfGoodSubstring = 0;\\n        \\n        for (var i = 0; i < strArray.Count(); i++)\\n        {\\n            if (i+2 < strArray.Count())\\n            {\\n                strSet.Add(strArray[i]);\\n                strSet.Add(strArray[i+1]);\\n                strSet.Add(strArray[i+2]);\\n            }            \\n            \\n            if (strSet.Count == 3)\\n            {\\n                numOfGoodSubstring++;\\n            }\\n            strSet.Clear();\\n        }\\n        \\n        return numOfGoodSubstring;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366864,
                "title": "easy-to-understand-python3-faster-than-99-83-of-python3",
                "content": "\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        counter = 0\\n        for i in range(len(s)-2):\\n            new = s[i:i+3]\\n            if len(new) == len(set(new)):\\n                counter = counter + 1\\n                \\n        return counter\\n```\\n\\nI know it can be condensed further but it works.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        counter = 0\\n        for i in range(len(s)-2):\\n            new = s[i:i+3]\\n            if len(new) == len(set(new)):\\n                counter = counter + 1\\n                \\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346771,
                "title": "java-clean-solution-why-people-confusing-with-i-1-i-1-all-the-jazz",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length()<3) return 0;\\n        \\n        int count = 0;\\n        for(int i=0;i+2<s.length();i++){\\n            char a = s.charAt(i);\\n            char b = s.charAt(i+1);\\n            char c = s.charAt(i+2);\\n            \\n            if(a !=b && b!=c && c!=a){\\n                count++; \\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length()<3) return 0;\\n        \\n        int count = 0;\\n        for(int i=0;i+2<s.length();i++){\\n            char a = s.charAt(i);\\n            char b = s.charAt(i+1);\\n            char c = s.charAt(i+2);\\n            \\n            if(a !=b && b!=c && c!=a){\\n                count++; \\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296008,
                "title": "kotlin-1-line",
                "content": "```\\nfun countGoodSubstrings(s: String) = s.windowed(3, 1).count { it.toSet().size == 3 }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun countGoodSubstrings(s: String) = s.windowed(3, 1).count { it.toSet().size == 3 }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1246820,
                "title": "java-sliding-window-approach-not-so-fast-but-intuitive",
                "content": "```\\npublic int countGoodSubstrings(String s) {\\n        int res = 0, start = 0, end = 3;\\n        \\n        if(s.length() < 3){\\n            return 0;\\n        }\\n\\t        \\n\\t    HashMap<Character, Integer> map = new HashMap<>();\\n\\t        \\n\\t    for(int i = 0 ; i < 3; i++) {\\n\\t    \\t char c  = s.charAt(i);\\n\\t    \\t map.put(c, map.getOrDefault(c, 0) + 1);\\n\\t     }\\n        \\n        if(map.size() == 3) {\\n\\t    \\t\\t   res++;\\n\\t    }\\n\\t       \\n\\t    while(end<s.length()) {\\n\\t    \\tchar e = s.charAt(end);\\n\\t    \\tchar st= s.charAt(start);\\n            \\n\\t    \\tmap.put(st, map.get(st) - 1);\\n\\t    \\tif(map.get(st) == 0) {\\n\\t    \\t\\t map.remove(st);\\n\\t    \\t }\\n            \\n\\t    \\tmap.put(e, map.getOrDefault(e ,0) + 1);\\n            \\n            if(map.size() == 3) {\\n\\t    \\t\\t   res++;\\n\\t    \\t   }\\n\\t    \\t   \\n\\t    \\t start++;\\n\\t    \\t end++;\\n\\t    }\\n\\t    return res;  \\n    }",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\npublic int countGoodSubstrings(String s) {\\n        int res = 0, start = 0, end = 3;\\n        \\n        if(s.length() < 3){\\n            return 0;\\n        }\\n\\t        \\n\\t    HashMap<Character, Integer> map = new HashMap<>();\\n\\t        \\n\\t    for(int i = 0 ; i < 3; i++) {\\n\\t    \\t char c  = s.charAt(i);\\n\\t    \\t map.put(c, map.getOrDefault(c, 0) + 1);\\n\\t     }\\n        \\n        if(map.size() == 3) {\\n\\t    \\t\\t   res++;\\n\\t    }\\n\\t       \\n\\t    while(end<s.length()) {\\n\\t    \\tchar e = s.charAt(end);\\n\\t    \\tchar st= s.charAt(start);\\n            \\n\\t    \\tmap.put(st, map.get(st) - 1);\\n\\t    \\tif(map.get(st) == 0) {\\n\\t    \\t\\t map.remove(st);\\n\\t    \\t }\\n            \\n\\t    \\tmap.put(e, map.getOrDefault(e ,0) + 1);\\n            \\n            if(map.size() == 3) {\\n\\t    \\t\\t   res++;\\n\\t    \\t   }\\n\\t    \\t   \\n\\t    \\t start++;\\n\\t    \\t end++;\\n\\t    }\\n\\t    return res;  \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1238826,
                "title": "js-single-loop-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countGoodSubstrings = function(s) {\\n    let count = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (!s[i+1] || !s[i+2]) break;\\n        if (s[i] !== s[i+1] && s[i] !== s[i+2] && s[i+1] !== s[i+2]) count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countGoodSubstrings = function(s) {\\n    let count = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (!s[i+1] || !s[i+2]) break;\\n        if (s[i] !== s[i+1] && s[i] !== s[i+2] && s[i+1] !== s[i+2]) count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040602,
                "title": "sliding-window-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int j=0;\\n        int i=0;\\n        int n=s.length();\\n        int ans=0;\\n        unordered_map<char,int> m;\\n\\n        while(j<n){\\n            m[s[j]]++;\\n\\n            if(j-i+1 < 3){\\n                j++;\\n            }else{\\n                if(m.size()==3){\\n                    ans++;\\n                }\\n                m[s[i]]--;\\n                if(m[s[i]]==0){\\n                    m.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int j=0;\\n        int i=0;\\n        int n=s.length();\\n        int ans=0;\\n        unordered_map<char,int> m;\\n\\n        while(j<n){\\n            m[s[j]]++;\\n\\n            if(j-i+1 < 3){\\n                j++;\\n            }else{\\n                if(m.size()==3){\\n                    ans++;\\n                }\\n                m[s[i]]--;\\n                if(m[s[i]]==0){\\n                    m.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918330,
                "title": "java-easy-solution-using-one-single-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count=0;\\n\\n        for(int i=0;i<s.length()-2;i++){\\n            if((s.charAt(i)!=s.charAt(i+1))&&(s.charAt(i)!=s.charAt(i+2))&&(s.charAt(i+2)!=s.charAt(i+1))){\\n                count++;\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count=0;\\n\\n        for(int i=0;i<s.length()-2;i++){\\n            if((s.charAt(i)!=s.charAt(i+1))&&(s.charAt(i)!=s.charAt(i+2))&&(s.charAt(i+2)!=s.charAt(i+1))){\\n                count++;\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880268,
                "title": "easy-understandable",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int cnt = 0;\\n        int sz = s.size();\\n        if(sz<3)return 0;\\n        for(int i = 0; i < sz-2; i++){\\n            string sb = s.substr(i,3);\\n            sort(sb.begin(),sb.end());\\n            for(int j = 0; j < 3; j++){\\n                if(j==2)cnt++;\\n                else if(sb[j]==sb[j+1])break;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int cnt = 0;\\n        int sz = s.size();\\n        if(sz<3)return 0;\\n        for(int i = 0; i < sz-2; i++){\\n            string sb = s.substr(i,3);\\n            sort(sb.begin(),sb.end());\\n            for(int j = 0; j < 3; j++){\\n                if(j==2)cnt++;\\n                else if(sb[j]==sb[j+1])break;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782904,
                "title": "easy-java-solution-clean-code-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int start = 0;\\n        int end = 0;\\n        int ans = 0;\\n        int count = 0;\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        while(end < s.length()) {\\n\\n            if(!map.containsKey(s.charAt(end))) {\\n\\n                map.put((s.charAt(end)), 1);\\n                count++;\\n            }\\n\\n            else {\\n\\n                map.put(s.charAt(end), map.get(s.charAt(end)) + 1);\\n\\n                if(map.get(s.charAt(end)) == 1) {\\n                    count++;\\n                }\\n            }\\n\\n            if(end - start + 1 < 3) {\\n                end++;\\n            }\\n\\n            else {\\n                if(count == 3) {\\n                    ans++;\\n                }\\n\\n                if(map.containsKey(s.charAt(start))) {\\n\\n                    map.put((s.charAt(start)), map.get(s.charAt(start)) - 1);\\n\\n                    if(map.get(s.charAt(start)) == 0) {\\n                        count--;\\n                    }\\n                }\\n                \\n                start++;\\n                end++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int start = 0;\\n        int end = 0;\\n        int ans = 0;\\n        int count = 0;\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        while(end < s.length()) {\\n\\n            if(!map.containsKey(s.charAt(end))) {\\n\\n                map.put((s.charAt(end)), 1);\\n                count++;\\n            }\\n\\n            else {\\n\\n                map.put(s.charAt(end), map.get(s.charAt(end)) + 1);\\n\\n                if(map.get(s.charAt(end)) == 1) {\\n                    count++;\\n                }\\n            }\\n\\n            if(end - start + 1 < 3) {\\n                end++;\\n            }\\n\\n            else {\\n                if(count == 3) {\\n                    ans++;\\n                }\\n\\n                if(map.containsKey(s.charAt(start))) {\\n\\n                    map.put((s.charAt(start)), map.get(s.charAt(start)) - 1);\\n\\n                    if(map.get(s.charAt(start)) == 0) {\\n                        count--;\\n                    }\\n                }\\n                \\n                start++;\\n                end++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706864,
                "title": "very-easy-solution-using-set-and-only-one-loop-and-one-condition",
                "content": "# Code\\n``` Javascript []\\nfunction countGoodSubstrings(s){\\n    let res = 0\\n    for(let i = 0; i < s.length; i++){\\n        if(new Set(s.substring( i, i+3)).size === 3) res++\\n    }\\n    return res\\n};\\n```\\n``` Typescript []\\nfunction countGoodSubstrings(s: string): number {\\n    let res: number = 0\\n    for(let i: number = 0; i < s.length; i++){\\n        if(new Set<string>(s.substring( i, i+3)).size === 3) res++\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` Javascript []\\nfunction countGoodSubstrings(s){\\n    let res = 0\\n    for(let i = 0; i < s.length; i++){\\n        if(new Set(s.substring( i, i+3)).size === 3) res++\\n    }\\n    return res\\n};\\n```\n``` Typescript []\\nfunction countGoodSubstrings(s: string): number {\\n    let res: number = 0\\n    for(let i: number = 0; i < s.length; i++){\\n        if(new Set<string>(s.substring( i, i+3)).size === 3) res++\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3573719,
                "title": "o-n-substrings-of-size-three-with-distinct-characters-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i, count=0;\\n        if(s.length()<3)\\n            return 0;\\n        for(i=0 ; i<s.length()-2 ; i++)\\n        {\\n            if(s[i]!=s[i+1] && s[i+1]!=s[i+2] && s[i+2]!=s[i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/972e7951-f10d-45c5-8bcc-abe476d8f044_1685332135.679337.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i, count=0;\\n        if(s.length()<3)\\n            return 0;\\n        for(i=0 ; i<s.length()-2 ; i++)\\n        {\\n            if(s[i]!=s[i+1] && s[i+1]!=s[i+2] && s[i+2]!=s[i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510529,
                "title": "big-brian-genuis-solution-beats-100000",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse your brian\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse as many method call as possible\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSUPER FAST\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWhat\\'s that?\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        LinkedHashSet<Character> set = new LinkedHashSet<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (set.size() != 3) {\\n                while (!set.add(s.charAt(i))) {\\n                    set.remove(set.iterator().next());\\n                }\\n            }\\n            else {\\n                count++;\\n                set.remove(set.iterator().next());\\n                while (!set.add(s.charAt(i))) {\\n                    set.remove(set.iterator().next());\\n                }\\n            }\\n        }\\n        if (set.size() == 3) {\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        LinkedHashSet<Character> set = new LinkedHashSet<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (set.size() != 3) {\\n                while (!set.add(s.charAt(i))) {\\n                    set.remove(set.iterator().next());\\n                }\\n            }\\n            else {\\n                count++;\\n                set.remove(set.iterator().next());\\n                while (!set.add(s.charAt(i))) {\\n                    set.remove(set.iterator().next());\\n                }\\n            }\\n        }\\n        if (set.size() == 3) {\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433317,
                "title": "python-99-92-faster-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        n = len(s)\\n        if n < 3:\\n            return 0\\n        count = 0\\n        for idx in range((n-3)+1):\\n            subString = s[idx:idx+3]\\n            unique_word_len = len(set(subString))\\n            if unique_word_len == 3:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        n = len(s)\\n        if n < 3:\\n            return 0\\n        count = 0\\n        for idx in range((n-3)+1):\\n            subString = s[idx:idx+3]\\n            unique_word_len = len(set(subString))\\n            if unique_word_len == 3:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336698,
                "title": "1876-substrings-of-size-three-with-distinct-characters-java",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0,j=0,k=3,cnt=0;\\n        while(j<s.length())\\n        {\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(i+2)&&s.charAt(i)!=s.charAt(i+2))\\n                    cnt++;\\n                  i++;\\n                  j++;  \\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0,j=0,k=3,cnt=0;\\n        while(j<s.length())\\n        {\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(i+2)&&s.charAt(i)!=s.charAt(i+2))\\n                    cnt++;\\n                  i++;\\n                  j++;  \\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291434,
                "title": "python-one-line-o-n",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        \\n        return sum(s[i] != s[i+1] and s[i]!= s[i+2] and s[i+1] != s[i+2] for i in range(len(s)-2))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        \\n        return sum(s[i] != s[i+1] and s[i]!= s[i+2] and s[i+1] != s[i+2] for i in range(len(s)-2))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147175,
                "title": "python-easy-beats-80-hashmap",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\n        l = 0\\n        r = 2\\n        count=0\\n\\n        while(r<len(s)):\\n            new = {}\\n            for i in range(l,r+1):\\n                new[s[i]] = 1 + new.get(s[i],0)\\n\\n            flag = True    \\n\\n            for i in new.values():\\n                if i>1:\\n                    flag=False\\n            if flag == True:\\n                count+=1   \\n            l+=1\\n            r+=1\\n\\n        return count             \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\n        l = 0\\n        r = 2\\n        count=0\\n\\n        while(r<len(s)):\\n            new = {}\\n            for i in range(l,r+1):\\n                new[s[i]] = 1 + new.get(s[i],0)\\n\\n            flag = True    \\n\\n            for i in new.values():\\n                if i>1:\\n                    flag=False\\n            if flag == True:\\n                count+=1   \\n            l+=1\\n            r+=1\\n\\n        return count             \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082466,
                "title": "python-solution-o-n-approach-using-sliding-window-beats-92-submissions",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        k=3\\n        i=0 \\n        j=0 \\n        n=len(s)\\n        count=0\\n        while j<n:\\n            if j-i+1<k:\\n                j+=1\\n            elif j-i+1==k:\\n                if s[i]!=s[i+1] and s[i+1]!=s[i+2] and s[i+2]!=s[i]:\\n                    count+=1 \\n                i+=1 \\n                j+=1\\n        return count\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        k=3\\n        i=0 \\n        j=0 \\n        n=len(s)\\n        count=0\\n        while j<n:\\n            if j-i+1<k:\\n                j+=1\\n            elif j-i+1==k:\\n                if s[i]!=s[i+1] and s[i+1]!=s[i+2] and s[i+2]!=s[i]:\\n                    count+=1 \\n                i+=1 \\n                j+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892544,
                "title": "c-simple-o-n-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n        var result = 0;\\n        for(int i=0;i<s.Length-2;i++){\\n            if(s[i] != s[i+1] && s[i+1] != s[i+2] && s[i+2] != s[i]){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n        var result = 0;\\n        for(int i=0;i<s.Length-2;i++){\\n            if(s[i] != s[i+1] && s[i+1] != s[i+2] && s[i+2] != s[i]){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876553,
                "title": "brute-force-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\n      //since the minimum length of the substring should be 3 \\n      if(s.length()<3) return 0;\\n      \\n      /* traverse the string and check if a substring of size 3 consists of all distinct characters and increment the ans variable */\\n      int ans = 0;\\n      for(int i=0;i<s.length()-2;++i){\\n         if(s[i]!=s[i+1] && s[i+1]!=s[i+2] && s[i]!=s[i+2]) ans++; \\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\n      //since the minimum length of the substring should be 3 \\n      if(s.length()<3) return 0;\\n      \\n      /* traverse the string and check if a substring of size 3 consists of all distinct characters and increment the ans variable */\\n      int ans = 0;\\n      for(int i=0;i<s.length()-2;++i){\\n         if(s[i]!=s[i+1] && s[i+1]!=s[i+2] && s[i]!=s[i+2]) ans++; \\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836229,
                "title": "substrings-of-size-three-with-distinct-characters",
                "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length() == 0){\\n            return 0;\\n        }\\n        \\n        int windowStart = 0;\\n        int wLength = 0;\\n      \\n        \\n        for(int windowEnd = 0;windowEnd < s.length() -2 ;windowEnd++){\\n            if(s.charAt(windowEnd) != s.charAt(windowEnd+1) &&  s.charAt(windowEnd+1) != s.charAt(windowEnd+2) && s.charAt(windowEnd) != s.charAt(windowEnd+2)){\\n                    windowStart += s.charAt(windowEnd);\\n            }\\n            \\n               if(windowStart >= 3){\\n                    wLength++;\\n                    windowStart = windowStart - s.charAt(windowEnd);\\n                }\\n            }\\n        \\n        \\n       return wLength;\\n    }\\n}\\n****\\n// useing the sliding window Technique \\n//Time Complexity: O(n3) = O(n) Solution\\n// where 3 is the size of the window\\n******",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length() == 0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2819908,
                "title": "python3-solution-o-n-time-complexity-using-sliding-window",
                "content": "Approach:\\nSlidding Window Technique:\\n1. At each ith position slice the string from i to i + 3 and count the letters\\n2. If there is a substring with all elements with count one, then the substring will be counted else the substring will be skipped\\n3. Then finally return the number of substrings that are good in the given criteria.\\n\\n```\\ndef countGoodSubstrings(self, s: str) -> int:\\n\\ti = 0\\n\\tnumberOfSubstring = 0\\n\\twhile i + 3 <= len(s):\\n\\t\\tfirst3 = s[i:i+3]\\n\\t\\tcountFirst3 = Counter(first3)\\n\\t\\tisOne = True\\n\\t\\tfor letter in countFirst3:\\n\\t\\t\\tif countFirst3[letter] != 1:\\n\\t\\t\\t\\tisOne = False\\n\\t\\tif isOne:\\n\\t\\t\\tnumberOfSubstring +=1\\n\\t\\ti +=1\\n\\treturn numberOfSubstring",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Approach:\\nSlidding Window Technique:\\n1. At each ith position slice the string from i to i + 3 and count the letters\\n2. If there is a substring with all elements with count one, then the substring will be counted else the substring will be skipped\\n3. Then finally return the number of substrings that are good in the given criteria.\\n\\n```\\ndef countGoodSubstrings(self, s: str) -> int:\\n\\ti = 0\\n\\tnumberOfSubstring = 0\\n\\twhile i + 3 <= len(s):\\n\\t\\tfirst3 = s[i:i+3]\\n\\t\\tcountFirst3 = Counter(first3)\\n\\t\\tisOne = True\\n\\t\\tfor letter in countFirst3:\\n\\t\\t\\tif countFirst3[letter] != 1:\\n\\t\\t\\t\\tisOne = False\\n\\t\\tif isOne:\\n\\t\\t\\tnumberOfSubstring +=1\\n\\t\\ti +=1\\n\\treturn numberOfSubstring",
                "codeTag": "Python3"
            },
            {
                "id": 2596839,
                "title": "easy-understanding-brute-force-using-python",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        substr = []\\n        counter = 0\\n        for i in range(0,len(s)):\\n            if i <= len(s)-3:\\n                substr.append(s[i:i+3])\\n            else:\\n                break\\n        for i in range(len(substr)):\\n            if len(substr[i]) == len(set(substr[i])):\\n                counter += 1\\n        return counter\\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        substr = []\\n        counter = 0\\n        for i in range(0,len(s)):\\n            if i <= len(s)-3:\\n                substr.append(s[i:i+3])\\n            else:\\n                break\\n        for i in range(len(substr)):\\n            if len(substr[i]) == len(set(substr[i])):\\n                counter += 1\\n        return counter\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568306,
                "title": "sliding-window-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        \\n        int i = 0, j = 0;\\n        int count = 0;\\n        while(j < s.length())\\n        {\\n            if(j - i + 1 == 3)\\n            {\\n                char ch1 = s[j];\\n                char ch2 = s[j - 1];\\n                char ch3 = s[j - 2];\\n                if(ch1 != ch2 and ch2 != ch3 and ch1 != ch3)\\n                    count++;\\n                \\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        \\n        int i = 0, j = 0;\\n        int count = 0;\\n        while(j < s.length())\\n        {\\n            if(j - i + 1 == 3)\\n            {\\n                char ch1 = s[j];\\n                char ch2 = s[j - 1];\\n                char ch3 = s[j - 2];\\n                if(ch1 != ch2 and ch2 != ch3 and ch1 != ch3)\\n                    count++;\\n                \\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535673,
                "title": "python-3-multiple-solutions-including-one-liner-most-efficient-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        return sum(len(set(s[i:i+3]))==3 for i in range(len(s)-2))\\n```\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        res=[]\\n        count=0\\n        for i in range(len(s)-2):\\n            res.append(s[i:i+3])\\n        for sub in res:\\n            if len(set(sub))==3:\\n                count+=1\\n        return count\\n```\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3:\\n                count+=1\\n        return count\\n```\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            sub=s[i]+s[i+1]+s[i+2]\\n            if len(set(sub))==3:\\n                count+=1\\n        return count\\n```\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\t\\tcount=0\\n\\t\\tfor a,b,c in zip(s,s[1:],s[2:]):\\n\\t\\t\\tif len({a,b,c})==3:\\n\\t\\t\\t\\tcount+=1\\n\\t\\treturn count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        return sum(len(set(s[i:i+3]))==3 for i in range(len(s)-2))\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        res=[]\\n        count=0\\n        for i in range(len(s)-2):\\n            res.append(s[i:i+3])\\n        for sub in res:\\n            if len(set(sub))==3:\\n                count+=1\\n        return count\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3:\\n                count+=1\\n        return count\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            sub=s[i]+s[i+1]+s[i+2]\\n            if len(set(sub))==3:\\n                count+=1\\n        return count\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\t\\tcount=0\\n\\t\\tfor a,b,c in zip(s,s[1:],s[2:]):\\n\\t\\t\\tif len({a,b,c})==3:\\n\\t\\t\\t\\tcount+=1\\n\\t\\treturn count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507366,
                "title": "simple-and-easy-to-understand-java-solution-in-o-n-time-complexity",
                "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        int ans = 0;\\n        for(int i = 0;i<s.length()-2;i++)\\n        {\\n            if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2))\\n                ans++;\\n        }\\n               return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        int ans = 0;\\n        for(int i = 0;i<s.length()-2;i++)\\n        {\\n            if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2))\\n                ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2465319,
                "title": "sliding-window-with-size-3",
                "content": "Start at index 2, then check if this char is different from the ones pointed at index-1 and at index-2. If all are different, count +1.\\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) \\n    {\\n        int i = 2, count = 0;\\n        while(i < s.length())\\n        {\\n            char last = s.charAt(i), middle = s.charAt(i-1), first = s.charAt(i-2);\\n            count += (last != middle && middle != first && first != last) ? 1 : 0;\\n            r++;\\n        }\\n        return count;\\n    }\\n```\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) \\n    {\\n        int i = 2, count = 0;\\n        while(i < s.length())\\n        {\\n            char last = s.charAt(i), middle = s.charAt(i-1), first = s.charAt(i-2);\\n            count += (last != middle && middle != first && first != last) ? 1 : 0;\\n            r++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464600,
                "title": "new-one-simple-boolean-trick-applied-aditya-verma-type-modified-solution-sliding-window",
                "content": "**Here u may wonder how boolean works**\\n\\nThe idea is as WINDOW is size 3. Only possibility is either 1st char repeats more than once.\\nOr 2nd Char repeats more than once. \\nSo whenever u slide. If after reduction its 1 then you have eliminated the duplicate from the window\\n\\nDIDNT Get it YET???\\nDont worry\\nLets take cases\\n* aaa  => here after mpp[a]-- you have val as 2 DUPLICATE Not Eliminated if SLIDED\\n* aab => here after mpp[a]-- you have val as 1 DUPLICATE Eliminated if SLIDED\\n* abb => here after mpp[a]-- you have val as 0 DUPLICATE NOT Eliminated if SLIDED. As you removed a element that is unique only.\\n* So if val of map goes to 1 after reduction then char that was repeated is removed is the CRUX of whole Story.\\n\\n\\n```\\n//O(N) time O(1) Space. As always map takes only 3 chars max 26.\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        \\n        unordered_map<char,int> mpp; //char, freq\\n        int i=0;\\n        int j=0;\\n        int N = s.size();\\n        bool flag = true;\\n        int ans_count=0;\\n        \\n        while(j<N){\\n            //calcs\\n            mpp[s[j]]++;\\n            if(mpp[s[j]] >1) flag = false;\\n            \\n            if(j-i+1 < 3){\\n                j++;\\n            }\\n            else if(j-i+1 == 3){\\n                //ans calc\\n                if(flag) ans_count++;\\n                \\n                //slide\\n                char ch = s[i];\\n                mpp[ch]--;\\n                i++;\\n                if(mpp[ch]==1) flag =true;\\n                j++;\\n                \\n            }\\n        }\\n        return ans_count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n//O(N) time O(1) Space. As always map takes only 3 chars max 26.\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        \\n        unordered_map<char,int> mpp; //char, freq\\n        int i=0;\\n        int j=0;\\n        int N = s.size();\\n        bool flag = true;\\n        int ans_count=0;\\n        \\n        while(j<N){\\n            //calcs\\n            mpp[s[j]]++;\\n            if(mpp[s[j]] >1) flag = false;\\n            \\n            if(j-i+1 < 3){\\n                j++;\\n            }\\n            else if(j-i+1 == 3){\\n                //ans calc\\n                if(flag) ans_count++;\\n                \\n                //slide\\n                char ch = s[i];\\n                mpp[ch]--;\\n                i++;\\n                if(mpp[ch]==1) flag =true;\\n                j++;\\n                \\n            }\\n        }\\n        return ans_count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455835,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        string res;\\n        vector<string>sk;\\n        vector<int>end;\\n        int c=0;\\n        if(s.length()==1){return 0;}\\n       for(int i=0;i<s.length()-2;i++){\\n           for(int j=i+1;j<s.length();j++){\\n              res+=s[i];\\n               res+=s[j];\\n               res+=s[j+1];\\n               break;\\n           }\\n        sk.push_back(res);\\n           res=\"\";\\n       }\\n        res=\"\";\\n        for(auto i:sk){\\n            res=i;\\n            cout<<res<<\" \";\\n            for(int j=0;j<res.length()-2;j++){\\n                if(res[j]!=res[j+1] && res[j]!=res[j+2] && res[j+1]!=res[j+2]){\\n                    end.push_back(1);\\n                }\\n                else{\\n                    end.push_back(2);\\n                }\\n            }\\n            }\\n        \\n        for(auto i:end){\\n            if(i==1){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        string res;\\n        vector<string>sk;\\n        vector<int>end;\\n        int c=0;\\n        if(s.length()==1){return 0;}\\n       for(int i=0;i<s.length()-2;i++){\\n           for(int j=i+1;j<s.length();j++){\\n              res+=s[i];\\n               res+=s[j];\\n               res+=s[j+1];\\n               break;\\n           }\\n        sk.push_back(res);\\n           res=\"\";\\n       }\\n        res=\"\";\\n        for(auto i:sk){\\n            res=i;\\n            cout<<res<<\" \";\\n            for(int j=0;j<res.length()-2;j++){\\n                if(res[j]!=res[j+1] && res[j]!=res[j+2] && res[j+1]!=res[j+2]){\\n                    end.push_back(1);\\n                }\\n                else{\\n                    end.push_back(2);\\n                }\\n            }\\n            }\\n        \\n        for(auto i:end){\\n            if(i==1){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2446628,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count = 0\\n        l= []\\n        for i in range(0,len(s)-2):\\n            temp = \\'\\'\\n            if s[i] != s[i+1] and s[i+1] != s[i+2] and s[i] != s[i+2]:\\n                temp = s[i]+s[i+1] + s[i+2]\\n                count = count + 1\\n        return count\\nRuntime: 38 ms, faster than 85.92% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count = 0\\n        l= []\\n        for i in range(0,len(s)-2):\\n            temp = \\'\\'\\n            if s[i] != s[i+1] and s[i+1] != s[i+2] and s[i] != s[i+2]:\\n                temp = s[i]+s[i+1] + s[i+2]\\n                count = count + 1\\n        return count\\nRuntime: 38 ms, faster than 85.92% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440972,
                "title": "simple-sliding-window-o-n",
                "content": "The solution uses simple dynamic sliding window approach. Instead of matching the characters we are checking their last occurrance using a map and if found we are shifting the \\'start\\' of our window to \\'last_occurrance_index + 1\\' position. If the last occurrance is less than the start of our window then we can keep the start as it is because the last occurrance is not in the scope of our current window. \\n\\nOnce this is done, we are calculating the size of current window by using (end - start + 1) and if the answer is equal to or greater than our N=3 the increamenting the counter by 1 and we are done.\\n\\nNote - The original question is asked for fixed size sub array but here we can change the value of N to tackle the follow up questions :-)\\n\\n```\\nvar countGoodSubstrings = function(s) {\\n    const n = 3;\\n    let count = 0;\\n    const map = {};\\n    let start = 0;\\n    for (let end = 0; end < s.length; end++) {\\n        const item = s[end]\\n        if (item in map) {\\n            start = Math.max(start, map[item] + 1)\\n        }\\n        map[item] = end\\n        const size = end - start + 1\\n        \\n        if (size >= n) {\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar countGoodSubstrings = function(s) {\\n    const n = 3;\\n    let count = 0;\\n    const map = {};\\n    let start = 0;\\n    for (let end = 0; end < s.length; end++) {\\n        const item = s[end]\\n        if (item in map) {\\n            start = Math.max(start, map[item] + 1)\\n        }\\n        map[item] = end\\n        const size = end - start + 1\\n        \\n        if (size >= n) {\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437224,
                "title": "c-solution-for-a-general-case-using-unordered-map",
                "content": "This solution will work even for a general window size of k (here given 3).\\n\\nFor creating the window have created a unordered_map which will store the elements. If an elements value becomes equal to 2 in the map it means it is duplicate so we will increment the `duplicate`.\\nAfter the iteration we remove the first element of window from map and if it\\'s value becomes 1 in `umap` it means it is no longer a duplicate so decrement duplicate by 1. \\n\\nWe will only increment answer variable only if duplicate is = 0.\\n```\\n  int countGoodSubstrings(string s) {\\n        if(s.length()<3) return 0;\\n        int n = s.length();\\n        unordered_map<char, int> umap;\\n        int duplicate = 0;\\n        int count = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            umap[s[i]]++; // insert in the window\\n            if(umap[s[i]]==2) duplicate++;\\n            if(i<2) continue; // if this satisfies we don\\'t need to remove anything from map neither increment count the first window is being created\\n            if(!duplicate) count++;\\n            umap[s[i-2]]--;  // remove from the window\\n            if(umap[s[i-2]]==1) duplicate--;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  int countGoodSubstrings(string s) {\\n        if(s.length()<3) return 0;\\n        int n = s.length();\\n        unordered_map<char, int> umap;\\n        int duplicate = 0;\\n        int count = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            umap[s[i]]++; // insert in the window\\n            if(umap[s[i]]==2) duplicate++;\\n            if(i<2) continue; // if this satisfies we don\\'t need to remove anything from map neither increment count the first window is being created\\n            if(!duplicate) count++;\\n            umap[s[i-2]]--;  // remove from the window\\n            if(umap[s[i-2]]==1) duplicate--;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2393723,
                "title": "python-o-n-sliding-window",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        counter = 0\\n        for i in range(len(s) - 2):\\n            if len(set(s[i:i+3])) == 3:\\n                counter += 1\\n        return counter\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        counter = 0\\n        for i in range(len(s) - 2):\\n            if len(set(s[i:i+3])) == 3:\\n                counter += 1\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336890,
                "title": "python-short-simple-set",
                "content": "```\\ndef countGoodSubstrings(self, s: str) -> int:\\n        cnt = 0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3])) == 3:\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\ndef countGoodSubstrings(self, s: str) -> int:\\n        cnt = 0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3])) == 3:\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2327279,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        for(int i=0;i<s.length()-2;i++){\\n            String str = s.substring(i,i+3);\\n            if((str.charAt(0) != str.charAt(1)) && (str.charAt(1) != str.charAt(2)) && (str.charAt(0) != str.charAt(2))){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        for(int i=0;i<s.length()-2;i++){\\n            String str = s.substring(i,i+3);\\n            if((str.charAt(0) != str.charAt(1)) && (str.charAt(1) != str.charAt(2)) && (str.charAt(0) != str.charAt(2))){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321627,
                "title": "easy-c-3-line-solution-with-o-n-approach",
                "content": "Here we will use sliding window technique by taking the window size as 3 according to the details given.\\nrun a loop till the string length.\\nwith each iteration, check the current 3 variables if they are same and increase count if true;\\n\\n\\t\\n\\t\\tint countGoodSubstrings(string s) {\\n\\t\\t\\tint count=0;\\n\\n\\t\\t\\tfor(int i=0;i+3<=s.length();i++) \\n\\t\\t\\tif((s[i]!=s[i+1]) && (s[i]!=s[i+2]) && (s[i+1]!=s[i+2])) count++;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "Here we will use sliding window technique by taking the window size as 3 according to the details given.\\nrun a loop till the string length.\\nwith each iteration, check the current 3 variables if they are same and increase count if true;\\n\\n\\t\\n\\t\\tint countGoodSubstrings(string s) {\\n\\t\\t\\tint count=0;\\n\\n\\t\\t\\tfor(int i=0;i+3<=s.length();i++) \\n\\t\\t\\tif((s[i]!=s[i+1]) && (s[i]!=s[i+2]) && (s[i+1]!=s[i+2])) count++;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2276337,
                "title": "c-sliding-window-sets-straightforward",
                "content": "![image](https://assets.leetcode.com/users/images/6e09450a-70cc-4736-865e-721641a98f97_1657705720.691491.png)\\n\\n**n==s.size()\\nT->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t//  Sliding window of constant length!\\n\\t\\tint countGoodSubstrings(string s) {\\n\\t\\t\\tunordered_set<char>st;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i+2<s.size();i++){\\n\\t\\t\\t\\tfor(int j=i;j<=i+2;j++) st.insert(s[j]);\\n\\t\\t\\t\\tif(st.size()==3)count++;\\n\\t\\t\\t\\tst.clear();\\n\\t\\t\\t}    \\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t//  Sliding window of constant length!\\n\\t\\tint countGoodSubstrings(string s) {\\n\\t\\t\\tunordered_set<char>st;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i+2<s.size();i++){\\n\\t\\t\\t\\tfor(int j=i;j<=i+2;j++) st.insert(s[j]);\\n\\t\\t\\t\\tif(st.size()==3)count++;\\n\\t\\t\\t\\tst.clear();\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2251130,
                "title": "java-sliding-window-1-ms",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if (s.length() < 3) return 0;\\n        int count = 0;\\n        for (int i = 0; i + 2 < s.length(); i++) {\\n            if (s.charAt(i) != s.charAt(i + 1) &&\\n                s.charAt(i + 1) != s.charAt(i + 2) &&\\n                s.charAt(i + 2) != s.charAt(i)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if (s.length() < 3) return 0;\\n        int count = 0;\\n        for (int i = 0; i + 2 < s.length(); i++) {\\n            if (s.charAt(i) != s.charAt(i + 1) &&\\n                s.charAt(i + 1) != s.charAt(i + 2) &&\\n                s.charAt(i + 2) != s.charAt(i)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241562,
                "title": "java-too-easy-solution-using-hashset",
                "content": "```\\nint c=0;\\n        for(int i=0;i<(s.length()-2);i++){\\n            Set<Character> set=new HashSet<>();\\n            set.add(s.charAt(i));\\n            set.add(s.charAt(i+1));\\n            set.add(s.charAt(i+2));\\n            if(set.size()==3)c++;\\n        }\\n        return c;```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint c=0;\\n        for(int i=0;i<(s.length()-2);i++){\\n            Set<Character> set=new HashSet<>();\\n            set.add(s.charAt(i));\\n            set.add(s.charAt(i+1));\\n            set.add(s.charAt(i+2));\\n            if(set.size()==3)c++;\\n        }\\n        return c;```",
                "codeTag": "Unknown"
            },
            {
                "id": 2217193,
                "title": "simple-javascript-solution-using-set-and-for-loop-o-n",
                "content": "\\n\\n\\tvar countGoodSubstrings = function(s) {\\n    let numOfGoodStrings = 0;\\n  \\n    for(let i=1;i<s.length-1;i++) {\\n      numOfGoodStrings += new Set([s[i-1],s[i],s[i+1]]).size===3?1:0;\\n    }\\n    return numOfGoodStrings;\\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "\\n\\n\\tvar countGoodSubstrings = function(s) {\\n    let numOfGoodStrings = 0;\\n  \\n    for(let i=1;i<s.length-1;i++) {\\n      numOfGoodStrings += new Set([s[i-1],s[i],s[i+1]]).size===3?1:0;\\n    }\\n    return numOfGoodStrings;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2195038,
                "title": "java-sliding-window-1-ms-faster-than-96-13-of-java-online-submissions",
                "content": "\\n        int i=0, ct=0;\\n        if(m.length()<3)\\n            return 0;\\n        for(i=1;i<m.length()-1;i++)\\n        {\\n          \\nif(m.charAt(i-1) != m.charAt(i) && m.charAt(i) != m.charAt(i+1) && m.charAt(i+1)!= m.charAt(i-1))\\n                ct++;\\n            \\n        \\n        }\\n        return ct;\\n\\t\\t\\n\\t\\t*** If You like the soution please hit up the like button share any thoughts and other solution  on this question  ****\\n\\t\\tThank You",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "\\n        int i=0, ct=0;\\n        if(m.length()<3)\\n            return 0;\\n        for(i=1;i<m.length()-1;i++)\\n        {\\n          \\nif(m.charAt(i-1) != m.charAt(i) && m.charAt(i) != m.charAt(i+1) && m.charAt(i+1)!= m.charAt(i-1))\\n                ct++;\\n            \\n        \\n        }\\n        return ct;\\n\\t\\t\\n\\t\\t*** If You like the soution please hit up the like button share any thoughts and other solution  on this question  ****\\n\\t\\tThank You",
                "codeTag": "Unknown"
            },
            {
                "id": 2187094,
                "title": "best-solution-and-4-method-in-python",
                "content": "\\tclass Solution:\\n\\t\\tdef countGoodSubstrings(self, s: str) -> int:\\n        \\n        #--------------Method-1---------------------\\n        # ans = 0\\n        # for i in range(3,len(s)+1):\\n        #     if len(set(s[i-3:i])) == 3:\\n        #         ans += 1\\n        # return ans\\n        \\n        #------------Method-2 (sliding window)------------------\\n        # c = 0\\n        # st = list(s[ : 3])\\n        # for i in range(3, len(s)):\\n        #     if len(set(st))==3:\\n        #         c += 1\\n        #     # print(st)\\n        #     st.append(s[i])\\n        #     st.pop(0)\\n        #     # print(st)\\n        # if len(set(st))==3:\\n        #     c += 1\\n        # return c\\n        \\n        #-------------Method-3--------------------\\n        # count=0\\n        # for i in range(len(s)-2):\\n        #     if(s[i]==s[i+1] or s[i+1]==s[i+2] or s[i+2]==s[i]):\\n        #         count+=0\\n        #     else:\\n        #         count+=1\\n        # return count\\n        \\n        #----------Method-4 (Using Map/Counting )----------------------\\n        if len(s) <3:\\n            return 0\\n        mp = {}\\n        c = 0\\n        left_window = 0\\n        right_window = 1\\n        for i in range(2):\\n            if s[i] not in mp:\\n                mp[s[i]] = 0\\n            mp[s[i]] += 1\\n            #--------OR-------\\n            # if s[i] in mp:\\n            #     mp[s[i]] += 1\\n            # else:\\n            #     mp[s[i]] = 1\\n        # print(mp)\\n        while right_window < len(s)-1 :\\n            right_window += 1\\n            if s[right_window] not in mp:\\n                  mp[s[right_window]] = 0\\n            mp[s[right_window]] += 1\\n            # print(mp)\\n            if all([mp[x]<2 for x in mp]):\\n                c += 1\\n                # print(all([mp[x]<2 for x in mp]))\\n            mp[s[left_window]] -=1\\n            left_window += 1\\n            # print(mp)\\n        return c",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\t\\tdef countGoodSubstrings(self, s: str) -> int:\\n        \\n        #--------------Method-1---------------------\\n        # ans = 0\\n        # for i in range(3,len(s)+1):\\n        #     if len(set(s[i-3:i])) == 3:\\n        #         ans += 1\\n        # return ans\\n        \\n        #------------Method-2 (sliding window)------------------\\n        # c = 0\\n        # st = list(s[ : 3])\\n        # for i in range(3, len(s)):\\n        #     if len(set(st))==3:\\n        #         c += 1\\n        #     # print(st)\\n        #     st.append(s[i])\\n        #     st.pop(0)\\n        #     # print(st)\\n        # if len(set(st))==3:\\n        #     c += 1\\n        # return c\\n        \\n        #-------------Method-3--------------------\\n        # count=0\\n        # for i in range(len(s)-2):\\n        #     if(s[i]==s[i+1] or s[i+1]==s[i+2] or s[i+2]==s[i]):\\n        #         count+=0\\n        #     else:\\n        #         count+=1\\n        # return count\\n        \\n        #----------Method-4 (Using Map/Counting )----------------------\\n        if len(s) <3:\\n            return 0\\n        mp = {}",
                "codeTag": "Java"
            },
            {
                "id": 2172777,
                "title": "easy-java-solution-o-n-loop",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length() < 3){\\n            return 0;\\n        }\\n        int count = 0;\\n        for(int i = 0; i< s.length() - 2; i++){\\n            if(s.charAt(i) != s.charAt(i+1) && s.charAt(i) != s.charAt(i+2) && s.charAt(i+1) != s.charAt(i+2)){\\n                count++;    \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length() < 3){\\n            return 0;\\n        }\\n        int count = 0;\\n        for(int i = 0; i< s.length() - 2; i++){\\n            if(s.charAt(i) != s.charAt(i+1) && s.charAt(i) != s.charAt(i+2) && s.charAt(i+1) != s.charAt(i+2)){\\n                count++;    \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166220,
                "title": "simple-c-sliding-window-approach-o-n",
                "content": "```\\nint countGoodSubstrings(string s) \\n    {\\n        int i=0;\\n        int j=2;\\n        int c=0;\\n        \\n        while(j<s.length())\\n        {\\n            if(s[i+1]!=s[i] && s[i]!=s[j] && s[j-1]!=s[j])\\n                c++;\\n            i++;\\n            j++;\\n        }\\n     return c;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint countGoodSubstrings(string s) \\n    {\\n        int i=0;\\n        int j=2;\\n        int c=0;\\n        \\n        while(j<s.length())\\n        {\\n            if(s[i+1]!=s[i] && s[i]!=s[j] && s[j-1]!=s[j])\\n                c++;\\n            i++;\\n            j++;\\n        }\\n     return c;   \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2151101,
                "title": "simple-and-best-by-aditya-verma",
                "content": "first, create window size of 3, once created maintain it and check condition.\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        unordered_map<char,int> m;\\n        if(s.length()<3) return 0;\\n        int i=0,count=0,j=0,n=s.length();\\n        while(j<n){\\n            m[s[j]]++;\\n            if(j-i+1<3) j++;\\n            else if(j-i+1==3){\\n                if(m.size()==3) count++;\\n                j++;\\n                m[s[i]]--;\\n                if(m[s[i]]==0) m.erase(s[i]);\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        unordered_map<char,int> m;\\n        if(s.length()<3) return 0;\\n        int i=0,count=0,j=0,n=s.length();\\n        while(j<n){\\n            m[s[j]]++;\\n            if(j-i+1<3) j++;\\n            else if(j-i+1==3){\\n                if(m.size()==3) count++;\\n                j++;\\n                m[s[i]]--;\\n                if(m[s[i]]==0) m.erase(s[i]);\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147861,
                "title": "c-fast-easy-simple-unique",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int start = 0;\\n        unordered_map<int,int>ump;\\n        int end = 0;\\n        int ans = 0;\\n        for( end = 0 ; end < 3 && end<s.size() ;end++){\\n            ump[s[end]]++;\\n        }\\n        if(end!=3){\\n            return ans;\\n        }\\n        if(ump.size() == end - start){\\n            ans += 1;\\n        }\\n        for(;end<s.size() ; end++){\\n            ump[s[start]]--;\\n            if(ump[s[start]] == 0){\\n                ump.erase(s[start]);\\n            }\\n            start++;\\n            ump[s[end]]++;\\n            if(ump.size() == end - start +1 ){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int start = 0;\\n        unordered_map<int,int>ump;\\n        int end = 0;\\n        int ans = 0;\\n        for( end = 0 ; end < 3 && end<s.size() ;end++){\\n            ump[s[end]]++;\\n        }\\n        if(end!=3){\\n            return ans;\\n        }\\n        if(ump.size() == end - start){\\n            ans += 1;\\n        }\\n        for(;end<s.size() ; end++){\\n            ump[s[start]]--;\\n            if(ump[s[start]] == 0){\\n                ump.erase(s[start]);\\n            }\\n            start++;\\n            ump[s[end]]++;\\n            if(ump.size() == end - start +1 ){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121793,
                "title": "easiet-java-solution-100-faster",
                "content": "int count = 0;\\n        for(int i = 0; i < s.length() - 2; i++){\\n            if(s.charAt(i) != s.charAt(i+1) && s.charAt(i) != s.charAt(i+2) && s.charAt(i+1) != s.charAt(i+2)){\\n                count++;\\n            }\\n        }\\n        return count;",
                "solutionTags": [],
                "code": "int count = 0;\\n        for(int i = 0; i < s.length() - 2; i++){\\n            if(s.charAt(i) != s.charAt(i+1) && s.charAt(i) != s.charAt(i+2) && s.charAt(i+1) != s.charAt(i+2)){\\n                count++;\\n            }\\n        }\\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 2089344,
                "title": "java-using-sliding-window",
                "content": "```\\npublic int countGoodSubstrings(String s) {\\n        Set<String>st=new HashSet();\\n        int co=0;\\n        int i=0;\\n        int j=2;\\n        while(j<s.length()){\\n            if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(j)&&s.charAt(j)!=s.charAt(i)){\\n                 co++;\\n        }\\n            i++;\\n            j++;\\n        }\\n        return co;\\n        \\n        \\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countGoodSubstrings(String s) {\\n        Set<String>st=new HashSet();\\n        int co=0;\\n        int i=0;\\n        int j=2;\\n        while(j<s.length()){\\n            if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(j)&&s.charAt(j)!=s.charAt(i)){\\n                 co++;\\n        }\\n            i++;\\n            j++;\\n        }\\n        return co;\\n        \\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2034244,
                "title": "golang-o-n-sliding-windows",
                "content": "substring is valid if all chars are uniq. So we can check if there\\'s no duplication in the substring (identified by windows of size k)\\n\\n```\\nfunc countGoodSubstrings(s string) int {\\n    // sliding windows of size k\\n    // condition: all uniq chars ~ no duplication\\n    // count the char frequency via freq\\n    freq := make([]int, 128)\\n    ans, dup := 0, 0\\n    for i := 0; i < len(s); i++ {\\n        freq[s[i]]++\\n        if freq[s[i]] == 2 { // duplicate found\\n            dup++\\n        }\\n        \\n\\t\\t// check if window size met\\n        if i < 2 {\\n            continue\\n        }\\n\\n        // is substring valid\\n        if dup == 0 {\\n            ans++\\n        }\\n        // resize windows from left side\\n        freq[s[i - 2]]--\\n        if freq[s[i - 2]] == 1 { // no longer dup, freq decreases from 2 or higher to 1\\n            dup--\\n        }\\n    }\\n    return ans\\n}\\n```\\n\\nComplexity: O(N) time, O(1) space.\\nWe may use `freq := make([]int, 26)` but updating frequency for char would need to change to `freq[s[i] - \\'a\\']`",
                "solutionTags": [
                    "Go",
                    "Sliding Window"
                ],
                "code": "```\\nfunc countGoodSubstrings(s string) int {\\n    // sliding windows of size k\\n    // condition: all uniq chars ~ no duplication\\n    // count the char frequency via freq\\n    freq := make([]int, 128)\\n    ans, dup := 0, 0\\n    for i := 0; i < len(s); i++ {\\n        freq[s[i]]++\\n        if freq[s[i]] == 2 { // duplicate found\\n            dup++\\n        }\\n        \\n\\t\\t// check if window size met\\n        if i < 2 {\\n            continue\\n        }\\n\\n        // is substring valid\\n        if dup == 0 {\\n            ans++\\n        }\\n        // resize windows from left side\\n        freq[s[i - 2]]--\\n        if freq[s[i - 2]] == 1 { // no longer dup, freq decreases from 2 or higher to 1\\n            dup--\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2004084,
                "title": "c-easy-sliding-window-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        unordered_map<char,int>mp;\\n        int winStart=0;\\n        int ans=0;\\n        for(int winEnd=0; winEnd<s.size(); winEnd++){\\n            mp[s[winEnd]]++;\\n            int count=mp.size();\\n            if(winEnd>=3-1){\\n                mp[s[winStart]]--;\\n                if (mp[s[winStart]] == 0) {\\n                    mp.erase(s[winStart]);\\n                }\\n                 if(count==3){\\n                    ans++;\\n                }\\n                winStart++; \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        unordered_map<char,int>mp;\\n        int winStart=0;\\n        int ans=0;\\n        for(int winEnd=0; winEnd<s.size(); winEnd++){\\n            mp[s[winEnd]]++;\\n            int count=mp.size();\\n            if(winEnd>=3-1){\\n                mp[s[winStart]]--;\\n                if (mp[s[winStart]] == 0) {\\n                    mp.erase(s[winStart]);\\n                }\\n                 if(count==3){\\n                    ans++;\\n                }\\n                winStart++; \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992350,
                "title": "python-solution-one-liner",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s):\\n        count = 0\\n        \\n        for i in range(2, len(s)):\\n            if len(set(s[i-2:i+1])) == 3:\\n                count += 1\\n        \\n        return count\\n```\\n\\n**One-Liner**:\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s):\\n        return sum(len(set(s[i-2:i+1])) == 3 for i in range(2, len(s)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s):\\n        count = 0\\n        \\n        for i in range(2, len(s)):\\n            if len(set(s[i-2:i+1])) == 3:\\n                count += 1\\n        \\n        return count\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s):\\n        return sum(len(set(s[i-2:i+1])) == 3 for i in range(2, len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943515,
                "title": "python-concise-solution",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        count = 0\\n        currString = \"\"\\n    \\n        for i in range(0, len(s) - 2):\\n            currString = s[i:i+3]\\n\\n            if len(set(currString)) == len(currString):\\n                count += 1\\n\\t\\t\\t\\t\\n            currString = \"\"\\n        \\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        count = 0\\n        currString = \"\"\\n    \\n        for i in range(0, len(s) - 2):\\n            currString = s[i:i+3]\\n\\n            if len(set(currString)) == len(currString):\\n                count += 1\\n\\t\\t\\t\\t\\n            currString = \"\"\\n        \\n        return count",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1717329,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1964571,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1733429,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2042625,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2035853,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1992869,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1926601,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]