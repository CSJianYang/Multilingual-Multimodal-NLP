[
    {
        "title": "Design Bitset",
        "question_content": "A Bitset is a data structure that compactly stores bits.\nImplement the Bitset class:\n\n\tBitset(int size) Initializes the Bitset with size bits, all of which are 0.\n\tvoid fix(int idx) Updates the value of the bit at the index idx to 1. If the value was already 1, no change occurs.\n\tvoid unfix(int idx) Updates the value of the bit at the index idx to 0. If the value was already 0, no change occurs.\n\tvoid flip() Flips the values of each bit in the Bitset. In other words, all bits with value 0 will now have value 1 and vice versa.\n\tboolean all() Checks if the value of each bit in the Bitset is 1. Returns true if it satisfies the condition, false otherwise.\n\tboolean one() Checks if there is at least one bit in the Bitset with value 1. Returns true if it satisfies the condition, false otherwise.\n\tint count() Returns the total number of bits in the Bitset which have value 1.\n\tString toString() Returns the current composition of the Bitset. Note that in the resultant string, the character at the ith index should coincide with the value at the ith bit of the Bitset.\n\n&nbsp;\nExample 1:\n\nInput\n[\"Bitset\", \"fix\", \"fix\", \"flip\", \"all\", \"unfix\", \"flip\", \"one\", \"unfix\", \"count\", \"toString\"]\n[[5], [3], [1], [], [], [0], [], [], [0], [], []]\nOutput\n[null, null, null, null, false, null, null, true, null, 2, \"01010\"]\nExplanation\nBitset bs = new Bitset(5); // bitset = \"00000\".\nbs.fix(3);     // the value at idx = 3 is updated to 1, so bitset = \"00010\".\nbs.fix(1);     // the value at idx = 1 is updated to 1, so bitset = \"01010\". \nbs.flip();     // the value of each bit is flipped, so bitset = \"10101\". \nbs.all();      // return False, as not all values of the bitset are 1.\nbs.unfix(0);   // the value at idx = 0 is updated to 0, so bitset = \"00101\".\nbs.flip();     // the value of each bit is flipped, so bitset = \"11010\". \nbs.one();      // return True, as there is at least 1 index with value 1.\nbs.unfix(0);   // the value at idx = 0 is updated to 0, so bitset = \"01010\".\nbs.count();    // return 2, as there are 2 bits with value 1.\nbs.toString(); // return \"01010\", which is the composition of bitset.\n\n&nbsp;\nConstraints:\n\n\t1 <= size <= 105\n\t0 <= idx <= size - 1\n\tAt most 105 calls will be made in total to fix, unfix, flip, all, one, count, and toString.\n\tAt least one call will be made to all, one, count, or toString.\n\tAt most 5 calls will be made to toString.",
        "solutions": [
            {
                "id": 1748448,
                "title": "o-1-all-java-hashset-except-tostring",
                "content": "```\\nclass Bitset {\\n    int size;\\n    Set<Integer> one = new HashSet<>();\\n    Set<Integer> zero = new HashSet<>();\\n    public Bitset(int size) {\\n        this.size = size;\\n        for(int i=0;i<size;i++) zero.add(i);\\n    }\\n    \\n    public void fix(int idx) {\\n        one.add(idx);\\n        zero.remove(idx);\\n    }\\n    \\n    public void unfix(int idx) {\\n        one.remove(idx);\\n        zero.add(idx);\\n    }\\n    \\n\\t//swapping object\\'s referrence is O(1)\\n    public void flip() {\\n        Set<Integer> s = one;\\n        one = zero;\\n        zero = s;\\n    }\\n    \\n    public boolean all() {\\n        return one.size() == size;\\n    }\\n    \\n    public boolean one() {\\n        return one.size()>=1;\\n    }\\n    \\n    public int count() {\\n        return one.size();\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb=  new StringBuilder();\\n        for(int i=0;i<size;i++) {\\n            if(one.contains(i)) sb.append(\"1\"); \\n            else if(zero.contains(i)) sb.append(\"0\");\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n    int size;\\n    Set<Integer> one = new HashSet<>();\\n    Set<Integer> zero = new HashSet<>();\\n    public Bitset(int size) {\\n        this.size = size;\\n        for(int i=0;i<size;i++) zero.add(i);\\n    }\\n    \\n    public void fix(int idx) {\\n        one.add(idx);\\n        zero.remove(idx);\\n    }\\n    \\n    public void unfix(int idx) {\\n        one.remove(idx);\\n        zero.add(idx);\\n    }\\n    \\n\\t//swapping object\\'s referrence is O(1)\\n    public void flip() {\\n        Set<Integer> s = one;\\n        one = zero;\\n        zero = s;\\n    }\\n    \\n    public boolean all() {\\n        return one.size() == size;\\n    }\\n    \\n    public boolean one() {\\n        return one.size()>=1;\\n    }\\n    \\n    public int count() {\\n        return one.size();\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb=  new StringBuilder();\\n        for(int i=0;i<size;i++) {\\n            if(one.contains(i)) sb.append(\"1\"); \\n            else if(zero.contains(i)) sb.append(\"0\");\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748431,
                "title": "python3-java-c-all-operations-o-1-flipped-string-flip-flag",
                "content": "\\n* Flipping can be done using a flipped string that contains the flipped version of the current bitset. C++ and Java solutions have been done using this method. All operations are O(1) in C++ at the cost of an extra string of length `size`\\n* Python solution has been done using a flip flag. Flip flag stores whether the current bitset has to be flipped. `toString` is O(n)\\n* Keep a count variable `ones` that counts the number of ones in the bitset. This has to be updated in `fix`, `unfix`, and `flip` functions.\\n<iframe src=\"https://leetcode.com/playground/kUJV4c3B/shared\" frameBorder=\"0\" width=\"900\" height=\"590\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "\\n* Flipping can be done using a flipped string that contains the flipped version of the current bitset. C++ and Java solutions have been done using this method. All operations are O(1) in C++ at the cost of an extra string of length `size`\\n* Python solution has been done using a flip flag. Flip flag stores whether the current bitset has to be flipped. `toString` is O(n)\\n* Keep a count variable `ones` that counts the number of ones in the bitset. This has to be updated in `fix`, `unfix`, and `flip` functions.\\n<iframe src=\"https://leetcode.com/playground/kUJV4c3B/shared\" frameBorder=\"0\" width=\"900\" height=\"590\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1748427,
                "title": "c-o-1-for-every-operation-except-tostring-2-solutions",
                "content": "```cntflip -> count number of flips```\\n```cnt -> number of set bits```\\n\\n```\\nclass Bitset {\\npublic:\\n    vector<int>arr;\\n    int cnt,cntflip;\\n    Bitset(int size) {\\n        arr.resize(size,0);\\n        cnt=0,cntflip=0;\\n    }\\n    void fix(int idx) {\\n\\t// means current bit is 0 ,so set it to 1\\n        if((arr[idx]+cntflip)%2==0){\\n            arr[idx]++;\\n            cnt++;\\n        }\\n    }\\n    void unfix(int idx) {\\n\\t// means current bit is 1,so set it to 0\\n      if((arr[idx]+cntflip)%2!=0){\\n            arr[idx]--;\\n            cnt--;\\n        }  \\n    }\\n    void flip() {\\n\\t// cnt will flip ,if we flip all the bits\\n         cnt=arr.size()-cnt;\\n        cntflip++;\\n    }\\n    bool all() {\\n        if(cnt==arr.size())\\n            return true;\\n        return false;\\n    }\\n    bool one() {\\n        if(cnt>=1)\\n            return true;\\n        return false;\\n    }\\n    int count() {\\n        return cnt;\\n    }\\n    string toString() {\\n        string ans;\\n        for(auto &ele :arr){\\n            if((cntflip+ele)%2==0)\\n                ans.push_back(\\'0\\');\\n            else\\n                ans.push_back(\\'1\\');  \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**2nd solution and i think it is better**\\n```\\nclass Bitset {\\npublic:\\n    vector<bool>bits;\\n    int cnt;\\n    bool isFlip;\\n    Bitset(int size) {\\n        bits.resize(size,false);\\n        cnt=0;\\n        isFlip=false;\\n    }\\n    void fix(int idx) {\\n        if((bits[idx] + isFlip)%2==0){\\n            cnt++;\\n            bits[idx]=!bits[idx];  \\n        }\\n    }\\n    void unfix(int idx) {\\n      if((bits[idx] + isFlip)%2!=0){\\n            cnt--;\\n            bits[idx]=!bits[idx];  \\n        } \\n    }\\n    void flip() {\\n        cnt=bits.size()-cnt;\\n        isFlip=!isFlip;\\n    }\\n    bool all() {\\n       return cnt==bits.size(); \\n    }\\n    bool one() {\\n        return cnt>=1;\\n    }\\n    int count() {\\n       return cnt; \\n    }\\n    string toString() {\\n        string ans;\\n        for(auto bit:bits)\\n            ans.push_back((bit+isFlip)%2?\\'1\\':\\'0\\')  ;   \\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps:)",
                "solutionTags": [
                    "C"
                ],
                "code": "```cntflip -> count number of flips```\n```cnt -> number of set bits```\n```\\nclass Bitset {\\npublic:\\n    vector<int>arr;\\n    int cnt,cntflip;\\n    Bitset(int size) {\\n        arr.resize(size,0);\\n        cnt=0,cntflip=0;\\n    }\\n    void fix(int idx) {\\n\\t// means current bit is 0 ,so set it to 1\\n        if((arr[idx]+cntflip)%2==0){\\n            arr[idx]++;\\n            cnt++;\\n        }\\n    }\\n    void unfix(int idx) {\\n\\t// means current bit is 1,so set it to 0\\n      if((arr[idx]+cntflip)%2!=0){\\n            arr[idx]--;\\n            cnt--;\\n        }  \\n    }\\n    void flip() {\\n\\t// cnt will flip ,if we flip all the bits\\n         cnt=arr.size()-cnt;\\n        cntflip++;\\n    }\\n    bool all() {\\n        if(cnt==arr.size())\\n            return true;\\n        return false;\\n    }\\n    bool one() {\\n        if(cnt>=1)\\n            return true;\\n        return false;\\n    }\\n    int count() {\\n        return cnt;\\n    }\\n    string toString() {\\n        string ans;\\n        for(auto &ele :arr){\\n            if((cntflip+ele)%2==0)\\n                ans.push_back(\\'0\\');\\n            else\\n                ans.push_back(\\'1\\');  \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Bitset {\\npublic:\\n    vector<bool>bits;\\n    int cnt;\\n    bool isFlip;\\n    Bitset(int size) {\\n        bits.resize(size,false);\\n        cnt=0;\\n        isFlip=false;\\n    }\\n    void fix(int idx) {\\n        if((bits[idx] + isFlip)%2==0){\\n            cnt++;\\n            bits[idx]=!bits[idx];  \\n        }\\n    }\\n    void unfix(int idx) {\\n      if((bits[idx] + isFlip)%2!=0){\\n            cnt--;\\n            bits[idx]=!bits[idx];  \\n        } \\n    }\\n    void flip() {\\n        cnt=bits.size()-cnt;\\n        isFlip=!isFlip;\\n    }\\n    bool all() {\\n       return cnt==bits.size(); \\n    }\\n    bool one() {\\n        return cnt>=1;\\n    }\\n    int count() {\\n       return cnt; \\n    }\\n    string toString() {\\n        string ans;\\n        for(auto bit:bits)\\n            ans.push_back((bit+isFlip)%2?\\'1\\':\\'0\\')  ;   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748480,
                "title": "c-python-different-solutions",
                "content": "**C++**\\nImplement with a string.\\nAll operation is `O(1)`, \\nexcept `toString()`\\n\\nWe record if we flip it with `isFlip`, \\nwe don\\'t need to really flip it.\\n```cpp\\n    int a = 0, sz = 0, cnt = 0, isFlip = 0;\\n    string s;\\n    Bitset(int size) {\\n        sz = size;\\n        s = string(sz, \\'0\\');\\n    }\\n    \\n    void fix(int idx) {\\n        if (s[idx] == \\'0\\' + isFlip) {\\n            s[idx] = \\'1\\' + \\'0\\' - s[idx];\\n            cnt++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if (s[idx] == \\'1\\' - isFlip) {\\n            s[idx] = \\'1\\' + \\'0\\' - s[idx];\\n            cnt--;\\n        }\\n    }\\n    \\n    void flip() {\\n        isFlip ^= 1;\\n        cnt = sz - cnt;\\n    }\\n    \\n    bool all() {\\n        return cnt == sz;\\n    }\\n    \\n    bool one() {\\n        return cnt > 0;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        if (isFlip) {\\n            string s2 = s;\\n            for (auto& c: s2)\\n                c = \\'0\\' + \\'1\\' - c;\\n            return s2;\\n        }\\n        return s;\\n    }\\n```\\n\\n**Python**\\nImplement with an integer, \\nall operation is `O(1) * O(bit operation)`, \\nexcept `toString()`.\\n\\n```py\\nclass Bitset(object):\\n\\n    def __init__(self, size):\\n        self.a = 0\\n        self.size = size\\n        self.cnt = 0\\n\\n    def fix(self, idx):\\n        if self.a & (1 << idx) == 0:\\n            self.a |= 1 << idx\\n            self.cnt += 1\\n\\n    def unfix(self, idx):\\n        if self.a & (1 << idx):\\n            self.a ^= 1 << idx\\n            self.cnt -= 1\\n\\n    def flip(self):\\n        self.a ^= (1 << self.size) - 1\\n        self.cnt = self.size - self.cnt\\n\\n    def all(self):\\n        return self.cnt == self.size\\n\\n    def one(self):\\n        return self.a > 0\\n\\n    def count(self):\\n        return self.cnt\\n\\n    def toString(self):\\n        a = bin(self.a)[2:]\\n        return a[::-1] + \\'0\\' * (self.size - len(a))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```cpp\\n    int a = 0, sz = 0, cnt = 0, isFlip = 0;\\n    string s;\\n    Bitset(int size) {\\n        sz = size;\\n        s = string(sz, \\'0\\');\\n    }\\n    \\n    void fix(int idx) {\\n        if (s[idx] == \\'0\\' + isFlip) {\\n            s[idx] = \\'1\\' + \\'0\\' - s[idx];\\n            cnt++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if (s[idx] == \\'1\\' - isFlip) {\\n            s[idx] = \\'1\\' + \\'0\\' - s[idx];\\n            cnt--;\\n        }\\n    }\\n    \\n    void flip() {\\n        isFlip ^= 1;\\n        cnt = sz - cnt;\\n    }\\n    \\n    bool all() {\\n        return cnt == sz;\\n    }\\n    \\n    bool one() {\\n        return cnt > 0;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        if (isFlip) {\\n            string s2 = s;\\n            for (auto& c: s2)\\n                c = \\'0\\' + \\'1\\' - c;\\n            return s2;\\n        }\\n        return s;\\n    }\\n```\n```py\\nclass Bitset(object):\\n\\n    def __init__(self, size):\\n        self.a = 0\\n        self.size = size\\n        self.cnt = 0\\n\\n    def fix(self, idx):\\n        if self.a & (1 << idx) == 0:\\n            self.a |= 1 << idx\\n            self.cnt += 1\\n\\n    def unfix(self, idx):\\n        if self.a & (1 << idx):\\n            self.a ^= 1 << idx\\n            self.cnt -= 1\\n\\n    def flip(self):\\n        self.a ^= (1 << self.size) - 1\\n        self.cnt = self.size - self.cnt\\n\\n    def all(self):\\n        return self.cnt == self.size\\n\\n    def one(self):\\n        return self.a > 0\\n\\n    def count(self):\\n        return self.cnt\\n\\n    def toString(self):\\n        a = bin(self.a)[2:]\\n        return a[::-1] + \\'0\\' * (self.size - len(a))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748449,
                "title": "track-flipped-flag-o-1-for-all",
                "content": "Here, the trick is to make the `flip` operation virtual, so it takes O(1) to flip the string.\\n\\n> Update: all operations are O(1) now, by tracking both original and flipped version of the bitset in a string.\\n\\n**C++**\\n```cpp\\nclass Bitset {\\npublic:\\n    string bs, bs_flip;\\n    int cnt = 0, flipped = false;\\n    Bitset(int size) { \\n        bs = string(size, \\'0\\'); \\n        bs_flip = string(size, \\'1\\'); \\n    }\\n    void fix(int idx) {\\n        cnt += bs[idx] == (flipped ? \\'1\\' : \\'0\\');\\n        bs[idx] = (flipped ? \\'0\\' : \\'1\\');\\n        bs_flip[idx] = (flipped ? \\'1\\' : \\'0\\');\\n    }\\n    void unfix(int idx) {\\n        cnt -= bs[idx] == (flipped ? \\'0\\' : \\'1\\');\\n        bs[idx] = (flipped ? \\'1\\' : \\'0\\');\\n        bs_flip[idx] = (flipped ? \\'0\\' : \\'1\\');\\n    }\\n    void flip() { \\n        flipped = !flipped; \\n        cnt = bs.size() - cnt;\\n    }\\n    bool all() { return cnt == bs.size(); }\\n    bool one() { return cnt != 0; }\\n    int count() { return cnt; }\\n    string toString() {\\n        return flipped ? bs_flip : bs;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Bitset {\\npublic:\\n    string bs, bs_flip;\\n    int cnt = 0, flipped = false;\\n    Bitset(int size) { \\n        bs = string(size, \\'0\\'); \\n        bs_flip = string(size, \\'1\\'); \\n    }\\n    void fix(int idx) {\\n        cnt += bs[idx] == (flipped ? \\'1\\' : \\'0\\');\\n        bs[idx] = (flipped ? \\'0\\' : \\'1\\');\\n        bs_flip[idx] = (flipped ? \\'1\\' : \\'0\\');\\n    }\\n    void unfix(int idx) {\\n        cnt -= bs[idx] == (flipped ? \\'0\\' : \\'1\\');\\n        bs[idx] = (flipped ? \\'1\\' : \\'0\\');\\n        bs_flip[idx] = (flipped ? \\'0\\' : \\'1\\');\\n    }\\n    void flip() { \\n        flipped = !flipped; \\n        cnt = bs.size() - cnt;\\n    }\\n    bool all() { return cnt == bs.size(); }\\n    bool one() { return cnt != 0; }\\n    int count() { return cnt; }\\n    string toString() {\\n        return flipped ? bs_flip : bs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748582,
                "title": "pure-o-1-for-all-calls",
                "content": "```\\n\\nclass Bitset {\\npublic:\\n    string s = \"\", fliped = \"\";\\n    \\n    int cnt1 = 0;\\n    int size = 0;\\n    \\n    Bitset(int size) \\n    {\\n        for(int i=0; i<size; i++)\\n        {\\n            s.push_back(\\'0\\');\\n            fliped.push_back(\\'1\\');\\n        }\\n        \\n        this->size = size;\\n    }\\n    \\n    void fix(int ind) \\n    {\\n        if(s[ind] == \\'0\\')\\n            cnt1++;\\n        \\n        s[ind] = \\'1\\';\\n        fliped[ind] = \\'0\\'; \\n    }\\n    \\n    void unfix(int ind) \\n    {\\n        if(s[ind] == \\'1\\')\\n            cnt1--;\\n        s[ind] = \\'0\\';\\n        fliped[ind] = \\'1\\';\\n    }\\n    \\n    void flip() \\n    {\\n        s.swap(fliped); // Updated After reading comments \\n        // swap(s, fliped);\\n        cnt1 = size - cnt1;\\n    }\\n    \\n    bool all() \\n    {\\n        return cnt1 == size;\\n    }\\n    \\n    bool one() \\n    {\\n        return cnt1;\\n    }\\n    \\n    int count() \\n    {\\n        return cnt1;\\n    }\\n    \\n    string toString() \\n    {\\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Bitset {\\npublic:\\n    string s = \"\", fliped = \"\";\\n    \\n    int cnt1 = 0;\\n    int size = 0;\\n    \\n    Bitset(int size) \\n    {\\n        for(int i=0; i<size; i++)\\n        {\\n            s.push_back(\\'0\\');\\n            fliped.push_back(\\'1\\');\\n        }\\n        \\n        this->size = size;\\n    }\\n    \\n    void fix(int ind) \\n    {\\n        if(s[ind] == \\'0\\')\\n            cnt1++;\\n        \\n        s[ind] = \\'1\\';\\n        fliped[ind] = \\'0\\'; \\n    }\\n    \\n    void unfix(int ind) \\n    {\\n        if(s[ind] == \\'1\\')\\n            cnt1--;\\n        s[ind] = \\'0\\';\\n        fliped[ind] = \\'1\\';\\n    }\\n    \\n    void flip() \\n    {\\n        s.swap(fliped); // Updated After reading comments \\n        // swap(s, fliped);\\n        cnt1 = size - cnt1;\\n    }\\n    \\n    bool all() \\n    {\\n        return cnt1 == size;\\n    }\\n    \\n    bool one() \\n    {\\n        return cnt1;\\n    }\\n    \\n    int count() \\n    {\\n        return cnt1;\\n    }\\n    \\n    string toString() \\n    {\\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748508,
                "title": "java-python-3-boolean-array-time-o-1-except-init-and-tostring",
                "content": "Use 2 boolean arrays to record current state and the corresponding flipped one.\\n\\n```java\\n    private boolean[] bits;\\n    private boolean[] flipped;\\n    private int sz, cnt;\\n    \\n    public BooleanArray2(int size) {\\n        sz = size;\\n        bits = new boolean[size];\\n        flipped = new boolean[size];\\n        Arrays.fill(flipped, true);\\n    }\\n    \\n    public void fix(int idx) {\\n        if (!bits[idx]) {\\n            bits[idx] ^= true;\\n            flipped[idx] ^= true;\\n            cnt += 1;\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if (bits[idx]) {\\n            bits[idx] ^= true;\\n            flipped[idx] ^= true;\\n            cnt -= 1;\\n        }\\n    }\\n    \\n    public void flip() {\\n        boolean[] tmp = bits;\\n        bits = flipped;\\n        flipped = tmp;\\n        cnt = sz - cnt;\\n    }\\n    \\n    public boolean all() {\\n        return cnt == sz;\\n    }\\n    \\n    public boolean one() {\\n        return cnt > 0;\\n    }\\n    \\n    public int count() {\\n        return cnt;\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for (boolean b : bits) {\\n            sb.append(b ? \\'1\\' : \\'0\\');\\n        }\\n        return sb.toString();\\n    }\\n```\\n```python\\n    def __init__(self, size: int):\\n        self.sz = size\\n        self.bits = [False] * size\\n        self.flipped = [True] * size\\n        self.bitCount = 0\\n        \\n    def fix(self, idx: int) -> None:\\n        if not self.bits[idx]:\\n            self.bits[idx] ^= True\\n            self.flipped[idx] ^= True\\n            self.bitCount += 1\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.bits[idx]:\\n            self.bits[idx] ^= True\\n            self.flipped[idx] ^= True\\n            self.bitCount -= 1\\n\\n    def flip(self) -> None:\\n        self.bits, self.flipped = self.flipped, self.bits\\n        self.bitCount = self.sz - self.bitCount    \\n\\n    def all(self) -> bool:\\n        return self.sz == self.bitCount\\n\\n    def one(self) -> bool:\\n        return self.bitCount > 0\\n\\n    def count(self) -> int:\\n        return self.bitCount\\n\\n    def toString(self) -> str:\\n        return \\'\\'.join([\\'1\\' if b else \\'0\\' for b in self.bits])\\n```\\n\\n----\\n\\nMinor optimization of the space: using only **one** boolean array and a boolean variable `flipAll` to indicate the flip.\\n\\n```java\\n    private boolean[] arr;\\n    private int sz, cnt;\\n    private boolean flipAll;\\n    \\n    public Bitset(int size) {\\n        sz = size;\\n        arr = new boolean[size];\\n    }\\n    \\n    public void fix(int idx) {\\n        if (!(arr[idx] ^ flipAll)) {\\n            arr[idx] ^= true;\\n            cnt += 1;\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if (arr[idx] ^ flipAll) {\\n            arr[idx] ^= true;\\n            cnt -= 1;\\n        }\\n    }\\n    \\n    public void flip() {\\n        flipAll ^= true;\\n        cnt = sz - cnt;\\n    }\\n    \\n    public boolean all() {\\n        return cnt == sz;\\n    }\\n    \\n    public boolean one() {\\n        return cnt > 0;\\n    }\\n    \\n    public int count() {\\n        return cnt;\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for (boolean b : arr) {\\n            sb.append(b ^ flipAll ? \\'1\\' : \\'0\\');\\n        }\\n        return sb.toString();\\n    }\\n```\\n\\n```python\\n    def __init__(self, size: int):\\n        self.sz = size\\n        self.arr = [False] * size\\n        self.cnt = 0\\n        self.flipAll = False\\n        \\n    def fix(self, idx: int) -> None:\\n        if not (self.arr[idx] ^ self.flipAll):\\n            self.cnt += 1\\n            self.arr[idx] ^= True\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.arr[idx] ^ self.flipAll:\\n            self.arr[idx] ^= True\\n            self.cnt -= 1\\n\\n    def flip(self) -> None:\\n        self.flipAll ^= True\\n        self.cnt = self.sz - self.cnt    \\n\\n    def all(self) -> bool:\\n        return self.sz == self.cnt\\n\\n    def one(self) -> bool:\\n        return self.cnt > 0\\n\\n    def count(self) -> int:\\n        return self.cnt\\n\\n    def toString(self) -> str:\\n        return \\'\\'.join([\\'1\\' if (v ^ self.flipAll) else \\'0\\' for v in self.arr])\\n```\\n\\n**Analysis:**\\n\\nTime & space:\\nInitialization and `toString()` are both `O(size)`; others are all `O(1)`;",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    private boolean[] bits;\\n    private boolean[] flipped;\\n    private int sz, cnt;\\n    \\n    public BooleanArray2(int size) {\\n        sz = size;\\n        bits = new boolean[size];\\n        flipped = new boolean[size];\\n        Arrays.fill(flipped, true);\\n    }\\n    \\n    public void fix(int idx) {\\n        if (!bits[idx]) {\\n            bits[idx] ^= true;\\n            flipped[idx] ^= true;\\n            cnt += 1;\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if (bits[idx]) {\\n            bits[idx] ^= true;\\n            flipped[idx] ^= true;\\n            cnt -= 1;\\n        }\\n    }\\n    \\n    public void flip() {\\n        boolean[] tmp = bits;\\n        bits = flipped;\\n        flipped = tmp;\\n        cnt = sz - cnt;\\n    }\\n    \\n    public boolean all() {\\n        return cnt == sz;\\n    }\\n    \\n    public boolean one() {\\n        return cnt > 0;\\n    }\\n    \\n    public int count() {\\n        return cnt;\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for (boolean b : bits) {\\n            sb.append(b ? \\'1\\' : \\'0\\');\\n        }\\n        return sb.toString();\\n    }\\n```\n```python\\n    def __init__(self, size: int):\\n        self.sz = size\\n        self.bits = [False] * size\\n        self.flipped = [True] * size\\n        self.bitCount = 0\\n        \\n    def fix(self, idx: int) -> None:\\n        if not self.bits[idx]:\\n            self.bits[idx] ^= True\\n            self.flipped[idx] ^= True\\n            self.bitCount += 1\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.bits[idx]:\\n            self.bits[idx] ^= True\\n            self.flipped[idx] ^= True\\n            self.bitCount -= 1\\n\\n    def flip(self) -> None:\\n        self.bits, self.flipped = self.flipped, self.bits\\n        self.bitCount = self.sz - self.bitCount    \\n\\n    def all(self) -> bool:\\n        return self.sz == self.bitCount\\n\\n    def one(self) -> bool:\\n        return self.bitCount > 0\\n\\n    def count(self) -> int:\\n        return self.bitCount\\n\\n    def toString(self) -> str:\\n        return \\'\\'.join([\\'1\\' if b else \\'0\\' for b in self.bits])\\n```\n```java\\n    private boolean[] arr;\\n    private int sz, cnt;\\n    private boolean flipAll;\\n    \\n    public Bitset(int size) {\\n        sz = size;\\n        arr = new boolean[size];\\n    }\\n    \\n    public void fix(int idx) {\\n        if (!(arr[idx] ^ flipAll)) {\\n            arr[idx] ^= true;\\n            cnt += 1;\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if (arr[idx] ^ flipAll) {\\n            arr[idx] ^= true;\\n            cnt -= 1;\\n        }\\n    }\\n    \\n    public void flip() {\\n        flipAll ^= true;\\n        cnt = sz - cnt;\\n    }\\n    \\n    public boolean all() {\\n        return cnt == sz;\\n    }\\n    \\n    public boolean one() {\\n        return cnt > 0;\\n    }\\n    \\n    public int count() {\\n        return cnt;\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for (boolean b : arr) {\\n            sb.append(b ^ flipAll ? \\'1\\' : \\'0\\');\\n        }\\n        return sb.toString();\\n    }\\n```\n```python\\n    def __init__(self, size: int):\\n        self.sz = size\\n        self.arr = [False] * size\\n        self.cnt = 0\\n        self.flipAll = False\\n        \\n    def fix(self, idx: int) -> None:\\n        if not (self.arr[idx] ^ self.flipAll):\\n            self.cnt += 1\\n            self.arr[idx] ^= True\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.arr[idx] ^ self.flipAll:\\n            self.arr[idx] ^= True\\n            self.cnt -= 1\\n\\n    def flip(self) -> None:\\n        self.flipAll ^= True\\n        self.cnt = self.sz - self.cnt    \\n\\n    def all(self) -> bool:\\n        return self.sz == self.cnt\\n\\n    def one(self) -> bool:\\n        return self.cnt > 0\\n\\n    def count(self) -> int:\\n        return self.cnt\\n\\n    def toString(self) -> str:\\n        return \\'\\'.join([\\'1\\' if (v ^ self.flipAll) else \\'0\\' for v in self.arr])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1748967,
                "title": "the-easiest-c-code-using-two-strings",
                "content": "Store both the bitset and inverted bitset as string. Keep updating both in each operation.\\nAlso store a counter to keep track of set bits.\\n```\\nclass Bitset {\\n    string bitset, inv_bitset;\\n    int sz;\\n    int counter;\\npublic:\\n    Bitset(int size) {\\n        for(int i = 0; i < size; i++) {\\n            bitset.push_back(\\'0\\');\\n            inv_bitset.push_back(\\'1\\');\\n        }\\n        sz = size;\\n        counter  = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(bitset[idx] == \\'0\\') counter++;\\n        bitset[idx] = \\'1\\';\\n        inv_bitset[idx] = \\'0\\';\\n    }\\n    \\n    void unfix(int idx) {\\n        if(bitset[idx] == \\'1\\') counter--;\\n        bitset[idx] = \\'0\\';\\n        inv_bitset[idx] = \\'1\\';\\n    }\\n    \\n    void flip() {\\n        swap(bitset, inv_bitset);\\n        counter = sz - counter;\\n    }\\n    \\n    bool all() {\\n        return counter == sz;\\n    }\\n    \\n    bool one() {\\n        return counter > 0;\\n    }\\n    \\n    int count() {\\n        return counter;\\n    }\\n    \\n    string toString() {\\n        return bitset;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Bitset {\\n    string bitset, inv_bitset;\\n    int sz;\\n    int counter;\\npublic:\\n    Bitset(int size) {\\n        for(int i = 0; i < size; i++) {\\n            bitset.push_back(\\'0\\');\\n            inv_bitset.push_back(\\'1\\');\\n        }\\n        sz = size;\\n        counter  = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(bitset[idx] == \\'0\\') counter++;\\n        bitset[idx] = \\'1\\';\\n        inv_bitset[idx] = \\'0\\';\\n    }\\n    \\n    void unfix(int idx) {\\n        if(bitset[idx] == \\'1\\') counter--;\\n        bitset[idx] = \\'0\\';\\n        inv_bitset[idx] = \\'1\\';\\n    }\\n    \\n    void flip() {\\n        swap(bitset, inv_bitset);\\n        counter = sz - counter;\\n    }\\n    \\n    bool all() {\\n        return counter == sz;\\n    }\\n    \\n    bool one() {\\n        return counter > 0;\\n    }\\n    \\n    int count() {\\n        return counter;\\n    }\\n    \\n    string toString() {\\n        return bitset;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748495,
                "title": "java-simple-2-arrays",
                "content": "```\\nclass Bitset {\\n\\n    private int len;\\n    private int [] bits;\\n    private int [] flipBits;\\n    private int count1;\\n\\t\\n    public Bitset(int size) {\\n        len=size;\\n        bits = new int [size];\\n        count1=0;\\n        flipBits = new int [size];\\n        Arrays.fill(flipBits,1);\\n    }\\n\\t\\n    public void fix(int idx) {\\n        if(bits[idx]==0){\\n            count1++;\\n        }\\n        bits[idx]=1;\\n        flipBits[idx]=0;\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(bits[idx]==1){\\n            count1--;\\n        }\\n        bits[idx]=0;\\n        flipBits[idx]=1;\\n    }\\n    \\n    public void flip() {\\n        int [] temp = flipBits;\\n        flipBits = bits;\\n        bits=temp;\\n        count1 = len-count1;\\n    }\\n    \\n    public boolean all() {\\n        return count1==len;\\n    }\\n    \\n    public boolean one() {\\n        return count1>0;\\n    }\\n    \\n    public int count() {\\n        return count1;\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<len;i++){\\n            sb.append(bits[i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Bitset {\\n\\n    private int len;\\n    private int [] bits;\\n    private int [] flipBits;\\n    private int count1;\\n\\t\\n    public Bitset(int size) {\\n        len=size;\\n        bits = new int [size];\\n        count1=0;\\n        flipBits = new int [size];\\n        Arrays.fill(flipBits,1);\\n    }\\n\\t\\n    public void fix(int idx) {\\n        if(bits[idx]==0){\\n            count1++;\\n        }\\n        bits[idx]=1;\\n        flipBits[idx]=0;\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(bits[idx]==1){\\n            count1--;\\n        }\\n        bits[idx]=0;\\n        flipBits[idx]=1;\\n    }\\n    \\n    public void flip() {\\n        int [] temp = flipBits;\\n        flipBits = bits;\\n        bits=temp;\\n        count1 = len-count1;\\n    }\\n    \\n    public boolean all() {\\n        return count1==len;\\n    }\\n    \\n    public boolean one() {\\n        return count1>0;\\n    }\\n    \\n    public int count() {\\n        return count1;\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<len;i++){\\n            sb.append(bits[i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150281,
                "title": "python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n* Make an array for storing bits. *Initializing all the values to 0*\\n* Keep a variable ```on``` to keep the count of number of ones.\\n* Create another ```bool``` variable ```flipped = False``` to store condition of array. **[ If array is fliiped, variable is changed to ```True```, if flipped again change to ```False``` and keeping doing this ]** Hence we can perform flip operation in O ( 1 ). Also remember to change number of one ```on```\\n* Other conditons can be derived and understood from the code below.\\n\\n**UPVOTE IF HELPFuuL**\\n\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.a=[0]*size\\n        self.on=0;\\n        self.n = size;\\n        self.flipped=False\\n\\n    \\n    def fix(self, idx: int) -> None:\\n        if self.flipped:\\n            if self.a[idx]==1:\\n                self.on+=1\\n                self.a[idx]=0\\n        else:\\n            if self.a[idx]==0:\\n                self.on+=1\\n                self.a[idx]=1\\n\\n    \\n    def unfix(self, idx: int) -> None:\\n        if self.flipped:\\n            if self.a[idx]==0:\\n                self.on-=1\\n                self.a[idx]=1\\n        else:\\n            if self.a[idx]==1:\\n                self.on-=1\\n                self.a[idx]=0\\n\\n    \\n    def flip(self) -> None:\\n        if self.flipped:\\n            self.flipped=False\\n        else:\\n            self.flipped=True\\n        self.on = self.n-self.on\\n    \\n    \\n    def all(self) -> bool:\\n        if self.n==self.on:\\n            return True\\n        return False\\n\\n    \\n    def one(self) -> bool:\\n        if self.on>0:\\n            return True\\n        return False\\n\\n    \\n    def count(self) -> int:\\n        return self.on\\n        \\n        \\n    def toString(self) -> str:\\n        s=\"\"\\n        if self.flipped:\\n            for i in self.a:\\n                if i:\\n                    s+=\"0\"\\n                else:\\n                    s+=\"1\"\\n            return s\\n        for i in self.a:\\n            if i:\\n                s+=\"1\"\\n            else:\\n                s+=\"0\"\\n        return s\\n```\\n![image](https://assets.leetcode.com/users/images/5ac79dfb-ab8a-478a-9c1c-e145cd1530be_1655191941.0682094.jpeg)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```on```\n```bool```\n```flipped = False```\n```True```\n```False```\n```on```\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.a=[0]*size\\n        self.on=0;\\n        self.n = size;\\n        self.flipped=False\\n\\n    \\n    def fix(self, idx: int) -> None:\\n        if self.flipped:\\n            if self.a[idx]==1:\\n                self.on+=1\\n                self.a[idx]=0\\n        else:\\n            if self.a[idx]==0:\\n                self.on+=1\\n                self.a[idx]=1\\n\\n    \\n    def unfix(self, idx: int) -> None:\\n        if self.flipped:\\n            if self.a[idx]==0:\\n                self.on-=1\\n                self.a[idx]=1\\n        else:\\n            if self.a[idx]==1:\\n                self.on-=1\\n                self.a[idx]=0\\n\\n    \\n    def flip(self) -> None:\\n        if self.flipped:\\n            self.flipped=False\\n        else:\\n            self.flipped=True\\n        self.on = self.n-self.on\\n    \\n    \\n    def all(self) -> bool:\\n        if self.n==self.on:\\n            return True\\n        return False\\n\\n    \\n    def one(self) -> bool:\\n        if self.on>0:\\n            return True\\n        return False\\n\\n    \\n    def count(self) -> int:\\n        return self.on\\n        \\n        \\n    def toString(self) -> str:\\n        s=\"\"\\n        if self.flipped:\\n            for i in self.a:\\n                if i:\\n                    s+=\"0\"\\n                else:\\n                    s+=\"1\"\\n            return s\\n        for i in self.a:\\n            if i:\\n                s+=\"1\"\\n            else:\\n                s+=\"0\"\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748822,
                "title": "java-single-array-boolean-flip-100-38-ms-o-1-except-tostring-simple-to-understand",
                "content": "No need to flip bits we can simply use boolean variable to store isflipped or not:\\n* flip means bit will set opposite to it \\n1) if isflip is true that means \\'0\\' will be treated as \\'1\\' and \\'1\\' will be treated as \\'0\\'\\nthat all the **new taste of this question**\\n\\n```\\nclass Bitset {\\n    \\n    \\n    char bit[];\\n    boolean isflip =  false;\\n    int count;\\n    public Bitset(int size) {\\n        bit =  new char[size];\\n        Arrays.fill(bit,\\'0\\');\\n        count = 0;\\n    }\\n    \\n    // if isflip is true then \\'1\\' will be treated as \\'0\\' and \\'0\\' will be treated as \\'1\\'\\n    public void fix(int idx) {\\n        \\n        if(!isflip && bit[idx]==\\'0\\'){\\n            count+=1;\\n            bit[idx]=\\'1\\';\\n        }\\n         else if(isflip && bit[idx]==\\'1\\') {\\n             count+=1;\\n             bit[idx]=\\'0\\';\\n            \\n        }              \\n    }\\n    \\n    public void unfix(int idx) {\\n        if(!isflip && bit[idx]==\\'1\\'){\\n            count-=1;\\n            bit[idx]=\\'0\\';\\n        }\\n        else if(isflip && bit[idx]==\\'0\\') {\\n            count-=1;    \\n            bit[idx]=\\'1\\';\\n        }\\n        \\n    }\\n    \\n    public void flip() {\\n        isflip =  !isflip;\\n        count =  bit.length-count;        \\n    }\\n    \\n    public boolean all() { return count==bit.length; }\\n    \\n    public boolean one() { return count>0; }\\n    \\n    public int count() { return  count;       }\\n    \\n    public String toString() {\\n        \\n        if(isflip){\\n            char b[] = bit.clone();\\n            for(int i=0;i<bit.length;i++){        \\n                b[i] = b[i]==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            return String.valueOf(b);\\n        }\\n        else{\\n          return String.valueOf(bit);\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n    \\n    \\n    char bit[];\\n    boolean isflip =  false;\\n    int count;\\n    public Bitset(int size) {\\n        bit =  new char[size];\\n        Arrays.fill(bit,\\'0\\');\\n        count = 0;\\n    }\\n    \\n    // if isflip is true then \\'1\\' will be treated as \\'0\\' and \\'0\\' will be treated as \\'1\\'\\n    public void fix(int idx) {\\n        \\n        if(!isflip && bit[idx]==\\'0\\'){\\n            count+=1;\\n            bit[idx]=\\'1\\';\\n        }\\n         else if(isflip && bit[idx]==\\'1\\') {\\n             count+=1;\\n             bit[idx]=\\'0\\';\\n            \\n        }              \\n    }\\n    \\n    public void unfix(int idx) {\\n        if(!isflip && bit[idx]==\\'1\\'){\\n            count-=1;\\n            bit[idx]=\\'0\\';\\n        }\\n        else if(isflip && bit[idx]==\\'0\\') {\\n            count-=1;    \\n            bit[idx]=\\'1\\';\\n        }\\n        \\n    }\\n    \\n    public void flip() {\\n        isflip =  !isflip;\\n        count =  bit.length-count;        \\n    }\\n    \\n    public boolean all() { return count==bit.length; }\\n    \\n    public boolean one() { return count>0; }\\n    \\n    public int count() { return  count;       }\\n    \\n    public String toString() {\\n        \\n        if(isflip){\\n            char b[] = bit.clone();\\n            for(int i=0;i<bit.length;i++){        \\n                b[i] = b[i]==\\'1\\'?\\'0\\':\\'1\\';\\n            }\\n            return String.valueOf(b);\\n        }\\n        else{\\n          return String.valueOf(bit);\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748473,
                "title": "c-easy-logic-detailed-explanation",
                "content": "**Trick:** Instead of flipping all the bits in the bitset, maintain a boolean variable and only flip it whenever there is flip operation\\n**Time complexity of operations:** \\nfix \\t- O(1)\\nunfix \\t- O(1)\\nflip \\t- O(1)\\nall \\t- O(1)\\none\\t- O(1)\\ncount \\t- O(1)\\ntoString - O(n)\\n```\\nclass Bitset {\\npublic:\\n    // bits to store the bittset\\n    string bits;\\n    // flipped stores whether the bitset has been flipped or not\\n    bool flipped;\\n    // noOfOnes = no.of ones in the bitset\\n    // noOfBits = size of the bitset\\n    int noOfBits, noOfOnes;\\n    \\n    Bitset(int size) {\\n        // Initialize string with zeroes\\n        bits = string(size, \\'0\\');\\n        // Bitset is not flipped initially\\n        flipped = false;\\n        noOfBits = size;\\n        noOfOnes = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        // If bitset is not flipped, then 0 is the unset bit. Hence change it to 1\\n        if(!flipped && bits[idx] == \\'0\\'){\\n            bits[idx] = \\'1\\';\\n            noOfOnes++;\\n        }\\n        // If bitset is flipped, then 1 is the unset bit. Hence change it to 0\\n        if(flipped && bits[idx] == \\'1\\'){\\n            bits[idx] = \\'0\\';\\n            noOfOnes++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        // If bitset is not flipped, then 1 is the set bit. Hence change it to 0\\n        if(!flipped && bits[idx] == \\'1\\'){\\n            bits[idx] = \\'0\\';\\n            noOfOnes--;\\n        }\\n        // If bitset is flipped, then 0 is the set bit. Hence change it to 1\\n        if(flipped && bits[idx] == \\'0\\'){\\n            bits[idx] = \\'1\\';\\n            noOfOnes--;\\n        }\\n    }\\n    \\n    // Just flipping the boolean variable to mark the bitset as flipped\\n    void flip() {\\n        flipped = !flipped;\\n        // No.of zeroes will now become the no.of ones .i.e. zeroes = total no.of bits - ones;\\n        int zeroes = noOfBits-noOfOnes;\\n        noOfOnes = zeroes;\\n    }\\n    \\n    // No.of ones == total no.of bits then true\\n    bool all() {\\n        return noOfOnes == noOfBits ? true : false;\\n    }\\n    \\n    // No.of ones is greater than zero, then there is atleast one set bit\\n    bool one() {\\n        return noOfOnes > 0 ? true : false;\\n    }\\n    \\n    // Returns total no.of set bits\\n    int count() {\\n        return noOfOnes;\\n    }\\n    \\n    string toString() {\\n        // If the string is not flipped, then return the original bitset\\n        if(!flipped){\\n            return bits;\\n        }\\n        // If the string is flipped, then we need to change zeroes to ones and ones to zeroes\\n        else{\\n            // Using the temporary string to do this\\n            // Changing the original bitset will affect the next operations\\n            string ans = bits;\\n            for(int i=0; i<noOfBits; i++){\\n                ans[i] = (ans[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    // bits to store the bittset\\n    string bits;\\n    // flipped stores whether the bitset has been flipped or not\\n    bool flipped;\\n    // noOfOnes = no.of ones in the bitset\\n    // noOfBits = size of the bitset\\n    int noOfBits, noOfOnes;\\n    \\n    Bitset(int size) {\\n        // Initialize string with zeroes\\n        bits = string(size, \\'0\\');\\n        // Bitset is not flipped initially\\n        flipped = false;\\n        noOfBits = size;\\n        noOfOnes = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        // If bitset is not flipped, then 0 is the unset bit. Hence change it to 1\\n        if(!flipped && bits[idx] == \\'0\\'){\\n            bits[idx] = \\'1\\';\\n            noOfOnes++;\\n        }\\n        // If bitset is flipped, then 1 is the unset bit. Hence change it to 0\\n        if(flipped && bits[idx] == \\'1\\'){\\n            bits[idx] = \\'0\\';\\n            noOfOnes++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        // If bitset is not flipped, then 1 is the set bit. Hence change it to 0\\n        if(!flipped && bits[idx] == \\'1\\'){\\n            bits[idx] = \\'0\\';\\n            noOfOnes--;\\n        }\\n        // If bitset is flipped, then 0 is the set bit. Hence change it to 1\\n        if(flipped && bits[idx] == \\'0\\'){\\n            bits[idx] = \\'1\\';\\n            noOfOnes--;\\n        }\\n    }\\n    \\n    // Just flipping the boolean variable to mark the bitset as flipped\\n    void flip() {\\n        flipped = !flipped;\\n        // No.of zeroes will now become the no.of ones .i.e. zeroes = total no.of bits - ones;\\n        int zeroes = noOfBits-noOfOnes;\\n        noOfOnes = zeroes;\\n    }\\n    \\n    // No.of ones == total no.of bits then true\\n    bool all() {\\n        return noOfOnes == noOfBits ? true : false;\\n    }\\n    \\n    // No.of ones is greater than zero, then there is atleast one set bit\\n    bool one() {\\n        return noOfOnes > 0 ? true : false;\\n    }\\n    \\n    // Returns total no.of set bits\\n    int count() {\\n        return noOfOnes;\\n    }\\n    \\n    string toString() {\\n        // If the string is not flipped, then return the original bitset\\n        if(!flipped){\\n            return bits;\\n        }\\n        // If the string is flipped, then we need to change zeroes to ones and ones to zeroes\\n        else{\\n            // Using the temporary string to do this\\n            // Changing the original bitset will affect the next operations\\n            string ans = bits;\\n            for(int i=0; i<noOfBits; i++){\\n                ans[i] = (ans[i] == \\'1\\' ? \\'0\\' : \\'1\\');\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1748484,
                "title": "c-counting-set-bits-and-flips",
                "content": "```\\nclass Bitset {\\npublic:\\n    vector<int> v;\\n    int c;// count of flips\\n    int cc;// count of set bits\\n    int n;//size\\n    Bitset(int size) {\\n        n=size;\\n        v=vector<int>(size,0);\\n        c=0;\\n        cc=0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(c%2==0){\\n            if(v[idx]==0){\\n                v[idx]=1;\\n                cc++;\\n            }\\n        }\\n        else{\\n            if(v[idx]==1){\\n                v[idx]=0;\\n                cc++;\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n          if(c%2==0){\\n            if(v[idx]==1){\\n                v[idx]=0;\\n                cc--;\\n            }\\n        }\\n        else{\\n            if(v[idx]==0){\\n                v[idx]=1;\\n                cc--;\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        c++;\\n        cc=(n-cc);\\n    }\\n    \\n    bool all() {\\n       if(cc==n) return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n       if(cc>0) return true;\\n        return false;\\n    }\\n    \\n    int count() {     \\n        return cc;\\n    }\\n    \\n    string toString() {\\n        string ans=\"\";\\n            for(int i=0;i<v.size();i++){\\n            if(c%2==0){\\n                if(v[i]==1) ans+=\\'1\\';\\n                else ans+=\\'0\\';\\n            }\\n            else{\\n                if(v[i]==0) ans+=\\'1\\';\\n                else ans+=\\'0\\';\\n            }\\n          }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    vector<int> v;\\n    int c;// count of flips\\n    int cc;// count of set bits\\n    int n;//size\\n    Bitset(int size) {\\n        n=size;\\n        v=vector<int>(size,0);\\n        c=0;\\n        cc=0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(c%2==0){\\n            if(v[idx]==0){\\n                v[idx]=1;\\n                cc++;\\n            }\\n        }\\n        else{\\n            if(v[idx]==1){\\n                v[idx]=0;\\n                cc++;\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n          if(c%2==0){\\n            if(v[idx]==1){\\n                v[idx]=0;\\n                cc--;\\n            }\\n        }\\n        else{\\n            if(v[idx]==0){\\n                v[idx]=1;\\n                cc--;\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        c++;\\n        cc=(n-cc);\\n    }\\n    \\n    bool all() {\\n       if(cc==n) return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n       if(cc>0) return true;\\n        return false;\\n    }\\n    \\n    int count() {     \\n        return cc;\\n    }\\n    \\n    string toString() {\\n        string ans=\"\";\\n            for(int i=0;i<v.size();i++){\\n            if(c%2==0){\\n                if(v[i]==1) ans+=\\'1\\';\\n                else ans+=\\'0\\';\\n            }\\n            else{\\n                if(v[i]==0) ans+=\\'1\\';\\n                else ans+=\\'0\\';\\n            }\\n          }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748425,
                "title": "java-simple-solution-flip-and-false-count",
                "content": "```\\nclass Bitset {\\n    boolean [] arr = null;\\n    int flipCount = 0;\\n    int falseCount = 0;\\n    public Bitset(int size) {\\n        arr = new boolean[size];\\n        falseCount = size;\\n    }\\n    \\n    public void fix(int idx) {\\n        boolean realTrue = true;\\n        boolean realFalse = false;\\n        if(flipCount%2==1)\\n        {\\n            realTrue = false;\\n            realFalse = true;\\n        }\\n        \\n        if(arr[idx]==realFalse) // Write code first with false and true, then replace with the realFalse, realTrue to accomodate flips\\n            falseCount--;\\n        \\n        arr[idx]=realTrue;\\n    }\\n    \\n    public void unfix(int idx) {\\n        boolean realTrue = true;\\n        boolean realFalse = false;\\n        if(flipCount%2==1)\\n        {\\n            realTrue = false;\\n            realFalse = true;\\n        }\\n        \\n        if(arr[idx]==realTrue)\\n            falseCount++;\\n        \\n       arr[idx] = realFalse; \\n    }\\n    \\n    public void flip() {\\n        falseCount = arr.length-falseCount;\\n        \\n        flipCount++;\\n    }\\n    \\n    public boolean all() {\\n        return (falseCount==0);\\n    }\\n    \\n    public boolean one() {\\n        return falseCount<arr.length;\\n    }\\n    \\n    public int count() {\\n        return arr.length-falseCount;\\n    }\\n    \\n    public String toString() {\\n        StringBuffer sb = new StringBuffer();;\\n        for(boolean val: arr){\\n            sb.append(\"\"+((flipCount%2==0)?(val?1:0):(val?0:1)));\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */",
                "solutionTags": [],
                "code": "```\\nclass Bitset {\\n    boolean [] arr = null;\\n    int flipCount = 0;\\n    int falseCount = 0;\\n    public Bitset(int size) {\\n        arr = new boolean[size];\\n        falseCount = size;\\n    }\\n    \\n    public void fix(int idx) {\\n        boolean realTrue = true;\\n        boolean realFalse = false;\\n        if(flipCount%2==1)\\n        {\\n            realTrue = false;\\n            realFalse = true;\\n        }\\n        \\n        if(arr[idx]==realFalse) // Write code first with false and true, then replace with the realFalse, realTrue to accomodate flips\\n            falseCount--;\\n        \\n        arr[idx]=realTrue;\\n    }\\n    \\n    public void unfix(int idx) {\\n        boolean realTrue = true;\\n        boolean realFalse = false;\\n        if(flipCount%2==1)\\n        {\\n            realTrue = false;\\n            realFalse = true;\\n        }\\n        \\n        if(arr[idx]==realTrue)\\n            falseCount++;\\n        \\n       arr[idx] = realFalse; \\n    }\\n    \\n    public void flip() {\\n        falseCount = arr.length-falseCount;\\n        \\n        flipCount++;\\n    }\\n    \\n    public boolean all() {\\n        return (falseCount==0);\\n    }\\n    \\n    public boolean one() {\\n        return falseCount<arr.length;\\n    }\\n    \\n    public int count() {\\n        return arr.length-falseCount;\\n    }\\n    \\n    public String toString() {\\n        StringBuffer sb = new StringBuffer();;\\n        for(boolean val: arr){\\n            sb.append(\"\"+((flipCount%2==0)?(val?1:0):(val?0:1)));\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1749044,
                "title": "o-1-cpp-all-operation-in-o-1-easy-to-understand",
                "content": "In this question we have to write all operation in way that they work in  constant time except last function (i.e we can write **toString( )** function in O(1) or O(n) also both are Accepted) .\\nso here i show how to implement **toString( )** so it works in constant time.\\n\\nIn starting make a vector of size two  which contain two string and both of string are opposite to each other and with this also three variable  two of them are for counting 0 and 1 and third one is for indicate position of string in **vec** We are using it currently. Because vec is of only two size so value of third variable is only 0 and 1 (represent index of vec) .This make sense in **fill** operation. \\n\\n```\\nvector<int> vec; // this stores two strings which are opposite to each other.\\nint  z=0; // count of 1\\nint o=0; // count of 0\\nint I=0; // index of vec (I only have two values {0,1} )\\n```\\n\\n* How to implement **Bitset(int size)**?\\n\\n\\tIn this make two string of length **size** both string must opposite of each other always so,\\n\\t\\tIf size = 5 then both string are\\n\\t\\t\\ts=\"00000\"\\n\\t\\t\\tr=\"11111\"\\n\\t\\tthen push this two string in **vec** and update count of zero(i.e **z**=0) ans **I** become 0 here because current string is present on 0th index of **vec**\\n\\t\\n\\t```\\n\\t    z=size;\\n        string s,r;\\n        for(int i=0;i<size;i++){s.push_back(\\'0\\'); r.push_back(\\'1\\');}\\n        vec.push_back(s);\\n        vec.push_back(v);\\n\\t\\t\\n\\t```\\n\\n* How to implement **fix(int idx)**?\\n\\n  In this firstly check whether the current string menas **vec[ I ]** contain already 1 at index idx then increase count  of one and then decrease count of zero otherwise do nothing change in count \\n  \\n\\tAter taking care of count now  you have to change the character at index idx in both strings with opposite characters because both strings should be opposite of each other always.\\n\\t\\t  vec[I][idx]=\\'1\\'\\n\\t\\t  vec[1-I][idx]=\\'0\\'\\n\\tThe current string is that string which is present in vec on index I.\\n\\t If I=0 then 1-I is 1 like this we are able to do changes on both strings.\\n\\t```\\n\\t    if(vec[I][idx]!=\\'1\\'){\\n            o++;\\n            z--;\\n        }\\n        vec[I][idx]=\\'1\\';\\n        vec[1-I][idx]=\\'0\\';\\n\\t\\t\\n\\t```\\n\\t\\n* How to implement **unfix(int idx)**?\\n\\t\\n\\tIn this do same thing as we done in **fix(int idx)**. but instead of checking for 1 we check for 0 in the current string .\\n\\t\\n\\t```\\n\\t    if(vec[I][idx]!=\\'0\\'){\\n            o--;\\n            z++;\\n        }\\n        vec[I][idx]=\\'0\\';\\n        vec[1-I][idx]=\\'1\\';\\n\\t\\t\\n\\t```\\n\\n* How to implement **flip()**?\\n\\n\\tIn this because we need to reverse all the bits and i have already a string which is opposite to my current string which is present on  **1-I** index of **vec**. so simply make these changes \\n\\t\\n\\t```\\n\\t    swap(o,z); //this is because if all bits are reverse then count of 1\\'s and 0\\'s is also change means all 0 become 1 and vice-versa \\n        I=1-I;\\n\\t\\t\\n\\t```\\n\\t\\n* How to implement **all()**?\\n\\n\\tThis function is easy implement because we have count of 1\\'s so we return true if current string size equal to count of 1\\'s otherwise return false\\n\\t\\n\\t```\\n\\t    return o==vec[I].size();\\n\\t```\\n\\t\\t\\n* How to implement **one()**?\\n\\t\\n\\tThis function is also easy to implement because we have count of 1\\'s so simply return true if count is greater than 0.\\n\\t\\n\\t```\\n\\t     return o>0;\\n\\t```\\n\\t\\n* How to implement **count()**?\\n\\t\\n\\twe have count of 1\\'s so simply return that\\n\\t\\n\\t```\\n\\t     return o;\\n\\t```\\n\\t\\n* How to implement **toString()**?\\n\\n\\tIn this we have to return current string which is present on **I**th index of **vec**\\n\\t\\n\\t```\\n\\t     return vec[ I ];\\n\\t```\\n\\t\\n\\t\\n\\t**IF THIS POST IS HELPFUL FOR YOU SO PLEASE UPVOTE!!  \\uD83D\\uDE4F\\uD83D\\uDE4F**\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nvector<int> vec; // this stores two strings which are opposite to each other.\\nint  z=0; // count of 1\\nint o=0; // count of 0\\nint I=0; // index of vec (I only have two values {0,1} )\\n```\n```\\n\\t    z=size;\\n        string s,r;\\n        for(int i=0;i<size;i++){s.push_back(\\'0\\'); r.push_back(\\'1\\');}\\n        vec.push_back(s);\\n        vec.push_back(v);\\n\\t\\t\\n\\t```\n```\\n\\t    if(vec[I][idx]!=\\'1\\'){\\n            o++;\\n            z--;\\n        }\\n        vec[I][idx]=\\'1\\';\\n        vec[1-I][idx]=\\'0\\';\\n\\t\\t\\n\\t```\n```\\n\\t    if(vec[I][idx]!=\\'0\\'){\\n            o--;\\n            z++;\\n        }\\n        vec[I][idx]=\\'0\\';\\n        vec[1-I][idx]=\\'1\\';\\n\\t\\t\\n\\t```\n```\\n\\t    swap(o,z); //this is because if all bits are reverse then count of 1\\'s and 0\\'s is also change means all 0 become 1 and vice-versa \\n        I=1-I;\\n\\t\\t\\n\\t```\n```\\n\\t    return o==vec[I].size();\\n\\t```\n```\\n\\t     return o>0;\\n\\t```\n```\\n\\t     return o;\\n\\t```\n```\\n\\t     return vec[ I ];\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1748832,
                "title": "javascript-decide-by-flip-1110ms",
                "content": "```\\nfunction Bitset(n) {\\n    let a = Array(n).fill(0), One = 0, f = 0;\\n    return { fix, unfix, flip, all, one, count, toString };\\n    function fix(idx) {\\n        if (a[idx] == f) { // 0 -> 1 set\\n            a[idx] = f ^ 1;\\n            One++;\\n        }\\n    }\\n    function unfix(idx) {\\n        if (a[idx] != f) { // 1 -> 0 unset\\n            a[idx] = f;\\n            One--;\\n        }\\n    }\\n    function flip() {\\n        f ^= 1;\\n        One = n - One;\\n    }\\n    function all() {\\n        return One == n;\\n    }\\n    function one() {\\n        return One >= 1;\\n    }\\n    function count() {\\n        return One;\\n    }\\n    function toString() {\\n        let res = \\'\\';\\n        for(const x of a) res += x ^ f;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction Bitset(n) {\\n    let a = Array(n).fill(0), One = 0, f = 0;\\n    return { fix, unfix, flip, all, one, count, toString };\\n    function fix(idx) {\\n        if (a[idx] == f) { // 0 -> 1 set\\n            a[idx] = f ^ 1;\\n            One++;\\n        }\\n    }\\n    function unfix(idx) {\\n        if (a[idx] != f) { // 1 -> 0 unset\\n            a[idx] = f;\\n            One--;\\n        }\\n    }\\n    function flip() {\\n        f ^= 1;\\n        One = n - One;\\n    }\\n    function all() {\\n        return One == n;\\n    }\\n    function one() {\\n        return One >= 1;\\n    }\\n    function count() {\\n        return One;\\n    }\\n    function toString() {\\n        let res = \\'\\';\\n        for(const x of a) res += x ^ f;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1748522,
                "title": "c-t-100-s-100-o-1-including-tostring",
                "content": "I have maintained a variable `flipp` that counts the no if time the flip function is called and i donot update the bit string everytime flip is called.\\nif `flipp%2` is even, my bit string is ``bit`` else ``rev``\\nAlso having a rev string that is reverse of bit string helps in doing a few operations in O(1)\\n\\n ``count1`` stores no. of time ``1`` in `bit` string\\n\\n```\\nclass Bitset {\\npublic:\\n    string bit = \"\";\\n    string rev = \"\";\\n    int count1 = 0;\\n    int flipp = 0;\\n    int n;\\n    \\n    Bitset(int size) {\\n        for(int i=0; i<size; i++) {\\n            bit += \\'0\\';\\n            rev += \\'1\\';\\n        }\\n        n = size;\\n    }\\n    \\n    void fix(int idx) {\\n        if(flipp%2==0) {\\n            if(bit[idx] == \\'0\\') count1++;\\n            bit[idx] = \\'1\\';\\n            rev[idx] = \\'0\\';\\n        } else {\\n            // if flipped, we need to fix rev and unfix bit at idx\\n            // count1 is 1 bits in bit not rev\\n            if(bit[idx] == \\'1\\') count1--;\\n            bit[idx] = \\'0\\';\\n            rev[idx] = \\'1\\';\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(flipp%2==0)\\n        {\\n            if(bit[idx] == \\'1\\') count1--;\\n            bit[idx] = \\'0\\';\\n            rev[idx] = \\'1\\';\\n        } else {\\n            // if flipped, we need to unfix rev and fix bit at idx\\n            if(bit[idx] == \\'0\\') count1++;\\n            bit[idx] = \\'1\\';\\n            rev[idx] = \\'0\\';\\n        }\\n    }\\n    \\n    void flip() {\\n        flipp++;\\n    }\\n    \\n    bool all() {\\n        //if flipped count 1\\'s in rev i.e., n-count1\\n        int temp = (flipp%2)? (n-count1) : count1;\\n        if(temp == n) return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n        //if flipped count 1\\'s in rev i.e., n-count1\\n        int temp = (flipp%2) ? (n-count1) : count1;\\n        if(temp) return true;\\n        return false;\\n    }\\n    \\n    int count() {\\n        if(flipp%2) return n-count1;\\n        return count1;\\n    }\\n    \\n    string toString() {\\n        return flipp%2 ? rev : bit;\\n    }\\n};\\n```\\n\\nDo Upvote if it helps :)",
                "solutionTags": [],
                "code": "```\\nclass Bitset {\\npublic:\\n    string bit = \"\";\\n    string rev = \"\";\\n    int count1 = 0;\\n    int flipp = 0;\\n    int n;\\n    \\n    Bitset(int size) {\\n        for(int i=0; i<size; i++) {\\n            bit += \\'0\\';\\n            rev += \\'1\\';\\n        }\\n        n = size;\\n    }\\n    \\n    void fix(int idx) {\\n        if(flipp%2==0) {\\n            if(bit[idx] == \\'0\\') count1++;\\n            bit[idx] = \\'1\\';\\n            rev[idx] = \\'0\\';\\n        } else {\\n            // if flipped, we need to fix rev and unfix bit at idx\\n            // count1 is 1 bits in bit not rev\\n            if(bit[idx] == \\'1\\') count1--;\\n            bit[idx] = \\'0\\';\\n            rev[idx] = \\'1\\';\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(flipp%2==0)\\n        {\\n            if(bit[idx] == \\'1\\') count1--;\\n            bit[idx] = \\'0\\';\\n            rev[idx] = \\'1\\';\\n        } else {\\n            // if flipped, we need to unfix rev and fix bit at idx\\n            if(bit[idx] == \\'0\\') count1++;\\n            bit[idx] = \\'1\\';\\n            rev[idx] = \\'0\\';\\n        }\\n    }\\n    \\n    void flip() {\\n        flipp++;\\n    }\\n    \\n    bool all() {\\n        //if flipped count 1\\'s in rev i.e., n-count1\\n        int temp = (flipp%2)? (n-count1) : count1;\\n        if(temp == n) return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n        //if flipped count 1\\'s in rev i.e., n-count1\\n        int temp = (flipp%2) ? (n-count1) : count1;\\n        if(temp) return true;\\n        return false;\\n    }\\n    \\n    int count() {\\n        if(flipp%2) return n-count1;\\n        return count1;\\n    }\\n    \\n    string toString() {\\n        return flipp%2 ? rev : bit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748463,
                "title": "c-solution-with-explanation",
                "content": "```\\n/*\\nIn this code :-\\n\\nzeros stores the number of zeros in the bitset\\none stores the number of ones in the bitset\\nflipCount is the number of times the bitset in flipped\\narr[i] is the number of times the ith bit is changed \\n\\nNote all bits are 0 by default.\\n\\nNow let\\'s consider a bit 0, \\n(Total times changed = 1) After the bit is changed once, the bit will become 1\\n(Total times changed = 2) The bit will become 0\\n(Total times changed = 3) The bit will become 1\\n(Total times changed = 4) The bit will become 0\\n\\nSo if the number of times bit is changed is even, then the final bit is 0 else 1\\n\\nflipCount idicates nothing but the number of times every bit needs to changed.\\nSo the number of times the ith bit of a bitset is changed = arr[i]+flipCount and this is what we need to do the question.\\n\\nRest of the code is easy to understand, if u have any doubts do ask.\\nAlso please upvote if u liked the Solution :D\\n*/\\n\\n\\nclass Bitset {\\npublic:\\n    \\n    int zeros,ones,flipCount,size;\\n    vector<int> arr;\\n    \\n    Bitset(int len) {\\n        \\n        zeros = len; size = len;\\n        ones = 0; flipCount = 0;\\n        \\n        while(len--) arr.push_back(0);\\n    }\\n    \\n    void fix(int idx) {\\n        if((arr[idx]+flipCount)%2 == 0) { //checking if i need to change the bit from 0 to 1\\n            ++arr[idx]; --zeros; ++ones;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if((arr[idx]+flipCount)%2 == 1) { //checking if i need to change the bit from 1 to 0\\n            ++arr[idx]; ++zeros; --ones;\\n        }\\n    }\\n    \\n    void flip() {\\n        ++flipCount;\\n        swap(ones,zeros);\\n    }\\n    \\n    bool all() {\\n        return (ones == size);\\n    }\\n    \\n    bool one() {\\n        return (ones != 0);\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        string ans = \"\";\\n        for(int x:arr) {\\n            ans += ((x+flipCount)%2 + \\'0\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nIn this code :-\\n\\nzeros stores the number of zeros in the bitset\\none stores the number of ones in the bitset\\nflipCount is the number of times the bitset in flipped\\narr[i] is the number of times the ith bit is changed \\n\\nNote all bits are 0 by default.\\n\\nNow let\\'s consider a bit 0, \\n(Total times changed = 1) After the bit is changed once, the bit will become 1\\n(Total times changed = 2) The bit will become 0\\n(Total times changed = 3) The bit will become 1\\n(Total times changed = 4) The bit will become 0\\n\\nSo if the number of times bit is changed is even, then the final bit is 0 else 1\\n\\nflipCount idicates nothing but the number of times every bit needs to changed.\\nSo the number of times the ith bit of a bitset is changed = arr[i]+flipCount and this is what we need to do the question.\\n\\nRest of the code is easy to understand, if u have any doubts do ask.\\nAlso please upvote if u liked the Solution :D\\n*/\\n\\n\\nclass Bitset {\\npublic:\\n    \\n    int zeros,ones,flipCount,size;\\n    vector<int> arr;\\n    \\n    Bitset(int len) {\\n        \\n        zeros = len; size = len;\\n        ones = 0; flipCount = 0;\\n        \\n        while(len--) arr.push_back(0);\\n    }\\n    \\n    void fix(int idx) {\\n        if((arr[idx]+flipCount)%2 == 0) { //checking if i need to change the bit from 0 to 1\\n            ++arr[idx]; --zeros; ++ones;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if((arr[idx]+flipCount)%2 == 1) { //checking if i need to change the bit from 1 to 0\\n            ++arr[idx]; ++zeros; --ones;\\n        }\\n    }\\n    \\n    void flip() {\\n        ++flipCount;\\n        swap(ones,zeros);\\n    }\\n    \\n    bool all() {\\n        return (ones == size);\\n    }\\n    \\n    bool one() {\\n        return (ones != 0);\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        string ans = \"\";\\n        for(int x:arr) {\\n            ans += ((x+flipCount)%2 + \\'0\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748446,
                "title": "o-n-solution-and-all-operation-in-o-1",
                "content": "Logic- Maintain two string one for set and other for reset and a boolean variable to track which one is our current answer.\\n\\nclass Bitset {\\npublic:\\n\\n    string s=\"\";\\n    string rs=\"\";\\n    bool f=0;\\n    int czs=0,czrs=0,n;\\n    Bitset(int size) {\\n        for(int i=0;i<size;i++)\\n        {\\n            s+=\\'0\\';\\n            rs+=\\'1\\';\\n        }\\n        n=size;\\n        czs=size;\\n        czrs=0;\\n    }\\n    \\n    void fix(int i) {\\n        if(f==0)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                s[i]=\\'1\\';\\n                rs[i]=\\'0\\';\\n                czs-=1;\\n            }\\n        }\\n        else\\n        {\\n            if(rs[i]==\\'0\\')\\n            {\\n                rs[i]=\\'1\\';\\n                s[i]=\\'0\\';\\n                czs+=1;\\n            }\\n        }\\n    }\\n    \\n    void unfix(int i) {\\n        if(f==0)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                s[i]=\\'0\\';\\n                rs[i]=\\'1\\';\\n                czs+=1;\\n            }\\n        }\\n        else\\n        {\\n            if(rs[i]==\\'1\\')\\n            {\\n                rs[i]=\\'0\\';\\n                s[i]=\\'1\\';\\n                czs-=1;\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        if(f==0)f=1;\\n        else f=0;\\n    }\\n    \\n    bool all() {\\n        \\n        if(f==0)\\n        {\\n            if(czs==0)return 1;\\n            return 0;\\n        }\\n        else \\n        {\\n            if(czs==n)return 1;\\n            return 0;\\n        }\\n    }\\n    \\n    bool one() {\\n        if(f==0)\\n        {\\n            if(czs<n)return 1;\\n            return 0;\\n        }\\n        else \\n        {\\n            if(czs>0)return 1;\\n            return 0;\\n        }\\n        \\n    }\\n    \\n    int count() {\\n        if(f==0)\\n        {\\n           return s.size()-czs;\\n        }\\n        \\n        return czs;\\n    }\\n    \\n    string toString() {\\n        if(f==0)return s;\\n        return rs;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "Logic- Maintain two string one for set and other for reset and a boolean variable to track which one is our current answer.\\n\\nclass Bitset {\\npublic:\\n\\n    string s=\"\";\\n    string rs=\"\";\\n    bool f=0;\\n    int czs=0,czrs=0,n;\\n    Bitset(int size) {\\n        for(int i=0;i<size;i++)\\n        {\\n            s+=\\'0\\';\\n            rs+=\\'1\\';\\n        }\\n        n=size;\\n        czs=size;\\n        czrs=0;\\n    }\\n    \\n    void fix(int i) {\\n        if(f==0)\\n        {\\n            if(s[i]==\\'0\\')\\n            {\\n                s[i]=\\'1\\';\\n                rs[i]=\\'0\\';\\n                czs-=1;\\n            }\\n        }\\n        else\\n        {\\n            if(rs[i]==\\'0\\')\\n            {\\n                rs[i]=\\'1\\';\\n                s[i]=\\'0\\';\\n                czs+=1;\\n            }\\n        }\\n    }\\n    \\n    void unfix(int i) {\\n        if(f==0)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                s[i]=\\'0\\';\\n                rs[i]=\\'1\\';\\n                czs+=1;\\n            }\\n        }\\n        else\\n        {\\n            if(rs[i]==\\'1\\')\\n            {\\n                rs[i]=\\'0\\';\\n                s[i]=\\'1\\';\\n                czs-=1;\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        if(f==0)f=1;\\n        else f=0;\\n    }\\n    \\n    bool all() {\\n        \\n        if(f==0)\\n        {\\n            if(czs==0)return 1;\\n            return 0;\\n        }\\n        else \\n        {\\n            if(czs==n)return 1;\\n            return 0;\\n        }\\n    }\\n    \\n    bool one() {\\n        if(f==0)\\n        {\\n            if(czs<n)return 1;\\n            return 0;\\n        }\\n        else \\n        {\\n            if(czs>0)return 1;\\n            return 0;\\n        }\\n        \\n    }\\n    \\n    int count() {\\n        if(f==0)\\n        {\\n           return s.size()-czs;\\n        }\\n        \\n        return czs;\\n    }\\n    \\n    string toString() {\\n        if(f==0)return s;\\n        return rs;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1754884,
                "title": "detailed-simple-easy-to-understand-o-1",
                "content": "```\\nclass Bitset {\\npublic:\\n    string original;\\n    int flip_count,count_one;;\\n    Bitset(int size) {\\n        flip_count = count_one = 0;\\n        for(int i=1;i<=size;i++){\\n            original.push_back(\\'0\\');\\n        }\\n    }\\n    \\n    void fix(int idx) {\\n        if(original[idx]==\\'0\\'){\\n            if(!flip_count){\\n                count_one++;\\n                original[idx] = \\'1\\';\\n            }\\n        }\\n        else{\\n            if(flip_count){\\n                count_one++;\\n                original[idx] = \\'0\\';\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(original[idx]==\\'0\\'){\\n            if(flip_count){\\n                count_one--;\\n                original[idx] = \\'1\\';\\n            }\\n        }\\n        else{\\n            if(!flip_count){\\n                count_one--;\\n                original[idx] = \\'0\\';\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        flip_count++;\\n        flip_count%=2;\\n        count_one = original.length() - count_one;\\n    }\\n    \\n    bool all() {\\n        return count_one==original.length();\\n    }\\n    \\n    bool one() {\\n        return count_one!=0;\\n    }\\n    \\n    int count() {\\n        return count_one;\\n    }\\n    \\n    string toString() {\\n        string ans;\\n        for(auto& c:original){\\n            if((c==\\'0\\' and !flip_count) or (c==\\'1\\' and flip_count)){\\n                ans.push_back(\\'0\\');\\n            }\\n            else{\\n                ans.push_back(\\'1\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Bitset {\\npublic:\\n    string original;\\n    int flip_count,count_one;;\\n    Bitset(int size) {\\n        flip_count = count_one = 0;\\n        for(int i=1;i<=size;i++){\\n            original.push_back(\\'0\\');\\n        }\\n    }\\n    \\n    void fix(int idx) {\\n        if(original[idx]==\\'0\\'){\\n            if(!flip_count){\\n                count_one++;\\n                original[idx] = \\'1\\';\\n            }\\n        }\\n        else{\\n            if(flip_count){\\n                count_one++;\\n                original[idx] = \\'0\\';\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(original[idx]==\\'0\\'){\\n            if(flip_count){\\n                count_one--;\\n                original[idx] = \\'1\\';\\n            }\\n        }\\n        else{\\n            if(!flip_count){\\n                count_one--;\\n                original[idx] = \\'0\\';\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        flip_count++;\\n        flip_count%=2;\\n        count_one = original.length() - count_one;\\n    }\\n    \\n    bool all() {\\n        return count_one==original.length();\\n    }\\n    \\n    bool one() {\\n        return count_one!=0;\\n    }\\n    \\n    int count() {\\n        return count_one;\\n    }\\n    \\n    string toString() {\\n        string ans;\\n        for(auto& c:original){\\n            if((c==\\'0\\' and !flip_count) or (c==\\'1\\' and flip_count)){\\n                ans.push_back(\\'0\\');\\n            }\\n            else{\\n                ans.push_back(\\'1\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751074,
                "title": "c-easy-understanding-using-vector-as-bitset-100-time-100-space",
                "content": "The implementation is simple, we are using a vector for storing the bitset \\nand maintaining the **count of flips.**\\nIf **flips are even** then we treat **0 as 0 and 1 as 1** because the bitset will remain same after even number of flips.\\nIf it flipped means, **flips are odd** then we treat **0 as 1 and 1 as 0.**\\n```\\nclass Bitset {\\n    \\n    vector<int> v;          // for storing the bits\\n    int n, counts, flips;  // n for the size, counts for maintaining the count of ones\\n                          // flips for counting the number of flips\\npublic:\\n    Bitset(int size) {\\n        n = size;\\n        v = vector<int>(size,0);\\n        counts = flips = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(flips%2 == 0)   // if flips is even, then the bitset will reamain as it is.\\n        {\\n            if(v[idx] == 0)\\n            {\\n                v[idx] = 1, counts++;\\n            }\\n        }\\n        else\\n        {\\n            if(v[idx] == 1)\\n            {\\n                v[idx] = 0, counts++;\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(flips%2 == 0)\\n        {\\n            if(v[idx] == 1)\\n            {\\n                v[idx] = 0, counts--;\\n            }\\n        }\\n        else\\n        {\\n            if(v[idx] == 0)\\n            {\\n                v[idx] = 1, counts--;\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        flips += 1;\\n        counts = n - counts;   // changing the number of total ones\\n    }\\n    \\n    bool all() {\\n        return n == counts;\\n    }\\n    \\n    bool one() {\\n        return counts > 0;\\n    }\\n    \\n    int count() {\\n        return counts;\\n    }\\n    \\n    string toString() {\\n        string s =\"\";\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(flips%2 == 0)   // if flips is even then the bitset will remain as it is.\\n            {\\n                if(v[i] == 0) s += \\'0\\';\\n                else  s += \\'1\\';\\n            }\\n            else\\n            {\\n                if(v[i] == 0) s += \\'1\\';\\n                else  s += \\'0\\';   \\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Bitset {\\n    \\n    vector<int> v;          // for storing the bits\\n    int n, counts, flips;  // n for the size, counts for maintaining the count of ones\\n                          // flips for counting the number of flips\\npublic:\\n    Bitset(int size) {\\n        n = size;\\n        v = vector<int>(size,0);\\n        counts = flips = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(flips%2 == 0)   // if flips is even, then the bitset will reamain as it is.\\n        {\\n            if(v[idx] == 0)\\n            {\\n                v[idx] = 1, counts++;\\n            }\\n        }\\n        else\\n        {\\n            if(v[idx] == 1)\\n            {\\n                v[idx] = 0, counts++;\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(flips%2 == 0)\\n        {\\n            if(v[idx] == 1)\\n            {\\n                v[idx] = 0, counts--;\\n            }\\n        }\\n        else\\n        {\\n            if(v[idx] == 0)\\n            {\\n                v[idx] = 1, counts--;\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        flips += 1;\\n        counts = n - counts;   // changing the number of total ones\\n    }\\n    \\n    bool all() {\\n        return n == counts;\\n    }\\n    \\n    bool one() {\\n        return counts > 0;\\n    }\\n    \\n    int count() {\\n        return counts;\\n    }\\n    \\n    string toString() {\\n        string s =\"\";\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(flips%2 == 0)   // if flips is even then the bitset will remain as it is.\\n            {\\n                if(v[i] == 0) s += \\'0\\';\\n                else  s += \\'1\\';\\n            }\\n            else\\n            {\\n                if(v[i] == 0) s += \\'1\\';\\n                else  s += \\'0\\';   \\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1750521,
                "title": "javascript-3-attempts-tweaks-finally-reworked-for-100-faster-and-100-less-mem",
                "content": "![image](https://assets.leetcode.com/users/images/191824f9-c75e-4f57-a5d4-803303d9b49f_1644166686.9546738.png)\\n\\nThis was question 3 in last nights contest.  At first read, seems really easy... (famous last words).\\nFirst attempt was just using an array, filled with zeros to start, and do the operations per the instructions.  Easy peasy... nope, got a TLE.\\nOk, so i\\'ll just optimize a few things.  no more filters... nope, still not enough.  Maybe the flip was taking too long.  Ok, i\\'ll make a dupicate inverse array, and just swap them on flip calls... still TLE... what else... I still had a pretty inefficient \"count\" function... how to speed that up... ugg, time ran out.\\n\\nNext morning I browsed the discussion and found a pretty sharp solution that wasn\\'t an impovement to what I had, but a complete change of implementation.  Rather than using the array up front, why not have 2 sets, one for 0\\'s another for 1\\'s.  simply move indexes between the two.  Each function implementation was easy, and oh so efficient.  Credit to pgmreddy for his code paste into the discussion board.\\n\\nHere\\'s my code, along with commented out iterations before getting to the final where I used 2 sets:\\n\\n```\\nvar Bitset = function(size) {\\n    //this.bits = new Array(size).fill(0);\\n    //this.bitsOp = new Array(size).fill(1);\\n    this.set0 = new Set();\\n    this.set1 = new Set();\\n    for (let i = 0; i<size; i++) this.set0.add(i);\\n};\\n\\n/** \\n * @param {number} idx\\n * @return {void}\\n */\\nBitset.prototype.fix = function(idx) {\\n  //this.bits[idx] = 1;\\n  //this.bitsOp[idx] = 0;\\n  if (this.set0.has(idx)) {\\n    this.set1.add(idx);\\n    this.set0.delete(idx);\\n  }\\n};\\n\\n/** \\n * @param {number} idx\\n * @return {void}\\n */\\nBitset.prototype.unfix = function(idx) {\\n  //this.bits[idx] = 0;\\n  //this.bitsOp[idx] = 1;\\n  if (this.set1.has(idx)) {\\n    this.set0.add(idx);\\n    this.set1.delete(idx);\\n  }\\n};\\n\\n/**\\n * @return {void}\\n */\\nBitset.prototype.flip = function() {\\n  //this.bits = this.bits.map(x=>(x)?0:1); \\n  //this.bits.forEach(x=>x=(x)?0:1); \\n  [this.set0, this.set1] = [this.set1, this.set0];\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nBitset.prototype.all = function() {\\n  //return (this.bits.filter(x=>x).length == this.bits.length) \\n  //return !this.bits.includes(0);\\n  //for (let i = 0; i<this.bits.length; i++)\\n    //if (this.bits[i] === 0) return false;\\n   //return true; \\n  return this.set0.size===0\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nBitset.prototype.one = function() {\\n    //return this.bits.filter(x=>x).length>0 \\n    //return this.bits.includes(1);\\n    //for (let i = 0; i<this.bits.length; i++)\\n      //if (this.bits[i] === 1) return true;\\n     //return false; \\n  return this.set1.size>0;\\n};\\n\\n/**\\n * @return {number}\\n */\\nBitset.prototype.count = function() {\\n    //return this.bits.filter(x=>x).length \\n  //return this.bits.reduce((sum, cur)=>sum+cur);\\n  return this.set1.size;\\n};\\n\\n/**\\n * @return {string}\\n */\\nBitset.prototype.toString = function() {\\n    //return this.bits.join(\\'\\');\\n  let set = new Array(this.set0.size+this.set1.size);\\n  for (let i=0; i<set.length; i++) {\\n    set[i] = this.set0.has(i)?0:1;\\n  }\\n  return set.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar Bitset = function(size) {\\n    //this.bits = new Array(size).fill(0);\\n    //this.bitsOp = new Array(size).fill(1);\\n    this.set0 = new Set();\\n    this.set1 = new Set();\\n    for (let i = 0; i<size; i++) this.set0.add(i);\\n};\\n\\n/** \\n * @param {number} idx\\n * @return {void}\\n */\\nBitset.prototype.fix = function(idx) {\\n  //this.bits[idx] = 1;\\n  //this.bitsOp[idx] = 0;\\n  if (this.set0.has(idx)) {\\n    this.set1.add(idx);\\n    this.set0.delete(idx);\\n  }\\n};\\n\\n/** \\n * @param {number} idx\\n * @return {void}\\n */\\nBitset.prototype.unfix = function(idx) {\\n  //this.bits[idx] = 0;\\n  //this.bitsOp[idx] = 1;\\n  if (this.set1.has(idx)) {\\n    this.set0.add(idx);\\n    this.set1.delete(idx);\\n  }\\n};\\n\\n/**\\n * @return {void}\\n */\\nBitset.prototype.flip = function() {\\n  //this.bits = this.bits.map(x=>(x)?0:1); \\n  //this.bits.forEach(x=>x=(x)?0:1); \\n  [this.set0, this.set1] = [this.set1, this.set0];\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nBitset.prototype.all = function() {\\n  //return (this.bits.filter(x=>x).length == this.bits.length) \\n  //return !this.bits.includes(0);\\n  //for (let i = 0; i<this.bits.length; i++)\\n    //if (this.bits[i] === 0) return false;\\n   //return true; \\n  return this.set0.size===0\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nBitset.prototype.one = function() {\\n    //return this.bits.filter(x=>x).length>0 \\n    //return this.bits.includes(1);\\n    //for (let i = 0; i<this.bits.length; i++)\\n      //if (this.bits[i] === 1) return true;\\n     //return false; \\n  return this.set1.size>0;\\n};\\n\\n/**\\n * @return {number}\\n */\\nBitset.prototype.count = function() {\\n    //return this.bits.filter(x=>x).length \\n  //return this.bits.reduce((sum, cur)=>sum+cur);\\n  return this.set1.size;\\n};\\n\\n/**\\n * @return {string}\\n */\\nBitset.prototype.toString = function() {\\n    //return this.bits.join(\\'\\');\\n  let set = new Array(this.set0.size+this.set1.size);\\n  for (let i=0; i<set.length; i++) {\\n    set[i] = this.set0.has(i)?0:1;\\n  }\\n  return set.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1748934,
                "title": "all-o-1-100-time-100-space",
                "content": "<br/>\\n\\n```\\nclass Bitset {\\npublic:\\n    string bitset, flipped;\\n    int set = 0, n;\\n    \\n    Bitset(int size) {\\n        bitset = string(size, \\'0\\');\\n        flipped = string(size, \\'1\\');\\n        n = size;\\n    }\\n    \\n    void fix(int idx) {\\n        if(bitset[idx] == \\'0\\') set++;\\n        bitset[idx] = \\'1\\';\\n        flipped[idx] = \\'0\\';\\n    }\\n    \\n    void unfix(int idx) {\\n        if(bitset[idx] == \\'1\\') set--;\\n        bitset[idx] = \\'0\\';\\n        flipped[idx] = \\'1\\';\\n    }\\n    \\n    void flip() {\\n        bitset.swap(flipped);\\n        set = n - set;\\n    }\\n    \\n    bool all() {\\n        return set == n;\\n    }\\n    \\n    bool one() {\\n        return  set >= 1;\\n    }\\n    \\n    int count() {\\n        return set;\\n    }\\n    \\n    string toString() {\\n        return bitset;\\n    }\\n};\\n```\\n\\n<br/>",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    string bitset, flipped;\\n    int set = 0, n;\\n    \\n    Bitset(int size) {\\n        bitset = string(size, \\'0\\');\\n        flipped = string(size, \\'1\\');\\n        n = size;\\n    }\\n    \\n    void fix(int idx) {\\n        if(bitset[idx] == \\'0\\') set++;\\n        bitset[idx] = \\'1\\';\\n        flipped[idx] = \\'0\\';\\n    }\\n    \\n    void unfix(int idx) {\\n        if(bitset[idx] == \\'1\\') set--;\\n        bitset[idx] = \\'0\\';\\n        flipped[idx] = \\'1\\';\\n    }\\n    \\n    void flip() {\\n        bitset.swap(flipped);\\n        set = n - set;\\n    }\\n    \\n    bool all() {\\n        return set == n;\\n    }\\n    \\n    bool one() {\\n        return  set >= 1;\\n    }\\n    \\n    int count() {\\n        return set;\\n    }\\n    \\n    string toString() {\\n        return bitset;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748711,
                "title": "javascript-2166-design-bitset",
                "content": "---\\n\\n- **Biweekly Contest 71 answers**\\n  - Q1\\n    - https://leetcode.com/problems/minimum-sum-of-four-digit-number-after-splitting-digits/discuss/1748621/JavaScript-2160.-Minimum-Sum-of-Four-Digit-Number-After-Splitting-Digits\\n  - Q2\\n    - https://leetcode.com/problems/partition-array-according-to-given-pivot/discuss/1748639/JavaScript-2161.-Partition-Array-According-to-Given-Pivot\\n  - Q3\\n    - https://leetcode.com/problems/minimum-cost-to-set-cooking-time/discuss/1748347/JavaScript-2162.-Minimum-Cost-to-Set-Cooking-Time\\n\\n---\\n\\n- **Weekly Contest 279 answers**\\n  - Q1\\n    - https://leetcode.com/problems/sort-even-and-odd-indices-independently/discuss/1748670/JavaScript-2164.-Sort-Even-and-Odd-Indices-Independently\\n  - Q2\\n    - https://leetcode.com/problems/smallest-value-of-the-rearranged-number/discuss/1748702/JavaScript-2165.-Smallest-Value-of-the-Rearranged-Number\\n  - Q3\\n    - https://leetcode.com/problems/design-bitset/discuss/1748711/JavaScript-2166.-Design-Bitset\\n    - **below**\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nlet n;\\nlet a;\\nlet set0;\\nlet set1;\\n\\nvar Bitset = function (size) {\\n    n = size;\\n    a = new Array(size).fill(0);\\n    set0 = new Set();\\n    set1 = new Set();\\n\\n    for (let i = 0; i < n; i++) set0.add(i);\\n};\\nBitset.prototype.fix = function (idx) {\\n    if (!set1.has(idx)) {\\n        set1.add(idx);\\n        set0.delete(idx);\\n    }\\n};\\nBitset.prototype.unfix = function (idx) {\\n    if (set1.has(idx)) {\\n        set0.add(idx);\\n        set1.delete(idx);\\n    }\\n};\\nBitset.prototype.flip = function () {\\n    [set0, set1] = [set1, set0];\\n};\\nBitset.prototype.all = function () {\\n    return !set0.size;\\n};\\nBitset.prototype.one = function () {\\n    return set1.size;\\n};\\nBitset.prototype.count = function () {\\n    return set1.size;\\n};\\nBitset.prototype.toString = function () {\\n    for (let i = 0; i < n; i++) a[i] = set0.has(i) ? 0 : 1;\\n    return a.join(\"\");\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet n;\\nlet a;\\nlet set0;\\nlet set1;\\n\\nvar Bitset = function (size) {\\n    n = size;\\n    a = new Array(size).fill(0);\\n    set0 = new Set();\\n    set1 = new Set();\\n\\n    for (let i = 0; i < n; i++) set0.add(i);\\n};\\nBitset.prototype.fix = function (idx) {\\n    if (!set1.has(idx)) {\\n        set1.add(idx);\\n        set0.delete(idx);\\n    }\\n};\\nBitset.prototype.unfix = function (idx) {\\n    if (set1.has(idx)) {\\n        set0.add(idx);\\n        set1.delete(idx);\\n    }\\n};\\nBitset.prototype.flip = function () {\\n    [set0, set1] = [set1, set0];\\n};\\nBitset.prototype.all = function () {\\n    return !set0.size;\\n};\\nBitset.prototype.one = function () {\\n    return set1.size;\\n};\\nBitset.prototype.count = function () {\\n    return set1.size;\\n};\\nBitset.prototype.toString = function () {\\n    for (let i = 0; i < n; i++) a[i] = set0.has(i) ? 0 : 1;\\n    return a.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1748622,
                "title": "python-straightforward-idea-with-bit-operation",
                "content": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.l = size\\n        self.b = 0\\n        self.c = 0\\n        mask = 1<<(self.l)\\n        self.mask = mask -1\\n\\n        \\n\\n    def fix(self, idx: int) -> None:\\n        t = 1 << (self.l-idx-1)\\n        if self.b != (self.b | t):\\n            self.c += 1\\n        self.b = self.b | t\\n        \\n\\n    def unfix(self, idx: int) -> None:\\n        t = 1 << (self.l-idx-1)\\n        t = self.mask ^ t\\n        if self.b != (self.b & t):\\n            self.c -= 1\\n        self.b = self.b & t\\n        \\n\\n    def flip(self) -> None:\\n\\n        self.b = self.b ^ self.mask\\n        self.c = self.l - self.c\\n        \\n\\n    def all(self) -> bool:\\n\\n        return self.b == self.mask\\n        \\n\\n    def one(self) -> bool:\\n        return self.b > 0\\n        \\n\\n    def count(self) -> int:\\n        return self.c\\n    \\n        \\n\\n    def toString(self) -> str:\\n        t = self.b\\n        mask = 1\\n        res = \"\"\\n        while True:\\n            if t == 0:\\n                break\\n            res = str(t&mask)+res\\n            t = t >> 1\\n        if len(res) < self.l:\\n            return \"0\"*(self.l-len(res)) + res\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.l = size\\n        self.b = 0\\n        self.c = 0\\n        mask = 1<<(self.l)\\n        self.mask = mask -1\\n\\n        \\n\\n    def fix(self, idx: int) -> None:\\n        t = 1 << (self.l-idx-1)\\n        if self.b != (self.b | t):\\n            self.c += 1\\n        self.b = self.b | t\\n        \\n\\n    def unfix(self, idx: int) -> None:\\n        t = 1 << (self.l-idx-1)\\n        t = self.mask ^ t\\n        if self.b != (self.b & t):\\n            self.c -= 1\\n        self.b = self.b & t\\n        \\n\\n    def flip(self) -> None:\\n\\n        self.b = self.b ^ self.mask\\n        self.c = self.l - self.c\\n        \\n\\n    def all(self) -> bool:\\n\\n        return self.b == self.mask\\n        \\n\\n    def one(self) -> bool:\\n        return self.b > 0\\n        \\n\\n    def count(self) -> int:\\n        return self.c\\n    \\n        \\n\\n    def toString(self) -> str:\\n        t = self.b\\n        mask = 1\\n        res = \"\"\\n        while True:\\n            if t == 0:\\n                break\\n            res = str(t&mask)+res\\n            t = t >> 1\\n        if len(res) < self.l:\\n            return \"0\"*(self.l-len(res)) + res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580666,
                "title": "easy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n(i) Initialize two string with all chars \\'0\\' and \\'1\\',like s0=\"0000\" and s1=\"1111\";\\n(ii) perform the given instruction on string s0 and exactly do opposite on string s1;\\n(iii) initially take int zero=size and int one=0;\\n(iv) for fix func call do 0--; and 1++; and for unfix do exactly opposite.\\n(v) In flip function swap(s0,s1) and swap(zero,one);\\n\\n# Complexity\\n- Time complexity:\\n$$O(size)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Bitset {\\npublic:\\n    int n,zero,One;\\n    string s0=\"\",s1=\"\";\\n    Bitset(int size) {\\n        n=size;\\n      for(int i=0;i<n;i++){\\n          s0+=\\'0\\';\\n          s1+=\\'1\\';\\n      }\\n      zero=size;\\n      One=0;  \\n    }\\n    \\n    void fix(int idx) {\\n        if(s0[idx]==\\'0\\'){\\n        zero--;\\n        One++;\\n        }\\n       s0[idx]=\\'1\\';\\n       s1[idx]=\\'0\\';\\n            \\n            \\n        \\n    }\\n    \\n    void unfix(int idx) {\\n        if(s0[idx]==\\'1\\'){\\n        zero++;\\n        One--;\\n        }\\n        s0[idx]=\\'0\\';\\n        s1[idx]=\\'1\\';\\n         \\n    }\\n    \\n    void flip(){\\n        swap(s0,s1);\\n        swap(zero,One);\\n        \\n    }\\n    \\n    bool all() {\\n      if(One==n)\\n      return true;\\n      else\\n      return false;  \\n    }\\n    \\n    bool one() {\\n       if(One>=1)\\n      return true;\\n      else\\n      return false; \\n    }\\n    \\n    int count() {\\n        return One;\\n    }\\n    \\n    string toString() {\\n       return s0;\\n       \\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    int n,zero,One;\\n    string s0=\"\",s1=\"\";\\n    Bitset(int size) {\\n        n=size;\\n      for(int i=0;i<n;i++){\\n          s0+=\\'0\\';\\n          s1+=\\'1\\';\\n      }\\n      zero=size;\\n      One=0;  \\n    }\\n    \\n    void fix(int idx) {\\n        if(s0[idx]==\\'0\\'){\\n        zero--;\\n        One++;\\n        }\\n       s0[idx]=\\'1\\';\\n       s1[idx]=\\'0\\';\\n            \\n            \\n        \\n    }\\n    \\n    void unfix(int idx) {\\n        if(s0[idx]==\\'1\\'){\\n        zero++;\\n        One--;\\n        }\\n        s0[idx]=\\'0\\';\\n        s1[idx]=\\'1\\';\\n         \\n    }\\n    \\n    void flip(){\\n        swap(s0,s1);\\n        swap(zero,One);\\n        \\n    }\\n    \\n    bool all() {\\n      if(One==n)\\n      return true;\\n      else\\n      return false;  \\n    }\\n    \\n    bool one() {\\n       if(One>=1)\\n      return true;\\n      else\\n      return false; \\n    }\\n    \\n    int count() {\\n        return One;\\n    }\\n    \\n    string toString() {\\n       return s0;\\n       \\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410972,
                "title": "flipped-flag",
                "content": "### Java\\n```java\\n    private final int[] bits;\\n    private int ones;\\n    private boolean flipped;\\n\\n    public Bitset(int size) {\\n        bits = new int[size];\\n        ones = 0;\\n        flipped = false;\\n    }\\n\\n    public void fix(int idx) {\\n        int currentValue = flipped ? bits[idx] ^ 1 : bits[idx];\\n        if (currentValue == 0)\\n            ones++;\\n\\n        bits[idx] = flipped ? 0 : 1;\\n    }\\n\\n    public void unfix(int idx) {\\n        int currentValue = flipped ? bits[idx] ^ 1 : bits[idx];\\n        if (currentValue == 1)\\n            ones--;\\n\\n        bits[idx] = flipped ? 1 : 0;\\n    }\\n\\n    public void flip() {\\n        ones = bits.length - ones;\\n        flipped = !flipped;\\n    }\\n\\n    public boolean all() {\\n        return ones == bits.length;\\n    }\\n\\n    public boolean one() {\\n        return ones > 0;\\n    }\\n\\n    public int count() {\\n        return ones;\\n    }\\n\\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for (int bit : bits) {\\n            if (flipped)\\n                sb.append(bit ^ 1);\\n            else\\n                sb.append(bit);\\n        }\\n        return sb.toString();\\n    }\\n```\\n\\n### C++\\n```cpp\\npublic:\\n    \\n    vector<int> bits;\\n    int ones;\\n    bool isFlipped;\\n    \\n    Bitset(int size) {\\n        bits.resize(size, 0);\\n        ones = 0;\\n        isFlipped = false;\\n    }\\n    \\n    void fix(int idx) {\\n        int currentValue = isFlipped ? bits[idx] ^ 1 : bits[idx];\\n        if (currentValue == 0)\\n            ones++;\\n\\n        bits[idx] = isFlipped ? 0 : 1;\\n    }\\n    \\n    void unfix(int idx) {\\n        int currentValue = isFlipped ? bits[idx] ^ 1 : bits[idx];\\n        if (currentValue == 1)\\n            ones--;\\n\\n        bits[idx] = isFlipped ? 1 : 0;\\n    }\\n    \\n    void flip() {\\n        ones = bits.size() - ones;\\n        isFlipped = !isFlipped;\\n    }\\n    \\n    bool all() {\\n        return ones == bits.size();\\n    }\\n    \\n    bool one() {\\n        return ones > 0;\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        string result = \"\";\\n        for (int bit : bits) {\\n            if (isFlipped)\\n                result += to_string(bit ^ 1);\\n            else\\n                result += to_string(bit);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\n    private final int[] bits;\\n    private int ones;\\n    private boolean flipped;\\n\\n    public Bitset(int size) {\\n        bits = new int[size];\\n        ones = 0;\\n        flipped = false;\\n    }\\n\\n    public void fix(int idx) {\\n        int currentValue = flipped ? bits[idx] ^ 1 : bits[idx];\\n        if (currentValue == 0)\\n            ones++;\\n\\n        bits[idx] = flipped ? 0 : 1;\\n    }\\n\\n    public void unfix(int idx) {\\n        int currentValue = flipped ? bits[idx] ^ 1 : bits[idx];\\n        if (currentValue == 1)\\n            ones--;\\n\\n        bits[idx] = flipped ? 1 : 0;\\n    }\\n\\n    public void flip() {\\n        ones = bits.length - ones;\\n        flipped = !flipped;\\n    }\\n\\n    public boolean all() {\\n        return ones == bits.length;\\n    }\\n\\n    public boolean one() {\\n        return ones > 0;\\n    }\\n\\n    public int count() {\\n        return ones;\\n    }\\n\\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for (int bit : bits) {\\n            if (flipped)\\n                sb.append(bit ^ 1);\\n            else\\n                sb.append(bit);\\n        }\\n        return sb.toString();\\n    }\\n```\n```cpp\\npublic:\\n    \\n    vector<int> bits;\\n    int ones;\\n    bool isFlipped;\\n    \\n    Bitset(int size) {\\n        bits.resize(size, 0);\\n        ones = 0;\\n        isFlipped = false;\\n    }\\n    \\n    void fix(int idx) {\\n        int currentValue = isFlipped ? bits[idx] ^ 1 : bits[idx];\\n        if (currentValue == 0)\\n            ones++;\\n\\n        bits[idx] = isFlipped ? 0 : 1;\\n    }\\n    \\n    void unfix(int idx) {\\n        int currentValue = isFlipped ? bits[idx] ^ 1 : bits[idx];\\n        if (currentValue == 1)\\n            ones--;\\n\\n        bits[idx] = isFlipped ? 1 : 0;\\n    }\\n    \\n    void flip() {\\n        ones = bits.size() - ones;\\n        isFlipped = !isFlipped;\\n    }\\n    \\n    bool all() {\\n        return ones == bits.size();\\n    }\\n    \\n    bool one() {\\n        return ones > 0;\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        string result = \"\";\\n        for (int bit : bits) {\\n            if (isFlipped)\\n                result += to_string(bit ^ 1);\\n            else\\n                result += to_string(bit);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1983078,
                "title": "python-3-two-lists-keep-track-of-ones-and-zeroes",
                "content": "**Approach:** Keep two lists, one with the regular bits and other with flipped.\\n\\nAlso, keep track of the number of ones and zeroes in the regular.\\nThen it is straightforward solution.\\nWhen using flip, interchange the two lists and the number of ones and zeroes.\\n\\n**DO UPVOTE IF YOU FOUND IT HELPFUL.**\\n\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bits = [0 for i in range(size)]\\n        self.flipped = [1 for i in range(size)]\\n        self.size = size\\n        self.ones = 0\\n        self.zeroes = self.size\\n\\n    def fix(self, idx: int) -> None:\\n        self.flipped[idx] = 0\\n        if self.bits[idx] == 1:\\n            return\\n        self.bits[idx] = 1\\n        self.ones += 1\\n        self.zeroes -= 1\\n\\n    def unfix(self, idx: int) -> None:\\n        self.flipped[idx] = 1\\n        if self.bits[idx] == 0:\\n            return\\n        self.bits[idx] = 0\\n        self.zeroes += 1\\n        self.ones -= 1\\n\\n    def flip(self) -> None:\\n        self.bits, self.flipped = self.flipped, self.bits\\n        self.ones = self.size-self.ones\\n        self.zeroes = self.size-self.zeroes\\n\\n    def all(self) -> bool:\\n        return self.ones == self.size\\n\\n    def one(self) -> bool:\\n        return self.ones > 0\\n\\n    def count(self) -> int:\\n        return self.ones\\n\\n    def toString(self) -> str:\\n        return \"\".join([str(i) for i in self.bits])\\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Design"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bits = [0 for i in range(size)]\\n        self.flipped = [1 for i in range(size)]\\n        self.size = size\\n        self.ones = 0\\n        self.zeroes = self.size\\n\\n    def fix(self, idx: int) -> None:\\n        self.flipped[idx] = 0\\n        if self.bits[idx] == 1:\\n            return\\n        self.bits[idx] = 1\\n        self.ones += 1\\n        self.zeroes -= 1\\n\\n    def unfix(self, idx: int) -> None:\\n        self.flipped[idx] = 1\\n        if self.bits[idx] == 0:\\n            return\\n        self.bits[idx] = 0\\n        self.zeroes += 1\\n        self.ones -= 1\\n\\n    def flip(self) -> None:\\n        self.bits, self.flipped = self.flipped, self.bits\\n        self.ones = self.size-self.ones\\n        self.zeroes = self.size-self.zeroes\\n\\n    def all(self) -> bool:\\n        return self.ones == self.size\\n\\n    def one(self) -> bool:\\n        return self.ones > 0\\n\\n    def count(self) -> int:\\n        return self.ones\\n\\n    def toString(self) -> str:\\n        return \"\".join([str(i) for i in self.bits])\\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818301,
                "title": "using-array-to-store-bit-and-it-s-compliment-swap",
                "content": "```\\nclass Bitset {\\n    char bit[];\\n    char flip[];\\n    int size;\\n    int count;\\n    public Bitset(int size) {\\n        bit=new char[size];\\n        flip=new char[size];\\n        this.size=size;\\n        this.count=0;\\n        Arrays.fill(bit,\\'0\\');\\n        Arrays.fill(flip,\\'1\\');\\n    }\\n    \\n    public void fix(int idx) {\\n        if(bit[idx]==\\'0\\')\\n            count++;\\n        bit[idx]=\\'1\\';\\n        flip[idx]=\\'0\\';\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(bit[idx]==\\'1\\')\\n            count--;\\n        bit[idx]=\\'0\\';\\n        flip[idx]=\\'1\\';\\n    }\\n    \\n    public void flip() {\\n        char []temp=bit;\\n        bit=flip;\\n        flip=temp;\\n        count=size-count;\\n    }\\n    \\n    public boolean all() {\\n        return count==size;\\n    }\\n    \\n    public boolean one() {\\n        return count>0;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n    \\n    public String toString() {\\n        return new String(bit);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Bitset {\\n    char bit[];\\n    char flip[];\\n    int size;\\n    int count;\\n    public Bitset(int size) {\\n        bit=new char[size];\\n        flip=new char[size];\\n        this.size=size;\\n        this.count=0;\\n        Arrays.fill(bit,\\'0\\');\\n        Arrays.fill(flip,\\'1\\');\\n    }\\n    \\n    public void fix(int idx) {\\n        if(bit[idx]==\\'0\\')\\n            count++;\\n        bit[idx]=\\'1\\';\\n        flip[idx]=\\'0\\';\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(bit[idx]==\\'1\\')\\n            count--;\\n        bit[idx]=\\'0\\';\\n        flip[idx]=\\'1\\';\\n    }\\n    \\n    public void flip() {\\n        char []temp=bit;\\n        bit=flip;\\n        flip=temp;\\n        count=size-count;\\n    }\\n    \\n    public boolean all() {\\n        return count==size;\\n    }\\n    \\n    public boolean one() {\\n        return count>0;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n    \\n    public String toString() {\\n        return new String(bit);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752032,
                "title": "explained-c-solution",
                "content": "In this given Question , flip , count ,all , one are few operations which if done in simple manner can take O(n) time for each operations  which can leads to TLE for the given constraints.\\nHere is the that approch.\\n### This will give TLE\\n```\\nclass Bitset {\\npublic:\\n    vector<bool> bits;\\n    int bitsize=0;\\n    Bitset(int size) {\\n\\n    vector<bool> v(size,false);\\n    bits=v;\\n     bitsize=size;\\n    }\\n    \\n    void fix(int idx) {\\n      bits[idx]=1;  \\n    }\\n    \\n    void unfix(int idx) {\\n        bits[idx]=0;\\n    }\\n    \\n    void flip() {\\n      \\n        for(int i=0;i<bits.size();i++)\\n        bits[i]=!bits[i];\\n    }\\n    \\n    bool all() {\\n     for(bool it:bits)\\n     if(it==false)return false;\\n        \\n    return true;\\n    }\\n    \\n    bool one() {\\n     for(bool it:bits)\\n     if(it==true)return true;\\n        \\n     return false;\\n    }\\n    \\n    int count() {\\n        int c=0;\\n        for(bool it:bits)\\n        if(it)c++;\\n        \\n        return c;\\n    }\\n    \\n    string toString() {\\n         string ans; \\n        \\n        for(int i=0;i<bits.size();i++)\\n        {\\n            if(bits[i]==true)\\n             ans+=\\'1\\';\\n            else\\n            ans+=\\'0\\';\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n\\n### **Improved Solution(Accepted)**\\nTo improve this solution we will use few variabes which will keep count of zero , one and no. of flips.\\nIt will improve flip , all , one & count operation.Instead of fliping all bit we will just keep track of flips and change the swap the no. of zeros and ones. And we will change our fix, unfix and tostring operations according to the no. of flips is even or odd.\\n\\n```\\nclass Bitset {\\npublic:\\n    vector<bool> bits;\\n    int bitsize=0;\\n    int z=0;\\n    int o=0;\\n    int f=0;\\n    Bitset(int size) {\\n\\n    vector<bool> v(size,false);\\n    bits=v;\\n    z=size;\\n    o=0;\\n    }\\n    \\n    void fix(int idx) {\\n      if(f%2==0)\\n      {\\n       if(bits[idx]==0)\\n      {\\n       bits[idx]=1;\\n       o++;\\n       z--;   \\n      }   \\n      }else{\\n       if(bits[idx]==1)\\n      {\\n       bits[idx]=0;\\n       o++;\\n       z--;   \\n      }  \\n      }\\n      \\n     \\n    }\\n    \\n    void unfix(int idx) {\\n      \\n    if(f%2==0)\\n    {  \\n     if(bits[idx]==1)\\n      {\\n       bits[idx]=0;\\n       z++;\\n       o--;   \\n      }\\n        \\n    }else{\\n       if(bits[idx]==0)\\n      {\\n       bits[idx]=1;\\n       z++;\\n       o--;   \\n      }   \\n     }\\n    }\\n    \\n    void flip() {\\n      f++;\\n      int temp=o;\\n      o=z;\\n      z=temp;\\n    }\\n    \\n    bool all() {\\n    \\n        return o==bits.size();\\n    }\\n    \\n    bool one() {\\n     \\n        return o;\\n    }\\n    \\n    int count() {\\n        \\n        return o;\\n    }\\n    \\n    string toString() {\\n         string ans; \\n        if(f%2==0)\\n        {\\n           for(int i=0;i<bits.size();i++)\\n          {\\n            if(bits[i]==true)\\n             ans+=\\'1\\';\\n            else\\n            ans+=\\'0\\';\\n           }   \\n        }else{\\n           for(int i=0;i<bits.size();i++)\\n          {\\n            if(bits[i]==true)\\n             ans+=\\'0\\';\\n            else\\n            ans+=\\'1\\';\\n           }  \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    vector<bool> bits;\\n    int bitsize=0;\\n    Bitset(int size) {\\n\\n    vector<bool> v(size,false);\\n    bits=v;\\n     bitsize=size;\\n    }\\n    \\n    void fix(int idx) {\\n      bits[idx]=1;  \\n    }\\n    \\n    void unfix(int idx) {\\n        bits[idx]=0;\\n    }\\n    \\n    void flip() {\\n      \\n        for(int i=0;i<bits.size();i++)\\n        bits[i]=!bits[i];\\n    }\\n    \\n    bool all() {\\n     for(bool it:bits)\\n     if(it==false)return false;\\n        \\n    return true;\\n    }\\n    \\n    bool one() {\\n     for(bool it:bits)\\n     if(it==true)return true;\\n        \\n     return false;\\n    }\\n    \\n    int count() {\\n        int c=0;\\n        for(bool it:bits)\\n        if(it)c++;\\n        \\n        return c;\\n    }\\n    \\n    string toString() {\\n         string ans; \\n        \\n        for(int i=0;i<bits.size();i++)\\n        {\\n            if(bits[i]==true)\\n             ans+=\\'1\\';\\n            else\\n            ans+=\\'0\\';\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Bitset {\\npublic:\\n    vector<bool> bits;\\n    int bitsize=0;\\n    int z=0;\\n    int o=0;\\n    int f=0;\\n    Bitset(int size) {\\n\\n    vector<bool> v(size,false);\\n    bits=v;\\n    z=size;\\n    o=0;\\n    }\\n    \\n    void fix(int idx) {\\n      if(f%2==0)\\n      {\\n       if(bits[idx]==0)\\n      {\\n       bits[idx]=1;\\n       o++;\\n       z--;   \\n      }   \\n      }else{\\n       if(bits[idx]==1)\\n      {\\n       bits[idx]=0;\\n       o++;\\n       z--;   \\n      }  \\n      }\\n      \\n     \\n    }\\n    \\n    void unfix(int idx) {\\n      \\n    if(f%2==0)\\n    {  \\n     if(bits[idx]==1)\\n      {\\n       bits[idx]=0;\\n       z++;\\n       o--;   \\n      }\\n        \\n    }else{\\n       if(bits[idx]==0)\\n      {\\n       bits[idx]=1;\\n       z++;\\n       o--;   \\n      }   \\n     }\\n    }\\n    \\n    void flip() {\\n      f++;\\n      int temp=o;\\n      o=z;\\n      z=temp;\\n    }\\n    \\n    bool all() {\\n    \\n        return o==bits.size();\\n    }\\n    \\n    bool one() {\\n     \\n        return o;\\n    }\\n    \\n    int count() {\\n        \\n        return o;\\n    }\\n    \\n    string toString() {\\n         string ans; \\n        if(f%2==0)\\n        {\\n           for(int i=0;i<bits.size();i++)\\n          {\\n            if(bits[i]==true)\\n             ans+=\\'1\\';\\n            else\\n            ans+=\\'0\\';\\n           }   \\n        }else{\\n           for(int i=0;i<bits.size();i++)\\n          {\\n            if(bits[i]==true)\\n             ans+=\\'0\\';\\n            else\\n            ans+=\\'1\\';\\n           }  \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751785,
                "title": "java-char-array-easy-peasy",
                "content": "```\\nclass Bitset {\\n    char[] real;\\n    char[] dup;\\n    int realCount;\\n    int dupCount;\\n    int size;\\n    public Bitset(int size) {\\n        this.size = size;\\n        realCount = 0;\\n        dupCount = size;\\n        real = new char[size];\\n        dup = new char[size];\\n        Arrays.fill(real,\\'0\\');\\n        Arrays.fill(dup,\\'1\\');\\n    }\\n    \\n    public void fix(int idx) {\\n        if(real[idx] == \\'1\\')\\n            return;\\n        ++realCount;\\n        --dupCount;\\n        real[idx] = \\'1\\';\\n        dup[idx] = \\'0\\';\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(real[idx] == \\'0\\')\\n            return;\\n        --realCount;\\n        ++dupCount;\\n        real[idx] = \\'0\\';\\n        dup[idx] = \\'1\\';\\n    }\\n    \\n    public void flip() {\\n        var temp = real;\\n        real = dup;\\n        dup = temp;\\n        realCount = realCount + dupCount;\\n        dupCount = realCount - dupCount;\\n        realCount = realCount - dupCount;\\n    }\\n    \\n    public boolean all() {\\n        return realCount == size;\\n    }\\n    \\n    public boolean one() {\\n        return realCount > 0;\\n    }\\n    \\n    public int count() {\\n        return realCount;\\n    }\\n    \\n    public String toString() {\\n        return new String(real);\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Bitset {\\n    char[] real;\\n    char[] dup;\\n    int realCount;\\n    int dupCount;\\n    int size;\\n    public Bitset(int size) {\\n        this.size = size;\\n        realCount = 0;\\n        dupCount = size;\\n        real = new char[size];\\n        dup = new char[size];\\n        Arrays.fill(real,\\'0\\');\\n        Arrays.fill(dup,\\'1\\');\\n    }\\n    \\n    public void fix(int idx) {\\n        if(real[idx] == \\'1\\')\\n            return;\\n        ++realCount;\\n        --dupCount;\\n        real[idx] = \\'1\\';\\n        dup[idx] = \\'0\\';\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(real[idx] == \\'0\\')\\n            return;\\n        --realCount;\\n        ++dupCount;\\n        real[idx] = \\'0\\';\\n        dup[idx] = \\'1\\';\\n    }\\n    \\n    public void flip() {\\n        var temp = real;\\n        real = dup;\\n        dup = temp;\\n        realCount = realCount + dupCount;\\n        dupCount = realCount - dupCount;\\n        realCount = realCount - dupCount;\\n    }\\n    \\n    public boolean all() {\\n        return realCount == size;\\n    }\\n    \\n    public boolean one() {\\n        return realCount > 0;\\n    }\\n    \\n    public int count() {\\n        return realCount;\\n    }\\n    \\n    public String toString() {\\n        return new String(real);\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1750558,
                "title": "java-long-array-bit-manipulation-solution",
                "content": "Jave implements BitSet with long[] internally. This solution is not as simplified as many other accepted solutions, but should be able to give some insights how a real bitset works\\n\\n```\\nclass Bitset {\\n    private int size;\\n    private int wordCount;\\n    private long[] words;\\n    private int oneCount;\\n\\n    public Bitset(int size) {\\n        int wordCount = divideSize(size);\\n\\t\\tif (modSize(size) > 0) {\\n\\t\\t\\twordCount++;\\n\\t\\t}\\n\\t\\tthis.size = size;\\n\\t\\tthis.wordCount = wordCount;\\n\\t\\twords = new long[wordCount];\\n        this.oneCount = 0;\\n    }\\n    \\n    private int divideSize(final int n) {\\n        // long is 64 bits = 2 ^ 6\\n\\t\\treturn n >>> 6;\\n\\t}\\n    private int modSize(final int n) {\\n        // same as n % 64;\\n\\t\\treturn n & 63;\\n\\t}\\n    \\n    public void fix(int idx) {\\n        int outerIdx = divideSize(idx);\\n        int innerIdx = modSize(idx);\\n        \\n        long word = words[outerIdx];\\n        long mask = (long) 1 << innerIdx;\\n        long bit = mask & word;\\n        \\n        if (bit == 0) {\\n            word = mask | word;\\n            words[outerIdx] = word;\\n            oneCount++;\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        int outerIdx = divideSize(idx);\\n        int innerIdx = modSize(idx);\\n        \\n        long word = words[outerIdx];\\n        long mask = (long) 1 << innerIdx;\\n        long bit = mask & word;\\n        \\n        if (bit != 0) {\\n            word = word & (~mask);\\n            words[outerIdx] = word;\\n            oneCount--;\\n        }\\n    }\\n    \\n    public void flip() {\\n        oneCount = size - oneCount;\\n        \\n        for (int i = 0; i < words.length - 1; i++) {\\n            long word = words[i];\\n            words[i] = ~word;\\n        }\\n\\n        int lastCount = modSize(size - 1);\\n        long word = words[words.length - 1];\\n        for (int i = 0; i < lastCount + 1; i++) {\\n            long mask = (long) 1 << i;\\n            long bit = mask & word;\\n            \\n            if (bit != 0) {\\n                word = word & (~mask);\\n            } else {\\n                word = mask | word;\\n            }\\n        }\\n        words[words.length - 1] = word;\\n    }\\n    \\n    public boolean all() {\\n        return oneCount == size;\\n    }\\n    \\n    public boolean one() {\\n        return oneCount > 0;\\n    }\\n    \\n    public int count() {\\n        return oneCount;\\n    }\\n    \\n    private String wordToString(int stop, long word) {\\n          StringBuilder sb = new StringBuilder();\\n          for (int i = 0; i < stop; i++) {\\n              long mask = (long) 1 << i;\\n              long bit = mask & word;\\n\\n              if (bit != 0) {\\n                  sb.append(1);\\n              } else {\\n                  sb.append(0);\\n              }\\n          }\\n          return sb.toString();\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < words.length - 1; i++) {\\n            sb.append(wordToString(64, words[i]));\\n        }\\n        \\n        int lastCount = modSize(size - 1);\\n        long word = words[words.length - 1];\\n        sb.append(wordToString(lastCount + 1, word));\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Bitset {\\n    private int size;\\n    private int wordCount;\\n    private long[] words;\\n    private int oneCount;\\n\\n    public Bitset(int size) {\\n        int wordCount = divideSize(size);\\n\\t\\tif (modSize(size) > 0) {\\n\\t\\t\\twordCount++;\\n\\t\\t}\\n\\t\\tthis.size = size;\\n\\t\\tthis.wordCount = wordCount;\\n\\t\\twords = new long[wordCount];\\n        this.oneCount = 0;\\n    }\\n    \\n    private int divideSize(final int n) {\\n        // long is 64 bits = 2 ^ 6\\n\\t\\treturn n >>> 6;\\n\\t}\\n    private int modSize(final int n) {\\n        // same as n % 64;\\n\\t\\treturn n & 63;\\n\\t}\\n    \\n    public void fix(int idx) {\\n        int outerIdx = divideSize(idx);\\n        int innerIdx = modSize(idx);\\n        \\n        long word = words[outerIdx];\\n        long mask = (long) 1 << innerIdx;\\n        long bit = mask & word;\\n        \\n        if (bit == 0) {\\n            word = mask | word;\\n            words[outerIdx] = word;\\n            oneCount++;\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        int outerIdx = divideSize(idx);\\n        int innerIdx = modSize(idx);\\n        \\n        long word = words[outerIdx];\\n        long mask = (long) 1 << innerIdx;\\n        long bit = mask & word;\\n        \\n        if (bit != 0) {\\n            word = word & (~mask);\\n            words[outerIdx] = word;\\n            oneCount--;\\n        }\\n    }\\n    \\n    public void flip() {\\n        oneCount = size - oneCount;\\n        \\n        for (int i = 0; i < words.length - 1; i++) {\\n            long word = words[i];\\n            words[i] = ~word;\\n        }\\n\\n        int lastCount = modSize(size - 1);\\n        long word = words[words.length - 1];\\n        for (int i = 0; i < lastCount + 1; i++) {\\n            long mask = (long) 1 << i;\\n            long bit = mask & word;\\n            \\n            if (bit != 0) {\\n                word = word & (~mask);\\n            } else {\\n                word = mask | word;\\n            }\\n        }\\n        words[words.length - 1] = word;\\n    }\\n    \\n    public boolean all() {\\n        return oneCount == size;\\n    }\\n    \\n    public boolean one() {\\n        return oneCount > 0;\\n    }\\n    \\n    public int count() {\\n        return oneCount;\\n    }\\n    \\n    private String wordToString(int stop, long word) {\\n          StringBuilder sb = new StringBuilder();\\n          for (int i = 0; i < stop; i++) {\\n              long mask = (long) 1 << i;\\n              long bit = mask & word;\\n\\n              if (bit != 0) {\\n                  sb.append(1);\\n              } else {\\n                  sb.append(0);\\n              }\\n          }\\n          return sb.toString();\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < words.length - 1; i++) {\\n            sb.append(wordToString(64, words[i]));\\n        }\\n        \\n        int lastCount = modSize(size - 1);\\n        long word = words[words.length - 1];\\n        sb.append(wordToString(lastCount + 1, word));\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749703,
                "title": "python-100-faster-100-space-efficient",
                "content": "![image](https://assets.leetcode.com/users/images/f8aeb3fc-0827-49e0-a5e8-b75206e89343_1644143389.2761774.png)\\n\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.s = [\"0\"] * size\\n        self.f = [\"1\"] * size\\n        self.cnt_1 = 0\\n\\n    def fix(self, idx: int) -> None:\\n        if self.s[idx] != \"1\":\\n            self.s[idx] = \"1\"\\n            self.f[idx] = \"0\"\\n            self.cnt_1 += 1\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.s[idx] != \"0\":\\n            self.s[idx] = \"0\"\\n            self.f[idx] = \"1\"\\n            self.cnt_1 -= 1\\n\\n    def flip(self) -> None:\\n        self.s, self.f = self.f, self.s\\n        self.cnt_1 = len(self.s) - self.cnt_1\\n\\n    def all(self) -> bool:\\n        return len(self.s) == self.cnt_1\\n\\n    def one(self) -> bool:\\n        return self.cnt_1 > 0\\n\\n    def count(self) -> int:\\n        return self.cnt_1\\n\\n    def toString(self) -> str:\\n        return \"\".join(self.s)\\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```\\n\\n**Please upvote if you find it helpful!!! Thanks**",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.s = [\"0\"] * size\\n        self.f = [\"1\"] * size\\n        self.cnt_1 = 0\\n\\n    def fix(self, idx: int) -> None:\\n        if self.s[idx] != \"1\":\\n            self.s[idx] = \"1\"\\n            self.f[idx] = \"0\"\\n            self.cnt_1 += 1\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.s[idx] != \"0\":\\n            self.s[idx] = \"0\"\\n            self.f[idx] = \"1\"\\n            self.cnt_1 -= 1\\n\\n    def flip(self) -> None:\\n        self.s, self.f = self.f, self.s\\n        self.cnt_1 = len(self.s) - self.cnt_1\\n\\n    def all(self) -> bool:\\n        return len(self.s) == self.cnt_1\\n\\n    def one(self) -> bool:\\n        return self.cnt_1 > 0\\n\\n    def count(self) -> int:\\n        return self.cnt_1\\n\\n    def toString(self) -> str:\\n        return \"\".join(self.s)\\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749460,
                "title": "easy-o-1-for-all-swap-flip",
                "content": "``` \\nclass Bitset {\\npublic:\\n\\n    string bitset, flipbitset;\\n    int ones=0,zero=0,n=0;\\n    Bitset(int size) {\\n        zero=size;\\n        n=size;\\n\\t\\tbitset = string(size,\\'0\\');\\n\\t\\tflipbitset = string(size,\\'1\\');\\n    }\\n    \\n    void fix(int idx) {\\n      if(bitset[idx]!=\\'1\\'){\\n          ones++;\\n          zero--;\\n      }\\n        flipbitset[idx]=\\'0\\';\\n      bitset[idx]=\\'1\\';  \\n    }\\n    \\n    void unfix(int idx) {\\n        if(bitset[idx]!=\\'0\\'){\\n          ones--;\\n          zero++;\\n      }\\n        flipbitset[idx]=\\'1\\';\\n       bitset[idx]=\\'0\\';  \\n    }\\n    \\n    void flip() {\\n        swap(zero,ones);\\n         swap(bitset,flipbitset);\\n    }\\n    \\n    bool all() {\\n        return n==ones;\\n    }\\n    \\n    bool one() {\\n        return ones>=1;\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        return bitset;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "``` \\nclass Bitset {\\npublic:\\n\\n    string bitset, flipbitset;\\n    int ones=0,zero=0,n=0;\\n    Bitset(int size) {\\n        zero=size;\\n        n=size;\\n\\t\\tbitset = string(size,\\'0\\');\\n\\t\\tflipbitset = string(size,\\'1\\');\\n    }\\n    \\n    void fix(int idx) {\\n      if(bitset[idx]!=\\'1\\'){\\n          ones++;\\n          zero--;\\n      }\\n        flipbitset[idx]=\\'0\\';\\n      bitset[idx]=\\'1\\';  \\n    }\\n    \\n    void unfix(int idx) {\\n        if(bitset[idx]!=\\'0\\'){\\n          ones--;\\n          zero++;\\n      }\\n        flipbitset[idx]=\\'1\\';\\n       bitset[idx]=\\'0\\';  \\n    }\\n    \\n    void flip() {\\n        swap(zero,ones);\\n         swap(bitset,flipbitset);\\n    }\\n    \\n    bool all() {\\n        return n==ones;\\n    }\\n    \\n    bool one() {\\n        return ones>=1;\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        return bitset;\\n    }\\n};\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1749301,
                "title": "golang-simple-solution",
                "content": "using two map to store the one & zero index\\n\\n**Time & Space complexity:**\\nTime:\\nInitialization and toString() are both **O(size)**, others are all **O(1)**;\\nSpace:\\n**O(size)**\\n\\nnote that if use + sign to concate string in toString() function will cause TLE\\n\\n```\\ntype Bitset struct {\\n    bitSlice []int\\n    size int\\n    oneIndex map[int]int\\n    zeroIndex map[int]int\\n}\\n\\n\\nfunc Constructor(size int) Bitset {\\n    zeroIndex := make(map[int]int, size)\\n    for i:=0; i<size; i++ {\\n        zeroIndex[i] = 1\\n    }\\n    return Bitset{bitSlice: make([]int, size), size: size, oneIndex:make(map[int]int, size), zeroIndex:zeroIndex}\\n}\\n\\n\\nfunc (this *Bitset) Fix(idx int)  {\\n    this.oneIndex[idx] = 1\\n    delete(this.zeroIndex, idx)\\n}\\n\\n\\nfunc (this *Bitset) Unfix(idx int)  {\\n    this.zeroIndex[idx] = 1\\n    delete(this.oneIndex, idx)\\n}\\n\\n\\nfunc (this *Bitset) Flip()  {\\n    this.zeroIndex, this.oneIndex = this.oneIndex, this.zeroIndex\\n}\\n\\n\\nfunc (this *Bitset) All() bool {\\n    return len(this.oneIndex) == this.size\\n}\\n\\n\\nfunc (this *Bitset) One() bool {\\n    return len(this.oneIndex) > 0\\n}\\n\\n\\nfunc (this *Bitset) Count() int {\\n    return len(this.oneIndex)\\n}\\n\\n\\nfunc (this *Bitset) ToString() string {\\n    // don\\'t use + to concate string\\n    // + is much slower than strings.Builder, so it will TLE\\n    var bitString strings.Builder\\n    for i:=0; i<this.size; i++ {\\n        if this.oneIndex[i] == 1 {\\n            bitString.WriteString(\"1\")\\n        } else {\\n            bitString.WriteString(\"0\")\\n        }\\n    }\\n    return bitString.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Bitset struct {\\n    bitSlice []int\\n    size int\\n    oneIndex map[int]int\\n    zeroIndex map[int]int\\n}\\n\\n\\nfunc Constructor(size int) Bitset {\\n    zeroIndex := make(map[int]int, size)\\n    for i:=0; i<size; i++ {\\n        zeroIndex[i] = 1\\n    }\\n    return Bitset{bitSlice: make([]int, size), size: size, oneIndex:make(map[int]int, size), zeroIndex:zeroIndex}\\n}\\n\\n\\nfunc (this *Bitset) Fix(idx int)  {\\n    this.oneIndex[idx] = 1\\n    delete(this.zeroIndex, idx)\\n}\\n\\n\\nfunc (this *Bitset) Unfix(idx int)  {\\n    this.zeroIndex[idx] = 1\\n    delete(this.oneIndex, idx)\\n}\\n\\n\\nfunc (this *Bitset) Flip()  {\\n    this.zeroIndex, this.oneIndex = this.oneIndex, this.zeroIndex\\n}\\n\\n\\nfunc (this *Bitset) All() bool {\\n    return len(this.oneIndex) == this.size\\n}\\n\\n\\nfunc (this *Bitset) One() bool {\\n    return len(this.oneIndex) > 0\\n}\\n\\n\\nfunc (this *Bitset) Count() int {\\n    return len(this.oneIndex)\\n}\\n\\n\\nfunc (this *Bitset) ToString() string {\\n    // don\\'t use + to concate string\\n    // + is much slower than strings.Builder, so it will TLE\\n    var bitString strings.Builder\\n    for i:=0; i<this.size; i++ {\\n        if this.oneIndex[i] == 1 {\\n            bitString.WriteString(\"1\")\\n        } else {\\n            bitString.WriteString(\"0\")\\n        }\\n    }\\n    return bitString.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1748694,
                "title": "java-o-1-solution-two-arrays",
                "content": "```\\nclass Bitset {\\n    int[] num;\\n    int[] rev;\\n    int size;\\n    int rsize;\\n    int countt;\\n    boolean curr=false;\\n    public Bitset(int size) {\\n        num=new int[size];\\n        rev=new int[size];\\n        for(int i=0;i<size;i++){\\n            rev[i]=1;\\n        }\\n        this.size=size;\\n        countt=0;\\n        rsize=size;\\n    }\\n    \\n    public void fix(int idx) {\\n        if(!curr){\\n            if(num[idx]==0){\\n                countt++;\\n                 num[idx]=1;\\n                rsize--;\\n                 rev[idx]=0;\\n            }\\n            \\n        }\\n        else{\\n             if(rev[idx]==0){\\n                 rsize++;\\n                 rev[idx]=1;\\n                 countt--;\\n                 num[idx]=0;\\n            }\\n        }\\n       \\n    }\\n    \\n    public void unfix(int idx) {\\n        if(!curr){\\n            if(num[idx]==1){\\n                countt--;\\n                 num[idx]=0;\\n                rsize++;\\n                 rev[idx]=1;\\n            }\\n            \\n        }\\n        else{\\n             if(rev[idx]==1){\\n                 rsize--;\\n                 countt++;\\n                 rev[idx]=0;\\n                 num[idx]=1;\\n            }\\n        }\\n        \\n    }\\n    \\n    public void flip() {\\n        curr= !curr;\\n    }\\n    \\n    public boolean all() {\\n        return curr?rsize==size:countt==size;\\n    }\\n    \\n    public boolean one() {\\n       return curr?rsize>0:countt>0;\\n    }\\n    \\n    public int count() {\\n        return curr?rsize:countt;\\n    }\\n    \\n    public String toString() {\\n        int[] viewBits = curr? rev: num;\\n        StringBuilder sb = new StringBuilder();\\n        for (int bit : viewBits) {\\n            sb.append(bit);\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n    int[] num;\\n    int[] rev;\\n    int size;\\n    int rsize;\\n    int countt;\\n    boolean curr=false;\\n    public Bitset(int size) {\\n        num=new int[size];\\n        rev=new int[size];\\n        for(int i=0;i<size;i++){\\n            rev[i]=1;\\n        }\\n        this.size=size;\\n        countt=0;\\n        rsize=size;\\n    }\\n    \\n    public void fix(int idx) {\\n        if(!curr){\\n            if(num[idx]==0){\\n                countt++;\\n                 num[idx]=1;\\n                rsize--;\\n                 rev[idx]=0;\\n            }\\n            \\n        }\\n        else{\\n             if(rev[idx]==0){\\n                 rsize++;\\n                 rev[idx]=1;\\n                 countt--;\\n                 num[idx]=0;\\n            }\\n        }\\n       \\n    }\\n    \\n    public void unfix(int idx) {\\n        if(!curr){\\n            if(num[idx]==1){\\n                countt--;\\n                 num[idx]=0;\\n                rsize++;\\n                 rev[idx]=1;\\n            }\\n            \\n        }\\n        else{\\n             if(rev[idx]==1){\\n                 rsize--;\\n                 countt++;\\n                 rev[idx]=0;\\n                 num[idx]=1;\\n            }\\n        }\\n        \\n    }\\n    \\n    public void flip() {\\n        curr= !curr;\\n    }\\n    \\n    public boolean all() {\\n        return curr?rsize==size:countt==size;\\n    }\\n    \\n    public boolean one() {\\n       return curr?rsize>0:countt>0;\\n    }\\n    \\n    public int count() {\\n        return curr?rsize:countt;\\n    }\\n    \\n    public String toString() {\\n        int[] viewBits = curr? rev: num;\\n        StringBuilder sb = new StringBuilder();\\n        for (int bit : viewBits) {\\n            sb.append(bit);\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748682,
                "title": "simple-c-every-operation-o-1",
                "content": "\\n\\nclass Bitset {\\npublic:\\n    \\n    int oc;\\n    string s, fs;\\n        \\n    Bitset(int size) {\\n        oc=0;\\n        s.resize(size,\\'0\\');\\n        fs.resize(size, \\'1\\');\\n    }\\n    \\n    void fix(int idx) {\\n        if(s[idx]==\\'0\\')\\n        {\\n            s[idx]=\\'1\\';\\n            fs[idx]=\\'0\\';\\n            oc++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(s[idx]==\\'1\\')\\n        {\\n            s[idx]=\\'0\\';\\n            fs[idx]=\\'1\\';\\n            oc--;\\n        }\\n        // for(int i=0; i<bs.size(); i++) cout<<bs[i]<<\" \";\\n        // cout<<endl;\\n    }\\n    \\n    void flip() {\\n        swap(fs, s);\\n        oc=s.length()-oc;\\n    }\\n    \\n    bool all() {\\n        if(oc==s.length()) return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n        if(oc>0) return true;\\n        return false;\\n    }\\n    \\n    int count() {\\n        return oc;\\n    }\\n    \\n    string toString() {\\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "\\n\\nclass Bitset {\\npublic:\\n    \\n    int oc;\\n    string s, fs;\\n        \\n    Bitset(int size) {\\n        oc=0;\\n        s.resize(size,\\'0\\');\\n        fs.resize(size, \\'1\\');\\n    }\\n    \\n    void fix(int idx) {\\n        if(s[idx]==\\'0\\')\\n        {\\n            s[idx]=\\'1\\';\\n            fs[idx]=\\'0\\';\\n            oc++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(s[idx]==\\'1\\')\\n        {\\n            s[idx]=\\'0\\';\\n            fs[idx]=\\'1\\';\\n            oc--;\\n        }\\n        // for(int i=0; i<bs.size(); i++) cout<<bs[i]<<\" \";\\n        // cout<<endl;\\n    }\\n    \\n    void flip() {\\n        swap(fs, s);\\n        oc=s.length()-oc;\\n    }\\n    \\n    bool all() {\\n        if(oc==s.length()) return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n        if(oc>0) return true;\\n        return false;\\n    }\\n    \\n    int count() {\\n        return oc;\\n    }\\n    \\n    string toString() {\\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */",
                "codeTag": "C++"
            },
            {
                "id": 1748638,
                "title": "c-o-1-for-each-operation-except-to-string-which-is-o-n",
                "content": "We dont have to flip the entire bitset everytime because that will lead to TLE. Instead of that maintain a flag variable which will tell if we need flipping or not and flip only when to_string is called. UPVOTE if you like the solution and if there is a better solution do comment. \\n```\\nclass Bitset\\n{\\npublic:\\n    string bs;\\n    int cnt = 0;\\n    int flag = 0;\\n    Bitset(int size)\\n    {\\n        while (size--)\\n            bs.push_back(\\'0\\');\\n    }\\n\\n    void fix(int idx)\\n    {\\n        if (flag % 2 == 0)\\n        {\\n            if (bs[idx] == \\'0\\')\\n                cnt++;\\n            bs[idx] = \\'1\\';\\n        }\\n        else\\n        {\\n            if (bs[idx] == \\'1\\')\\n                cnt++;\\n            bs[idx] = \\'0\\';\\n        }\\n    }\\n\\n    void unfix(int idx)\\n    {\\n        if (flag % 2 == 0)\\n        {\\n            if (bs[idx] == \\'1\\')\\n                cnt--;\\n            bs[idx] = \\'0\\';\\n        }\\n        else\\n        {\\n            if (bs[idx] == \\'0\\')\\n                cnt--;\\n            bs[idx] = \\'1\\';\\n        }\\n    }\\n\\n    void flip()\\n    {\\n        flag++;\\n        cnt = bs.size() - cnt;\\n    }\\n\\n    bool all()\\n    {\\n        return cnt == bs.size();\\n    }\\n\\n    bool one()\\n    {\\n        return cnt;\\n    }\\n\\n    int count()\\n    {\\n        return cnt;\\n    }\\n\\n    string toString()\\n    {\\n        string s = bs;\\n        if (flag % 2 != 0)\\n        {\\n            for (int i = 0; i < s.size(); ++i)\\n            {\\n                if (s[i] == \\'1\\')\\n                    s[i] = \\'0\\';\\n                else\\n                    s[i] = \\'1\\';\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Bitset\\n{\\npublic:\\n    string bs;\\n    int cnt = 0;\\n    int flag = 0;\\n    Bitset(int size)\\n    {\\n        while (size--)\\n            bs.push_back(\\'0\\');\\n    }\\n\\n    void fix(int idx)\\n    {\\n        if (flag % 2 == 0)\\n        {\\n            if (bs[idx] == \\'0\\')\\n                cnt++;\\n            bs[idx] = \\'1\\';\\n        }\\n        else\\n        {\\n            if (bs[idx] == \\'1\\')\\n                cnt++;\\n            bs[idx] = \\'0\\';\\n        }\\n    }\\n\\n    void unfix(int idx)\\n    {\\n        if (flag % 2 == 0)\\n        {\\n            if (bs[idx] == \\'1\\')\\n                cnt--;\\n            bs[idx] = \\'0\\';\\n        }\\n        else\\n        {\\n            if (bs[idx] == \\'0\\')\\n                cnt--;\\n            bs[idx] = \\'1\\';\\n        }\\n    }\\n\\n    void flip()\\n    {\\n        flag++;\\n        cnt = bs.size() - cnt;\\n    }\\n\\n    bool all()\\n    {\\n        return cnt == bs.size();\\n    }\\n\\n    bool one()\\n    {\\n        return cnt;\\n    }\\n\\n    int count()\\n    {\\n        return cnt;\\n    }\\n\\n    string toString()\\n    {\\n        string s = bs;\\n        if (flag % 2 != 0)\\n        {\\n            for (int i = 0; i < s.size(); ++i)\\n            {\\n                if (s[i] == \\'1\\')\\n                    s[i] = \\'0\\';\\n                else\\n                    s[i] = \\'1\\';\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748588,
                "title": "java-o-1-methods-implementation",
                "content": "```\\nclass Bitset {\\n    public int ones;\\n    public int zeros;\\n    public int[] nums;\\n    public int[] numsFlipped;\\n    public int n;\\n    public boolean isFlipped;\\n    public StringBuilder sb;\\n    public StringBuilder sbFlipped;\\n    \\n    public Bitset(int size) {\\n        sb = new StringBuilder();\\n        sbFlipped = new StringBuilder();\\n        n = size;\\n        ones = 0;\\n        zeros = n;\\n        nums = new int[n];\\n        \\n        numsFlipped = new int[n];\\n        Arrays.fill(numsFlipped, 1);\\n        isFlipped = false;\\n        \\n        for (int i = 0; i < n; i++) {\\n            sb.append(\\'0\\');\\n            sbFlipped.append(\\'1\\');\\n        }\\n    }\\n    \\n    public void fix(int idx) {\\n        if (isFlipped) {\\n            if (numsFlipped[idx] != 1) {\\n                numsFlipped[idx] = 1;\\n                sbFlipped.setCharAt(idx, \\'1\\');\\n                zeros--;\\n                ones++;\\n\\n\\n                sb.setCharAt(idx, \\'0\\');\\n                nums[idx] = 0;\\n            }\\n        } else {\\n            if (nums[idx] != 1) {\\n                nums[idx] = 1;\\n                sb.setCharAt(idx, \\'1\\');\\n                zeros--;\\n                ones++;\\n\\n\\n                sbFlipped.setCharAt(idx, \\'0\\');\\n                numsFlipped[idx] = 0;\\n            }\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if (isFlipped) {\\n            if (numsFlipped[idx] == 1) {\\n                sbFlipped.setCharAt(idx, \\'0\\');\\n                numsFlipped[idx] = 0;\\n                zeros++;\\n                ones--;\\n                \\n                nums[idx] = 1;\\n                sb.setCharAt(idx, \\'1\\');\\n            }\\n        } else {\\n            if (nums[idx] == 1) {\\n                nums[idx] = 0;\\n                sb.setCharAt(idx, \\'0\\');\\n                zeros++;\\n                ones--;\\n\\n\\n                sbFlipped.setCharAt(idx, \\'1\\');\\n                numsFlipped[idx] = 1;\\n            }\\n        }\\n    }\\n    \\n    public void flip() {\\n        int tmp = zeros;\\n        zeros = ones;\\n        ones = tmp;\\n        isFlipped = !isFlipped;\\n    }\\n    \\n    public boolean all() {\\n        return ones == n;\\n    }\\n    \\n    public boolean one() {\\n        return ones > 0;\\n    }\\n    \\n    public int count() {\\n        return ones;\\n    }\\n    \\n    public String toString() {\\n        return isFlipped ? sbFlipped.toString() : sb.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n    public int ones;\\n    public int zeros;\\n    public int[] nums;\\n    public int[] numsFlipped;\\n    public int n;\\n    public boolean isFlipped;\\n    public StringBuilder sb;\\n    public StringBuilder sbFlipped;\\n    \\n    public Bitset(int size) {\\n        sb = new StringBuilder();\\n        sbFlipped = new StringBuilder();\\n        n = size;\\n        ones = 0;\\n        zeros = n;\\n        nums = new int[n];\\n        \\n        numsFlipped = new int[n];\\n        Arrays.fill(numsFlipped, 1);\\n        isFlipped = false;\\n        \\n        for (int i = 0; i < n; i++) {\\n            sb.append(\\'0\\');\\n            sbFlipped.append(\\'1\\');\\n        }\\n    }\\n    \\n    public void fix(int idx) {\\n        if (isFlipped) {\\n            if (numsFlipped[idx] != 1) {\\n                numsFlipped[idx] = 1;\\n                sbFlipped.setCharAt(idx, \\'1\\');\\n                zeros--;\\n                ones++;\\n\\n\\n                sb.setCharAt(idx, \\'0\\');\\n                nums[idx] = 0;\\n            }\\n        } else {\\n            if (nums[idx] != 1) {\\n                nums[idx] = 1;\\n                sb.setCharAt(idx, \\'1\\');\\n                zeros--;\\n                ones++;\\n\\n\\n                sbFlipped.setCharAt(idx, \\'0\\');\\n                numsFlipped[idx] = 0;\\n            }\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if (isFlipped) {\\n            if (numsFlipped[idx] == 1) {\\n                sbFlipped.setCharAt(idx, \\'0\\');\\n                numsFlipped[idx] = 0;\\n                zeros++;\\n                ones--;\\n                \\n                nums[idx] = 1;\\n                sb.setCharAt(idx, \\'1\\');\\n            }\\n        } else {\\n            if (nums[idx] == 1) {\\n                nums[idx] = 0;\\n                sb.setCharAt(idx, \\'0\\');\\n                zeros++;\\n                ones--;\\n\\n\\n                sbFlipped.setCharAt(idx, \\'1\\');\\n                numsFlipped[idx] = 1;\\n            }\\n        }\\n    }\\n    \\n    public void flip() {\\n        int tmp = zeros;\\n        zeros = ones;\\n        ones = tmp;\\n        isFlipped = !isFlipped;\\n    }\\n    \\n    public boolean all() {\\n        return ones == n;\\n    }\\n    \\n    public boolean one() {\\n        return ones > 0;\\n    }\\n    \\n    public int count() {\\n        return ones;\\n    }\\n    \\n    public String toString() {\\n        return isFlipped ? sbFlipped.toString() : sb.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748577,
                "title": "c",
                "content": "```\\nclass Bitset {\\npublic:vector<int> v;\\n    int c=0;\\n    int fc=0;\\n    Bitset(int size) {\\n        v.resize(size);\\n    }\\n    \\n    void fix(int idx) {\\n       if((v[idx]+fc)%2==0){\\n            v[idx]++;\\n            c++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n      if((v[idx]+fc)%2!=0){\\n            v[idx]--;\\n            c--;\\n        }  \\n        \\n    }\\n    \\n    void flip() {\\n        c=v.size()-c;\\n        fc++;\\n    }\\n    \\n    bool all() {\\n         if(c==v.size())\\n        return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n        if(c>=1)\\n            return true;\\n        return false;\\n    }\\n    \\n    int count() {\\n        return c;\\n    }\\n    \\n    string toString() {\\n        string s;\\n        for(int i=0;i<v.size();++i)\\n        {\\n            if((fc+v[i])%2==0)\\n            s.push_back(\\'0\\');\\n            else\\n                s.push_back(\\'1\\');\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Bitset {\\npublic:vector<int> v;\\n    int c=0;\\n    int fc=0;\\n    Bitset(int size) {\\n        v.resize(size);\\n    }\\n    \\n    void fix(int idx) {\\n       if((v[idx]+fc)%2==0){\\n            v[idx]++;\\n            c++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n      if((v[idx]+fc)%2!=0){\\n            v[idx]--;\\n            c--;\\n        }  \\n        \\n    }\\n    \\n    void flip() {\\n        c=v.size()-c;\\n        fc++;\\n    }\\n    \\n    bool all() {\\n         if(c==v.size())\\n        return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n        if(c>=1)\\n            return true;\\n        return false;\\n    }\\n    \\n    int count() {\\n        return c;\\n    }\\n    \\n    string toString() {\\n        string s;\\n        for(int i=0;i<v.size();++i)\\n        {\\n            if((fc+v[i])%2==0)\\n            s.push_back(\\'0\\');\\n            else\\n                s.push_back(\\'1\\');\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748575,
                "title": "c-o-1-all-operations-in-o-1-by-taking-care-of-parity",
                "content": "I used two strings, the first one is initially filled with all zero. Second one is filled with all ones (a doppleganger :)). When the flip function is called, parity is changed and all the methods are called according to the new parity.\\n\\ns is all zero string.\\ng is all one string.\\n\\n```\\n\\nclass Bitset {\\npublic:\\n    \\n    int par = 0;\\n    string s,g;\\n    int os = 0, og = 0;\\n    int n;\\n    Bitset(int size) {\\n        par = 0;\\n        s.resize(size,\\'0\\');\\n        g.resize(size,\\'1\\');\\n        os = 0;\\n        og = size;\\n        n = size;\\n    }\\n    \\n    void fix(int idx) {\\n        \\n        if(par%2==1)\\n        {\\n            if(s[idx] != \\'0\\')\\n            {\\n                s[idx] = \\'0\\';\\n                os--;\\n            }\\n\\n\\n            if(g[idx] != \\'1\\')\\n            {\\n                g[idx] = \\'1\\';\\n                og++;\\n            }  \\n        }\\n        else\\n        {\\n            if(s[idx] != \\'1\\')\\n            {\\n                s[idx] = \\'1\\';\\n                os++;\\n            }\\n\\n            if(g[idx] != \\'0\\')\\n            {\\n                g[idx] = \\'0\\';\\n                og--;\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        \\n        if(par%2==0)\\n        {\\n            if(s[idx] != \\'0\\')\\n            {\\n                s[idx] = \\'0\\';\\n                os--;\\n            }\\n\\n\\n            if(g[idx] != \\'1\\')\\n            {\\n                g[idx] = \\'1\\';\\n                og++;\\n            }  \\n        }\\n        else\\n        {\\n            if(s[idx] != \\'1\\')\\n            {\\n                s[idx] = \\'1\\';\\n                os++;\\n            }\\n\\n            if(g[idx] != \\'0\\')\\n            {\\n                g[idx] = \\'0\\';\\n                og--;\\n            }\\n        } \\n    }\\n    \\n    void flip() {\\n        \\n        par++;\\n        \\n    }\\n    \\n    bool all() {\\n        \\n        if(par%2==0)\\n        {\\n            // s\\n            \\n            return (n == os);\\n            \\n        }\\n        else\\n        {\\n            //g\\n            \\n            return (n == og);\\n        }\\n    }\\n    \\n    bool one() {\\n        \\n        if(par%2==0)\\n        {\\n            return os>0;\\n        }\\n        else\\n        {\\n            return (og>0);\\n        }\\n    }\\n    \\n    int count() {\\n        \\n        if(par%2==0)\\n        {\\n            return os;\\n        }\\n        else\\n        {\\n            return (og);\\n        }\\n    }\\n    \\n    string toString() {\\n\\n        \\n        if(par%2==0)\\n            return s;\\n        else\\n            return g;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n\\nclass Bitset {\\npublic:\\n    \\n    int par = 0;\\n    string s,g;\\n    int os = 0, og = 0;\\n    int n;\\n    Bitset(int size) {\\n        par = 0;\\n        s.resize(size,\\'0\\');\\n        g.resize(size,\\'1\\');\\n        os = 0;\\n        og = size;\\n        n = size;\\n    }\\n    \\n    void fix(int idx) {\\n        \\n        if(par%2==1)\\n        {\\n            if(s[idx] != \\'0\\')\\n            {\\n                s[idx] = \\'0\\';\\n                os--;\\n            }\\n\\n\\n            if(g[idx] != \\'1\\')\\n            {\\n                g[idx] = \\'1\\';\\n                og++;\\n            }  \\n        }\\n        else\\n        {\\n            if(s[idx] != \\'1\\')\\n            {\\n                s[idx] = \\'1\\';\\n                os++;\\n            }\\n\\n            if(g[idx] != \\'0\\')\\n            {\\n                g[idx] = \\'0\\';\\n                og--;\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        \\n        if(par%2==0)\\n        {\\n            if(s[idx] != \\'0\\')\\n            {\\n                s[idx] = \\'0\\';\\n                os--;\\n            }\\n\\n\\n            if(g[idx] != \\'1\\')\\n            {\\n                g[idx] = \\'1\\';\\n                og++;\\n            }  \\n        }\\n        else\\n        {\\n            if(s[idx] != \\'1\\')\\n            {\\n                s[idx] = \\'1\\';\\n                os++;\\n            }\\n\\n            if(g[idx] != \\'0\\')\\n            {\\n                g[idx] = \\'0\\';\\n                og--;\\n            }\\n        } \\n    }\\n    \\n    void flip() {\\n        \\n        par++;\\n        \\n    }\\n    \\n    bool all() {\\n        \\n        if(par%2==0)\\n        {\\n            // s\\n            \\n            return (n == os);\\n            \\n        }\\n        else\\n        {\\n            //g\\n            \\n            return (n == og);\\n        }\\n    }\\n    \\n    bool one() {\\n        \\n        if(par%2==0)\\n        {\\n            return os>0;\\n        }\\n        else\\n        {\\n            return (og>0);\\n        }\\n    }\\n    \\n    int count() {\\n        \\n        if(par%2==0)\\n        {\\n            return os;\\n        }\\n        else\\n        {\\n            return (og);\\n        }\\n    }\\n    \\n    string toString() {\\n\\n        \\n        if(par%2==0)\\n            return s;\\n        else\\n            return g;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748468,
                "title": "keep-bits-and-reversedbits-java-with-explanation",
                "content": "We can use binary array to store the bits. So `fix()`, `unfix()` can be achieved in `O(1)` time.\\n\\nFor `one()`, `count()`, we can use a separate counter variable to keep track of the number of ones in the bit array, so we don\\'t have to iterate over the array to find the count. We can achieve `O(1)` time complexity for this two methods two.\\n\\nHow about `flip()`? It seems we need to traverse the array and flip each bit right? Well, we can actually use extra space to avoid this hassle. In addition to the original bit array, we keep an extra reversed bit array, to store the reversed bit information. If our original bit array is like `[1,1,0,1,0]`, then the reversed bit array looks like `[0,0,1,0,1]`. If we have this two arrays, then we can just use a flag to indicate which one is the current bitset we are using. Flip the array is no longer a painful `O(n)` iteration but a `O(1)` snap of a finger by flipping the flag.\\n\\nFor the `toString()` method, we still need to create the string representation of the bit array, which takes `O(n)` time.\\n\\nTime complexity: `O(1)` for other operations except `toString()`, which is `O(n)`. We are using `2 * size` space, so the space complexity is `O(n)`.\\n\\n```java\\nclass Bitset {\\n\\n    private int[] rbits;        // stores the reversed bit \\n    private int[] bits;         // stores the original bit \\n    private int oneCount, roneCount;\\n    private int size;\\n    private boolean useBit = true;     // flag for our current bit array\\n\\n    public Bitset(int size) {\\n        this.size = size;\\n        // initialize bit array \\n        bits = new int[size];\\n        rbits = new int[size];\\n        Arrays.fill(rbits, 1);\\n        oneCount = 0;\\n        roneCount = size;\\n    }\\n    \\n    public void fix(int idx) {\\n        if (useBit && bits[idx] == 0) {\\n            // update bits[]\\n            bits[idx] = 1;\\n            oneCount++;\\n            // update rbits[]\\n            rbits[idx] = 0;\\n            roneCount--;\\n        } else if (!useBit && rbits[idx] == 0) {\\n            // update rbits[]\\n            rbits[idx] = 1;\\n            roneCount++;\\n            // update bits[]\\n            bits[idx] = 0;\\n            oneCount--;\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if (useBit && bits[idx] == 1) {\\n            // update bits \\n            bits[idx] = 0;\\n            oneCount--;\\n            // update rbits \\n            rbits[idx] = 1;\\n            roneCount++;\\n        } else if (!useBit && rbits[idx] == 1) {\\n            // update rbits[]\\n            rbits[idx] = 0;\\n            roneCount--;\\n            // update bits[]\\n            bits[idx] = 1;\\n            oneCount++;\\n        }\\n    }\\n    \\n    public void flip() {\\n        useBit = !useBit;\\n    }\\n    \\n    public boolean all() {\\n        return useBit ? oneCount == size : roneCount == size;\\n    }\\n    \\n    public boolean one() {\\n        return useBit ? oneCount > 0 : roneCount > 0;\\n    }\\n    \\n    public int count() {\\n        return useBit ? oneCount : roneCount;\\n    }\\n    \\n    public String toString() {\\n        int[] viewBits = useBit ? bits : rbits;\\n        StringBuilder sb = new StringBuilder();\\n        for (int bit : viewBits) {\\n            sb.append(bit);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Bitset {\\n\\n    private int[] rbits;        // stores the reversed bit \\n    private int[] bits;         // stores the original bit \\n    private int oneCount, roneCount;\\n    private int size;\\n    private boolean useBit = true;     // flag for our current bit array\\n\\n    public Bitset(int size) {\\n        this.size = size;\\n        // initialize bit array \\n        bits = new int[size];\\n        rbits = new int[size];\\n        Arrays.fill(rbits, 1);\\n        oneCount = 0;\\n        roneCount = size;\\n    }\\n    \\n    public void fix(int idx) {\\n        if (useBit && bits[idx] == 0) {\\n            // update bits[]\\n            bits[idx] = 1;\\n            oneCount++;\\n            // update rbits[]\\n            rbits[idx] = 0;\\n            roneCount--;\\n        } else if (!useBit && rbits[idx] == 0) {\\n            // update rbits[]\\n            rbits[idx] = 1;\\n            roneCount++;\\n            // update bits[]\\n            bits[idx] = 0;\\n            oneCount--;\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if (useBit && bits[idx] == 1) {\\n            // update bits \\n            bits[idx] = 0;\\n            oneCount--;\\n            // update rbits \\n            rbits[idx] = 1;\\n            roneCount++;\\n        } else if (!useBit && rbits[idx] == 1) {\\n            // update rbits[]\\n            rbits[idx] = 0;\\n            roneCount--;\\n            // update bits[]\\n            bits[idx] = 1;\\n            oneCount++;\\n        }\\n    }\\n    \\n    public void flip() {\\n        useBit = !useBit;\\n    }\\n    \\n    public boolean all() {\\n        return useBit ? oneCount == size : roneCount == size;\\n    }\\n    \\n    public boolean one() {\\n        return useBit ? oneCount > 0 : roneCount > 0;\\n    }\\n    \\n    public int count() {\\n        return useBit ? oneCount : roneCount;\\n    }\\n    \\n    public String toString() {\\n        int[] viewBits = useBit ? bits : rbits;\\n        StringBuilder sb = new StringBuilder();\\n        for (int bit : viewBits) {\\n            sb.append(bit);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748458,
                "title": "java-simple-avoid-flip-using-flag",
                "content": "```\\nclass Bitset {\\n\\n    Set<Integer> o = new HashSet<>();\\n    int s = 0;\\n    boolean flip = false;\\n    public Bitset(int size) {\\n        s = size;\\n    }\\n    \\n    public void fix(int idx) {\\n        if(flip)\\n            o.remove(idx);\\n        else\\n            o.add(idx);\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(flip)\\n            o.add(idx);\\n        else\\n            o.remove(idx);\\n    }\\n    \\n    public void flip() {\\n        flip = !flip;\\n    }\\n    \\n    public boolean all() {\\n        return flip ? o.isEmpty() : o.size()== s;\\n    }\\n    \\n    public boolean one() {\\n        return flip ? s - o.size() > 0 : !o.isEmpty();\\n    }\\n    \\n    public int count() {\\n        return flip ? s - o.size() : o.size();        \\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<s;i++){\\n            if(flip){\\n                if(o.contains(i)){\\n                    sb.append(0);\\n                }else {\\n                    sb.append(1);\\n                }\\n            }else {\\n                if(o.contains(i)){\\n                    sb.append(1);\\n                }else {\\n                    sb.append(0);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */",
                "solutionTags": [],
                "code": "```\\nclass Bitset {\\n\\n    Set<Integer> o = new HashSet<>();\\n    int s = 0;\\n    boolean flip = false;\\n    public Bitset(int size) {\\n        s = size;\\n    }\\n    \\n    public void fix(int idx) {\\n        if(flip)\\n            o.remove(idx);\\n        else\\n            o.add(idx);\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(flip)\\n            o.add(idx);\\n        else\\n            o.remove(idx);\\n    }\\n    \\n    public void flip() {\\n        flip = !flip;\\n    }\\n    \\n    public boolean all() {\\n        return flip ? o.isEmpty() : o.size()== s;\\n    }\\n    \\n    public boolean one() {\\n        return flip ? s - o.size() > 0 : !o.isEmpty();\\n    }\\n    \\n    public int count() {\\n        return flip ? s - o.size() : o.size();        \\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<s;i++){\\n            if(flip){\\n                if(o.contains(i)){\\n                    sb.append(0);\\n                }else {\\n                    sb.append(1);\\n                }\\n            }else {\\n                if(o.contains(i)){\\n                    sb.append(1);\\n                }else {\\n                    sb.append(0);\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 3854694,
                "title": "simple-java-solution-with-1-set",
                "content": "# Intuition\\nStore either of bit (0 or 1)\\n\\n# Approach\\nUse Set to store index while mainting flip flag to denotes the set contains indexes of 0 or 1\\n\\n# Complexity\\n- Time complexity:\\nAll operation: $$O(1)$$ \\ntoStiring() : $$O(size)$$\\n\\n- Space complexity: $$O(size)$$\\n\\n# Code\\n```\\nclass Bitset {\\n    Set<Integer> set;\\n    boolean flip;\\n    int total;\\n    //flip = false; denotes indexes in set have bit 1\\n    //flip = true; denotes indexes in set have bit 0\\n    public Bitset(int size) {\\n       set = new HashSet<>();\\n       flip = false;\\n       total = size;\\n    }\\n    \\n    public void fix(int idx) {\\n        if(!flip)\\n            set.add(idx);\\n        else{\\n            set.remove(idx);\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(!flip){\\n            set.remove(idx);\\n        } else {\\n            set.add(idx);\\n        }\\n    }\\n    \\n    public void flip() {\\n        flip = !flip;\\n    }\\n    \\n    public boolean all() {\\n        if((!flip && set.size()==total) || (flip && set.size()==0))\\n            return true;\\n        return false;\\n    }\\n    \\n    public boolean one() {\\n        if((!flip && set.size()>=1) || (flip && set.size()!=total))\\n            return true;\\n        return false;\\n    }\\n    \\n    public int count() {\\n        if(!flip)\\n            return set.size();\\n        return Math.abs(total-set.size());\\n    }\\n    \\n    public String toString() {\\n        StringBuilder str = new StringBuilder();\\n        for(int i=0;i<total;i++){\\n            if(!flip)\\n                str.append(set.contains(i) ? \\'1\\' : \\'0\\');\\n            else{\\n                str.append(set.contains(i) ? \\'0\\' : \\'1\\');\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Bitset {\\n    Set<Integer> set;\\n    boolean flip;\\n    int total;\\n    //flip = false; denotes indexes in set have bit 1\\n    //flip = true; denotes indexes in set have bit 0\\n    public Bitset(int size) {\\n       set = new HashSet<>();\\n       flip = false;\\n       total = size;\\n    }\\n    \\n    public void fix(int idx) {\\n        if(!flip)\\n            set.add(idx);\\n        else{\\n            set.remove(idx);\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(!flip){\\n            set.remove(idx);\\n        } else {\\n            set.add(idx);\\n        }\\n    }\\n    \\n    public void flip() {\\n        flip = !flip;\\n    }\\n    \\n    public boolean all() {\\n        if((!flip && set.size()==total) || (flip && set.size()==0))\\n            return true;\\n        return false;\\n    }\\n    \\n    public boolean one() {\\n        if((!flip && set.size()>=1) || (flip && set.size()!=total))\\n            return true;\\n        return false;\\n    }\\n    \\n    public int count() {\\n        if(!flip)\\n            return set.size();\\n        return Math.abs(total-set.size());\\n    }\\n    \\n    public String toString() {\\n        StringBuilder str = new StringBuilder();\\n        for(int i=0;i<total;i++){\\n            if(!flip)\\n                str.append(set.contains(i) ? \\'1\\' : \\'0\\');\\n            else{\\n                str.append(set.contains(i) ? \\'0\\' : \\'1\\');\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696018,
                "title": "java-solution-with-only-one-array-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Bitset {\\n    int[] arr;\\n    int count;\\n    boolean flip;\\n    public Bitset(int size) { //initialize the array\\n        arr=new int[size];\\n        count=0;\\n        flip=false;\\n    }\\n    \\n    public void fix(int idx) { // based on the flip write the code\\n        if(!flip){\\n            if(arr[idx]==0){\\n                arr[idx]=1;\\n                count++;\\n            }\\n        }\\n        else{\\n            if(arr[idx]==1){\\n                arr[idx]=0;\\n                count++;\\n            }\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(flip){\\n            if(arr[idx]==0){\\n                arr[idx]=1;\\n                count--;\\n            }\\n        }\\n        else{\\n            if(arr[idx]==1){\\n                arr[idx]=0;\\n                count--;\\n            }\\n        }\\n    }\\n    \\n    public void flip() {\\n        flip=!flip;\\n        count=arr.length-count;\\n    }\\n    \\n    public boolean all() {\\n        return count==arr.length;\\n    }\\n    \\n    public boolean one() {\\n        return count>0;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        if(flip){\\n            for(int i:arr){\\n                sb.append((i==1)?0:1);\\n            }\\n        }\\n        else{\\n            for(int i:arr){\\n                sb.append(i);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n    int[] arr;\\n    int count;\\n    boolean flip;\\n    public Bitset(int size) { //initialize the array\\n        arr=new int[size];\\n        count=0;\\n        flip=false;\\n    }\\n    \\n    public void fix(int idx) { // based on the flip write the code\\n        if(!flip){\\n            if(arr[idx]==0){\\n                arr[idx]=1;\\n                count++;\\n            }\\n        }\\n        else{\\n            if(arr[idx]==1){\\n                arr[idx]=0;\\n                count++;\\n            }\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(flip){\\n            if(arr[idx]==0){\\n                arr[idx]=1;\\n                count--;\\n            }\\n        }\\n        else{\\n            if(arr[idx]==1){\\n                arr[idx]=0;\\n                count--;\\n            }\\n        }\\n    }\\n    \\n    public void flip() {\\n        flip=!flip;\\n        count=arr.length-count;\\n    }\\n    \\n    public boolean all() {\\n        return count==arr.length;\\n    }\\n    \\n    public boolean one() {\\n        return count>0;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        if(flip){\\n            for(int i:arr){\\n                sb.append((i==1)?0:1);\\n            }\\n        }\\n        else{\\n            for(int i:arr){\\n                sb.append(i);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619834,
                "title": "java-solution-using-char-arrays",
                "content": "```\\nclass Bitset {\\n    \\n  char[] org,flip;\\n    int c;\\n    public Bitset(int size) {\\n        \\n        org=new char[size];\\n        flip=new char[size];\\n        Arrays.fill(org,\\'0\\');\\n        Arrays.fill(flip,\\'1\\');\\n        c=0;\\n    }\\n    \\n    public void fix(int idx) {\\n        \\n        if(org[idx]==\\'0\\') c++;\\n        org[idx]=\\'1\\';\\n        flip[idx]=\\'0\\';\\n        \\n    }\\n    \\n    public void unfix(int idx) {\\n        \\n        if(org[idx]==\\'1\\') c--;\\n        org[idx]=\\'0\\';\\n        flip[idx]=\\'1\\';\\n    }\\n    \\n    public void flip() {\\n        char[] temp=org;\\n        org=flip;\\n        flip=temp;\\n        c=org.length-c;\\n        \\n    }\\n    \\n    public boolean all() {\\n        \\n        return c==org.length;\\n    }\\n    \\n    public boolean one() {\\n    \\n        return c>=1;\\n    }\\n    \\n    public int count() {\\n        \\n        return c;\\n        \\n    }\\n    \\n    public String toString() {\\n        return new String(org);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Bitset {\\n    \\n  char[] org,flip;\\n    int c;\\n    public Bitset(int size) {\\n        \\n        org=new char[size];\\n        flip=new char[size];\\n        Arrays.fill(org,\\'0\\');\\n        Arrays.fill(flip,\\'1\\');\\n        c=0;\\n    }\\n    \\n    public void fix(int idx) {\\n        \\n        if(org[idx]==\\'0\\') c++;\\n        org[idx]=\\'1\\';\\n        flip[idx]=\\'0\\';\\n        \\n    }\\n    \\n    public void unfix(int idx) {\\n        \\n        if(org[idx]==\\'1\\') c--;\\n        org[idx]=\\'0\\';\\n        flip[idx]=\\'1\\';\\n    }\\n    \\n    public void flip() {\\n        char[] temp=org;\\n        org=flip;\\n        flip=temp;\\n        c=org.length-c;\\n        \\n    }\\n    \\n    public boolean all() {\\n        \\n        return c==org.length;\\n    }\\n    \\n    public boolean one() {\\n    \\n        return c>=1;\\n    }\\n    \\n    public int count() {\\n        \\n        return c;\\n        \\n    }\\n    \\n    public String toString() {\\n        return new String(org);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585124,
                "title": "think-on-the-fliping-condition-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Bitset {\\n    string x = \"\";\\n    int size ;\\n    int ones;\\n    int flips;\\npublic:\\n    Bitset(int size) {\\n        this->size = size;\\n        for(int i=0;i<size;i++){\\n            x+=\\'0\\';\\n        }\\n        ones = 0;\\n        flips=0;\\n\\n    }\\n    \\n    void fix(int idx) {\\n        if(flips%2 == 0){\\n            //means i am thinking that \\'1\\' means \\'1\\' and \\'0\\' means \\'0\\';\\n            if(x[idx] == \\'0\\'){\\n                ones++;\\n                x[idx] = \\'1\\';\\n            }\\n        }\\n        else{\\n            //means now \\'0\\' means \\'1\\' and \\'1\\' means\\'0\\'\\n            if(x[idx] == \\'1\\'){\\n                ones++;\\n                x[idx] = \\'0\\';\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(flips%2 == 0){\\n            //means i am thinking that \\'1\\' means \\'1\\' and \\'0\\' means \\'0\\';\\n            if(x[idx] == \\'1\\'){\\n                ones--;\\n                x[idx] = \\'0\\';\\n            }\\n        }\\n        else{\\n            //means now \\'0\\' means \\'1\\' and \\'1\\' means\\'0\\'\\n            if(x[idx] == \\'0\\'){\\n                ones--;\\n                x[idx] = \\'1\\';\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        flips++;\\n        ones = size - ones;\\n    }\\n    \\n    bool all() {\\n        if(ones == size)return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n        if(ones>=1)return true;\\n        return false;\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        string ans = x;\\n        if(flips%2 == 1){\\n            for(int i=0;i<size;i++){\\n                if(ans[i] == \\'1\\')ans[i] = \\'0\\';\\n                else if(ans[i] == \\'0\\')ans[i] = \\'1\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Bitset {\\n    string x = \"\";\\n    int size ;\\n    int ones;\\n    int flips;\\npublic:\\n    Bitset(int size) {\\n        this->size = size;\\n        for(int i=0;i<size;i++){\\n            x+=\\'0\\';\\n        }\\n        ones = 0;\\n        flips=0;\\n\\n    }\\n    \\n    void fix(int idx) {\\n        if(flips%2 == 0){\\n            //means i am thinking that \\'1\\' means \\'1\\' and \\'0\\' means \\'0\\';\\n            if(x[idx] == \\'0\\'){\\n                ones++;\\n                x[idx] = \\'1\\';\\n            }\\n        }\\n        else{\\n            //means now \\'0\\' means \\'1\\' and \\'1\\' means\\'0\\'\\n            if(x[idx] == \\'1\\'){\\n                ones++;\\n                x[idx] = \\'0\\';\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(flips%2 == 0){\\n            //means i am thinking that \\'1\\' means \\'1\\' and \\'0\\' means \\'0\\';\\n            if(x[idx] == \\'1\\'){\\n                ones--;\\n                x[idx] = \\'0\\';\\n            }\\n        }\\n        else{\\n            //means now \\'0\\' means \\'1\\' and \\'1\\' means\\'0\\'\\n            if(x[idx] == \\'0\\'){\\n                ones--;\\n                x[idx] = \\'1\\';\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        flips++;\\n        ones = size - ones;\\n    }\\n    \\n    bool all() {\\n        if(ones == size)return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n        if(ones>=1)return true;\\n        return false;\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        string ans = x;\\n        if(flips%2 == 1){\\n            for(int i=0;i<size;i++){\\n                if(ans[i] == \\'1\\')ans[i] = \\'0\\';\\n                else if(ans[i] == \\'0\\')ans[i] = \\'1\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580911,
                "title": "simplest-fast-solution-100-runtime-space-efficient-c",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUsing two StringBuilder, one to maintain original and one to maintain flipped version of original we can solve the given problem faster.\\n\\n![Screenshot 2023-05-31 101630.png](https://assets.leetcode.com/users/images/57e47fef-4a8c-4efc-91b9-d0e5bc23b82a_1685508472.7349489.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAll functionalities except \\'ToString\\' runs in O(1)\\nToString takes O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\npublic class Bitset {\\n    // original bit string of zeros and count of ones in it (initially 0)\\n    StringBuilder orig;\\n    int oneCount;\\n\\n    //flipped version of original - all bits set to 1s\\n    StringBuilder flip;\\n    int length;\\n\\n    public Bitset(int size) {\\n        orig = new StringBuilder();\\n        oneCount = 0;\\n\\n        flip = new StringBuilder();\\n\\n        length = size;\\n\\n        for (int i = 0; i < length; i++)\\n        {\\n            orig.Append(\\'0\\');\\n            flip.Append(\\'1\\');\\n        }\\n    }\\n    \\n    public void Fix(int idx) {\\n        if (orig[idx] != \\'1\\')\\n        {\\n            orig[idx] = \\'1\\';\\n            oneCount++;\\n\\n            flip[idx] = \\'0\\';\\n        }\\n    }\\n    \\n    public void Unfix(int idx) {\\n        if (orig[idx] != \\'0\\')\\n        {\\n            orig[idx] = \\'0\\';\\n            oneCount--;\\n\\n            flip[idx] = \\'1\\';\\n        }\\n    }\\n    \\n    public void Flip() {\\n        //update 1s count - to the one\\'s count of flipped\\n        oneCount = length - oneCount;\\n\\n        //swap original and flipped stringbuilders\\n        StringBuilder tempPointer = orig;\\n        orig = flip;\\n        flip = tempPointer;\\n    }\\n    \\n    public bool All() {\\n        return (oneCount == length);\\n    }\\n    \\n    public bool One() {\\n        return (oneCount > 0);\\n    }\\n    \\n    public int Count() {\\n        return oneCount;\\n    }\\n    \\n    public string ToString() {\\n        return orig.ToString();\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach\\n![Upvote please.jpg](https://assets.leetcode.com/users/images/431a0d3b-406a-457e-b40e-09ca60878c05_1685508768.270358.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Array",
                    "String",
                    "Design"
                ],
                "code": "```\\npublic class Bitset {\\n    // original bit string of zeros and count of ones in it (initially 0)\\n    StringBuilder orig;\\n    int oneCount;\\n\\n    //flipped version of original - all bits set to 1s\\n    StringBuilder flip;\\n    int length;\\n\\n    public Bitset(int size) {\\n        orig = new StringBuilder();\\n        oneCount = 0;\\n\\n        flip = new StringBuilder();\\n\\n        length = size;\\n\\n        for (int i = 0; i < length; i++)\\n        {\\n            orig.Append(\\'0\\');\\n            flip.Append(\\'1\\');\\n        }\\n    }\\n    \\n    public void Fix(int idx) {\\n        if (orig[idx] != \\'1\\')\\n        {\\n            orig[idx] = \\'1\\';\\n            oneCount++;\\n\\n            flip[idx] = \\'0\\';\\n        }\\n    }\\n    \\n    public void Unfix(int idx) {\\n        if (orig[idx] != \\'0\\')\\n        {\\n            orig[idx] = \\'0\\';\\n            oneCount--;\\n\\n            flip[idx] = \\'1\\';\\n        }\\n    }\\n    \\n    public void Flip() {\\n        //update 1s count - to the one\\'s count of flipped\\n        oneCount = length - oneCount;\\n\\n        //swap original and flipped stringbuilders\\n        StringBuilder tempPointer = orig;\\n        orig = flip;\\n        flip = tempPointer;\\n    }\\n    \\n    public bool All() {\\n        return (oneCount == length);\\n    }\\n    \\n    public bool One() {\\n        return (oneCount > 0);\\n    }\\n    \\n    public int Count() {\\n        return oneCount;\\n    }\\n    \\n    public string ToString() {\\n        return orig.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069356,
                "title": "python-solution-easy-to-understand-string-bitset",
                "content": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n\\t\\t# stores original bits True -> 1, False -> 0\\n        self.bit = [False for i in range(size)]\\n\\t\\t# inverse list of self.bit\\n        self.bitinv = [True for i in range(size)]\\n\\t\\t# counter of True\\n        self.ones = 0\\n\\t\\t# counter of False (both are for self.bit)\\n        self.zeros = size\\n\\t\\t# original size\\n        self.size = size\\n\\n    def fix(self, idx: int) -> None:\\n\\t\\t# if the bit is 0/False set the bit and update the counters bitinv stores opposite of self.bit every time\\n        if not self.bit[idx]:\\n            self.zeros -= 1\\n            self.ones += 1\\n        self.bit[idx] = True\\n        self.bitinv[idx] = False\\n\\n    def unfix(self, idx: int) -> None:\\n\\t\\t# if the bit is set unset the bit and update both the lists as mentioned above\\n        if self.bit[idx]:\\n            self.zeros += 1\\n            self.ones -= 1\\n        self.bit[idx] = False\\n        self.bitinv[idx] = True\\n\\n    def flip(self) -> None:\\n\\t\\t# changing the zeros counter to ones and vice versa.\\n        self.ones,self.zeros = self.zeros,self.ones\\n\\t\\t# changing the list pointers now inverse list will be the main list i.e. self.bit will point towards self.bitinv and vice versa.\\n        self.bit,self.bitinv = self.bitinv,self.bit\\n\\n    def all(self) -> bool:\\n\\t\\t# return True if ones counter equal to size otherwise False.\\n        return self.ones == self.size\\n\\n    def one(self) -> bool:\\n\\t\\t# returns True if ones counter greater than zeros\\n        return self.ones > 0\\n\\n    def count(self) -> int:\\n\\t\\t# returns the number of ones\\n        return self.ones\\n\\n    def toString(self) -> str:\\n\\t\\t# appending 1 to string if it\\'s True in self.bit otherwise 0\\n        ans = \\'\\'\\n        for bit in self.bit:\\n            if bit:\\n                ans += \\'1\\'\\n            else:\\n                ans += \\'0\\'\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n\\t\\t# stores original bits True -> 1, False -> 0\\n        self.bit = [False for i in range(size)]\\n\\t\\t# inverse list of self.bit\\n        self.bitinv = [True for i in range(size)]\\n\\t\\t# counter of True\\n        self.ones = 0\\n\\t\\t# counter of False (both are for self.bit)\\n        self.zeros = size\\n\\t\\t# original size\\n        self.size = size\\n\\n    def fix(self, idx: int) -> None:\\n\\t\\t# if the bit is 0/False set the bit and update the counters bitinv stores opposite of self.bit every time\\n        if not self.bit[idx]:\\n            self.zeros -= 1\\n            self.ones += 1\\n        self.bit[idx] = True\\n        self.bitinv[idx] = False\\n\\n    def unfix(self, idx: int) -> None:\\n\\t\\t# if the bit is set unset the bit and update both the lists as mentioned above\\n        if self.bit[idx]:\\n            self.zeros += 1\\n            self.ones -= 1\\n        self.bit[idx] = False\\n        self.bitinv[idx] = True\\n\\n    def flip(self) -> None:\\n\\t\\t# changing the zeros counter to ones and vice versa.\\n        self.ones,self.zeros = self.zeros,self.ones\\n\\t\\t# changing the list pointers now inverse list will be the main list i.e. self.bit will point towards self.bitinv and vice versa.\\n        self.bit,self.bitinv = self.bitinv,self.bit\\n\\n    def all(self) -> bool:\\n\\t\\t# return True if ones counter equal to size otherwise False.\\n        return self.ones == self.size\\n\\n    def one(self) -> bool:\\n\\t\\t# returns True if ones counter greater than zeros\\n        return self.ones > 0\\n\\n    def count(self) -> int:\\n\\t\\t# returns the number of ones\\n        return self.ones\\n\\n    def toString(self) -> str:\\n\\t\\t# appending 1 to string if it\\'s True in self.bit otherwise 0\\n        ans = \\'\\'\\n        for bit in self.bit:\\n            if bit:\\n                ans += \\'1\\'\\n            else:\\n                ans += \\'0\\'\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528397,
                "title": "all-operations-in-o-1-take-both-original-and-inverted-string-c",
                "content": "```\\nint n;\\n    string original,inverted;\\n    int ones=0;\\n    \\n    Bitset(int size) {\\n        \\n        original=string(size,\\'0\\');\\n        inverted=string(size,\\'1\\');\\n        n=size;\\n    }\\n    \\n    void fix(int idx) {\\n        \\n        if(original[idx]==\\'0\\')   //us place pe 0 hai tabhi 1 kro vaha par aur ones++\\n        {\\n            original[idx]=\\'1\\';\\n            inverted[idx]=\\'0\\';\\n            ones++;\\n        }\\n        \\n    }\\n    \\n    void unfix(int idx) {\\n        \\n        if(original[idx]==\\'1\\')  //us place pe 1 hai tabhi unifx krke 0 krege aur ones-- \\n        {\\n            original[idx]=\\'0\\';\\n            inverted[idx]=\\'1\\';  //inverted string me ulta kro jo kr rhe taaki jab puri \\n            ones--; //string ko flip marne bole to hm original aur inverted ko swap marde\\n        }\\n    }\\n    \\n    void flip() {\\n        \\n        original.swap(inverted);        //stl use kro for removing TLE (temp se mat kro) \\n        ones=n-ones;\\n    }\\n    \\n    bool all() { return ones==n; }\\n    \\n    bool one() { return ones>0; }\\n    \\n    int count() { return ones; }\\n    \\n    string toString() { return original;}",
                "solutionTags": [],
                "code": "```\\nint n;\\n    string original,inverted;\\n    int ones=0;\\n    \\n    Bitset(int size) {\\n        \\n        original=string(size,\\'0\\');\\n        inverted=string(size,\\'1\\');\\n        n=size;\\n    }\\n    \\n    void fix(int idx) {\\n        \\n        if(original[idx]==\\'0\\')   //us place pe 0 hai tabhi 1 kro vaha par aur ones++\\n        {\\n            original[idx]=\\'1\\';\\n            inverted[idx]=\\'0\\';\\n            ones++;\\n        }\\n        \\n    }\\n    \\n    void unfix(int idx) {\\n        \\n        if(original[idx]==\\'1\\')  //us place pe 1 hai tabhi unifx krke 0 krege aur ones-- \\n        {\\n            original[idx]=\\'0\\';\\n            inverted[idx]=\\'1\\';  //inverted string me ulta kro jo kr rhe taaki jab puri \\n            ones--; //string ko flip marne bole to hm original aur inverted ko swap marde\\n        }\\n    }\\n    \\n    void flip() {\\n        \\n        original.swap(inverted);        //stl use kro for removing TLE (temp se mat kro) \\n        ones=n-ones;\\n    }\\n    \\n    bool all() { return ones==n; }\\n    \\n    bool one() { return ones>0; }\\n    \\n    int count() { return ones; }\\n    \\n    string toString() { return original;}",
                "codeTag": "Unknown"
            },
            {
                "id": 2369305,
                "title": "c-bit-ops",
                "content": "```\\nclass Bitset {\\n    using below_type = uint64_t;\\n    static constexpr int bit_width = sizeof(below_type) * CHAR_BIT;\\n    static constexpr below_type shift_one = 1;\\n    int cnt;\\n    int sz;\\n    vector<below_type> data;\\n    \\n    pair<int,int> indexOffset(int idx) {\\n        int i = idx / bit_width;\\n        int offs = idx % bit_width;\\n        return {i, offs};\\n    }\\n    \\npublic:\\n    Bitset(int size) : cnt(0), sz(size) {\\n        data.resize((sz + bit_width - 1) / bit_width, 0);\\n    }\\n    \\n    void fix(int idx) {\\n        auto [i, offs] = indexOffset(idx);\\n        if(!(data[i] & (shift_one << offs)))\\n            cnt++;\\n        data[i] |= (shift_one << offs);\\n    }\\n    \\n    void unfix(int idx) {\\n        auto [i, offs] = indexOffset(idx);\\n        if(data[i] & (shift_one << offs))\\n            cnt--;\\n        data[i] &= ~(shift_one << offs);        \\n    }\\n    \\n    void flip() {\\n        for(auto &i : data)\\n            i = ~i;\\n        cnt = sz - cnt;\\n    }\\n    \\n    bool all() {\\n        return cnt == sz;\\n    }\\n    \\n    bool one() {\\n        return cnt > 0;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        string ret;        \\n        ret.reserve(sz);\\n        for(auto i : data) {\\n            for(int j = 0; j < bit_width; ++j) {\\n                if(i & (shift_one << j)) {\\n                    ret += \\'1\\';\\n                } else {\\n                    ret += \\'0\\';\\n                }\\n                if(ret.length() == sz)\\n                    return ret;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Bitset {\\n    using below_type = uint64_t;\\n    static constexpr int bit_width = sizeof(below_type) * CHAR_BIT;\\n    static constexpr below_type shift_one = 1;\\n    int cnt;\\n    int sz;\\n    vector<below_type> data;\\n    \\n    pair<int,int> indexOffset(int idx) {\\n        int i = idx / bit_width;\\n        int offs = idx % bit_width;\\n        return {i, offs};\\n    }\\n    \\npublic:\\n    Bitset(int size) : cnt(0), sz(size) {\\n        data.resize((sz + bit_width - 1) / bit_width, 0);\\n    }\\n    \\n    void fix(int idx) {\\n        auto [i, offs] = indexOffset(idx);\\n        if(!(data[i] & (shift_one << offs)))\\n            cnt++;\\n        data[i] |= (shift_one << offs);\\n    }\\n    \\n    void unfix(int idx) {\\n        auto [i, offs] = indexOffset(idx);\\n        if(data[i] & (shift_one << offs))\\n            cnt--;\\n        data[i] &= ~(shift_one << offs);        \\n    }\\n    \\n    void flip() {\\n        for(auto &i : data)\\n            i = ~i;\\n        cnt = sz - cnt;\\n    }\\n    \\n    bool all() {\\n        return cnt == sz;\\n    }\\n    \\n    bool one() {\\n        return cnt > 0;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        string ret;        \\n        ret.reserve(sz);\\n        for(auto i : data) {\\n            for(int j = 0; j < bit_width; ++j) {\\n                if(i & (shift_one << j)) {\\n                    ret += \\'1\\';\\n                } else {\\n                    ret += \\'0\\';\\n                }\\n                if(ret.length() == sz)\\n                    return ret;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257811,
                "title": "python-minimum-space-usage",
                "content": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.size = size\\n        self.bit_set = 0\\n        self.ones = 0\\n        self.all_ones = 0\\n        \\n        for i in range(size):\\n            self.all_ones |= 1 << i\\n\\n    def fix(self, idx: int) -> None:\\n        if self.bit_set & (1 << idx) == 0:\\n            self.bit_set |= 1 << idx\\n            self.ones += 1\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.bit_set & (1 << idx) > 0:\\n            self.bit_set ^= 1 << idx\\n            self.ones -= 1\\n\\n    def flip(self) -> None:\\n        self.bit_set ^= self.all_ones\\n        self.ones = self.size - self.ones\\n\\n    def all(self) -> bool:\\n        return self.ones == self.size \\n\\n    def one(self) -> bool:\\n        return self.ones >= 1\\n\\n    def count(self) -> int:\\n        return self.ones \\n\\n    def toString(self) -> str:\\n        arr = [\\'0\\']*self.size\\n        for idx in range(self.size):\\n            if self.bit_set & (1 << idx) > 0:\\n                arr[idx] = \\'1\\'\\n        return \\'\\'.join(arr)",
                "solutionTags": [],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.size = size\\n        self.bit_set = 0\\n        self.ones = 0\\n        self.all_ones = 0\\n        \\n        for i in range(size):\\n            self.all_ones |= 1 << i\\n\\n    def fix(self, idx: int) -> None:\\n        if self.bit_set & (1 << idx) == 0:\\n            self.bit_set |= 1 << idx\\n            self.ones += 1\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.bit_set & (1 << idx) > 0:\\n            self.bit_set ^= 1 << idx\\n            self.ones -= 1\\n\\n    def flip(self) -> None:\\n        self.bit_set ^= self.all_ones\\n        self.ones = self.size - self.ones\\n\\n    def all(self) -> bool:\\n        return self.ones == self.size \\n\\n    def one(self) -> bool:\\n        return self.ones >= 1\\n\\n    def count(self) -> int:\\n        return self.ones \\n\\n    def toString(self) -> str:\\n        arr = [\\'0\\']*self.size\\n        for idx in range(self.size):\\n            if self.bit_set & (1 << idx) > 0:\\n                arr[idx] = \\'1\\'\\n        return \\'\\'.join(arr)",
                "codeTag": "Java"
            },
            {
                "id": 2228290,
                "title": "python-o-1-operations-using-one-list-only-97-43-faster",
                "content": "```python\\nclass Bitset:\\n    def __init__(self, size: int):\\n        self.bitset = [0] * size\\n        self.size = size\\n        self.ones = 0\\n        self.flipped = False\\n        \\n\\t\\t\\n    def fix(self, idx: int) -> None:\\n        if self.flipped and self.bitset[idx]:\\n            self.bitset[idx] = 0\\n            self.ones += 1\\n\\t\\t\\t\\n        elif not self.flipped and not self.bitset[idx]:\\n            self.bitset[idx] = 1\\n            self.ones += 1\\n        \\n\\t\\t\\n    def unfix(self, idx: int) -> None:\\n        if self.flipped and not self.bitset[idx]:\\n            self.bitset[idx] = 1\\n            self.ones -= 1\\n\\t\\t\\t\\n        elif not self.flipped and self.bitset[idx]:\\n            self.bitset[idx] = 0\\n            self.ones -= 1\\n        \\n\\t\\t\\n    def flip(self) -> None:\\n        self.flipped = not self.flipped\\n        self.ones = self.size - self.ones\\n\\n\\n    def all(self) -> bool:\\n        return self.ones == self.size\\n        \\n\\n    def one(self) -> bool:\\n        return self.ones > 0\\n        \\n\\t\\t\\n    def count(self) -> int:\\n        return self.ones\\n        \\n\\t\\t\\n    def toString(self) -> str:\\n        if self.flipped:\\n            return \"\".join(\"0\" if i else \"1\" for i in self.bitset)\\n        \\n        return \"\".join(\"1\" if i else \"0\" for i in self.bitset)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Design"
                ],
                "code": "```python\\nclass Bitset:\\n    def __init__(self, size: int):\\n        self.bitset = [0] * size\\n        self.size = size\\n        self.ones = 0\\n        self.flipped = False\\n        \\n\\t\\t\\n    def fix(self, idx: int) -> None:\\n        if self.flipped and self.bitset[idx]:\\n            self.bitset[idx] = 0\\n            self.ones += 1\\n\\t\\t\\t\\n        elif not self.flipped and not self.bitset[idx]:\\n            self.bitset[idx] = 1\\n            self.ones += 1\\n        \\n\\t\\t\\n    def unfix(self, idx: int) -> None:\\n        if self.flipped and not self.bitset[idx]:\\n            self.bitset[idx] = 1\\n            self.ones -= 1\\n\\t\\t\\t\\n        elif not self.flipped and self.bitset[idx]:\\n            self.bitset[idx] = 0\\n            self.ones -= 1\\n        \\n\\t\\t\\n    def flip(self) -> None:\\n        self.flipped = not self.flipped\\n        self.ones = self.size - self.ones\\n\\n\\n    def all(self) -> bool:\\n        return self.ones == self.size\\n        \\n\\n    def one(self) -> bool:\\n        return self.ones > 0\\n        \\n\\t\\t\\n    def count(self) -> int:\\n        return self.ones\\n        \\n\\t\\t\\n    def toString(self) -> str:\\n        if self.flipped:\\n            return \"\".join(\"0\" if i else \"1\" for i in self.bitset)\\n        \\n        return \"\".join(\"1\" if i else \"0\" for i in self.bitset)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121685,
                "title": "c-o-n-for-string-and-ctor-other-operation-o-1",
                "content": "```\\nclass Bitset {\\n    vector<bool> bits;\\n    bool bflip;\\n    int onecount;\\n    void _fix(int idx)\\n    {\\n        if (bits[idx]==0)\\n            onecount++;\\n        bits[idx] = true;\\n    }\\n    \\n    void _unfix(int idx) {\\n        if (bits[idx] == 1)\\n            onecount--;\\n        bits[idx] = false;\\n    }\\npublic:\\n    Bitset(int size) {\\n        bits.resize(size,false);\\n        bflip = false;\\n        onecount = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        if (bflip) _unfix(idx);\\n        else _fix(idx);\\n    }\\n    \\n    void unfix(int idx) {\\n        if (bflip) _fix(idx);\\n        else _unfix(idx);\\n    }\\n    \\n    void flip() {\\n        bflip = !bflip;\\n    }\\n    \\n    bool all() {\\n        return count() == bits.size();\\n    }\\n    \\n    bool one() {\\n        return count() >= 1;\\n    }\\n    \\n    int count() {\\n        if (!bflip) return onecount;\\n        else return bits.size() - onecount;\\n    }\\n    \\n    string toString() {\\n        string ans;\\n        for(int i=0; i<bits.size(); i++)\\n        {\\n            if (bits[i])\\n                ans.push_back(bflip?\\'0\\':\\'1\\');\\n            else\\n                ans.push_back(bflip?\\'1\\':\\'0\\');\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Bitset {\\n    vector<bool> bits;\\n    bool bflip;\\n    int onecount;\\n    void _fix(int idx)\\n    {\\n        if (bits[idx]==0)\\n            onecount++;\\n        bits[idx] = true;\\n    }\\n    \\n    void _unfix(int idx) {\\n        if (bits[idx] == 1)\\n            onecount--;\\n        bits[idx] = false;\\n    }\\npublic:\\n    Bitset(int size) {\\n        bits.resize(size,false);\\n        bflip = false;\\n        onecount = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        if (bflip) _unfix(idx);\\n        else _fix(idx);\\n    }\\n    \\n    void unfix(int idx) {\\n        if (bflip) _fix(idx);\\n        else _unfix(idx);\\n    }\\n    \\n    void flip() {\\n        bflip = !bflip;\\n    }\\n    \\n    bool all() {\\n        return count() == bits.size();\\n    }\\n    \\n    bool one() {\\n        return count() >= 1;\\n    }\\n    \\n    int count() {\\n        if (!bflip) return onecount;\\n        else return bits.size() - onecount;\\n    }\\n    \\n    string toString() {\\n        string ans;\\n        for(int i=0; i<bits.size(); i++)\\n        {\\n            if (bits[i])\\n                ans.push_back(bflip?\\'0\\':\\'1\\');\\n            else\\n                ans.push_back(bflip?\\'1\\':\\'0\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982503,
                "title": "c-o-n-constructor-for-o-1-methods-bitwise-trick-95-time-381ms-65-space-196-5mb",
                "content": "Let\\'s go through a first naive implementation first and its related class variables:\\n* our core logic will be a `bool` array to store our values `store`;\\n* `flipped` is another boolean flag we will use to remind us whether the bitset has been flipped an odd numbers of times or not;\\n* `size` and `trues` will store respectively the capacity of our DS and the number of values set to `trues`, with the latter initially set to `0`;\\n* `str` will be our  result variable for the `toString` method.\\n\\nIn our constructor we will:\\n* set store to point to a new boolean array of size `size`;\\n* fill `store` with all `false` values;\\n* similarly, resize `str` to `size` and...\\n* fill it all with `\\'0\\'`;\\n* pass the value of `size` to our internal class variable.\\n\\nIn the `fix` method, we will check if `flipped` equals `store[idx]` (which means, we will act only when it is a `false` for an unflipped array or `true` for a flipped one) and, in case:\\n* set `store[idx]` to be `!flipped` (so, the opposite of its current value);\\n* increase `trues` by `1`.\\n\\nIn the `unfix` method, specularly, we will check if `flipped` differs from `store[idx]` (which means, we will act only when it is a `true` for an unflipped array or `false` for a flipped one) and, in case:\\n* set `store[idx]` to be `flipped` (so, again, the opposite of its current value);\\n* decrease `trues` by `1`.\\n\\nNow, since we are using the boolean flag `flipped`, the `flip` method actually becomes crazy cheap for us and we can just:\\n* switch `flipped`;\\n* updated `trues` to be its complmentary value to `size`, which is just `size - trues`.\\n\\nSimilarly, since we keep an updated count of how many values are set to `trues`, we can `return` whether or not `trues` equals `size` for the `all` method.\\n\\nThe one is even easier, since we can merely `return` `trues` (which will be converted to a boolean, so `false` for `trues == 0` and `true` for any other value).\\n\\n`toString` will run in linear time, running with the pointer `i` through all the elements and updating `str[i]` to be `\\'0\\'` when `flipped == store[i]`, `\\'1\\'` otherwise.\\n\\nThe code:\\n\\n```cpp\\nclass Bitset {\\n    // support variables\\n    bool *store, flipped = false;\\n    int size, trues = 0;\\n    string str;\\npublic:\\n    Bitset(int size) {\\n        // initialising store, str and internal `size`\\n        store = new bool[size];\\n        fill(store, store + size, false);\\n        str.resize(size);\\n        fill(begin(str), end(str), \\'0\\');\\n        this->size = size;\\n    }\\n    \\n    void fix(int idx) {\\n        // flipping and turning only if store[idx] == flipped\\n        if (flipped == store[idx]) {\\n            store[idx] = !flipped, trues++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        // flipping and turning only if store[idx] != flipped\\n        if (!flipped == store[idx]) {\\n            store[idx] = flipped, trues--;\\n        }\\n    }\\n    \\n    void flip() {\\n        flipped = !flipped;\\n        trues = size - trues;\\n    }\\n    \\n    bool all() {\\n        return trues == size;\\n    }\\n    \\n    bool one() {\\n        return trues;\\n    }\\n    \\n    int count() {\\n        return trues;\\n    }\\n    \\n    string toString() {\\n        // properly updating str\\n        for (int i = 0; i < size; i++) str[i] = store[i] == flipped ? \\'0\\' : \\'1\\';\\n        return str;\\n    }\\n};\\n```\\n\\nBut, wait, a moment \\uD83E\\uDD14  - the `toString` is still pretty expensive, even if we know it will not be called many times; can we do better?\\n\\nWell, yes - for example if we put a tiny bit of extra memory and effort to store a parallel string, `flippedStr`, initially set to be all `\\'1\\'`s and updated accordingly on each `fix`/`unfix` operation, with `flip` only telling us which one to use.\\n\\nThe updated code, which runs about 60-70% faster:\\n\\n```cpp\\nclass Bitset {\\n    // support variables\\n    bool *store, flipped = false;\\n    int size, trues = 0;\\n    string str, flippedStr;\\npublic:\\n    Bitset(int size) {\\n        // initialising store, str and internal `size`\\n        store = new bool[size];\\n        fill(store, store + size, false);\\n        str.resize(size);\\n        fill(begin(str), end(str), \\'0\\');\\n        flippedStr.resize(size);\\n        fill(begin(flippedStr), end(flippedStr), \\'1\\');\\n        this->size = size;\\n    }\\n    \\n    void fix(int idx) {\\n        // flipping and turning only if store[idx] == flipped\\n        if (flipped == store[idx]) {\\n            store[idx] = !flipped, trues++;\\n            (flipped ? flippedStr : str)[idx] = \\'1\\';\\n            (flipped ? str : flippedStr)[idx] = \\'0\\';\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        // flipping and turning only if store[idx] != flipped\\n        if (!flipped == store[idx]) {\\n            store[idx] = flipped, trues--;\\n            (flipped ? flippedStr : str)[idx] = \\'0\\';\\n            (flipped ? str : flippedStr)[idx] = \\'1\\';\\n        }\\n    }\\n    \\n    void flip() {\\n        flipped = !flipped;\\n        trues = size - trues;\\n    }\\n    \\n    bool all() {\\n        return trues == size;\\n    }\\n    \\n    bool one() {\\n        return trues;\\n    }\\n    \\n    int count() {\\n        return trues;\\n    }\\n    \\n    string toString() {\\n        // returning the right string\\n        return flipped ? flippedStr : str;\\n    }\\n};\\n```\\n\\nAnd just for the sake of bit manipulation, a divertissement actually using actual specific bits.\\n\\nWe will start getting `cellSize` as the size of a `long long`, then deriving `cellShift` (ie: how many cells we will have to shift when doing binary shift later on) from that, plus `3` (since each byte equals `8` bits, which means `3` extra steps, since `8` is `1000` in binary representation). Similarly, we will get `bitmask` as `2` raised to `cellShift` minus `1`. With `cellShfit` equal to `6`, for example, our `bitmask` is going to be `63`, that is to say `111111` in binary - we will use this value since it is waaaay cheaper than computing a modulo all the time.\\n\\nIn our constructor we will then compute how many `cells` we will need as `cell >> cellShift` (which in the example above equates to `size / 64`, applying a right shift of `6` positions) and add `1` to it, since we need to store also the  values that would be truncated by this operation.\\n\\nThe rest of the logic is almost the same, with the sole different that this time we will address a specific bit of memory in `store`, whose position `currCell` is obtained dividing `idx` by the size of each cell (again, `64` in our example) or, more cheaply, right shifting `idx` by `cellShift` positions; the specific bit inside the cell is then found computing `currBit` as `idx & bitmask`, a much cheaper alternative of doing `% cellSize` all the time, since we just work with powers of `2`.\\n\\nShifting the bit itself can be similarly done in an easy way using a binary XOR `^`.\\n\\nThe code, which runs basically as fast and consumes a tiny bit less memory than the previous:\\n\\n```cpp\\nconstexpr unsigned int cellSize = sizeof(long long);\\n\\nclass Bitset {\\n    // support variables\\n    bool flipped = false;\\n    unsigned int size, trues = 0, cellShift = log2(cellSize) + 3;\\n    unsigned long long *store, bitmask = pow(2, cellShift) - 1;\\n    string str, flippedStr;\\npublic:\\n    Bitset(int size) {\\n        // initialising store, str and internal `size`\\n        int cells = (size >> cellShift) + 1;\\n        store = new unsigned long long[cells];\\n        fill(store, store + cells, 0);\\n        str.resize(size);\\n        fill(begin(str), end(str), \\'0\\');\\n        flippedStr.resize(size);\\n        fill(begin(flippedStr), end(flippedStr), \\'1\\');\\n        this->size = size;\\n    }\\n    \\n    void fix(int idx) {\\n        int currCell = idx >> cellShift;\\n        long long currBit = 1ll << (idx & bitmask);\\n        // flipping and turning only if (store[currCell] & currBit) == flipped\\n        if (flipped == bool(store[currCell] & currBit)) {\\n            store[currCell] ^= currBit, trues++;\\n            (flipped ? flippedStr : str)[idx] = \\'1\\';\\n            (flipped ? str : flippedStr)[idx] = \\'0\\';\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        int currCell = idx >> cellShift;\\n        long long currBit = 1ll << (idx & bitmask);\\n        // flipping and turning only if (store[currCell] & currBit) != flipped\\n        if (!flipped == bool(store[currCell] & currBit)) {\\n            store[currCell] ^= currBit, trues--;\\n            (flipped ? flippedStr : str)[idx] = \\'0\\';\\n            (flipped ? str : flippedStr)[idx] = \\'1\\';\\n        }\\n    }\\n    \\n    void flip() {\\n        flipped = !flipped;\\n        trues = size - trues;\\n    }\\n    \\n    bool all() {\\n        return trues == size;\\n    }\\n    \\n    bool one() {\\n        return trues;\\n    }\\n    \\n    int count() {\\n        return trues;\\n    }\\n    \\n    string toString() {\\n        // returning the right string\\n        return flipped ? flippedStr : str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Bitset {\\n    // support variables\\n    bool *store, flipped = false;\\n    int size, trues = 0;\\n    string str;\\npublic:\\n    Bitset(int size) {\\n        // initialising store, str and internal `size`\\n        store = new bool[size];\\n        fill(store, store + size, false);\\n        str.resize(size);\\n        fill(begin(str), end(str), \\'0\\');\\n        this->size = size;\\n    }\\n    \\n    void fix(int idx) {\\n        // flipping and turning only if store[idx] == flipped\\n        if (flipped == store[idx]) {\\n            store[idx] = !flipped, trues++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        // flipping and turning only if store[idx] != flipped\\n        if (!flipped == store[idx]) {\\n            store[idx] = flipped, trues--;\\n        }\\n    }\\n    \\n    void flip() {\\n        flipped = !flipped;\\n        trues = size - trues;\\n    }\\n    \\n    bool all() {\\n        return trues == size;\\n    }\\n    \\n    bool one() {\\n        return trues;\\n    }\\n    \\n    int count() {\\n        return trues;\\n    }\\n    \\n    string toString() {\\n        // properly updating str\\n        for (int i = 0; i < size; i++) str[i] = store[i] == flipped ? \\'0\\' : \\'1\\';\\n        return str;\\n    }\\n};\\n```\n```cpp\\nclass Bitset {\\n    // support variables\\n    bool *store, flipped = false;\\n    int size, trues = 0;\\n    string str, flippedStr;\\npublic:\\n    Bitset(int size) {\\n        // initialising store, str and internal `size`\\n        store = new bool[size];\\n        fill(store, store + size, false);\\n        str.resize(size);\\n        fill(begin(str), end(str), \\'0\\');\\n        flippedStr.resize(size);\\n        fill(begin(flippedStr), end(flippedStr), \\'1\\');\\n        this->size = size;\\n    }\\n    \\n    void fix(int idx) {\\n        // flipping and turning only if store[idx] == flipped\\n        if (flipped == store[idx]) {\\n            store[idx] = !flipped, trues++;\\n            (flipped ? flippedStr : str)[idx] = \\'1\\';\\n            (flipped ? str : flippedStr)[idx] = \\'0\\';\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        // flipping and turning only if store[idx] != flipped\\n        if (!flipped == store[idx]) {\\n            store[idx] = flipped, trues--;\\n            (flipped ? flippedStr : str)[idx] = \\'0\\';\\n            (flipped ? str : flippedStr)[idx] = \\'1\\';\\n        }\\n    }\\n    \\n    void flip() {\\n        flipped = !flipped;\\n        trues = size - trues;\\n    }\\n    \\n    bool all() {\\n        return trues == size;\\n    }\\n    \\n    bool one() {\\n        return trues;\\n    }\\n    \\n    int count() {\\n        return trues;\\n    }\\n    \\n    string toString() {\\n        // returning the right string\\n        return flipped ? flippedStr : str;\\n    }\\n};\\n```\n```cpp\\nconstexpr unsigned int cellSize = sizeof(long long);\\n\\nclass Bitset {\\n    // support variables\\n    bool flipped = false;\\n    unsigned int size, trues = 0, cellShift = log2(cellSize) + 3;\\n    unsigned long long *store, bitmask = pow(2, cellShift) - 1;\\n    string str, flippedStr;\\npublic:\\n    Bitset(int size) {\\n        // initialising store, str and internal `size`\\n        int cells = (size >> cellShift) + 1;\\n        store = new unsigned long long[cells];\\n        fill(store, store + cells, 0);\\n        str.resize(size);\\n        fill(begin(str), end(str), \\'0\\');\\n        flippedStr.resize(size);\\n        fill(begin(flippedStr), end(flippedStr), \\'1\\');\\n        this->size = size;\\n    }\\n    \\n    void fix(int idx) {\\n        int currCell = idx >> cellShift;\\n        long long currBit = 1ll << (idx & bitmask);\\n        // flipping and turning only if (store[currCell] & currBit) == flipped\\n        if (flipped == bool(store[currCell] & currBit)) {\\n            store[currCell] ^= currBit, trues++;\\n            (flipped ? flippedStr : str)[idx] = \\'1\\';\\n            (flipped ? str : flippedStr)[idx] = \\'0\\';\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        int currCell = idx >> cellShift;\\n        long long currBit = 1ll << (idx & bitmask);\\n        // flipping and turning only if (store[currCell] & currBit) != flipped\\n        if (!flipped == bool(store[currCell] & currBit)) {\\n            store[currCell] ^= currBit, trues--;\\n            (flipped ? flippedStr : str)[idx] = \\'0\\';\\n            (flipped ? str : flippedStr)[idx] = \\'1\\';\\n        }\\n    }\\n    \\n    void flip() {\\n        flipped = !flipped;\\n        trues = size - trues;\\n    }\\n    \\n    bool all() {\\n        return trues == size;\\n    }\\n    \\n    bool one() {\\n        return trues;\\n    }\\n    \\n    int count() {\\n        return trues;\\n    }\\n    \\n    string toString() {\\n        // returning the right string\\n        return flipped ? flippedStr : str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981512,
                "title": "rust-o-1-operations-including-flip-only-1-array",
                "content": "I  tried a few approaches to optimize for speed. My first implementation included an actual bitfield using a u32/u64/u128 as the underlying partial bitfield. My thinking was this would give good timing results, but it didn\\'t.  The bitwise operations on partial bitfields should have been fast. The slow point may have been `to_string()`.\\n\\nAfter trying a few different approaches, I figured we only need to keep count of 1\\'s and track which bits have been modified. So I utilized a `HashMap` to track modified bits.  The flip operation only involved setting a variable `.flipped` and adjusting the ones count.  When `.flipped` is true, the logic deals with existing bit entries in the `HashMap` as if they\\'re the opposite value.\\n\\nAfter the version with the `HashMap` was working, I replaced it with an array of bool values, which sped the operations up a bit.   Approaching the implementation for `fix()` and `unfix()` was tough. Their implementations were arrived at by gradually simlifying their initial code.\\n\\n`to_string()` is `O(n)`, but so is everyone\\'s even if they think it isn\\'t. Calling an `O(n)` class library routine makes the overall algorithm `O(n)` even though it\\'s hidden.\\n\\nMy latest optimization strategy is to obsessively continue running the code at random intervals until I hit a time when the server has low load and finally gives me the \"faster than 100%\" rating.. but as it is now, runs are only giving me 50-90%.\\n\\n```rust\\nstruct Bitset {\\n    count   : usize,\\n    flipped : bool,\\n    bits    : Vec<bool>,\\n}\\n\\nimpl Bitset {\\n    fn new(size: i32) -> Self {\\n        Self {\\n            count   : 0,\\n            flipped : false,\\n            bits    : vec![false; size as usize],\\n        }\\n    }\\n    fn fix(&mut self, idx: i32) {\\n        if self.bits[idx as usize] == self.flipped {\\n            self.count += 1;\\n            self.bits[idx as usize] = !self.flipped;\\n        }\\n    }\\n    fn unfix(&mut self, idx: i32) {\\n        if self.bits[idx as usize] == !self.flipped {\\n            self.count -= 1;\\n            self.bits[idx as usize] = self.flipped;\\n        }\\n    }\\n    fn flip(&mut self) {\\n        self.flipped = !self.flipped;\\n        self.count = self.bits.len() - self.count;\\n    }\\n    fn all(&self) -> bool {\\n        self.count == self.bits.len()\\n    }\\n    fn one(&self) -> bool {\\n        self.count > 0\\n    }\\n    fn count(&self) -> i32 {\\n        self.count as i32\\n    }\\n    fn to_string(&self) -> String {\\n        self.bits.iter()\\n                 .map(|&val| if val == self.flipped {\\'0\\'} else {\\'1\\'})\\n                 .collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nstruct Bitset {\\n    count   : usize,\\n    flipped : bool,\\n    bits    : Vec<bool>,\\n}\\n\\nimpl Bitset {\\n    fn new(size: i32) -> Self {\\n        Self {\\n            count   : 0,\\n            flipped : false,\\n            bits    : vec![false; size as usize],\\n        }\\n    }\\n    fn fix(&mut self, idx: i32) {\\n        if self.bits[idx as usize] == self.flipped {\\n            self.count += 1;\\n            self.bits[idx as usize] = !self.flipped;\\n        }\\n    }\\n    fn unfix(&mut self, idx: i32) {\\n        if self.bits[idx as usize] == !self.flipped {\\n            self.count -= 1;\\n            self.bits[idx as usize] = self.flipped;\\n        }\\n    }\\n    fn flip(&mut self) {\\n        self.flipped = !self.flipped;\\n        self.count = self.bits.len() - self.count;\\n    }\\n    fn all(&self) -> bool {\\n        self.count == self.bits.len()\\n    }\\n    fn one(&self) -> bool {\\n        self.count > 0\\n    }\\n    fn count(&self) -> i32 {\\n        self.count as i32\\n    }\\n    fn to_string(&self) -> String {\\n        self.bits.iter()\\n                 .map(|&val| if val == self.flipped {\\'0\\'} else {\\'1\\'})\\n                 .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1979158,
                "title": "o-1-for-all-function-calls-using-vector",
                "content": "```\\nclass Bitset {\\npublic:\\n    vector<bool>ans;\\n    int o=0;\\n    int zero=0;\\n    Bitset(int size) {\\n        ans.resize(size,false);\\n        zero=size;\\n    }\\n    \\n    void fix(int idx) {\\n        if(ans[idx]!=true)\\n        {\\n            ans[idx]=true;\\n            o++;\\n            zero--;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(ans[idx])\\n        {\\n            ans[idx]=false;\\n            zero++;\\n            o--;\\n        }\\n    }\\n    \\n    void flip() {\\n        ans.flip();\\n        swap(zero,o);\\n    }\\n    \\n    bool all() {\\n        return o==ans.size();\\n    }\\n    \\n    bool one() {\\n        return o!=0;\\n    }\\n    \\n    int count() {\\n        return o;\\n    }\\n    \\n    string toString() {\\n        string temp=\"\";\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i])\\n            {\\n                temp+=\\'1\\';\\n            }\\n            else\\n            {\\n                temp+=\\'0\\';    \\n            }\\n        }\\n        return temp;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    vector<bool>ans;\\n    int o=0;\\n    int zero=0;\\n    Bitset(int size) {\\n        ans.resize(size,false);\\n        zero=size;\\n    }\\n    \\n    void fix(int idx) {\\n        if(ans[idx]!=true)\\n        {\\n            ans[idx]=true;\\n            o++;\\n            zero--;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(ans[idx])\\n        {\\n            ans[idx]=false;\\n            zero++;\\n            o--;\\n        }\\n    }\\n    \\n    void flip() {\\n        ans.flip();\\n        swap(zero,o);\\n    }\\n    \\n    bool all() {\\n        return o==ans.size();\\n    }\\n    \\n    bool one() {\\n        return o!=0;\\n    }\\n    \\n    int count() {\\n        return o;\\n    }\\n    \\n    string toString() {\\n        string temp=\"\";\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i])\\n            {\\n                temp+=\\'1\\';\\n            }\\n            else\\n            {\\n                temp+=\\'0\\';    \\n            }\\n        }\\n        return temp;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979083,
                "title": "c-o-1-for-everything-clean-easy-and-explained",
                "content": "```\\nclass Bitset {\\npublic:\\n    vector<bool> ans; // true-> 1 and false-> 0\\n    bool f=false;   \\n    int b1=0,b2=0; // b1-> count of \\'1\\' and b2-> count of \\'0\\'\\n    Bitset(int size) {\\n        for(int i=0;i<size;i++) ans.emplace_back(false);\\n        b2=size;\\n    }\\n    void fix(int idx) {\\n        if(!ans[idx] && !f){\\n        ans[idx]=true;\\n            b1++;\\n            b2--;\\n        }\\n        else if(f && ans[idx]){\\n            ans[idx]=false;\\n            b1++;\\n            b2--;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(ans[idx] && !f){\\n        ans[idx]=false;\\n        b1--;\\n        b2++;\\n        }\\n        else if(f && !ans[idx]){\\n            ans[idx]=true;\\n        b1--;\\n        b2++;\\n        }\\n    }\\n    \\n    void flip() {\\n        f= !f ;\\n        swap(b1,b2);\\n    }\\n    \\n    bool all() {\\n      return b2==0;\\n    }\\n    \\n    bool one() {\\n          return b1>0; \\n    }\\n    \\n    int count() {\\n        return b1;\\n    }\\n    \\n    string toString() {\\n        string res;\\n        char a=\\'1\\', b=\\'0\\';\\n        if(f) swap(a,b);\\n        for(auto it : ans)\\n        {\\n            if(it) res+=a;\\n            else res+=b;\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Bitset {\\npublic:\\n    vector<bool> ans; // true-> 1 and false-> 0\\n    bool f=false;   \\n    int b1=0,b2=0; // b1-> count of \\'1\\' and b2-> count of \\'0\\'\\n    Bitset(int size) {\\n        for(int i=0;i<size;i++) ans.emplace_back(false);\\n        b2=size;\\n    }\\n    void fix(int idx) {\\n        if(!ans[idx] && !f){\\n        ans[idx]=true;\\n            b1++;\\n            b2--;\\n        }\\n        else if(f && ans[idx]){\\n            ans[idx]=false;\\n            b1++;\\n            b2--;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(ans[idx] && !f){\\n        ans[idx]=false;\\n        b1--;\\n        b2++;\\n        }\\n        else if(f && !ans[idx]){\\n            ans[idx]=true;\\n        b1--;\\n        b2++;\\n        }\\n    }\\n    \\n    void flip() {\\n        f= !f ;\\n        swap(b1,b2);\\n    }\\n    \\n    bool all() {\\n      return b2==0;\\n    }\\n    \\n    bool one() {\\n          return b1>0; \\n    }\\n    \\n    int count() {\\n        return b1;\\n    }\\n    \\n    string toString() {\\n        string res;\\n        char a=\\'1\\', b=\\'0\\';\\n        if(f) swap(a,b);\\n        for(auto it : ans)\\n        {\\n            if(it) res+=a;\\n            else res+=b;\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976688,
                "title": "c-design-bitset-o-1-operation-simple-and-easy",
                "content": "```\\nclass Bitset {\\npublic:\\n    string s,revS;\\n    int c,revC;\\n    Bitset(int size) {\\n        s.resize(size,\\'0\\');\\n        revS.resize(size,\\'1\\');\\n        c=0;\\n        revC=revS.size();\\n    }\\n    \\n    void fix(int idx) {\\n        if(s[idx]==\\'0\\'){\\n            s[idx]=\\'1\\';\\n            c++;\\n        }\\n        if(revS[idx]==\\'1\\'){\\n            revS[idx]=\\'0\\';\\n            revC--;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n         if(s[idx]==\\'1\\'){\\n            s[idx]=\\'0\\';\\n            c--;\\n        }\\n        if(revS[idx]==\\'0\\'){\\n            revS[idx]=\\'1\\';\\n            revC++;\\n        }\\n    }\\n    \\n    void flip() {\\n        swap(s,revS);\\n        swap(c,revC);\\n    }\\n    \\n    bool all() {\\n        return c==s.size();\\n    }\\n    \\n    bool one() {\\n        return c>0;\\n    }\\n    \\n    int count() {\\n        return c;\\n    }\\n    \\n    string toString() {\\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```\\n\\n### if you like it upvote it",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    string s,revS;\\n    int c,revC;\\n    Bitset(int size) {\\n        s.resize(size,\\'0\\');\\n        revS.resize(size,\\'1\\');\\n        c=0;\\n        revC=revS.size();\\n    }\\n    \\n    void fix(int idx) {\\n        if(s[idx]==\\'0\\'){\\n            s[idx]=\\'1\\';\\n            c++;\\n        }\\n        if(revS[idx]==\\'1\\'){\\n            revS[idx]=\\'0\\';\\n            revC--;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n         if(s[idx]==\\'1\\'){\\n            s[idx]=\\'0\\';\\n            c--;\\n        }\\n        if(revS[idx]==\\'0\\'){\\n            revS[idx]=\\'1\\';\\n            revC++;\\n        }\\n    }\\n    \\n    void flip() {\\n        swap(s,revS);\\n        swap(c,revC);\\n    }\\n    \\n    bool all() {\\n        return c==s.size();\\n    }\\n    \\n    bool one() {\\n        return c>0;\\n    }\\n    \\n    int count() {\\n        return c;\\n    }\\n    \\n    string toString() {\\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966075,
                "title": "java-2-solutions-1-hashset-2-2-char-o-1-include-tostring",
                "content": "HashSet\\n\\n```\\nclass Bitset {\\n    int size;\\n    Set<Integer> set=new HashSet();\\n    boolean isOne=true;\\n    public Bitset(int size) {\\n        this.size=size;\\n    }\\n    \\n    public void fix(int idx) {\\n        if(isOne){\\n            set.add(idx);\\n        }else{\\n            set.remove(idx);\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(!isOne){\\n            set.add(idx);\\n        }else{\\n            set.remove(idx);\\n        }\\n    }\\n    \\n    public void flip() {\\n        isOne=!isOne;\\n    }\\n    \\n    public boolean all() {\\n        return count()==size;\\n    }\\n    \\n    public boolean one() {\\n        return count()>=1;\\n    }\\n    \\n    public int count() {\\n        if(isOne){\\n            return set.size();\\n        }else{\\n            return size-set.size();\\n        }\\n    }\\n    \\n    public String toString() {\\n        char v[]=new char[size];        \\n        if(isOne){\\n            Arrays.fill(v,\\'0\\');\\n            for(int n:set){\\n                v[n]=\\'1\\';\\n            }\\n        }else{\\n            Arrays.fill(v,\\'1\\');\\n            for(int n:set){\\n                v[n]=\\'0\\';\\n            }\\n        }\\n        return new String(v);\\n    }\\n}\\n```\\n\\n2 char[]\\n```\\nclass Bitset {\\n    char vOnes[];\\n    char vMirror[];\\n    int countOnes;\\n    int countMirror;\\n    public Bitset(int size) {\\n        vOnes=new char[size];\\n        vMirror=new char[size];\\n        Arrays.fill(vOnes,\\'0\\');\\n        Arrays.fill(vMirror,\\'1\\');\\n        countOnes=0;\\n        countMirror=size;\\n    }\\n    \\n    public void fix(int idx) {\\n        if(vOnes[idx]==\\'0\\'){\\n            countOnes++;\\n            countMirror--;\\n        }\\n        vOnes[idx]=\\'1\\';\\n        vMirror[idx]=\\'0\\';\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(vOnes[idx]==\\'1\\'){\\n            countOnes--;\\n            countMirror++;\\n        }\\n        vOnes[idx]=\\'0\\';\\n        vMirror[idx]=\\'1\\';\\n    }\\n    \\n    public void flip() {\\n        char v[]=vOnes;\\n        vOnes=vMirror;\\n        vMirror=v;\\n        int t=countOnes;\\n        countOnes=countMirror;\\n        countMirror=t;\\n    }\\n    \\n    public boolean all() {\\n        return countOnes==vOnes.length;\\n    }\\n    \\n    public boolean one() {\\n        return countOnes>=1;\\n    }\\n    \\n    public int count() {\\n        return countOnes;\\n    }\\n    \\n    public String toString() {\\n        return new String(vOnes);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n    int size;\\n    Set<Integer> set=new HashSet();\\n    boolean isOne=true;\\n    public Bitset(int size) {\\n        this.size=size;\\n    }\\n    \\n    public void fix(int idx) {\\n        if(isOne){\\n            set.add(idx);\\n        }else{\\n            set.remove(idx);\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(!isOne){\\n            set.add(idx);\\n        }else{\\n            set.remove(idx);\\n        }\\n    }\\n    \\n    public void flip() {\\n        isOne=!isOne;\\n    }\\n    \\n    public boolean all() {\\n        return count()==size;\\n    }\\n    \\n    public boolean one() {\\n        return count()>=1;\\n    }\\n    \\n    public int count() {\\n        if(isOne){\\n            return set.size();\\n        }else{\\n            return size-set.size();\\n        }\\n    }\\n    \\n    public String toString() {\\n        char v[]=new char[size];        \\n        if(isOne){\\n            Arrays.fill(v,\\'0\\');\\n            for(int n:set){\\n                v[n]=\\'1\\';\\n            }\\n        }else{\\n            Arrays.fill(v,\\'1\\');\\n            for(int n:set){\\n                v[n]=\\'0\\';\\n            }\\n        }\\n        return new String(v);\\n    }\\n}\\n```\n```\\nclass Bitset {\\n    char vOnes[];\\n    char vMirror[];\\n    int countOnes;\\n    int countMirror;\\n    public Bitset(int size) {\\n        vOnes=new char[size];\\n        vMirror=new char[size];\\n        Arrays.fill(vOnes,\\'0\\');\\n        Arrays.fill(vMirror,\\'1\\');\\n        countOnes=0;\\n        countMirror=size;\\n    }\\n    \\n    public void fix(int idx) {\\n        if(vOnes[idx]==\\'0\\'){\\n            countOnes++;\\n            countMirror--;\\n        }\\n        vOnes[idx]=\\'1\\';\\n        vMirror[idx]=\\'0\\';\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(vOnes[idx]==\\'1\\'){\\n            countOnes--;\\n            countMirror++;\\n        }\\n        vOnes[idx]=\\'0\\';\\n        vMirror[idx]=\\'1\\';\\n    }\\n    \\n    public void flip() {\\n        char v[]=vOnes;\\n        vOnes=vMirror;\\n        vMirror=v;\\n        int t=countOnes;\\n        countOnes=countMirror;\\n        countMirror=t;\\n    }\\n    \\n    public boolean all() {\\n        return countOnes==vOnes.length;\\n    }\\n    \\n    public boolean one() {\\n        return countOnes>=1;\\n    }\\n    \\n    public int count() {\\n        return countOnes;\\n    }\\n    \\n    public String toString() {\\n        return new String(vOnes);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921358,
                "title": "o-1-space-and-time-python-bitwise-operator-solution",
                "content": "Key here is to record number of ones as you filp, fix, and unfix to avoid O(n) counting\\n\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.data = 0\\n        self.size = size\\n        self.full = (1 << (size)) - 1\\n        self.ones_cnt = 0\\n    \\n    def __isone__(self,idx):\\n        lidx = self.size - idx - 1\\n        return self.data & (1 << (lidx)) > 0\\n\\n    def fix(self, idx: int) -> None:\\n        if not self.__isone__(idx):\\n            self.ones_cnt += 1\\n            lidx = self.size - idx - 1\\n            self.data |= (1 << (lidx))\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.__isone__(idx):\\n            self.ones_cnt -= 1\\n            lidx = self.size - idx - 1\\n            self.data &= self.full ^ (1 << lidx)\\n\\n    def flip(self) -> None:\\n        self.data ^= self.full\\n        self.ones_cnt = self.size - self.ones_cnt\\n        \\n\\n    def all(self) -> bool:\\n        return self.data == self.full\\n    \\n    def one(self) -> bool:\\n        return self.data > 0\\n\\n    def count(self) -> int:\\n        return self.ones_cnt\\n        \\n\\n    def toString(self) -> str:\\n        return \"{0:b}\".format(self.data).rjust(self.size,\\'0\\')\\n        \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.data = 0\\n        self.size = size\\n        self.full = (1 << (size)) - 1\\n        self.ones_cnt = 0\\n    \\n    def __isone__(self,idx):\\n        lidx = self.size - idx - 1\\n        return self.data & (1 << (lidx)) > 0\\n\\n    def fix(self, idx: int) -> None:\\n        if not self.__isone__(idx):\\n            self.ones_cnt += 1\\n            lidx = self.size - idx - 1\\n            self.data |= (1 << (lidx))\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.__isone__(idx):\\n            self.ones_cnt -= 1\\n            lidx = self.size - idx - 1\\n            self.data &= self.full ^ (1 << lidx)\\n\\n    def flip(self) -> None:\\n        self.data ^= self.full\\n        self.ones_cnt = self.size - self.ones_cnt\\n        \\n\\n    def all(self) -> bool:\\n        return self.data == self.full\\n    \\n    def one(self) -> bool:\\n        return self.data > 0\\n\\n    def count(self) -> int:\\n        return self.ones_cnt\\n        \\n\\n    def toString(self) -> str:\\n        return \"{0:b}\".format(self.data).rjust(self.size,\\'0\\')\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907588,
                "title": "python3-two-list-simple",
                "content": "Runtime: 847 ms, faster than 86.58% of Python3 online submissions for Design Bitset.\\nMemory Usage: 46.4 MB, less than 29.58% of Python3 online submissions for Design Bitset.\\n\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bitset = [0] * size\\n        self.flipp = [1] * size\\n        self.cnt_1 = 0\\n        \\n\\n    def fix(self, idx: int) -> None:\\n        if self.bitset[idx] != 1:\\n            self.bitset[idx] = 1\\n            self.flipp[idx] = 0\\n            self.cnt_1 += 1\\n \\n    def unfix(self, idx: int) -> None:\\n        if self.bitset[idx] != 0:\\n            self.bitset[idx] = 0\\n            self.flipp[idx] = 1\\n            self.cnt_1 -= 1\\n\\n    def flip(self) -> None:\\n        self.bitset, self.flipp = self.flipp, self.bitset\\n        self.cnt_1 = len(self.bitset) - self.cnt_1\\n\\n    def all(self) -> bool:\\n        return self.cnt_1 == len(self.bitset)\\n\\n    def one(self) -> bool:\\n        return self.cnt_1 > 0\\n\\n    def count(self) -> int:\\n        return self.cnt_1\\n\\n    def toString(self) -> str:\\n        return \"\".join(map(str, self.bitset))\\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bitset = [0] * size\\n        self.flipp = [1] * size\\n        self.cnt_1 = 0\\n        \\n\\n    def fix(self, idx: int) -> None:\\n        if self.bitset[idx] != 1:\\n            self.bitset[idx] = 1\\n            self.flipp[idx] = 0\\n            self.cnt_1 += 1\\n \\n    def unfix(self, idx: int) -> None:\\n        if self.bitset[idx] != 0:\\n            self.bitset[idx] = 0\\n            self.flipp[idx] = 1\\n            self.cnt_1 -= 1\\n\\n    def flip(self) -> None:\\n        self.bitset, self.flipp = self.flipp, self.bitset\\n        self.cnt_1 = len(self.bitset) - self.cnt_1\\n\\n    def all(self) -> bool:\\n        return self.cnt_1 == len(self.bitset)\\n\\n    def one(self) -> bool:\\n        return self.cnt_1 > 0\\n\\n    def count(self) -> int:\\n        return self.cnt_1\\n\\n    def toString(self) -> str:\\n        return \"\".join(map(str, self.bitset))\\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901981,
                "title": "python3-flipped-version",
                "content": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        # original array of bitset\\n        self.bitset = [0] * size\\n        # similar array but in flipped version\\n        self.flip_set = [1] * size\\n        self.bit_count = 0\\n\\n    def fix(self, idx: int) -> None:\\n        # also update the flip array in O(1) time\\n        if not self.bitset[idx]:\\n            self.bitset[idx] = 1\\n            self.flip_set[idx] = 0\\n            self.bit_count += 1\\n\\n    def unfix(self, idx: int) -> None:\\n        # also update the flip array in O(1) time\\n        if self.bitset[idx]:\\n            self.bitset[idx] = 0\\n            self.flip_set[idx] = 1\\n            self.bit_count -= 1\\n\\n    def flip(self) -> None:\\n        # just exchage the array in O(1) operation\\n        self.bitset, self.flip_set = self.flip_set, self.bitset\\n        # also calculate the bit count for flipped version\\n        self.bit_count = len(self.bitset) - self.bit_count\\n\\n    def all(self) -> bool:\\n        return self.bit_count == len(self.bitset)\\n\\n    def one(self) -> bool:\\n        return self.bit_count > 0\\n\\n    def count(self) -> int:\\n        return self.bit_count\\n\\n    def toString(self) -> str:\\n        return \\'\\'.join(str(each) for each in self.bitset)\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        # original array of bitset\\n        self.bitset = [0] * size\\n        # similar array but in flipped version\\n        self.flip_set = [1] * size\\n        self.bit_count = 0\\n\\n    def fix(self, idx: int) -> None:\\n        # also update the flip array in O(1) time\\n        if not self.bitset[idx]:\\n            self.bitset[idx] = 1\\n            self.flip_set[idx] = 0\\n            self.bit_count += 1\\n\\n    def unfix(self, idx: int) -> None:\\n        # also update the flip array in O(1) time\\n        if self.bitset[idx]:\\n            self.bitset[idx] = 0\\n            self.flip_set[idx] = 1\\n            self.bit_count -= 1\\n\\n    def flip(self) -> None:\\n        # just exchage the array in O(1) operation\\n        self.bitset, self.flip_set = self.flip_set, self.bitset\\n        # also calculate the bit count for flipped version\\n        self.bit_count = len(self.bitset) - self.bit_count\\n\\n    def all(self) -> bool:\\n        return self.bit_count == len(self.bitset)\\n\\n    def one(self) -> bool:\\n        return self.bit_count > 0\\n\\n    def count(self) -> int:\\n        return self.bit_count\\n\\n    def toString(self) -> str:\\n        return \\'\\'.join(str(each) for each in self.bitset)\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850311,
                "title": "java-using-only-array-all-o-1-except-for-tostring",
                "content": "```\\nclass Bitset {\\n    \\n    int size = 0;\\n    int[] arr;\\n    int count = 0;\\n    boolean flip = false;\\n    \\n    public Bitset(int size) {\\n        this.size = size;\\n        int[] arr = new int[this.size];\\n        this.arr = arr;\\n    }\\n    \\n    public void fix(int idx) {\\n        if(this.flip){\\n            if(this.arr[idx] == 1){this.arr[idx] = 0; this.count ++;}\\n        }else{\\n            if(this.arr[idx] == 0){this.arr[idx] = 1; this.count ++;}\\n        }\\n        \\n        \\n    }\\n    \\n    public void unfix(int idx) {\\n        if(this.flip){\\n            if(this.arr[idx] == 0){this.arr[idx] = 1; this.count --;}\\n        }else{\\n            if(this.arr[idx] == 1){this.arr[idx] = 0; this.count --;}\\n        }\\n        \\n    }\\n    \\n    public void flip() {\\n        this.flip = ! this.flip;\\n        this.count = this.arr.length - this.count;\\n    }\\n    \\n    public boolean all() {\\n        if(this.count == this.arr.length){return true;}\\n        return false;\\n    }\\n    \\n    public boolean one() {\\n        if(this.count != 0){return true;}\\n        return false;\\n    }\\n    \\n    public int count() {\\n\\n        return this.count;\\n    }\\n    \\n    public String toString() {\\n        StringBuffer sb = new StringBuffer();\\n        for(int i : this.arr){\\n            if(i == 1 && this.flip){sb.append(\\'0\\');}\\n            else if(i == 1 && ! this.flip){sb.append(\\'1\\');}\\n            else if(i == 0 && ! this.flip){sb.append(\\'0\\');}\\n            else{sb.append(\\'1\\');}\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n    \\n    int size = 0;\\n    int[] arr;\\n    int count = 0;\\n    boolean flip = false;\\n    \\n    public Bitset(int size) {\\n        this.size = size;\\n        int[] arr = new int[this.size];\\n        this.arr = arr;\\n    }\\n    \\n    public void fix(int idx) {\\n        if(this.flip){\\n            if(this.arr[idx] == 1){this.arr[idx] = 0; this.count ++;}\\n        }else{\\n            if(this.arr[idx] == 0){this.arr[idx] = 1; this.count ++;}\\n        }\\n        \\n        \\n    }\\n    \\n    public void unfix(int idx) {\\n        if(this.flip){\\n            if(this.arr[idx] == 0){this.arr[idx] = 1; this.count --;}\\n        }else{\\n            if(this.arr[idx] == 1){this.arr[idx] = 0; this.count --;}\\n        }\\n        \\n    }\\n    \\n    public void flip() {\\n        this.flip = ! this.flip;\\n        this.count = this.arr.length - this.count;\\n    }\\n    \\n    public boolean all() {\\n        if(this.count == this.arr.length){return true;}\\n        return false;\\n    }\\n    \\n    public boolean one() {\\n        if(this.count != 0){return true;}\\n        return false;\\n    }\\n    \\n    public int count() {\\n\\n        return this.count;\\n    }\\n    \\n    public String toString() {\\n        StringBuffer sb = new StringBuffer();\\n        for(int i : this.arr){\\n            if(i == 1 && this.flip){sb.append(\\'0\\');}\\n            else if(i == 1 && ! this.flip){sb.append(\\'1\\');}\\n            else if(i == 0 && ! this.flip){sb.append(\\'0\\');}\\n            else{sb.append(\\'1\\');}\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842889,
                "title": "c-all-operations-o-1-solution",
                "content": "```\\nclass Bitset {\\nprivate:\\n    string str, revStr ;\\n    int cnt, revCnt;\\npublic:\\n    Bitset(int size) {\\n        str.resize(size, \\'0\\');\\n        revStr.resize(size, \\'1\\');\\n        cnt = 0;\\n        revCnt = size;\\n    }\\n    \\n    void fix(int idx) {\\n        if(str[idx] == \\'0\\'){\\n            str[idx] = \\'1\\';\\n            cnt++;\\n         \\n        }\\n        \\n        if(revStr[idx] == \\'1\\'){\\n            revStr[idx] = \\'0\\';\\n            revCnt--;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(str[idx] == \\'1\\'){\\n            str[idx] = \\'0\\';\\n            cnt--;\\n        }\\n        \\n        if(revStr[idx] == \\'0\\'){\\n            revStr[idx] = \\'1\\';\\n            revCnt++;\\n        }\\n    }\\n    \\n    void flip() {\\n       swap(revStr, str);\\n        swap(cnt , revCnt);\\n    }\\n    \\n    bool all() {\\n        return cnt == str.size();\\n        \\n    }\\n    \\n    bool one() {\\n        return cnt > 0;\\n        \\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Bitset {\\nprivate:\\n    string str, revStr ;\\n    int cnt, revCnt;\\npublic:\\n    Bitset(int size) {\\n        str.resize(size, \\'0\\');\\n        revStr.resize(size, \\'1\\');\\n        cnt = 0;\\n        revCnt = size;\\n    }\\n    \\n    void fix(int idx) {\\n        if(str[idx] == \\'0\\'){\\n            str[idx] = \\'1\\';\\n            cnt++;\\n         \\n        }\\n        \\n        if(revStr[idx] == \\'1\\'){\\n            revStr[idx] = \\'0\\';\\n            revCnt--;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(str[idx] == \\'1\\'){\\n            str[idx] = \\'0\\';\\n            cnt--;\\n        }\\n        \\n        if(revStr[idx] == \\'0\\'){\\n            revStr[idx] = \\'1\\';\\n            revCnt++;\\n        }\\n    }\\n    \\n    void flip() {\\n       swap(revStr, str);\\n        swap(cnt , revCnt);\\n    }\\n    \\n    bool all() {\\n        return cnt == str.size();\\n        \\n    }\\n    \\n    bool one() {\\n        return cnt > 0;\\n        \\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842086,
                "title": "pyhton3-solution",
                "content": "class Bitset:\\n\\n    def __init__(self, size: int):\\n        self.onec=set()\\n        self.zero=set([i for i in range(size)])\\n        self.size=size\\n\\n    def fix(self, idx: int) -> None:\\n        if idx in self.onec:\\n            return\\n        else:\\n            self.zero.remove(idx)\\n            self.onec.add(idx)\\n\\n    def unfix(self, idx: int) -> None:\\n        if idx in self.zero:\\n            return\\n        else:\\n            self.onec.remove(idx)\\n            self.zero.add(idx)\\n\\n    def flip(self) -> None:\\n        self.zero,self.onec=self.onec,self.zero\\n\\n    def all(self) -> bool:\\n        return len(self.onec)==self.size\\n\\n    def one(self) -> bool:\\n        return len(self.onec)>0\\n\\n    def count(self) -> int:\\n        return len(self.onec)\\n\\n    def toString(self) -> str:\\n        res=\"\"\\n        for i in range(self.size):\\n            if i in self.zero:\\n                res+=\\'0\\'\\n            else:\\n                res+=\\'1\\'\\n        return res\\n\\n",
                "solutionTags": [],
                "code": "class Bitset:\\n\\n    def __init__(self, size: int):\\n        self.onec=set()\\n        self.zero=set([i for i in range(size)])\\n        self.size=size\\n\\n    def fix(self, idx: int) -> None:\\n        if idx in self.onec:\\n            return\\n        else:\\n            self.zero.remove(idx)\\n            self.onec.add(idx)\\n\\n    def unfix(self, idx: int) -> None:\\n        if idx in self.zero:\\n            return\\n        else:\\n            self.onec.remove(idx)\\n            self.zero.add(idx)\\n\\n    def flip(self) -> None:\\n        self.zero,self.onec=self.onec,self.zero\\n\\n    def all(self) -> bool:\\n        return len(self.onec)==self.size\\n\\n    def one(self) -> bool:\\n        return len(self.onec)>0\\n\\n    def count(self) -> int:\\n        return len(self.onec)\\n\\n    def toString(self) -> str:\\n        res=\"\"\\n        for i in range(self.size):\\n            if i in self.zero:\\n                res+=\\'0\\'\\n            else:\\n                res+=\\'1\\'\\n        return res\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1832022,
                "title": "typescript-easy-and-fast-o-1",
                "content": "```\\nclass Bitset {\\n  private size = 0;\\n  private bits: number[] = [];\\n  private bitsFlipped: number[] = [];\\n  private counts = {\\n    zeroes: 0,\\n    ones: 0,\\n  };\\n\\n  constructor(size: number) {\\n    this.bits = new Array(size).fill(0);\\n    this.bitsFlipped = new Array(size).fill(1);\\n    this.size = size;\\n    this.counts.zeroes = size;\\n  }\\n\\n  public fix(idx: number): void {\\n    if (idx > this.size - 1) {\\n      return;\\n    }\\n\\n    if (this.bits[idx] === 0) {\\n      this.counts.zeroes--;\\n      this.counts.ones++;\\n      this.bits[idx] = 1;\\n\\n      this.bitsFlipped[idx] = 0;\\n    }\\n  }\\n\\n  public unfix(idx: number): void {\\n    if (idx > this.size - 1) {\\n      return;\\n    }\\n\\n    if (this.bits[idx] === 1) {\\n      this.counts.zeroes++;\\n      this.counts.ones--;\\n      this.bits[idx] = 0;\\n\\n      this.bitsFlipped[idx] = 1;\\n    }\\n  }\\n\\n  public flip(): void {\\n    [this.counts.ones, this.counts.zeroes] = [this.counts.zeroes, this.counts.ones];\\n    [this.bits, this.bitsFlipped] = [this.bitsFlipped, this.bits];\\n  }\\n\\n  public all(): boolean {\\n    return this.counts.ones === this.size;\\n  }\\n\\n  public one(): boolean {\\n    return this.counts.ones >= 1;\\n  }\\n\\n  public count(): number {\\n    return this.counts.ones;\\n  }\\n\\n  public toString(): string {\\n    return this.bits.join(\"\");\\n  }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass Bitset {\\n  private size = 0;\\n  private bits: number[] = [];\\n  private bitsFlipped: number[] = [];\\n  private counts = {\\n    zeroes: 0,\\n    ones: 0,\\n  };\\n\\n  constructor(size: number) {\\n    this.bits = new Array(size).fill(0);\\n    this.bitsFlipped = new Array(size).fill(1);\\n    this.size = size;\\n    this.counts.zeroes = size;\\n  }\\n\\n  public fix(idx: number): void {\\n    if (idx > this.size - 1) {\\n      return;\\n    }\\n\\n    if (this.bits[idx] === 0) {\\n      this.counts.zeroes--;\\n      this.counts.ones++;\\n      this.bits[idx] = 1;\\n\\n      this.bitsFlipped[idx] = 0;\\n    }\\n  }\\n\\n  public unfix(idx: number): void {\\n    if (idx > this.size - 1) {\\n      return;\\n    }\\n\\n    if (this.bits[idx] === 1) {\\n      this.counts.zeroes++;\\n      this.counts.ones--;\\n      this.bits[idx] = 0;\\n\\n      this.bitsFlipped[idx] = 1;\\n    }\\n  }\\n\\n  public flip(): void {\\n    [this.counts.ones, this.counts.zeroes] = [this.counts.zeroes, this.counts.ones];\\n    [this.bits, this.bitsFlipped] = [this.bitsFlipped, this.bits];\\n  }\\n\\n  public all(): boolean {\\n    return this.counts.ones === this.size;\\n  }\\n\\n  public one(): boolean {\\n    return this.counts.ones >= 1;\\n  }\\n\\n  public count(): number {\\n    return this.counts.ones;\\n  }\\n\\n  public toString(): string {\\n    return this.bits.join(\"\");\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815335,
                "title": "java-clean-solution-all-operation-except-to-string-o-1-space-o-n",
                "content": "```\\nclass Bitset {\\n    boolean []bits;\\n    boolean isTrue = false;\\n    int size;\\n    int trueCnt = 0;\\n    boolean setValue = true;\\n    \\n    public Bitset(int size) {\\n        this.size = size;\\n        bits = new boolean[size];\\n    }\\n    \\n    public void fix(int idx) {\\n        if(bits[idx] != setValue) {\\n            trueCnt++;\\n        }\\n        bits[idx] = setValue;\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(bits[idx] == setValue) {\\n            trueCnt--;\\n        }\\n        bits[idx] = !setValue;\\n    }\\n    \\n    public void flip() {\\n        setValue ^= true;\\n        trueCnt = size - trueCnt;\\n    }\\n    \\n    public boolean all() {\\n        return (trueCnt == size);\\n    }\\n    \\n    public boolean one() {\\n        return (trueCnt  != 0);\\n    }\\n    \\n    public int count() {\\n        return trueCnt;\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < size; i++) {\\n            if(!setValue)\\n                sb.append(((bits[i]) ? \"0\" : \"1\"));\\n            else\\n                sb.append(((bits[i]) ? \"1\" : \"0\"));\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Bitset {\\n    boolean []bits;\\n    boolean isTrue = false;\\n    int size;\\n    int trueCnt = 0;\\n    boolean setValue = true;\\n    \\n    public Bitset(int size) {\\n        this.size = size;\\n        bits = new boolean[size];\\n    }\\n    \\n    public void fix(int idx) {\\n        if(bits[idx] != setValue) {\\n            trueCnt++;\\n        }\\n        bits[idx] = setValue;\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(bits[idx] == setValue) {\\n            trueCnt--;\\n        }\\n        bits[idx] = !setValue;\\n    }\\n    \\n    public void flip() {\\n        setValue ^= true;\\n        trueCnt = size - trueCnt;\\n    }\\n    \\n    public boolean all() {\\n        return (trueCnt == size);\\n    }\\n    \\n    public boolean one() {\\n        return (trueCnt  != 0);\\n    }\\n    \\n    public int count() {\\n        return trueCnt;\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < size; i++) {\\n            if(!setValue)\\n                sb.append(((bits[i]) ? \"0\" : \"1\"));\\n            else\\n                sb.append(((bits[i]) ? \"1\" : \"0\"));\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804732,
                "title": "c-time-o-1-all-solution-with-detailed-explanation",
                "content": "// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n```\\nclass Bitset {\\npublic:\\n    int countOf1=0; //This Will store the actual no of one\\'s...\\n    vector<int>bitset;\\n    bool Flip=false; // false means 0 is 0 and  1 is 1\\n    Bitset(int size) {\\n        bitset.resize(size,0);        \\n    }\\n    \\n    // convert to 1 \\n    void fix(int idx) {\\n        if(Flip==false){ // 0 is 0 and 1 is 1\\n            if(bitset[idx]==0){\\n                ++countOf1;\\n                bitset[idx]=1;\\n            }\\n        }\\n        else{ // 0 is 1 and 1 is 0\\n            if(bitset[idx]==1){\\n                ++countOf1;\\n                bitset[idx]=0; // since flag is true therefore 0 means 1.\\n            }\\n        }\\n        \\n    }\\n    \\n    // convert ot 0\\n    void unfix(int idx) {\\n         if(Flip==false){ // 0 is 0 and 1 is 1\\n            if(bitset[idx]==1){\\n                --countOf1;\\n                bitset[idx]=0;\\n            }\\n        }\\n        else{\\n            if(bitset[idx]==0){\\n                --countOf1;\\n                bitset[idx]=1; // since flag is true therefore 0 means 1.\\n            }\\n        }\\n        \\n    }\\n    \\n    void flip() {\\n        Flip=!Flip;\\n        countOf1=bitset.size()-countOf1;\\n        \\n    }\\n    \\n    bool all() {\\n        return countOf1==bitset.size();\\n        \\n    }\\n    \\n    bool one() {\\n        return countOf1>0;\\n    }\\n    \\n    int count() {\\n        return countOf1;\\n    }\\n    \\n    string toString() {\\n        string ans=\"\";\\n        if(Flip==false)\\n        for(auto x:bitset){\\n            ans+=x==0?\\'0\\':\\'1\\';            \\n        }\\n        else{\\n            for(auto x:bitset){\\n            ans+=x==0?\\'1\\':\\'0\\';            \\n        }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    int countOf1=0; //This Will store the actual no of one\\'s...\\n    vector<int>bitset;\\n    bool Flip=false; // false means 0 is 0 and  1 is 1\\n    Bitset(int size) {\\n        bitset.resize(size,0);        \\n    }\\n    \\n    // convert to 1 \\n    void fix(int idx) {\\n        if(Flip==false){ // 0 is 0 and 1 is 1\\n            if(bitset[idx]==0){\\n                ++countOf1;\\n                bitset[idx]=1;\\n            }\\n        }\\n        else{ // 0 is 1 and 1 is 0\\n            if(bitset[idx]==1){\\n                ++countOf1;\\n                bitset[idx]=0; // since flag is true therefore 0 means 1.\\n            }\\n        }\\n        \\n    }\\n    \\n    // convert ot 0\\n    void unfix(int idx) {\\n         if(Flip==false){ // 0 is 0 and 1 is 1\\n            if(bitset[idx]==1){\\n                --countOf1;\\n                bitset[idx]=0;\\n            }\\n        }\\n        else{\\n            if(bitset[idx]==0){\\n                --countOf1;\\n                bitset[idx]=1; // since flag is true therefore 0 means 1.\\n            }\\n        }\\n        \\n    }\\n    \\n    void flip() {\\n        Flip=!Flip;\\n        countOf1=bitset.size()-countOf1;\\n        \\n    }\\n    \\n    bool all() {\\n        return countOf1==bitset.size();\\n        \\n    }\\n    \\n    bool one() {\\n        return countOf1>0;\\n    }\\n    \\n    int count() {\\n        return countOf1;\\n    }\\n    \\n    string toString() {\\n        string ans=\"\";\\n        if(Flip==false)\\n        for(auto x:bitset){\\n            ans+=x==0?\\'0\\':\\'1\\';            \\n        }\\n        else{\\n            for(auto x:bitset){\\n            ans+=x==0?\\'1\\':\\'0\\';            \\n        }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761049,
                "title": "c-zeroes-ones-simple-flip",
                "content": "using two variables for storing zeroes and ones \\nexcept tostring() all functions with constant time \\n```\\nclass Bitset {\\n    string s;\\n    int ones,zers,isflip;\\npublic:\\n    Bitset(int size) {\\n        s = string(size,\\'0\\') ;\\n        //t = string(size,\\'0\\');\\n        zers = size; //all  zeroes\\n        ones = 0; //no ones\\n        isflip = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(isflip%2 == 0){\\n            if(s[idx]==\\'0\\'){\\n                s[idx] = \\'1\\';\\n                //t[idx] = \\'1\\';\\n                ones++;\\n                zers--;\\n            }\\n            \\n        }\\n        else{\\n            //isflip%2 != 0\\n            if(s[idx] == \\'1\\'){\\n                s[idx] = \\'0\\';\\n                ones++;\\n                zers--;\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    void unfix(int idx) {\\n        if(isflip%2 == 0){\\n            if(s[idx] == \\'1\\'){\\n                s[idx] = \\'0\\';\\n                //t[idx] = \\'0\\';\\n                zers++;\\n                ones--;\\n            }\\n            \\n        }\\n        else{\\n            if(s[idx] == \\'0\\'){\\n                s[idx] = \\'1\\';\\n                zers++;\\n                ones--;\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    void flip() {\\n        \\n        swap(ones,zers); //swapping zeroes and ones\\n        isflip++;\\n        \\n    }\\n    \\n    bool all() {\\n        return (ones == s.size());\\n        \\n    }\\n    \\n    bool one() {\\n        return (ones>0);\\n        \\n    }\\n    \\n    int count() {\\n        return ones;\\n        \\n    }\\n    \\n    string toString() {\\n        if(isflip%2 == 0) return s ;\\n        string temp = string(s.size(),\\'0\\') ;\\n        for(int j = 0;j<s.size();j++){\\n            if(s[j] == \\'0\\'){\\n                temp[j] = \\'1\\';\\n            }\\n            else{\\n                temp[j] = \\'0\\';\\n            }\\n        }\\n        return temp ;\\n\\t\\t/*\\n\\t\\tTime : O(N)\\n\\t\\t*/\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Bitset {\\n    string s;\\n    int ones,zers,isflip;\\npublic:\\n    Bitset(int size) {\\n        s = string(size,\\'0\\') ;\\n        //t = string(size,\\'0\\');\\n        zers = size; //all  zeroes\\n        ones = 0; //no ones\\n        isflip = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(isflip%2 == 0){\\n            if(s[idx]==\\'0\\'){\\n                s[idx] = \\'1\\';\\n                //t[idx] = \\'1\\';\\n                ones++;\\n                zers--;\\n            }\\n            \\n        }\\n        else{\\n            //isflip%2 != 0\\n            if(s[idx] == \\'1\\'){\\n                s[idx] = \\'0\\';\\n                ones++;\\n                zers--;\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    void unfix(int idx) {\\n        if(isflip%2 == 0){\\n            if(s[idx] == \\'1\\'){\\n                s[idx] = \\'0\\';\\n                //t[idx] = \\'0\\';\\n                zers++;\\n                ones--;\\n            }\\n            \\n        }\\n        else{\\n            if(s[idx] == \\'0\\'){\\n                s[idx] = \\'1\\';\\n                zers++;\\n                ones--;\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    void flip() {\\n        \\n        swap(ones,zers); //swapping zeroes and ones\\n        isflip++;\\n        \\n    }\\n    \\n    bool all() {\\n        return (ones == s.size());\\n        \\n    }\\n    \\n    bool one() {\\n        return (ones>0);\\n        \\n    }\\n    \\n    int count() {\\n        return ones;\\n        \\n    }\\n    \\n    string toString() {\\n        if(isflip%2 == 0) return s ;\\n        string temp = string(s.size(),\\'0\\') ;\\n        for(int j = 0;j<s.size();j++){\\n            if(s[j] == \\'0\\'){\\n                temp[j] = \\'1\\';\\n            }\\n            else{\\n                temp[j] = \\'0\\';\\n            }\\n        }\\n        return temp ;\\n\\t\\t/*\\n\\t\\tTime : O(N)\\n\\t\\t*/\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760119,
                "title": "java-tostring-o-n-all-other-operations-o-1",
                "content": "```java\\nclass Bitset {\\n    boolean[] bits;\\n    boolean flipActive = false;\\n    int zeroCount;\\n    \\n    public Bitset(int size) {\\n        bits = new boolean[size];\\n        zeroCount = size;\\n    }\\n    \\n\\t// Get value of bit considering flip \\n    private boolean isSet(int idx) {\\n        return flipActive ? !bits[idx] : bits[idx];\\n    }\\n    \\n    public void fix(int idx) {\\n        if (!isSet(idx)) {\\n            bits[idx] = !bits[idx];\\n            zeroCount--;\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if (isSet(idx)) {\\n            bits[idx] = !bits[idx];\\n            zeroCount++;\\n        }\\n    }\\n    \\n    public void flip() {\\n        flipActive = !flipActive;\\n        zeroCount = bits.length - zeroCount;\\n    }\\n    \\n    public boolean all() {\\n        return zeroCount == 0;\\n    }\\n    \\n    public boolean one() {\\n        return zeroCount != bits.length;\\n    }\\n    \\n    public int count() {\\n        return bits.length - zeroCount;\\n    }\\n    \\n    public String toString() {\\n        var str = new char[bits.length];\\n        for (int i=0; i<bits.length; i++) {\\n            str[i] = isSet(i) ? \\'1\\' : \\'0\\';\\n        }\\n        return new String(str);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Bitset {\\n    boolean[] bits;\\n    boolean flipActive = false;\\n    int zeroCount;\\n    \\n    public Bitset(int size) {\\n        bits = new boolean[size];\\n        zeroCount = size;\\n    }\\n    \\n\\t// Get value of bit considering flip \\n    private boolean isSet(int idx) {\\n        return flipActive ? !bits[idx] : bits[idx];\\n    }\\n    \\n    public void fix(int idx) {\\n        if (!isSet(idx)) {\\n            bits[idx] = !bits[idx];\\n            zeroCount--;\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if (isSet(idx)) {\\n            bits[idx] = !bits[idx];\\n            zeroCount++;\\n        }\\n    }\\n    \\n    public void flip() {\\n        flipActive = !flipActive;\\n        zeroCount = bits.length - zeroCount;\\n    }\\n    \\n    public boolean all() {\\n        return zeroCount == 0;\\n    }\\n    \\n    public boolean one() {\\n        return zeroCount != bits.length;\\n    }\\n    \\n    public int count() {\\n        return bits.length - zeroCount;\\n    }\\n    \\n    public String toString() {\\n        var str = new char[bits.length];\\n        for (int i=0; i<bits.length; i++) {\\n            str[i] = isSet(i) ? \\'1\\' : \\'0\\';\\n        }\\n        return new String(str);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757579,
                "title": "o-n-for-tostring-o-1-for-other-operations",
                "content": "```\\nclass Bitset {\\n    int size;\\n    int[] set;\\n    int ones;\\n    boolean isFlip;\\n\\n    public Bitset(int size) {\\n        this.size = size;\\n        ones = 0;\\n        set = new int[size];\\n    }\\n    \\n    public void fix(int idx) {\\n        if(!isFlip && set[idx] == 0) {\\n            ones++;\\n            set[idx] = 1;\\n        } else if(isFlip && set[idx] == 1) {\\n            ones++;\\n            set[idx] = 0;\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(!isFlip && set[idx] == 1) {\\n            ones--;\\n            set[idx] = 0;\\n        } else if(isFlip && set[idx] == 0) {\\n            ones--;\\n            set[idx] = 1;\\n        }\\n    }\\n    \\n    public void flip() {\\n        isFlip = !isFlip;\\n        ones = size - ones;\\n    }\\n    \\n    public boolean all() {\\n        return ones == size;\\n    }\\n    \\n    public boolean one() {\\n        return ones > 0;\\n    }\\n    \\n    public int count() {\\n        return ones;\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < size; i++) {\\n            sb.append(isFlip ? (set[i] ^ 1) : (set[i]));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n    int size;\\n    int[] set;\\n    int ones;\\n    boolean isFlip;\\n\\n    public Bitset(int size) {\\n        this.size = size;\\n        ones = 0;\\n        set = new int[size];\\n    }\\n    \\n    public void fix(int idx) {\\n        if(!isFlip && set[idx] == 0) {\\n            ones++;\\n            set[idx] = 1;\\n        } else if(isFlip && set[idx] == 1) {\\n            ones++;\\n            set[idx] = 0;\\n        }\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(!isFlip && set[idx] == 1) {\\n            ones--;\\n            set[idx] = 0;\\n        } else if(isFlip && set[idx] == 0) {\\n            ones--;\\n            set[idx] = 1;\\n        }\\n    }\\n    \\n    public void flip() {\\n        isFlip = !isFlip;\\n        ones = size - ones;\\n    }\\n    \\n    public boolean all() {\\n        return ones == size;\\n    }\\n    \\n    public boolean one() {\\n        return ones > 0;\\n    }\\n    \\n    public int count() {\\n        return ones;\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < size; i++) {\\n            sb.append(isFlip ? (set[i] ^ 1) : (set[i]));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756053,
                "title": "unordered-set-simple-easy-approach-easy-to-understand-c",
                "content": "Implementation\\n\\n**Using unordered set\\nTime Complexity = O(1) for all functions, except toString() -> (O(N))\\nSpace Complexity = O(N)**\\n\\n```\\nclass Bitset {\\npublic:\\n    int size;\\n    unordered_set<int> onee, zero;\\n    \\n    Bitset(int size) {\\n        this->size = size;        \\n        for(int itr = 0; itr < size; itr++) zero.insert(itr); \\n    }\\n    \\n    void fix(int idx) {\\n        onee.insert(idx);\\n        zero.erase(idx);\\n    }\\n    \\n    void unfix(int idx) {\\n        onee.erase(idx);\\n        zero.insert(idx);\\n    }\\n    \\n    void flip() {\\n        swap(onee, zero);\\n    }\\n    \\n    bool all() {\\n        return (onee.size() == size);\\n    }\\n    \\n    bool one() {\\n        return (onee.size() >= 1);\\n    }\\n    \\n    int count() {\\n        return onee.size();\\n    }\\n    \\n    string toString() {\\n        string str = \"\";        \\n        for(int itr = 0; itr < size; itr++){\\n            str += (onee.find(itr) != onee.end()) ? \\'1\\' : \\'0\\';\\n        }\\n        return str;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    int size;\\n    unordered_set<int> onee, zero;\\n    \\n    Bitset(int size) {\\n        this->size = size;        \\n        for(int itr = 0; itr < size; itr++) zero.insert(itr); \\n    }\\n    \\n    void fix(int idx) {\\n        onee.insert(idx);\\n        zero.erase(idx);\\n    }\\n    \\n    void unfix(int idx) {\\n        onee.erase(idx);\\n        zero.insert(idx);\\n    }\\n    \\n    void flip() {\\n        swap(onee, zero);\\n    }\\n    \\n    bool all() {\\n        return (onee.size() == size);\\n    }\\n    \\n    bool one() {\\n        return (onee.size() >= 1);\\n    }\\n    \\n    int count() {\\n        return onee.size();\\n    }\\n    \\n    string toString() {\\n        string str = \"\";        \\n        for(int itr = 0; itr < size; itr++){\\n            str += (onee.find(itr) != onee.end()) ? \\'1\\' : \\'0\\';\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756030,
                "title": "using-string-o-1-except-tostring-xor-different-logic",
                "content": "Mostly self-explanatory code\\nI\\'ve used xor for flip bit\\n\\n**s[i]  ^  flip-flag  = x**\\n```\\n0\\t 0       0   --> enters fix\\n0\\t 1       1   --> enters unfix\\n1\\t 0       1   --> enters unfix\\n1\\t 1       0   --> enters fix\\n```\\n\\n```\\nclass Bitset {\\npublic:\\n    \\n    string s;\\n    int o,f;\\n    \\n    Bitset(int size) {\\n        while(size--)s+=\\'0\\';\\n        o=0;f=0;\\n    }\\n    \\n    void fix(int i) {\\n        int x=(s[i]-\\'0\\')^f;\\n        if(!x)\\n        {\\n            o++;s[i]=(s[i]==\\'1\\')?\\'0\\':\\'1\\';\\n            // cout<<o<<\" fx \"<<s<<\" \\\\n\";\\n        }\\n    }\\n    \\n    void unfix(int i) {\\n        int x=(s[i]-\\'0\\')^f;\\n        if(x)\\n        {\\n            o--;s[i]=(s[i]==\\'1\\')?\\'0\\':\\'1\\';\\n            // cout<<o<<\" un \"<<s<<\" \\\\n\";\\n        }   \\n    }\\n    \\n    void flip() {\\n        f^=1;o=s.size()-o;\\n        // cout<<o<<\" fl \"<<s<<\" \\\\n\";\\n    }\\n    \\n    bool all() {\\n        return o==s.size();\\n    }\\n    \\n    bool one() {\\n        return o;\\n    }\\n    \\n    int count() {\\n        return o;\\n    }\\n    \\n    string toString() {\\n        if(f)\\n        {f=0;\\n            for(int i=0;i<s.size();i++)\\n            s[i]=(s[i]==\\'1\\')?\\'0\\':\\'1\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n0\\t 0       0   --> enters fix\\n0\\t 1       1   --> enters unfix\\n1\\t 0       1   --> enters unfix\\n1\\t 1       0   --> enters fix\\n```\n```\\nclass Bitset {\\npublic:\\n    \\n    string s;\\n    int o,f;\\n    \\n    Bitset(int size) {\\n        while(size--)s+=\\'0\\';\\n        o=0;f=0;\\n    }\\n    \\n    void fix(int i) {\\n        int x=(s[i]-\\'0\\')^f;\\n        if(!x)\\n        {\\n            o++;s[i]=(s[i]==\\'1\\')?\\'0\\':\\'1\\';\\n            // cout<<o<<\" fx \"<<s<<\" \\\\n\";\\n        }\\n    }\\n    \\n    void unfix(int i) {\\n        int x=(s[i]-\\'0\\')^f;\\n        if(x)\\n        {\\n            o--;s[i]=(s[i]==\\'1\\')?\\'0\\':\\'1\\';\\n            // cout<<o<<\" un \"<<s<<\" \\\\n\";\\n        }   \\n    }\\n    \\n    void flip() {\\n        f^=1;o=s.size()-o;\\n        // cout<<o<<\" fl \"<<s<<\" \\\\n\";\\n    }\\n    \\n    bool all() {\\n        return o==s.size();\\n    }\\n    \\n    bool one() {\\n        return o;\\n    }\\n    \\n    int count() {\\n        return o;\\n    }\\n    \\n    string toString() {\\n        if(f)\\n        {f=0;\\n            for(int i=0;i<s.size();i++)\\n            s[i]=(s[i]==\\'1\\')?\\'0\\':\\'1\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1753235,
                "title": "swift-solution",
                "content": "```\\n\\nclass Bitset {\\n    var bitset = [Int]()\\n    var counter = 0\\n    var flips = false\\n    \\n    init(_ size: Int) {\\n        bitset = Array(repeating: 0, count: size)\\n        counter = 0\\n        flips = false\\n    }\\n    \\n    func fix(_ idx: Int) {\\n       if !flips {\\n           if bitset[idx] == 0 {\\n               bitset[idx] = 1\\n               counter += 1\\n           }\\n       } else {\\n          if bitset[idx] == 1 {\\n             counter += 1 \\n             bitset[idx] = 0\\n          } \\n       }\\n    }\\n    \\n    func unfix(_ idx: Int) {\\n       if !flips {\\n           if bitset[idx] == 1 {\\n               bitset[idx] = 0\\n               counter -= 1\\n           }\\n       } else {\\n          if bitset[idx] == 0 {\\n             bitset[idx] = 1\\n             counter -= 1  \\n          } \\n       }\\n    }\\n    \\n    func flip() {\\n        flips = !flips\\n        counter = bitset.count - counter\\n    }\\n    \\n    func all() -> Bool {\\n       return counter == bitset.count\\n    }\\n    \\n    func one() -> Bool {\\n        return counter >= 1\\n    }\\n    \\n    func count() -> Int {\\n        return counter\\n    }\\n    \\n    func toString() -> String {\\n        var ans = \"\"\\n        if !flips {\\n            for i in 0..<bitset.count {\\n                ans += \"\\\\(bitset[i])\" ?? \"\"\\n            }\\n        } else {\\n             for i in 0..<bitset.count {\\n                 if bitset[i] == 0{\\n                    ans += \"1\"\\n                 } else {\\n                    ans += \"0\" \\n                 }\\n            }\\n        }\\n        return ans\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\n\\nclass Bitset {\\n    var bitset = [Int]()\\n    var counter = 0\\n    var flips = false\\n    \\n    init(_ size: Int) {\\n        bitset = Array(repeating: 0, count: size)\\n        counter = 0\\n        flips = false\\n    }\\n    \\n    func fix(_ idx: Int) {\\n       if !flips {\\n           if bitset[idx] == 0 {\\n               bitset[idx] = 1\\n               counter += 1\\n           }\\n       } else {\\n          if bitset[idx] == 1 {\\n             counter += 1 \\n             bitset[idx] = 0\\n          } \\n       }\\n    }\\n    \\n    func unfix(_ idx: Int) {\\n       if !flips {\\n           if bitset[idx] == 1 {\\n               bitset[idx] = 0\\n               counter -= 1\\n           }\\n       } else {\\n          if bitset[idx] == 0 {\\n             bitset[idx] = 1\\n             counter -= 1  \\n          } \\n       }\\n    }\\n    \\n    func flip() {\\n        flips = !flips\\n        counter = bitset.count - counter\\n    }\\n    \\n    func all() -> Bool {\\n       return counter == bitset.count\\n    }\\n    \\n    func one() -> Bool {\\n        return counter >= 1\\n    }\\n    \\n    func count() -> Int {\\n        return counter\\n    }\\n    \\n    func toString() -> String {\\n        var ans = \"\"\\n        if !flips {\\n            for i in 0..<bitset.count {\\n                ans += \"\\\\(bitset[i])\" ?? \"\"\\n            }\\n        } else {\\n             for i in 0..<bitset.count {\\n                 if bitset[i] == 0{\\n                    ans += \"1\"\\n                 } else {\\n                    ans += \"0\" \\n                 }\\n            }\\n        }\\n        return ans\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1753119,
                "title": "beginner-s-solution-o-1-for-every-operation-except-tostring",
                "content": "```\\nclass Bitset {\\nprivate:\\n    vector<int> bit;\\n    int counter;\\n    bool flipRes;\\npublic:\\n    Bitset(int size) {\\n        bit.resize(size);\\n        counter = 0;\\n        flipRes = false;\\n    }\\n    \\n    void fix(int idx) {\\n        if(!flipRes) {\\n            if(bit[idx] == 0) {\\n                bit[idx] = 1;\\n                counter++;\\n            }\\n        } else {\\n            if(bit[idx] == 1) {\\n                counter++;\\n                bit[idx] = 0;\\n            }\\n            \\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(!flipRes) {\\n            if(bit[idx] == 1) {\\n                bit[idx] = 0;\\n                counter--;\\n                \\n            }\\n        } else {\\n            if(bit[idx] == 0) {\\n                bit[idx] = 1;\\n                counter--;\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        flipRes = !flipRes;\\n        counter = bit.size() - counter;\\n    }\\n    \\n    bool all() {\\n        return counter == bit.size();\\n    }\\n    \\n    bool one() {\\n        return counter>=1;\\n    }\\n    \\n    int count() {\\n        return counter;\\n    }\\n    \\n    string toString() {\\n        string str = \"\";\\n        if(!flipRes) {\\n            for(auto it : bit) {\\n                if(it == 0) str += \\'0\\';\\n                else str+= \\'1\\';\\n            }\\n        } else {\\n            for(auto it : bit) {\\n                if(it == 0) str += \\'1\\';\\n                else str+= \\'0\\';\\n            }\\n        }\\n            \\n        return str;\\n    }\\n};\\n```\\n\\nAn optimization to the above approach can be to maintain two strings. One which isn\\'t flipped if ```(!flipRes)``` equivalent & the other one flipped ```if(flip)``` equivalent. Performing operations based off flipRes value. Makes it a tad easier to implement and understanding wise.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Bitset {\\nprivate:\\n    vector<int> bit;\\n    int counter;\\n    bool flipRes;\\npublic:\\n    Bitset(int size) {\\n        bit.resize(size);\\n        counter = 0;\\n        flipRes = false;\\n    }\\n    \\n    void fix(int idx) {\\n        if(!flipRes) {\\n            if(bit[idx] == 0) {\\n                bit[idx] = 1;\\n                counter++;\\n            }\\n        } else {\\n            if(bit[idx] == 1) {\\n                counter++;\\n                bit[idx] = 0;\\n            }\\n            \\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(!flipRes) {\\n            if(bit[idx] == 1) {\\n                bit[idx] = 0;\\n                counter--;\\n                \\n            }\\n        } else {\\n            if(bit[idx] == 0) {\\n                bit[idx] = 1;\\n                counter--;\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        flipRes = !flipRes;\\n        counter = bit.size() - counter;\\n    }\\n    \\n    bool all() {\\n        return counter == bit.size();\\n    }\\n    \\n    bool one() {\\n        return counter>=1;\\n    }\\n    \\n    int count() {\\n        return counter;\\n    }\\n    \\n    string toString() {\\n        string str = \"\";\\n        if(!flipRes) {\\n            for(auto it : bit) {\\n                if(it == 0) str += \\'0\\';\\n                else str+= \\'1\\';\\n            }\\n        } else {\\n            for(auto it : bit) {\\n                if(it == 0) str += \\'1\\';\\n                else str+= \\'0\\';\\n            }\\n        }\\n            \\n        return str;\\n    }\\n};\\n```\n```(!flipRes)```\n```if(flip)```",
                "codeTag": "Java"
            },
            {
                "id": 1751061,
                "title": "c-explanation-for-each-function",
                "content": "```\\nclass Bitset {\\npublic:\\n    int n = 0;//size of our bit array\\n    int flip_count = 0;// number of times all the bits were flipped \\n    int one_count = 0;//total number of 1 bits\\n    vector<int>bits;// this will help to see the total number of flip for a particular  bit\\n    Bitset(int size) {\\n        n = size;\\n        flip_count = 0;\\n        one_count = 0;\\n        bits.resize(n,0);//initialy all the bits were flipped zero times\\n        \\n    }\\n    // this is one of the  tricky part to handle the flip count of the bit will increase if the bit value of that index is 0 and we can see the bit value by getting the total_flip\\n    void fix(int idx) {\\n        int total_flip = bits[idx] + flip_count;\\n        if(total_flip % 2 == 0)\\n        {\\n            bits[idx]++;\\n            one_count++;\\n        }\\n        \\n        \\n    }\\n    // this is one of the  tricky part to handle the flip count of the bit will increase if the bit value of that index is 1 and we can see the bit value by getting the total_flip\\n    void unfix(int idx) {\\n        int total_flip = bits[idx] + flip_count;\\n        if(total_flip % 2 == 1)\\n        {\\n            bits[idx]++;\\n            one_count--;\\n        }\\n        \\n    }\\n    //one more trick part (one_count  = n - one_count) because we are flipping so the zeros will be ones and ones will be zeros\\n    void flip() {\\n        flip_count++;\\n        one_count = n - one_count;\\n    }\\n    //one_cont has the total number of ones so we just need to see the condition\\n    bool all() {\\n         return (one_count == n);\\n        \\n    }\\n    //one_cont has the total number of ones so we just need to see the condition\\n    bool one() {\\n        return (one_count >= 1);\\n        \\n    }\\n    //one_cont has the total number of ones so we just need to return that\\n    int count() {\\n        return one_count;\\n    }\\n    \\n    string toString() {//here you just need to see if the total_flip is odd or even for a particular flip\\n        string cur_bits_val = \"\";\\n        int total_flip = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            total_flip = bits[i] + flip_count;\\n            if(total_flip % 2 == 1)\\n                cur_bits_val += \\'1\\';\\n            else\\n                cur_bits_val += \\'0\\';\\n        }\\n        return cur_bits_val;\\n        \\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```\\n**please upvote if it helped**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    int n = 0;//size of our bit array\\n    int flip_count = 0;// number of times all the bits were flipped \\n    int one_count = 0;//total number of 1 bits\\n    vector<int>bits;// this will help to see the total number of flip for a particular  bit\\n    Bitset(int size) {\\n        n = size;\\n        flip_count = 0;\\n        one_count = 0;\\n        bits.resize(n,0);//initialy all the bits were flipped zero times\\n        \\n    }\\n    // this is one of the  tricky part to handle the flip count of the bit will increase if the bit value of that index is 0 and we can see the bit value by getting the total_flip\\n    void fix(int idx) {\\n        int total_flip = bits[idx] + flip_count;\\n        if(total_flip % 2 == 0)\\n        {\\n            bits[idx]++;\\n            one_count++;\\n        }\\n        \\n        \\n    }\\n    // this is one of the  tricky part to handle the flip count of the bit will increase if the bit value of that index is 1 and we can see the bit value by getting the total_flip\\n    void unfix(int idx) {\\n        int total_flip = bits[idx] + flip_count;\\n        if(total_flip % 2 == 1)\\n        {\\n            bits[idx]++;\\n            one_count--;\\n        }\\n        \\n    }\\n    //one more trick part (one_count  = n - one_count) because we are flipping so the zeros will be ones and ones will be zeros\\n    void flip() {\\n        flip_count++;\\n        one_count = n - one_count;\\n    }\\n    //one_cont has the total number of ones so we just need to see the condition\\n    bool all() {\\n         return (one_count == n);\\n        \\n    }\\n    //one_cont has the total number of ones so we just need to see the condition\\n    bool one() {\\n        return (one_count >= 1);\\n        \\n    }\\n    //one_cont has the total number of ones so we just need to return that\\n    int count() {\\n        return one_count;\\n    }\\n    \\n    string toString() {//here you just need to see if the total_flip is odd or even for a particular flip\\n        string cur_bits_val = \"\";\\n        int total_flip = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            total_flip = bits[i] + flip_count;\\n            if(total_flip % 2 == 1)\\n                cur_bits_val += \\'1\\';\\n            else\\n                cur_bits_val += \\'0\\';\\n        }\\n        return cur_bits_val;\\n        \\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750780,
                "title": "java-solution-using-hashset-easy-to-understand",
                "content": "I used - state variable to maintain the state of all the indexes that I\\'m storing in hashset. Incase of flip/unflip I change the state variable.\\n\\n```\\nclass Bitset {\\n    \\n    int state=1;\\n    int size;\\n    Set<Integer> set;\\n\\n    public Bitset(int size) {\\n        this.size = size;\\n        set = new HashSet<>();\\n    }\\n    \\n    public void fix(int idx) {\\n        if(state == 1 && set.contains(idx)) return;\\n        else if(state == 1) set.add(idx);\\n        else if(state == 0 && set.contains(idx)) set.remove(idx);\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(state == 0 && set.contains(idx)) return;\\n        else if(state == 0)set.add(idx);\\n        else if(state == 1 && set.contains(idx))set.remove(idx);\\n    }\\n    \\n    public void flip() {\\n        state = 1-state;\\n    }\\n    \\n    public boolean all() {\\n        return (state == 1 && set.size() == this.size) || (state == 0 && set.size() == 0);\\n    }\\n    \\n    public boolean one() {\\n        return (state == 1 && set.size() >= 1) || (state == 0 && set.size() < this.size);\\n    }\\n    \\n    public int count() {\\n        if(state == 1) return set.size();\\n        else return this.size - set.size();\\n    }\\n    \\n    public String toString() {\\n        StringBuilder str = new StringBuilder();\\n        for(int i=0; i<this.size; i++) {\\n           if(set.contains(i)) str.append(state+\"\");\\n            else str.append((1-state)+\"\");\\n        }\\n        return str.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n    \\n    int state=1;\\n    int size;\\n    Set<Integer> set;\\n\\n    public Bitset(int size) {\\n        this.size = size;\\n        set = new HashSet<>();\\n    }\\n    \\n    public void fix(int idx) {\\n        if(state == 1 && set.contains(idx)) return;\\n        else if(state == 1) set.add(idx);\\n        else if(state == 0 && set.contains(idx)) set.remove(idx);\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(state == 0 && set.contains(idx)) return;\\n        else if(state == 0)set.add(idx);\\n        else if(state == 1 && set.contains(idx))set.remove(idx);\\n    }\\n    \\n    public void flip() {\\n        state = 1-state;\\n    }\\n    \\n    public boolean all() {\\n        return (state == 1 && set.size() == this.size) || (state == 0 && set.size() == 0);\\n    }\\n    \\n    public boolean one() {\\n        return (state == 1 && set.size() >= 1) || (state == 0 && set.size() < this.size);\\n    }\\n    \\n    public int count() {\\n        if(state == 1) return set.size();\\n        else return this.size - set.size();\\n    }\\n    \\n    public String toString() {\\n        StringBuilder str = new StringBuilder();\\n        for(int i=0; i<this.size; i++) {\\n           if(set.contains(i)) str.append(state+\"\");\\n            else str.append((1-state)+\"\");\\n        }\\n        return str.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750272,
                "title": "a-few-solutions",
                "content": "Use two arrays `A` and `B` to track the unflipped and flipped bitset values.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Bitset(size: Int) {\\n    private var K: Int\\n    private var N: Int\\n    private var A: IntArray\\n    private var B: IntArray\\n    init {\\n        K = 0\\n        N = size\\n        A = IntArray(N) { 0 }\\n        B = IntArray(N) { 1 }\\n    }\\n    fun fix(i: Int) {\\n        if (A[i] == 1)\\n            return\\n        A[i] = 1; ++K\\n        B[i] = 0\\n    }\\n    fun unfix(i: Int) {\\n        if (A[i] == 0)\\n            return\\n        A[i] = 0; --K\\n        B[i] = 1\\n    }\\n    var flip = { A = B.also{ B = A }; K = N - K }\\n    var all = { K == N }\\n    var one = { 0 < K }\\n    var count = { K }\\n    override fun toString(): String {\\n        return A.joinToString(\"\")\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nclass Bitset {\\n    constructor(N) {\\n        this.A = Array(N).fill(0);\\n        this.B = Array(N).fill(1);\\n        this.K = 0;\\n        this.N = N;\\n    }\\n    fix(i) {\\n        if (this.A[i])\\n            return;\\n        this.A[i] = 1, ++this.K;\\n        this.B[i] = 0;\\n    }\\n    unfix(i) {\\n        if (!this.A[i])\\n            return;\\n        this.A[i] = 0, --this.K;\\n        this.B[i] = 1;\\n    }\\n    flip = i => { [this.A, this.B] = [this.B, this.A], this.K = this.N - this.K; }\\n    all = () => this.K == this.N;\\n    one = () => 0 < this.K;\\n    count = () => this.K;\\n    toString = () => this.A.join(\\'\\');\\n}\\n```\\n\\n*Python3*\\n```\\nclass Bitset:\\n    def __init__(self, N: int):\\n        self.A = [0] * N\\n        self.B = [1] * N\\n        self.K = 0\\n        self.N = N\\n\\n    def fix(self, i: int) -> None:\\n        if self.A[i]:\\n            return\\n        self.A[i] = 1; self.K += 1\\n        self.B[i] = 0\\n\\n    def unfix(self, i: int) -> None:\\n        if not self.A[i]:\\n            return\\n        self.A[i] = 0; self.K -= 1\\n        self.B[i] = 1\\n\\n    def flip(self) -> None:\\n        self.A, self.B = self.B, self.A\\n        self.K = self.N - self.K\\n\\n    all = lambda self: self.K == self.N\\n    one = lambda self: 0 < self.K\\n    count = lambda self: self.K\\n    toString = lambda self: \\'\\'.join(str(x) for x in self.A)\\n```\\n\\n*C++*\\n```\\nclass Bitset {\\n    using VI = vector<int>;\\n    VI A, B;\\n    int K, N;\\npublic:\\n    Bitset(int N) : A{ VI(N) }, B{ VI(N, 1) }, K{ 0 }, N{ N } {}\\n    void fix(int i) {\\n        if (A[i])\\n            return;\\n        A[i] = 1, ++K;\\n        B[i] = 0;\\n    }\\n    void unfix(int i) {\\n        if (!A[i])\\n            return;\\n        A[i] = 0, --K;\\n        B[i] = 1;\\n    }\\n    void flip() {\\n        swap(A, B);\\n        K = N - K;\\n    }\\n    bool all() {\\n        return K == N;\\n    }\\n    bool one() {\\n        return 0 < K;\\n    }\\n    int count() {\\n        return K;\\n    }\\n    string toString(ostringstream os = ostringstream()) {\\n        transform(A.begin(), A.end(), ostream_iterator<char>(os, \"\"), [](auto x) {\\n            return x ? \\'1\\' : \\'0\\';\\n        });\\n        return os.str();\\n    }\\n};\\n```\\n\\n---\\n\\n**Contest Solutions: 2022-02-06:**\\n\\nUse a map `m` to track each bit\\'s value per index `i`.  A naive implementation will TLE since `flip()` has a linear O(N) runtime.  To transform the `flip()` into a O(1) operation, we can use inversion for tracking the amount of bits set `K` which can be derived from the cardinality `N`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Bitset(size: Int) {\\n    private var N: Int\\n    private var K: Int\\n    private var m: IntArray\\n    private var inv: Boolean\\n    init {\\n        N = size\\n        K = 0\\n        m = IntArray(N) { 0 }\\n        inv = false\\n    }\\n    fun fix(i: Int) {\\n        if (!inv && m[i] == 0) { m[i] = 1; ++K }\\n        if ( inv && m[i] == 1) { m[i] = 0; --K }\\n    }\\n    fun unfix(i: Int) {\\n        if (!inv && m[i] == 1) { m[i] = 0; --K }\\n        if ( inv && m[i] == 0) { m[i] = 1; ++K }\\n    }\\n    var flip = { inv = if (inv) false else true }\\n    var all = { count() == N }\\n    var one = { 0 < count() }\\n    var count = { if (!inv) K else N - K }\\n    override fun toString(): String {\\n        var A = mutableListOf<Int>()\\n        for (i in 0 until N) {\\n            var x = m[i]\\n            A.add(if (!inv) x else x xor 1)\\n        }\\n        return A.map{ if (it == 1) \\'1\\' else \\'0\\' }.joinToString(\"\")\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nclass Bitset {\\n    constructor(N) {\\n        this.N = N;\\n        this.K = 0;\\n        this.inv = 0;\\n        this.m = Array(100000 + 1).fill(0);\\n    }\\n    fix(i) {\\n        if (!this.inv && !this.m[i]) this.m[i] = 1, ++this.K;\\n        if ( this.inv &&  this.m[i]) this.m[i] = 0, --this.K;\\n    }\\n    unfix(i) {\\n        if (!this.inv && this.m[i]) this.m[i] = 0, --this.K;\\n        if (this.inv && !this.m[i]) this.m[i] = 1, ++this.K;\\n    }\\n    flip = i => this.inv ^= 1;\\n    all = () => this.count() == this.N;\\n    one = () => 0 < this.count();\\n    count = () => !this.inv ? this.K : this.N - this.K;\\n    toString() {\\n        let A = [];\\n        for (let i = 0; i < this.N; ++i)\\n            A.push(!this.inv ? this.m[i] : this.m[i] ^ 1);\\n        return A.map(x => x ? \\'1\\' : \\'0\\').join(\\'\\');\\n    }\\n}\\n```\\n\\n*Python3*\\n```\\nclass Bitset:\\n    def __init__(self, N: int):\\n        self.N = N\\n        self.K = 0\\n        self.m = {i: 0 for i in range(100000 + 1)}\\n        self.inv = 0\\n\\n    def fix(self, i: int) -> None:\\n        if not self.inv and self.m[i] == 0: self.m[i] = 1; self.K += 1\\n        if     self.inv and self.m[i] == 1: self.m[i] = 0; self.K -= 1\\n            \\n    def unfix(self, i: int) -> None:\\n        if not self.inv and self.m[i] == 1: self.m[i] = 0; self.K -= 1\\n        if     self.inv and self.m[i] == 0: self.m[i] = 1; self.K += 1\\n\\n    def flip(self): self.inv ^= 1\\n    all = lambda self: self.count() == self.N\\n    one = lambda self: 0 < self.count()\\n    count = lambda self: self.K if not self.inv else self.N - self.K\\n\\n    def toString(self) -> str:\\n        A = [self.m[i] if not self.inv else self.m[i] ^ 1 for i in range(self.N)]\\n        return \\'\\'.join(\\'1\\' if x else \\'0\\' for x in A)\\n```\\n\\n*C++*\\n```\\nclass Bitset {\\n    using Map = bitset<100000>;\\n    Map m;\\n    int N, K, inv;\\npublic:\\n    Bitset(int N) : N{ N } {}\\n    void fix(int i) {\\n        if (!inv && !m[i]) m[i] = 1, ++K;\\n        if ( inv &&  m[i]) m[i] = 0, --K;\\n    }\\n    void unfix(int i) {\\n        if (!inv && m[i]) m[i] = 0, --K;\\n        if (inv && !m[i]) m[i] = 1, ++K;\\n    }\\n    void flip() { inv ^= 1; }\\n    bool all() { return count() == N; }\\n    bool one() { return 0 < count(); }\\n    int count() { return !inv ? K : N - K; }\\n    string toString() {\\n        string s;\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto c = m[i] ? \\'1\\' : \\'0\\';\\n            if (inv)\\n                c = c == \\'1\\' ? \\'0\\' : \\'1\\';\\n            s.push_back(c);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Bitset(size: Int) {\\n    private var K: Int\\n    private var N: Int\\n    private var A: IntArray\\n    private var B: IntArray\\n    init {\\n        K = 0\\n        N = size\\n        A = IntArray(N) { 0 }\\n        B = IntArray(N) { 1 }\\n    }\\n    fun fix(i: Int) {\\n        if (A[i] == 1)\\n            return\\n        A[i] = 1; ++K\\n        B[i] = 0\\n    }\\n    fun unfix(i: Int) {\\n        if (A[i] == 0)\\n            return\\n        A[i] = 0; --K\\n        B[i] = 1\\n    }\\n    var flip = { A = B.also{ B = A }; K = N - K }\\n    var all = { K == N }\\n    var one = { 0 < K }\\n    var count = { K }\\n    override fun toString(): String {\\n        return A.joinToString(\"\")\\n    }\\n}\\n```\n```\\nclass Bitset {\\n    constructor(N) {\\n        this.A = Array(N).fill(0);\\n        this.B = Array(N).fill(1);\\n        this.K = 0;\\n        this.N = N;\\n    }\\n    fix(i) {\\n        if (this.A[i])\\n            return;\\n        this.A[i] = 1, ++this.K;\\n        this.B[i] = 0;\\n    }\\n    unfix(i) {\\n        if (!this.A[i])\\n            return;\\n        this.A[i] = 0, --this.K;\\n        this.B[i] = 1;\\n    }\\n    flip = i => { [this.A, this.B] = [this.B, this.A], this.K = this.N - this.K; }\\n    all = () => this.K == this.N;\\n    one = () => 0 < this.K;\\n    count = () => this.K;\\n    toString = () => this.A.join(\\'\\');\\n}\\n```\n```\\nclass Bitset:\\n    def __init__(self, N: int):\\n        self.A = [0] * N\\n        self.B = [1] * N\\n        self.K = 0\\n        self.N = N\\n\\n    def fix(self, i: int) -> None:\\n        if self.A[i]:\\n            return\\n        self.A[i] = 1; self.K += 1\\n        self.B[i] = 0\\n\\n    def unfix(self, i: int) -> None:\\n        if not self.A[i]:\\n            return\\n        self.A[i] = 0; self.K -= 1\\n        self.B[i] = 1\\n\\n    def flip(self) -> None:\\n        self.A, self.B = self.B, self.A\\n        self.K = self.N - self.K\\n\\n    all = lambda self: self.K == self.N\\n    one = lambda self: 0 < self.K\\n    count = lambda self: self.K\\n    toString = lambda self: \\'\\'.join(str(x) for x in self.A)\\n```\n```\\nclass Bitset {\\n    using VI = vector<int>;\\n    VI A, B;\\n    int K, N;\\npublic:\\n    Bitset(int N) : A{ VI(N) }, B{ VI(N, 1) }, K{ 0 }, N{ N } {}\\n    void fix(int i) {\\n        if (A[i])\\n            return;\\n        A[i] = 1, ++K;\\n        B[i] = 0;\\n    }\\n    void unfix(int i) {\\n        if (!A[i])\\n            return;\\n        A[i] = 0, --K;\\n        B[i] = 1;\\n    }\\n    void flip() {\\n        swap(A, B);\\n        K = N - K;\\n    }\\n    bool all() {\\n        return K == N;\\n    }\\n    bool one() {\\n        return 0 < K;\\n    }\\n    int count() {\\n        return K;\\n    }\\n    string toString(ostringstream os = ostringstream()) {\\n        transform(A.begin(), A.end(), ostream_iterator<char>(os, \"\"), [](auto x) {\\n            return x ? \\'1\\' : \\'0\\';\\n        });\\n        return os.str();\\n    }\\n};\\n```\n```\\nclass Bitset(size: Int) {\\n    private var N: Int\\n    private var K: Int\\n    private var m: IntArray\\n    private var inv: Boolean\\n    init {\\n        N = size\\n        K = 0\\n        m = IntArray(N) { 0 }\\n        inv = false\\n    }\\n    fun fix(i: Int) {\\n        if (!inv && m[i] == 0) { m[i] = 1; ++K }\\n        if ( inv && m[i] == 1) { m[i] = 0; --K }\\n    }\\n    fun unfix(i: Int) {\\n        if (!inv && m[i] == 1) { m[i] = 0; --K }\\n        if ( inv && m[i] == 0) { m[i] = 1; ++K }\\n    }\\n    var flip = { inv = if (inv) false else true }\\n    var all = { count() == N }\\n    var one = { 0 < count() }\\n    var count = { if (!inv) K else N - K }\\n    override fun toString(): String {\\n        var A = mutableListOf<Int>()\\n        for (i in 0 until N) {\\n            var x = m[i]\\n            A.add(if (!inv) x else x xor 1)\\n        }\\n        return A.map{ if (it == 1) \\'1\\' else \\'0\\' }.joinToString(\"\")\\n    }\\n}\\n```\n```\\nclass Bitset {\\n    constructor(N) {\\n        this.N = N;\\n        this.K = 0;\\n        this.inv = 0;\\n        this.m = Array(100000 + 1).fill(0);\\n    }\\n    fix(i) {\\n        if (!this.inv && !this.m[i]) this.m[i] = 1, ++this.K;\\n        if ( this.inv &&  this.m[i]) this.m[i] = 0, --this.K;\\n    }\\n    unfix(i) {\\n        if (!this.inv && this.m[i]) this.m[i] = 0, --this.K;\\n        if (this.inv && !this.m[i]) this.m[i] = 1, ++this.K;\\n    }\\n    flip = i => this.inv ^= 1;\\n    all = () => this.count() == this.N;\\n    one = () => 0 < this.count();\\n    count = () => !this.inv ? this.K : this.N - this.K;\\n    toString() {\\n        let A = [];\\n        for (let i = 0; i < this.N; ++i)\\n            A.push(!this.inv ? this.m[i] : this.m[i] ^ 1);\\n        return A.map(x => x ? \\'1\\' : \\'0\\').join(\\'\\');\\n    }\\n}\\n```\n```\\nclass Bitset:\\n    def __init__(self, N: int):\\n        self.N = N\\n        self.K = 0\\n        self.m = {i: 0 for i in range(100000 + 1)}\\n        self.inv = 0\\n\\n    def fix(self, i: int) -> None:\\n        if not self.inv and self.m[i] == 0: self.m[i] = 1; self.K += 1\\n        if     self.inv and self.m[i] == 1: self.m[i] = 0; self.K -= 1\\n            \\n    def unfix(self, i: int) -> None:\\n        if not self.inv and self.m[i] == 1: self.m[i] = 0; self.K -= 1\\n        if     self.inv and self.m[i] == 0: self.m[i] = 1; self.K += 1\\n\\n    def flip(self): self.inv ^= 1\\n    all = lambda self: self.count() == self.N\\n    one = lambda self: 0 < self.count()\\n    count = lambda self: self.K if not self.inv else self.N - self.K\\n\\n    def toString(self) -> str:\\n        A = [self.m[i] if not self.inv else self.m[i] ^ 1 for i in range(self.N)]\\n        return \\'\\'.join(\\'1\\' if x else \\'0\\' for x in A)\\n```\n```\\nclass Bitset {\\n    using Map = bitset<100000>;\\n    Map m;\\n    int N, K, inv;\\npublic:\\n    Bitset(int N) : N{ N } {}\\n    void fix(int i) {\\n        if (!inv && !m[i]) m[i] = 1, ++K;\\n        if ( inv &&  m[i]) m[i] = 0, --K;\\n    }\\n    void unfix(int i) {\\n        if (!inv && m[i]) m[i] = 0, --K;\\n        if (inv && !m[i]) m[i] = 1, ++K;\\n    }\\n    void flip() { inv ^= 1; }\\n    bool all() { return count() == N; }\\n    bool one() { return 0 < count(); }\\n    int count() { return !inv ? K : N - K; }\\n    string toString() {\\n        string s;\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto c = m[i] ? \\'1\\' : \\'0\\';\\n            if (inv)\\n                c = c == \\'1\\' ? \\'0\\' : \\'1\\';\\n            s.push_back(c);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749693,
                "title": "o-1-for-all-except-tostring",
                "content": "```\\nclass Bitset {\\n    int count,flips,zeros;\\n    int bitset[];\\n    public Bitset(int size) {\\n        bitset=new int[size];\\n        count=0;\\n        flips=0;\\n        zeros=0;\\n    }\\n    \\n    public void fix(int idx) {\\n       if(flips%2==0){\\n           if(bitset[idx]==0)count++;\\n           bitset[idx]=1;\\n       }else{\\n           if(bitset[idx]==1)count++;\\n           bitset[idx]=0;\\n       }\\n    }\\n    \\n    public void unfix(int idx) {\\n       if(flips%2==0){\\n           if(bitset[idx]==1)count--;\\n           bitset[idx]=0;\\n       }else{\\n           if(bitset[idx]==0)count--;\\n           bitset[idx]=1; \\n       }\\n    }\\n    \\n    public void flip() {\\n        //in flip count of 1s and 0s will be changed\\n        //curr zerocount=curr 1count and vice versa\\n        int temp=count;\\n        zeros=bitset.length-count;\\n        count=zeros;\\n        zeros=temp;\\n        flips++;\\n    }\\n    \\n    public boolean all() {\\n        return count==bitset.length;\\n    }\\n    \\n    public boolean one() {\\n        return count>0;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n    \\n    public String toString() {\\n        StringBuilder s=new StringBuilder();\\n        for(int i:bitset){\\n            if(flips%2==0)s.append(i);\\n            else s.append(1-i);\\n        }\\n        return s.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Bitset {\\n    int count,flips,zeros;\\n    int bitset[];\\n    public Bitset(int size) {\\n        bitset=new int[size];\\n        count=0;\\n        flips=0;\\n        zeros=0;\\n    }\\n    \\n    public void fix(int idx) {\\n       if(flips%2==0){\\n           if(bitset[idx]==0)count++;\\n           bitset[idx]=1;\\n       }else{\\n           if(bitset[idx]==1)count++;\\n           bitset[idx]=0;\\n       }\\n    }\\n    \\n    public void unfix(int idx) {\\n       if(flips%2==0){\\n           if(bitset[idx]==1)count--;\\n           bitset[idx]=0;\\n       }else{\\n           if(bitset[idx]==0)count--;\\n           bitset[idx]=1; \\n       }\\n    }\\n    \\n    public void flip() {\\n        //in flip count of 1s and 0s will be changed\\n        //curr zerocount=curr 1count and vice versa\\n        int temp=count;\\n        zeros=bitset.length-count;\\n        count=zeros;\\n        zeros=temp;\\n        flips++;\\n    }\\n    \\n    public boolean all() {\\n        return count==bitset.length;\\n    }\\n    \\n    public boolean one() {\\n        return count>0;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n    \\n    public String toString() {\\n        StringBuilder s=new StringBuilder();\\n        for(int i:bitset){\\n            if(flips%2==0)s.append(i);\\n            else s.append(1-i);\\n        }\\n        return s.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749448,
                "title": "c-o-1-time-for-all-operation-except-constructor-by-2-string",
                "content": "# 1. Idea \\nThe idea is to fix and unfix by maintaining two opposite string\\n```\\nv[0] = \"000000000\"\\nv[1] = \"111111111\"\\n```\\nm_flip would be the index of v and return  **v[m_flip]** for toString function. \\nThe variable **onecnt** is to keep track how many one in the string v[m_flip]; \\n\\n\\n# 2. Source Code\\n\\n```C++\\nclass Bitset {\\npublic:\\n    vector<string> v;\\n    int onecnt = 0, m_flip = 0, int m_size = 0;\\n    Bitset(int size) {\\n        m_size = size;\\n        v=vector<string>(2);\\n        v[0]=string(m_size, \\'0\\'); //O(N)\\n        v[1]=string(m_size, \\'1\\'); //O(N)\\n        onecnt=0;\\n    }\\n    \\n    void fix(int idx) { //O(1)\\n        if(idx<0 || idx>=m_size) return;\\n        if(v[m_flip][idx]==\\'0\\') {\\n            v[m_flip][idx] = \\'1\\';\\n            v[(m_flip+1)%2][idx] = \\'0\\';\\n            onecnt++;\\n        }\\n    }\\n    \\n    void unfix(int idx) { //O(1)\\n        if(idx<0 || idx>=m_size) return;\\n        if(v[m_flip][idx]==\\'1\\') {\\n            v[m_flip][idx] = \\'0\\';\\n            v[(m_flip+1)%2][idx] = \\'1\\';\\n            onecnt--;\\n        }        \\n    }\\n    \\n    void flip() { //O(1)\\n        m_flip = (m_flip+1)%2;\\n        onecnt = m_size - onecnt; \\n    }\\n    \\n    bool all() {   return onecnt==m_size;  } //O(1)\\n    bool one() { return onecnt>0; } //O(1)\\n    int count() { return onecnt;  } //O(1)\\n    string toString() {return v[m_flip]; } \\n\\t//O(1) if the API of this problem set  return type of this function as string& \\n\\t//O(N) because API of this problem limit return type to string but not string&\\n};\\n```\\nBecause the return function of toString is declare as string but not string&, \\nSo copy assignment will be trigger.  The detail of how string work is in here.\\nhttps://www.onlinegdb.com/H7HExHAwc  \\n\\n\\n# 3. Time & Space \\n## Time Complexity\\nAll behavior are O(1) except the constructor Bitset O(N). \\nBecause it need O(N) to create two string with size O(N);\\n\\n## Space Complexity \\nTwo string with size N, so O(N) is the space complexity \\nin this solution.",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nv[0] = \"000000000\"\\nv[1] = \"111111111\"\\n```\n```C++\\nclass Bitset {\\npublic:\\n    vector<string> v;\\n    int onecnt = 0, m_flip = 0, int m_size = 0;\\n    Bitset(int size) {\\n        m_size = size;\\n        v=vector<string>(2);\\n        v[0]=string(m_size, \\'0\\'); //O(N)\\n        v[1]=string(m_size, \\'1\\'); //O(N)\\n        onecnt=0;\\n    }\\n    \\n    void fix(int idx) { //O(1)\\n        if(idx<0 || idx>=m_size) return;\\n        if(v[m_flip][idx]==\\'0\\') {\\n            v[m_flip][idx] = \\'1\\';\\n            v[(m_flip+1)%2][idx] = \\'0\\';\\n            onecnt++;\\n        }\\n    }\\n    \\n    void unfix(int idx) { //O(1)\\n        if(idx<0 || idx>=m_size) return;\\n        if(v[m_flip][idx]==\\'1\\') {\\n            v[m_flip][idx] = \\'0\\';\\n            v[(m_flip+1)%2][idx] = \\'1\\';\\n            onecnt--;\\n        }        \\n    }\\n    \\n    void flip() { //O(1)\\n        m_flip = (m_flip+1)%2;\\n        onecnt = m_size - onecnt; \\n    }\\n    \\n    bool all() {   return onecnt==m_size;  } //O(1)\\n    bool one() { return onecnt>0; } //O(1)\\n    int count() { return onecnt;  } //O(1)\\n    string toString() {return v[m_flip]; } \\n\\t//O(1) if the API of this problem set  return type of this function as string& \\n\\t//O(N) because API of this problem limit return type to string but not string&\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749246,
                "title": "easy-cpp-solution",
                "content": "```\\n\\nclass Bitset {\\npublic:\\n    string v,v1;\\n    int c1=0,c2=0,n;\\n    Bitset(int size) {\\n        string s1(size,\\'0\\');\\n        v=s1;\\n        c2=size;\\n        n=size;\\n        string s2(size,\\'1\\');\\n        v1=s2;\\n    }\\n    \\n    void fix(int idx) {\\n        if(v[idx]==\\'0\\')\\n        {\\n            c1++;\\n            c2--;\\n        }\\n        v[idx]=\\'1\\';\\n        v1[idx]=\\'0\\';\\n    }\\n    \\n    void unfix(int idx) {\\n        if(v[idx]==\\'1\\')\\n        {\\n            c2++;\\n            c1--;\\n        }\\n        v[idx]=\\'0\\';\\n        v1[idx]=\\'1\\';\\n    }\\n    \\n    void flip() {\\n        swap(v,v1);\\n        swap(c1,c2);\\n    }\\n    \\n    bool all() {\\n        if(c1==n)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n        if(c1>0)\\n            return true;\\n        return false;\\n    }\\n    \\n    int count() {\\n        return c1;\\n    }\\n    \\n    string toString() {\\n        return v;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */",
                "solutionTags": [
                    "C",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Bitset {\\npublic:\\n    string v,v1;\\n    int c1=0,c2=0,n;\\n    Bitset(int size) {\\n        string s1(size,\\'0\\');\\n        v=s1;\\n        c2=size;\\n        n=size;\\n        string s2(size,\\'1\\');\\n        v1=s2;\\n    }\\n    \\n    void fix(int idx) {\\n        if(v[idx]==\\'0\\')\\n        {\\n            c1++;\\n            c2--;\\n        }\\n        v[idx]=\\'1\\';\\n        v1[idx]=\\'0\\';\\n    }\\n    \\n    void unfix(int idx) {\\n        if(v[idx]==\\'1\\')\\n        {\\n            c2++;\\n            c1--;\\n        }\\n        v[idx]=\\'0\\';\\n        v1[idx]=\\'1\\';\\n    }\\n    \\n    void flip() {\\n        swap(v,v1);\\n        swap(c1,c2);\\n    }\\n    \\n    bool all() {\\n        if(c1==n)\\n            return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n        if(c1>0)\\n            return true;\\n        return false;\\n    }\\n    \\n    int count() {\\n        return c1;\\n    }\\n    \\n    string toString() {\\n        return v;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1749188,
                "title": "python-lazy-flipping-684ms",
                "content": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bits = [\\'0\\' for i in range(size)];\\n        self.ones = 0;\\n        self.size = size;\\n        self.flipped = False;\\n\\n    def fix(self, idx: int) -> None:\\n        if self.flipped:\\n            if self.bits[idx] == \\'1\\':\\n                self.ones += 1;\\n            self.bits[idx] = \\'0\\';\\n            return;\\n            \\n        if self.bits[idx] == \\'0\\':\\n            self.ones += 1;\\n        self.bits[idx] = \\'1\\';\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.flipped:\\n            if self.bits[idx] == \\'0\\':\\n                self.ones -= 1;\\n            self.bits[idx] = \\'1\\';\\n            return\\n        \\n        if self.bits[idx] == \\'1\\':\\n            self.ones-=1;\\n        self.bits[idx] = \\'0\\';\\n\\n    def flip(self) -> None:\\n        self.flipped = not self.flipped;\\n        self.ones = self.size - self.ones\\n\\n    def all(self) -> bool:\\n        return self.ones == self.size;\\n\\n    def one(self) -> bool:\\n        return self.ones>0;\\n\\n    def count(self) -> int:\\n        return self.ones;\\n\\n    def toString(self) -> str:\\n        if self.flipped:\\n            for i in range(len (self.bits) ):\\n                if self.bits[ i ] == \\'0\\':\\n                    self.bits[ i ] = \\'1\\';\\n                else:\\n                    self.bits[ i ] = \\'0\\';\\n            self.flipped = False;\\n        return \"\".join(self.bits);\\n```\\n\\nTwo tricks:\\nFor flipping the bits, I ignore it completely (until it makes sense to resolve when toString is called) and use a flag self.flipped to keep track whether I am flipped or not. Then, I adjust the self.ones count to the complement of the size. Now, I have to adjust fix and unfix to keep track of the opposite values. ie if I am flipped, and fix is called when the target index is 1, it is actually 0 when flipped. so I increment my self.ones count, but continue to change the index from 1 to 0. \\n\\none count and all can be called immediately in constant time because I know the size of the binary value and the counter self.ones.\\n\\nWhen toString is called, I return the joined self.bits. If I am flipped, I take the time to unflip it and return the correct value. I also adjust the flag. This is linear time, but I know toString is called at a maximum of 5 times!",
                "solutionTags": [],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bits = [\\'0\\' for i in range(size)];\\n        self.ones = 0;\\n        self.size = size;\\n        self.flipped = False;\\n\\n    def fix(self, idx: int) -> None:\\n        if self.flipped:\\n            if self.bits[idx] == \\'1\\':\\n                self.ones += 1;\\n            self.bits[idx] = \\'0\\';\\n            return;\\n            \\n        if self.bits[idx] == \\'0\\':\\n            self.ones += 1;\\n        self.bits[idx] = \\'1\\';\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.flipped:\\n            if self.bits[idx] == \\'0\\':\\n                self.ones -= 1;\\n            self.bits[idx] = \\'1\\';\\n            return\\n        \\n        if self.bits[idx] == \\'1\\':\\n            self.ones-=1;\\n        self.bits[idx] = \\'0\\';\\n\\n    def flip(self) -> None:\\n        self.flipped = not self.flipped;\\n        self.ones = self.size - self.ones\\n\\n    def all(self) -> bool:\\n        return self.ones == self.size;\\n\\n    def one(self) -> bool:\\n        return self.ones>0;\\n\\n    def count(self) -> int:\\n        return self.ones;\\n\\n    def toString(self) -> str:\\n        if self.flipped:\\n            for i in range(len (self.bits) ):\\n                if self.bits[ i ] == \\'0\\':\\n                    self.bits[ i ] = \\'1\\';\\n                else:\\n                    self.bits[ i ] = \\'0\\';\\n            self.flipped = False;\\n        return \"\".join(self.bits);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749076,
                "title": "c-100-faster-using-two-strings",
                "content": "```\\nclass Bitset {\\npublic:\\n    string s,dub;\\n    int c=0;\\n    int siz=0;\\n    Bitset(int size) {\\nfor(int i=0;i<size;i++){\\n        s.push_back(\\'0\\');\\n        dub.push_back(\\'1\\');\\n}\\n    }\\n    \\n    void fix(int idx) {\\n        if(s[idx]!=\\'1\\'){\\n        s[idx]=\\'1\\';\\n        dub[idx]=\\'0\\';    \\n        c++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(s[idx]!=\\'0\\'){\\n        s[idx]=\\'0\\';\\n        dub[idx]=\\'1\\';\\n        c--;\\n        }\\n    }\\n    \\n    void flip() {\\n        swap(s,dub);\\n        c=s.size()-c;\\n    }\\n    \\n    bool all() {\\n         if(c==s.size())return true;\\n        else return false;\\n    }\\n    \\n    bool one() {\\n         if(c>0)return true;\\n        else return false;\\n    }\\n    \\n    int count() {\\n\\n        return c;\\n        \\n    }\\n    \\n    string toString() {\\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n ```\\n PLease do upvote if u find this helpful.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    string s,dub;\\n    int c=0;\\n    int siz=0;\\n    Bitset(int size) {\\nfor(int i=0;i<size;i++){\\n        s.push_back(\\'0\\');\\n        dub.push_back(\\'1\\');\\n}\\n    }\\n    \\n    void fix(int idx) {\\n        if(s[idx]!=\\'1\\'){\\n        s[idx]=\\'1\\';\\n        dub[idx]=\\'0\\';    \\n        c++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(s[idx]!=\\'0\\'){\\n        s[idx]=\\'0\\';\\n        dub[idx]=\\'1\\';\\n        c--;\\n        }\\n    }\\n    \\n    void flip() {\\n        swap(s,dub);\\n        c=s.size()-c;\\n    }\\n    \\n    bool all() {\\n         if(c==s.size())return true;\\n        else return false;\\n    }\\n    \\n    bool one() {\\n         if(c>0)return true;\\n        else return false;\\n    }\\n    \\n    int count() {\\n\\n        return c;\\n        \\n    }\\n    \\n    string toString() {\\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1749042,
                "title": "simple-with-a-bool-flag-and-xor-explained",
                "content": "## Explanation \\n\\n### Prequisite (XOR)\\n\\n- Technically XOR is high when both its inputs are different, else it is low\\n\\n### Intuition\\n\\n- Key is to realize the operation in which we can\\'t afford O(n) time, but actually performing it will cost us O(n) time is the ```flip``` operation \\n- So, instead we never perform the flip operation, instead we keep a count of 1\\'s and 0\\'s in the array, \\n- and a bool flipped which stored the state of the array viz weather flipped or not\\n- While setting or unsetting a bit we take xor or xnor of the given index to determine if the operation is required\\n- whever we set or unset a bit we update the sum accordingly \\n- finally while printing we return the xor of the bit with the flipped variable\\n\\n\\n\\n## Code\\n```\\nclass Bitset {\\npublic:\\n    \\n    int sum; // a sum variable \\n    bool flipped;\\n    vector <bool> bitArray;\\n    int n;\\n    \\n    Bitset(int size) {\\n        // initialization of the  bitarray\\n        bitArray = vector <bool> (size,false); \\n        sum = 0;\\n        flipped = false;\\n        n = size;\\n        \\n        // avoid the code below\\n        // it is for faster execution \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);        \\n    }\\n    \\n    void fix(int idx) {\\n        // xor gives true when both inputs are different \\n        // so we take xnor \\n        // we need to set if the given bit is not set and flipped is true or vice versa\\n        // we update the sum variable accordingly\\n        if (!(bitArray[idx] ^ flipped))\\n            bitArray[idx] = !bitArray[idx], sum++;\\n\\n    }\\n    \\n    void unfix(int idx) {\\n        // we need to unfix if the given idx is set and flipped is false or vice versa\\n        if (bitArray[idx] ^ flipped)\\n            bitArray[idx] = !bitArray[idx], sum--;\\n    }\\n    \\n    void flip() {\\n        // we update the sum \\n        flipped = !flipped;\\n        sum = n-sum;\\n    }\\n    \\n    // rest part is trivial \\n    // since the sum is composed of ones and zeros\\n    // the sum gives us the number of zeroes in the bit array\\n    \\n    bool all() {\\n        return sum == n;\\n    }\\n    \\n    bool one() {\\n        return sum > 0;\\n    }\\n    \\n    int count() {\\n        return sum;\\n    }\\n    \\n    string toString() {\\n        string ret;\\n        for( auto it : bitArray){\\n            if( it^flipped  ) ret.push_back(\\'1\\');\\n            else ret.push_back(\\'0\\');\\n        }\\n        return ret;\\n    }\\n};\\n\\n```\\n\\n> PS : If you like the explanation do upvote \\n> Cheers !",
                "solutionTags": [
                    "C"
                ],
                "code": "```flip```\n```\\nclass Bitset {\\npublic:\\n    \\n    int sum; // a sum variable \\n    bool flipped;\\n    vector <bool> bitArray;\\n    int n;\\n    \\n    Bitset(int size) {\\n        // initialization of the  bitarray\\n        bitArray = vector <bool> (size,false); \\n        sum = 0;\\n        flipped = false;\\n        n = size;\\n        \\n        // avoid the code below\\n        // it is for faster execution \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);        \\n    }\\n    \\n    void fix(int idx) {\\n        // xor gives true when both inputs are different \\n        // so we take xnor \\n        // we need to set if the given bit is not set and flipped is true or vice versa\\n        // we update the sum variable accordingly\\n        if (!(bitArray[idx] ^ flipped))\\n            bitArray[idx] = !bitArray[idx], sum++;\\n\\n    }\\n    \\n    void unfix(int idx) {\\n        // we need to unfix if the given idx is set and flipped is false or vice versa\\n        if (bitArray[idx] ^ flipped)\\n            bitArray[idx] = !bitArray[idx], sum--;\\n    }\\n    \\n    void flip() {\\n        // we update the sum \\n        flipped = !flipped;\\n        sum = n-sum;\\n    }\\n    \\n    // rest part is trivial \\n    // since the sum is composed of ones and zeros\\n    // the sum gives us the number of zeroes in the bit array\\n    \\n    bool all() {\\n        return sum == n;\\n    }\\n    \\n    bool one() {\\n        return sum > 0;\\n    }\\n    \\n    int count() {\\n        return sum;\\n    }\\n    \\n    string toString() {\\n        string ret;\\n        for( auto it : bitArray){\\n            if( it^flipped  ) ret.push_back(\\'1\\');\\n            else ret.push_back(\\'0\\');\\n        }\\n        return ret;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1748993,
                "title": "python-pure-o-1-calls-trick",
                "content": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        \\n        self.string=[0]*size\\n        self.flipp=[1]*size\\n        self.ones=0\\n        self.size=size\\n        \\n\\n    def fix(self, idx: int) -> None:\\n        \\n        if self.string[idx]==0:\\n            self.ones+=1\\n        \\n        \\n        self.string[idx]=1\\n        self.flipp[idx]=0    \\n            \\n        \\n        \\n\\n    def unfix(self, idx: int) -> None:\\n        \\n        if self.string[idx]==1:\\n            self.ones-=1\\n        \\n        \\n        self.string[idx]=0\\n        self.flipp[idx]=1\\n            \\n            \\n        \\n\\n    def flip(self) -> None:\\n        \\n        self.string,self.flipp=self.flipp,self.string\\n\\t\\t\\n\\t\\t#if you use this line instead of above line then it will give you the TLE\\n\\t\\t\\n\\t\\t#self.string,self.flipp=self.flipp[::],self.string[::]\\n\\t\\t\\n\\t\\t#####################\\n\\t\\t\\n        self.ones = self.size - self.ones\\n        \\n\\n    def all(self) -> bool:\\n        \\n        return self.ones==self.size\\n        \\n\\n    def one(self) -> bool:\\n        \\n        return self.ones>0\\n        \\n\\n    def count(self) -> int:\\n        \\n        return self.ones\\n        \\n\\n    def toString(self) -> str:\\n        \\n        return \"\".join(map(str,self.string))\\n        \\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        \\n        self.string=[0]*size\\n        self.flipp=[1]*size\\n        self.ones=0\\n        self.size=size\\n        \\n\\n    def fix(self, idx: int) -> None:\\n        \\n        if self.string[idx]==0:\\n            self.ones+=1\\n        \\n        \\n        self.string[idx]=1\\n        self.flipp[idx]=0    \\n            \\n        \\n        \\n\\n    def unfix(self, idx: int) -> None:\\n        \\n        if self.string[idx]==1:\\n            self.ones-=1\\n        \\n        \\n        self.string[idx]=0\\n        self.flipp[idx]=1\\n            \\n            \\n        \\n\\n    def flip(self) -> None:\\n        \\n        self.string,self.flipp=self.flipp,self.string\\n\\t\\t\\n\\t\\t#if you use this line instead of above line then it will give you the TLE\\n\\t\\t\\n\\t\\t#self.string,self.flipp=self.flipp[::],self.string[::]\\n\\t\\t\\n\\t\\t#####################\\n\\t\\t\\n        self.ones = self.size - self.ones\\n        \\n\\n    def all(self) -> bool:\\n        \\n        return self.ones==self.size\\n        \\n\\n    def one(self) -> bool:\\n        \\n        return self.ones>0\\n        \\n\\n    def count(self) -> int:\\n        \\n        return self.ones\\n        \\n\\n    def toString(self) -> str:\\n        \\n        return \"\".join(map(str,self.string))\\n        \\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748901,
                "title": "java-o-1-solution-keep-track-2-stringbuilder-main-bits-and-its-reversion",
                "content": "Got tons of TLE submission in the contest, but finally I\\'ve gone through it then \\uD83D\\uDE14\\uD83D\\uDE14. I think the main problem avoiding TLE of this question is to optimize the `flip()` function. I do this by using one more StringBuilder to store the reversed version of our main bitset\\n```\\nclass Bitset {\\n\\tStringBuilder bits;\\n\\tStringBuilder reverse;\\n\\tint countOne;\\n\\n    public Bitset(int size) {\\n        bits = new StringBuilder();\\n        reverse = new StringBuilder();\\n        while(size>0) {\\n        \\tbits.append(\\'0\\');\\n        \\treverse.append(\\'1\\');\\n        \\tsize--;\\n        }\\n        countOne = 0;\\n    }\\n    \\n    public void fix(int idx) {\\n    \\tif(bits.charAt(idx)==\\'0\\') {\\n    \\t\\tbits.setCharAt(idx, \\'1\\');\\n    \\t\\treverse.setCharAt(idx, \\'0\\');\\n    \\t\\tcountOne++;\\n    \\t}\\n    }\\n    \\n    public void unfix(int idx) {\\n    \\tif(bits.charAt(idx)==\\'1\\') {\\n    \\t\\tbits.setCharAt(idx, \\'0\\');\\n    \\t\\treverse.setCharAt(idx, \\'1\\');\\n    \\t\\tcountOne--;\\n    \\t}\\n    }\\n    \\n    public void flip() {\\n        StringBuilder temp = reverse;\\n        reverse = bits;\\n        bits = temp;\\n        countOne = bits.length() - countOne;\\n    }\\n    \\n    public boolean all() {\\n        return countOne==bits.length();\\n    }\\n    \\n    public boolean one() {\\n        return countOne > 0;\\n    }\\n    \\n    public int count() {\\n        return countOne;\\n    }\\n    \\n    public String toString() {\\n        return bits.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "Got tons of TLE submission in the contest, but finally I\\'ve gone through it then \\uD83D\\uDE14\\uD83D\\uDE14. I think the main problem avoiding TLE of this question is to optimize the `flip()` function. I do this by using one more StringBuilder to store the reversed version of our main bitset\\n```\\nclass Bitset {\\n\\tStringBuilder bits;\\n\\tStringBuilder reverse;\\n\\tint countOne;\\n\\n    public Bitset(int size) {\\n        bits = new StringBuilder();\\n        reverse = new StringBuilder();\\n        while(size>0) {\\n        \\tbits.append(\\'0\\');\\n        \\treverse.append(\\'1\\');\\n        \\tsize--;\\n        }\\n        countOne = 0;\\n    }\\n    \\n    public void fix(int idx) {\\n    \\tif(bits.charAt(idx)==\\'0\\') {\\n    \\t\\tbits.setCharAt(idx, \\'1\\');\\n    \\t\\treverse.setCharAt(idx, \\'0\\');\\n    \\t\\tcountOne++;\\n    \\t}\\n    }\\n    \\n    public void unfix(int idx) {\\n    \\tif(bits.charAt(idx)==\\'1\\') {\\n    \\t\\tbits.setCharAt(idx, \\'0\\');\\n    \\t\\treverse.setCharAt(idx, \\'1\\');\\n    \\t\\tcountOne--;\\n    \\t}\\n    }\\n    \\n    public void flip() {\\n        StringBuilder temp = reverse;\\n        reverse = bits;\\n        bits = temp;\\n        countOne = bits.length() - countOne;\\n    }\\n    \\n    public boolean all() {\\n        return countOne==bits.length();\\n    }\\n    \\n    public boolean one() {\\n        return countOne > 0;\\n    }\\n    \\n    public int count() {\\n        return countOne;\\n    }\\n    \\n    public String toString() {\\n        return bits.toString();\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1748885,
                "title": "python-o-1-very-easy-solution",
                "content": "I have taken two bitset. According to code, bitset2 is anti-bitset1 (i.e. bitset1[i] != bitset2[i], eg: bitset1 = [000001], bitset2 = [111110]). printline is commented(uncomment it and run code. You will understand).\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bitset1 = [\"0\"]*size\\n        self.bitset2 = [\"1\"]*size\\n        self.size = size\\n        self.count1 = 0\\n        self.count2 = size\\n\\n    def fix(self, idx: int) -> None:\\n        if self.bitset1[idx] == \"0\":\\n            self.count1 +=1\\n        if self.bitset2[idx] == \"1\":\\n            self.count2 -=1\\n        self.bitset1[idx] = \"1\"\\n        self.bitset2[idx] = \"0\"\\n        # print(\"fix\",  self.bitset1, self.count1, self.count2)\\n        # print(\"fix\",  self.bitset2, self.count1, self.count2)\\n        # print(\" \")\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.bitset1[idx] == \"1\":\\n            self.count1 -=1\\n        if self.bitset2[idx] == \"0\":\\n            self.count2 +=1\\n        self.bitset1[idx] = \"0\"\\n        self.bitset2[idx] = \"1\"\\n        # print(\"unfix\", self.bitset1, self.count1, self.count2)\\n        # print(\"unfix\", self.bitset2, self.count1, self.count2)\\n        # print(\" \")\\n\\n    def flip(self) -> None:\\n        self.bitset1, self.bitset2 = self.bitset2, self.bitset1\\n        self.count1, self.count2 = self.count2, self.count1\\n\\n        # print(\"flip\", self.bitset1, self.count1, self.count2)\\n\\n    def all(self) -> bool:\\n        # print(\"all\", self.count1, self.count2)\\n        if self.count1 == self.size:\\n            return True\\n        else: \\n            return False\\n\\n    def one(self) -> bool:\\n        # print(\"one\", self.count1, self.count2)\\n        if self.count1 >0:\\n            return True\\n        else: \\n            return False\\n\\n\\n    def count(self) -> int:\\n        # print(\"count\", self.count1, self.count2)\\n        return self.count1\\n\\n    def toString(self) -> str:\\n        return \"\".join(self.bitset1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bitset1 = [\"0\"]*size\\n        self.bitset2 = [\"1\"]*size\\n        self.size = size\\n        self.count1 = 0\\n        self.count2 = size\\n\\n    def fix(self, idx: int) -> None:\\n        if self.bitset1[idx] == \"0\":\\n            self.count1 +=1\\n        if self.bitset2[idx] == \"1\":\\n            self.count2 -=1\\n        self.bitset1[idx] = \"1\"\\n        self.bitset2[idx] = \"0\"\\n        # print(\"fix\",  self.bitset1, self.count1, self.count2)\\n        # print(\"fix\",  self.bitset2, self.count1, self.count2)\\n        # print(\" \")\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.bitset1[idx] == \"1\":\\n            self.count1 -=1\\n        if self.bitset2[idx] == \"0\":\\n            self.count2 +=1\\n        self.bitset1[idx] = \"0\"\\n        self.bitset2[idx] = \"1\"\\n        # print(\"unfix\", self.bitset1, self.count1, self.count2)\\n        # print(\"unfix\", self.bitset2, self.count1, self.count2)\\n        # print(\" \")\\n\\n    def flip(self) -> None:\\n        self.bitset1, self.bitset2 = self.bitset2, self.bitset1\\n        self.count1, self.count2 = self.count2, self.count1\\n\\n        # print(\"flip\", self.bitset1, self.count1, self.count2)\\n\\n    def all(self) -> bool:\\n        # print(\"all\", self.count1, self.count2)\\n        if self.count1 == self.size:\\n            return True\\n        else: \\n            return False\\n\\n    def one(self) -> bool:\\n        # print(\"one\", self.count1, self.count2)\\n        if self.count1 >0:\\n            return True\\n        else: \\n            return False\\n\\n\\n    def count(self) -> int:\\n        # print(\"count\", self.count1, self.count2)\\n        return self.count1\\n\\n    def toString(self) -> str:\\n        return \"\".join(self.bitset1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748866,
                "title": "c-o-1-for-all-operations-including-tostring",
                "content": "To save time for the `toString()`, we can use `string main_str`, data structure instead of a `vector<bool>`.\\n\\n`c` = #set bits in the bitset\\n\\nWe create another `string sub_str`, which stores the complement of the `main_str`. With that said, the time complexity of all operations is O(1).\\n\\n\\n```\\nclass Bitset {\\npublic:\\n    string main_str;\\n    string sub_str;\\n    int c;\\n    Bitset(int size) {\\n        main_str = string(size, \\'0\\');\\n        sub_str = string(size, \\'1\\');\\n        c = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(main_str[idx] == \\'0\\') {\\n            main_str[idx] = \\'1\\';\\n            sub_str[idx] = \\'0\\';\\n            c++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(main_str[idx] == \\'1\\') {\\n            main_str[idx] = \\'0\\';\\n            sub_str[idx] = \\'1\\';\\n            c--;\\n        }\\n    }\\n    \\n    \\n    void flip() {\\n        main_str.swap(sub_str);\\n        c = main_str.size() - c;\\n    }\\n    \\n    bool all() {\\n        return c == main_str.size();\\n    }\\n    \\n    bool one() {\\n        return c > 0;\\n    }\\n    \\n    int count() {\\n        return c;\\n    }\\n    \\n    string toString() {\\n        return main_str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    string main_str;\\n    string sub_str;\\n    int c;\\n    Bitset(int size) {\\n        main_str = string(size, \\'0\\');\\n        sub_str = string(size, \\'1\\');\\n        c = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(main_str[idx] == \\'0\\') {\\n            main_str[idx] = \\'1\\';\\n            sub_str[idx] = \\'0\\';\\n            c++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(main_str[idx] == \\'1\\') {\\n            main_str[idx] = \\'0\\';\\n            sub_str[idx] = \\'1\\';\\n            c--;\\n        }\\n    }\\n    \\n    \\n    void flip() {\\n        main_str.swap(sub_str);\\n        c = main_str.size() - c;\\n    }\\n    \\n    bool all() {\\n        return c == main_str.size();\\n    }\\n    \\n    bool one() {\\n        return c > 0;\\n    }\\n    \\n    int count() {\\n        return c;\\n    }\\n    \\n    string toString() {\\n        return main_str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748792,
                "title": "c-o-1-for-every-operation-except-tostring-with-explanation",
                "content": "1. use a vector f to maintain how many flips this element need to become its value now (actually use the value (f[idx]+flips))\\n2. use a single varieble flips to maintain how many flips for all the bitset.\\n3. in function fix:  if(( f[idx] + flips) % 2 == 0) means the current element at index idx is 0, so we need to modify this bit.\\n4. use the vector f + how many flip operation has done so far to convert the string.\\n\\n```\\nclass Bitset {\\npublic:\\n    vector<int> f;\\n    int cnt = 0, flips = 0;\\n    Bitset(int size) {\\n        for( int i = 0; i < size; i++){\\n            f.push_back(0);\\n        }\\n    }\\n    \\n    void fix(int idx) {\\n        if(( f[idx] + flips) % 2 == 0){\\n            cnt++;\\n            f[idx]++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(( f[idx] + flips) % 2 == 1) {\\n            cnt--;\\n            f[idx]++;\\n        }\\n    }\\n    \\n    void flip() {\\n        cnt = f.size() - cnt;\\n        flips++;\\n    }\\n    \\n    bool all() {\\n        if( cnt != f.size()) return 0;\\n        else return 1;\\n        \\n    }\\n    \\n    bool one() {\\n         return cnt != 0;\\n    }\\n    \\n    int count() {\\n\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        string res = \"\";\\n        for(auto a:f){\\n            if( (a + flips) % 2 == 0 ) res += \"0\";\\n            else res += \"1\";\\n        }\\n        return res;\\n    }\\n};\\n```\\nplease upvote if you think this helps.",
                "solutionTags": [],
                "code": "```\\nclass Bitset {\\npublic:\\n    vector<int> f;\\n    int cnt = 0, flips = 0;\\n    Bitset(int size) {\\n        for( int i = 0; i < size; i++){\\n            f.push_back(0);\\n        }\\n    }\\n    \\n    void fix(int idx) {\\n        if(( f[idx] + flips) % 2 == 0){\\n            cnt++;\\n            f[idx]++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(( f[idx] + flips) % 2 == 1) {\\n            cnt--;\\n            f[idx]++;\\n        }\\n    }\\n    \\n    void flip() {\\n        cnt = f.size() - cnt;\\n        flips++;\\n    }\\n    \\n    bool all() {\\n        if( cnt != f.size()) return 0;\\n        else return 1;\\n        \\n    }\\n    \\n    bool one() {\\n         return cnt != 0;\\n    }\\n    \\n    int count() {\\n\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        string res = \"\";\\n        for(auto a:f){\\n            if( (a + flips) % 2 == 0 ) res += \"0\";\\n            else res += \"1\";\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748777,
                "title": "c-o-1-for-everything-best-solution",
                "content": "string s;\\n    int ones=0,zero=0;\\n    int f=0;\\n    Bitset(int size) {\\n        zero=size;\\n        for(int i=0;i<size;i++)\\n            s.push_back(\\'0\\');\\n    }\\n    \\n    void fix(int idx) {\\n        if(s[idx]==\\'0\\'&&f==0)\\n        {\\n            zero--;\\n            ones++;\\n        }\\n        if(s[idx]==\\'1\\'&&f==1)\\n        {\\n            zero--;\\n            ones++;\\n        }\\n        if(f)\\n        s[idx]=\\'0\\';\\n        else\\n        s[idx]=\\'1\\';\\n    }\\n    \\n    void unfix(int idx) {\\n        if(s[idx]==\\'1\\'&&f==0)\\n        {\\n            zero++;\\n            ones--;\\n        }\\n        if(s[idx]==\\'0\\'&&f==1)\\n        {\\n            zero++;\\n            ones--;\\n        }\\n        if(f)\\n        s[idx]=\\'1\\';\\n        else\\n        s[idx]=\\'0\\';\\n    }\\n    \\n    void flip() {\\n        \\n        swap(zero,ones);\\n        f=1-f;\\n    }\\n    \\n    bool all() {\\n            if(zero>0)\\n                return false;\\n        return true;\\n    }\\n    \\n    bool one() {\\n            if(ones>0)\\n                return true;\\n        return false;\\n        \\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        if(f)\\n        {\\n            for(auto &x:s)\\n                if(x==\\'1\\') x=\\'0\\';\\n                    else x=\\'1\\';\\n            f=0;\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "string s;\\n    int ones=0,zero=0;\\n    int f=0;\\n    Bitset(int size) {\\n        zero=size;\\n        for(int i=0;i<size;i++)\\n            s.push_back(\\'0\\');\\n    }\\n    \\n    void fix(int idx) {\\n        if(s[idx]==\\'0\\'&&f==0)\\n        {\\n            zero--;\\n            ones++;\\n        }\\n        if(s[idx]==\\'1\\'&&f==1)\\n        {\\n            zero--;\\n            ones++;\\n        }\\n        if(f)\\n        s[idx]=\\'0\\';\\n        else\\n        s[idx]=\\'1\\';\\n    }\\n    \\n    void unfix(int idx) {\\n        if(s[idx]==\\'1\\'&&f==0)\\n        {\\n            zero++;\\n            ones--;\\n        }\\n        if(s[idx]==\\'0\\'&&f==1)\\n        {\\n            zero++;\\n            ones--;\\n        }\\n        if(f)\\n        s[idx]=\\'1\\';\\n        else\\n        s[idx]=\\'0\\';\\n    }\\n    \\n    void flip() {\\n        \\n        swap(zero,ones);\\n        f=1-f;\\n    }\\n    \\n    bool all() {\\n            if(zero>0)\\n                return false;\\n        return true;\\n    }\\n    \\n    bool one() {\\n            if(ones>0)\\n                return true;\\n        return false;\\n        \\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        if(f)\\n        {\\n            for(auto &x:s)\\n                if(x==\\'1\\') x=\\'0\\';\\n                    else x=\\'1\\';\\n            f=0;\\n        }\\n        return s;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1748760,
                "title": "clean-c-using-bitset",
                "content": "```\\nclass Bitset {\\nprivate:\\n        int zerosCount;\\n        int onesCount;\\n        int size;\\n        bitset <100000> arr;\\n    \\n    public:\\n\\n    Bitset(int size) {\\n        this->size = size; \\n        zerosCount = size;\\n        onesCount = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        int actualIdx = size-idx-1;\\n        if (arr[actualIdx] == 0) {\\n            arr[actualIdx] = 1;\\n            onesCount++;\\n            zerosCount--;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        int actualIdx = size-idx-1;\\n        if (arr[actualIdx] == 1) {\\n            arr[actualIdx] = 0;\\n            onesCount--;\\n            zerosCount++;\\n            \\n        }\\n    }\\n    \\n    void flip() {\\n        swap(zerosCount, onesCount);\\n        arr.flip();    \\n    }\\n    \\n    bool all() {\\n        return onesCount == size;\\n    }\\n    \\n    bool one() {\\n        return onesCount > 0;\\n    }\\n    \\n    int count() {\\n        return onesCount;\\n    }\\n    \\n    string toString() {\\n        int idx = 100000-size;\\n        string ans = arr.to_string();\\n        string fans = ans.substr(idx);\\n        return fans;\\n    }\\n};\\n\\n/*\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```\\n\\nAn even better approach has been explained here : https://leetcode.com/problems/design-bitset/discuss/1748463/c-solution-with-explanation/1254095",
                "solutionTags": [],
                "code": "```\\nclass Bitset {\\nprivate:\\n        int zerosCount;\\n        int onesCount;\\n        int size;\\n        bitset <100000> arr;\\n    \\n    public:\\n\\n    Bitset(int size) {\\n        this->size = size; \\n        zerosCount = size;\\n        onesCount = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        int actualIdx = size-idx-1;\\n        if (arr[actualIdx] == 0) {\\n            arr[actualIdx] = 1;\\n            onesCount++;\\n            zerosCount--;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        int actualIdx = size-idx-1;\\n        if (arr[actualIdx] == 1) {\\n            arr[actualIdx] = 0;\\n            onesCount--;\\n            zerosCount++;\\n            \\n        }\\n    }\\n    \\n    void flip() {\\n        swap(zerosCount, onesCount);\\n        arr.flip();    \\n    }\\n    \\n    bool all() {\\n        return onesCount == size;\\n    }\\n    \\n    bool one() {\\n        return onesCount > 0;\\n    }\\n    \\n    int count() {\\n        return onesCount;\\n    }\\n    \\n    string toString() {\\n        int idx = 100000-size;\\n        string ans = arr.to_string();\\n        string fans = ans.substr(idx);\\n        return fans;\\n    }\\n};\\n\\n/*\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748739,
                "title": "o-1-except-for-initialization-100-faster",
                "content": "\\n```\\nclass Bitset {\\npublic:\\n    string bits1,bits2;\\n    int ones;\\n    int n;\\n    Bitset(int size) {\\n        n = size;\\n        for (int i=0;i<size;i++){\\n            bits1 += \"0\";\\n            bits2 += \"1\";\\n        }\\n        ones = 0;\\n    } \\n    \\n    void fix(int idx) {\\n        if (bits1[idx]==\\'1\\')\\n            return;\\n        bits1[idx] = \\'1\\';\\n        bits2[idx] = \\'0\\';\\n        ones++;\\n    }\\n    \\n    void unfix(int idx) {\\n        if (bits1[idx]==\\'0\\')\\n            return;\\n        bits1[idx] = \\'0\\';\\n        bits2[idx] = \\'1\\';\\n        ones--;\\n    }\\n    \\n    void flip() {\\n        ones = n - ones;\\n        bits1.swap(bits2);\\n    }\\n    \\n    bool all() {\\n        return (ones == n);\\n    }\\n    \\n    bool one() {\\n        return (ones > 0);\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        return bits1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    string bits1,bits2;\\n    int ones;\\n    int n;\\n    Bitset(int size) {\\n        n = size;\\n        for (int i=0;i<size;i++){\\n            bits1 += \"0\";\\n            bits2 += \"1\";\\n        }\\n        ones = 0;\\n    } \\n    \\n    void fix(int idx) {\\n        if (bits1[idx]==\\'1\\')\\n            return;\\n        bits1[idx] = \\'1\\';\\n        bits2[idx] = \\'0\\';\\n        ones++;\\n    }\\n    \\n    void unfix(int idx) {\\n        if (bits1[idx]==\\'0\\')\\n            return;\\n        bits1[idx] = \\'0\\';\\n        bits2[idx] = \\'1\\';\\n        ones--;\\n    }\\n    \\n    void flip() {\\n        ones = n - ones;\\n        bits1.swap(bits2);\\n    }\\n    \\n    bool all() {\\n        return (ones == n);\\n    }\\n    \\n    bool one() {\\n        return (ones > 0);\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        return bits1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748738,
                "title": "simplest-logic-all-operations-o-1",
                "content": "```\\nclass Bitset {\\npublic:\\n    string s,rev;\\n    int n,ones;\\n    bool f;\\n    Bitset(int size) {\\n        n = size;\\n        string st(n,\\'0\\');\\n        string rt(n,\\'1\\');\\n        s = st;\\n        rev = rt;\\n        ones = 0;\\n        f = true; //true means s, false means rev\\n    }\\n    \\n    void fix(int idx) {\\n        if(f){\\n            if(s[idx]==\\'1\\') return;\\n            s[idx] = \\'1\\';\\n            rev[idx] = \\'0\\';\\n            ones++;\\n        }\\n        else{\\n            if(rev[idx]==\\'1\\') return;\\n            rev[idx] = \\'1\\';\\n            s[idx] = \\'0\\';\\n            ones++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(f){\\n            if(s[idx]==\\'0\\') return;\\n            s[idx] = \\'0\\';\\n            rev[idx] = \\'1\\';\\n            ones--;\\n        }\\n        else{\\n            if(rev[idx]==\\'0\\') return;\\n            rev[idx] = \\'0\\';\\n            s[idx] = \\'1\\';\\n            ones--;\\n        }\\n    }\\n    \\n    void flip() {\\n        f = !f;\\n        ones = n - ones;\\n    }\\n    \\n    bool all() {\\n        return ones==n;\\n    }\\n    \\n    bool one() {\\n        return ones>0;\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        if(f) return s;\\n        else return rev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    string s,rev;\\n    int n,ones;\\n    bool f;\\n    Bitset(int size) {\\n        n = size;\\n        string st(n,\\'0\\');\\n        string rt(n,\\'1\\');\\n        s = st;\\n        rev = rt;\\n        ones = 0;\\n        f = true; //true means s, false means rev\\n    }\\n    \\n    void fix(int idx) {\\n        if(f){\\n            if(s[idx]==\\'1\\') return;\\n            s[idx] = \\'1\\';\\n            rev[idx] = \\'0\\';\\n            ones++;\\n        }\\n        else{\\n            if(rev[idx]==\\'1\\') return;\\n            rev[idx] = \\'1\\';\\n            s[idx] = \\'0\\';\\n            ones++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(f){\\n            if(s[idx]==\\'0\\') return;\\n            s[idx] = \\'0\\';\\n            rev[idx] = \\'1\\';\\n            ones--;\\n        }\\n        else{\\n            if(rev[idx]==\\'0\\') return;\\n            rev[idx] = \\'0\\';\\n            s[idx] = \\'1\\';\\n            ones--;\\n        }\\n    }\\n    \\n    void flip() {\\n        f = !f;\\n        ones = n - ones;\\n    }\\n    \\n    bool all() {\\n        return ones==n;\\n    }\\n    \\n    bool one() {\\n        return ones>0;\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        if(f) return s;\\n        else return rev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748714,
                "title": "c-using-bitset-inbuilt",
                "content": "\\n```\\nclass Bitset {\\n    bitset<100000> bset;\\n    int n;\\n    int cnt;\\npublic:\\n    Bitset(int size) {\\n        n = size;\\n        cnt = 0;\\n    }\\n    \\n    void fix(int idx) {\\n\\t//because bitsets indices start from the LSB\\n        if(bset[n-1-idx] == 0) cnt++;\\n        bset[n-1-idx] = 1;\\n    }\\n    \\n    void unfix(int idx) {\\n\\t//I have updated cnt in every bit related operation\\n        if(bset[n-1-idx] == 1) cnt--;\\n        bset[n-1-idx] = 0;\\n    }\\n    \\n    void flip() {\\n        bset = ~bset;\\n        cnt = (n-cnt);\\n    }\\n    \\n    bool all() {\\n        if(cnt == n) return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n        if(cnt) return true;\\n        return false;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        string s(n, \\'0\\');\\n        for(int i=0; i<n; i++){\\n\\t\\t//once again...indices in bitset objects start from the LSB\\n            s[i] = bset[n-1-i] + \\'0\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Bitset {\\n    bitset<100000> bset;\\n    int n;\\n    int cnt;\\npublic:\\n    Bitset(int size) {\\n        n = size;\\n        cnt = 0;\\n    }\\n    \\n    void fix(int idx) {\\n\\t//because bitsets indices start from the LSB\\n        if(bset[n-1-idx] == 0) cnt++;\\n        bset[n-1-idx] = 1;\\n    }\\n    \\n    void unfix(int idx) {\\n\\t//I have updated cnt in every bit related operation\\n        if(bset[n-1-idx] == 1) cnt--;\\n        bset[n-1-idx] = 0;\\n    }\\n    \\n    void flip() {\\n        bset = ~bset;\\n        cnt = (n-cnt);\\n    }\\n    \\n    bool all() {\\n        if(cnt == n) return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n        if(cnt) return true;\\n        return false;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        string s(n, \\'0\\');\\n        for(int i=0; i<n; i++){\\n\\t\\t//once again...indices in bitset objects start from the LSB\\n            s[i] = bset[n-1-i] + \\'0\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748665,
                "title": "java-o-1-for-every-operation-except-tostring-space-optimised",
                "content": "```\\nclass Bitset {\\n    char[] bitset;\\n    int count;\\n    char z;\\n    char o;\\n    \\n    public Bitset(int size) {\\n        bitset = new char[size];\\n        z = \\'0\\';\\n        o = \\'1\\';\\n        Arrays.fill(bitset, z);\\n        count = 0;\\n    }\\n    \\n    public void fix(int idx) {\\n        if(bitset[idx] != o)\\n            count++;\\n        \\n        bitset[idx] = o;\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(bitset[idx] == o)\\n            count--;\\n        \\n        bitset[idx] = z;\\n    }\\n    \\n    public void flip() {\\n        count = bitset.length - count;\\n        \\n        char t = z;\\n        z = o;\\n        o = t;\\n    }\\n    \\n    public boolean all() {\\n        return count == bitset.length;\\n    }\\n    \\n    public boolean one() {\\n        return count > 0;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n    \\n    public String toString() {\\n        if(z == \\'0\\')\\n            return new String(bitset);\\n        \\n        char[] bit = new char[bitset.length];\\n\\n        for(int i = 0; i < bitset.length; i++) {\\n            if(bitset[i] == z)\\n                bit[i] = o;\\n            else\\n                bit[i] = z;\\n        }\\n        \\n        return new String(bit);\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n ```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Bitset {\\n    char[] bitset;\\n    int count;\\n    char z;\\n    char o;\\n    \\n    public Bitset(int size) {\\n        bitset = new char[size];\\n        z = \\'0\\';\\n        o = \\'1\\';\\n        Arrays.fill(bitset, z);\\n        count = 0;\\n    }\\n    \\n    public void fix(int idx) {\\n        if(bitset[idx] != o)\\n            count++;\\n        \\n        bitset[idx] = o;\\n    }\\n    \\n    public void unfix(int idx) {\\n        if(bitset[idx] == o)\\n            count--;\\n        \\n        bitset[idx] = z;\\n    }\\n    \\n    public void flip() {\\n        count = bitset.length - count;\\n        \\n        char t = z;\\n        z = o;\\n        o = t;\\n    }\\n    \\n    public boolean all() {\\n        return count == bitset.length;\\n    }\\n    \\n    public boolean one() {\\n        return count > 0;\\n    }\\n    \\n    public int count() {\\n        return count;\\n    }\\n    \\n    public String toString() {\\n        if(z == \\'0\\')\\n            return new String(bitset);\\n        \\n        char[] bit = new char[bitset.length];\\n\\n        for(int i = 0; i < bitset.length; i++) {\\n            if(bitset[i] == z)\\n                bit[i] = o;\\n            else\\n                bit[i] = z;\\n        }\\n        \\n        return new String(bit);\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1748564,
                "title": "typescript",
                "content": "Complicated solution... but the idea is to keep track of the number of ones by finding the true value of the bit before fix/unfix.  Real value is found by tracking the \"time\" (using a counter) for each fix/unfix and for each flip...and then applying all flips since the last time the bit was set.\\n```\\nclass Bitset {\\n    private bits: number[]\\n    private ones: number;\\n    private flips: number[];\\n    private counter: number;\\n    private touched: number[];\\n    \\n    constructor(size: number) {\\n        this.ones = 0;\\n        this.bits = Array(size).fill(0)\\n        this.flips = []\\n        this.counter = 0\\n        this.touched = Array(size).fill(-1)\\n    }\\n\\n    private findFirstFlip(target: number): number {\\n        const flips = this.flips\\n        let left = 0\\n        let right = flips.length - 1\\n        \\n        while (left <= right) {\\n            const mid = left + Math.floor((right - left) / 2)\\n        \\n            const value = flips[mid]\\n            if (value === target) {\\n                return mid\\n            }\\n\\n            if (value < target) {\\n                left = mid + 1\\n            } else {\\n                right = mid - 1\\n            }\\n        }\\n        \\n        return left\\n    }\\n\\n    fix(idx: number): void {\\n        // find current state\\n        const currValue = this.bits[idx]\\n        if (this.touched[idx] === -1) {\\n            this.touched[idx] = ++this.counter\\n            \\n            if (this.flips.length % 2 === 0) {\\n                this.ones++\\n            }\\n            \\n            this.bits[idx] = 1\\n            \\n            return\\n        }\\n\\n        // find flips since that value was set\\n        const firstFlip = this.findFirstFlip(this.touched[idx])\\n        const totalFlips = firstFlip === this.flips.length ? 0 : ((this.flips.length - firstFlip) % 2)\\n        \\n        const currFlippedValue = Math.abs(currValue - totalFlips)\\n        if (!currFlippedValue) {\\n            this.ones++\\n        }\\n\\n        this.touched[idx] = ++this.counter\\n        this.bits[idx] = 1\\n    }\\n\\n    unfix(idx: number): void {\\n        // find current state\\n        const currValue = this.bits[idx]\\n        if (this.touched[idx] === -1) {\\n            this.touched[idx] = ++this.counter\\n            if (this.flips.length % 2 === 1) {\\n                this.ones--\\n            }            \\n            return\\n        }\\n        \\n\\n        // find flips since that value was set\\n        const firstFlip = this.findFirstFlip(this.touched[idx])\\n        const totalFlips = firstFlip === this.flips.length ? 0 : ((this.flips.length - firstFlip) % 2)\\n        \\n        const currFlippedValue = Math.abs(currValue - totalFlips)\\n        if (currFlippedValue) {\\n            this.ones--\\n        }\\n\\n        this.touched[idx] = ++this.counter\\n        this.bits[idx] = 0\\n    }\\n\\n    flip(): void {\\n        this.flips.push(++this.counter)\\n        this.ones = Math.abs(this.bits.length - this.ones)\\n    }\\n\\n    all(): boolean {\\n        return this.ones === this.bits.length\\n    }\\n\\n    one(): boolean {\\n        return this.ones > 0\\n    }\\n\\n    count(): number {\\n        return this.ones\\n    }\\n\\n    toString(): string {\\n        const values = []\\n        for (let i = 0; i < this.bits.length; i++) {\\n            let value = this.bits[i]\\n            const firstFlip = this.findFirstFlip(this.touched[i])\\n            if (firstFlip < this.flips.length) {\\n                const totalFlips = (this.flips.length - firstFlip) % 2\\n                const currFlippedValue = Math.abs(value - totalFlips)\\n                values.push(currFlippedValue)                \\n            } else {\\n                values.push(value)\\n            }\\n\\n        }\\n        return values.join(\\'\\')\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Bitset {\\n    private bits: number[]\\n    private ones: number;\\n    private flips: number[];\\n    private counter: number;\\n    private touched: number[];\\n    \\n    constructor(size: number) {\\n        this.ones = 0;\\n        this.bits = Array(size).fill(0)\\n        this.flips = []\\n        this.counter = 0\\n        this.touched = Array(size).fill(-1)\\n    }\\n\\n    private findFirstFlip(target: number): number {\\n        const flips = this.flips\\n        let left = 0\\n        let right = flips.length - 1\\n        \\n        while (left <= right) {\\n            const mid = left + Math.floor((right - left) / 2)\\n        \\n            const value = flips[mid]\\n            if (value === target) {\\n                return mid\\n            }\\n\\n            if (value < target) {\\n                left = mid + 1\\n            } else {\\n                right = mid - 1\\n            }\\n        }\\n        \\n        return left\\n    }\\n\\n    fix(idx: number): void {\\n        // find current state\\n        const currValue = this.bits[idx]\\n        if (this.touched[idx] === -1) {\\n            this.touched[idx] = ++this.counter\\n            \\n            if (this.flips.length % 2 === 0) {\\n                this.ones++\\n            }\\n            \\n            this.bits[idx] = 1\\n            \\n            return\\n        }\\n\\n        // find flips since that value was set\\n        const firstFlip = this.findFirstFlip(this.touched[idx])\\n        const totalFlips = firstFlip === this.flips.length ? 0 : ((this.flips.length - firstFlip) % 2)\\n        \\n        const currFlippedValue = Math.abs(currValue - totalFlips)\\n        if (!currFlippedValue) {\\n            this.ones++\\n        }\\n\\n        this.touched[idx] = ++this.counter\\n        this.bits[idx] = 1\\n    }\\n\\n    unfix(idx: number): void {\\n        // find current state\\n        const currValue = this.bits[idx]\\n        if (this.touched[idx] === -1) {\\n            this.touched[idx] = ++this.counter\\n            if (this.flips.length % 2 === 1) {\\n                this.ones--\\n            }            \\n            return\\n        }\\n        \\n\\n        // find flips since that value was set\\n        const firstFlip = this.findFirstFlip(this.touched[idx])\\n        const totalFlips = firstFlip === this.flips.length ? 0 : ((this.flips.length - firstFlip) % 2)\\n        \\n        const currFlippedValue = Math.abs(currValue - totalFlips)\\n        if (currFlippedValue) {\\n            this.ones--\\n        }\\n\\n        this.touched[idx] = ++this.counter\\n        this.bits[idx] = 0\\n    }\\n\\n    flip(): void {\\n        this.flips.push(++this.counter)\\n        this.ones = Math.abs(this.bits.length - this.ones)\\n    }\\n\\n    all(): boolean {\\n        return this.ones === this.bits.length\\n    }\\n\\n    one(): boolean {\\n        return this.ones > 0\\n    }\\n\\n    count(): number {\\n        return this.ones\\n    }\\n\\n    toString(): string {\\n        const values = []\\n        for (let i = 0; i < this.bits.length; i++) {\\n            let value = this.bits[i]\\n            const firstFlip = this.findFirstFlip(this.touched[i])\\n            if (firstFlip < this.flips.length) {\\n                const totalFlips = (this.flips.length - firstFlip) % 2\\n                const currFlippedValue = Math.abs(value - totalFlips)\\n                values.push(currFlippedValue)                \\n            } else {\\n                values.push(value)\\n            }\\n\\n        }\\n        return values.join(\\'\\')\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748538,
                "title": "easy-to-understand-with-one-set",
                "content": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        \\n        self.l = [\"ones\", set()]\\n        self.size = size\\n\\n    def fix(self, idx: int) -> None:\\n        \\n        if self.l[0] == \"ones\" :\\n            self.l[1].add(idx)\\n        \\n        else:\\n            if idx in self.l[1] :\\n                self.l[1].remove(idx)\\n\\n        \\n    def unfix(self, idx: int) -> None:\\n        \\n        if self.l[0] == \"ones\" :\\n            if idx in self.l[1] :\\n                self.l[1].remove(idx)\\n        else:\\n            self.l[1].add(idx)\\n            \\n        \\n    def flip(self) -> None:\\n        \\n        if self.l[0] == \"ones\" :\\n            self.l[0] = \"zeros\"\\n        else:\\n            self.l[0] = \"ones\"\\n        \\n    def all(self) -> bool:\\n        \\n        if self.l[0] == \"ones\" :\\n            return  len(self.l[1]) == self.size \\n        \\n        else:\\n            return len(self.l[1]) == 0\\n            \\n\\n    def one(self) -> bool:\\n        \\n        if self.l[0] == \"ones\" :\\n            return len(self.l[1])>0\\n        \\n        else:\\n            return len(self.l[1])<self.size\\n        \\n        \\n    def count(self) -> int:\\n        \\n        if self.l[0] == \"ones\" :\\n            return len(self.l[1])\\n        \\n        else:\\n            return self.size - len(self.l[1])\\n\\n    def toString(self) -> str:\\n        \\n        \\n        if self.l[0] == \"ones\" :\\n            res = \"\"\\n            for i in range(self.size) :\\n                if i in self.l[1] :\\n                    res += \"1\"\\n                else:\\n                    res += \"0\"\\n            return res\\n        else:\\n            res = \"\"\\n            for i in range(self.size) :\\n                if i in self.l[1] :\\n                    res += \"0\"\\n                else:\\n                    res += \"1\"\\n            return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        \\n        self.l = [\"ones\", set()]\\n        self.size = size\\n\\n    def fix(self, idx: int) -> None:\\n        \\n        if self.l[0] == \"ones\" :\\n            self.l[1].add(idx)\\n        \\n        else:\\n            if idx in self.l[1] :\\n                self.l[1].remove(idx)\\n\\n        \\n    def unfix(self, idx: int) -> None:\\n        \\n        if self.l[0] == \"ones\" :\\n            if idx in self.l[1] :\\n                self.l[1].remove(idx)\\n        else:\\n            self.l[1].add(idx)\\n            \\n        \\n    def flip(self) -> None:\\n        \\n        if self.l[0] == \"ones\" :\\n            self.l[0] = \"zeros\"\\n        else:\\n            self.l[0] = \"ones\"\\n        \\n    def all(self) -> bool:\\n        \\n        if self.l[0] == \"ones\" :\\n            return  len(self.l[1]) == self.size \\n        \\n        else:\\n            return len(self.l[1]) == 0\\n            \\n\\n    def one(self) -> bool:\\n        \\n        if self.l[0] == \"ones\" :\\n            return len(self.l[1])>0\\n        \\n        else:\\n            return len(self.l[1])<self.size\\n        \\n        \\n    def count(self) -> int:\\n        \\n        if self.l[0] == \"ones\" :\\n            return len(self.l[1])\\n        \\n        else:\\n            return self.size - len(self.l[1])\\n\\n    def toString(self) -> str:\\n        \\n        \\n        if self.l[0] == \"ones\" :\\n            res = \"\"\\n            for i in range(self.size) :\\n                if i in self.l[1] :\\n                    res += \"1\"\\n                else:\\n                    res += \"0\"\\n            return res\\n        else:\\n            res = \"\"\\n            for i in range(self.size) :\\n                if i in self.l[1] :\\n                    res += \"0\"\\n                else:\\n                    res += \"1\"\\n            return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748534,
                "title": "python-just-two-buckets-of-zeros-and-ones",
                "content": "\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.ones = set()\\n        self.zeros = set(range(size))\\n        self.size = size\\n    \\n    def fix(self, idx: int) -> None:\\n        self.ones.add(idx)\\n        self.zeros.discard(idx)\\n\\n    def unfix(self, idx: int) -> None:\\n        self.ones.discard(idx)\\n        self.zeros.add(idx)\\n\\n    def flip(self) -> None:\\n        self.ones,self.zeros = self.zeros,self.ones\\n\\n    def all(self) -> bool:\\n        return len(self.zeros) == 0\\n\\n    def one(self) -> bool:\\n        return len(self.ones) != 0\\n\\n    def count(self) -> int:\\n        return len(self.ones)\\n\\n    def toString(self) -> str:\\n        answer = [\\'0\\']*self.size\\n        for val in self.ones: answer[val] = \\'1\\'\\n        return \\'\\'.join(answer)\\n        \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.ones = set()\\n        self.zeros = set(range(size))\\n        self.size = size\\n    \\n    def fix(self, idx: int) -> None:\\n        self.ones.add(idx)\\n        self.zeros.discard(idx)\\n\\n    def unfix(self, idx: int) -> None:\\n        self.ones.discard(idx)\\n        self.zeros.add(idx)\\n\\n    def flip(self) -> None:\\n        self.ones,self.zeros = self.zeros,self.ones\\n\\n    def all(self) -> bool:\\n        return len(self.zeros) == 0\\n\\n    def one(self) -> bool:\\n        return len(self.ones) != 0\\n\\n    def count(self) -> int:\\n        return len(self.ones)\\n\\n    def toString(self) -> str:\\n        answer = [\\'0\\']*self.size\\n        for val in self.ones: answer[val] = \\'1\\'\\n        return \\'\\'.join(answer)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748451,
                "title": "help",
                "content": "why it is giving TLE?\\n```\\nclass Bitset {\\npublic:\\n    string s;\\n    Bitset(int size) {\\n        for(int i=0;i<size;i++){\\n            s+=\\'0\\';\\n        }\\n    }\\n    \\n    void fix(int idx) {\\n        s[idx]=\\'1\\';\\n    }\\n    \\n    void unfix(int idx) {\\n        s[idx]=\\'0\\';\\n    }\\n    \\n    void flip() {\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') s[i]=\\'0\\';\\n            else s[i]=\\'1\\';\\n        }\\n    }\\n    \\n    bool all() {\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool one() {\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') return true;\\n        }\\n        return false;\\n    }\\n    \\n    int count() {\\n        int yaha=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') yaha++;\\n        }\\n        return yaha;\\n        \\n    }\\n    \\n    string toString() {\\n        return s;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "why it is giving TLE?\\n```\\nclass Bitset {\\npublic:\\n    string s;\\n    Bitset(int size) {\\n        for(int i=0;i<size;i++){\\n            s+=\\'0\\';\\n        }\\n    }\\n    \\n    void fix(int idx) {\\n        s[idx]=\\'1\\';\\n    }\\n    \\n    void unfix(int idx) {\\n        s[idx]=\\'0\\';\\n    }\\n    \\n    void flip() {\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') s[i]=\\'0\\';\\n            else s[i]=\\'1\\';\\n        }\\n    }\\n    \\n    bool all() {\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool one() {\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') return true;\\n        }\\n        return false;\\n    }\\n    \\n    int count() {\\n        int yaha=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'1\\') yaha++;\\n        }\\n        return yaha;\\n        \\n    }\\n    \\n    string toString() {\\n        return s;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1748439,
                "title": "python-easy-understanding",
                "content": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n\\t\\t#counts no of 1\\'s\\n        self.sum=0\\n\\t\\t#max  no of 1\\'s is size\\n        self.size=size\\n\\t\\t#self.s is the main string\\n        self.s=\\'0\\'*size\\n\\t\\t#self.r is for fliping the self.s we do reverse for this.\\n        self.r=\\'1\\'*size\\n    def fix(self, idx: int) -> None:\\n        if self.s[idx]==\\'0\\':\\n            self.sum+=1\\n\\t\\t\\t#changing bit in self.s\\n            self.s=self.s[:idx]+\\'1\\'+self.s[idx+1:]\\n\\t\\t\\t#changing bit in reverse\\n            self.r=self.r[:idx]+\\'0\\'+self.r[idx+1:]\\n            \\n        \\n        \\n\\n    def unfix(self, idx: int) -> None:\\n        if self.s[idx]==\\'1\\':\\n            self.sum-=1\\n\\t\\t\\t#changing bit in self.s \\n            self.s=self.s[:idx]+\\'0\\'+self.s[idx+1:]\\n\\t\\t\\t#changing bit in reverse in self.r\\n            self.r=self.r[:idx]+\\'1\\'+self.r[idx+1:]\\n            \\n        \\n\\n    def flip(self) -> None:\\n\\t\\t#sum updates as below\\n        self.sum=self.size-self.sum\\n\\t\\t#for filping assign reverse to orginal and orginal to reverse\\n        self.s,self.r=self.r,self.s\\n\\n    def all(self) -> bool:\\n\\t\\t#if self.sum==self.size means all are one\\n        return self.sum==self.size\\n\\n    def one(self) -> bool:\\n\\t\\t#self.sum>0 means contains atleast one 1\\n        return self.sum>0\\n\\n    def count(self) -> int:\\n\\t\\t#return self.sum which is no of 1\\'s\\n        return self.sum\\n    \\n    def toString(self) -> str:\\n        return self.s\\n        \\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```\\n**Please upvote if it helped you in any way.**",
                "solutionTags": [],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n\\t\\t#counts no of 1\\'s\\n        self.sum=0\\n\\t\\t#max  no of 1\\'s is size\\n        self.size=size\\n\\t\\t#self.s is the main string\\n        self.s=\\'0\\'*size\\n\\t\\t#self.r is for fliping the self.s we do reverse for this.\\n        self.r=\\'1\\'*size\\n    def fix(self, idx: int) -> None:\\n        if self.s[idx]==\\'0\\':\\n            self.sum+=1\\n\\t\\t\\t#changing bit in self.s\\n            self.s=self.s[:idx]+\\'1\\'+self.s[idx+1:]\\n\\t\\t\\t#changing bit in reverse\\n            self.r=self.r[:idx]+\\'0\\'+self.r[idx+1:]\\n            \\n        \\n        \\n\\n    def unfix(self, idx: int) -> None:\\n        if self.s[idx]==\\'1\\':\\n            self.sum-=1\\n\\t\\t\\t#changing bit in self.s \\n            self.s=self.s[:idx]+\\'0\\'+self.s[idx+1:]\\n\\t\\t\\t#changing bit in reverse in self.r\\n            self.r=self.r[:idx]+\\'1\\'+self.r[idx+1:]\\n            \\n        \\n\\n    def flip(self) -> None:\\n\\t\\t#sum updates as below\\n        self.sum=self.size-self.sum\\n\\t\\t#for filping assign reverse to orginal and orginal to reverse\\n        self.s,self.r=self.r,self.s\\n\\n    def all(self) -> bool:\\n\\t\\t#if self.sum==self.size means all are one\\n        return self.sum==self.size\\n\\n    def one(self) -> bool:\\n\\t\\t#self.sum>0 means contains atleast one 1\\n        return self.sum>0\\n\\n    def count(self) -> int:\\n\\t\\t#return self.sum which is no of 1\\'s\\n        return self.sum\\n    \\n    def toString(self) -> str:\\n        return self.s\\n        \\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084165,
                "title": "c-approach-with-bit-manipulation",
                "content": "# Intuition\\n###### Initially, we store the number of units and the bit size to perform all, one, and count operations for O(1). We need **m_flip** for the same operations, but it is added to the **toString**, **fix** and **unfix** methods.\\n\\n###### The c ^= 1 here, is a change of the first bit, \\'0\\' (code 48) is changed to \\'1\\' (code 49) and vice versa.\\n\\n###### The **fix** and **unfix** operations use **m_flip** to keep track of what to do with the string and how to handle the **m_ones** variable.\\n\\n\\n# Complexity\\n- Time complexity: all operations $$O(1)$$ except **toString** $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Bitset {\\nprivate:\\n    const int m_size;\\n    int m_ones;\\n    bool m_flip;\\n    std::string m_str;\\n\\npublic:\\n    Bitset(int size) :\\n        m_size(size), m_ones(0), m_flip(false), m_str(m_size, \\'0\\') {}\\n    \\n    void fix(int idx) {\\n        m_ones += (m_str[idx]-\\'0\\') == m_flip;\\n        m_str[idx] = \\'0\\' + !m_flip;        \\n    }\\n    \\n    void unfix(int idx) {\\n        m_ones -= (m_str[idx]-\\'0\\') == !m_flip;\\n        m_str[idx] = \\'0\\' + m_flip;\\n    }\\n    \\n    void flip() {\\n        m_flip ^= true;\\n        m_ones = m_size - m_ones;\\n    }\\n    \\n    bool all()  { return m_ones == m_size; }\\n    bool one()  { return m_ones; }\\n    int count() { return m_ones; }\\n    \\n    string toString() {\\n        if (!m_flip) return m_str;\\n        m_flip = false;\\n\\n        for (char &c : m_str)\\n            c ^= 1;\\n        return m_str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Bitset {\\nprivate:\\n    const int m_size;\\n    int m_ones;\\n    bool m_flip;\\n    std::string m_str;\\n\\npublic:\\n    Bitset(int size) :\\n        m_size(size), m_ones(0), m_flip(false), m_str(m_size, \\'0\\') {}\\n    \\n    void fix(int idx) {\\n        m_ones += (m_str[idx]-\\'0\\') == m_flip;\\n        m_str[idx] = \\'0\\' + !m_flip;        \\n    }\\n    \\n    void unfix(int idx) {\\n        m_ones -= (m_str[idx]-\\'0\\') == !m_flip;\\n        m_str[idx] = \\'0\\' + m_flip;\\n    }\\n    \\n    void flip() {\\n        m_flip ^= true;\\n        m_ones = m_size - m_ones;\\n    }\\n    \\n    bool all()  { return m_ones == m_size; }\\n    bool one()  { return m_ones; }\\n    int count() { return m_ones; }\\n    \\n    string toString() {\\n        if (!m_flip) return m_str;\\n        m_flip = false;\\n\\n        for (char &c : m_str)\\n            c ^= 1;\\n        return m_str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065113,
                "title": "design-bitset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Bitset {\\n  public Bitset(int size) {\\n    for (int i = 0; i < size; ++i) {\\n      sb.append(\\'0\\');\\n      rb.append(\\'1\\');\\n    }\\n  }\\n\\n  public void fix(int idx) {\\n    if (sb.charAt(idx) == \\'0\\')\\n      ++cnt;\\n    sb.setCharAt(idx, \\'1\\');\\n    rb.setCharAt(idx, \\'0\\');\\n  }\\n\\n  public void unfix(int idx) {\\n    if (sb.charAt(idx) == \\'1\\')\\n      --cnt;\\n    sb.setCharAt(idx, \\'0\\');\\n    rb.setCharAt(idx, \\'1\\');\\n  }\\n\\n  public void flip() {\\n    StringBuilder temp = sb;\\n    sb = rb;\\n    rb = temp;\\n    cnt = sb.length() - cnt;\\n  }\\n\\n  public boolean all() {\\n    return cnt == sb.length();\\n  }\\n\\n  public boolean one() {\\n    return cnt > 0;\\n  }\\n\\n  public int count() {\\n    return cnt;\\n  }\\n\\n  public String toString() {\\n    return sb.toString();\\n  }\\n\\n  private StringBuilder sb = new StringBuilder();\\n  private StringBuilder rb = new StringBuilder();\\n  private int cnt = 0;\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n  public Bitset(int size) {\\n    for (int i = 0; i < size; ++i) {\\n      sb.append(\\'0\\');\\n      rb.append(\\'1\\');\\n    }\\n  }\\n\\n  public void fix(int idx) {\\n    if (sb.charAt(idx) == \\'0\\')\\n      ++cnt;\\n    sb.setCharAt(idx, \\'1\\');\\n    rb.setCharAt(idx, \\'0\\');\\n  }\\n\\n  public void unfix(int idx) {\\n    if (sb.charAt(idx) == \\'1\\')\\n      --cnt;\\n    sb.setCharAt(idx, \\'0\\');\\n    rb.setCharAt(idx, \\'1\\');\\n  }\\n\\n  public void flip() {\\n    StringBuilder temp = sb;\\n    sb = rb;\\n    rb = temp;\\n    cnt = sb.length() - cnt;\\n  }\\n\\n  public boolean all() {\\n    return cnt == sb.length();\\n  }\\n\\n  public boolean one() {\\n    return cnt > 0;\\n  }\\n\\n  public int count() {\\n    return cnt;\\n  }\\n\\n  public String toString() {\\n    return sb.toString();\\n  }\\n\\n  private StringBuilder sb = new StringBuilder();\\n  private StringBuilder rb = new StringBuilder();\\n  private int cnt = 0;\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009868,
                "title": "space-optimized-using-vectorized-numpy",
                "content": "# Keep one numpy array\\n# SC = O(N)\\n# TC = O(N)\\n\\n# Code\\n\\n\\n# Keep one numpy array\\'s SC = O(N)\\n# TC = O(N)\\n```\\nimport numpy as np\\n\\n\\nclass Bitset:\\n\\n    def __init__(self, size: int): #O(1)\\n        self.A = np.ones(size) * -1\\n        self.A = self.A.astype(np.int8) # vectorized\\n        self.count_zero = size\\n        self.count_one = 0\\n\\n    def fix(self, idx: int) -> None: #O(1)\\n        if self.A[idx] == -1:\\n            self.count_one +=1\\n            self.count_zero -=1\\n            self.A[idx] = 1\\n        \\n    def unfix(self, idx: int) -> None: #O(1)\\n        if self.A[idx] == 1:\\n            self.count_zero +=1\\n            self.count_one -=1\\n            self.A[idx] = -1\\n        \\n    def flip(self) -> None:  #O(1) as vectorized\\n        self.A = self.A * -1\\n        self.count_zero , self.count_one = self.count_one, self.count_zero\\n\\n\\n    def all(self) -> bool: #O(1)\\n        return self.count_zero == 0\\n\\n    def one(self) -> bool:   #O(1)\\n        return self.count_one > 0\\n\\n    def count(self) -> int:  #O(1)\\n        return self.count_one\\n\\n    def toString(self) -> str: #O(N)\\n        self.A[self.A == -1] = 0 # vectorized\\n        self.A = self.A.astype(str) # vectorized\\n\\n        st = \\'\\'.join(self.A) # O(N)\\n        self.A = self.A.astype(np.int8) # vectorized\\n        self.A[self.A == 0] = -1  # vectorized\\n\\n        return st\\n\\n```\\n\\n\\n\\n# keep two array\\'s SC = O(2N)\\nTC =. O(N)\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n\\t\\t# stores original bits True -> 1, False -> 0\\n        self.bit = [False for i in range(size)]\\n\\t\\t# inverse list of self.bit\\n        self.bitinv = [True for i in range(size)]\\n\\t\\t# counter of True\\n        self.ones = 0\\n\\t\\t# counter of False (both are for self.bit)\\n        self.zeros = size\\n\\t\\t# original size\\n        self.size = size\\n\\n    def fix(self, idx: int) -> None:\\n\\t\\t# if the bit is 0/False set the bit and update the counters bitinv stores opposite of self.bit every time\\n        if not self.bit[idx]:\\n            self.zeros -= 1\\n            self.ones += 1\\n        self.bit[idx] = True\\n        self.bitinv[idx] = False\\n\\n    def unfix(self, idx: int) -> None:\\n\\t\\t# if the bit is set unset the bit and update both the lists as mentioned above\\n        if self.bit[idx]:\\n            self.zeros += 1\\n            self.ones -= 1\\n        self.bit[idx] = False\\n        self.bitinv[idx] = True\\n\\n    def flip(self) -> None:\\n\\t\\t# changing the zeros counter to ones and vice versa.\\n        self.ones,self.zeros = self.zeros,self.ones\\n\\t\\t# changing the list pointers now inverse list will be the main list i.e. self.bit will point towards self.bitinv and vice versa.\\n        self.bit,self.bitinv = self.bitinv,self.bit\\n\\n    def all(self) -> bool:\\n\\t\\t# return True if ones counter equal to size otherwise False.\\n        return self.ones == self.size\\n\\n    def one(self) -> bool:\\n\\t\\t# returns True if ones counter greater than zeros\\n        return self.ones > 0\\n\\n    def count(self) -> int:\\n\\t\\t# returns the number of ones\\n        return self.ones\\n\\n    def toString(self) -> str:\\n\\t\\t# appending 1 to string if it\\'s True in self.bit otherwise 0\\n        ans = \\'\\'\\n        for bit in self.bit:\\n            if bit:\\n                ans += \\'1\\'\\n            else:\\n                ans += \\'0\\'\\n        return ans\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nimport numpy as np\\n\\n\\nclass Bitset:\\n\\n    def __init__(self, size: int): #O(1)\\n        self.A = np.ones(size) * -1\\n        self.A = self.A.astype(np.int8) # vectorized\\n        self.count_zero = size\\n        self.count_one = 0\\n\\n    def fix(self, idx: int) -> None: #O(1)\\n        if self.A[idx] == -1:\\n            self.count_one +=1\\n            self.count_zero -=1\\n            self.A[idx] = 1\\n        \\n    def unfix(self, idx: int) -> None: #O(1)\\n        if self.A[idx] == 1:\\n            self.count_zero +=1\\n            self.count_one -=1\\n            self.A[idx] = -1\\n        \\n    def flip(self) -> None:  #O(1) as vectorized\\n        self.A = self.A * -1\\n        self.count_zero , self.count_one = self.count_one, self.count_zero\\n\\n\\n    def all(self) -> bool: #O(1)\\n        return self.count_zero == 0\\n\\n    def one(self) -> bool:   #O(1)\\n        return self.count_one > 0\\n\\n    def count(self) -> int:  #O(1)\\n        return self.count_one\\n\\n    def toString(self) -> str: #O(N)\\n        self.A[self.A == -1] = 0 # vectorized\\n        self.A = self.A.astype(str) # vectorized\\n\\n        st = \\'\\'.join(self.A) # O(N)\\n        self.A = self.A.astype(np.int8) # vectorized\\n        self.A[self.A == 0] = -1  # vectorized\\n\\n        return st\\n\\n```\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n\\t\\t# stores original bits True -> 1, False -> 0\\n        self.bit = [False for i in range(size)]\\n\\t\\t# inverse list of self.bit\\n        self.bitinv = [True for i in range(size)]\\n\\t\\t# counter of True\\n        self.ones = 0\\n\\t\\t# counter of False (both are for self.bit)\\n        self.zeros = size\\n\\t\\t# original size\\n        self.size = size\\n\\n    def fix(self, idx: int) -> None:\\n\\t\\t# if the bit is 0/False set the bit and update the counters bitinv stores opposite of self.bit every time\\n        if not self.bit[idx]:\\n            self.zeros -= 1\\n            self.ones += 1\\n        self.bit[idx] = True\\n        self.bitinv[idx] = False\\n\\n    def unfix(self, idx: int) -> None:\\n\\t\\t# if the bit is set unset the bit and update both the lists as mentioned above\\n        if self.bit[idx]:\\n            self.zeros += 1\\n            self.ones -= 1\\n        self.bit[idx] = False\\n        self.bitinv[idx] = True\\n\\n    def flip(self) -> None:\\n\\t\\t# changing the zeros counter to ones and vice versa.\\n        self.ones,self.zeros = self.zeros,self.ones\\n\\t\\t# changing the list pointers now inverse list will be the main list i.e. self.bit will point towards self.bitinv and vice versa.\\n        self.bit,self.bitinv = self.bitinv,self.bit\\n\\n    def all(self) -> bool:\\n\\t\\t# return True if ones counter equal to size otherwise False.\\n        return self.ones == self.size\\n\\n    def one(self) -> bool:\\n\\t\\t# returns True if ones counter greater than zeros\\n        return self.ones > 0\\n\\n    def count(self) -> int:\\n\\t\\t# returns the number of ones\\n        return self.ones\\n\\n    def toString(self) -> str:\\n\\t\\t# appending 1 to string if it\\'s True in self.bit otherwise 0\\n        ans = \\'\\'\\n        for bit in self.bit:\\n            if bit:\\n                ans += \\'1\\'\\n            else:\\n                ans += \\'0\\'\\n        return ans\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973415,
                "title": "python-hashmap-hashset-easiest-implementation-you-seen-beats-65",
                "content": "self explainable \\n\\n```\\nclass Bitset:\\n    \\n    def __init__(self, size: int):\\n        self.hashmap = defaultdict(lambda:set())\\n        self.size = size\\n        for i in range(size):\\n            self.hashmap[0].add(i)\\n        \\n    def fix(self, idx: int) -> None:\\n        if idx not in self.hashmap[1]:\\n            self.hashmap[0].remove(idx)\\n            self.hashmap[1].add(idx)\\n        \\n    def unfix(self, idx: int) -> None:\\n        if idx not in self.hashmap[0]:\\n            self.hashmap[0].add(idx)\\n            self.hashmap[1].remove(idx)\\n\\n    def flip(self) -> None:\\n        self.hashmap[0],self.hashmap[1] = self.hashmap[1],self.hashmap[0]\\n        \\n    def all(self) -> bool:\\n        return len(self.hashmap[1]) == self.size\\n        \\n    def one(self) -> bool:\\n        return len(self.hashmap[1]) >= 1\\n        \\n    def count(self) -> int:\\n        return len(self.hashmap[1])\\n        \\n    def toString(self) -> str:\\n        return \\'\\'.join([\\'0\\' if i in self.hashmap[0] else \\'1\\' for i in range(self.size)])\\n",
                "solutionTags": [],
                "code": "self explainable \\n\\n```\\nclass Bitset:\\n    \\n    def __init__(self, size: int):\\n        self.hashmap = defaultdict(lambda:set())\\n        self.size = size\\n        for i in range(size):\\n            self.hashmap[0].add(i)\\n        \\n    def fix(self, idx: int) -> None:\\n        if idx not in self.hashmap[1]:\\n            self.hashmap[0].remove(idx)\\n            self.hashmap[1].add(idx)\\n        \\n    def unfix(self, idx: int) -> None:\\n        if idx not in self.hashmap[0]:\\n            self.hashmap[0].add(idx)\\n            self.hashmap[1].remove(idx)\\n\\n    def flip(self) -> None:\\n        self.hashmap[0],self.hashmap[1] = self.hashmap[1],self.hashmap[0]\\n        \\n    def all(self) -> bool:\\n        return len(self.hashmap[1]) == self.size\\n        \\n    def one(self) -> bool:\\n        return len(self.hashmap[1]) >= 1\\n        \\n    def count(self) -> int:\\n        return len(self.hashmap[1])\\n        \\n    def toString(self) -> str:\\n        return \\'\\'.join([\\'0\\' if i in self.hashmap[0] else \\'1\\' for i in range(self.size)])\\n",
                "codeTag": "Java"
            },
            {
                "id": 3973282,
                "title": "dont-actually-flip-all-the-bits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFlipping the Bits was very costly because I was *literally* flipping all the bits in the list which took $$O(N)$$ time. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere\\'s no need to flip, just have to store a `boolean` or per-say an `integer` which only stores `1\\'s` and `0\\'s`. Depending upon this flip boolean the current `0\\'s` and `1\\'s` change their faces.\\n\\n# Complexity\\n- Time complexity: All of the functions take $$O(1)$$ time except the `toString` function. But, as there\\'s an upper bound on how many times it will be called so there\\'s no need to worry.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(N)$$ because of the array of intgers.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# P.S.\\nSpace complexity can be optimised further if we use a `list` of `booleans` instead of `integers`.\\n\\n# Code\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bits = [0] * size\\n        self.ones = 0\\n        self._flip = 0\\n\\n    def check_if_its_0(self, bit):\\n        return self._flip == bit\\n    \\n    def check_if_its_1(self, bit):\\n        return self._flip != bit\\n    \\n    def current_0(self):\\n        return 1 if self._flip else 0\\n    \\n    def current_1(self):\\n        return 0 if self._flip else 1\\n\\n    def fix(self, idx: int) -> None:\\n        if self.check_if_its_0(self.bits[idx]):\\n            self.bits[idx] = self.current_1()\\n            self.ones += 1\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.check_if_its_1(self.bits[idx]):\\n            self.bits[idx] = self.current_0()\\n            self.ones -= 1 \\n\\n\\n    def flip(self) -> None:\\n        self._flip = not self._flip\\n        self.ones = len(self.bits) - self.ones\\n\\n    def all(self) -> bool:\\n        return len(self.bits) == self.ones\\n\\n    def one(self) -> bool:\\n        return self.ones > 0\\n\\n    def count(self) -> int:\\n        return self.ones\\n\\n    def toString(self) -> str:\\n        temp_str = \"\"\\n        for bit in self.bits:\\n            temp_str += str(1 if self.check_if_its_1(bit) else 0)\\n        return temp_str\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bits = [0] * size\\n        self.ones = 0\\n        self._flip = 0\\n\\n    def check_if_its_0(self, bit):\\n        return self._flip == bit\\n    \\n    def check_if_its_1(self, bit):\\n        return self._flip != bit\\n    \\n    def current_0(self):\\n        return 1 if self._flip else 0\\n    \\n    def current_1(self):\\n        return 0 if self._flip else 1\\n\\n    def fix(self, idx: int) -> None:\\n        if self.check_if_its_0(self.bits[idx]):\\n            self.bits[idx] = self.current_1()\\n            self.ones += 1\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.check_if_its_1(self.bits[idx]):\\n            self.bits[idx] = self.current_0()\\n            self.ones -= 1 \\n\\n\\n    def flip(self) -> None:\\n        self._flip = not self._flip\\n        self.ones = len(self.bits) - self.ones\\n\\n    def all(self) -> bool:\\n        return len(self.bits) == self.ones\\n\\n    def one(self) -> bool:\\n        return self.ones > 0\\n\\n    def count(self) -> int:\\n        return self.ones\\n\\n    def toString(self) -> str:\\n        temp_str = \"\"\\n        for bit in self.bits:\\n            temp_str += str(1 if self.check_if_its_1(bit) else 0)\\n        return temp_str\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942682,
                "title": "bitset-using-32-bits-per-int-beats-100-memory",
                "content": "# Intuition\\nIt looks like most solutions are using whole integers to store each bit, but this is wasteful, as an integer can hold 32 bits. \\n\\n# Approach\\nAn int can hold 32 bits, so for x bits we need x+31 / 32 ints.\\nThen we can just set each bit in the int as needed using bitwise operators. \\nto set the x bit in int i, we create a mask 1 << x, where x is the bit we want to set in the int\\nTo set a bit to 1, we take **int | 1 << x**\\nTo set s bit to 0, we invert the mask  **int & ~(1 << x)**\\n\\n\\n# Code\\n```\\nclass Bitset {\\n\\n    private int[] bitset;\\n    private int ones;\\n    private boolean flipped;\\n    private int size;\\n\\n    public Bitset(int size) {\\n      this.size = size;\\n      //An int is 32 bits so for \\'size\\' bits we need size+31 / 32 ints \\n      bitset = new int[(size+31) / 32];\\n      ones = 0;\\n    }\\n    \\n    public void fix(int idx) {\\n        if (flipped) dounfix(idx);\\n        else dofix(idx);\\n    }\\n\\n    private void dofix(int idx){\\n      int intloc = idx / 32;      //Find the location in bitset array\\n      int bit = 31 -(idx % 32);     //get bit inside integer. 0 is leftmost \\n      if ((1 << bit & bitset[intloc]) == 0) {   // if bit is 0\\n        ones++;\\n      }\\n      bitset[intloc] =(bitset[intloc] | 1 << bit); //use mask 1<<bit to set bit to 1\\n    }\\n      \\n    public void unfix(int idx) {\\n      if (flipped) dofix(idx);\\n      else dounfix(idx);\\n    }\\n\\n    private void dounfix(int idx){\\n      int intloc = idx/32;    //Find the location in bitset array\\n      int bit = 31 -(idx % 32);     //get bit inside integer. 0 is leftmost \\n      if ((1 << bit & bitset[intloc]) != 0) {   //check if bit is 1\\n        ones--;\\n      }\\n      bitset[intloc] = bitset[intloc] & ~(1 << bit); //use mask ~1<<bit to set bit to 0\\n    }\\n      \\n    public void flip() {\\n    \\tflipped = !flipped;\\n    }\\n      \\n    public boolean all() {\\n      if (flipped) return ones == 0;\\n      else return ones == size;\\n    }\\n      \\n    public boolean one() {\\n      if (flipped) return ones < size;\\n      else return ones > 0;\\n    }\\n      \\n    public int count() {\\n      if (flipped) return size - ones;\\n      else return ones;  \\n    }\\n      \\n    public String toString() {\\n      StringBuilder sb = new StringBuilder();\\n      for (int i = 0; i < bitset.length; i++) {\\n      \\tint num = flipped ? ~bitset[i] : bitset[i];\\n      \\tString bitstring = ( \"0\".repeat(Integer.numberOfLeadingZeros(num != 0 ? num : 1))\\n                + Integer.toBinaryString(num));\\n      \\tif (i == bitset.length -1) {\\n      \\t\\tsb.append(bitstring.substring(0,size % 32 == 0 ? 32 : size % 32));\\n      \\t} else {\\n      \\t\\tsb.append(bitstring);\\n      \\t}\\n      }\\n      return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n\\n    private int[] bitset;\\n    private int ones;\\n    private boolean flipped;\\n    private int size;\\n\\n    public Bitset(int size) {\\n      this.size = size;\\n      //An int is 32 bits so for \\'size\\' bits we need size+31 / 32 ints \\n      bitset = new int[(size+31) / 32];\\n      ones = 0;\\n    }\\n    \\n    public void fix(int idx) {\\n        if (flipped) dounfix(idx);\\n        else dofix(idx);\\n    }\\n\\n    private void dofix(int idx){\\n      int intloc = idx / 32;      //Find the location in bitset array\\n      int bit = 31 -(idx % 32);     //get bit inside integer. 0 is leftmost \\n      if ((1 << bit & bitset[intloc]) == 0) {   // if bit is 0\\n        ones++;\\n      }\\n      bitset[intloc] =(bitset[intloc] | 1 << bit); //use mask 1<<bit to set bit to 1\\n    }\\n      \\n    public void unfix(int idx) {\\n      if (flipped) dofix(idx);\\n      else dounfix(idx);\\n    }\\n\\n    private void dounfix(int idx){\\n      int intloc = idx/32;    //Find the location in bitset array\\n      int bit = 31 -(idx % 32);     //get bit inside integer. 0 is leftmost \\n      if ((1 << bit & bitset[intloc]) != 0) {   //check if bit is 1\\n        ones--;\\n      }\\n      bitset[intloc] = bitset[intloc] & ~(1 << bit); //use mask ~1<<bit to set bit to 0\\n    }\\n      \\n    public void flip() {\\n    \\tflipped = !flipped;\\n    }\\n      \\n    public boolean all() {\\n      if (flipped) return ones == 0;\\n      else return ones == size;\\n    }\\n      \\n    public boolean one() {\\n      if (flipped) return ones < size;\\n      else return ones > 0;\\n    }\\n      \\n    public int count() {\\n      if (flipped) return size - ones;\\n      else return ones;  \\n    }\\n      \\n    public String toString() {\\n      StringBuilder sb = new StringBuilder();\\n      for (int i = 0; i < bitset.length; i++) {\\n      \\tint num = flipped ? ~bitset[i] : bitset[i];\\n      \\tString bitstring = ( \"0\".repeat(Integer.numberOfLeadingZeros(num != 0 ? num : 1))\\n                + Integer.toBinaryString(num));\\n      \\tif (i == bitset.length -1) {\\n      \\t\\tsb.append(bitstring.substring(0,size % 32 == 0 ? 32 : size % 32));\\n      \\t} else {\\n      \\t\\tsb.append(bitstring);\\n      \\t}\\n      }\\n      return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916034,
                "title": "flip-but-not-flip-beats-95",
                "content": "# Intuition\\nLazily flip\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ for all except `toString`, which is $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bit = [0]*size\\n        self.flipped = False\\n        self.count_one = 0\\n\\n    def fix(self, idx: int) -> None:\\n        if not self.flipped:\\n            self.count_one += 1 if self.bit[idx] == 0 else 0\\n            self.bit[idx] = 1\\n        else:\\n            self.count_one += 1 if self.bit[idx] == 1 else 0\\n            self.bit[idx] = 0\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.flipped:\\n            self.count_one -= 1 if self.bit[idx] == 0 else 0\\n            self.bit[idx] = 1\\n        else:\\n            self.count_one -= 1 if self.bit[idx] == 1 else 0\\n            self.bit[idx] = 0\\n\\n    def flip(self) -> None:\\n        self.count_one = len(self.bit) - self.count_one\\n        self.flipped = not self.flipped\\n\\n    def all(self) -> bool:\\n        return self.count_one == len(self.bit)\\n\\n    def one(self) -> bool:\\n        return self.count_one > 0\\n\\n    def count(self) -> int:\\n        return self.count_one\\n\\n    def toString(self) -> str:\\n        if not self.flipped: return \"\".join([str(i) for i in self.bit])\\n        return \"\".join([(\"1\" if i==0 else \"0\") for i in self.bit])\\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bit = [0]*size\\n        self.flipped = False\\n        self.count_one = 0\\n\\n    def fix(self, idx: int) -> None:\\n        if not self.flipped:\\n            self.count_one += 1 if self.bit[idx] == 0 else 0\\n            self.bit[idx] = 1\\n        else:\\n            self.count_one += 1 if self.bit[idx] == 1 else 0\\n            self.bit[idx] = 0\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.flipped:\\n            self.count_one -= 1 if self.bit[idx] == 0 else 0\\n            self.bit[idx] = 1\\n        else:\\n            self.count_one -= 1 if self.bit[idx] == 1 else 0\\n            self.bit[idx] = 0\\n\\n    def flip(self) -> None:\\n        self.count_one = len(self.bit) - self.count_one\\n        self.flipped = not self.flipped\\n\\n    def all(self) -> bool:\\n        return self.count_one == len(self.bit)\\n\\n    def one(self) -> bool:\\n        return self.count_one > 0\\n\\n    def count(self) -> int:\\n        return self.count_one\\n\\n    def toString(self) -> str:\\n        if not self.flipped: return \"\".join([str(i) for i in self.bit])\\n        return \"\".join([(\"1\" if i==0 else \"0\") for i in self.bit])\\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845726,
                "title": "javascript-all-methods-except-tostring-o-1-space-and-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep track of the bits as an array. the biggest breakthrough though is pre-computing the reverse array. look at the methods to see the relationships and how to flip it.\\n\\nkeep track of the number of ones as a member of the class.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nconstructor $$O(n)$$ - creating the array of bits\\nfix $$O(1)$$\\nunfix $$O(1)$$\\nflip $$O(1)$$\\nall $$O(1)$$\\none $$O(1)$$\\ncount $$O(1)$$\\ntoString $$O(n)$$ - join method loops through the bit array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nconstructor $$O(n)$$ - creating the array of bits\\nfix $$O(1)$$\\nunfix $$O(1)$$\\nflip $$O(1)$$\\nall $$O(1)$$\\none $$O(1)$$\\ncount $$O(1)$$\\ntoString $$O(n)$$ - creating new string to return. if you do not count the return value though, its O(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} size\\n */\\nvar Bitset = function(size) {\\n    this.size = size;\\n    this.bits = new Array(size).fill(0);\\n    this.reverse = new Array(size).fill(1);\\n    this.numOnes = 0;\\n};\\n\\n/** \\n * @param {number} idx\\n * @return {void}\\n */\\nBitset.prototype.fix = function(idx) {\\n    if(this.bits[idx] === 0) {\\n        this.numOnes++;\\n    }\\n    this.bits[idx] = 1;\\n    this.reverse[idx] = 0;\\n};\\n\\n/** \\n * @param {number} idx\\n * @return {void}\\n */\\nBitset.prototype.unfix = function(idx) {\\n    if(this.bits[idx] === 1) {\\n        this.numOnes--;\\n    }\\n    this.bits[idx] = 0;\\n    this.reverse[idx] = 1;\\n};\\n\\n/**\\n * @return {void}\\n */\\nBitset.prototype.flip = function() {\\n    let tmp = this.reverse;\\n    this.reverse = this.bits;\\n    this.bits = tmp;\\n\\n    this.numOnes = this.size - this.numOnes;\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nBitset.prototype.all = function() {\\n    return this.numOnes === this.size;\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nBitset.prototype.one = function() {\\n    return this.numOnes > 0;\\n};\\n\\n/**\\n * @return {number}\\n */\\nBitset.prototype.count = function() {\\n    return this.numOnes;\\n};\\n\\n/**\\n * @return {string}\\n */\\nBitset.prototype.toString = function() {\\n    return this.bits.join(\\'\\');\\n};\\n\\n/** \\n * Your Bitset object will be instantiated and called as such:\\n * var obj = new Bitset(size)\\n * obj.fix(idx)\\n * obj.unfix(idx)\\n * obj.flip()\\n * var param_4 = obj.all()\\n * var param_5 = obj.one()\\n * var param_6 = obj.count()\\n * var param_7 = obj.toString()\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} size\\n */\\nvar Bitset = function(size) {\\n    this.size = size;\\n    this.bits = new Array(size).fill(0);\\n    this.reverse = new Array(size).fill(1);\\n    this.numOnes = 0;\\n};\\n\\n/** \\n * @param {number} idx\\n * @return {void}\\n */\\nBitset.prototype.fix = function(idx) {\\n    if(this.bits[idx] === 0) {\\n        this.numOnes++;\\n    }\\n    this.bits[idx] = 1;\\n    this.reverse[idx] = 0;\\n};\\n\\n/** \\n * @param {number} idx\\n * @return {void}\\n */\\nBitset.prototype.unfix = function(idx) {\\n    if(this.bits[idx] === 1) {\\n        this.numOnes--;\\n    }\\n    this.bits[idx] = 0;\\n    this.reverse[idx] = 1;\\n};\\n\\n/**\\n * @return {void}\\n */\\nBitset.prototype.flip = function() {\\n    let tmp = this.reverse;\\n    this.reverse = this.bits;\\n    this.bits = tmp;\\n\\n    this.numOnes = this.size - this.numOnes;\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nBitset.prototype.all = function() {\\n    return this.numOnes === this.size;\\n};\\n\\n/**\\n * @return {boolean}\\n */\\nBitset.prototype.one = function() {\\n    return this.numOnes > 0;\\n};\\n\\n/**\\n * @return {number}\\n */\\nBitset.prototype.count = function() {\\n    return this.numOnes;\\n};\\n\\n/**\\n * @return {string}\\n */\\nBitset.prototype.toString = function() {\\n    return this.bits.join(\\'\\');\\n};\\n\\n/** \\n * Your Bitset object will be instantiated and called as such:\\n * var obj = new Bitset(size)\\n * obj.fix(idx)\\n * obj.unfix(idx)\\n * obj.flip()\\n * var param_4 = obj.all()\\n * var param_5 = obj.one()\\n * var param_6 = obj.count()\\n * var param_7 = obj.toString()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831443,
                "title": "fast-and-intuitive-python-3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially, what I did was to have a hashmap to keep track of the counts of 1 and 0 and also create a list that I could update when I had to fix or unfix. While this logic works very well, both the flip and toString methods had time complexities of O(N), so I encountered a time limit error.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo overcome this, I instead created a hashmap and not a list. The hashmap had keys of 1 and 0 with their values being a set of the indexes in the \"bit_string\" they occupy. And throughout the methods we updates these sets in the hashmaps and also create the final string from these indexes as well.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNow flip became O(1) since we can just swap their index sets, but the toString remained O(N) as that is the only logically best time complexity it can have given that strings are immutable.\\n\\nall the methods have time complexity of 0(1) except toString\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N) since we keep track of the set of indexes whose size is dependent linearly on \"size\".\\n# Code\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bit_count = {\"0\":size,\"1\":0}\\n        self.bit_indexes = {\"0\":{i for i in range(size)},\"1\":set()}\\n        self.size = size\\n        \\n    def fix(self, idx: int) -> None:\\n        if idx in self.bit_indexes[\"1\"]:\\n            return\\n        self.bit_indexes[\"0\"].remove(idx)\\n        self.bit_indexes[\"1\"].add(idx)\\n        self.bit_count[\"1\"] = self.bit_count[\"1\"] + 1\\n        self.bit_count[\"0\"] = self.bit_count[\"0\"] - 1\\n        \\n\\n    def unfix(self, idx: int) -> None:\\n        if idx in self.bit_indexes[\"0\"]:\\n            return\\n        self.bit_indexes[\"1\"].remove(idx)\\n        self.bit_indexes[\"0\"].add(idx)\\n        self.bit_count[\"1\"] = self.bit_count[\"1\"] - 1\\n        self.bit_count[\"0\"] = self.bit_count[\"0\"] + 1\\n\\n    def flip(self) -> None:\\n        self.bit_indexes[\"0\"],self.bit_indexes[\"1\"] = self.bit_indexes[\"1\"],self.bit_indexes[\"0\"]\\n        self.bit_count[\"0\"],self.bit_count[\"1\"] = self.bit_count[\"1\"],self.bit_count[\"0\"]\\n\\n    def all(self) -> bool:\\n        return self.bit_count[\"1\"] == self.size\\n\\n    def one(self) -> bool:\\n        return self.bit_count[\"1\"] > 0\\n\\n    def count(self) -> int:\\n        return self.bit_count[\"1\"]\\n\\n    def toString(self) -> str:\\n        res = \"\"\\n        for i in range(self.size):\\n            if i in self.bit_indexes[\"1\"]:\\n                res+=\"1\"\\n            else:\\n                res+=\"0\"\\n\\n        return res\\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bit_count = {\"0\":size,\"1\":0}\\n        self.bit_indexes = {\"0\":{i for i in range(size)},\"1\":set()}\\n        self.size = size\\n        \\n    def fix(self, idx: int) -> None:\\n        if idx in self.bit_indexes[\"1\"]:\\n            return\\n        self.bit_indexes[\"0\"].remove(idx)\\n        self.bit_indexes[\"1\"].add(idx)\\n        self.bit_count[\"1\"] = self.bit_count[\"1\"] + 1\\n        self.bit_count[\"0\"] = self.bit_count[\"0\"] - 1\\n        \\n\\n    def unfix(self, idx: int) -> None:\\n        if idx in self.bit_indexes[\"0\"]:\\n            return\\n        self.bit_indexes[\"1\"].remove(idx)\\n        self.bit_indexes[\"0\"].add(idx)\\n        self.bit_count[\"1\"] = self.bit_count[\"1\"] - 1\\n        self.bit_count[\"0\"] = self.bit_count[\"0\"] + 1\\n\\n    def flip(self) -> None:\\n        self.bit_indexes[\"0\"],self.bit_indexes[\"1\"] = self.bit_indexes[\"1\"],self.bit_indexes[\"0\"]\\n        self.bit_count[\"0\"],self.bit_count[\"1\"] = self.bit_count[\"1\"],self.bit_count[\"0\"]\\n\\n    def all(self) -> bool:\\n        return self.bit_count[\"1\"] == self.size\\n\\n    def one(self) -> bool:\\n        return self.bit_count[\"1\"] > 0\\n\\n    def count(self) -> int:\\n        return self.bit_count[\"1\"]\\n\\n    def toString(self) -> str:\\n        res = \"\"\\n        for i in range(self.size):\\n            if i in self.bit_indexes[\"1\"]:\\n                res+=\"1\"\\n            else:\\n                res+=\"0\"\\n\\n        return res\\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789682,
                "title": "java-hashset-simple",
                "content": "**Idea:** Use separate hash-sets to store indices of ones and zeros. Using array, in most cases, will get TLE\\n>**T/S:**\\n>*constructor, toString*: O(size)/O(size)\\n>*fix, unfix, flip, all, one, count*: O(1)/O(1)\\n```\\nclass Bitset {\\n    private final int size;\\n    private Set<Integer> zeros = new HashSet<>();\\n    private Set<Integer> ones = new HashSet<>();\\n\\n    /**\\n     * @param size Initialize the Bitset with size bits, all of which are 0\\n     */\\n    public Bitset(int size) {\\n        this.size = size;\\n        for (var i = 0; i < size; i++)\\n            zeros.add(i);\\n    }\\n\\n    /**\\n     * @param idx Update the value of the bit at the index idx to 1. If the value was already 1, no change occurs.\\n     */\\n    public void fix(int idx) {\\n        zeros.remove(idx);\\n        ones.add(idx);\\n    }\\n\\n    /**\\n     * @param idx Update the value of the bit at the index idx to 0. If the value was already 0, no change occurs\\n     */\\n    public void unfix(int idx) {\\n        zeros.add(idx);\\n        ones.remove(idx);\\n    }\\n\\n    /**\\n     * Flips the values of each bit in the Bitset. In other words, all bits with value 0 will now have value 1 and\\n     * vice versa.\\n     */\\n    public void flip() {\\n        var temp = ones;\\n        ones = zeros;\\n        zeros = temp;\\n    }\\n\\n    /**\\n     * Checks if the value of each bit in the Bitset is 1.\\n     *\\n     * @return true if it satisfies the condition, false otherwise.\\n     */\\n    public boolean all() {\\n        return ones.size() == size;\\n    }\\n\\n    /**\\n     * Checks if there is at least one bit in the Bitset with value 1.\\n     *\\n     * @return true if it satisfies the condition, false otherwise.\\n     */\\n    public boolean one() {\\n        return !ones.isEmpty();\\n    }\\n\\n    /**\\n     * @return the total number of bits in the Bitset which have value 1.\\n     */\\n    public int count() {\\n        return ones.size();\\n    }\\n\\n    /**\\n     * Note that in the resultant string, the character at the ith index should coincide with the value\\n     * at the ith bit of the Bitset.\\n     *\\n     * @return the current composition of the Bitset.\\n     */\\n    public String toString() {\\n        return IntStream.range(0, size)\\n\\t\\t\\t\\t\\t\\t.mapToObj(i -> String.valueOf(zeros.contains(i) ? \\'0\\' : \\'1\\'))\\n\\t\\t\\t\\t\\t\\t.collect(Collectors.joining())\\n    }\\n}\\n```\\n**Note:** toString() 1 liner is just a short form of \\n```\\nvar str = new StringBuilder();\\n\\nfor (var i = 0; i < size; i++)\\n\\tstr.append(zeros.contains(i) ? \\'0\\' : \\'1\\');\\n\\nreturn str.toString();\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n    private final int size;\\n    private Set<Integer> zeros = new HashSet<>();\\n    private Set<Integer> ones = new HashSet<>();\\n\\n    /**\\n     * @param size Initialize the Bitset with size bits, all of which are 0\\n     */\\n    public Bitset(int size) {\\n        this.size = size;\\n        for (var i = 0; i < size; i++)\\n            zeros.add(i);\\n    }\\n\\n    /**\\n     * @param idx Update the value of the bit at the index idx to 1. If the value was already 1, no change occurs.\\n     */\\n    public void fix(int idx) {\\n        zeros.remove(idx);\\n        ones.add(idx);\\n    }\\n\\n    /**\\n     * @param idx Update the value of the bit at the index idx to 0. If the value was already 0, no change occurs\\n     */\\n    public void unfix(int idx) {\\n        zeros.add(idx);\\n        ones.remove(idx);\\n    }\\n\\n    /**\\n     * Flips the values of each bit in the Bitset. In other words, all bits with value 0 will now have value 1 and\\n     * vice versa.\\n     */\\n    public void flip() {\\n        var temp = ones;\\n        ones = zeros;\\n        zeros = temp;\\n    }\\n\\n    /**\\n     * Checks if the value of each bit in the Bitset is 1.\\n     *\\n     * @return true if it satisfies the condition, false otherwise.\\n     */\\n    public boolean all() {\\n        return ones.size() == size;\\n    }\\n\\n    /**\\n     * Checks if there is at least one bit in the Bitset with value 1.\\n     *\\n     * @return true if it satisfies the condition, false otherwise.\\n     */\\n    public boolean one() {\\n        return !ones.isEmpty();\\n    }\\n\\n    /**\\n     * @return the total number of bits in the Bitset which have value 1.\\n     */\\n    public int count() {\\n        return ones.size();\\n    }\\n\\n    /**\\n     * Note that in the resultant string, the character at the ith index should coincide with the value\\n     * at the ith bit of the Bitset.\\n     *\\n     * @return the current composition of the Bitset.\\n     */\\n    public String toString() {\\n        return IntStream.range(0, size)\\n\\t\\t\\t\\t\\t\\t.mapToObj(i -> String.valueOf(zeros.contains(i) ? \\'0\\' : \\'1\\'))\\n\\t\\t\\t\\t\\t\\t.collect(Collectors.joining())\\n    }\\n}\\n```\n```\\nvar str = new StringBuilder();\\n\\nfor (var i = 0; i < size; i++)\\n\\tstr.append(zeros.contains(i) ? \\'0\\' : \\'1\\');\\n\\nreturn str.toString();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736485,
                "title": "simple-java-solution",
                "content": "```\\nclass Bitset {\\n\\n    int[] arr;\\n    int count;\\n    boolean flipped;\\n\\n    public Bitset(int size) {\\n        arr = new int[size];\\n        count = 0;\\n        flipped = false;\\n    }\\n\\n    public void fix(int idx) {\\n        int a = flipped ? 1 : 0;\\n        int b = flipped ? 0 : 1;\\n        if (arr[idx] == a) {\\n            arr[idx] = b;\\n            count++;\\n        }\\n    }\\n\\n    public void unfix(int idx) {\\n        int a = flipped ? 0 : 1;\\n        int b = flipped ? 1 : 0;\\n        if (arr[idx] == a) {\\n            arr[idx] = b;\\n            count--;\\n        }\\n    }\\n\\n    public void flip() {\\n        flipped = !flipped;\\n        count = arr.length - count;\\n    }\\n\\n    public boolean all() {\\n        return count == arr.length;\\n    }\\n\\n    public boolean one() {\\n        return count > 0;\\n    }\\n\\n    public int count() {\\n        return count;\\n    }\\n\\n    public String toString() {\\n        int c = flipped ? 0 : 1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i : arr) {\\n            sb.append(i == c ? 1 : 0);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n\\n    int[] arr;\\n    int count;\\n    boolean flipped;\\n\\n    public Bitset(int size) {\\n        arr = new int[size];\\n        count = 0;\\n        flipped = false;\\n    }\\n\\n    public void fix(int idx) {\\n        int a = flipped ? 1 : 0;\\n        int b = flipped ? 0 : 1;\\n        if (arr[idx] == a) {\\n            arr[idx] = b;\\n            count++;\\n        }\\n    }\\n\\n    public void unfix(int idx) {\\n        int a = flipped ? 0 : 1;\\n        int b = flipped ? 1 : 0;\\n        if (arr[idx] == a) {\\n            arr[idx] = b;\\n            count--;\\n        }\\n    }\\n\\n    public void flip() {\\n        flipped = !flipped;\\n        count = arr.length - count;\\n    }\\n\\n    public boolean all() {\\n        return count == arr.length;\\n    }\\n\\n    public boolean one() {\\n        return count > 0;\\n    }\\n\\n    public int count() {\\n        return count;\\n    }\\n\\n    public String toString() {\\n        int c = flipped ? 0 : 1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i : arr) {\\n            sb.append(i == c ? 1 : 0);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730293,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Bitset {\\npublic:\\n   int n,z,e;\\n   string p=\"\",q=\"\";\\n    Bitset(int size) {\\n        n=size;\\n        for(int i=0;i<n;i++){\\n            p+=\\'0\\';\\n            q+=\\'1\\';\\n        }\\n        z=size;\\n        e=0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(p[idx]==\\'0\\'){\\n            z--;\\n            e++;\\n        }\\n        p[idx]=\\'1\\';\\n        q[idx]=\\'0\\';\\n    }\\n    \\n    void unfix(int idx) {\\n         if(p[idx]==\\'1\\'){\\n            z++;\\n            e--;\\n        }\\n        p[idx]=\\'0\\';\\n        q[idx]=\\'1\\';\\n    }\\n    \\n    void flip() {\\n        swap(p,q);\\n        swap(z,e);\\n    }\\n    \\n    bool all() {\\n       if(e==n)\\n       {\\n           return 1;\\n       } \\n       return 0;\\n    }\\n    \\n    bool one() {\\n       if(e>=1)\\n       {\\n           return 1;\\n       } \\n       return 0;\\n    }\\n    \\n    int count() {\\n        return e;\\n    }\\n    \\n    string toString() {\\n     return p;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n   int n,z,e;\\n   string p=\"\",q=\"\";\\n    Bitset(int size) {\\n        n=size;\\n        for(int i=0;i<n;i++){\\n            p+=\\'0\\';\\n            q+=\\'1\\';\\n        }\\n        z=size;\\n        e=0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(p[idx]==\\'0\\'){\\n            z--;\\n            e++;\\n        }\\n        p[idx]=\\'1\\';\\n        q[idx]=\\'0\\';\\n    }\\n    \\n    void unfix(int idx) {\\n         if(p[idx]==\\'1\\'){\\n            z++;\\n            e--;\\n        }\\n        p[idx]=\\'0\\';\\n        q[idx]=\\'1\\';\\n    }\\n    \\n    void flip() {\\n        swap(p,q);\\n        swap(z,e);\\n    }\\n    \\n    bool all() {\\n       if(e==n)\\n       {\\n           return 1;\\n       } \\n       return 0;\\n    }\\n    \\n    bool one() {\\n       if(e>=1)\\n       {\\n           return 1;\\n       } \\n       return 0;\\n    }\\n    \\n    int count() {\\n        return e;\\n    }\\n    \\n    string toString() {\\n     return p;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672850,
                "title": "two-set-ones-zeros-ez-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.ones=set()\\n        self.zeros=set({*[i for i in range(size)]})\\n        self.res=[0 for i in range(size)]\\n    def fix(self, idx: int) -> None:\\n        if idx in self.zeros:self.zeros.remove(idx)\\n        self.ones.add(idx)\\n\\n    def unfix(self, idx: int) -> None:\\n        if idx in self.ones:self.ones.remove(idx)\\n        self.zeros.add(idx)\\n\\n    def flip(self) -> None:\\n        prev=self.ones\\n        self.ones=self.zeros        \\n        self.zeros=prev\\n    def all(self) -> bool:\\n       \\n        return len(self.zeros)==0\\n\\n    def one(self) -> bool:\\n        \\n        return len(self.ones)>0\\n\\n    def count(self) -> int:\\n        return len(self.ones)\\n\\n    def toString(self) -> str:\\n        for i in self.ones:\\n            self.res[i]=\"1\"\\n        for i in self.zeros:\\n            self.res[i]=\"0\"\\n        return \"\".join([i for i in self.res])\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.ones=set()\\n        self.zeros=set({*[i for i in range(size)]})\\n        self.res=[0 for i in range(size)]\\n    def fix(self, idx: int) -> None:\\n        if idx in self.zeros:self.zeros.remove(idx)\\n        self.ones.add(idx)\\n\\n    def unfix(self, idx: int) -> None:\\n        if idx in self.ones:self.ones.remove(idx)\\n        self.zeros.add(idx)\\n\\n    def flip(self) -> None:\\n        prev=self.ones\\n        self.ones=self.zeros        \\n        self.zeros=prev\\n    def all(self) -> bool:\\n       \\n        return len(self.zeros)==0\\n\\n    def one(self) -> bool:\\n        \\n        return len(self.ones)>0\\n\\n    def count(self) -> int:\\n        return len(self.ones)\\n\\n    def toString(self) -> str:\\n        for i in self.ones:\\n            self.res[i]=\"1\"\\n        for i in self.zeros:\\n            self.res[i]=\"0\"\\n        return \"\".join([i for i in self.res])\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638059,
                "title": "easy-swift-set-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$ except `toString()` having O(n)  \\n- Space complexity: $$O(size)$$\\n\\n# Code\\n```\\nclass Bitset {\\n    var oneIndices: Set<Int>\\n    var zeroIndices: Set<Int>\\n\\n    init(_ size: Int) {\\n        zeroIndices =  Set(0..<size)\\n        oneIndices = []\\n    }\\n    \\n    func fix(_ idx: Int) {\\n        if let i = zeroIndices.remove(idx) { \\n            oneIndices.insert(i)\\n        }\\n    }\\n    \\n    func unfix(_ idx: Int) {\\n        if let i = oneIndices.remove(idx) { \\n            zeroIndices.insert(i)   \\n        }\\n    }\\n    \\n    func flip() {\\n        (oneIndices, zeroIndices) = (zeroIndices, oneIndices)\\n    }\\n    \\n    func all() -> Bool {\\n        zeroIndices.count == 0\\n    }\\n    \\n    func one() -> Bool {\\n        oneIndices.count >= 1\\n    }\\n    \\n    func count() -> Int {\\n        oneIndices.count\\n    }\\n    \\n    func toString() -> String {\\n        String((0..<(oneIndices.count + zeroIndices.count)).map { oneIndices.contains($0) ? \"1\" : \"0\" })\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * let obj = Bitset(size)\\n * obj.fix(idx)\\n * obj.unfix(idx)\\n * obj.flip()\\n * let ret_4: Bool = obj.all()\\n * let ret_5: Bool = obj.one()\\n * let ret_6: Int = obj.count()\\n * let ret_7: String = obj.toString()\\n */\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Bitset {\\n    var oneIndices: Set<Int>\\n    var zeroIndices: Set<Int>\\n\\n    init(_ size: Int) {\\n        zeroIndices =  Set(0..<size)\\n        oneIndices = []\\n    }\\n    \\n    func fix(_ idx: Int) {\\n        if let i = zeroIndices.remove(idx) { \\n            oneIndices.insert(i)\\n        }\\n    }\\n    \\n    func unfix(_ idx: Int) {\\n        if let i = oneIndices.remove(idx) { \\n            zeroIndices.insert(i)   \\n        }\\n    }\\n    \\n    func flip() {\\n        (oneIndices, zeroIndices) = (zeroIndices, oneIndices)\\n    }\\n    \\n    func all() -> Bool {\\n        zeroIndices.count == 0\\n    }\\n    \\n    func one() -> Bool {\\n        oneIndices.count >= 1\\n    }\\n    \\n    func count() -> Int {\\n        oneIndices.count\\n    }\\n    \\n    func toString() -> String {\\n        String((0..<(oneIndices.count + zeroIndices.count)).map { oneIndices.contains($0) ? \"1\" : \"0\" })\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * let obj = Bitset(size)\\n * obj.fix(idx)\\n * obj.unfix(idx)\\n * obj.flip()\\n * let ret_4: Bool = obj.all()\\n * let ret_5: Bool = obj.one()\\n * let ret_6: Int = obj.count()\\n * let ret_7: String = obj.toString()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628987,
                "title": "clean-best-c-code-o-1-all-operations",
                "content": "# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Bitset {\\npublic:\\n    string bitSet,flipped;\\n    int countOne,size;\\n    Bitset(int size) {\\n        bitSet.resize(size,\\'0\\');\\n        flipped.resize(size,\\'1\\');\\n        countOne = 0;\\n        this->size = size;\\n    }\\n    \\n    void fix(int ind) {\\n        if(bitSet[ind] == \\'0\\'){\\n            countOne++;\\n            bitSet[ind] = \\'1\\';\\n        }\\n        flipped[ind] = \\'0\\';\\n    }\\n    \\n    void unfix(int ind) {\\n        if(bitSet[ind] == \\'1\\'){\\n            countOne--;\\n            bitSet[ind] = \\'0\\';\\n        }\\n        flipped[ind] = \\'1\\';\\n    }\\n    \\n    void flip() {\\n        swap(bitSet,flipped);\\n        countOne = size - countOne;\\n    }\\n    \\n    bool all() {\\n        return (countOne == size);\\n    }\\n    \\n    bool one() {\\n        return (countOne >= 1);\\n    }\\n    \\n    int count() {\\n        return countOne;\\n    }\\n    \\n    string toString() {\\n        return bitSet;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */",
                "solutionTags": [
                    "C++",
                    "String",
                    "Design"
                ],
                "code": "# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Bitset {\\npublic:\\n    string bitSet,flipped;\\n    int countOne,size;\\n    Bitset(int size) {\\n        bitSet.resize(size,\\'0\\');\\n        flipped.resize(size,\\'1\\');\\n        countOne = 0;\\n        this->size = size;\\n    }\\n    \\n    void fix(int ind) {\\n        if(bitSet[ind] == \\'0\\'){\\n            countOne++;\\n            bitSet[ind] = \\'1\\';\\n        }\\n        flipped[ind] = \\'0\\';\\n    }\\n    \\n    void unfix(int ind) {\\n        if(bitSet[ind] == \\'1\\'){\\n            countOne--;\\n            bitSet[ind] = \\'0\\';\\n        }\\n        flipped[ind] = \\'1\\';\\n    }\\n    \\n    void flip() {\\n        swap(bitSet,flipped);\\n        countOne = size - countOne;\\n    }\\n    \\n    bool all() {\\n        return (countOne == size);\\n    }\\n    \\n    bool one() {\\n        return (countOne >= 1);\\n    }\\n    \\n    int count() {\\n        return countOne;\\n    }\\n    \\n    string toString() {\\n        return bitSet;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 3587441,
                "title": "effective-approach-using-two-arrays",
                "content": "An approach using one array for manipulation is enough, however operations of flip and toString are too slow. Since time complexity for flip() and toString() are O(N)\\n\\nHence, i used two Arrays, when fix() is called, i do fix in one array and do unfix in the other. The same applies to unfix(). When flip() is called, \\ni just swap each other. Hence, I win in terms of Time Complexity reducing it from O(N) till O(1)\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(2 * N) = O (N)\\n\\n# Code\\n```\\nclass Bitset(private val size: Int) {\\n\\n    private var count = 0\\n\\n    private var zeroArray = IntArray(size)\\n\\n    private var oneArray = List(size) {\\n        1\\n    }.toIntArray()\\n\\n    private var zeroArrayStringBuilder = StringBuilder(\\n        zeroArray.joinToString(separator = \"\") { \"$it\" }\\n    )\\n\\n    private var oneArrayStringBuilder = StringBuilder(\\n        oneArray.joinToString(separator = \"\") { \"$it\" }\\n    )\\n\\n\\n    fun fix(index: Int) {\\n        if (zeroArray[index] == 1) {\\n            return\\n        }\\n        zeroArray[index] = 1\\n        zeroArrayStringBuilder.setCharAt(index, \\'1\\')\\n\\n        oneArray[index] = 0\\n        oneArrayStringBuilder.setCharAt(index, \\'0\\')\\n        count++\\n    }\\n\\n    fun unfix(index: Int) {\\n        if (zeroArray[index] == 0) {\\n            return\\n        }\\n        zeroArray[index] = 0\\n        zeroArrayStringBuilder.setCharAt(index, \\'0\\')\\n\\n        oneArray[index] = 1\\n        oneArrayStringBuilder.setCharAt(index, \\'1\\')\\n\\n        count--\\n    }\\n\\n    fun flip() {\\n        val temp = zeroArray\\n        zeroArray = oneArray\\n        oneArray = temp\\n        count = size - count\\n\\n        val tempString = zeroArrayStringBuilder\\n        zeroArrayStringBuilder = oneArrayStringBuilder\\n        oneArrayStringBuilder = tempString\\n    }\\n\\n    fun all(): Boolean {\\n       return count == size\\n    }\\n\\n    fun one(): Boolean {\\n        return count > 0\\n    }\\n\\n    fun count(): Int {\\n        return count\\n    }\\n\\n    override fun toString(): String {\\n        return zeroArrayStringBuilder.toString()\\n    }\\n\\n}\\n\\n\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * var obj = Bitset(size)\\n * obj.fix(idx)\\n * obj.unfix(idx)\\n * obj.flip()\\n * var param_4 = obj.all()\\n * var param_5 = obj.one()\\n * var param_6 = obj.count()\\n * var param_7 = obj.toString()\\n */\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Array"
                ],
                "code": "```\\nclass Bitset(private val size: Int) {\\n\\n    private var count = 0\\n\\n    private var zeroArray = IntArray(size)\\n\\n    private var oneArray = List(size) {\\n        1\\n    }.toIntArray()\\n\\n    private var zeroArrayStringBuilder = StringBuilder(\\n        zeroArray.joinToString(separator = \"\") { \"$it\" }\\n    )\\n\\n    private var oneArrayStringBuilder = StringBuilder(\\n        oneArray.joinToString(separator = \"\") { \"$it\" }\\n    )\\n\\n\\n    fun fix(index: Int) {\\n        if (zeroArray[index] == 1) {\\n            return\\n        }\\n        zeroArray[index] = 1\\n        zeroArrayStringBuilder.setCharAt(index, \\'1\\')\\n\\n        oneArray[index] = 0\\n        oneArrayStringBuilder.setCharAt(index, \\'0\\')\\n        count++\\n    }\\n\\n    fun unfix(index: Int) {\\n        if (zeroArray[index] == 0) {\\n            return\\n        }\\n        zeroArray[index] = 0\\n        zeroArrayStringBuilder.setCharAt(index, \\'0\\')\\n\\n        oneArray[index] = 1\\n        oneArrayStringBuilder.setCharAt(index, \\'1\\')\\n\\n        count--\\n    }\\n\\n    fun flip() {\\n        val temp = zeroArray\\n        zeroArray = oneArray\\n        oneArray = temp\\n        count = size - count\\n\\n        val tempString = zeroArrayStringBuilder\\n        zeroArrayStringBuilder = oneArrayStringBuilder\\n        oneArrayStringBuilder = tempString\\n    }\\n\\n    fun all(): Boolean {\\n       return count == size\\n    }\\n\\n    fun one(): Boolean {\\n        return count > 0\\n    }\\n\\n    fun count(): Int {\\n        return count\\n    }\\n\\n    override fun toString(): String {\\n        return zeroArrayStringBuilder.toString()\\n    }\\n\\n}\\n\\n\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * var obj = Bitset(size)\\n * obj.fix(idx)\\n * obj.unfix(idx)\\n * obj.flip()\\n * var param_4 = obj.all()\\n * var param_5 = obj.one()\\n * var param_6 = obj.count()\\n * var param_7 = obj.toString()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586614,
                "title": "difficult-to-understand-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Bitset {\\npublic:  \\nvector<int> str;\\nbool fp;\\nint cnt1,cnt0,sz,swap;\\n    Bitset(int size) {\\n     str.resize(size,0);\\n      cnt0=size;\\n    sz=size;\\n    fp=false;\\n    cnt1=0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(fp){\\n          if(str[idx]==1)\\n          str[idx]=0,cnt1++,cnt0--;\\n        }\\n        else{\\n            if(str[idx]==0)\\n            str[idx]=1,cnt1++,cnt0--;\\n\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n       if(fp){\\n            if(str[idx]==0)\\n            str[idx]=1,cnt0++,cnt1--;\\n\\n\\n       }\\n       else{\\n            if(str[idx]==1)\\n            str[idx]=0,cnt0++,cnt1--;\\n       }\\n       \\n    }\\n    \\n    void flip() {\\n        fp = !fp;\\n        swap=cnt1;\\n        cnt1=cnt0;\\n        cnt0=swap;\\n    }\\n    \\n    bool all() {\\n        if(cnt1==sz) return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n        if(cnt1>0) return true;\\n        return false;\\n    }\\n    \\n    int count() {\\n        return cnt1;\\n    }\\n    \\n    string toString() {\\n        string ans;\\n        if(fp){\\n            for(int i=0;i<sz;i++)\\n            {\\n                if(str[i]==0)\\n               ans +=\\'1\\',str[i]=1;\\n                else\\n                ans +=\\'0\\',str[i]=0;\\n            }\\n            fp=false;\\n        }\\n        else{\\n              for(int i=0;i<sz;i++)\\n            {\\n                if(str[i]==0)\\n               ans +=\\'0\\';\\n                else\\n                ans +=\\'1\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Bitset {\\npublic:  \\nvector<int> str;\\nbool fp;\\nint cnt1,cnt0,sz,swap;\\n    Bitset(int size) {\\n     str.resize(size,0);\\n      cnt0=size;\\n    sz=size;\\n    fp=false;\\n    cnt1=0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(fp){\\n          if(str[idx]==1)\\n          str[idx]=0,cnt1++,cnt0--;\\n        }\\n        else{\\n            if(str[idx]==0)\\n            str[idx]=1,cnt1++,cnt0--;\\n\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n       if(fp){\\n            if(str[idx]==0)\\n            str[idx]=1,cnt0++,cnt1--;\\n\\n\\n       }\\n       else{\\n            if(str[idx]==1)\\n            str[idx]=0,cnt0++,cnt1--;\\n       }\\n       \\n    }\\n    \\n    void flip() {\\n        fp = !fp;\\n        swap=cnt1;\\n        cnt1=cnt0;\\n        cnt0=swap;\\n    }\\n    \\n    bool all() {\\n        if(cnt1==sz) return true;\\n        return false;\\n    }\\n    \\n    bool one() {\\n        if(cnt1>0) return true;\\n        return false;\\n    }\\n    \\n    int count() {\\n        return cnt1;\\n    }\\n    \\n    string toString() {\\n        string ans;\\n        if(fp){\\n            for(int i=0;i<sz;i++)\\n            {\\n                if(str[i]==0)\\n               ans +=\\'1\\',str[i]=1;\\n                else\\n                ans +=\\'0\\',str[i]=0;\\n            }\\n            fp=false;\\n        }\\n        else{\\n              for(int i=0;i<sz;i++)\\n            {\\n                if(str[i]==0)\\n               ans +=\\'0\\';\\n                else\\n                ans +=\\'1\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583729,
                "title": "c-o-n-for-tostring-o-1-for-everything-else-swap-meaning",
                "content": "Just swap what 0 and 1 mean in terms of bit value whenever ```flip()``` is called. Also swap frequency of 0s and 1s.\\nMaintain frequency of 0s and 1s separately.\\n\\nCode:\\n```\\nclass Bitset {\\npublic:\\n    int n_o,n_z,n;\\n    vector<int> bitset;\\n    unordered_map<int,char> map;//assigns meaning to bit values. saves us from traversing the array when flip is called\\n    Bitset(int n) {\\n        this->n=n;\\n        bitset.resize(n,0);\\n        map[0]=\\'z\\';map[1]=\\'o\\';\\n        n_o=0;n_z=n; //no. of ones = 0, no. of zeros =n initially.\\n    }\\n    \\n    void fix(int idx) {\\n        if(map[bitset[idx]]==\\'z\\'){\\n            bitset[idx]^=1;\\n            n_z-=1;\\n            n_o+=1;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(map[bitset[idx]]==\\'o\\'){\\n            bitset[idx]^=1;\\n            n_z+=1;\\n            n_o-=1;\\n        }\\n    }\\n    \\n    void flip() {\\n        swap(map[0],map[1]);//swap meaning of bit value.\\n        swap(n_o,n_z);//swap the frequency.\\n    }\\n    \\n    bool all() {\\n        return n_o==n;\\n    }\\n    \\n    bool one() {\\n        return n_o>0;\\n    }\\n    \\n    int count() {\\n        return n_o;\\n    }\\n    \\n    string toString() {\\n        string s=\"\";\\n        for(int i=0;i<n;i++){\\n            if(map[bitset[i]]==\\'z\\'){s.push_back(\\'0\\');}\\n            else{s.push_back(\\'1\\');}\\n        }\\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```flip()```\n```\\nclass Bitset {\\npublic:\\n    int n_o,n_z,n;\\n    vector<int> bitset;\\n    unordered_map<int,char> map;//assigns meaning to bit values. saves us from traversing the array when flip is called\\n    Bitset(int n) {\\n        this->n=n;\\n        bitset.resize(n,0);\\n        map[0]=\\'z\\';map[1]=\\'o\\';\\n        n_o=0;n_z=n; //no. of ones = 0, no. of zeros =n initially.\\n    }\\n    \\n    void fix(int idx) {\\n        if(map[bitset[idx]]==\\'z\\'){\\n            bitset[idx]^=1;\\n            n_z-=1;\\n            n_o+=1;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(map[bitset[idx]]==\\'o\\'){\\n            bitset[idx]^=1;\\n            n_z+=1;\\n            n_o-=1;\\n        }\\n    }\\n    \\n    void flip() {\\n        swap(map[0],map[1]);//swap meaning of bit value.\\n        swap(n_o,n_z);//swap the frequency.\\n    }\\n    \\n    bool all() {\\n        return n_o==n;\\n    }\\n    \\n    bool one() {\\n        return n_o>0;\\n    }\\n    \\n    int count() {\\n        return n_o;\\n    }\\n    \\n    string toString() {\\n        string s=\"\";\\n        for(int i=0;i<n;i++){\\n            if(map[bitset[i]]==\\'z\\'){s.push_back(\\'0\\');}\\n            else{s.push_back(\\'1\\');}\\n        }\\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583365,
                "title": "day-156-java",
                "content": "\\n\\n# Code\\n```\\nclass Bitset {\\n    private char[] a;\\n    private char[] b;\\n    private int cnt;\\n\\n    public Bitset(int size) {\\n        a = new char[size];\\n        b = new char[size];\\n        Arrays.fill(a, \\'0\\');\\n        Arrays.fill(b, \\'1\\');\\n    }\\n\\n    public void fix(int idx) {\\n        if (a[idx] == \\'0\\') {\\n            a[idx] = \\'1\\';\\n            ++cnt;\\n        }\\n        b[idx] = \\'0\\';\\n    }\\n\\n    public void unfix(int idx) {\\n        if (a[idx] == \\'1\\') {\\n            a[idx] = \\'0\\';\\n            --cnt;\\n        }\\n        b[idx] = \\'1\\';\\n    }\\n\\n    public void flip() {\\n        char[] t = a;\\n        a = b;\\n        b = t;\\n        cnt = a.length - cnt;\\n    }\\n\\n    public boolean all() {\\n        return cnt == a.length;\\n    }\\n\\n    public boolean one() {\\n        return cnt > 0;\\n    }\\n\\n    public int count() {\\n        return cnt;\\n    }\\n\\n    public String toString() {\\n        return String.valueOf(a);\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n    private char[] a;\\n    private char[] b;\\n    private int cnt;\\n\\n    public Bitset(int size) {\\n        a = new char[size];\\n        b = new char[size];\\n        Arrays.fill(a, \\'0\\');\\n        Arrays.fill(b, \\'1\\');\\n    }\\n\\n    public void fix(int idx) {\\n        if (a[idx] == \\'0\\') {\\n            a[idx] = \\'1\\';\\n            ++cnt;\\n        }\\n        b[idx] = \\'0\\';\\n    }\\n\\n    public void unfix(int idx) {\\n        if (a[idx] == \\'1\\') {\\n            a[idx] = \\'0\\';\\n            --cnt;\\n        }\\n        b[idx] = \\'1\\';\\n    }\\n\\n    public void flip() {\\n        char[] t = a;\\n        a = b;\\n        b = t;\\n        cnt = a.length - cnt;\\n    }\\n\\n    public boolean all() {\\n        return cnt == a.length;\\n    }\\n\\n    public boolean one() {\\n        return cnt > 0;\\n    }\\n\\n    public int count() {\\n        return cnt;\\n    }\\n\\n    public String toString() {\\n        return String.valueOf(a);\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582891,
                "title": "simple-c-approach",
                "content": "```\\nvector<int>num ;\\n    int set , unset ;\\n    int flipe = 0 ;\\n    Bitset(int size) {\\n        \\n        num.resize( size , 0 ) ;\\n        \\n        set = 0 ;\\n        unset = size ;\\n    }\\n    \\n    void fix(int idx) {\\n        \\n        if( ( num[idx] + flipe )%2 == 0 )\\n        {\\n            num[idx]++ ;\\n            set++ ;\\n            unset-- ;\\n        }\\n        \\n    }\\n    \\n    void unfix(int idx) {\\n        if(( num[idx] + flipe )%2 == 1)\\n        {\\n            num[idx]-- ;\\n            set-- ;\\n            unset++ ;\\n        }\\n    }\\n    \\n    void flip() {\\n        int temp = set ;\\n        flipe++ ;\\n        set = unset ;\\n        unset = temp ;\\n        \\n        \\n        \\n    }\\n    \\n    bool all() {\\n        \\n        if( unset == 0 ) return  true ; \\n        \\n        return false ;\\n        \\n    }\\n    \\n    bool one() {\\n        if( set != 0 ) return  true ; \\n        \\n        return false ;\\n    }\\n    \\n    int count() {\\n        return set ;\\n    }\\n    \\n    string toString() {\\n        string s = \"\" ;\\n        \\n        for( int i = 0 ; i < num.size() ; i++ )\\n        {\\n            if(( num[i] + flipe )%2 == 1)\\n            {\\n                s += \"1\" ;\\n            }\\n            else{\\n                s += \"0\" ;\\n            }\\n        }\\n        \\n        return  s ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int>num ;\\n    int set , unset ;\\n    int flipe = 0 ;\\n    Bitset(int size) {\\n        \\n        num.resize( size , 0 ) ;\\n        \\n        set = 0 ;\\n        unset = size ;\\n    }\\n    \\n    void fix(int idx) {\\n        \\n        if( ( num[idx] + flipe )%2 == 0 )\\n        {\\n            num[idx]++ ;\\n            set++ ;\\n            unset-- ;\\n        }\\n        \\n    }\\n    \\n    void unfix(int idx) {\\n        if(( num[idx] + flipe )%2 == 1)\\n        {\\n            num[idx]-- ;\\n            set-- ;\\n            unset++ ;\\n        }\\n    }\\n    \\n    void flip() {\\n        int temp = set ;\\n        flipe++ ;\\n        set = unset ;\\n        unset = temp ;\\n        \\n        \\n        \\n    }\\n    \\n    bool all() {\\n        \\n        if( unset == 0 ) return  true ; \\n        \\n        return false ;\\n        \\n    }\\n    \\n    bool one() {\\n        if( set != 0 ) return  true ; \\n        \\n        return false ;\\n    }\\n    \\n    int count() {\\n        return set ;\\n    }\\n    \\n    string toString() {\\n        string s = \"\" ;\\n        \\n        for( int i = 0 ; i < num.size() ; i++ )\\n        {\\n            if(( num[i] + flipe )%2 == 1)\\n            {\\n                s += \"1\" ;\\n            }\\n            else{\\n                s += \"0\" ;\\n            }\\n        }\\n        \\n        return  s ;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582336,
                "title": "python-using-2-hashsets-all-in-o-1-except-tostring",
                "content": "# Code\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        ## self.O to store 1 indexes and self.Z to store 0 indexes\\n        self.O = set()\\n        self.Z = set([x for x in range(size)])\\n        self.size = size\\n\\n    def fix(self, idx: int) -> None:\\n        self.O.add(idx)\\n        if idx in self.Z:\\n            self.Z.remove(idx)\\n\\n    def unfix(self, idx: int) -> None:\\n        self.Z.add(idx)\\n        if idx in self.O:\\n            self.O.remove(idx)\\n\\n    def flip(self) -> None:\\n        self.Z, self.O = self.O, self.Z\\n\\n    def all(self) -> bool:\\n        return len(self.Z) == 0\\n\\n    def one(self) -> bool:\\n        return len(self.O) >= 1\\n\\n    def count(self) -> int:\\n        return len(self.O)\\n\\n    def toString(self) -> str:\\n        temp = [\"0\"] * self.size\\n        for index in self.O:\\n            temp[index] = \"1\"\\n        return \"\".join(temp)\\n\\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        ## self.O to store 1 indexes and self.Z to store 0 indexes\\n        self.O = set()\\n        self.Z = set([x for x in range(size)])\\n        self.size = size\\n\\n    def fix(self, idx: int) -> None:\\n        self.O.add(idx)\\n        if idx in self.Z:\\n            self.Z.remove(idx)\\n\\n    def unfix(self, idx: int) -> None:\\n        self.Z.add(idx)\\n        if idx in self.O:\\n            self.O.remove(idx)\\n\\n    def flip(self) -> None:\\n        self.Z, self.O = self.O, self.Z\\n\\n    def all(self) -> bool:\\n        return len(self.Z) == 0\\n\\n    def one(self) -> bool:\\n        return len(self.O) >= 1\\n\\n    def count(self) -> int:\\n        return len(self.O)\\n\\n    def toString(self) -> str:\\n        temp = [\"0\"] * self.size\\n        for index in self.O:\\n            temp[index] = \"1\"\\n        return \"\".join(temp)\\n\\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581948,
                "title": "cpp-using-set",
                "content": "```\\nclass Bitset {\\npublic:\\n    set<int> st;\\n    int sz;\\n    bool flipp=1;\\n    Bitset(int size) {\\n        sz=size;\\n    }\\n    \\n    void fix(int idx) {\\n        if(flipp)\\n            st.insert(idx);\\n        else{\\n            auto it = st.find(idx);\\n            if(it!=st.end())\\n                st.erase(it);\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(flipp){\\n            auto it = st.find(idx);\\n            if(it!=st.end())\\n                st.erase(it);\\n        }\\n        else{\\n            st.insert(idx);\\n        }\\n    }\\n    \\n    void flip() {\\n        flipp = !flipp;\\n    }\\n    \\n    bool all() {\\n        int x = flipp?st.size():sz-st.size();\\n        return x==sz;\\n    }\\n    \\n    bool one() {\\n        int x = flipp?st.size():sz-st.size();\\n        return x;\\n    }\\n    \\n    int count() {\\n        int x = flipp?st.size():sz-st.size();\\n        return x;\\n    }\\n    \\n    string toString() {\\n        string ans;\\n        auto it = st.begin();\\n        for(int i=0;i<sz;i++){\\n            if(it!=st.end() and i==*it) {\\n                ans.push_back(flipp?\\'1\\':\\'0\\');\\n                it++;\\n            }\\n            else ans.push_back(flipp?\\'0\\':\\'1\\');\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    set<int> st;\\n    int sz;\\n    bool flipp=1;\\n    Bitset(int size) {\\n        sz=size;\\n    }\\n    \\n    void fix(int idx) {\\n        if(flipp)\\n            st.insert(idx);\\n        else{\\n            auto it = st.find(idx);\\n            if(it!=st.end())\\n                st.erase(it);\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(flipp){\\n            auto it = st.find(idx);\\n            if(it!=st.end())\\n                st.erase(it);\\n        }\\n        else{\\n            st.insert(idx);\\n        }\\n    }\\n    \\n    void flip() {\\n        flipp = !flipp;\\n    }\\n    \\n    bool all() {\\n        int x = flipp?st.size():sz-st.size();\\n        return x==sz;\\n    }\\n    \\n    bool one() {\\n        int x = flipp?st.size():sz-st.size();\\n        return x;\\n    }\\n    \\n    int count() {\\n        int x = flipp?st.size():sz-st.size();\\n        return x;\\n    }\\n    \\n    string toString() {\\n        string ans;\\n        auto it = st.begin();\\n        for(int i=0;i<sz;i++){\\n            if(it!=st.end() and i==*it) {\\n                ans.push_back(flipp?\\'1\\':\\'0\\');\\n                it++;\\n            }\\n            else ans.push_back(flipp?\\'0\\':\\'1\\');\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581908,
                "title": "python-using-dictionary-with-explanation",
                "content": "We use two ```dictionary``` to track which bit is ```0``` or ```1``` by putting its index into them.\\n\\nFor example, if the ```size``` is 8, at the beginning, we had two dictionary as:\\n```self.bitOne = {}```\\n```self.zero = {0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1}```\\n\\nIf we run ```fix(1)```, the two dictionary will be:\\n```self.bitOne = {1: 1}```\\n```self.zero = {0: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1}```\\n\\nWhen we run ```fix```, ensure the ```idx``` is put into ```self.bitOne```, and remove from ```self.zero``` if ```idx``` is in it.\\n```unfix``` using the same idea from ```fix```.\\n\\n```flip```, very simple, we swap ```self.bitOne``` and ```self.zero```.\\n\\nFor the rest of the functions, they\\'re quite easy to understand though, so I am not going through every of them.\\nBy the way, I think it\\'s also ok to go with ```set```.\\nThank you for reading this solution.\\n\\n\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bitOne = {}\\n        self.zero = {i:1 for i in range(size)}\\n        self.length = size\\n\\n    def fix(self, idx: int) -> None:\\n        self.bitOne[idx] = 1\\n        if idx in self.zero: self.zero.pop(idx)\\n\\n    def unfix(self, idx: int) -> None:\\n        self.zero[idx] = 1\\n        if idx in self.bitOne: self.bitOne.pop(idx)\\n\\n    def flip(self) -> None:\\n        self.zero, self.bitOne = self.bitOne, self.zero\\n\\n    def all(self) -> bool:\\n        return len(self.bitOne) == self.length\\n\\n    def one(self) -> bool:\\n        return len(self.bitOne) > 0\\n\\n    def count(self) -> int:\\n        return len(self.bitOne)\\n\\n    def toString(self) -> str:\\n        result = [\"0\"]*self.length\\n        for i in self.bitOne: result[i] = \"1\"\\n        return \\'\\'.join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```dictionary```\n```0```\n```1```\n```size```\n```self.bitOne = {}```\n```self.zero = {0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1}```\n```fix(1)```\n```self.bitOne = {1: 1}```\n```self.zero = {0: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1}```\n```fix```\n```idx```\n```self.bitOne```\n```self.zero```\n```idx```\n```unfix```\n```fix```\n```flip```\n```self.bitOne```\n```self.zero```\n```set```\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bitOne = {}\\n        self.zero = {i:1 for i in range(size)}\\n        self.length = size\\n\\n    def fix(self, idx: int) -> None:\\n        self.bitOne[idx] = 1\\n        if idx in self.zero: self.zero.pop(idx)\\n\\n    def unfix(self, idx: int) -> None:\\n        self.zero[idx] = 1\\n        if idx in self.bitOne: self.bitOne.pop(idx)\\n\\n    def flip(self) -> None:\\n        self.zero, self.bitOne = self.bitOne, self.zero\\n\\n    def all(self) -> bool:\\n        return len(self.bitOne) == self.length\\n\\n    def one(self) -> bool:\\n        return len(self.bitOne) > 0\\n\\n    def count(self) -> int:\\n        return len(self.bitOne)\\n\\n    def toString(self) -> str:\\n        result = [\"0\"]*self.length\\n        for i in self.bitOne: result[i] = \"1\"\\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581896,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Bitset {\\npublic:\\n    int counter=0;\\n    string bit;\\n    string inverse_bit;\\n    Bitset(int size) {\\n        for(int i=0;i<size;i++){\\n            bit+=\\'0\\';\\n            inverse_bit+=\\'1\\';\\n        }\\n    }\\n    \\n    void fix(int idx) {\\n        if(bit[idx]==\\'0\\')\\n            counter++;\\n        bit[idx]=\\'1\\';\\n        inverse_bit[idx]=\\'0\\';\\n    }\\n    \\n    void unfix(int idx) {\\n        if(bit[idx]==\\'1\\')\\n            counter--;\\n        bit[idx]=\\'0\\';\\n        inverse_bit[idx]=\\'1\\';\\n    }\\n    \\n    void flip() {\\n        swap(bit,inverse_bit);\\n        counter=bit.size()-counter;\\n    }\\n    bool all() {\\n        return counter==bit.size();\\n    }\\n    \\n    bool one() {\\n        return counter>0;\\n    }\\n    \\n    int count() {\\n        return counter;\\n    }\\n    \\n    string toString() {\\n        return bit;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    int counter=0;\\n    string bit;\\n    string inverse_bit;\\n    Bitset(int size) {\\n        for(int i=0;i<size;i++){\\n            bit+=\\'0\\';\\n            inverse_bit+=\\'1\\';\\n        }\\n    }\\n    \\n    void fix(int idx) {\\n        if(bit[idx]==\\'0\\')\\n            counter++;\\n        bit[idx]=\\'1\\';\\n        inverse_bit[idx]=\\'0\\';\\n    }\\n    \\n    void unfix(int idx) {\\n        if(bit[idx]==\\'1\\')\\n            counter--;\\n        bit[idx]=\\'0\\';\\n        inverse_bit[idx]=\\'1\\';\\n    }\\n    \\n    void flip() {\\n        swap(bit,inverse_bit);\\n        counter=bit.size()-counter;\\n    }\\n    bool all() {\\n        return counter==bit.size();\\n    }\\n    \\n    bool one() {\\n        return counter>0;\\n    }\\n    \\n    int count() {\\n        return counter;\\n    }\\n    \\n    string toString() {\\n        return bit;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581629,
                "title": "c-every-operation-in-o-1-easy-explanation-bits-and-anti-bits",
                "content": "# **Bits** and **Anti-Bits**\\nThe only operation which gives an issue is the `flip()` operation, given that you apply the brute force approach.\\nTo counter the same, we can use 2 strings, `bits` and `antiBits`, using which we perform the given operation on the `bits` string and the exact reverse operation on the `antiBits` string.\\nWhen the `flip()` operation is required, we swap these 2 strings.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ - All Operations\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Bitset {\\nprivate:\\n    string bits;\\n    string antiBits;\\n    \\n    int zeros;\\n    int ones;\\n    int size;\\n\\npublic:\\n    Bitset(int size) {\\n        bits = string (size , \\'0\\');\\n        antiBits = string(size , \\'1\\');\\n\\n        zeros = size;\\n        ones = 0;   \\n        this -> size = size;\\n    }\\n    \\n    void fix(int idx) {\\n        if(bits[idx] == \\'0\\'){\\n            zeros--;\\n            ones++;\\n            bits[idx] = \\'1\\';\\n\\n            if(antiBits[idx] == \\'1\\'){\\n                antiBits[idx] = \\'0\\';\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(bits[idx] == \\'1\\'){\\n            zeros++;\\n            ones--;\\n            bits[idx] = \\'0\\';\\n\\n            if(antiBits[idx] == \\'0\\'){\\n                antiBits[idx] = \\'1\\';\\n            }\\n        }\\n        \\n    }\\n    \\n    void flip() {\\n        swap(ones , zeros);\\n        swap(bits , antiBits);\\n    }\\n    \\n    bool all() {\\n        return (ones == size);\\n    }\\n    \\n    bool one() {\\n        return ones;\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        return bits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Bitset {\\nprivate:\\n    string bits;\\n    string antiBits;\\n    \\n    int zeros;\\n    int ones;\\n    int size;\\n\\npublic:\\n    Bitset(int size) {\\n        bits = string (size , \\'0\\');\\n        antiBits = string(size , \\'1\\');\\n\\n        zeros = size;\\n        ones = 0;   \\n        this -> size = size;\\n    }\\n    \\n    void fix(int idx) {\\n        if(bits[idx] == \\'0\\'){\\n            zeros--;\\n            ones++;\\n            bits[idx] = \\'1\\';\\n\\n            if(antiBits[idx] == \\'1\\'){\\n                antiBits[idx] = \\'0\\';\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(bits[idx] == \\'1\\'){\\n            zeros++;\\n            ones--;\\n            bits[idx] = \\'0\\';\\n\\n            if(antiBits[idx] == \\'0\\'){\\n                antiBits[idx] = \\'1\\';\\n            }\\n        }\\n        \\n    }\\n    \\n    void flip() {\\n        swap(ones , zeros);\\n        swap(bits , antiBits);\\n    }\\n    \\n    bool all() {\\n        return (ones == size);\\n    }\\n    \\n    bool one() {\\n        return ones;\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    \\n    string toString() {\\n        return bits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581536,
                "title": "c-store-bits-tightly-in-a-long-100-memory-and-87-runtime",
                "content": "# Approach\\nWill store bits inside the array of long integers where one integer contains 64 bits.\\n\\n`flip` just reverses `fix` and `unfix` operations.\\n\\n# Complexity\\n- Time complexity:\\n    - `toString`: $$O(n)$$\\n    - the rest: $$O(1)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Bitset {\\npublic:\\n    constexpr static size_t BSZ = 64;\\n    Bitset(int size)\\n        : sz_(size)\\n        , cnt_(0)\\n        , v_((size + BSZ - 1) / BSZ)\\n        , fl_(false)\\n    {\\n    }\\n    \\n    void fix(int idx) {\\n        auto bucket = idx >> 6;\\n        auto bitidx = idx & 0x3f;\\n        auto fixed = !fl_ ? (v_[bucket] | (1ull << bitidx)) : (v_[bucket] & ~(1ull << bitidx));\\n        if (fixed != v_[bucket]) {\\n            v_[bucket] = fixed;\\n            cnt_++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        auto bucket = idx >> 6;\\n        auto bitidx = idx & 0x3f;\\n        auto fixed = fl_ ? (v_[bucket] | (1ull << bitidx)) : (v_[bucket] & ~(1ull << bitidx));\\n        if (fixed != v_[bucket]) {\\n            v_[bucket] = fixed;\\n            cnt_--;\\n        }\\n    }\\n    \\n    void flip() {\\n        fl_ = !fl_;\\n        cnt_ = sz_ - cnt_;\\n    }\\n    \\n    bool all() {\\n        return sz_ == cnt_;\\n    }\\n    \\n    bool one() {\\n        return cnt_ > 0;\\n    }\\n    \\n    int count() {\\n        return cnt_;\\n    }\\n    \\n    string toString() {\\n        string res(sz_, \\'0\\');\\n        auto i = 0;\\n        for (auto b : v_)\\n            for (auto j = 0; j < BSZ && i < sz_; ++i, ++j)\\n                if (bool(b & (1ull << j)) != fl_)\\n                    res[i] = \\'1\\';\\n        return res;\\n    }\\nprivate:\\n    int sz_;\\n    int cnt_;\\n    vector<uint64_t> v_;\\n    bool fl_;\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    constexpr static size_t BSZ = 64;\\n    Bitset(int size)\\n        : sz_(size)\\n        , cnt_(0)\\n        , v_((size + BSZ - 1) / BSZ)\\n        , fl_(false)\\n    {\\n    }\\n    \\n    void fix(int idx) {\\n        auto bucket = idx >> 6;\\n        auto bitidx = idx & 0x3f;\\n        auto fixed = !fl_ ? (v_[bucket] | (1ull << bitidx)) : (v_[bucket] & ~(1ull << bitidx));\\n        if (fixed != v_[bucket]) {\\n            v_[bucket] = fixed;\\n            cnt_++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        auto bucket = idx >> 6;\\n        auto bitidx = idx & 0x3f;\\n        auto fixed = fl_ ? (v_[bucket] | (1ull << bitidx)) : (v_[bucket] & ~(1ull << bitidx));\\n        if (fixed != v_[bucket]) {\\n            v_[bucket] = fixed;\\n            cnt_--;\\n        }\\n    }\\n    \\n    void flip() {\\n        fl_ = !fl_;\\n        cnt_ = sz_ - cnt_;\\n    }\\n    \\n    bool all() {\\n        return sz_ == cnt_;\\n    }\\n    \\n    bool one() {\\n        return cnt_ > 0;\\n    }\\n    \\n    int count() {\\n        return cnt_;\\n    }\\n    \\n    string toString() {\\n        string res(sz_, \\'0\\');\\n        auto i = 0;\\n        for (auto b : v_)\\n            for (auto j = 0; j < BSZ && i < sz_; ++i, ++j)\\n                if (bool(b & (1ull << j)) != fl_)\\n                    res[i] = \\'1\\';\\n        return res;\\n    }\\nprivate:\\n    int sz_;\\n    int cnt_;\\n    vector<uint64_t> v_;\\n    bool fl_;\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581434,
                "title": "2166-design-bitset",
                "content": "*Approach I*    The most simple solution!!! - **But would lead to TLE**\\n```\\nclass Bitset {\\npublic:\\n    vector<int>vec;\\n   \\n    Bitset(int size) {  \\n    vec.resize(size,0);     \\n    }\\n    \\n    void fix(int idx) {\\n    vec[idx]=1;    \\n    }\\n    \\n    void unfix(int idx) {\\n    vec[idx]=0;    \\n    }\\n    \\n    void flip() {\\n    for(int i=0;i<vec.size();i++)\\n    {\\n        if(vec[i]==1)\\n            vec[i]=0;\\n        else\\n            vec[i]=1;\\n    }\\n        vec=!vec;\\n    }\\n    \\n    bool all() {\\n    for(int i=0;i<vec.size();i++)\\n    {\\n        if(vec[i]==0)\\n            return false;\\n    }\\n        return true;\\n    }\\n    \\n    bool one() {\\n    for(int i=0;i<vec.size();i++)\\n    {\\n        if(vec[i]==1)\\n            return true;\\n    }\\n        return false;    \\n    }\\n    \\n    int count() {\\n     int cnt=0;\\n        for(int i=0;i<vec.size();i++)\\n    {\\n        if(vec[i]==1)\\n           cnt++;\\n    }\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n       string ans;\\n      for(int i=0;i<vec.size();i++)\\n      {\\n          string temp=to_string(vec[i]);\\n          ans+=temp;\\n      }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```\\n\\nThe better solution- **Solving TLE**\\n*Approach II*\\n```\\nclass Bitset {\\npublic:\\n    string ans, flipped;\\n    int set=0,n;\\n    \\n    Bitset(int size) {\\n    ans=string(size,\\'0\\');\\n    flipped=string(size,\\'1\\');\\n    n=size;    \\n    }\\n    \\n    void fix(int idx) {\\n    if(ans[idx]==\\'0\\') set++;\\n        ans[idx]=\\'1\\';\\n        flipped[idx]=\\'0\\';\\n    }\\n    \\n    void unfix(int idx) {\\n    if(ans[idx]==\\'1\\') set--;\\n        ans[idx]=\\'0\\';\\n        flipped[idx]=\\'1\\';\\n    }\\n    \\n    void flip() {\\n       ans.swap(flipped);\\n        set=n-set;\\n    }\\n    \\n    bool all() {\\n        return set==n;\\n    }\\n    \\n    bool one() {\\n        return set>=1;\\n    }\\n    \\n    int count() {\\n        return set;\\n    }\\n    \\n    string toString() {\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```\\nIn the second approach, rather than creating a vector and then converting it into string which would be a O(n) opertaion always. We intially take strings.\\nHere, two strings have been taken so as to make the opertion of flipping of O(1) .\\nAll the opertaions are of O(1) T.C.\\n\\nHappy Coding!",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    vector<int>vec;\\n   \\n    Bitset(int size) {  \\n    vec.resize(size,0);     \\n    }\\n    \\n    void fix(int idx) {\\n    vec[idx]=1;    \\n    }\\n    \\n    void unfix(int idx) {\\n    vec[idx]=0;    \\n    }\\n    \\n    void flip() {\\n    for(int i=0;i<vec.size();i++)\\n    {\\n        if(vec[i]==1)\\n            vec[i]=0;\\n        else\\n            vec[i]=1;\\n    }\\n        vec=!vec;\\n    }\\n    \\n    bool all() {\\n    for(int i=0;i<vec.size();i++)\\n    {\\n        if(vec[i]==0)\\n            return false;\\n    }\\n        return true;\\n    }\\n    \\n    bool one() {\\n    for(int i=0;i<vec.size();i++)\\n    {\\n        if(vec[i]==1)\\n            return true;\\n    }\\n        return false;    \\n    }\\n    \\n    int count() {\\n     int cnt=0;\\n        for(int i=0;i<vec.size();i++)\\n    {\\n        if(vec[i]==1)\\n           cnt++;\\n    }\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n       string ans;\\n      for(int i=0;i<vec.size();i++)\\n      {\\n          string temp=to_string(vec[i]);\\n          ans+=temp;\\n      }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```\n```\\nclass Bitset {\\npublic:\\n    string ans, flipped;\\n    int set=0,n;\\n    \\n    Bitset(int size) {\\n    ans=string(size,\\'0\\');\\n    flipped=string(size,\\'1\\');\\n    n=size;    \\n    }\\n    \\n    void fix(int idx) {\\n    if(ans[idx]==\\'0\\') set++;\\n        ans[idx]=\\'1\\';\\n        flipped[idx]=\\'0\\';\\n    }\\n    \\n    void unfix(int idx) {\\n    if(ans[idx]==\\'1\\') set--;\\n        ans[idx]=\\'0\\';\\n        flipped[idx]=\\'1\\';\\n    }\\n    \\n    void flip() {\\n       ans.swap(flipped);\\n        set=n-set;\\n    }\\n    \\n    bool all() {\\n        return set==n;\\n    }\\n    \\n    bool one() {\\n        return set>=1;\\n    }\\n    \\n    int count() {\\n        return set;\\n    }\\n    \\n    string toString() {\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581066,
                "title": "c-two-solutions-o-1-calls",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNumbers of ones in current bit can be stored in integer `ones`. If `flip()` is called this will also be updated.\\nInstead of flipping every bit whenever flip is called, a status boolean `flipped` can be maintained. Then `fix()` and `unfix()` can be called using simple logic between boolean `flipped` and bit value `bit[idx]`.\\nFor `toString()` if string is not `flipped` just return `bit` otherwise set `flipped` to false , flip all the bits and return the new `bit`.\\nHowever this function becomes $O(n)$. The main problem is that we need to flip all the bits. So, in the second approach, we maintained a flipped version of `bit` , string `flip_bit`.\\nLogic is pretty much same. Just remember whatever operation that you did on `bit`, do its reverse on `flip_bit` [i.e. if `bit[idx]` was set to `0` set `flip_bit[idx]` to `1` and vice-versa]. In this case boolean `flipped` acts as a switch that changes current bit to `bit` or `flip_bit`.\\n# Code [Without maintaining flip string]\\n```\\nclass Bitset {\\npublic:\\n    int size;\\n    string bit;\\n    int ones;\\n    bool flipped;\\n    Bitset(int size) {\\n        this->size = size;\\n        this->bit = string(size,\\'0\\');\\n        ones = 0;\\n        flipped = false;\\n    }\\n    \\n    void fix(int idx) {\\n        //if flipped is true, that means in actuality\\n        //0 is 1 and 1 is 0\\n        if(flipped && bit[idx]==\\'1\\'){\\n            bit[idx]=\\'0\\';\\n            ones++;\\n        }\\n        else if(!flipped && bit[idx]==\\'0\\'){\\n            bit[idx] = \\'1\\';\\n            ones++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        //if flipped is true, that means in actuality\\n        //0 is 1 and 1 is 0\\n        if(flipped && bit[idx]==\\'0\\'){\\n            bit[idx] = \\'1\\';\\n            ones--;\\n        }\\n        else if(!flipped && bit[idx]==\\'1\\'){\\n            bit[idx] = \\'0\\';\\n            ones--;\\n        }\\n    }\\n    \\n    void flip() {\\n        ones = size - ones;\\n        flipped^=1;\\n    }\\n    \\n    bool all() {\\n        return ones==size;\\n    }\\n    \\n    bool one() {\\n        return ones;\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    void flipit(){\\n        for(auto&x:bit){\\n            if(x==\\'0\\') x=\\'1\\';\\n            else x=\\'0\\';\\n        }\\n    }\\n    string toString() {\\n        if(!flipped) return bit;\\n        flipped = false;\\n        flipit();\\n        return bit;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```\\n# Complexity\\n- Time complexity: \\nAll calls are $O(1)$ except `toString()` which is $O(n)$\\n\\n- Space complexity:\\n1 string of length n is maintained, $O(n)$\\n____________________________\\n\\n# Code [Maintaining flip string]\\n```\\nclass Bitset {\\npublic:\\n    int size;\\n    string bit;\\n    string flip_bit;\\n    int ones;\\n    bool flipped;\\n    Bitset(int size) {\\n        this->size = size;\\n        this->bit = string(size,\\'0\\');\\n        this->flip_bit = string(size,\\'1\\');\\n        ones = 0;\\n        flipped = false;\\n    }\\n    \\n    void fix(int idx) {\\n        //if flipped is true, current string is flip_bit\\n        //otherwise current string is bit\\n        if(flipped && flip_bit[idx]==\\'0\\'){\\n            flip_bit[idx]=\\'1\\';\\n            bit[idx]=\\'0\\';\\n            ones++;\\n        }\\n        else if(!flipped && bit[idx]==\\'0\\'){\\n            bit[idx] = \\'1\\';\\n            flip_bit[idx] = \\'0\\';\\n            ones++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        //if flipped is true, current string is flip_bit\\n        //otherwise current string is bit\\n        if(flipped && flip_bit[idx]==\\'1\\'){\\n            flip_bit[idx] = \\'0\\';\\n            bit[idx] = \\'1\\';\\n            ones--;\\n        }\\n        else if(!flipped && bit[idx]==\\'1\\'){\\n            bit[idx] = \\'0\\';\\n            flip_bit[idx] = \\'1\\';\\n            ones--;\\n        }\\n    }\\n    \\n    void flip() {\\n        ones = size - ones;\\n        flipped^=1;\\n    }\\n    \\n    bool all() {\\n        return ones==size;\\n    }\\n    \\n    bool one() {\\n        return ones;\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    string toString() {\\n        if(!flipped) return bit;\\n        return flip_bit;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```\\n# Complexity\\n- Time complexity: \\nAll calls are $O(1)$\\n\\n- Space complexity:\\n2 strings of length n is maintained, $O(n)$\\n\\n______________\\nDo upvote if you liked the solution.",
                "solutionTags": [
                    "C++",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    int size;\\n    string bit;\\n    int ones;\\n    bool flipped;\\n    Bitset(int size) {\\n        this->size = size;\\n        this->bit = string(size,\\'0\\');\\n        ones = 0;\\n        flipped = false;\\n    }\\n    \\n    void fix(int idx) {\\n        //if flipped is true, that means in actuality\\n        //0 is 1 and 1 is 0\\n        if(flipped && bit[idx]==\\'1\\'){\\n            bit[idx]=\\'0\\';\\n            ones++;\\n        }\\n        else if(!flipped && bit[idx]==\\'0\\'){\\n            bit[idx] = \\'1\\';\\n            ones++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        //if flipped is true, that means in actuality\\n        //0 is 1 and 1 is 0\\n        if(flipped && bit[idx]==\\'0\\'){\\n            bit[idx] = \\'1\\';\\n            ones--;\\n        }\\n        else if(!flipped && bit[idx]==\\'1\\'){\\n            bit[idx] = \\'0\\';\\n            ones--;\\n        }\\n    }\\n    \\n    void flip() {\\n        ones = size - ones;\\n        flipped^=1;\\n    }\\n    \\n    bool all() {\\n        return ones==size;\\n    }\\n    \\n    bool one() {\\n        return ones;\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    void flipit(){\\n        for(auto&x:bit){\\n            if(x==\\'0\\') x=\\'1\\';\\n            else x=\\'0\\';\\n        }\\n    }\\n    string toString() {\\n        if(!flipped) return bit;\\n        flipped = false;\\n        flipit();\\n        return bit;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```\n```\\nclass Bitset {\\npublic:\\n    int size;\\n    string bit;\\n    string flip_bit;\\n    int ones;\\n    bool flipped;\\n    Bitset(int size) {\\n        this->size = size;\\n        this->bit = string(size,\\'0\\');\\n        this->flip_bit = string(size,\\'1\\');\\n        ones = 0;\\n        flipped = false;\\n    }\\n    \\n    void fix(int idx) {\\n        //if flipped is true, current string is flip_bit\\n        //otherwise current string is bit\\n        if(flipped && flip_bit[idx]==\\'0\\'){\\n            flip_bit[idx]=\\'1\\';\\n            bit[idx]=\\'0\\';\\n            ones++;\\n        }\\n        else if(!flipped && bit[idx]==\\'0\\'){\\n            bit[idx] = \\'1\\';\\n            flip_bit[idx] = \\'0\\';\\n            ones++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        //if flipped is true, current string is flip_bit\\n        //otherwise current string is bit\\n        if(flipped && flip_bit[idx]==\\'1\\'){\\n            flip_bit[idx] = \\'0\\';\\n            bit[idx] = \\'1\\';\\n            ones--;\\n        }\\n        else if(!flipped && bit[idx]==\\'1\\'){\\n            bit[idx] = \\'0\\';\\n            flip_bit[idx] = \\'1\\';\\n            ones--;\\n        }\\n    }\\n    \\n    void flip() {\\n        ones = size - ones;\\n        flipped^=1;\\n    }\\n    \\n    bool all() {\\n        return ones==size;\\n    }\\n    \\n    bool one() {\\n        return ones;\\n    }\\n    \\n    int count() {\\n        return ones;\\n    }\\n    string toString() {\\n        if(!flipped) return bit;\\n        return flip_bit;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580744,
                "title": "beats-94-6-solution-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Bitset {\\n    string s;\\n    int cnt;\\n    int flp;\\npublic:\\n    Bitset(int size) {\\n        s = \"\";\\n        for(int i=0; i<size; i++){\\n            s.push_back(\\'0\\');\\n        }\\n        cnt = 0;\\n        flp = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(s[idx]==\\'0\\' && flp%2==0){\\n            s[idx] = \\'1\\';\\n            cnt++;\\n        }\\n        else if(s[idx]==\\'1\\' && flp%2==1){\\n            s[idx] = \\'0\\';\\n            cnt++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(s[idx]==\\'1\\' && flp%2==0){\\n            s[idx] = \\'0\\';\\n            cnt--;\\n        }\\n        else if(s[idx]==\\'0\\' && flp%2==1){\\n            s[idx] = \\'1\\';\\n            cnt--;\\n        }\\n    }\\n    \\n    void flip() {\\n        cnt = s.length()-cnt;\\n        flp++;\\n    }\\n    \\n    bool all() {\\n        return cnt==s.length();\\n    }\\n    \\n    bool one() {\\n        return cnt>=1;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        if(flp&1){\\n            string temp = \"\";\\n            for(int i=0; i<s.length(); i++){\\n                char ch = s[i]==\\'0\\' ? \\'1\\' : \\'0\\';\\n                temp.push_back(ch);\\n            }\\n            return temp;\\n        }\\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Bitset {\\n    string s;\\n    int cnt;\\n    int flp;\\npublic:\\n    Bitset(int size) {\\n        s = \"\";\\n        for(int i=0; i<size; i++){\\n            s.push_back(\\'0\\');\\n        }\\n        cnt = 0;\\n        flp = 0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(s[idx]==\\'0\\' && flp%2==0){\\n            s[idx] = \\'1\\';\\n            cnt++;\\n        }\\n        else if(s[idx]==\\'1\\' && flp%2==1){\\n            s[idx] = \\'0\\';\\n            cnt++;\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(s[idx]==\\'1\\' && flp%2==0){\\n            s[idx] = \\'0\\';\\n            cnt--;\\n        }\\n        else if(s[idx]==\\'0\\' && flp%2==1){\\n            s[idx] = \\'1\\';\\n            cnt--;\\n        }\\n    }\\n    \\n    void flip() {\\n        cnt = s.length()-cnt;\\n        flp++;\\n    }\\n    \\n    bool all() {\\n        return cnt==s.length();\\n    }\\n    \\n    bool one() {\\n        return cnt>=1;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        if(flp&1){\\n            string temp = \"\";\\n            for(int i=0; i<s.length(); i++){\\n                char ch = s[i]==\\'0\\' ? \\'1\\' : \\'0\\';\\n                temp.push_back(ch);\\n            }\\n            return temp;\\n        }\\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580436,
                "title": "easy-two-strings-approach-all-operations-o-1",
                "content": "# Intuition\\nJust use two strings\\n\\n# Approach\\n\\nJust use two strings\\n\\n# Complexity\\n- Time complexity:\\n- All operations O(1)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nLength of strings\\n\\n# Code\\n```\\nclass Bitset {\\npublic:\\n\\n    string s;\\n    string s1;\\n    int ones = 0;\\n   // int zeroes = 0;\\n    Bitset(int size) {\\n\\n        for(int i = 0; i < size; i++){\\n            s += \\'0\\';\\n            s1 += \\'1\\';\\n        }\\n       // zeroes = size;\\n        \\n    }\\n    \\n    void fix(int idx) {\\n\\n        if(s[idx] == \\'1\\'){\\n            return;\\n        }\\n        s[idx] = \\'1\\';\\n        s1[idx] = \\'0\\';\\n        ones++;\\n        \\n    }\\n    \\n    void unfix(int idx) {\\n\\n         if(s[idx] == \\'0\\'){\\n            return;\\n        }\\n        s[idx] = \\'0\\';\\n        s1[idx] = \\'1\\';\\n        ones--;\\n        \\n    }\\n    \\n    void flip() {\\n\\n        string temp;\\n        temp = s;\\n        s = s1;\\n        s1 = temp;\\n\\n        ones = s.length() - ones;\\n    }\\n    \\n    bool all() {\\n\\n        return ones == s.length();\\n        \\n    }\\n    \\n    bool one() {\\n\\n        return ones > 0;\\n        \\n    }\\n    \\n    int count() {\\n\\n        return ones;\\n        \\n    }\\n    \\n    string toString() {\\n\\n        return s;\\n        \\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n\\n    string s;\\n    string s1;\\n    int ones = 0;\\n   // int zeroes = 0;\\n    Bitset(int size) {\\n\\n        for(int i = 0; i < size; i++){\\n            s += \\'0\\';\\n            s1 += \\'1\\';\\n        }\\n       // zeroes = size;\\n        \\n    }\\n    \\n    void fix(int idx) {\\n\\n        if(s[idx] == \\'1\\'){\\n            return;\\n        }\\n        s[idx] = \\'1\\';\\n        s1[idx] = \\'0\\';\\n        ones++;\\n        \\n    }\\n    \\n    void unfix(int idx) {\\n\\n         if(s[idx] == \\'0\\'){\\n            return;\\n        }\\n        s[idx] = \\'0\\';\\n        s1[idx] = \\'1\\';\\n        ones--;\\n        \\n    }\\n    \\n    void flip() {\\n\\n        string temp;\\n        temp = s;\\n        s = s1;\\n        s1 = temp;\\n\\n        ones = s.length() - ones;\\n    }\\n    \\n    bool all() {\\n\\n        return ones == s.length();\\n        \\n    }\\n    \\n    bool one() {\\n\\n        return ones > 0;\\n        \\n    }\\n    \\n    int count() {\\n\\n        return ones;\\n        \\n    }\\n    \\n    string toString() {\\n\\n        return s;\\n        \\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456371,
                "title": "design-bitset",
                "content": "--------------- Easy C++ Solution -------\\n\\n# Code\\n```\\nclass Bitset {\\npublic:\\n   Bitset(int size) : s(size, \\'0\\'), r(size, \\'1\\') {}\\n\\n  void fix(int idx) {\\n    if (s[idx] == \\'0\\')\\n      ++cnt;\\n    s[idx] = \\'1\\';\\n    r[idx] = \\'0\\';\\n  }\\n\\n  void unfix(int idx) {\\n    if (s[idx] == \\'1\\')\\n      --cnt;\\n    s[idx] = \\'0\\';\\n    r[idx] = \\'1\\';\\n  }\\n\\n  void flip() {\\n    swap(s, r);\\n    cnt = s.length() - cnt;\\n  }\\n\\n  bool all() {\\n    return cnt == s.length();\\n  }\\n\\n  bool one() {\\n    return cnt;\\n  }\\n\\n  int count() {\\n    return cnt;\\n  }\\n\\n  string toString() {\\n    return s;\\n  }\\n\\n private:\\n  string s;  \\n  string r;\\n  int cnt = 0;\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n   Bitset(int size) : s(size, \\'0\\'), r(size, \\'1\\') {}\\n\\n  void fix(int idx) {\\n    if (s[idx] == \\'0\\')\\n      ++cnt;\\n    s[idx] = \\'1\\';\\n    r[idx] = \\'0\\';\\n  }\\n\\n  void unfix(int idx) {\\n    if (s[idx] == \\'1\\')\\n      --cnt;\\n    s[idx] = \\'0\\';\\n    r[idx] = \\'1\\';\\n  }\\n\\n  void flip() {\\n    swap(s, r);\\n    cnt = s.length() - cnt;\\n  }\\n\\n  bool all() {\\n    return cnt == s.length();\\n  }\\n\\n  bool one() {\\n    return cnt;\\n  }\\n\\n  int count() {\\n    return cnt;\\n  }\\n\\n  string toString() {\\n    return s;\\n  }\\n\\n private:\\n  string s;  \\n  string r;\\n  int cnt = 0;\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453692,
                "title": "kotlin-o-1-for-all-except-tostring-one-hashset-only",
                "content": "```\\nclass Bitset(private val size: Int) {\\n\\n    private val indicesHolder = mutableSetOf<Int>() // initially contains indices of ones\\n    private var holderContainsOnes = true\\n    \\n    fun fix(idx: Int) = when(holderContainsOnes) { \\n        true -> indicesHolder.add(idx)\\n        false -> indicesHolder.remove(idx)\\n    }\\n\\n    fun unfix(idx: Int) = when(holderContainsOnes) { \\n        true -> indicesHolder.remove(idx)\\n        false -> indicesHolder.add(idx)\\n    }\\n\\n    fun flip() {\\n        holderContainsOnes = !holderContainsOnes\\n    }\\n\\n    fun all() = count() == size\\n\\n    fun one() = count() >= 1\\n\\n    fun count() = if (holderContainsOnes) indicesHolder.size else size - indicesHolder.size\\n\\n    override fun toString(): String {\\n        val arr: IntArray\\n        if (holderContainsOnes) {\\n            arr = IntArray(size)\\n            indicesHolder.forEach { arr[it] = 1 }\\n        } else {\\n            arr = IntArray(size) { 1 }\\n            indicesHolder.forEach { arr[it] = 0 }\\n        }\\n        \\n        return arr.joinToString(separator = \"\")\\n    }\\n\\n}\\n ```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Bitset(private val size: Int) {\\n\\n    private val indicesHolder = mutableSetOf<Int>() // initially contains indices of ones\\n    private var holderContainsOnes = true\\n    \\n    fun fix(idx: Int) = when(holderContainsOnes) { \\n        true -> indicesHolder.add(idx)\\n        false -> indicesHolder.remove(idx)\\n    }\\n\\n    fun unfix(idx: Int) = when(holderContainsOnes) { \\n        true -> indicesHolder.remove(idx)\\n        false -> indicesHolder.add(idx)\\n    }\\n\\n    fun flip() {\\n        holderContainsOnes = !holderContainsOnes\\n    }\\n\\n    fun all() = count() == size\\n\\n    fun one() = count() >= 1\\n\\n    fun count() = if (holderContainsOnes) indicesHolder.size else size - indicesHolder.size\\n\\n    override fun toString(): String {\\n        val arr: IntArray\\n        if (holderContainsOnes) {\\n            arr = IntArray(size)\\n            indicesHolder.forEach { arr[it] = 1 }\\n        } else {\\n            arr = IntArray(size) { 1 }\\n            indicesHolder.forEach { arr[it] = 0 }\\n        }\\n        \\n        return arr.joinToString(separator = \"\")\\n    }\\n\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3371686,
                "title": "readable-and-simple-no-need-for-the-flip-flag-just-flip-arrays-on-flip-operation",
                "content": "# Intuition\\nThe intention is to provide O(1) on every operation. What if we maintain both straignt and flipped flags at the same time?\\nTo reduce the time on building String what if we store the bits as a char array?\\n\\n# Approach\\nSo we maintain 2 arrays bits and flippedBits as char[] of \\'0\\' or \\'1\\'\\nOn the flip operation we just swap the arrays.\\n\\n# Complexity\\n- Time complexity:\\nO(1) on all operation except toString() - we don\\'t iterate there explicitly but internally toString() does.\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Bitset {\\n    char[] bits;\\n    char[] flippedBits;\\n    int oneCount;\\n\\n    public Bitset(int size) {\\n        this.bits = new char[size];\\n        Arrays.fill(bits, \\'0\\');\\n        this.flippedBits = new char[size];\\n        Arrays.fill(flippedBits, \\'1\\');\\n        this.oneCount = 0;\\n    }\\n    \\n    public void fix(int idx) {\\n        oneCount += bits[idx]==\\'0\\' ? 1 : 0;\\n        bits[idx] = \\'1\\';\\n        flippedBits[idx] = \\'0\\';\\n    }\\n    \\n    public void unfix(int idx) {\\n        oneCount -= bits[idx]==\\'1\\' ? 1 : 0;\\n        bits[idx] = \\'0\\';\\n        flippedBits[idx] = \\'1\\';\\n    }\\n    \\n    public void flip() {\\n        char[] tmp = bits;\\n        bits = flippedBits;\\n        flippedBits = tmp;\\n\\n        oneCount = bits.length - oneCount;\\n    }\\n    \\n    public boolean all() {\\n        return oneCount==bits.length;\\n    }\\n    \\n    public boolean one() {\\n        return oneCount>0;\\n    }\\n    \\n    public int count() {\\n        return oneCount;\\n    }\\n    \\n    public String toString() {\\n        return new String(bits);\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n    char[] bits;\\n    char[] flippedBits;\\n    int oneCount;\\n\\n    public Bitset(int size) {\\n        this.bits = new char[size];\\n        Arrays.fill(bits, \\'0\\');\\n        this.flippedBits = new char[size];\\n        Arrays.fill(flippedBits, \\'1\\');\\n        this.oneCount = 0;\\n    }\\n    \\n    public void fix(int idx) {\\n        oneCount += bits[idx]==\\'0\\' ? 1 : 0;\\n        bits[idx] = \\'1\\';\\n        flippedBits[idx] = \\'0\\';\\n    }\\n    \\n    public void unfix(int idx) {\\n        oneCount -= bits[idx]==\\'1\\' ? 1 : 0;\\n        bits[idx] = \\'0\\';\\n        flippedBits[idx] = \\'1\\';\\n    }\\n    \\n    public void flip() {\\n        char[] tmp = bits;\\n        bits = flippedBits;\\n        flippedBits = tmp;\\n\\n        oneCount = bits.length - oneCount;\\n    }\\n    \\n    public boolean all() {\\n        return oneCount==bits.length;\\n    }\\n    \\n    public boolean one() {\\n        return oneCount>0;\\n    }\\n    \\n    public int count() {\\n        return oneCount;\\n    }\\n    \\n    public String toString() {\\n        return new String(bits);\\n    }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353760,
                "title": "python-keep-two-sets-original-and-reversed",
                "content": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bits = [[0] * size, [1] * size]\\n        self.size = size\\n        self.cnt_1 = 0\\n        self.cnt_flip = 0\\n\\n    def fix(self, idx: int) -> None:\\n        b = self.bits[self.cnt_flip]\\n        if b[idx] == 0:\\n            self.cnt_1 += 1\\n        b[idx] = 1\\n        self.bits[(self.cnt_flip + 1) % 2][idx] = 0\\n        \\n\\n    def unfix(self, idx: int) -> None:\\n        b = self.bits[self.cnt_flip]\\n        if b[idx] == 1:\\n            self.cnt_1 -= 1\\n        b[idx] = 0\\n        self.bits[(self.cnt_flip + 1) % 2][idx] = 1\\n        \\n\\n    def flip(self) -> None:\\n        self.cnt_flip = (self.cnt_flip + 1) % 2\\n        self.cnt_1 = self.size - self.cnt_1\\n        \\n\\n    def all(self) -> bool:\\n        return self.cnt_1 == self.size\\n        \\n\\n    def one(self) -> bool:\\n        return self.cnt_1 > 0\\n        \\n\\n    def count(self) -> int:\\n        return self.cnt_1\\n        \\n\\n    def toString(self) -> str:\\n        return \"\".join(map(str, self.bits[self.cnt_flip]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bits = [[0] * size, [1] * size]\\n        self.size = size\\n        self.cnt_1 = 0\\n        self.cnt_flip = 0\\n\\n    def fix(self, idx: int) -> None:\\n        b = self.bits[self.cnt_flip]\\n        if b[idx] == 0:\\n            self.cnt_1 += 1\\n        b[idx] = 1\\n        self.bits[(self.cnt_flip + 1) % 2][idx] = 0\\n        \\n\\n    def unfix(self, idx: int) -> None:\\n        b = self.bits[self.cnt_flip]\\n        if b[idx] == 1:\\n            self.cnt_1 -= 1\\n        b[idx] = 0\\n        self.bits[(self.cnt_flip + 1) % 2][idx] = 1\\n        \\n\\n    def flip(self) -> None:\\n        self.cnt_flip = (self.cnt_flip + 1) % 2\\n        self.cnt_1 = self.size - self.cnt_1\\n        \\n\\n    def all(self) -> bool:\\n        return self.cnt_1 == self.size\\n        \\n\\n    def one(self) -> bool:\\n        return self.cnt_1 > 0\\n        \\n\\n    def count(self) -> int:\\n        return self.cnt_1\\n        \\n\\n    def toString(self) -> str:\\n        return \"\".join(map(str, self.bits[self.cnt_flip]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317528,
                "title": "real-bitset-1-bit-map-to-1-bit-in-memory",
                "content": "# Intuition\\nIn a bitset 1 bit should map to 1 bit in memory. std::bitset is of fixed-sized and cannot be used. std::vector<bool> could be useful though\\n\\n# Approach\\nDo all operations with bit-shifts and bitwise operators\\n\\n# Complexity\\n- Time complexity:\\nBad according to LC because the function flip() flips all the bits \\n\\n# Code\\n```\\nclass Bitset\\n{\\n    public:\\n    Bitset(int size)\\n    {\\n        int s = size / 8 + ((size % 8) != 0);\\n        size_ = size;\\n        data_.resize(s, 0);\\n    }\\n\\n    void fix(int p)\\n    {\\n        auto& el = data_[p / 8];\\n        int i = p % 8;\\n\\n        uint8_t mask = 0b10000000;\\n        mask >>= i;\\n        if((el | mask) != el) ++bit1;\\n        el |= mask;\\n    }\\n\\n    void unfix(int p)\\n    {\\n        auto& el = data_[p / 8];\\n        int i = p % 8;\\n        uint8_t mask = 0b10000000;\\n        mask >>= i;\\n        mask = ~mask; \\n\\n        if((el & mask) != el) --bit1;\\n        el &= mask;\\n    }\\n\\n    bool one()\\n    {\\n        return bit1 > 0;\\n    }\\n\\n    bool all()\\n    {\\n        return bit1 == size_;\\n    }\\n\\n    void flip()\\n    {\\n        for(auto& el : data_) el = ~el;\\n        bit1 = size_ - bit1; \\n    }\\n\\n    int count()\\n    {\\n        return bit1;\\n    }\\n\\n    std::string toString()\\n    {\\n        std::string str;\\n        for(int i = 0; i < data_.size(); ++i)\\n        {\\n            int maxj = std::min(size_, i * 8 + 8);\\n            uint8_t mask = 0b10000000;\\n            for(int j = i * 8; j < maxj; ++j)\\n            {\\n                str += \\'0\\' + ((data_[i] & mask) != 0);\\n                mask >>= 1;\\n            }\\n        }\\n        return str;\\n    }\\n\\n    std::vector<uint8_t> data_;\\n    int size_ = 0;\\n    int bit1 = 0;\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Bitset\\n{\\n    public:\\n    Bitset(int size)\\n    {\\n        int s = size / 8 + ((size % 8) != 0);\\n        size_ = size;\\n        data_.resize(s, 0);\\n    }\\n\\n    void fix(int p)\\n    {\\n        auto& el = data_[p / 8];\\n        int i = p % 8;\\n\\n        uint8_t mask = 0b10000000;\\n        mask >>= i;\\n        if((el | mask) != el) ++bit1;\\n        el |= mask;\\n    }\\n\\n    void unfix(int p)\\n    {\\n        auto& el = data_[p / 8];\\n        int i = p % 8;\\n        uint8_t mask = 0b10000000;\\n        mask >>= i;\\n        mask = ~mask; \\n\\n        if((el & mask) != el) --bit1;\\n        el &= mask;\\n    }\\n\\n    bool one()\\n    {\\n        return bit1 > 0;\\n    }\\n\\n    bool all()\\n    {\\n        return bit1 == size_;\\n    }\\n\\n    void flip()\\n    {\\n        for(auto& el : data_) el = ~el;\\n        bit1 = size_ - bit1; \\n    }\\n\\n    int count()\\n    {\\n        return bit1;\\n    }\\n\\n    std::string toString()\\n    {\\n        std::string str;\\n        for(int i = 0; i < data_.size(); ++i)\\n        {\\n            int maxj = std::min(size_, i * 8 + 8);\\n            uint8_t mask = 0b10000000;\\n            for(int j = i * 8; j < maxj; ++j)\\n            {\\n                str += \\'0\\' + ((data_[i] & mask) != 0);\\n                mask >>= 1;\\n            }\\n        }\\n        return str;\\n    }\\n\\n    std::vector<uint8_t> data_;\\n    int size_ = 0;\\n    int bit1 = 0;\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313429,
                "title": "golang-407-ms-30-7-mb",
                "content": "```\\ntype Bitset struct {\\n\\tbits        []byte\\n\\tflippedBits []byte\\n\\tonesCount   int\\n}\\n\\nfunc Constructor(size int) Bitset {\\n\\treturn Bitset{\\n\\t\\tbits:        bytes.Repeat([]byte{\\'0\\'}, size),\\n\\t\\tflippedBits: bytes.Repeat([]byte{\\'1\\'}, size),\\n\\t}\\n}\\n\\nfunc (b *Bitset) Fix(idx int) {\\n\\tif b.bits[idx] == \\'0\\' {\\n\\t\\tb.bits[idx] = \\'1\\'\\n\\t\\tb.flippedBits[idx] = \\'0\\'\\n\\t\\tb.onesCount++\\n\\t}\\n}\\n\\nfunc (b *Bitset) Unfix(idx int) {\\n\\tif b.bits[idx] == \\'1\\' {\\n\\t\\tb.bits[idx] = \\'0\\'\\n\\t\\tb.flippedBits[idx] = \\'1\\'\\n\\t\\tb.onesCount--\\n\\t}\\n}\\n\\nfunc (b *Bitset) Flip() {\\n\\tb.onesCount = len(b.bits) - b.onesCount\\n\\tb.bits, b.flippedBits = b.flippedBits, b.bits\\n}\\n\\nfunc (b *Bitset) All() bool {\\n\\treturn b.onesCount == len(b.bits)\\n}\\n\\nfunc (b *Bitset) One() bool {\\n\\treturn b.onesCount != 0\\n}\\n\\nfunc (b *Bitset) Count() int {\\n\\treturn b.onesCount\\n}\\n\\nfunc (b *Bitset) ToString() string {\\n\\treturn string(b.bits)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Bitset struct {\\n\\tbits        []byte\\n\\tflippedBits []byte\\n\\tonesCount   int\\n}\\n\\nfunc Constructor(size int) Bitset {\\n\\treturn Bitset{\\n\\t\\tbits:        bytes.Repeat([]byte{\\'0\\'}, size),\\n\\t\\tflippedBits: bytes.Repeat([]byte{\\'1\\'}, size),\\n\\t}\\n}\\n\\nfunc (b *Bitset) Fix(idx int) {\\n\\tif b.bits[idx] == \\'0\\' {\\n\\t\\tb.bits[idx] = \\'1\\'\\n\\t\\tb.flippedBits[idx] = \\'0\\'\\n\\t\\tb.onesCount++\\n\\t}\\n}\\n\\nfunc (b *Bitset) Unfix(idx int) {\\n\\tif b.bits[idx] == \\'1\\' {\\n\\t\\tb.bits[idx] = \\'0\\'\\n\\t\\tb.flippedBits[idx] = \\'1\\'\\n\\t\\tb.onesCount--\\n\\t}\\n}\\n\\nfunc (b *Bitset) Flip() {\\n\\tb.onesCount = len(b.bits) - b.onesCount\\n\\tb.bits, b.flippedBits = b.flippedBits, b.bits\\n}\\n\\nfunc (b *Bitset) All() bool {\\n\\treturn b.onesCount == len(b.bits)\\n}\\n\\nfunc (b *Bitset) One() bool {\\n\\treturn b.onesCount != 0\\n}\\n\\nfunc (b *Bitset) Count() int {\\n\\treturn b.onesCount\\n}\\n\\nfunc (b *Bitset) ToString() string {\\n\\treturn string(b.bits)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3294519,
                "title": "all-in-o-1-except-tostring",
                "content": "# Code\\n```\\nclass Bitset {\\nprivate:\\n    vector<int> bit;\\n    int cnt;\\n    int fl;\\npublic:\\n    Bitset(int size) {\\n        bit.resize(size);\\n        cnt = 0;\\n        fl = false;\\n    }\\n    \\n    void fix(int idx) {\\n        if(!fl){\\n            if(bit[idx] == 0){\\n                bit[idx] = 1;\\n                cnt++;\\n            }\\n        }\\n        else{\\n            // because flip is true\\n            // that means someone who is 1 \\n            // is actually 0 in the sense.\\n            if(bit[idx] == 1){\\n                cnt++;\\n                bit[idx] = 0;\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(!fl){\\n            if(bit[idx] == 1){\\n                cnt--;\\n                bit[idx] = 0;\\n            }\\n        }\\n        else{\\n            if(bit[idx] == 0){\\n                cnt--;\\n                bit[idx] = 1;\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        // We are only doing an imaginary flip.\\n        // If you do a actual flip then it will be O(n)\\n        fl = !fl;\\n        cnt = bit.size() - cnt;\\n    }\\n    \\n    bool all() {\\n        return cnt == bit.size();\\n    }\\n    \\n    bool one() {\\n        return cnt >= 1;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        string ans = \"\";\\n        if(!fl){\\n            for(auto it : bit){\\n                if(it == 0) ans += \\'0\\';\\n                else ans += \\'1\\';\\n            }\\n        }\\n        else{\\n           for(auto it : bit){\\n                if(it == 0) ans += \\'1\\';\\n                else ans += \\'0\\';\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Design"
                ],
                "code": "```\\nclass Bitset {\\nprivate:\\n    vector<int> bit;\\n    int cnt;\\n    int fl;\\npublic:\\n    Bitset(int size) {\\n        bit.resize(size);\\n        cnt = 0;\\n        fl = false;\\n    }\\n    \\n    void fix(int idx) {\\n        if(!fl){\\n            if(bit[idx] == 0){\\n                bit[idx] = 1;\\n                cnt++;\\n            }\\n        }\\n        else{\\n            // because flip is true\\n            // that means someone who is 1 \\n            // is actually 0 in the sense.\\n            if(bit[idx] == 1){\\n                cnt++;\\n                bit[idx] = 0;\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        if(!fl){\\n            if(bit[idx] == 1){\\n                cnt--;\\n                bit[idx] = 0;\\n            }\\n        }\\n        else{\\n            if(bit[idx] == 0){\\n                cnt--;\\n                bit[idx] = 1;\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        // We are only doing an imaginary flip.\\n        // If you do a actual flip then it will be O(n)\\n        fl = !fl;\\n        cnt = bit.size() - cnt;\\n    }\\n    \\n    bool all() {\\n        return cnt == bit.size();\\n    }\\n    \\n    bool one() {\\n        return cnt >= 1;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        string ans = \"\";\\n        if(!fl){\\n            for(auto it : bit){\\n                if(it == 0) ans += \\'0\\';\\n                else ans += \\'1\\';\\n            }\\n        }\\n        else{\\n           for(auto it : bit){\\n                if(it == 0) ans += \\'1\\';\\n                else ans += \\'0\\';\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276706,
                "title": "dart-o-1-clean-code-explained",
                "content": "# Intuition\\nAs we found any functions could call 10^5 times except toString(). Should O(1) to all funtions except toString().\\n\\n\\n# Code\\n```\\nclass Bitset {\\n  late List<int> bits;\\n  bool isFlip = false;\\n  int onesCount = 0;\\n\\n  Bitset(int size) {\\n    bits = List.filled(size, 0);\\n  }\\n\\n  // Set 1 and increase count. If flipped, set 0\\n  void fix(int idx) {\\n    if (!isFlip) {\\n      if (bits[idx] == 0) {\\n        bits[idx] = 1;\\n        onesCount++;\\n      }\\n    } else {\\n      if (bits[idx] == 1) {\\n        bits[idx] = 0;\\n        onesCount++;\\n      }\\n    }\\n  }\\n\\n  // Set 0 and decrease count. If flipped, set 1\\n  void unfix(int idx) {\\n    if (!isFlip) {\\n      if (bits[idx] == 1) {\\n        bits[idx] = 0;\\n        onesCount--;\\n      }\\n    } else {\\n      if (bits[idx] == 0) {\\n        bits[idx] = 1;\\n        onesCount--;\\n      }\\n    }\\n  }\\n\\n  // Flip, update onesCount\\n  void flip() {\\n    isFlip = !isFlip;\\n    onesCount = bits.length - onesCount;\\n  }\\n\\n\\n  bool all() {\\n    return onesCount == bits.length;\\n  }\\n\\n  bool one() {\\n    return onesCount >= 1;\\n  }\\n\\n  int count() {\\n    return onesCount;\\n  }\\n\\n  String toString() {\\n    if (!isFlip) {\\n      return bits.join();\\n    } else {\\n      String s = \\'\\';\\n      for (var e in bits) {\\n        s += e == 0 ? \\'1\\' : \\'0\\';\\n      }\\n      return s;\\n    }\\n  }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * bool param4 = obj.all();\\n * bool param5 = obj.one();\\n * int param6 = obj.count();\\n * String param7 = obj.toString();\\n */\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Bitset {\\n  late List<int> bits;\\n  bool isFlip = false;\\n  int onesCount = 0;\\n\\n  Bitset(int size) {\\n    bits = List.filled(size, 0);\\n  }\\n\\n  // Set 1 and increase count. If flipped, set 0\\n  void fix(int idx) {\\n    if (!isFlip) {\\n      if (bits[idx] == 0) {\\n        bits[idx] = 1;\\n        onesCount++;\\n      }\\n    } else {\\n      if (bits[idx] == 1) {\\n        bits[idx] = 0;\\n        onesCount++;\\n      }\\n    }\\n  }\\n\\n  // Set 0 and decrease count. If flipped, set 1\\n  void unfix(int idx) {\\n    if (!isFlip) {\\n      if (bits[idx] == 1) {\\n        bits[idx] = 0;\\n        onesCount--;\\n      }\\n    } else {\\n      if (bits[idx] == 0) {\\n        bits[idx] = 1;\\n        onesCount--;\\n      }\\n    }\\n  }\\n\\n  // Flip, update onesCount\\n  void flip() {\\n    isFlip = !isFlip;\\n    onesCount = bits.length - onesCount;\\n  }\\n\\n\\n  bool all() {\\n    return onesCount == bits.length;\\n  }\\n\\n  bool one() {\\n    return onesCount >= 1;\\n  }\\n\\n  int count() {\\n    return onesCount;\\n  }\\n\\n  String toString() {\\n    if (!isFlip) {\\n      return bits.join();\\n    } else {\\n      String s = \\'\\';\\n      for (var e in bits) {\\n        s += e == 0 ? \\'1\\' : \\'0\\';\\n      }\\n      return s;\\n    }\\n  }\\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * bool param4 = obj.all();\\n * bool param5 = obj.one();\\n * int param6 = obj.count();\\n * String param7 = obj.toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239430,
                "title": "clean-c-o-1-using-two-strings-very-easy",
                "content": "# Intuition\\nMaintain two strings representing bitset at any state: one is the state itself, another is the flipped version of the state. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhenever there is a fix in current state, there is unfix in the flipped version of the state;\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Bitset {\\npublic:\\n    struct Bit {\\n        string bit; \\n        int ones;\\n\\n        Bit(string& bit, int ones) {\\n            this->bit = bit;\\n            this->ones = ones;\\n        }\\n        \\n        void fix(int idx) {\\n            if(bit[idx] == \\'0\\') {\\n                bit[idx] = \\'1\\';\\n                ones++;\\n            }\\n        }\\n\\n        void unfix(int idx) {\\n            if(bit[idx] == \\'1\\') {\\n                bit[idx] = \\'0\\';\\n                ones--;\\n            }\\n        }\\n    };\\n\\n\\n\\n    Bit* b;\\n    Bit* f;\\n    int size;\\n\\n    Bitset(int size) {\\n        string s(size, \\'0\\');\\n        string sf(size, \\'1\\');\\n\\n        this->size = size;\\n\\n        b = new Bit(s, 0);\\n        f = new Bit(sf, size);\\n    }\\n    \\n    void fix(int idx) {\\n        b->fix(idx);\\n        f->unfix(idx);\\n    }\\n    \\n    void unfix(int idx) {\\n        b->unfix(idx);\\n        f->fix(idx);\\n    }\\n    \\n    void flip() {\\n        swap(b, f);\\n    }\\n    \\n    bool all() {\\n        return b->ones == size;\\n    }\\n    \\n    bool one() {\\n        return b->ones > 0;\\n    }\\n    \\n    int count() {\\n        return b->ones;\\n    }\\n    \\n    string toString() {\\n        return b->bit;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    struct Bit {\\n        string bit; \\n        int ones;\\n\\n        Bit(string& bit, int ones) {\\n            this->bit = bit;\\n            this->ones = ones;\\n        }\\n        \\n        void fix(int idx) {\\n            if(bit[idx] == \\'0\\') {\\n                bit[idx] = \\'1\\';\\n                ones++;\\n            }\\n        }\\n\\n        void unfix(int idx) {\\n            if(bit[idx] == \\'1\\') {\\n                bit[idx] = \\'0\\';\\n                ones--;\\n            }\\n        }\\n    };\\n\\n\\n\\n    Bit* b;\\n    Bit* f;\\n    int size;\\n\\n    Bitset(int size) {\\n        string s(size, \\'0\\');\\n        string sf(size, \\'1\\');\\n\\n        this->size = size;\\n\\n        b = new Bit(s, 0);\\n        f = new Bit(sf, size);\\n    }\\n    \\n    void fix(int idx) {\\n        b->fix(idx);\\n        f->unfix(idx);\\n    }\\n    \\n    void unfix(int idx) {\\n        b->unfix(idx);\\n        f->fix(idx);\\n    }\\n    \\n    void flip() {\\n        swap(b, f);\\n    }\\n    \\n    bool all() {\\n        return b->ones == size;\\n    }\\n    \\n    bool one() {\\n        return b->ones > 0;\\n    }\\n    \\n    int count() {\\n        return b->ones;\\n    }\\n    \\n    string toString() {\\n        return b->bit;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182667,
                "title": "python3-simple-flipped-bool-o-1",
                "content": "```Python\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.flipped = False\\n        self.bits = [0]*size \\n        self.o_cnt, self.z_cnt = 0, size\\n        self.size = size\\n\\n    def fix(self, idx: int) -> None:\\n        if not self.bits[idx] and not self.flipped:\\n            self.bits[idx] = 1\\n        elif self.bits[idx] and self.flipped:\\n            self.bits[idx] = 0\\n        else: return \\n\\n        self.o_cnt += 1\\n        self.z_cnt -= 1\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.bits[idx] and not self.flipped:\\n            self.bits[idx] = 0\\n        elif not self.bits[idx] and self.flipped:\\n            self.bits[idx] = 1\\n        else: return \\n\\n        self.o_cnt -= 1\\n        self.z_cnt += 1\\n\\n    def flip(self) -> None:\\n        self.flipped = not self.flipped\\n        self.o_cnt, self.z_cnt = self.z_cnt, self.o_cnt\\n\\n    def all(self) -> bool:\\n        return self.o_cnt == self.size\\n\\n    def one(self) -> bool:\\n        return self.o_cnt > 0\\n\\n    def count(self) -> int:\\n        return self.o_cnt\\n\\n    def toString(self) -> str:\\n        return \\'\\'.join(str(int(c == 0) if self.flipped else c) for c in self.bits)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.flipped = False\\n        self.bits = [0]*size \\n        self.o_cnt, self.z_cnt = 0, size\\n        self.size = size\\n\\n    def fix(self, idx: int) -> None:\\n        if not self.bits[idx] and not self.flipped:\\n            self.bits[idx] = 1\\n        elif self.bits[idx] and self.flipped:\\n            self.bits[idx] = 0\\n        else: return \\n\\n        self.o_cnt += 1\\n        self.z_cnt -= 1\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.bits[idx] and not self.flipped:\\n            self.bits[idx] = 0\\n        elif not self.bits[idx] and self.flipped:\\n            self.bits[idx] = 1\\n        else: return \\n\\n        self.o_cnt -= 1\\n        self.z_cnt += 1\\n\\n    def flip(self) -> None:\\n        self.flipped = not self.flipped\\n        self.o_cnt, self.z_cnt = self.z_cnt, self.o_cnt\\n\\n    def all(self) -> bool:\\n        return self.o_cnt == self.size\\n\\n    def one(self) -> bool:\\n        return self.o_cnt > 0\\n\\n    def count(self) -> int:\\n        return self.o_cnt\\n\\n    def toString(self) -> str:\\n        return \\'\\'.join(str(int(c == 0) if self.flipped else c) for c in self.bits)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134232,
                "title": "ruby-o-1-solution",
                "content": "```\\nclass Bitset\\n\\n=begin\\n    :type size: Integer\\n=end\\n  def initialize(size)\\n    @count = 0\\n    @bits = \"0\" * size\\n    @flipped = \"1\" * size\\n  end\\n\\n=begin\\n    :type idx: Integer\\n    :rtype: Void\\n=end\\n  def fix(idx)\\n    return if @bits[idx] == \\'1\\'\\n    @bits[idx] = \\'1\\'\\n    @flipped[idx] = \\'0\\'\\n    @count += 1\\n  end\\n\\n=begin\\n    :type idx: Integer\\n    :rtype: Void\\n=end\\n  def unfix(idx)\\n    return if @bits[idx] == \\'0\\'\\n    @bits[idx] = \\'0\\'\\n    @flipped[idx] = \\'1\\'\\n    @count -= 1\\n  end\\n\\n=begin\\n    :rtype: Void\\n=end\\n  def flip()\\n    @count = @bits.size - @count\\n    @bits, @flipped = @flipped, @bits\\n  end\\n\\n=begin\\n    :rtype: Boolean\\n=end\\n  def all()\\n    @count == @bits.size\\n  end\\n\\n=begin\\n    :rtype: Boolean\\n=end\\n  def one()\\n    @count > 0\\n  end\\n\\n=begin\\n    :rtype: Integer\\n=end\\n  def count()\\n    @count\\n  end\\n\\n=begin\\n    :rtype: String\\n=end\\n  def to_string()\\n    @bits\\n  end\\nend\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset.new(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.to_string()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Bitset\\n\\n=begin\\n    :type size: Integer\\n=end\\n  def initialize(size)\\n    @count = 0\\n    @bits = \"0\" * size\\n    @flipped = \"1\" * size\\n  end\\n\\n=begin\\n    :type idx: Integer\\n    :rtype: Void\\n=end\\n  def fix(idx)\\n    return if @bits[idx] == \\'1\\'\\n    @bits[idx] = \\'1\\'\\n    @flipped[idx] = \\'0\\'\\n    @count += 1\\n  end\\n\\n=begin\\n    :type idx: Integer\\n    :rtype: Void\\n=end\\n  def unfix(idx)\\n    return if @bits[idx] == \\'0\\'\\n    @bits[idx] = \\'0\\'\\n    @flipped[idx] = \\'1\\'\\n    @count -= 1\\n  end\\n\\n=begin\\n    :rtype: Void\\n=end\\n  def flip()\\n    @count = @bits.size - @count\\n    @bits, @flipped = @flipped, @bits\\n  end\\n\\n=begin\\n    :rtype: Boolean\\n=end\\n  def all()\\n    @count == @bits.size\\n  end\\n\\n=begin\\n    :rtype: Boolean\\n=end\\n  def one()\\n    @count > 0\\n  end\\n\\n=begin\\n    :rtype: Integer\\n=end\\n  def count()\\n    @count\\n  end\\n\\n=begin\\n    :rtype: String\\n=end\\n  def to_string()\\n    @bits\\n  end\\nend\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset.new(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.to_string()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070767,
                "title": "python-parity-clean-code-o-1-except-tostring",
                "content": "# Code\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bits = [0]*size\\n        self.ones = 0\\n        self.parity = 0\\n        \\n    def fix(self, idx: int) -> None:\\n        if self.parity +(-1)**self.parity*self.bits[idx] == 0:\\n            self.bits[idx] = 1 - self.parity\\n            self.ones += 1  \\n\\n    def unfix(self, idx: int) -> None:\\n        if self.parity +(-1)**self.parity*self.bits[idx] == 1:\\n            self.bits[idx] = self.parity\\n            self.ones -= 1\\n\\n    def flip(self) -> None:\\n        self.parity = 1 - self.parity\\n        self.ones = len(self.bits) - self.ones\\n\\n    def all(self) -> bool:\\n        return self.ones == len(self.bits)\\n\\n    def one(self) -> bool:\\n        return self.ones > 0\\n        \\n\\n    def count(self) -> int:\\n        return self.ones\\n\\n    def toString(self) -> str:\\n        return \"\".join(map(lambda x: str(self.parity +(-1)**self.parity*x) ,self.bits))\\n        \\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.bits = [0]*size\\n        self.ones = 0\\n        self.parity = 0\\n        \\n    def fix(self, idx: int) -> None:\\n        if self.parity +(-1)**self.parity*self.bits[idx] == 0:\\n            self.bits[idx] = 1 - self.parity\\n            self.ones += 1  \\n\\n    def unfix(self, idx: int) -> None:\\n        if self.parity +(-1)**self.parity*self.bits[idx] == 1:\\n            self.bits[idx] = self.parity\\n            self.ones -= 1\\n\\n    def flip(self) -> None:\\n        self.parity = 1 - self.parity\\n        self.ones = len(self.bits) - self.ones\\n\\n    def all(self) -> bool:\\n        return self.ones == len(self.bits)\\n\\n    def one(self) -> bool:\\n        return self.ones > 0\\n        \\n\\n    def count(self) -> int:\\n        return self.ones\\n\\n    def toString(self) -> str:\\n        return \"\".join(map(lambda x: str(self.parity +(-1)**self.parity*x) ,self.bits))\\n        \\n\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011552,
                "title": "optimal-solution-using-hashset-java",
                "content": "\\n\\n# Code\\n```\\nclass Bitset {\\n    private int size;\\n    private Set<Integer> zero = new HashSet<>();\\n    private Set<Integer> one = new HashSet<>();\\n\\n    public Bitset(int size) {\\n        this.size = size;\\n        for(int i = 0; i < size ; i++){\\n            zero.add(i);\\n        }\\n    }\\n    \\n    public void fix(int idx) {\\n        one.add(idx);\\n        zero.remove(idx);\\n    }\\n    \\n    public void unfix(int idx) {\\n        zero.add(idx);\\n        one.remove(idx);\\n    }\\n    \\n    public void flip() {\\n        Set<Integer> temp = one;\\n        one = zero;\\n        zero = temp;\\n    }\\n    \\n    public boolean all() {\\n        return one.size() == size;\\n    }\\n    \\n    public boolean one() {\\n        return one.size()>=1;\\n    }\\n    \\n    public int count() {\\n        return one.size();\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0 ; i < size ; i++){\\n            if(one.contains(i)){\\n                sb.append(\"1\");\\n            }\\n            else if(zero.contains(i)){\\n                sb.append(\"0\");\\n            }\\n        }\\n        return sb.toString();\\n    }   \\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Bitset {\\n    private int size;\\n    private Set<Integer> zero = new HashSet<>();\\n    private Set<Integer> one = new HashSet<>();\\n\\n    public Bitset(int size) {\\n        this.size = size;\\n        for(int i = 0; i < size ; i++){\\n            zero.add(i);\\n        }\\n    }\\n    \\n    public void fix(int idx) {\\n        one.add(idx);\\n        zero.remove(idx);\\n    }\\n    \\n    public void unfix(int idx) {\\n        zero.add(idx);\\n        one.remove(idx);\\n    }\\n    \\n    public void flip() {\\n        Set<Integer> temp = one;\\n        one = zero;\\n        zero = temp;\\n    }\\n    \\n    public boolean all() {\\n        return one.size() == size;\\n    }\\n    \\n    public boolean one() {\\n        return one.size()>=1;\\n    }\\n    \\n    public int count() {\\n        return one.size();\\n    }\\n    \\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0 ; i < size ; i++){\\n            if(one.contains(i)){\\n                sb.append(\"1\");\\n            }\\n            else if(zero.contains(i)){\\n                sb.append(\"0\");\\n            }\\n        }\\n        return sb.toString();\\n    }   \\n}\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset obj = new Bitset(size);\\n * obj.fix(idx);\\n * obj.unfix(idx);\\n * obj.flip();\\n * boolean param_4 = obj.all();\\n * boolean param_5 = obj.one();\\n * int param_6 = obj.count();\\n * String param_7 = obj.toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008756,
                "title": "keep-track-of-flipped-status-without-changing-bits",
                "content": "# Complexity\\n\\nBest possible, but can probably be reduced by a constant factor with less internal function calls.\\n\\n# Code\\n```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.size = size\\n        self.ones = 0\\n        self.bits = [0] * size\\n        self.flipped = 0\\n\\n    def fix(self, idx: int) -> None:\\n        self.setbit(idx, 1)\\n\\n    def unfix(self, idx: int) -> None:\\n        self.setbit(idx, 0)\\n\\n    def getbit(self, idx: int) -> int:\\n        return (self.bits[idx] + self.flipped) % 2\\n\\n    def setbit(self, idx: int, bit: int) -> None:\\n        if self.getbit(idx) != bit:\\n            self.ones += -1 + 2 * bit\\n            self.bits[idx] = (bit + self.flipped) % 2\\n\\n    def flip(self) -> None:\\n        self.flipped = not self.flipped\\n        self.ones = self.size - self.ones\\n\\n    def all(self) -> bool:\\n        return self.ones == self.size\\n\\n    def one(self) -> bool:\\n        return self.ones > 0\\n\\n    def count(self) -> int:\\n        return self.ones\\n\\n    def toString(self) -> str:\\n        if self.flipped:\\n            return \\'\\'.join(map(lambda a: str(1 - a), self.bits))\\n        else:\\n            return \\'\\'.join(map(lambda a: str(a), self.bits))\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.size = size\\n        self.ones = 0\\n        self.bits = [0] * size\\n        self.flipped = 0\\n\\n    def fix(self, idx: int) -> None:\\n        self.setbit(idx, 1)\\n\\n    def unfix(self, idx: int) -> None:\\n        self.setbit(idx, 0)\\n\\n    def getbit(self, idx: int) -> int:\\n        return (self.bits[idx] + self.flipped) % 2\\n\\n    def setbit(self, idx: int, bit: int) -> None:\\n        if self.getbit(idx) != bit:\\n            self.ones += -1 + 2 * bit\\n            self.bits[idx] = (bit + self.flipped) % 2\\n\\n    def flip(self) -> None:\\n        self.flipped = not self.flipped\\n        self.ones = self.size - self.ones\\n\\n    def all(self) -> bool:\\n        return self.ones == self.size\\n\\n    def one(self) -> bool:\\n        return self.ones > 0\\n\\n    def count(self) -> int:\\n        return self.ones\\n\\n    def toString(self) -> str:\\n        if self.flipped:\\n            return \\'\\'.join(map(lambda a: str(1 - a), self.bits))\\n        else:\\n            return \\'\\'.join(map(lambda a: str(a), self.bits))\\n\\n# Your Bitset object will be instantiated and called as such:\\n# obj = Bitset(size)\\n# obj.fix(idx)\\n# obj.unfix(idx)\\n# obj.flip()\\n# param_4 = obj.all()\\n# param_5 = obj.one()\\n# param_6 = obj.count()\\n# param_7 = obj.toString()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990809,
                "title": "simple-approach-by-monitoring-parity-of-flips",
                "content": "```\\nclass Bitset {\\n    string s;\\n    int c1,c0,f;\\npublic:\\n    Bitset(int size) {\\n        while(s.length()<size)\\n            s.push_back(\\'0\\');\\n        c0=size;\\n        c1=0;\\n        f=0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(s.length()>idx){\\n            if(f&1){\\n                if(s[idx]==\\'1\\'){\\n                    s[idx]=\\'0\\';\\n                    c1++;\\n                    c0--;\\n                }\\n            }\\n            else{\\n                if(s[idx]==\\'0\\'){\\n                    s[idx]=\\'1\\';\\n                    c1++;\\n                    c0--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        \\n        if(s.length()>idx){\\n            if(f&1){\\n                if(s[idx]==\\'0\\'){\\n                    c1--;\\n                    c0++;\\n                    s[idx]=\\'1\\';\\n                }\\n            }\\n            else{\\n                if(s[idx]==\\'1\\'){\\n                    c1--;\\n                    c0++;\\n                    s[idx]=\\'0\\';\\n                }\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        f=f^1;\\n        swap(c1,c0);\\n    }\\n    \\n    bool all() {\\n        return c1==s.length();\\n    }\\n    \\n    bool one() {\\n        return c1>0;\\n    }\\n    \\n    int count() {\\n        return c1;\\n    }\\n    \\n    char swapChar(char c){\\n        if(c==\\'1\\')\\n            return \\'0\\';\\n        return \\'1\\';\\n    }\\n    \\n    string toString() {\\n        if(f&1){\\n            string t=s;\\n            for(int i=0;i<t.length();i++)\\n                t[i]=swapChar(t[i]);\\n            return t;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Bitset {\\n    string s;\\n    int c1,c0,f;\\npublic:\\n    Bitset(int size) {\\n        while(s.length()<size)\\n            s.push_back(\\'0\\');\\n        c0=size;\\n        c1=0;\\n        f=0;\\n    }\\n    \\n    void fix(int idx) {\\n        if(s.length()>idx){\\n            if(f&1){\\n                if(s[idx]==\\'1\\'){\\n                    s[idx]=\\'0\\';\\n                    c1++;\\n                    c0--;\\n                }\\n            }\\n            else{\\n                if(s[idx]==\\'0\\'){\\n                    s[idx]=\\'1\\';\\n                    c1++;\\n                    c0--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    void unfix(int idx) {\\n        \\n        if(s.length()>idx){\\n            if(f&1){\\n                if(s[idx]==\\'0\\'){\\n                    c1--;\\n                    c0++;\\n                    s[idx]=\\'1\\';\\n                }\\n            }\\n            else{\\n                if(s[idx]==\\'1\\'){\\n                    c1--;\\n                    c0++;\\n                    s[idx]=\\'0\\';\\n                }\\n            }\\n        }\\n    }\\n    \\n    void flip() {\\n        f=f^1;\\n        swap(c1,c0);\\n    }\\n    \\n    bool all() {\\n        return c1==s.length();\\n    }\\n    \\n    bool one() {\\n        return c1>0;\\n    }\\n    \\n    int count() {\\n        return c1;\\n    }\\n    \\n    char swapChar(char c){\\n        if(c==\\'1\\')\\n            return \\'0\\';\\n        return \\'1\\';\\n    }\\n    \\n    string toString() {\\n        if(f&1){\\n            string t=s;\\n            for(int i=0;i<t.length();i++)\\n                t[i]=swapChar(t[i]);\\n            return t;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983791,
                "title": "c",
                "content": "```\\n\\n\\n\\ntypedef struct {\\n    bool *data ;\\n    int size;\\n    int one;\\n    int flip;\\n} Bitset;\\n\\n\\nBitset* bitsetCreate(int size) {\\n    Bitset* ret = malloc(sizeof(Bitset));\\n    ret->data = calloc(size , sizeof(bool)) ;\\n    ret->size = size;\\n    ret->one = 0;\\n    ret->flip = 0;\\n    return ret;\\n}\\n\\nvoid bitsetFix(Bitset* obj, int idx) {\\n      if((obj->data[idx] + obj->flip) % 2 == 0){\\n        obj->data[idx] = !obj->data[idx] ;\\n        obj->one = obj->one  + 1 ;\\n      }\\n}\\n\\nvoid bitsetUnfix(Bitset* obj, int idx) {\\n      if((obj->data[idx] + obj->flip) % 2 == 1){\\n        obj->data[idx] = !obj->data[idx] ;\\n        obj->one = obj->one  - 1 ;\\n      }\\n}\\n\\nvoid bitsetFlip(Bitset* obj) { \\n    obj->flip = obj->flip + 1;\\n    obj->one = obj->size - obj->one;\\n}\\n\\nbool bitsetAll(Bitset* obj) {\\n    if(obj->size != obj->one)\\n        return false;\\n    return true;\\n}\\n\\nbool bitsetOne(Bitset* obj) {\\n    if(obj->one > 0)\\n        return true;\\n    return false;\\n}\\n\\nint bitsetCount(Bitset* obj) {\\n    return obj->one;\\n}\\n\\nchar * bitsetToString(Bitset* obj) {\\n    char* ans = malloc((obj->size + 1) * sizeof(char));\\n    ans[obj->size] = \\'\\\\0\\';\\n    for(int i = 0; i < obj->size; i++){\\n        if((obj->data[i] + obj->flip) % 2 == 0)\\n            ans[i] = \\'0\\';\\n        else\\n            ans[i] = \\'1\\';\\n    }\\n    return ans;\\n}\\n\\nvoid bitsetFree(Bitset* obj) {\\n    free(obj->data);\\n    free(obj);\\n}\\n\\n/**\\n * Your Bitset struct will be instantiated and called as such:\\n * Bitset* obj = bitsetCreate(size);\\n * bitsetFix(obj, idx);\\n \\n * bitsetUnfix(obj, idx);\\n \\n * bitsetFlip(obj);\\n \\n * bool param_4 = bitsetAll(obj);\\n \\n * bool param_5 = bitsetOne(obj);\\n \\n * int param_6 = bitsetCount(obj);\\n \\n * char * param_7 = bitsetToString(obj);\\n \\n * bitsetFree(obj);\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\ntypedef struct {\\n    bool *data ;\\n    int size;\\n    int one;\\n    int flip;\\n} Bitset;\\n\\n\\nBitset* bitsetCreate(int size) {\\n    Bitset* ret = malloc(sizeof(Bitset));\\n    ret->data = calloc(size , sizeof(bool)) ;\\n    ret->size = size;\\n    ret->one = 0;\\n    ret->flip = 0;\\n    return ret;\\n}\\n\\nvoid bitsetFix(Bitset* obj, int idx) {\\n      if((obj->data[idx] + obj->flip) % 2 == 0){\\n        obj->data[idx] = !obj->data[idx] ;\\n        obj->one = obj->one  + 1 ;\\n      }\\n}\\n\\nvoid bitsetUnfix(Bitset* obj, int idx) {\\n      if((obj->data[idx] + obj->flip) % 2 == 1){\\n        obj->data[idx] = !obj->data[idx] ;\\n        obj->one = obj->one  - 1 ;\\n      }\\n}\\n\\nvoid bitsetFlip(Bitset* obj) { \\n    obj->flip = obj->flip + 1;\\n    obj->one = obj->size - obj->one;\\n}\\n\\nbool bitsetAll(Bitset* obj) {\\n    if(obj->size != obj->one)\\n        return false;\\n    return true;\\n}\\n\\nbool bitsetOne(Bitset* obj) {\\n    if(obj->one > 0)\\n        return true;\\n    return false;\\n}\\n\\nint bitsetCount(Bitset* obj) {\\n    return obj->one;\\n}\\n\\nchar * bitsetToString(Bitset* obj) {\\n    char* ans = malloc((obj->size + 1) * sizeof(char));\\n    ans[obj->size] = \\'\\\\0\\';\\n    for(int i = 0; i < obj->size; i++){\\n        if((obj->data[i] + obj->flip) % 2 == 0)\\n            ans[i] = \\'0\\';\\n        else\\n            ans[i] = \\'1\\';\\n    }\\n    return ans;\\n}\\n\\nvoid bitsetFree(Bitset* obj) {\\n    free(obj->data);\\n    free(obj);\\n}\\n\\n/**\\n * Your Bitset struct will be instantiated and called as such:\\n * Bitset* obj = bitsetCreate(size);\\n * bitsetFix(obj, idx);\\n \\n * bitsetUnfix(obj, idx);\\n \\n * bitsetFlip(obj);\\n \\n * bool param_4 = bitsetAll(obj);\\n \\n * bool param_5 = bitsetOne(obj);\\n \\n * int param_6 = bitsetCount(obj);\\n \\n * char * param_7 = bitsetToString(obj);\\n \\n * bitsetFree(obj);\\n*/\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2933922,
                "title": "tracking-parity-of-the-number-of-flips",
                "content": "```\\nclass Bitset\\n{\\n    string s;\\n    int c{}, p{};\\npublic:\\n    Bitset(int n)    { s=move(string(n,\\'0\\'));      }\\n    void fix(int i)  { c+=s[i]==\\'0\\'+p; s[i]=\\'1\\'-p; }\\n    void unfix(int i){ c-=s[i]==\\'1\\'-p; s[i]=\\'0\\'+p; }\\n    void flip()      { p^=1; c=size(s)-c;          }\\n    bool all()       { return count()==size(s);    }\\n    bool one()       { return count();             } \\n\\tint count()      { return c;                   }\\n    string toString() \\n\\t{\\n\\t    if(p) transform(begin(s), end(s), begin(s), [](auto i){ return \\'a\\'-i; }), p=0;\\n\\t    return s;\\n\\t}\\n};\\n```\\n**Notation:**\\n`p` - **p**arity of number of flips;\\n`c` - **c**ount of ones.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Bitset\\n{\\n    string s;\\n    int c{}, p{};\\npublic:\\n    Bitset(int n)    { s=move(string(n,\\'0\\'));      }\\n    void fix(int i)  { c+=s[i]==\\'0\\'+p; s[i]=\\'1\\'-p; }\\n    void unfix(int i){ c-=s[i]==\\'1\\'-p; s[i]=\\'0\\'+p; }\\n    void flip()      { p^=1; c=size(s)-c;          }\\n    bool all()       { return count()==size(s);    }\\n    bool one()       { return count();             } \\n\\tint count()      { return c;                   }\\n    string toString() \\n\\t{\\n\\t    if(p) transform(begin(s), end(s), begin(s), [](auto i){ return \\'a\\'-i; }), p=0;\\n\\t    return s;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925576,
                "title": "no-hashset-simple-very-basic-solution-no-fancy-computations",
                "content": "# Intuition\\nKeep a string and flipped string update according to the operation and swap when flip is called. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)create a string with all zero and all ones\\n2)Increment the count when fix is called and fix operation in curr string and unfix for flipped string and do opposite for unifx operation\\n3)For flip=>swap as they are complement of each other\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n# Code\\n```\\nclass Bitset {\\npublic:\\n    string s,ns;\\n    int cnt,cnt2;\\n    int n;\\n    Bitset(int size) {\\n        for(int i=0;i<size;i++){\\n            s+=\"0\";\\n            ns+=\"1\";\\n        }\\n        n=size;\\n        cnt=0,cnt2=size;\\n    }\\n    \\n    void fix(int idx) {\\n        if(s[idx]!=\\'1\\')\\n        cnt++;\\n        if(ns[idx]==\\'1\\'){\\n            cnt2--;\\n        }\\n        ns[idx]=\\'0\\';\\n        s[idx]=\\'1\\';\\n    }\\n    \\n    void unfix(int idx) {\\n        if(s[idx]==\\'1\\')\\n        cnt--;\\n        if(ns[idx]!=\\'1\\'){\\n            cnt2++;\\n        }\\n        ns[idx]=\\'1\\';\\n        s[idx]=\\'0\\';\\n    }\\n    \\n    void flip() {\\n        swap(ns,s);\\n        swap(cnt,cnt2);\\n\\n    }\\n    \\n    bool all() {\\n        return cnt==n;\\n    }\\n    \\n    bool one() {\\n        return cnt>0;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Bitset {\\npublic:\\n    string s,ns;\\n    int cnt,cnt2;\\n    int n;\\n    Bitset(int size) {\\n        for(int i=0;i<size;i++){\\n            s+=\"0\";\\n            ns+=\"1\";\\n        }\\n        n=size;\\n        cnt=0,cnt2=size;\\n    }\\n    \\n    void fix(int idx) {\\n        if(s[idx]!=\\'1\\')\\n        cnt++;\\n        if(ns[idx]==\\'1\\'){\\n            cnt2--;\\n        }\\n        ns[idx]=\\'0\\';\\n        s[idx]=\\'1\\';\\n    }\\n    \\n    void unfix(int idx) {\\n        if(s[idx]==\\'1\\')\\n        cnt--;\\n        if(ns[idx]!=\\'1\\'){\\n            cnt2++;\\n        }\\n        ns[idx]=\\'1\\';\\n        s[idx]=\\'0\\';\\n    }\\n    \\n    void flip() {\\n        swap(ns,s);\\n        swap(cnt,cnt2);\\n\\n    }\\n    \\n    bool all() {\\n        return cnt==n;\\n    }\\n    \\n    bool one() {\\n        return cnt>0;\\n    }\\n    \\n    int count() {\\n        return cnt;\\n    }\\n    \\n    string toString() {\\n        return s;\\n    }\\n};\\n\\n/**\\n * Your Bitset object will be instantiated and called as such:\\n * Bitset* obj = new Bitset(size);\\n * obj->fix(idx);\\n * obj->unfix(idx);\\n * obj->flip();\\n * bool param_4 = obj->all();\\n * bool param_5 = obj->one();\\n * int param_6 = obj->count();\\n * string param_7 = obj->toString();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899072,
                "title": "easy-solution-on-python3",
                "content": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.arr = [\"0\"] * size\\n        self.countOne = 0\\n        self.ifFlip = False\\n\\n    def fix(self, idx: int) -> None:\\n        if self.ifFlip == True:\\n            if self.arr[idx] == \"1\": \\n                self.countOne += 1\\n            self.arr[idx] = \"0\"\\n        else:\\n            if self.arr[idx] == \"0\": \\n                self.countOne += 1\\n            self.arr[idx] = \"1\"\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.ifFlip == True:\\n            if self.arr[idx] == \"0\" : \\n                self.countOne -= 1\\n            self.arr[idx] = \"1\"\\n        else:\\n            if self.arr[idx] == \"1\" :\\n                self.countOne -= 1\\n            self.arr[idx] = \"0\"\\n\\n    def flip(self) -> None:\\n        self.ifFlip = not self.ifFlip\\n        self.countOne = len(self.arr) - self.countOne\\n\\n    def all(self) -> bool:\\n        return self.countOne == len(self.arr)\\n\\n    def one(self) -> bool:\\n        return self.countOne > 0  \\n\\n    def count(self) -> int:\\n        return self.countOne\\n\\n    def toString(self) -> str:\\n        return \"\".join([\"0\" if k == \"1\" else \"1\" for k in self.arr]) if self.ifFlip == True else \"\".join([k1 for k1 in self.arr])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Bitset:\\n\\n    def __init__(self, size: int):\\n        self.arr = [\"0\"] * size\\n        self.countOne = 0\\n        self.ifFlip = False\\n\\n    def fix(self, idx: int) -> None:\\n        if self.ifFlip == True:\\n            if self.arr[idx] == \"1\": \\n                self.countOne += 1\\n            self.arr[idx] = \"0\"\\n        else:\\n            if self.arr[idx] == \"0\": \\n                self.countOne += 1\\n            self.arr[idx] = \"1\"\\n\\n    def unfix(self, idx: int) -> None:\\n        if self.ifFlip == True:\\n            if self.arr[idx] == \"0\" : \\n                self.countOne -= 1\\n            self.arr[idx] = \"1\"\\n        else:\\n            if self.arr[idx] == \"1\" :\\n                self.countOne -= 1\\n            self.arr[idx] = \"0\"\\n\\n    def flip(self) -> None:\\n        self.ifFlip = not self.ifFlip\\n        self.countOne = len(self.arr) - self.countOne\\n\\n    def all(self) -> bool:\\n        return self.countOne == len(self.arr)\\n\\n    def one(self) -> bool:\\n        return self.countOne > 0  \\n\\n    def count(self) -> int:\\n        return self.countOne\\n\\n    def toString(self) -> str:\\n        return \"\".join([\"0\" if k == \"1\" else \"1\" for k in self.arr]) if self.ifFlip == True else \"\".join([k1 for k1 in self.arr])\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1965739,
                "content": [
                    {
                        "username": "misba_shoeib",
                        "content": "TLE :)"
                    }
                ]
            }
        ]
    }
]