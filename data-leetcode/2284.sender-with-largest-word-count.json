[
    {
        "title": "Sender With Largest Word Count",
        "question_content": "You have a chat log of n messages. You are given two string arrays messages and senders where messages[i] is a message sent by senders[i].\nA message is list of words that are separated by a single space with no leading or trailing spaces. The word count of a sender is the total number of words sent by the sender. Note that a sender may send more than one message.\nReturn the sender with the largest word count. If there is more than one sender with the largest word count, return the one with the lexicographically largest name.\nNote:\n\n\tUppercase letters come before lowercase letters in lexicographical order.\n\t\"Alice\" and \"alice\" are distinct.\n\n&nbsp;\nExample 1:\n\nInput: messages = [\"Hello userTwooo\",\"Hi userThree\",\"Wonderful day Alice\",\"Nice day userThree\"], senders = [\"Alice\",\"userTwo\",\"userThree\",\"Alice\"]\nOutput: \"Alice\"\nExplanation: Alice sends a total of 2 + 3 = 5 words.\nuserTwo sends a total of 2 words.\nuserThree sends a total of 3 words.\nSince Alice has the largest word count, we return \"Alice\".\n\nExample 2:\n\nInput: messages = [\"How is leetcode for everyone\",\"Leetcode is useful for practice\"], senders = [\"Bob\",\"Charlie\"]\nOutput: \"Charlie\"\nExplanation: Bob sends a total of 5 words.\nCharlie sends a total of 5 words.\nSince there is a tie for the largest word count, we return the sender with the lexicographically larger name, Charlie.\n&nbsp;\nConstraints:\n\n\tn == messages.length == senders.length\n\t1 <= n <= 104\n\t1 <= messages[i].length <= 100\n\t1 <= senders[i].length <= 10\n\tmessages[i] consists of uppercase and lowercase English letters and ' '.\n\tAll the words in messages[i] are separated by a single space.\n\tmessages[i] does not have leading or trailing spaces.\n\tsenders[i] consists of uppercase and lowercase English letters only.",
        "solutions": [
            {
                "id": 2083788,
                "title": "count-spaces",
                "content": "The number of words in a message is the number of spaces, plus one.\\n\\nWe count words for each sender using a hash map, and track max count with the sender\\'s name.\\n\\n**C++**\\n```cpp\\nstring largestWordCount(vector<string>& messages, vector<string>& senders) {\\n    unordered_map<string, int> cnt;\\n    string res;\\n    int max_cnt = 0;\\n    for (int i = 0; i < messages.size(); ++i) {\\n        int words = count(begin(messages[i]), end(messages[i]), \\' \\') + 1;\\n        int total = cnt[senders[i]] += words;\\n        if (total > max_cnt || (total == max_cnt && senders[i] > res)) {\\n            max_cnt = total;\\n            res = senders[i];\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring largestWordCount(vector<string>& messages, vector<string>& senders) {\\n    unordered_map<string, int> cnt;\\n    string res;\\n    int max_cnt = 0;\\n    for (int i = 0; i < messages.size(); ++i) {\\n        int words = count(begin(messages[i]), end(messages[i]), \\' \\') + 1;\\n        int total = cnt[senders[i]] += words;\\n        if (total > max_cnt || (total == max_cnt && senders[i] > res)) {\\n            max_cnt = total;\\n            res = senders[i];\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2083856,
                "title": "two-solution-stringstream-and-count-space",
                "content": "***Store the count of words sent by each sender and find the sender with the largest word count in the hashmap.***\\n\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        \\n        int n(size(messages));\\n        map<string, int> m;\\n        for (auto i=0; i<n; i++) {\\n            \\n            stringstream ss(messages[i]);\\n            string word;\\n            int count(0);\\n            while (ss >> word)   count++;\\n            m[senders[i]] += count;\\n        }\\n        \\n        int count(0);\\n        string res;\\n        for (auto& p : m) {\\n            if (p.second >= count) {\\n                count = p.second;\\n                if (!res.empty() or res < p.first)  res = p.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Count space to find number of words**\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        \\n        auto doit = [&](string& message) {\\n            int word(1);\\n            for (auto& ch : message)    if (ch == \\' \\')  word++;\\n            return word;\\n        };\\n        \\n        int n(size(messages));\\n        map<string, int> m;\\n        for (auto i=0; i<n; i++)\\n            m[senders[i]] += doit(messages[i]);\\n        \\n        string res;\\n        int count(0);\\n        for (auto& p : m) {\\n            if (p.second >= count) {\\n                count = p.second;\\n                if (!res.empty() or res < p.first)  res = p.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        \\n        int n(size(messages));\\n        map<string, int> m;\\n        for (auto i=0; i<n; i++) {\\n            \\n            stringstream ss(messages[i]);\\n            string word;\\n            int count(0);\\n            while (ss >> word)   count++;\\n            m[senders[i]] += count;\\n        }\\n        \\n        int count(0);\\n        string res;\\n        for (auto& p : m) {\\n            if (p.second >= count) {\\n                count = p.second;\\n                if (!res.empty() or res < p.first)  res = p.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        \\n        auto doit = [&](string& message) {\\n            int word(1);\\n            for (auto& ch : message)    if (ch == \\' \\')  word++;\\n            return word;\\n        };\\n        \\n        int n(size(messages));\\n        map<string, int> m;\\n        for (auto i=0; i<n; i++)\\n            m[senders[i]] += doit(messages[i]);\\n        \\n        string res;\\n        int count(0);\\n        for (auto& p : m) {\\n            if (p.second >= count) {\\n                count = p.second;\\n                if (!res.empty() or res < p.first)  res = p.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083940,
                "title": "java-python-3-two-codes-w-analysis",
                "content": "**Method 1: Sort the senders with the largest word count**\\n```java\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> cnt = new HashMap<>();\\n        int largest = 0;\\n        for (int i = 0; i < senders.length; ++i) {\\n            largest = Math.max(largest, cnt.merge(senders[i], messages[i].split(\" \").length, Integer::sum));\\n        }\\n        TreeSet<String> senderSet = new TreeSet<>();\\n        for (var entry : cnt.entrySet()) {\\n            if (entry.getValue() == largest) {\\n                senderSet.add(entry.getKey());\\n            }\\n        }\\n        return senderSet.pollLast();\\n    }\\n```\\n```python\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        c = Counter()\\n        mx = 0\\n        for s, m in zip(senders, messages):\\n            c[s] += len(m.split())\\n            mx = max(mx, c[s])\\n        for s in reversed(sorted(c)):\\n            if c[s] == mx:\\n                return s\\n```\\n**Analysis:**\\nTime: `O(nlogn)`, space: `O(n)`, where `n = senders.length`.\\n\\n----\\n\\n**Method 2: No sort** - inspired by **@giulian**\\n\\n```java\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> cnt = new HashMap<>();\\n        int largest = 0;\\n        for (int i = 0; i < senders.length; ++i) {\\n            largest = Math.max(largest, cnt.merge(senders[i], messages[i].split(\" \").length, Integer::sum));\\n        }\\n        String sender = \"\";\\n        for (var entry : cnt.entrySet()) {\\n            if (entry.getValue() == largest && sender.compareTo(entry.getKey()) < 0) {\\n                sender = entry.getKey();\\n            }\\n        }\\n        return sender;\\n    }\\n```\\n```python\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        c = Counter()\\n        mx = 0\\n        for s, m in zip(senders, messages):\\n            c[s] += len(m.split())\\n            mx = max(mx, c[s])\\n        sender = \\'\\'    \\n        for k, v in c.items():\\n            if v == mx and sender < k:\\n                sender = k\\n        return sender\\n```\\n**Analysis:**\\nTime & space: `O(n)`, where `n = senders.length`.",
                "solutionTags": [],
                "code": "```java\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> cnt = new HashMap<>();\\n        int largest = 0;\\n        for (int i = 0; i < senders.length; ++i) {\\n            largest = Math.max(largest, cnt.merge(senders[i], messages[i].split(\" \").length, Integer::sum));\\n        }\\n        TreeSet<String> senderSet = new TreeSet<>();\\n        for (var entry : cnt.entrySet()) {\\n            if (entry.getValue() == largest) {\\n                senderSet.add(entry.getKey());\\n            }\\n        }\\n        return senderSet.pollLast();\\n    }\\n```\n```python\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        c = Counter()\\n        mx = 0\\n        for s, m in zip(senders, messages):\\n            c[s] += len(m.split())\\n            mx = max(mx, c[s])\\n        for s in reversed(sorted(c)):\\n            if c[s] == mx:\\n                return s\\n```\n```java\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> cnt = new HashMap<>();\\n        int largest = 0;\\n        for (int i = 0; i < senders.length; ++i) {\\n            largest = Math.max(largest, cnt.merge(senders[i], messages[i].split(\" \").length, Integer::sum));\\n        }\\n        String sender = \"\";\\n        for (var entry : cnt.entrySet()) {\\n            if (entry.getValue() == largest && sender.compareTo(entry.getKey()) < 0) {\\n                sender = entry.getKey();\\n            }\\n        }\\n        return sender;\\n    }\\n```\n```python\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        c = Counter()\\n        mx = 0\\n        for s, m in zip(senders, messages):\\n            c[s] += len(m.split())\\n            mx = max(mx, c[s])\\n        sender = \\'\\'    \\n        for k, v in c.items():\\n            if v == mx and sender < k:\\n                sender = k\\n        return sender\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2084181,
                "title": "c-map-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders){\\n        map<string, int> mp;\\n        for(int i = 0; i<messages.size(); ++i){\\n            int words = count(begin(messages[i]), end(messages[i]), \\' \\')+1;\\n            mp[senders[i]]+=words;\\n        }\\n        string ans = \"\";\\n        int count = 0;\\n        for(auto it = mp.begin(); it!=mp.end(); ++it){\\n            if(it->second >= count){\\n                count = it->second;\\n                ans = it->first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders){\\n        map<string, int> mp;\\n        for(int i = 0; i<messages.size(); ++i){\\n            int words = count(begin(messages[i]), end(messages[i]), \\' \\')+1;\\n            mp[senders[i]]+=words;\\n        }\\n        string ans = \"\";\\n        int count = 0;\\n        for(auto it = mp.begin(); it!=mp.end(); ++it){\\n            if(it->second >= count){\\n                count = it->second;\\n                ans = it->first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083925,
                "title": "java-code-with-comments-hashmap-priorityqueue",
                "content": "```\\nclass Solution {\\n    \\n    class Pair {\\n        String name;\\n        int cnt;\\n        \\n        public Pair(String n, int c) {\\n            this.name = n;\\n            this.cnt = c;\\n        }\\n    }\\n    \\n    class Compare implements Comparator<Pair> {\\n        public int compare(Pair a, Pair b) {\\n            if (a.cnt == b.cnt) {\\n                return b.name.compareTo(a.name);\\n            }\\n            \\n            return b.cnt - a.cnt;\\n        }\\n    }\\n    \\n    public String largestWordCount(String[] messages, String[] senders) {\\n        PriorityQueue <Pair> pq = new PriorityQueue<>(new Compare());\\n        /* Pair ==> key   -> name\\n                ==> Value -> cnt\\n           \\n           new Compare() ==> it sort the queue on the cnt in descending order.\\n                         ==> if cnt are same than sort on the name\\n        */\\n        \\n        HashMap <String, Integer> hash = new HashMap<>();\\n        \\n        for (int i = 0; i < messages.length; i++) {\\n            String []str = messages[i].split(\" \");  // total words in a message\\n            int len = str.length + hash.getOrDefault(senders[i], 0);\\n            hash.put(senders[i], len);\\n        }\\n        \\n        for (Map.Entry <String, Integer> map: hash.entrySet()) {\\n            pq.add(new Pair(map.getKey(), map.getValue()));\\n        }\\n        \\n        return pq.poll().name;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Pair {\\n        String name;\\n        int cnt;\\n        \\n        public Pair(String n, int c) {\\n            this.name = n;\\n            this.cnt = c;\\n        }\\n    }\\n    \\n    class Compare implements Comparator<Pair> {\\n        public int compare(Pair a, Pair b) {\\n            if (a.cnt == b.cnt) {\\n                return b.name.compareTo(a.name);\\n            }\\n            \\n            return b.cnt - a.cnt;\\n        }\\n    }\\n    \\n    public String largestWordCount(String[] messages, String[] senders) {\\n        PriorityQueue <Pair> pq = new PriorityQueue<>(new Compare());\\n        /* Pair ==> key   -> name\\n                ==> Value -> cnt\\n           \\n           new Compare() ==> it sort the queue on the cnt in descending order.\\n                         ==> if cnt are same than sort on the name\\n        */\\n        \\n        HashMap <String, Integer> hash = new HashMap<>();\\n        \\n        for (int i = 0; i < messages.length; i++) {\\n            String []str = messages[i].split(\" \");  // total words in a message\\n            int len = str.length + hash.getOrDefault(senders[i], 0);\\n            hash.put(senders[i], len);\\n        }\\n        \\n        for (Map.Entry <String, Integer> map: hash.entrySet()) {\\n            pq.add(new Pair(map.getKey(), map.getValue()));\\n        }\\n        \\n        return pq.poll().name;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084222,
                "title": "easy-python-solution-with-dictionary",
                "content": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d={}\\n        l=[]\\n        for i in range(len(messages)):\\n            if senders[i] not in d:\\n                d[senders[i]]=len(messages[i].split())\\n            else:\\n                d[senders[i]]+=len(messages[i].split())\\n        x=max(d.values())\\n        for k,v in d.items():\\n            if v==x :\\n                l.append(k)\\n        if len(l)==1:\\n            return l[0]\\n        else:\\n            l=sorted(l)[::-1]      #Lexigograhical sorting of list\\n            return l[0]\\n```\\n\\n***Please Upvote if you like it.***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d={}\\n        l=[]\\n        for i in range(len(messages)):\\n            if senders[i] not in d:\\n                d[senders[i]]=len(messages[i].split())\\n            else:\\n                d[senders[i]]+=len(messages[i].split())\\n        x=max(d.values())\\n        for k,v in d.items():\\n            if v==x :\\n                l.append(k)\\n        if len(l)==1:\\n            return l[0]\\n        else:\\n            l=sorted(l)[::-1]      #Lexigograhical sorting of list\\n            return l[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084182,
                "title": "simple-space-count-solution-no-string-stream",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string,int> m;\\n        int n=senders.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int cnt=0;\\n            for(int j=0;j<messages[i].size();j++)\\n            {\\n                if(messages[i][j]==\\' \\')cnt++; //counting spaces\\n            }\\n            m[senders[i]]+=(cnt+1);//words count = space count+1 bcz of no trailing and leading spaces\\n        }\\n        vector<pair<int,string>> v;\\n        for(auto& it:m)\\n        {\\n            v.push_back({it.second,it.first}); //sorting according to words sent\\n        }\\n        sort(v.begin(),v.end());\\n        return v[v.size()-1].second; //even if there is a tie lexicographically larger will be at last\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string,int> m;\\n        int n=senders.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int cnt=0;\\n            for(int j=0;j<messages[i].size();j++)\\n            {\\n                if(messages[i][j]==\\' \\')cnt++; //counting spaces\\n            }\\n            m[senders[i]]+=(cnt+1);//words count = space count+1 bcz of no trailing and leading spaces\\n        }\\n        vector<pair<int,string>> v;\\n        for(auto& it:m)\\n        {\\n            v.push_back({it.second,it.first}); //sorting according to words sent\\n        }\\n        sort(v.begin(),v.end());\\n        return v[v.size()-1].second; //even if there is a tie lexicographically larger will be at last\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083945,
                "title": "easy-approach-in-java-using-hashmap-only",
                "content": "```\\n\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String,Integer> hm=new HashMap<>();\\n\\t\\t\\n        int max=0;\\n        String name=\"\";\\n        for(int i=0;i<messages.length;i++){\\n            String[] words=messages[i].split(\" \");\\n            \\n            int freq=hm.getOrDefault(senders[i],0)+words.length;\\n            hm.put(senders[i],freq);\\n            \\n            if(hm.get(senders[i])>max){\\n                max=hm.get(senders[i]);\\n                name=senders[i];\\n            }\\n            else if(hm.get(senders[i])==max && name.compareTo(senders[i])<0){\\n                name=senders[i];\\n            } \\n        }\\n        \\n        return name;\\n    }\\n}\\n```\\n\\n\\n\\n**Time Complexity - O(messages.length*messages[i].length)**\\n**Space Compexity - O(senders.length);**\\n\\n**Connect with me ->** https://www.linkedin.com/in/himanshusharma2024/\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String,Integer> hm=new HashMap<>();\\n\\t\\t\\n        int max=0;\\n        String name=\"\";\\n        for(int i=0;i<messages.length;i++){\\n            String[] words=messages[i].split(\" \");\\n            \\n            int freq=hm.getOrDefault(senders[i],0)+words.length;\\n            hm.put(senders[i],freq);\\n            \\n            if(hm.get(senders[i])>max){\\n                max=hm.get(senders[i]);\\n                name=senders[i];\\n            }\\n            else if(hm.get(senders[i])==max && name.compareTo(senders[i])<0){\\n                name=senders[i];\\n            } \\n        }\\n        \\n        return name;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084830,
                "title": "c-map-count-space-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(string &s){\\n        int n=s.length();\\n        int cnt=1;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\' \\'){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n          int n=messages.size();\\n          int m=senders.size();\\n          map<string,int> mp;\\n          string res=\"\";\\n          for(int i=0;i<n;i++){\\n              mp[senders[i]]=mp[senders[i]]+solve(messages[i]);\\n          }\\n         int maxx=INT_MIN;\\n         for(auto it=mp.begin();it!=mp.end();it++){\\n             if(it->second>=maxx){\\n                 maxx=it->second;\\n                 res=max(res,it->first);\\n             }\\n         }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string &s){\\n        int n=s.length();\\n        int cnt=1;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\' \\'){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n          int n=messages.size();\\n          int m=senders.size();\\n          map<string,int> mp;\\n          string res=\"\";\\n          for(int i=0;i<n;i++){\\n              mp[senders[i]]=mp[senders[i]]+solve(messages[i]);\\n          }\\n         int maxx=INT_MIN;\\n         for(auto it=mp.begin();it!=mp.end();it++){\\n             if(it->second>=maxx){\\n                 maxx=it->second;\\n                 res=max(res,it->first);\\n             }\\n         }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083931,
                "title": "map-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int find(string str)\\n{\\n         int count = 0;\\n         int temp = 0;\\n        int i=0;\\n       \\n   while (i!=str.length()){\\n      if (str[i] == \\' \\' || str[i] == \\'\\\\n\\' || str[i] == \\'\\\\t\\'){\\n         temp = 0;\\n      }\\n      else if(temp == 0){\\n         temp = 1;\\n         count++;\\n      }\\n      i++;\\n   }\\n   return count;\\n}\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        \\n        //Map will sort senders lexicographically  \\n        map<string,string> umap;\\n        string ans=\"\";\\n        int count=0;\\n        for(int i=0;i<messages.size();i++)\\n        {\\n            if(umap[senders[i]]!=\"\")\\n                umap[senders[i]]+=\" \";\\n            umap[senders[i]]+=messages[i];\\n        }\\n        for(auto i=umap.begin();i!=umap.end();i++)\\n        {\\n            //Count Number of words for each Senders\\n            int c=find(i->second);\\n            //If count of words is greater than the last word count\\n            //Note: Map has already sorted Senders lexicographically\\n            if(c>=count)\\n            {\\n                count=c;\\n                ans=i->first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int find(string str)\\n{\\n         int count = 0;\\n         int temp = 0;\\n        int i=0;\\n       \\n   while (i!=str.length()){\\n      if (str[i] == \\' \\' || str[i] == \\'\\\\n\\' || str[i] == \\'\\\\t\\'){\\n         temp = 0;\\n      }\\n      else if(temp == 0){\\n         temp = 1;\\n         count++;\\n      }\\n      i++;\\n   }\\n   return count;\\n}\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        \\n        //Map will sort senders lexicographically  \\n        map<string,string> umap;\\n        string ans=\"\";\\n        int count=0;\\n        for(int i=0;i<messages.size();i++)\\n        {\\n            if(umap[senders[i]]!=\"\")\\n                umap[senders[i]]+=\" \";\\n            umap[senders[i]]+=messages[i];\\n        }\\n        for(auto i=umap.begin();i!=umap.end();i++)\\n        {\\n            //Count Number of words for each Senders\\n            int c=find(i->second);\\n            //If count of words is greater than the last word count\\n            //Note: Map has already sorted Senders lexicographically\\n            if(c>=count)\\n            {\\n                count=c;\\n                ans=i->first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108392,
                "title": "python-fast-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        \\n        # total will contain total sum of sender\\'s words                   \\n        total = {}\\n        max_name = \\'\\'\\n        max_value = 0\\n        \\n        for i in range(len(senders)):\\n            # get num of words in message             \\n            words_num = len(messages[i].split(\\' \\'))\\n            \\n            # if total contain sender\\'s name\\n            # we add words_num to its value    \\n            # else add new key              \\n            if total.get(senders[i], None):\\n                total[senders[i]] += words_num\\n            else:\\n                total[senders[i]] = words_num\\n                \\n            # if max_num of words is equal to sender\\'s total words num\\n            # and max_name is less then sender\\'s name we change max_name        \\n            if total[senders[i]]==max_value and max_name<senders[i]:\\n                max_name = senders[i]\\n            \\n            # if sender\\'s total words num is greater then current max\\n            # we save its name and num of words          \\n            elif total[senders[i]]>max_value:\\n                max_value = total[senders[i]]\\n                max_name = senders[i]\\n        return max_name\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        \\n        # total will contain total sum of sender\\'s words                   \\n        total = {}\\n        max_name = \\'\\'\\n        max_value = 0\\n        \\n        for i in range(len(senders)):\\n            # get num of words in message             \\n            words_num = len(messages[i].split(\\' \\'))\\n            \\n            # if total contain sender\\'s name\\n            # we add words_num to its value    \\n            # else add new key              \\n            if total.get(senders[i], None):\\n                total[senders[i]] += words_num\\n            else:\\n                total[senders[i]] = words_num\\n                \\n            # if max_num of words is equal to sender\\'s total words num\\n            # and max_name is less then sender\\'s name we change max_name        \\n            if total[senders[i]]==max_value and max_name<senders[i]:\\n                max_name = senders[i]\\n            \\n            # if sender\\'s total words num is greater then current max\\n            # we save its name and num of words          \\n            elif total[senders[i]]>max_value:\\n                max_value = total[senders[i]]\\n                max_name = senders[i]\\n        return max_name\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084379,
                "title": "c-count-space-hashmap-2284-sender-with-largest-word-count",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring largestWordCount(vector<string>& messages, vector<string>& senders) {\\n\\t\\t\\tmap<string,int>m;\\n\\t\\t\\tfor(int i=0;i<senders.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint cnt=1;\\n\\t\\t\\t\\tfor(int j=0;j<messages[i].size();j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(messages[i][j]==\\' \\') cnt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tm[senders[i]]+=cnt;\\n\\t\\t\\t}\\n\\t\\t\\tint maxi=INT_MIN;\\n\\t\\t\\tstring ans;\\n\\t\\t\\tfor(auto &i:m)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i.second>maxi)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans=i.first;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(i.second==maxi)\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t\\tif(i.first>ans) ans=i.first;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmaxi=max(maxi,i.second);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring largestWordCount(vector<string>& messages, vector<string>& senders) {\\n\\t\\t\\tmap<string,int>m;\\n\\t\\t\\tfor(int i=0;i<senders.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint cnt=1;\\n\\t\\t\\t\\tfor(int j=0;j<messages[i].size();j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(messages[i][j]==\\' \\') cnt++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2083916,
                "title": "count-spaces-maps-c-easy-to-understand",
                "content": "We simply count the words for each sender and store the sender and their count of words in a map.\\n\\nFinally we iterate over the map and find sender with max word count.\\n\\n```\\nclass Solution {\\n\\t// Count number of words in a message by counting spaces\\n    int f(string s) {\\n        int words = 0;\\n        for(auto &el: s) {\\n            if(el == \\' \\') words++;\\n        }\\n        return words + 1;\\n    }\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        int n = m.size();\\n        map<string, int> mp;\\n        for(int i=0; i<n; i++) {\\n            int words = f(m[i]);\\n            mp[s[i]] += words;\\n        }\\n        \\n        int maxLen = INT_MIN;\\n        string ans;\\n        for(auto &el: mp) {\\n            if(el.second > maxLen) {\\n                maxLen = el.second;\\n                ans = el.first;\\n            }\\n            if(el.second == maxLen && el.first > ans) {\\n                ans = el.first;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n\\t// Count number of words in a message by counting spaces\\n    int f(string s) {\\n        int words = 0;\\n        for(auto &el: s) {\\n            if(el == \\' \\') words++;\\n        }\\n        return words + 1;\\n    }\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        int n = m.size();\\n        map<string, int> mp;\\n        for(int i=0; i<n; i++) {\\n            int words = f(m[i]);\\n            mp[s[i]] += words;\\n        }\\n        \\n        int maxLen = INT_MIN;\\n        string ans;\\n        for(auto &el: mp) {\\n            if(el.second > maxLen) {\\n                maxLen = el.second;\\n                ans = el.first;\\n            }\\n            if(el.second == maxLen && el.first > ans) {\\n                ans = el.first;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083763,
                "title": "stringstream-implementation-based-question-sorting",
                "content": "```\\nstatic bool cmp(pair<int,string> &a,pair<int,string> &b){\\n        \\n        if(a.first != b.first) return a.first > b.first;\\n        \\n        return a.second > b.second;\\n        \\n    }\\n    \\n    string largestWordCount(vector<string>& M, vector<string>& S) {\\n        unordered_map<string,int> um;\\n        \\n        int n = M.size();\\n        \\n        for(int i=0;i<n;i++){\\n            stringstream ss(M[i]);\\n            string word;\\n            int cnt = 0;\\n            while(ss >> word){\\n                cnt++;\\n            }\\n            um[S[i]]+=cnt;\\n        }\\n        \\n        vector<pair<int,string>> vec;\\n        \\n        for(auto x : um){\\n            vec.push_back({x.second,x.first});\\n        }\\n        \\n        sort(vec.begin(),vec.end(),cmp);\\n        \\n        return vec[0].second;\\n        \\n    }",
                "solutionTags": [
                    "String",
                    "Sorting"
                ],
                "code": "```\\nstatic bool cmp(pair<int,string> &a,pair<int,string> &b){\\n        \\n        if(a.first != b.first) return a.first > b.first;\\n        \\n        return a.second > b.second;\\n        \\n    }\\n    \\n    string largestWordCount(vector<string>& M, vector<string>& S) {\\n        unordered_map<string,int> um;\\n        \\n        int n = M.size();\\n        \\n        for(int i=0;i<n;i++){\\n            stringstream ss(M[i]);\\n            string word;\\n            int cnt = 0;\\n            while(ss >> word){\\n                cnt++;\\n            }\\n            um[S[i]]+=cnt;\\n        }\\n        \\n        vector<pair<int,string>> vec;\\n        \\n        for(auto x : um){\\n            vec.push_back({x.second,x.first});\\n        }\\n        \\n        sort(vec.begin(),vec.end(),cmp);\\n        \\n        return vec[0].second;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3761341,
                "title": "python-3-4-lines-using-dictionary-beats-97",
                "content": "```python3 []\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d = defaultdict(int)\\n        for m, n in zip(messages, senders):\\n            d[n] += len(m.split())\\n        return max(d, key = lambda k: (d[k], k))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d = defaultdict(int)\\n        for m, n in zip(messages, senders):\\n            d[n] += len(m.split())\\n        return max(d, key = lambda k: (d[k], k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827234,
                "title": "simple-solution-using-dictionary-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all , for this problem we are going to use a map which in python can be implemented by using dictionary.\\nWe are going to find the words count of every sender\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn python we create an empty dictionary and traversing the senders list , if a particular element of senders in not in dictionary then we create key value pair with key as senders name and value as the respective message(count of words).If the element of senders is already present then we just add the respective count of words to the existing one and keep track of the maximum value\\n\\nBy the above steps we get maximum and for every element in map we are going to check if the value is maximum and keep track of maximum and return it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFor traversing into the senders list and adding values  into the dictionary and keeping track of the maximum value takes O(n) and if we have multiple keys with same maximum traversing the map with the maximum and keeping track of answer takes O(n). Hence the time complexity is basically O(n+n) which equals O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using hashmap , which can be of size \\'n\\' in the worst case so..\\nthe space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        map = {}\\n        m=0\\n        ans=\"\"\\n        for i in range(len(senders)):\\n            if senders[i] not in map:\\n                map[senders[i]] =  messages[i].count(\\' \\')+1\\n            else:\\n                map[senders[i]]+= messages[i].count(\\' \\')+1\\n            m=max(m,map[senders[i]])\\n        for i,k in map.items():\\n            if k==m:\\n                ans=max(ans,i)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        map = {}\\n        m=0\\n        ans=\"\"\\n        for i in range(len(senders)):\\n            if senders[i] not in map:\\n                map[senders[i]] =  messages[i].count(\\' \\')+1\\n            else:\\n                map[senders[i]]+= messages[i].count(\\' \\')+1\\n            m=max(m,map[senders[i]])\\n        for i,k in map.items():\\n            if k==m:\\n                ans=max(ans,i)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344071,
                "title": "c-solution-easy-explained-using-maps",
                "content": "1. we create a new function to count total number of words in a string;\\n2.  we create a a map PerUserWordCount and a vector maxCounter;\\n3.  we put all the count of words per user in the map, while doing so , we also save the maximum frequency.\\n4.  we also check that if a multiple senders have maximum words, if so then we sort them and return the last of them as required.\\n\\n``` \\nint numberOfWords(string s){\\n    string word = \"\";\\n    int count  = 0;\\n    for(int i = 0; i < s.size();i++){\\n        if(s[i] == \\' \\' && word != \"\"){\\n            word = \"\";\\n            count++;\\n        }\\n        word = word + s[i];\\n    }\\n    count++;\\n    return count;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string, int> PerUserWordCount;\\n        vector<string>maxCounter;\\n        int maxCount = 0;\\n        for(int i = 0; i < messages.size(); i++){\\n            string message = messages[i];\\n            PerUserWordCount[senders[i]] = PerUserWordCount[senders[i]] + numberOfWords(message);\\n            if(PerUserWordCount[senders[i]] > maxCount){\\n                maxCount = PerUserWordCount[senders[i]];\\n            }\\n        }\\n\\n        for(auto i : PerUserWordCount){\\n            if(i.second == maxCount){\\n                maxCounter.push_back(i.first);\\n            }\\n        }\\n\\n        if(maxCounter.size() == 1){\\n            return maxCounter[0];\\n        }else{\\n            sort(maxCounter.begin(), maxCounter.end());\\n            return maxCounter[maxCounter.size()-1];\\n        }\\n\\n        return \"\";\\n    }\\n};  ```",
                "solutionTags": [
                    "C",
                    "String",
                    "Iterator"
                ],
                "code": "``` \\nint numberOfWords(string s){\\n    string word = \"\";\\n    int count  = 0;\\n    for(int i = 0; i < s.size();i++){\\n        if(s[i] == \\' \\' && word != \"\"){\\n            word = \"\";\\n            count++;\\n        }\\n        word = word + s[i];\\n    }\\n    count++;\\n    return count;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string, int> PerUserWordCount;\\n        vector<string>maxCounter;\\n        int maxCount = 0;\\n        for(int i = 0; i < messages.size(); i++){\\n            string message = messages[i];\\n            PerUserWordCount[senders[i]] = PerUserWordCount[senders[i]] + numberOfWords(message);\\n            if(PerUserWordCount[senders[i]] > maxCount){\\n                maxCount = PerUserWordCount[senders[i]];\\n            }\\n        }\\n\\n        for(auto i : PerUserWordCount){\\n            if(i.second == maxCount){\\n                maxCounter.push_back(i.first);\\n            }\\n        }\\n\\n        if(maxCounter.size() == 1){\\n            return maxCounter[0];\\n        }else{\\n            sort(maxCounter.begin(), maxCounter.end());\\n            return maxCounter[maxCounter.size()-1];\\n        }\\n\\n        return \"\";\\n    }\\n};  ```",
                "codeTag": "Java"
            },
            {
                "id": 2102840,
                "title": "javascript-count-space-hashmap",
                "content": "```\\n/**\\n * @param {string[]} messages\\n * @param {string[]} senders\\n * @return {string}\\n */\\nvar largestWordCount = function(messages, senders) {\\n    let wordCount = {}\\n    let result = \\'\\'\\n    let maxCount = -Infinity\\n    for (let i = 0; i < messages.length;i++) {\\n        let count=messages[i].split(\\' \\').length\\n        wordCount[senders[i]] = wordCount[senders[i]] == undefined ? count : wordCount[senders[i]] + count;\\n        if (wordCount[senders[i]]  > maxCount || (wordCount[senders[i]]  == maxCount && senders[i] > result)) {\\n            maxCount = wordCount[senders[i]];\\n            result = senders[i];\\n        }\\n    }\\n    return result;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} messages\\n * @param {string[]} senders\\n * @return {string}\\n */\\nvar largestWordCount = function(messages, senders) {\\n    let wordCount = {}\\n    let result = \\'\\'\\n    let maxCount = -Infinity\\n    for (let i = 0; i < messages.length;i++) {\\n        let count=messages[i].split(\\' \\').length\\n        wordCount[senders[i]] = wordCount[senders[i]] == undefined ? count : wordCount[senders[i]] + count;\\n        if (wordCount[senders[i]]  > maxCount || (wordCount[senders[i]]  == maxCount && senders[i] > result)) {\\n            maxCount = wordCount[senders[i]];\\n            result = senders[i];\\n        }\\n    }\\n    return result;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084026,
                "title": "easy-to-understand-beginner-friendly-my-notes",
                "content": "Keep a hashmap that stores keys as elements from sender and the value as a list with the indexes.\\n\\nIf Senders are [Alice,Zhund,Zhund,Alice]\\n\\nYour dictionary becomes: {\\'Alice\\': [0,3], \\'Zhund\\':[1,2]}\\n\\nNow you need to iterate within this dictionary.\\nAnd use those indexes.\\n\\nSo, for every element, we can iterate in the list of indexes it has.\\n\\n*len(messages[each].split(\\' \\'))* will give you the word count for the index stored in the messages.\\nand then you can compare the total count with the maximum count everytime.\\n\\n\\n```\\nans = \\'\\'\\nd = {}\\nfor i in range(0,len(senders)):\\n\\td.setdefault(senders[i], []).append(i)\\n\\nfor element in d.keys():\\n\\tcount = 0\\n\\tfor each in d[element]:\\n\\t\\tcount+=len(messages[each].split(\\' \\'))\\n\\t\\t#equal case\\n\\t\\tif count == mc and element>ans:\\n\\t\\t\\tans = element\\n\\t\\t#greater case\\n\\t\\tif count>mc:\\n\\t\\t\\tmc = count\\n\\t\\t\\tans = element\\n\\nreturn ans\\n```\\n\\n\\nNote:\\n\\n[If these notes are helpful, do upvote! I also post the explanation on my channel. The link\\ncan be found in my profile as website. If you feel my explanation needs to be improved either while writing here/explaning, feel free to comment.\\n]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nans = \\'\\'\\nd = {}\\nfor i in range(0,len(senders)):\\n\\td.setdefault(senders[i], []).append(i)\\n\\nfor element in d.keys():\\n\\tcount = 0\\n\\tfor each in d[element]:\\n\\t\\tcount+=len(messages[each].split(\\' \\'))\\n\\t\\t#equal case\\n\\t\\tif count == mc and element>ans:\\n\\t\\t\\tans = element\\n\\t\\t#greater case\\n\\t\\tif count>mc:\\n\\t\\t\\tmc = count\\n\\t\\t\\tans = element\\n\\nreturn ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2083837,
                "title": "map",
                "content": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String,Integer> map=new HashMap<>();\\n        int max=0;\\n        for(int i=0;i<messages.length;i++){\\n            String s=messages[i];\\n            String str[]=s.split(\" \");\\n            map.put(senders[i],map.getOrDefault(senders[i],0)+str.length);\\n            max=Math.max(max,map.get(senders[i]));\\n        }\\n        \\n        String res=\"\";\\n        for(String e: map.keySet()){\\n            if(map.get(e)==max){\\n                if(res.compareTo(e)<0){\\n                    res=e;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String,Integer> map=new HashMap<>();\\n        int max=0;\\n        for(int i=0;i<messages.length;i++){\\n            String s=messages[i];\\n            String str[]=s.split(\" \");\\n            map.put(senders[i],map.getOrDefault(senders[i],0)+str.length);\\n            max=Math.max(max,map.get(senders[i]));\\n        }\\n        \\n        String res=\"\";\\n        for(String e: map.keySet()){\\n            if(map.get(e)==max){\\n                if(res.compareTo(e)<0){\\n                    res=e;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305575,
                "title": "java-clean-solution-using-hashmap-explained",
                "content": "# Solution explained using comments \\uD83D\\uDE07\\n---\\n### Code:\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        // In a hashmap, record whhich person has sent how many words\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < messages.length; i++) {\\n            // doing this would get us the number of words in that particular message\\n            int words = messages[i].split(\" \").length;\\n            String name = senders[i];\\n            // update in the map\\n            map.put(name, words + map.getOrDefault(name, 0));\\n        }\\n\\n        // a string \\'ans\\' to record our final sender\\'s name\\n        String ans = \"\";\\n        // variable to keep track of the maximum number of words spoken by a sender\\n        int max = 0;    \\n        // go through the senders\\n        for (String name : map.keySet()) {\\n            // number of words current sender has sent\\n            int words = map.get(name);  \\n            // if number of words > max spoken words\\n            if (words > max) {\\n                max = words;    // update max\\n                ans = name;     // make this sender our candidate\\n            } \\n            // if we have a tie in the max number of words spoken\\n            else if (words == max) {\\n                // keep the name which is lexicographically greater\\n                int x = ans.compareTo(name);\\n                ans = (x > 0)? ans : name;\\n            }\\n        }\\n\\n        // return the final sender\\'s name\\n        return ans;\\n    }\\n}\\n```\\n---\\n#### Clean solution:\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < messages.length; i++) {\\n            int words = messages[i].split(\" \").length;\\n            String name = senders[i];\\n            map.put(name, words + map.getOrDefault(name, 0));\\n        }\\n\\n        String ans = \"\";\\n        int max = 0;    \\n        for (String name : map.keySet()) {\\n            int words = map.get(name);  \\n            if (words > max) {\\n                max = words;    \\n                ans = name;     \\n            } else if (words == max) {\\n                int x = ans.compareTo(name);\\n                ans = (x > 0)? ans : name;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n---\\n### Complexity analysis:\\n##### Time complexity: $$O(n) + O(n) => O(n)$$\\n> A $$O(n)$$ to populate our map. Another $$O(n)$$ to go thorugh the map to go through the map.\\n\\n##### Space complexity: $$O(n)$$\\n> We use a hashmap to store the data of our senders.\\n---\\n                          Do comment if you have any doubt \\uD83D\\uDC4D\\uD83C\\uDFFB\\n                                 Upvote if you like \\uD83D\\uDC96",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        // In a hashmap, record whhich person has sent how many words\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < messages.length; i++) {\\n            // doing this would get us the number of words in that particular message\\n            int words = messages[i].split(\" \").length;\\n            String name = senders[i];\\n            // update in the map\\n            map.put(name, words + map.getOrDefault(name, 0));\\n        }\\n\\n        // a string \\'ans\\' to record our final sender\\'s name\\n        String ans = \"\";\\n        // variable to keep track of the maximum number of words spoken by a sender\\n        int max = 0;    \\n        // go through the senders\\n        for (String name : map.keySet()) {\\n            // number of words current sender has sent\\n            int words = map.get(name);  \\n            // if number of words > max spoken words\\n            if (words > max) {\\n                max = words;    // update max\\n                ans = name;     // make this sender our candidate\\n            } \\n            // if we have a tie in the max number of words spoken\\n            else if (words == max) {\\n                // keep the name which is lexicographically greater\\n                int x = ans.compareTo(name);\\n                ans = (x > 0)? ans : name;\\n            }\\n        }\\n\\n        // return the final sender\\'s name\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < messages.length; i++) {\\n            int words = messages[i].split(\" \").length;\\n            String name = senders[i];\\n            map.put(name, words + map.getOrDefault(name, 0));\\n        }\\n\\n        String ans = \"\";\\n        int max = 0;    \\n        for (String name : map.keySet()) {\\n            int words = map.get(name);  \\n            if (words > max) {\\n                max = words;    \\n                ans = name;     \\n            } else if (words == max) {\\n                int x = ans.compareTo(name);\\n                ans = (x > 0)? ans : name;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208543,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string a)\\n    {\\n        int c=0;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(a[i]==\\' \\')c++;\\n        }\\n        return c+1;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        vector<pair<string,int>>v;\\n        for(int i=0;i<messages.size();i++)\\n        {\\n            v.push_back({senders[i],solve(messages[i])});\\n        }\\n        unordered_map<string,int>m;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            m[v[i].first]+=v[i].second;\\n        }\\n        string ans=\"\";\\n        int temp=0;\\n        for(auto it:m)\\n        {\\n            if(temp<it.second)\\n            {\\n                ans=it.first;\\n                temp=it.second;\\n            }\\n            else if(temp==it.second)\\n            {\\n                if(ans<it.first)\\n                {\\n                    ans=it.first;\\n                }\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/ab9bddaa-881c-4ca3-a31d-bc14ccfd6b19_1676872335.3289537.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string a)\\n    {\\n        int c=0;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(a[i]==\\' \\')c++;\\n        }\\n        return c+1;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        vector<pair<string,int>>v;\\n        for(int i=0;i<messages.size();i++)\\n        {\\n            v.push_back({senders[i],solve(messages[i])});\\n        }\\n        unordered_map<string,int>m;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            m[v[i].first]+=v[i].second;\\n        }\\n        string ans=\"\";\\n        int temp=0;\\n        for(auto it:m)\\n        {\\n            if(temp<it.second)\\n            {\\n                ans=it.first;\\n                temp=it.second;\\n            }\\n            else if(temp==it.second)\\n            {\\n                if(ans<it.first)\\n                {\\n                    ans=it.first;\\n                }\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103370,
                "title": "java-hashmap-o-n-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculate the word count for every message. Maintain a hash map of senders -> word count. Iterate over the hash map and figure out the sender with the largest word count.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public String largestWordCount(String[] messages, String[] senders) {\\n    HashMap<String, Integer> map = new HashMap<>();\\n\\n    for (int i=0; i < messages.length; i++) {\\n      int cnt = 0;\\n      for (int j=0; j < messages[i].length(); j++)\\n        if (messages[i].charAt(j) == \\' \\')\\n          cnt++;\\n\\n      map.put(senders[i], map.getOrDefault(senders[i], 0) + cnt + 1);\\n    }\\n    String ans = \"\";\\n    int maxWordCount = Integer.MIN_VALUE;\\n    \\n    for (Map.Entry<String, Integer> entry : map.entrySet()) {\\n      String sender = map.getKey();\\n      int wordCount = map.getValue();\\n\\n      if (wordCount >= maxWordCount) {\\n        ans = \\n          wordCount == maxWordCount\\n            ? ans.compareTo(sender) > 0 ? ans : sender\\n            : sender;\\n        maxWordCount = wordCount;\\n      }\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n  public String largestWordCount(String[] messages, String[] senders) {\\n    HashMap<String, Integer> map = new HashMap<>();\\n\\n    for (int i=0; i < messages.length; i++) {\\n      int cnt = 0;\\n      for (int j=0; j < messages[i].length(); j++)\\n        if (messages[i].charAt(j) == \\' \\')\\n          cnt++;\\n\\n      map.put(senders[i], map.getOrDefault(senders[i], 0) + cnt + 1);\\n    }\\n    String ans = \"\";\\n    int maxWordCount = Integer.MIN_VALUE;\\n    \\n    for (Map.Entry<String, Integer> entry : map.entrySet()) {\\n      String sender = map.getKey();\\n      int wordCount = map.getValue();\\n\\n      if (wordCount >= maxWordCount) {\\n        ans = \\n          wordCount == maxWordCount\\n            ? ans.compareTo(sender) > 0 ? ans : sender\\n            : sender;\\n        maxWordCount = wordCount;\\n      }\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043814,
                "title": "c-faster-than-100-hashmap",
                "content": "\\n\\n\\n```\\n// This function takes in two vectors of strings, \"messages\" and \"senders\", and returns the sender \\n// with the largest number of words in their messages. \\nstring largestWordCount(vector<string>& messages, vector<string>& senders) {\\n    // Create an unordered map to store the number of words in each sender\\'s messages\\n    unordered_map<string,int> mp;\\n    // Iterate through the \"messages\" vector\\n    for(int i=0;i<size(messages);i++)\\n    {\\n        int c=0;\\n        // Count the number of spaces in the current message\\n        for(int j=0;j<size(messages[i]);j++)\\n        {\\n            if(messages[i][j]==\\' \\')\\n                c++;\\n        }\\n        // Add the number of words (count of spaces + 1) to the corresponding sender\\'s count in the map\\n        mp[senders[i]]+=c+1;\\n    }\\n    // Create a priority queue of pairs where the first element is the number of words and \\n    // the second element is the sender\\'s name\\n    priority_queue<pair<int,string>> p;\\n    // Push all the pairs from the map into the priority queue\\n    for(auto it:mp)\\n    {\\n        p.push({it.second,it.first});\\n    }\\n    // Return the sender with the highest number of words (the top element of the priority queue)\\n    return p.top().second;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// This function takes in two vectors of strings, \"messages\" and \"senders\", and returns the sender \\n// with the largest number of words in their messages. \\nstring largestWordCount(vector<string>& messages, vector<string>& senders) {\\n    // Create an unordered map to store the number of words in each sender\\'s messages\\n    unordered_map<string,int> mp;\\n    // Iterate through the \"messages\" vector\\n    for(int i=0;i<size(messages);i++)\\n    {\\n        int c=0;\\n        // Count the number of spaces in the current message\\n        for(int j=0;j<size(messages[i]);j++)\\n        {\\n            if(messages[i][j]==\\' \\')\\n                c++;\\n        }\\n        // Add the number of words (count of spaces + 1) to the corresponding sender\\'s count in the map\\n        mp[senders[i]]+=c+1;\\n    }\\n    // Create a priority queue of pairs where the first element is the number of words and \\n    // the second element is the sender\\'s name\\n    priority_queue<pair<int,string>> p;\\n    // Push all the pairs from the map into the priority queue\\n    for(auto it:mp)\\n    {\\n        p.push({it.second,it.first});\\n    }\\n    // Return the sender with the highest number of words (the top element of the priority queue)\\n    return p.top().second;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2671755,
                "title": "python-faster",
                "content": "```\\n def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n \\n        hashMap = {}\\n        for message, sender in zip(messages, senders):\\n            if sender in hashMap:\\n                hashMap[sender] += len(message.split())\\n            else:\\n                hashMap[sender] = len(message.split())\\n                \\n                \\n        return sorted(hashMap.items(), key=lambda item: (item[1], item[0]), reverse=True)[0][0]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n \\n        hashMap = {}\\n        for message, sender in zip(messages, senders):\\n            if sender in hashMap:\\n                hashMap[sender] += len(message.split())\\n            else:\\n                hashMap[sender] = len(message.split())\\n                \\n                \\n        return sorted(hashMap.items(), key=lambda item: (item[1], item[0]), reverse=True)[0][0]\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2541683,
                "title": "c-solution-using-hashmap-simple-easy",
                "content": "Just create a map of (string, int) pair and store the count of no of words for each word in the map. \\nAfter this iterate and find the strings for maximum count, if 2 such string exists, check which one is lexicographically greater and print the required output.\\n\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string, int> mp;\\n        for(int i = 0;i < messages.size(); i++)\\n        {\\n            int count = 0;\\n            string tmp = messages[i];\\n            for(char ch : tmp) \\n                if(ch == \\' \\') \\n                    count++;\\n                mp[senders[i]] += count + 1;\\n        }\\n        string ans = \"\";\\n        int mx = INT_MIN;\\n        for(auto i : mp)\\n        {\\n            if(i.second >= mx)\\n            {\\n                mx = i.second;\\n                if(i.first > ans) \\n                    ans = i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string, int> mp;\\n        for(int i = 0;i < messages.size(); i++)\\n        {\\n            int count = 0;\\n            string tmp = messages[i];\\n            for(char ch : tmp) \\n                if(ch == \\' \\') \\n                    count++;\\n                mp[senders[i]] += count + 1;\\n        }\\n        string ans = \"\";\\n        int mx = INT_MIN;\\n        for(auto i : mp)\\n        {\\n            if(i.second >= mx)\\n            {\\n                mx = i.second;\\n                if(i.first > ans) \\n                    ans = i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523902,
                "title": "python-easy-sorting-map",
                "content": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d = defaultdict(int)\\n        mx = 0\\n        for i,snd in enumerate(senders):\\n            d[snd] += len(messages[i].split())\\n            mx = max(mx, d[snd])\\n        \\n        for snd in sorted(d.keys())[::-1]:\\n            if d[snd] == mx:\\n                return snd\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d = defaultdict(int)\\n        mx = 0\\n        for i,snd in enumerate(senders):\\n            d[snd] += len(messages[i].split())\\n            mx = max(mx, d[snd])\\n        \\n        for snd in sorted(d.keys())[::-1]:\\n            if d[snd] == mx:\\n                return snd\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2405967,
                "title": "python-99-90-memory-efficient-simple-fast-detailed-explanation",
                "content": "* Take a `defaultdict` of integers to store the count of words.\\n* Iterate over the `senders` array and count number of words during each iteration. If key already exisits in the hash table, add the current value in already exisiting value. For example, if `Alice` has send a message `Hi`. Add it to the dictionary with value as 1. If again, `Alice` sends out a message, for instance `Hello` then update the value this time. Now Alice will have `value = 2`.\\n* Now after iterating through the array, you will have a hashtable ready with the senders and their number of words. \\n* At this point, we only need to calculate the sender with max words. \\n* Initialize a `max_` variable with value **0**, and `winner` with value equal to first index `senders[0]`\\n* We need to take care of the case when their is a tie between two senders. \\n* Python `max` function gives you the value in lexicographical order in case of strings. \\n* return the `winner` in the end. \\n\\n```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d = defaultdict(int)\\n        for i in range(len(senders)):\\n            d[senders[i]] = d.get(senders[i], 0) + len(messages[i].split())\\n\\n        max_ = 0\\n        winner = senders[0]\\n        for key, value in d.items():\\n            if value == max_:\\n                winner = max(winner, key)\\n            if value > max_:\\n                winner = key\\n                max_ = value\\n\\n        return winner\\n```\\n\\nDo comment if you have any doubt, feel free to reach out. \\nIf you like the solution, please do upvote. Thanks.",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d = defaultdict(int)\\n        for i in range(len(senders)):\\n            d[senders[i]] = d.get(senders[i], 0) + len(messages[i].split())\\n\\n        max_ = 0\\n        winner = senders[0]\\n        for key, value in d.items():\\n            if value == max_:\\n                winner = max(winner, key)\\n            if value > max_:\\n                winner = key\\n                max_ = value\\n\\n        return winner\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208244,
                "title": "java-hashmap-one-pass-count-space-1",
                "content": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) \\n    {\\n        int n=messages.length;\\n        \\n        String ans=\"\";\\n        int max=0;\\n        Map<String,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            for(int j=0;j<messages[i].length();j++)\\n            {\\n                if(messages[i].charAt(j)==\\' \\')\\n                c++;\\n            }\\n            \\n            c++;\\n            map.put(senders[i],map.getOrDefault(senders[i],0)+c);\\n            \\n            int x=map.get(senders[i]);\\n            \\n            if(x<max)\\n            continue;\\n            \\n            if(x==max)\\n            ans=senders[i].compareTo(ans)>0?senders[i]:ans;\\n            \\n            else\\n            {\\n                max=x;\\n                ans=senders[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) \\n    {\\n        int n=messages.length;\\n        \\n        String ans=\"\";\\n        int max=0;\\n        Map<String,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            for(int j=0;j<messages[i].length();j++)\\n            {\\n                if(messages[i].charAt(j)==\\' \\')\\n                c++;\\n            }\\n            \\n            c++;\\n            map.put(senders[i],map.getOrDefault(senders[i],0)+c);\\n            \\n            int x=map.get(senders[i]);\\n            \\n            if(x<max)\\n            continue;\\n            \\n            if(x==max)\\n            ans=senders[i].compareTo(ans)>0?senders[i]:ans;\\n            \\n            else\\n            {\\n                max=x;\\n                ans=senders[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087154,
                "title": "c-and-linq",
                "content": "We can just *query* the both arrays with a help of *Linq*. Instead of counting words (which can be time consuming for `Split`) we can count *spaces*:\\n\\n```\\n   wordCount = spaceCount + 1\\n```\\n\\n**Code:**\\n\\n```\\npublic class Solution {\\n    public string LargestWordCount(string[] messages, string[] senders) {\\n        return senders\\n            .Zip(messages, (s, m) => (sender : s, words : m.Count(c => c == \\' \\') + 1))\\n            .GroupBy(p => p.sender, p => p.words)\\n            .Select(g => (sender : g.Key, wc : g.Sum()))\\n            .OrderByDescending(p => p.wc)\\n            .ThenByDescending(p => p.sender, StringComparer.Ordinal)\\n            .First()\\n            .sender;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n   wordCount = spaceCount + 1\\n```\n```\\npublic class Solution {\\n    public string LargestWordCount(string[] messages, string[] senders) {\\n        return senders\\n            .Zip(messages, (s, m) => (sender : s, words : m.Count(c => c == \\' \\') + 1))\\n            .GroupBy(p => p.sender, p => p.words)\\n            .Select(g => (sender : g.Key, wc : g.Sum()))\\n            .OrderByDescending(p => p.wc)\\n            .ThenByDescending(p => p.sender, StringComparer.Ordinal)\\n            .First()\\n            .sender;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084856,
                "title": "c-dictionary",
                "content": "```\\n    public string LargestWordCount(string[] messages, string[] senders)\\n    {\\n        Dictionary<string, int> messageCount = new();\\n        for (int i = 0; i < messages.Length; i++)\\n        {\\n            messageCount.TryAdd(senders[i], 0);\\n            messageCount[senders[i]] += messages[i].Split(\\' \\').Count();\\n        }\\n\\n        List<string> names = new();\\n        int maxCount = 0;\\n        foreach (var kv in messageCount)\\n        {\\n            if (kv.Value == maxCount)\\n            {\\n                names.Add(kv.Key);\\n            }\\n            else if (kv.Value > maxCount)\\n            {\\n                maxCount = kv.Value;\\n                names = new List<string> { kv.Key };\\n            }\\n        }\\n        return names.OrderBy(n => n, StringComparer.Ordinal).Last();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public string LargestWordCount(string[] messages, string[] senders)\\n    {\\n        Dictionary<string, int> messageCount = new();\\n        for (int i = 0; i < messages.Length; i++)\\n        {\\n            messageCount.TryAdd(senders[i], 0);\\n            messageCount[senders[i]] += messages[i].Split(\\' \\').Count();\\n        }\\n\\n        List<string> names = new();\\n        int maxCount = 0;\\n        foreach (var kv in messageCount)\\n        {\\n            if (kv.Value == maxCount)\\n            {\\n                names.Add(kv.Key);\\n            }\\n            else if (kv.Value > maxCount)\\n            {\\n                maxCount = kv.Value;\\n                names = new List<string> { kv.Key };\\n            }\\n        }\\n        return names.OrderBy(n => n, StringComparer.Ordinal).Last();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084585,
                "title": "easiest-explanation-python",
                "content": "class Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        \\n        f={}\\n        for i in range(len(senders)):\\n            if senders[i] in f:\\n                f[senders[i]]=f[senders[i]]+\" \"+messages[i]\\n            else:\\n                f[senders[i]]=messages[i]\\n      \\n        for values in f:\\n            f[values]=(len((f[values]).split()))\\n        m=max(f.values())\\n \\n        keys = [k for k, v in f.items() if v == m]\\n        keys.sort()\\n        \\n        return keys[-1]\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        \\n        f={}",
                "codeTag": "Java"
            },
            {
                "id": 2084391,
                "title": "c-priority-queue-hashmap",
                "content": "```\\nclass Solution {\\nprivate:\\n    struct my_comparator {\\n        bool operator() (const pair<int,string>&a, const pair<int,string>& b) {\\n            if(a.first != b.first) {\\n                return a.first > b.first;\\n            }\\n            else {\\n                return a.second > b.second;\\n            }\\n        }\\n    };\\n    \\n    int count_words(string str){\\n        int count=0;\\n        for(int i=0;i<str.size();i++){\\n            if(str[i]==\\' \\'){ count++; }\\n        }\\n        return count+1;\\n    }\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string, int> mp;\\n        for(int i=0;i<messages.size();i++){\\n            int temp = count_words(messages[i]);\\n            mp[senders[i]] += temp;\\n        }\\n        \\n        priority_queue<pair<int,string>, vector<pair<int,string>>,my_comparator> pq;\\n        for(auto itrator: mp){\\n            pq.push({itrator.second, itrator.first});\\n            if(pq.size()>1){ \\n                pq.pop(); \\n            }\\n        }\\n        return pq.top().second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    struct my_comparator {\\n        bool operator() (const pair<int,string>&a, const pair<int,string>& b) {\\n            if(a.first != b.first) {\\n                return a.first > b.first;\\n            }\\n            else {\\n                return a.second > b.second;\\n            }\\n        }\\n    };\\n    \\n    int count_words(string str){\\n        int count=0;\\n        for(int i=0;i<str.size();i++){\\n            if(str[i]==\\' \\'){ count++; }\\n        }\\n        return count+1;\\n    }\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string, int> mp;\\n        for(int i=0;i<messages.size();i++){\\n            int temp = count_words(messages[i]);\\n            mp[senders[i]] += temp;\\n        }\\n        \\n        priority_queue<pair<int,string>, vector<pair<int,string>>,my_comparator> pq;\\n        for(auto itrator: mp){\\n            pq.push({itrator.second, itrator.first});\\n            if(pq.size()>1){ \\n                pq.pop(); \\n            }\\n        }\\n        return pq.top().second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084172,
                "title": "c-count-space-map-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// this function will return the number of words in the given string\\n    int countWord(string s){\\n        int cnt=1;\\n        for(int i=0;i<s.size();i++) \\n            if(s[i]==\\' \\') cnt++;\\n        return cnt;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string,int> mp;\\n        for(int i=0;i<messages.size();i++){\\n            int cnt=countWord(messages[i]); // count the number of word in i-th string\\n            mp[senders[i]]+=cnt; // store it into the map\\n        }\\n        string ans=\"\";\\n        int count=0;\\n\\t\\t// now just check the highest number of words\\n        for(auto x:mp){\\n            if(x.second>count or (x.second==count and x.first>ans)){\\n                ans=x.first;\\n                count=x.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**If you like this, Do Upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// this function will return the number of words in the given string\\n    int countWord(string s){\\n        int cnt=1;\\n        for(int i=0;i<s.size();i++) \\n            if(s[i]==\\' \\') cnt++;\\n        return cnt;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string,int> mp;\\n        for(int i=0;i<messages.size();i++){\\n            int cnt=countWord(messages[i]); // count the number of word in i-th string\\n            mp[senders[i]]+=cnt; // store it into the map\\n        }\\n        string ans=\"\";\\n        int count=0;\\n\\t\\t// now just check the highest number of words\\n        for(auto x:mp){\\n            if(x.second>count or (x.second==count and x.first>ans)){\\n                ans=x.first;\\n                count=x.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084132,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int func(string s){\\n        int c=0;\\n        for(auto n: s){\\n            if(n==\\' \\') c++;\\n        }\\n        return c+1;\\n    }\\n    string largestWordCount(vector<string>& m, vector<string>& senders) {\\n        map<string,int> mp;\\n        for(int i=0;i<m.size(); i++){\\n            mp[senders[i]] += func(m[i]);\\n        }\\n        int maxVal = INT_MIN;\\n        string ans=\"\";\\n        \\n        for(auto it:mp){\\n            if(it.second >= maxVal){\\n                maxVal = it.second;\\n                ans = it.first;\\n            }\\n            \\n        }\\n        return ans;\\n\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int func(string s){\\n        int c=0;\\n        for(auto n: s){\\n            if(n==\\' \\') c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2083930,
                "title": "sender-with-largest-word-count-java-solution",
                "content": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String, Integer> hm=new HashMap<>();//sender->word count\\n        int n=messages.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            String sender=senders[i];\\n            int wordCount=messages[i].split(\"\\\\\\\\s\").length;\\n            hm.put(sender,hm.getOrDefault(sender,0)+wordCount);\\n        }\\n        int largest=Integer.MIN_VALUE;\\n        String ans=\"\";\\n        for(String sender:hm.keySet())\\n        {\\n            int value=hm.get(sender);\\n            if(value > largest)\\n            {\\n                largest=value;\\n                ans=sender;\\n            }\\n            else if(value == largest)\\n            {\\n                if(ans.compareTo(sender) < 0)\\n                {\\n                    ans=sender;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String, Integer> hm=new HashMap<>();//sender->word count\\n        int n=messages.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            String sender=senders[i];\\n            int wordCount=messages[i].split(\"\\\\\\\\s\").length;\\n            hm.put(sender,hm.getOrDefault(sender,0)+wordCount);\\n        }\\n        int largest=Integer.MIN_VALUE;\\n        String ans=\"\";\\n        for(String sender:hm.keySet())\\n        {\\n            int value=hm.get(sender);\\n            if(value > largest)\\n            {\\n                largest=value;\\n                ans=sender;\\n            }\\n            else if(value == largest)\\n            {\\n                if(ans.compareTo(sender) < 0)\\n                {\\n                    ans=sender;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083865,
                "title": "string-stream-and-hashmap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string,int> hm;\\n        int n = messages.size();\\n        for(int i=0;i<n;i++){\\n            istringstream ss(messages[i]);\\n            string temp;\\n            int cnt = 0;\\n            while(getline(ss,temp,\\' \\')){\\n            cnt++;\\n            }\\n            hm[senders[i]] += cnt;\\n        }\\n        int mx = INT_MIN;\\n        for(auto it:hm){\\n            mx = max(it.second,mx);\\n        }\\n        string ans=\"\";\\n        for(auto it:hm){\\n            if(mx == it.second){\\n                if(ans < it.first){\\n                    ans = it.first;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string,int> hm;\\n        int n = messages.size();\\n        for(int i=0;i<n;i++){\\n            istringstream ss(messages[i]);\\n            string temp;\\n            int cnt = 0;\\n            while(getline(ss,temp,\\' \\')){\\n            cnt++;\\n            }\\n            hm[senders[i]] += cnt;\\n        }\\n        int mx = INT_MIN;\\n        for(auto it:hm){\\n            mx = max(it.second,mx);\\n        }\\n        string ans=\"\";\\n        for(auto it:hm){\\n            if(mx == it.second){\\n                if(ans < it.first){\\n                    ans = it.first;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083834,
                "title": "c-easy-to-understand-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        int n=m.size();\\n        map<string,vector<string>> mp;\\n        int maxi=-1;\\n        string ans=\"asdja\";\\n        for(int i=0;i<n;i++)\\n        {\\n            string str=m[i]+\\' \\';\\n            int left=0;\\n            for(int j=0;j<str.size();j++)\\n            {\\n                if(str[j]==\\' \\')\\n                {\\n                    string str2=str.substr(left,j-left);\\n     \\n                    left=j+1;\\n                    mp[s[i]].push_back(str2);\\n                    maxi=max((int)maxi,(int)mp[s[i]].size());\\n                }\\n            }\\n        }\\n        for(auto pr:mp)\\n        {\\n            if(pr.second.size()==maxi)\\n            {\\n                ans=pr.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        int n=m.size();\\n        map<string,vector<string>> mp;\\n        int maxi=-1;\\n        string ans=\"asdja\";\\n        for(int i=0;i<n;i++)\\n        {\\n            string str=m[i]+\\' \\';\\n            int left=0;\\n            for(int j=0;j<str.size();j++)\\n            {\\n                if(str[j]==\\' \\')\\n                {\\n                    string str2=str.substr(left,j-left);\\n     \\n                    left=j+1;\\n                    mp[s[i]].push_back(str2);\\n                    maxi=max((int)maxi,(int)mp[s[i]].size());\\n                }\\n            }\\n        }\\n        for(auto pr:mp)\\n        {\\n            if(pr.second.size()==maxi)\\n            {\\n                ans=pr.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083770,
                "title": "c-stringstream",
                "content": "```   \\nstring largestWordCount(vector<string>& m, vector<string>& s) {\\n        string ans;\\n        int Maxcnt=0;\\n        unordered_map<string,int> umap;\\n\\n        for(int i=0;i<s.size();i++){\\n            stringstream ss(m[i]);\\n            string word;\\n            int cnt=0;\\n            while(ss>>word){\\n                cnt++;\\n            }\\n            int k=cnt;\\n            cnt+=umap[s[i]];           // taking previous counts\\n            if(cnt>Maxcnt){\\n                ans=s[i];\\n                Maxcnt=cnt;\\n            }\\n            else if(Maxcnt==cnt){\\n                if(s[i]>ans) ans=s[i];\\n            }\\n            umap[s[i]]+=k;\\n        }\\n        return ans;\\n }\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```   \\nstring largestWordCount(vector<string>& m, vector<string>& s) {\\n        string ans;\\n        int Maxcnt=0;\\n        unordered_map<string,int> umap;\\n\\n        for(int i=0;i<s.size();i++){\\n            stringstream ss(m[i]);\\n            string word;\\n            int cnt=0;\\n            while(ss>>word){\\n                cnt++;\\n            }\\n            int k=cnt;\\n            cnt+=umap[s[i]];           // taking previous counts\\n            if(cnt>Maxcnt){\\n                ans=s[i];\\n                Maxcnt=cnt;\\n            }\\n            else if(Maxcnt==cnt){\\n                if(s[i]>ans) ans=s[i];\\n            }\\n            umap[s[i]]+=k;\\n        }\\n        return ans;\\n }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3957793,
                "title": "easy-c-solution-using-map-and-stl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        unordered_map<string,int> mp;\\n        int mx=INT_MIN;\\n        string ans=\"\";\\n        for(int i=0;i<m.size();i++)\\n        {\\n            char ch=\\' \\';\\n            int counter=0;\\n            counter=count(m[i].begin(),m[i].end(),ch);\\n            mp[s[i]]+=(counter+1);\\n            if(mp[s[i]] == mx){\\n               ans = max(ans ,s[i] );\\n            }\\n            else if(mp[s[i]] > mx){\\n                mx = mp[s[i]];\\n                ans = s[i];\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        unordered_map<string,int> mp;\\n        int mx=INT_MIN;\\n        string ans=\"\";\\n        for(int i=0;i<m.size();i++)\\n        {\\n            char ch=\\' \\';\\n            int counter=0;\\n            counter=count(m[i].begin(),m[i].end(),ch);\\n            mp[s[i]]+=(counter+1);\\n            if(mp[s[i]] == mx){\\n               ans = max(ans ,s[i] );\\n            }\\n            else if(mp[s[i]] > mx){\\n                mx = mp[s[i]];\\n                ans = s[i];\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562670,
                "title": "easy-simple-basic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int helper(string &s){\\n        int ans = 0;\\n        int i=0;\\n        while(i < s.length()){\\n            while(i < s.length() && s[i] != \\' \\'){\\n                i++;\\n            }\\n            i++;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string, int> mp;\\n        string ans = \"\";\\n        int mx = 0;\\n\\n        for(int i=0;i<messages.size();i++){\\n            int count = helper(messages[i]);\\n            mp[senders[i]] += count;\\n            if(mp[senders[i]] == mx){\\n               ans = max(ans ,senders[i] );\\n            }\\n            else if(mp[senders[i]] > mx){\\n                mx = mp[senders[i]];\\n                ans = senders[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int helper(string &s){\\n        int ans = 0;\\n        int i=0;\\n        while(i < s.length()){\\n            while(i < s.length() && s[i] != \\' \\'){\\n                i++;\\n            }\\n            i++;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string, int> mp;\\n        string ans = \"\";\\n        int mx = 0;\\n\\n        for(int i=0;i<messages.size();i++){\\n            int count = helper(messages[i]);\\n            mp[senders[i]] += count;\\n            if(mp[senders[i]] == mx){\\n               ans = max(ans ,senders[i] );\\n            }\\n            else if(mp[senders[i]] > mx){\\n                mx = mp[senders[i]];\\n                ans = senders[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485904,
                "title": "easy-solution-using-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncounting and hashmap\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncount each senders word and store in hashmap. If current count is more than max_count, then update the sender\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        int max_count = INT_MIN, cnt, n=senders.size();        \\n        map<string, int> mp;\\n\\n        string msg, sender, ms=\"\";\\n        \\n        for (int i=0; i<n; i++) {\\n            msg = messages[i], sender = senders[i];\\n            \\n            mp[sender] += count(msg.begin(), msg.end(), \\' \\')+1;\\n            \\n            cnt = mp[sender];\\n            \\n            if (cnt > max_count) {\\n                max_count = cnt;\\n                ms = sender;\\n            }\\n            else if (cnt == max_count) {\\n                if (sender > ms) ms = sender;\\n            }\\n            \\n        }\\n\\n        return ms;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        int max_count = INT_MIN, cnt, n=senders.size();        \\n        map<string, int> mp;\\n\\n        string msg, sender, ms=\"\";\\n        \\n        for (int i=0; i<n; i++) {\\n            msg = messages[i], sender = senders[i];\\n            \\n            mp[sender] += count(msg.begin(), msg.end(), \\' \\')+1;\\n            \\n            cnt = mp[sender];\\n            \\n            if (cnt > max_count) {\\n                max_count = cnt;\\n                ms = sender;\\n            }\\n            else if (cnt == max_count) {\\n                if (sender > ms) ms = sender;\\n            }\\n            \\n        }\\n\\n        return ms;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877665,
                "title": "most-intuitive-python-solution",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        \\n        d = defaultdict(int)\\n        ans = [0, \\'a\\']\\n        \\n        for i, x in enumerate(messages):\\n            d[senders[i]] += x.count(\\' \\') + 1\\n            ans = max(ans, [d[senders[i]], senders[i]])\\n            \\n        return ans[1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        \\n        d = defaultdict(int)\\n        ans = [0, \\'a\\']\\n        \\n        for i, x in enumerate(messages):\\n            d[senders[i]] += x.count(\\' \\') + 1\\n            ans = max(ans, [d[senders[i]], senders[i]])\\n            \\n        return ans[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829141,
                "title": "c-intuitive-hashmap",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        \\n        string ans=\"\";\\n        map<string, int> mp;\\n        for(int i=0; i<messages.size(); i++)\\n        {\\n            string s = messages[i];\\n            for(int j=0; j<s.size(); j++){\\n                if(s[j] == \\' \\')\\n                    mp[senders[i]]+=1;\\n            }\\n            mp[senders[i]]+=1;\\n        }\\n        \\n        int maxi = INT_MIN;\\n        for(auto i: mp){\\n            if(i.second >= maxi){\\n                maxi=i.second;\\n                if(i.first>ans)\\n                    ans=i.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2755007,
                "title": "c-easy-short",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) \\n    {\\n        unordered_map<string,int>mp;\\n        int size = messages.size();\\n        int words=0;\\n        int val=0;\\n        string ans=\"\";\\n        string str;\\n        for(int i=0;i<size;i++)\\n        {\\n            str = messages[i];\\n            words=0;\\n            for(int j=0;j<str.length();j++)\\n            {\\n                if(str[j]==\\' \\')\\n                {\\n                    words++;\\n                }\\n            }\\n            words++;\\n            mp[senders[i]]+=words;\\n            if(val<mp[senders[i]])\\n            {\\n                val=mp[senders[i]];\\n                ans=senders[i];\\n            }\\n            else if(val==mp[senders[i]] and senders[i]>ans)\\n            {\\n                ans=senders[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) \\n    {\\n        unordered_map<string,int>mp;\\n        int size = messages.size();\\n        int words=0;\\n        int val=0;\\n        string ans=\"\";\\n        string str;\\n        for(int i=0;i<size;i++)\\n        {\\n            str = messages[i];\\n            words=0;\\n            for(int j=0;j<str.length();j++)\\n            {\\n                if(str[j]==\\' \\')\\n                {\\n                    words++;\\n                }\\n            }\\n            words++;\\n            mp[senders[i]]+=words;\\n            if(val<mp[senders[i]])\\n            {\\n                val=mp[senders[i]];\\n                ans=senders[i];\\n            }\\n            else if(val==mp[senders[i]] and senders[i]>ans)\\n            {\\n                ans=senders[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755005,
                "title": "easy-cpp-solution-count-method",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) \\n    {\\n        string name=\"\";\\n        int ans=INT_MIN;\\n        unordered_map<string,int>mp;\\n        for(int i=0;i<messages.size();i++)\\n        {\\n            int val = count(messages[i].begin(),messages[i].end(),\\' \\')+1;\\n            mp[senders[i]]+=val;\\n            if(mp[senders[i]]>ans or (mp[senders[i]]==ans and senders[i]>name))\\n            {\\n                ans=mp[senders[i]];\\n                name=senders[i];\\n            }\\n        }\\n        return name;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) \\n    {\\n        string name=\"\";\\n        int ans=INT_MIN;\\n        unordered_map<string,int>mp;\\n        for(int i=0;i<messages.size();i++)\\n        {\\n            int val = count(messages[i].begin(),messages[i].end(),\\' \\')+1;\\n            mp[senders[i]]+=val;\\n            if(mp[senders[i]]>ans or (mp[senders[i]]==ans and senders[i]>name))\\n            {\\n                ans=mp[senders[i]];\\n                name=senders[i];\\n            }\\n        }\\n        return name;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754949,
                "title": "c-easy-short",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) \\n{\\n    unordered_map<string,int>mp;\\n    int size = messages.size();\\n    \\n    for(int i=0;i<size;i++)\\n    {\\n    \\tstring str = messages[i];\\n    \\t\\n    \\tint idx=0;\\n    \\t\\n    \\twhile(idx<str.length())\\n    \\t{\\n            string s=\"\";\\n    \\t\\twhile(idx<str.length() and ((str[idx]>=\\'a\\' and str[idx]<=\\'z\\') or (str[idx]>=\\'A\\' and str[idx]<=\\'Z\\')))\\n    \\t\\t{\\n    \\t\\t\\t s.push_back(str[idx]);\\n    \\t\\t\\t idx++;\\n\\t\\t\\t}\\n\\t\\t\\tmp[senders[i]]=mp[senders[i]]+1;\\n\\t\\t\\twhile(idx<str.length() and (str[idx]==\\' \\'))\\n\\t\\t\\t{\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tint val = INT_MIN;\\n\\tfor(auto it=mp.begin();it!=mp.end();it++)\\n\\t{\\n\\t\\tif(it->second > val)\\n\\t\\t{\\n\\t\\t\\tval = it->second;\\n\\t\\t}\\n\\t}\\n\\tstring ans=\"\";\\n\\tfor(auto it=mp.begin();it!=mp.end();it++)\\n\\t{\\n\\t\\tif(it->second == val and it->first > ans)\\n\\t\\t{\\n\\t\\t\\tans=it->first;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) \\n{\\n    unordered_map<string,int>mp;\\n    int size = messages.size();\\n    \\n    for(int i=0;i<size;i++)\\n    {\\n    \\tstring str = messages[i];\\n    \\t\\n    \\tint idx=0;\\n    \\t\\n    \\twhile(idx<str.length())\\n    \\t{\\n            string s=\"\";\\n    \\t\\twhile(idx<str.length() and ((str[idx]>=\\'a\\' and str[idx]<=\\'z\\') or (str[idx]>=\\'A\\' and str[idx]<=\\'Z\\')))\\n    \\t\\t{\\n    \\t\\t\\t s.push_back(str[idx]);\\n    \\t\\t\\t idx++;\\n\\t\\t\\t}\\n\\t\\t\\tmp[senders[i]]=mp[senders[i]]+1;\\n\\t\\t\\twhile(idx<str.length() and (str[idx]==\\' \\'))\\n\\t\\t\\t{\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tint val = INT_MIN;\\n\\tfor(auto it=mp.begin();it!=mp.end();it++)\\n\\t{\\n\\t\\tif(it->second > val)\\n\\t\\t{\\n\\t\\t\\tval = it->second;\\n\\t\\t}\\n\\t}\\n\\tstring ans=\"\";\\n\\tfor(auto it=mp.begin();it!=mp.end();it++)\\n\\t{\\n\\t\\tif(it->second == val and it->first > ans)\\n\\t\\t{\\n\\t\\t\\tans=it->first;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744277,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   string largestWordCount(vector<string>& messages, vector<string>& senders){\\n        map<string, int> mp;\\n        for(int i = 0; i<messages.size(); ++i){\\n            int words = count(begin(messages[i]), end(messages[i]), \\' \\')+1;\\n            mp[senders[i]]+=words;\\n        }\\n        string ans = \"\";\\n        int count = 0;\\n        for(auto it = mp.begin(); it!=mp.end(); ++it){\\n            if(it->second >= count){\\n                count = it->second;\\n                ans = it->first;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string largestWordCount(vector<string>& messages, vector<string>& senders){\\n        map<string, int> mp;\\n        for(int i = 0; i<messages.size(); ++i){\\n            int words = count(begin(messages[i]), end(messages[i]), \\' \\')+1;\\n            mp[senders[i]]+=words;\\n        }\\n        string ans = \"\";\\n        int count = 0;\\n        for(auto it = mp.begin(); it!=mp.end(); ++it){\\n            if(it->second >= count){\\n                count = it->second;\\n                ans = it->first;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720705,
                "title": "simple-java-solution-beats-99",
                "content": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) \\n    {\\n        HashMap<String,Integer> map = new HashMap<>();\\n        String res = \"\";int max =0;\\n        \\n        for(int i=0; i<messages.length;i++)\\n        {\\n            int words = get_count(messages[i]);\\n            \\n            if(!map.containsKey(senders[i]))\\n               map.put(senders[i] , words);\\n               \\n            else\\n               map.put(senders[i],map.get(senders[i]) + words);\\n        }\\n        \\n        for(String s: map.keySet())\\n        {\\n            if(map.get(s) > max)\\n            {\\n                res = s;\\n                max = map.get(s);\\n            }\\n            \\n            if(map.get(s) == max && res.compareTo(s) < 0)\\n                res = s;\\n        }\\n        return res;\\n    }\\n    \\n    private int get_count(String s)\\n    {\\n        int spaces = 0;\\n        \\n        for(int i=0; i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\' \\')\\n                spaces++;\\n        }\\n        return spaces+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) \\n    {\\n        HashMap<String,Integer> map = new HashMap<>();\\n        String res = \"\";int max =0;\\n        \\n        for(int i=0; i<messages.length;i++)\\n        {\\n            int words = get_count(messages[i]);\\n            \\n            if(!map.containsKey(senders[i]))\\n               map.put(senders[i] , words);\\n               \\n            else\\n               map.put(senders[i],map.get(senders[i]) + words);\\n        }\\n        \\n        for(String s: map.keySet())\\n        {\\n            if(map.get(s) > max)\\n            {\\n                res = s;\\n                max = map.get(s);\\n            }\\n            \\n            if(map.get(s) == max && res.compareTo(s) < 0)\\n                res = s;\\n        }\\n        return res;\\n    }\\n    \\n    private int get_count(String s)\\n    {\\n        int spaces = 0;\\n        \\n        for(int i=0; i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\' \\')\\n                spaces++;\\n        }\\n        return spaces+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720324,
                "title": "python-o-n",
                "content": "```python\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        count = defaultdict(int)\\n        largest, name = 0, \\'\\'\\n        for i in range(len(messages)):\\n            count[senders[i]] += messages[i].count(\\' \\') + 1\\n            if count[senders[i]] > largest \\\\\\n            or (count[senders[i]] == largest and senders[i] > name):\\n                largest = count[senders[i]]\\n                name = senders[i]\\n        return name\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        count = defaultdict(int)\\n        largest, name = 0, \\'\\'\\n        for i in range(len(messages)):\\n            count[senders[i]] += messages[i].count(\\' \\') + 1\\n            if count[senders[i]] > largest \\\\\\n            or (count[senders[i]] == largest and senders[i] > name):\\n                largest = count[senders[i]]\\n                name = senders[i]\\n        return name\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643277,
                "title": "python3-hash-word-count-associated-with-a-sender-s-name-then-return-max",
                "content": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        words_count = defaultdict(int)\\n        for m, person in zip(messages, senders):\\n            words_count[person] += len(m.split())\\n                \\n        max_len = max(words_count.values())\\n        \\n        names = sorted([name for name, words in words_count.items() if words == max_len], reverse=True)\\n        return names[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        words_count = defaultdict(int)\\n        for m, person in zip(messages, senders):\\n            words_count[person] += len(m.split())\\n                \\n        max_len = max(words_count.values())\\n        \\n        names = sorted([name for name, words in words_count.items() if words == max_len], reverse=True)\\n        return names[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634032,
                "title": "c-map-vector-of-pairs-sorting-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n      \\n      unordered_map<string,int>mpp;\\n      \\n       for(int i=0;i<m.size();++i)\\n       {\\n           int cnt=0;\\n        for(int j=0;j<m[i].size();++j)\\n        {\\n            if(m[i][j]==\\' \\') cnt++;\\n            \\n        }\\n         mpp[s[i]]+=cnt+1;\\n         \\n       }\\n      \\n      vector<pair<int,string>>vp;\\n      \\n      for(auto it:mpp)\\n      {\\n        vp.push_back(make_pair(it.second,it.first));\\n      \\n      }\\n      \\n      sort(vp.begin(),vp.end());\\n      \\n      return vp[vp.size()-1].second ;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n      \\n      unordered_map<string,int>mpp;\\n      \\n       for(int i=0;i<m.size();++i)\\n       {\\n           int cnt=0;\\n        for(int j=0;j<m[i].size();++j)\\n        {\\n            if(m[i][j]==\\' \\') cnt++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2250918,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string,int> mpp;\\n        string temp=\"\";\\n        int j;\\n        for(int i=0;i<senders.size();i++)\\n        {\\n             for(j=0;j<messages[i].size();j++)\\n             {\\n                 if(messages[i][j]==\\' \\')\\n                     mpp[senders[i]]++;\\n             }\\n             if(j==messages[i].size())\\n                 mpp[senders[i]]++;\\n        }\\n        \\n        int maxfreq=INT_MIN;\\n        for(auto it:mpp)\\n        {\\n            if(maxfreq < it.second)\\n            {\\n                maxfreq=it.second;\\n                temp=it.first;\\n            }\\n        }\\n        \\n        for(auto it:mpp)\\n        {\\n            if(it.second==maxfreq && temp < it.first)\\n            {\\n                temp=it.first;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string,int> mpp;\\n        string temp=\"\";\\n        int j;\\n        for(int i=0;i<senders.size();i++)\\n        {\\n             for(j=0;j<messages[i].size();j++)\\n             {\\n                 if(messages[i][j]==\\' \\')\\n                     mpp[senders[i]]++;\\n             }\\n             if(j==messages[i].size())\\n                 mpp[senders[i]]++;\\n        }\\n        \\n        int maxfreq=INT_MIN;\\n        for(auto it:mpp)\\n        {\\n            if(maxfreq < it.second)\\n            {\\n                maxfreq=it.second;\\n                temp=it.first;\\n            }\\n        }\\n        \\n        for(auto it:mpp)\\n        {\\n            if(it.second==maxfreq && temp < it.first)\\n            {\\n                temp=it.first;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244714,
                "title": "python-solution",
                "content": "```\\ndef largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        hashmap = defaultdict(int)\\n        \\n        for i in range(len(messages)):\\n            hashmap[senders[i]] += len(messages[i].split(\" \"))\\n        \\n\\t\\t# (hashmap.get(x),x) -> sort by frequency of words used or if frequency is same sort by the sender name\\n        result = sorted(hashmap.keys(), key=lambda x: (hashmap.get(x), x), reverse = True)\\n        \\n        return result[0]",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\ndef largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        hashmap = defaultdict(int)\\n        \\n        for i in range(len(messages)):\\n            hashmap[senders[i]] += len(messages[i].split(\" \"))\\n        \\n\\t\\t# (hashmap.get(x),x) -> sort by frequency of words used or if frequency is same sort by the sender name\\n        result = sorted(hashmap.keys(), key=lambda x: (hashmap.get(x), x), reverse = True)\\n        \\n        return result[0]",
                "codeTag": "Python3"
            },
            {
                "id": 2209262,
                "title": "easy-with-map",
                "content": "```\\nfunc largestWordCount(messages []string, senders []string) string {\\n    m := make(map[string]int)\\n    \\n    for i := 0; i < len(senders); i++ {\\n        m[senders[i]] += len(strings.Split(messages[i], \" \"))\\n    }\\n\\n    maxSender := senders[0]\\n    maxMessage := m[maxSender]\\n    \\n    for key, value := range m {\\n        if value > maxMessage || (value == maxMessage && key > maxSender) {\\n            maxSender = key\\n            maxMessage = value\\n        }\\n    }\\n    \\n    return maxSender\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nfunc largestWordCount(messages []string, senders []string) string {\\n    m := make(map[string]int)\\n    \\n    for i := 0; i < len(senders); i++ {\\n        m[senders[i]] += len(strings.Split(messages[i], \" \"))\\n    }\\n\\n    maxSender := senders[0]\\n    maxMessage := m[maxSender]\\n    \\n    for key, value := range m {\\n        if value > maxMessage || (value == maxMessage && key > maxSender) {\\n            maxSender = key\\n            maxMessage = value\\n        }\\n    }\\n    \\n    return maxSender\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2188238,
                "title": "c-hashmap-with-comparison",
                "content": "The code is self explanatory\\n\\n```\\nclass Solution {\\npublic:  \\n    \\n    static bool cmp(pair<int,string>& a, pair<int,string>& b)  // always remember in a class the sort function needs                                                                          static function.\\n    {\\n        if(a.first == b.first) return a.second > b.second;\\n        return a.first > b.first;\\n    }\\n       \\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        vector<pair<int,string>> v;\\n        unordered_map<string,int> mp; // use map to cover the cases of multiple msg on same name.\\n        \\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            int c= 0;\\n            for(int j = 0; j < m[i].size(); j++)\\n            {\\n                if(m[i][j] == \\' \\') c++; \\n            }\\n            \\n            mp[s[i]] += c+1;\\n        }\\n        \\n        for(auto k : mp) v.push_back({k.second, k.first});\\n        sort(v.begin(), v.end(), cmp);\\n        \\n        return v[0].second;   \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:  \\n    \\n    static bool cmp(pair<int,string>& a, pair<int,string>& b)  // always remember in a class the sort function needs                                                                          static function.\\n    {\\n        if(a.first == b.first) return a.second > b.second;\\n        return a.first > b.first;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2183153,
                "title": "javascript-one-liner",
                "content": "```\\n/**\\n * @param {string[]} messages\\n * @param {string[]} senders\\n * @return {string}\\n */\\nconst largestWordCount = (messages, senders) => Object.entries(senders.reduce((counter, name, i) => (counter[name] = (counter[name] ?? 0) + messages[i].split(/\\\\s/).length, counter), {})).sort((a, b) => b[1] - a[1] !== 0 ? b[1] - a[1] : (a[0] > b[0] ? -1 : 1))[0][0];\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} messages\\n * @param {string[]} senders\\n * @return {string}\\n */\\nconst largestWordCount = (messages, senders) => Object.entries(senders.reduce((counter, name, i) => (counter[name] = (counter[name] ?? 0) + messages[i].split(/\\\\s/).length, counter), {})).sort((a, b) => b[1] - a[1] !== 0 ? b[1] - a[1] : (a[0] > b[0] ? -1 : 1))[0][0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2175459,
                "title": "c-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string,int> mp;\\n        int ans=INT_MIN;\\n        string temp=\"-1\";\\n        for(int i=0;i<messages.size();i++){\\n            int count=0;\\n            stringstream sss(messages[i]);\\n            string word;\\n            while(sss>>word){\\n                count++;\\n            }\\n            mp[senders[i]] += count;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.second>ans)\\n            {\\n                ans=it.second;\\n                temp=it.first;\\n            }\\n            else if(it.second==ans)\\n            {\\n                temp=max(temp,it.first);\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string,int> mp;\\n        int ans=INT_MIN;\\n        string temp=\"-1\";\\n        for(int i=0;i<messages.size();i++){\\n            int count=0;\\n            stringstream sss(messages[i]);\\n            string word;\\n            while(sss>>word){\\n                count++;\\n            }\\n            mp[senders[i]] += count;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.second>ans)\\n            {\\n                ans=it.second;\\n                temp=it.first;\\n            }\\n            else if(it.second==ans)\\n            {\\n                temp=max(temp,it.first);\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151937,
                "title": "python3-clear-solution-using-dictionaries-for-word-count-per-sender",
                "content": "At first glance, I thought that I can get the solution by making one loop over `zip(messages, senders)` and finding the sender with the maximum word count, But I realized that this won\\'t work because a sender can send multple messages. Therefore, I had to create a dictionary to track the word count of each sender, then find the sender with the biggest word count.\\n\\nAnother thing to note is that I don\\'t need to split the message into a list of words then get the length of that list. I can simply get the number of words by counting the number of spaces between each word then adding one to it. Therefore I won\\'t need extra memory to store the words list in order to get its length. I thought about using generators instead of lists, but I think this approach in much simpler. \\n\\n```python\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        word_count = {}\\n        \\n        for message, sender in zip(messages, senders):\\n            message_word_count = message.count(\" \") + 1\\n            word_count[sender] = word_count.get(sender, 0) + message_word_count\\n            \\n        top_sender = \"\"\\n        max_count = 0\\n        \\n        for sender, wc in word_count.items():\\n            if wc > max_count or (wc == max_count and sender > top_sender ):\\n                top_sender = sender\\n                max_count = wc\\n                \\n        return top_sender\\n```\\n\\n**Time complexity:** `O(nm)` where `n` is the length of `messages` or `senders`, `m` is the maximum message length.\\nwe loop over both lists at once, counting the spaces in each message, which takes `O(m)`. so the first `for` loop takes `O(nm)`. The second loop looks for the sender with the maximum word count. the worst case is that all the names in `senders` are unique, Therefore this loop would take `O(n)`.\\n\\n**Space complexity:** `O(n)`\\nThe created dictionary would have `n` senders at the worst case, which requires a space complexity of `O(n)`",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Counting"
                ],
                "code": "```python\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        word_count = {}\\n        \\n        for message, sender in zip(messages, senders):\\n            message_word_count = message.count(\" \") + 1\\n            word_count[sender] = word_count.get(sender, 0) + message_word_count\\n            \\n        top_sender = \"\"\\n        max_count = 0\\n        \\n        for sender, wc in word_count.items():\\n            if wc > max_count or (wc == max_count and sender > top_sender ):\\n                top_sender = sender\\n                max_count = wc\\n                \\n        return top_sender\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140115,
                "title": "unique-and-easy-python-solution-unique-approach-memory-usage-less-than-99-91",
                "content": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        \\n        dic = {}\\n        name = 0\\n        while senders:\\n            print(senders[name] , messages[name].lstrip().rstrip())\\n            \\n            if senders[name] not in dic:\\n                dic[senders[name]] = len(messages[name].lstrip().rstrip().split(\\' \\'))\\n\\n            else:\\n                dic[senders[name]] += len(messages[name].lstrip().rstrip().split(\\' \\'))\\n            \\n            senders.pop(name)\\n            messages.pop(name)\\n                \\n        \\n        d = {}\\n        for key , val in dic.items():\\n            if val not in d:\\n                d[val] = [key]\\n                \\n            else:\\n                d[val].append(key)\\n                \\n            d[val].sort(reverse = True)\\n                \\n            \\n        return d[max(d)][0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        \\n        dic = {}\\n        name = 0\\n        while senders:\\n            print(senders[name] , messages[name].lstrip().rstrip())\\n            \\n            if senders[name] not in dic:\\n                dic[senders[name]] = len(messages[name].lstrip().rstrip().split(\\' \\'))\\n\\n            else:\\n                dic[senders[name]] += len(messages[name].lstrip().rstrip().split(\\' \\'))\\n            \\n            senders.pop(name)\\n            messages.pop(name)\\n                \\n        \\n        d = {}\\n        for key , val in dic.items():\\n            if val not in d:\\n                d[val] = [key]\\n                \\n            else:\\n                d[val].append(key)\\n                \\n            d[val].sort(reverse = True)\\n                \\n            \\n        return d[max(d)][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100494,
                "title": "rust-hashmap-counter-split-o-n",
                "content": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn largest_word_count(messages: Vec<String>, senders: Vec<String>) -> String {\\n        let n = senders.len();\\n        let mut xs = HashMap::new();\\n        let mut hi = 0;\\n        let mut ans = String::new();\\n        for (i, x) in senders.into_iter().enumerate() {\\n            let cnt = messages[i].split(\" \").collect::<Vec<&str>>().len();\\n            *xs.entry(x.clone()).or_insert(0) += cnt;\\n            if xs[&x] > hi || (xs[&x] == hi && x > ans) {\\n                hi = xs[&x];\\n                ans = x;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn largest_word_count(messages: Vec<String>, senders: Vec<String>) -> String {\\n        let n = senders.len();\\n        let mut xs = HashMap::new();\\n        let mut hi = 0;\\n        let mut ans = String::new();\\n        for (i, x) in senders.into_iter().enumerate() {\\n            let cnt = messages[i].split(\" \").collect::<Vec<&str>>().len();\\n            *xs.entry(x.clone()).or_insert(0) += cnt;\\n            if xs[&x] > hi || (xs[&x] == hi && x > ans) {\\n                hi = xs[&x];\\n                ans = x;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2091769,
                "title": "js-solution-using-map",
                "content": "```\\nvar largestWordCount = function(messages, senders) {\\n    let map = new Map();\\n    for(let i=0;i<messages.length;i++){\\n        if(map.get(senders[i])){\\n            map.set(senders[i],map.get(senders[i])+messages[i].split(\\' \\').length);    \\n        }\\n        else map.set(senders[i],messages[i].split(\\' \\').length);\\n    }\\n    let max=0,ans=\\'\\';\\n    for(let [key,val] of map){\\n        if(val>max){\\n            max=val;\\n            ans=key\\n        }else if(val===max){\\n            ans = key>ans ? key: ans;\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestWordCount = function(messages, senders) {\\n    let map = new Map();\\n    for(let i=0;i<messages.length;i++){\\n        if(map.get(senders[i])){\\n            map.set(senders[i],map.get(senders[i])+messages[i].split(\\' \\').length);    \\n        }\\n        else map.set(senders[i],messages[i].split(\\' \\').length);\\n    }\\n    let max=0,ans=\\'\\';\\n    for(let [key,val] of map){\\n        if(val>max){\\n            max=val;\\n            ans=key\\n        }else if(val===max){\\n            ans = key>ans ? key: ans;\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2091704,
                "title": "simple-java-solution-in-o-n",
                "content": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        ArrayList<String> key=new ArrayList();\\n        HashMap<String, Integer> mp=new HashMap();\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<messages.length;i++){\\n            int temp = messages[i].split(\" \").length;\\n            if(mp.containsKey(senders[i])){\\n                mp.put(senders[i], mp.get(senders[i])+temp);\\n            }\\n            else{\\n                mp.put(senders[i],temp);\\n                key.add(senders[i]);\\n            }\\n            max = Math.max(max, mp.get(senders[i]));\\n        }\\n        Collections.sort(key);\\n        for(int i=key.size()-1;i>=0;i--){\\n            if(mp.get(key.get(i))==max)return key.get(i);\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        ArrayList<String> key=new ArrayList();\\n        HashMap<String, Integer> mp=new HashMap();\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<messages.length;i++){\\n            int temp = messages[i].split(\" \").length;\\n            if(mp.containsKey(senders[i])){\\n                mp.put(senders[i], mp.get(senders[i])+temp);\\n            }\\n            else{\\n                mp.put(senders[i],temp);\\n                key.add(senders[i]);\\n            }\\n            max = Math.max(max, mp.get(senders[i]));\\n        }\\n        Collections.sort(key);\\n        for(int i=key.size()-1;i>=0;i--){\\n            if(mp.get(key.get(i))==max)return key.get(i);\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086321,
                "title": "python-4-lines-clean-and-precise",
                "content": "Code:\\n\\n```\\n\\t\\td1={}\\n        for i in range(len(messages)): d1[senders[i]]=d1.get(senders[i],0)+(len(messages[i].split(\\' \\')))\\n        t=sorted(d1.items(),key= lambda x: (-x[1],x[0]))\\n        for i in range(len(t)-1,-1,-1):\\n            if t[i][1]==t[0][1]: return t[i][0]\\n```",
                "solutionTags": [
                    "String",
                    "Sorting"
                ],
                "code": "```\\n\\t\\td1={}\\n        for i in range(len(messages)): d1[senders[i]]=d1.get(senders[i],0)+(len(messages[i].split(\\' \\')))\\n        t=sorted(d1.items(),key= lambda x: (-x[1],x[0]))\\n        for i in range(len(t)-1,-1,-1):\\n            if t[i][1]==t[0][1]: return t[i][0]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086193,
                "title": "cpp-best-and-easy-sollution-using-map",
                "content": "class Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        int n=senders.size();\\n        unordered_map<string,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            mp[senders[i]]++;\\n            int size=messages[i].length();\\n            for(int j=0;j<size;j++){\\n                if(messages[i][j]==\\' \\')\\n                    mp[senders[i]]++;\\n            }\\n        }\\n        int count=0;\\n        string ans=\"\";\\n        for(auto x : mp){\\n            if(count<x.second){\\n                count=x.second;\\n                ans=x.first;\\n            }\\n            if(count==x.second and x.first>ans)\\n                ans=x.first;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        int n=senders.size();\\n        unordered_map<string,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            mp[senders[i]]++;\\n            int size=messages[i].length();\\n            for(int j=0;j<size;j++){\\n                if(messages[i][j]==\\' \\')\\n                    mp[senders[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2085311,
                "title": "c-easy-solution-map-and-set",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string,int> m1;\\n        int maxi = 0;\\n\\t\\t\\n        for(int i=0;i<senders.size();i++){\\n\\t\\t\\t// min. no. of words per sender\\n            int req = 1;\\n\\t\\t\\t\\n\\t\\t\\t// count spaces\\n            for(auto &it:messages[i])   if(it==\\' \\') req++;\\n            \\n\\t\\t\\t// insert it into map\\n\\t\\t\\tm1[senders[i]] += req;\\n\\t\\t\\t\\n\\t\\t\\t// get the max value in map\\n            maxi = max(maxi,m1[senders[i]]);\\n        }\\n\\t\\t// using set for highest order string\\n\\t\\tset<string> s1;\\n\\t\\t\\n        for(auto &it:m1){\\n\\t\\t\\n            // string correponding to max value of map\\n\\t\\t\\tif(it.second==maxi){\\n                s1.insert(it.first);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// last element of set\\n        return *(--s1.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string,int> m1;\\n        int maxi = 0;\\n\\t\\t\\n        for(int i=0;i<senders.size();i++){\\n\\t\\t\\t// min. no. of words per sender\\n            int req = 1;\\n\\t\\t\\t\\n\\t\\t\\t// count spaces\\n            for(auto &it:messages[i])   if(it==\\' \\') req++;\\n            \\n\\t\\t\\t// insert it into map\\n\\t\\t\\tm1[senders[i]] += req;\\n\\t\\t\\t\\n\\t\\t\\t// get the max value in map\\n            maxi = max(maxi,m1[senders[i]]);\\n        }\\n\\t\\t// using set for highest order string\\n\\t\\tset<string> s1;\\n\\t\\t\\n        for(auto &it:m1){\\n\\t\\t\\n            // string correponding to max value of map\\n\\t\\t\\tif(it.second==maxi){\\n                s1.insert(it.first);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// last element of set\\n        return *(--s1.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085023,
                "title": "java-easy-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String,Integer> map=new HashMap();\\n        String name=senders[0];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<senders.length;i++)\\n        {\\n            String[] arr=messages[i].split(\" \");\\n            map.put(senders[i],map.getOrDefault(senders[i],0)+arr.length);\\n            if(max==map.get(senders[i]) && senders[i].compareTo(name)>=0)\\n            {\\n                name=senders[i];\\n            }\\n            else if(max<map.get(senders[i]))\\n            {\\n                max=map.get(senders[i]);\\n                name=senders[i];\\n            }\\n        }\\n        return name;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String,Integer> map=new HashMap();\\n        String name=senders[0];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<senders.length;i++)\\n        {\\n            String[] arr=messages[i].split(\" \");\\n            map.put(senders[i],map.getOrDefault(senders[i],0)+arr.length);\\n            if(max==map.get(senders[i]) && senders[i].compareTo(name)>=0)\\n            {\\n                name=senders[i];\\n            }\\n            else if(max<map.get(senders[i]))\\n            {\\n                max=map.get(senders[i]);\\n                name=senders[i];\\n            }\\n        }\\n        return name;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084626,
                "title": "python-o-n-space-and-o-n-time",
                "content": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        count_by_sender = Counter()\\n        max_messages = 0\\n        for message, sender in zip(messages, senders):\\n            word_count = len(message.split(\" \"))\\n            count_by_sender[sender] += word_count\\n            max_messages = max(max_messages, count_by_sender[sender])\\n        \\n        max_sender = None\\n        for sender in senders:\\n            if count_by_sender[sender] == max_messages and (not max_sender or sender > max_sender):\\n                max_sender = sender\\n        \\n        return max_sender\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        count_by_sender = Counter()\\n        max_messages = 0\\n        for message, sender in zip(messages, senders):\\n            word_count = len(message.split(\" \"))\\n            count_by_sender[sender] += word_count\\n            max_messages = max(max_messages, count_by_sender[sender])\\n        \\n        max_sender = None\\n        for sender in senders:\\n            if count_by_sender[sender] == max_messages and (not max_sender or sender > max_sender):\\n                max_sender = sender\\n        \\n        return max_sender\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084521,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * size of string)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        \\n        int n = messages.size();\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            string str = messages[i];\\n            \\n            string name = senders[i];\\n            \\n            int count = 0;\\n            \\n            for(int j = 0; j < str.size(); j++)\\n            {\\n                if(str[j] == \\' \\')\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n            mp[name] += count + 1;\\n        }\\n        \\n        int maxi = 0;\\n        \\n        string max_name = \"\";\\n        \\n        for(auto x : mp)\\n        {\\n            if(x.second > maxi)\\n            {\\n                maxi = x.second;\\n                \\n                max_name = x.first;\\n            }\\n            else if(x.second == maxi)\\n            {\\n                if(max_name < x.first)\\n                {\\n                    max_name = x.first;\\n                }\\n            }\\n        }\\n        \\n        return max_name;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        \\n        int n = messages.size();\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            string str = messages[i];\\n            \\n            string name = senders[i];\\n            \\n            int count = 0;\\n            \\n            for(int j = 0; j < str.size(); j++)\\n            {\\n                if(str[j] == \\' \\')\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n            mp[name] += count + 1;\\n        }\\n        \\n        int maxi = 0;\\n        \\n        string max_name = \"\";\\n        \\n        for(auto x : mp)\\n        {\\n            if(x.second > maxi)\\n            {\\n                maxi = x.second;\\n                \\n                max_name = x.first;\\n            }\\n            else if(x.second == maxi)\\n            {\\n                if(max_name < x.first)\\n                {\\n                    max_name = x.first;\\n                }\\n            }\\n        }\\n        \\n        return max_name;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084386,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d = defaultdict(list)\\n        \\n        for m, s in zip(messages, senders):\\n            d[s].append(m)\\n\\n        longest = [0, []]\\n        for s in d:\\n            l = 0\\n            for m in d[s]:\\n                l += len(m.split())\\n            if l > longest[0]:\\n                longest[0] = l\\n                longest[1] = [s]\\n            elif l == longest[0]:\\n                longest[1].append(s)\\n                    \\n        return max(longest[1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d = defaultdict(list)\\n        \\n        for m, s in zip(messages, senders):\\n            d[s].append(m)\\n\\n        longest = [0, []]\\n        for s in d:\\n            l = 0\\n            for m in d[s]:\\n                l += len(m.split())\\n            if l > longest[0]:\\n                longest[0] = l\\n                longest[1] = [s]\\n            elif l == longest[0]:\\n                longest[1].append(s)\\n                    \\n        return max(longest[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084321,
                "title": "python3-5-lines-easy-understanding",
                "content": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d = defaultdict(int)\\n        for sender, size in zip( senders, [len(message.split()) for message in messages] ):\\n            d[sender] += size\\n        max_word = max(d.values())\\n        return sorted([sender for sender, size in d.items() if size == max_word])[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d = defaultdict(int)\\n        for sender, size in zip( senders, [len(message.split()) for message in messages] ):\\n            d[sender] += size\\n        max_word = max(d.values())\\n        return sorted([sender for sender, size in d.items() if size == max_word])[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084131,
                "title": "count-spaces",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string,int> sent;\\n        int i=0;\\n        for(string msg:messages){\\n            int state = 1;\\n            int wc = 0;\\n            for (char c:msg)\\n            {\\n                if (c == \\' \\' ) state = 1;\\n                else if (state)\\n                {\\n                    state = 0;\\n                    ++wc;\\n                }\\n            }\\n            sent[senders[i]]+=wc;\\n            i++;\\n        }\\n        int max=-1;\\n        string ans=\"\";\\n        for(auto p:sent){\\n            //word with max count\\n            if(max< p.second){\\n                max=p.second;\\n                ans=p.first;\\n            }\\n            else if(max== p.second){\\n\\t\\t\\t//lexographically largest name\\n                if(ans<p.first)\\n                    ans=p.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string,int> sent;\\n        int i=0;\\n        for(string msg:messages){\\n            int state = 1;\\n            int wc = 0;\\n            for (char c:msg)\\n            {\\n                if (c == \\' \\' ) state = 1;\\n                else if (state)\\n                {\\n                    state = 0;\\n                    ++wc;\\n                }\\n            }\\n            sent[senders[i]]+=wc;\\n            i++;\\n        }\\n        int max=-1;\\n        string ans=\"\";\\n        for(auto p:sent){\\n            //word with max count\\n            if(max< p.second){\\n                max=p.second;\\n                ans=p.first;\\n            }\\n            else if(max== p.second){\\n\\t\\t\\t//lexographically largest name\\n                if(ans<p.first)\\n                    ans=p.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084128,
                "title": "python-7-liner-100-solution-simple-fast",
                "content": "```python\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        conversation=dict()\\n        for message, sender in zip(messages, senders):\\n            if sender not in conversation:\\n                conversation[sender]=0\\n            conversation[sender]+=len(message.split(\" \"))\\n        sorted_conversation = sorted(conversation.items(), key=lambda x: (x[1], x[0]), reverse=True)\\n        return sorted_conversation[0][0]\\n```\\n\\nPlease commnet below if you have any further questions and **UPVOTE** if you like it!\\nAll the solutions that I\\'ve been through is archived here: https://github.com/hyeseonko/LeetCode",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        conversation=dict()\\n        for message, sender in zip(messages, senders):\\n            if sender not in conversation:\\n                conversation[sender]=0\\n            conversation[sender]+=len(message.split(\" \"))\\n        sorted_conversation = sorted(conversation.items(), key=lambda x: (x[1], x[0]), reverse=True)\\n        return sorted_conversation[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084065,
                "title": "smooth-af-explanation-in-comments-with-clean-code-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    \\n    int solve(string &s) //this function is to count the number of spaces\\n    {\\n        s += \\' \\';\\n        int cnt =0;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==\\' \\') cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\npublic:\\n    \\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string,int> mp;\\n        for(int i=0; i<messages.size(); i++)\\n        {\\n            int words = solve(messages[i]);\\n            mp[senders[i]]+= words;\\n        }\\n        \\n        string ans;\\n        int max_words = -1;\\n        for(auto &it : mp)\\n        {\\n            if(it.second == max_words)\\n            {\\n                char temp = it.first[0];\\n                ans = (ans[0]>temp) ? ans : it.first;  //this will return the lexicographically greater string!!\\n            }\\n            \\n            else if(it.second > max_words)\\n            {\\n                ans = it.first;\\n                max_words = it.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    \\n    int solve(string &s) //this function is to count the number of spaces\\n    {\\n        s += \\' \\';\\n        int cnt =0;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==\\' \\') cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\npublic:\\n    \\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string,int> mp;\\n        for(int i=0; i<messages.size(); i++)\\n        {\\n            int words = solve(messages[i]);\\n            mp[senders[i]]+= words;\\n        }\\n        \\n        string ans;\\n        int max_words = -1;\\n        for(auto &it : mp)\\n        {\\n            if(it.second == max_words)\\n            {\\n                char temp = it.first[0];\\n                ans = (ans[0]>temp) ? ans : it.first;  //this will return the lexicographically greater string!!\\n            }\\n            \\n            else if(it.second > max_words)\\n            {\\n                ans = it.first;\\n                max_words = it.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084044,
                "title": "treemap-java-solution",
                "content": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        // retains the String order. Hence, we can find the lexicographically largest name if more than one sender with the largest word count \\n        TreeMap<String, Integer> map= new TreeMap<>();\\n        \\n        for(int i=0;i<messages.length;i++)\\n        {\\n            int c= countWords(messages[i]);\\n            map.put(senders[i],map.getOrDefault(senders[i],0)+c);\\n        }\\n        int max=0;\\n        String ans=\"\";\\n        for(String k: map.keySet())\\n        {\\n\\t\\t\\t//>= since we need to find the lexicographically largest\\n            if(map.get(k)>=max)\\n            {\\n                max=map.get(k);\\n                ans=k;\\n            }\\n        }\\n        return ans;\\n    }\\n    public int countWords(String str)\\n    {\\n\\n        if (str == null || str.isEmpty())\\n            return 0;\\n        String[] words = str.split(\"\\\\\\\\s+\");\\n        return words.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        // retains the String order. Hence, we can find the lexicographically largest name if more than one sender with the largest word count \\n        TreeMap<String, Integer> map= new TreeMap<>();\\n        \\n        for(int i=0;i<messages.length;i++)\\n        {\\n            int c= countWords(messages[i]);\\n            map.put(senders[i],map.getOrDefault(senders[i],0)+c);\\n        }\\n        int max=0;\\n        String ans=\"\";\\n        for(String k: map.keySet())\\n        {\\n\\t\\t\\t//>= since we need to find the lexicographically largest\\n            if(map.get(k)>=max)\\n            {\\n                max=map.get(k);\\n                ans=k;\\n            }\\n        }\\n        return ans;\\n    }\\n    public int countWords(String str)\\n    {\\n\\n        if (str == null || str.isEmpty())\\n            return 0;\\n        String[] words = str.split(\"\\\\\\\\s+\");\\n        return words.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083993,
                "title": "python-very-short-and-simple",
                "content": "```\\ndef largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n\\tdic = defaultdict(int)\\n\\tfor s, m in zip(senders, messages):\\n\\t\\tdic[s] += m.count(\\' \\') + 1\\n\\treturn max([(c, s) for s, c in dic.items()])[1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n\\tdic = defaultdict(int)\\n\\tfor s, m in zip(senders, messages):\\n\\t\\tdic[s] += m.count(\\' \\') + 1\\n\\treturn max([(c, s) for s, c in dic.items()])[1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2083975,
                "title": "hash-map-ordered-map-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(string s,int &cnt)\\n    {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\' \\')\\n                cnt++;\\n        }\\n        if(s!=\"\") cnt++;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string,int> mp;\\n        for(int i=0;i<messages.size();i++)\\n        {\\n            string s=senders[i];\\n            int cnt=0;\\n            helper(messages[i],cnt);\\n            mp[s]=mp[s]+cnt;\\n        }\\n        int x=0;\\n        string ans=\"\";\\n        for(auto ele: mp)\\n        {\\n            if(x<=ele.second)\\n            {\\n                x=ele.second;\\n                ans=ele.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(string s,int &cnt)\\n    {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\' \\')\\n                cnt++;\\n        }\\n        if(s!=\"\") cnt++;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string,int> mp;\\n        for(int i=0;i<messages.size();i++)\\n        {\\n            string s=senders[i];\\n            int cnt=0;\\n            helper(messages[i],cnt);\\n            mp[s]=mp[s]+cnt;\\n        }\\n        int x=0;\\n        string ans=\"\";\\n        for(auto ele: mp)\\n        {\\n            if(x<=ele.second)\\n            {\\n                x=ele.second;\\n                ans=ele.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083973,
                "title": "solution-in-python-hashmap-sorting",
                "content": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        leng = len(senders)\\n        freq = {}\\n        for i in range(leng):\\n            sender = senders[i]\\n            msg = messages[i]\\n            msg_len = len(msg.split())\\n            if sender in freq:\\n                freq[sender] += msg_len\\n            else:\\n                freq[sender] = msg_len\\n            \\n            \\n        max_sender_len = float(\\'-inf\\')\\n        max_sender_name = \\'\\'\\n        \\n        for sender in freq:\\n            if freq[sender] > max_sender_len:\\n                max_sender_len = freq[sender]\\n                max_sender_name = sender\\n            elif freq[sender] == max_sender_len:\\n                temp = sorted([sender, max_sender_name], key=str, reverse=True)\\n                max_sender_name = temp[0]\\n                \\n        return max_sender_name\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        leng = len(senders)\\n        freq = {}\\n        for i in range(leng):\\n            sender = senders[i]\\n            msg = messages[i]\\n            msg_len = len(msg.split())\\n            if sender in freq:\\n                freq[sender] += msg_len\\n            else:\\n                freq[sender] = msg_len\\n            \\n            \\n        max_sender_len = float(\\'-inf\\')\\n        max_sender_name = \\'\\'\\n        \\n        for sender in freq:\\n            if freq[sender] > max_sender_len:\\n                max_sender_len = freq[sender]\\n                max_sender_name = sender\\n            elif freq[sender] == max_sender_len:\\n                temp = sorted([sender, max_sender_name], key=str, reverse=True)\\n                max_sender_name = temp[0]\\n                \\n        return max_sender_name\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083971,
                "title": "leetcode-2284-simple-o-nlog-n-tc-o-n-sc-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int count(string &s)\\n    {   \\n        //if string is empty ,there are no words\\n        if(s.size()==0)\\n            return 0;\\n        int n=s.size();\\n        //counter to count words\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n                c++;\\n        }\\n        //count of number of words is one more than count of spaces\\n        return (c+1);\\n    }\\n    string largestWordCount(vector<string>& msg, vector<string>& s) \\n    {\\n        int n=msg.size();\\n        //since we count frequency of words by sender\\n        //we use long long to avoid overflow while counting\\n        unordered_map<string,long long>m;\\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t//we add 0LL to avoid overflow in integer by doing calculation in long long\\n            m[s[i]]=m[s[i]]+0ll+count(msg[i]);\\n        }\\n        //we first find maximum frequency of words by any sender\\n        long long maxi=0;\\n        for(auto &i:m)\\n        {\\n            if((i.second+0ll)>maxi)\\n                maxi=i.second;\\n        }\\n        //Then we find all senders with same maximum frequency and store them in vector\\n        vector<string>ans;\\n        for(auto &i:m)\\n        {\\n            if(i.second==maxi)\\n            {\\n                cout<<i.first<<\" \"<<i.second<<endl;\\n                ans.push_back(i.first);\\n            }\\n        }\\n        //we sort the answer vector to get lexicographically largest vector at end\\n        sort(ans.begin(),ans.end());\\n        return ans[ans.size()-1];\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int count(string &s)\\n    {   \\n        //if string is empty ,there are no words\\n        if(s.size()==0)\\n            return 0;\\n        int n=s.size();\\n        //counter to count words\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n                c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2083961,
                "title": "treemap-java-solution",
                "content": "```java\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < messages.length; i++) {\\n            String s = messages[i];\\n            String[] str = s.split(\" \");\\n            map.put(senders[i], map.getOrDefault(senders[i], 0) + str.length);\\n        }\\n        String ans = \"\";\\n        int max = 0;\\n        for (String key : map.keySet()) {\\n            if (map.get(key) >= max) {\\n                max = map.get(key);\\n                ans = key.compareTo(ans) >= 0 ? key : ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Tree"
                ],
                "code": "```java\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < messages.length; i++) {\\n            String s = messages[i];\\n            String[] str = s.split(\" \");\\n            map.put(senders[i], map.getOrDefault(senders[i], 0) + str.length);\\n        }\\n        String ans = \"\";\\n        int max = 0;\\n        for (String key : map.keySet()) {\\n            if (map.get(key) >= max) {\\n                max = map.get(key);\\n                ans = key.compareTo(ans) >= 0 ? key : ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083914,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& msg, vector<string>& s) {\\n        map<string,int> m;\\n        set<string> st;\\n        \\n        int n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            st.insert(s[i]);\\n            int n1=msg[i].size();\\n            int count=1;\\n            for(int j=0;j<n1;j++)\\n            {\\n                if(msg[i][j]==\\' \\') count++;\\n            }\\n            m[s[i]]+=count;\\n        }\\n        \\n        vector<string> v(st.begin(),st.end());\\n        \\n        reverse(v.begin(),v.end());\\n        \\n        n=v.size();\\n        \\n        string res=v[0];\\n        int count=m[v[0]];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(m[v[i]]>count)\\n            {\\n                res=v[i];\\n                count=m[v[i]];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& msg, vector<string>& s) {\\n        map<string,int> m;\\n        set<string> st;\\n        \\n        int n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            st.insert(s[i]);\\n            int n1=msg[i].size();\\n            int count=1;\\n            for(int j=0;j<n1;j++)\\n            {\\n                if(msg[i][j]==\\' \\') count++;\\n            }\\n            m[s[i]]+=count;\\n        }\\n        \\n        vector<string> v(st.begin(),st.end());\\n        \\n        reverse(v.begin(),v.end());\\n        \\n        n=v.size();\\n        \\n        string res=v[0];\\n        int count=m[v[0]];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(m[v[i]]>count)\\n            {\\n                res=v[i];\\n                count=m[v[i]];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083912,
                "title": "python-easy-solution-using-hashing-and-sorting",
                "content": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        mapping, res = {}, []\\n        \\n        for i, sender in enumerate(senders):\\n            if sender not in mapping:\\n                mapping[sender] = len(messages[i].split())\\n            else:\\n                mapping[sender] += len(messages[i].split())\\n                \\n        mapping = {val[0] : val[1] for val in sorted(mapping.items(), key = lambda x: (-x[1], x[0]))}\\n        max_val = max(mapping.values())\\n        \\n        for k, v in mapping.items():\\n            if v == max_val:\\n                res.append(k)\\n                \\n        if len(res) == 1:\\n            return res[0]\\n        \\n        res.sort(key = len)\\n        res.sort(key = str)\\n        \\n        return res[-1]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "class Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        mapping, res = {}",
                "codeTag": "Java"
            },
            {
                "id": 2083907,
                "title": "c-no-use-of-stringstream",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        int n = messages.size();\\n        unordered_map<string,int> mp; // count of words for each sender.\\n        \\n        int count = 0;\\n        for(int i = 0;i<n;i++){\\n            count = 0;\\n            string s = messages[i];\\n            for(int j = 0;j<s.size();j++){\\n                if(s[j] == \\' \\'){\\n                    count++;\\n                }\\n            }\\n            count++;\\n            mp[senders[i]]+= count;\\n        }\\n        vector<int> counts; // for all the counts, made extra array for (if in the case) more than one \\n        // maximums.\\n        for(auto &it : mp){\\n            counts.push_back(it.second);\\n        }\\n        int ctmax = *max_element(counts.begin(),counts.end()); \\n        vector<string> ans;\\n        for(auto &it : mp){\\n            if(it.second == ctmax)\\n                ans.push_back(it.first);\\n        }\\n        // populated ans with all the maximums.\\n        if(ans.size() == 1)\\n            return ans[0];\\n        else{\\n            return *max_element(ans.begin(),ans.end());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        int n = messages.size();\\n        unordered_map<string,int> mp; // count of words for each sender.\\n        \\n        int count = 0;\\n        for(int i = 0;i<n;i++){\\n            count = 0;\\n            string s = messages[i];\\n            for(int j = 0;j<s.size();j++){\\n                if(s[j] == \\' \\'){\\n                    count++;\\n                }\\n            }\\n            count++;\\n            mp[senders[i]]+= count;\\n        }\\n        vector<int> counts; // for all the counts, made extra array for (if in the case) more than one \\n        // maximums.\\n        for(auto &it : mp){\\n            counts.push_back(it.second);\\n        }\\n        int ctmax = *max_element(counts.begin(),counts.end()); \\n        vector<string> ans;\\n        for(auto &it : mp){\\n            if(it.second == ctmax)\\n                ans.push_back(it.first);\\n        }\\n        // populated ans with all the maximums.\\n        if(ans.size() == 1)\\n            return ans[0];\\n        else{\\n            return *max_element(ans.begin(),ans.end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083887,
                "title": "simple-c-without-stringstream",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string,int> maps;\\n        int n = messages.size();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < messages[i].length(); j++) {\\n                if(messages[i][j] == \\' \\')\\n                    maps[senders[i]]++;\\n            }\\n             maps[senders[i]]++;\\n        }\\n        int maxFqr = INT_MIN;\\n        string ans = \"\";\\n        for(auto x : maps) {\\n            // cout<<x.first<<\" \"<<x.second<<endl;\\n            if(x.second > maxFqr) {\\n                maxFqr = x.second;\\n                ans = x.first;\\n            }\\n            else if(x.second == maxFqr) {\\n                if(ans.compare(x.first) < 0)\\n                    ans = x.first;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string,int> maps;\\n        int n = messages.size();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < messages[i].length(); j++) {\\n                if(messages[i][j] == \\' \\')\\n                    maps[senders[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2083877,
                "title": "python-easy-approach",
                "content": "The pseudo code is as follows:\\n1. Find the word count tally for each sender. \\n2. Find the max word count.\\n3. Find lexicographically larger sender name if there are more than one senders with same max word count.\\n\\nMy implementation is as follows:\\n```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        counter = defaultdict(int)\\n        max_count = -math.inf\\n        res=\\'\\'\\n        # find the word count tally for each sender\\n        for message, sender in zip(messages, senders):            \\n            counter[sender]+=len(message.split(\\' \\'))\\n            \\n            if counter[sender]>=max_count:\\n                # pick lexicographically larger name in case same word count\\n                if max_count<counter[sender] or sender>res: \\n                    res=sender\\n                max_count=counter[sender]                                       \\n        \\n        return res                                             \\n```\\n**Time - O(n)**\\n**Space - O(n)** - space to store the `counter` dict\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        counter = defaultdict(int)\\n        max_count = -math.inf\\n        res=\\'\\'\\n        # find the word count tally for each sender\\n        for message, sender in zip(messages, senders):            \\n            counter[sender]+=len(message.split(\\' \\'))\\n            \\n            if counter[sender]>=max_count:\\n                # pick lexicographically larger name in case same word count\\n                if max_count<counter[sender] or sender>res: \\n                    res=sender\\n                max_count=counter[sender]                                       \\n        \\n        return res                                             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083874,
                "title": "simple-efficient-solution",
                "content": "```\\nclass Solution {\\n#define ln ListNode\\n#define tn TreeNode\\n#define endl \\'\\\\n\\'\\n    typedef long long ll;\\n    typedef vector<ll> vi;\\n    const ll mod = 1e9;\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        ll sz = m.size();\\n        unordered_map<string, ll>ump;\\n        for (ll i = 0;i < sz;++i) {\\n            string& snd = s[i];\\n            ll cnt = 1;\\n            for (char& ch : m[i])\\n                if (ch == \\' \\')\\n                    cnt++;\\n            ump[snd] += cnt;\\n        }\\n        string snd=\"\";\\n        for (auto& it : ump) {\\n            if (snd.empty() || it.second > ump[snd] || (it.second == ump[snd] && it.first > snd))\\n                snd = it.first;\\n        }\\n        return snd;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n#define ln ListNode\\n#define tn TreeNode\\n#define endl \\'\\\\n\\'\\n    typedef long long ll;\\n    typedef vector<ll> vi;\\n    const ll mod = 1e9;\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        ll sz = m.size();\\n        unordered_map<string, ll>ump;\\n        for (ll i = 0;i < sz;++i) {\\n            string& snd = s[i];\\n            ll cnt = 1;\\n            for (char& ch : m[i])\\n                if (ch == \\' \\')\\n                    cnt++;\\n            ump[snd] += cnt;\\n        }\\n        string snd=\"\";\\n        for (auto& it : ump) {\\n            if (snd.empty() || it.second > ump[snd] || (it.second == ump[snd] && it.first > snd))\\n                snd = it.first;\\n        }\\n        return snd;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083807,
                "title": "java-o-n",
                "content": "Please upvote if helpful.\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        // Count the words for every sender and return the sender with the maximum words.\\n        // Time: O(N), Space: O(N)\\n        Map<String, Integer> map = new HashMap();\\n        String ans = \"\";\\n        for (int i = 0; i < senders.length; i++) {\\n            if (!map.containsKey(senders[i])) map.put(senders[i], 0);\\n            int max = ans == \"\" ? 0 : map.get(ans);\\n            map.put(senders[i], map.get(senders[i]) + messages[i].split(\" \").length);\\n            if (map.get(senders[i]) >= max) {\\n                if (map.get(senders[i]) == max) {\\n                    ans = senders[i].compareTo(ans) < 0 ? ans : senders[i];\\n                } else {\\n                    ans = senders[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        // Count the words for every sender and return the sender with the maximum words.\\n        // Time: O(N), Space: O(N)\\n        Map<String, Integer> map = new HashMap();\\n        String ans = \"\";\\n        for (int i = 0; i < senders.length; i++) {\\n            if (!map.containsKey(senders[i])) map.put(senders[i], 0);\\n            int max = ans == \"\" ? 0 : map.get(ans);\\n            map.put(senders[i], map.get(senders[i]) + messages[i].split(\" \").length);\\n            if (map.get(senders[i]) >= max) {\\n                if (map.get(senders[i]) == max) {\\n                    ans = senders[i].compareTo(ans) < 0 ? ans : senders[i];\\n                } else {\\n                    ans = senders[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083805,
                "title": "java-short-and-sweet",
                "content": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> hm = new HashMap<>();\\n        for(int i=0; i<senders.length; i++){\\n            int len = messages[i].split(\"\\\\\\\\s+\").length;\\n            hm.put(senders[i], hm.getOrDefault(senders[i],0) + len);\\n        }\\n        \\n        List<String> al = new ArrayList<>(hm.keySet());        \\n        Collections.sort(al, (a, b) -> (hm.get(b) == hm.get(a)) ? b.compareTo(a) : (hm.get(b) - hm.get(a)));\\n        \\n        return al.get(0);\\n    }\\n}\\n```\\nTC: O(nlogn) SC: O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> hm = new HashMap<>();\\n        for(int i=0; i<senders.length; i++){\\n            int len = messages[i].split(\"\\\\\\\\s+\").length;\\n            hm.put(senders[i], hm.getOrDefault(senders[i],0) + len);\\n        }\\n        \\n        List<String> al = new ArrayList<>(hm.keySet());        \\n        Collections.sort(al, (a, b) -> (hm.get(b) == hm.get(a)) ? b.compareTo(a) : (hm.get(b) - hm.get(a)));\\n        \\n        return al.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083782,
                "title": "clean-java-priority-queue-solution",
                "content": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int max = 0;\\n        for(int i = 0; i < senders.length; i++) {\\n            int size = messages[i].split(\" \").length;\\n            map.put(senders[i], map.getOrDefault(senders[i], 0) + size);\\n            max = Math.max(max, map.get(senders[i]));\\n        }\\n        \\n        PriorityQueue<String> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(String key : map.keySet()) {\\n            if(map.get(key) == max) {\\n                pq.add(key);\\n            }\\n        }\\n        return pq.poll();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int max = 0;\\n        for(int i = 0; i < senders.length; i++) {\\n            int size = messages[i].split(\" \").length;\\n            map.put(senders[i], map.getOrDefault(senders[i], 0) + size);\\n            max = Math.max(max, map.get(senders[i]));\\n        }\\n        \\n        PriorityQueue<String> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(String key : map.keySet()) {\\n            if(map.get(key) == max) {\\n                pq.add(key);\\n            }\\n        }\\n        return pq.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083766,
                "title": "java-treemap",
                "content": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String,Integer> m=new TreeMap<>();\\n        int n=messages.length;\\n        for(int i=0;i<n;i++){\\n            String a[]=messages[i].split(\" \");\\n            if(m.containsKey(senders[i])){\\n                m.put(senders[i],m.get(senders[i])+a.length);\\n            }else{\\n                m.put(senders[i],a.length);\\n            }\\n        }\\n        \\n        int max=Collections.max(m.values());\\n        String ans=\"\";\\n        for(Map.Entry k : m.entrySet()){\\n            int x= (int)k.getValue();\\n            if(x==max){\\n                ans=String.valueOf(k.getKey());\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String,Integer> m=new TreeMap<>();\\n        int n=messages.length;\\n        for(int i=0;i<n;i++){\\n            String a[]=messages[i].split(\" \");\\n            if(m.containsKey(senders[i])){\\n                m.put(senders[i],m.get(senders[i])+a.length);\\n            }else{\\n                m.put(senders[i],a.length);\\n            }\\n        }\\n        \\n        int max=Collections.max(m.values());\\n        String ans=\"\";\\n        for(Map.Entry k : m.entrySet()){\\n            int x= (int)k.getValue();\\n            if(x==max){\\n                ans=String.valueOf(k.getKey());\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083755,
                "title": "easy-approach-hash-map-and-priority-queue",
                "content": "```cpp\\nclass Solution {\\n    \\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n\\n        int n = messages.size();\\n        unordered_map<string, int> mp; //name, cnt\\n        priority_queue<pair<int, string>> pq; //cnt, name\\n \\n        for(int i = 0; i < n; i++) {\\n            int cnt = 1;\\n            for(auto j : messages[i]) {\\n                if(j == \\' \\')\\n                    cnt++;\\n            }\\n            mp[senders[i]] += cnt;\\n            pq.push({mp[senders[i]], senders[i]});\\n        }\\n        \\n        return pq.top().second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nclass Solution {\\n    \\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n\\n        int n = messages.size();\\n        unordered_map<string, int> mp; //name, cnt\\n        priority_queue<pair<int, string>> pq; //cnt, name\\n \\n        for(int i = 0; i < n; i++) {\\n            int cnt = 1;\\n            for(auto j : messages[i]) {\\n                if(j == \\' \\')\\n                    cnt++;\\n            }\\n            mp[senders[i]] += cnt;\\n            pq.push({mp[senders[i]], senders[i]});\\n        }\\n        \\n        return pq.top().second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083753,
                "title": "c-map-sorting",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring largestWordCount(vector<string>& msg, vector<string>& senders) {\\n\\t\\t\\tunordered_map<string,int>mp;\\n\\t\\t\\tfor(int i=0;i<size(msg);i++){\\n\\t\\t\\t\\tistringstream str(msg[i]);\\n\\t\\t\\t\\tstring word;\\n\\t\\t\\t\\twhile(str>>word) mp[senders[i]]++;\\n\\t\\t\\t}\\n\\t\\t\\tvector<pair<int,string>>arr;\\n\\t\\t\\tfor(auto [first,second]:mp) arr.push_back({second,first});\\n\\t\\t\\tsort(begin(arr),end(arr),[](auto a,auto b){\\n\\t\\t\\t\\tif(a.first==b.first) return a.second>b.second;\\n\\t\\t\\t\\treturn a.first>b.first;\\n\\t\\t\\t});\\n\\t\\t\\treturn arr[0].second;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring largestWordCount(vector<string>& msg, vector<string>& senders) {\\n\\t\\t\\tunordered_map<string,int>mp;\\n\\t\\t\\tfor(int i=0;i<size(msg);i++){\\n\\t\\t\\t\\tistringstream str(msg[i]);\\n\\t\\t\\t\\tstring word;\\n\\t\\t\\t\\twhile(str>>word) mp[senders[i]]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4091884,
                "title": "easy-c-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string,int> mp;\\n        int n = messages.size();\\n        for(auto it:senders) mp.insert({it,0});\\n\\n        for(int i=0;i<n;++i){\\n            int ct = 0;\\n            for(int j=0;j<messages[i].size();++j){\\n                if(messages[i][j] == \\' \\') ct++;\\n            }\\n            mp[senders[i]] += (ct + 1);\\n        }\\n\\n        priority_queue<pair<int,string>> pq;\\n        for(auto it:mp){\\n            pq.push({it.second,it.first});\\n        }\\n\\n        while(!pq.empty()){\\n            int t = pq.top().first;\\n            string temp = pq.top().second;\\n            pq.pop();\\n            if(pq.top().first == t){\\n                if(temp < pq.top().second) return pq.top().second;\\n                else return temp;\\n            }else{\\n                return temp;\\n            }\\n        }\\n\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table",
                    "String",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string,int> mp;\\n        int n = messages.size();\\n        for(auto it:senders) mp.insert({it,0});\\n\\n        for(int i=0;i<n;++i){\\n            int ct = 0;\\n            for(int j=0;j<messages[i].size();++j){\\n                if(messages[i][j] == \\' \\') ct++;\\n            }\\n            mp[senders[i]] += (ct + 1);\\n        }\\n\\n        priority_queue<pair<int,string>> pq;\\n        for(auto it:mp){\\n            pq.push({it.second,it.first});\\n        }\\n\\n        while(!pq.empty()){\\n            int t = pq.top().first;\\n            string temp = pq.top().second;\\n            pq.pop();\\n            if(pq.top().first == t){\\n                if(temp < pq.top().second) return pq.top().second;\\n                else return temp;\\n            }else{\\n                return temp;\\n            }\\n        }\\n\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089885,
                "title": "basic-approach-easy-to-understand-java",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.HashMap;\\n\\npublic class Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n\\n        // Calculate word counts for each sender\\n        for (int i = 0; i < senders.length; i++) {\\n            if (!map.containsKey(senders[i])) {\\n                int count = wordCount(messages[i]);\\n                map.put(senders[i], count);\\n            } else {\\n                int v = map.get(senders[i]);\\n                int count = v + wordCount(messages[i]);\\n                map.put(senders[i], count);\\n            }\\n        }\\n\\n        String ans = \"\";\\n        int maxWordCount = 0;\\n\\n        // Find the sender with the largest word count\\n        for (int i = 0; i < senders.length; i++) {\\n            if (maxWordCount < map.get(senders[i])) {\\n                ans = senders[i];\\n                maxWordCount = map.get(senders[i]);\\n            } else if (maxWordCount == map.get(senders[i])) {\\n                // In case of a tie, choose the lexicographically larger sender\\n                if (senders[i].compareTo(ans) > 0) {\\n                    ans = senders[i];\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int wordCount(String str) {\\n        int count = 0;\\n        for (int i = 0; i < str.length(); i++) {\\n            if (str.charAt(i) == \\' \\') {\\n                count++;\\n            }\\n        }\\n        return count + 1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\n\\npublic class Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n\\n        // Calculate word counts for each sender\\n        for (int i = 0; i < senders.length; i++) {\\n            if (!map.containsKey(senders[i])) {\\n                int count = wordCount(messages[i]);\\n                map.put(senders[i], count);\\n            } else {\\n                int v = map.get(senders[i]);\\n                int count = v + wordCount(messages[i]);\\n                map.put(senders[i], count);\\n            }\\n        }\\n\\n        String ans = \"\";\\n        int maxWordCount = 0;\\n\\n        // Find the sender with the largest word count\\n        for (int i = 0; i < senders.length; i++) {\\n            if (maxWordCount < map.get(senders[i])) {\\n                ans = senders[i];\\n                maxWordCount = map.get(senders[i]);\\n            } else if (maxWordCount == map.get(senders[i])) {\\n                // In case of a tie, choose the lexicographically larger sender\\n                if (senders[i].compareTo(ans) > 0) {\\n                    ans = senders[i];\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int wordCount(String str) {\\n        int count = 0;\\n        for (int i = 0; i < str.length(); i++) {\\n            if (str.charAt(i) == \\' \\') {\\n                count++;\\n            }\\n        }\\n        return count + 1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068658,
                "title": "easily-understandable-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\n     int fun(String s)\\n     {\\n         String[] arr=s.split(\" \");\\n         return arr.length;\\n     }\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String,Integer> mp=new HashMap<>();\\n        for(int i=0;i<senders.length;i++)\\n        {\\n            int x=fun(messages[i]);\\n            if(mp.containsKey(senders[i]))\\n            {\\n                mp.put(senders[i],mp.get(senders[i])+x);\\n            }\\n            else\\n            {\\n                mp.put(senders[i],x);\\n            }\\n        }\\n        PriorityQueue<String> pq=new PriorityQueue<>((a,b)->{\\n            if(mp.get(a)==mp.get(b))\\n            {\\n                return b.compareTo(a);\\n            }\\n            else\\n            {\\n                return mp.get(b)-mp.get(a);\\n            }\\n        });\\n        pq.addAll(mp.keySet());\\n        return pq.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n     int fun(String s)\\n     {\\n         String[] arr=s.split(\" \");\\n         return arr.length;\\n     }\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String,Integer> mp=new HashMap<>();\\n        for(int i=0;i<senders.length;i++)\\n        {\\n            int x=fun(messages[i]);\\n            if(mp.containsKey(senders[i]))\\n            {\\n                mp.put(senders[i],mp.get(senders[i])+x);\\n            }\\n            else\\n            {\\n                mp.put(senders[i],x);\\n            }\\n        }\\n        PriorityQueue<String> pq=new PriorityQueue<>((a,b)->{\\n            if(mp.get(a)==mp.get(b))\\n            {\\n                return b.compareTo(a);\\n            }\\n            else\\n            {\\n                return mp.get(b)-mp.get(a);\\n            }\\n        });\\n        pq.addAll(mp.keySet());\\n        return pq.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015716,
                "title": "python-3-lines-beats-95-explanation",
                "content": "# Approach\\n1. Use dict to count amount of words for every sender. Amount of words in one message == count(\\' \\') + 1\\n2. Sort in reverse order list of senders with the biggest amount of words sent and return first\\n\\n# Code\\n```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d = defaultdict(int)\\n        for message, sender in zip(messages, senders): d[sender] += message.count(\\' \\') + 1\\n        return sorted([key for key, count in d.items() if count == maxim], reverse=True)[0] if (maxim:=max(d.values())) else 0\\n        \\n```\\n\\n# \\u2764\\uFE0F Plese upvote if you found it helpful \\u2764\\uFE0F",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d = defaultdict(int)\\n        for message, sender in zip(messages, senders): d[sender] += message.count(\\' \\') + 1\\n        return sorted([key for key, count in d.items() if count == maxim], reverse=True)[0] if (maxim:=max(d.values())) else 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013630,
                "title": "c-solution-with-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public string LargestWordCount(string[] messages, string[] senders) {\\n                Dictionary<string, int> messenger = new Dictionary<string, int>();\\n        int j = 0;\\n        string result = \"\";\\n        for (int i = 0; i < senders.Length; i++)\\n        {\\n            if (!(messenger.ContainsKey(senders[i])))\\n            {\\n                messenger.Add(senders[i], CountWords(messages[i]));\\n                if (messenger[senders[i]]>j)\\n                {\\n                    j=messenger[senders[i]];\\n                    result = senders[i];\\n                    \\n                }\\n                else if (messenger[senders[i]]==j)\\n                {\\n                    for (int k = 0; k <  Math.Min(result.Length, senders[i].Length); k++)\\n                    {\\n                        if (result[k] > senders[i][k])\\n                        {\\n                            break;\\n                        }\\n                        if (result[k] < senders[i][k])\\n                        {\\n                            result = senders[i];\\n                            break;\\n                        }\\n                        if (k + 1 == result.Length)\\n                        {\\n                            if (senders[i].Length > result.Length)\\n                            {\\n                                result = senders[i];\\n                                break;\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n            else\\n            {\\n                messenger[senders[i]] += CountWords(messages[i]);\\n                if (messenger[senders[i]] > j)\\n                {\\n                    j = messenger[senders[i]];\\n                    result = senders[i];\\n                }\\n                else if (messenger[senders[i]] == j)\\n                {\\n                    for (int k = 0; k < Math.Min(result.Length, senders[i].Length); k++)\\n                    {\\n                        if (result[k] > senders[i][k])\\n                        {\\n                            break;\\n                        }\\n                        if (result[k] < senders[i][k])\\n                        {\\n                            result = senders[i];\\n                            break;\\n                        }\\n                        if (k+1==result.Length)\\n                        {\\n                            if (senders[i].Length>result.Length)\\n                            {\\n                                result = senders[i];\\n                                break;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n           \\n        }\\n        return result;\\n    }\\n    public int CountWords(string message)\\n    {\\n        int count = 1;\\n\\n        for (int i = 0; i < message.Length; i++)\\n        {\\n            if (message[i]==\\' \\')\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LargestWordCount(string[] messages, string[] senders) {\\n                Dictionary<string, int> messenger = new Dictionary<string, int>();\\n        int j = 0;\\n        string result = \"\";\\n        for (int i = 0; i < senders.Length; i++)\\n        {\\n            if (!(messenger.ContainsKey(senders[i])))\\n            {\\n                messenger.Add(senders[i], CountWords(messages[i]));\\n                if (messenger[senders[i]]>j)\\n                {\\n                    j=messenger[senders[i]];\\n                    result = senders[i];\\n                    \\n                }\\n                else if (messenger[senders[i]]==j)\\n                {\\n                    for (int k = 0; k <  Math.Min(result.Length, senders[i].Length); k++)\\n                    {\\n                        if (result[k] > senders[i][k])\\n                        {\\n                            break;\\n                        }\\n                        if (result[k] < senders[i][k])\\n                        {\\n                            result = senders[i];\\n                            break;\\n                        }\\n                        if (k + 1 == result.Length)\\n                        {\\n                            if (senders[i].Length > result.Length)\\n                            {\\n                                result = senders[i];\\n                                break;\\n                            }\\n                        }\\n                    }\\n                }\\n                \\n            }\\n            else\\n            {\\n                messenger[senders[i]] += CountWords(messages[i]);\\n                if (messenger[senders[i]] > j)\\n                {\\n                    j = messenger[senders[i]];\\n                    result = senders[i];\\n                }\\n                else if (messenger[senders[i]] == j)\\n                {\\n                    for (int k = 0; k < Math.Min(result.Length, senders[i].Length); k++)\\n                    {\\n                        if (result[k] > senders[i][k])\\n                        {\\n                            break;\\n                        }\\n                        if (result[k] < senders[i][k])\\n                        {\\n                            result = senders[i];\\n                            break;\\n                        }\\n                        if (k+1==result.Length)\\n                        {\\n                            if (senders[i].Length>result.Length)\\n                            {\\n                                result = senders[i];\\n                                break;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n           \\n        }\\n        return result;\\n    }\\n    public int CountWords(string message)\\n    {\\n        int count = 1;\\n\\n        for (int i = 0; i < message.Length; i++)\\n        {\\n            if (message[i]==\\' \\')\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946053,
                "title": "easy-solution-nnn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < messages.length ; i++){\\n            int cnt = 0;\\n            for(int j = 0 ; j < messages[i].length() ;j++){\\n                if(j == 0 || (j > 0 &&  messages[i].charAt(j - 1) == \\' \\')){\\n                    cnt++;\\n                }\\n            }\\n            if(map.containsKey(senders[i])){\\n                map.put(senders[i],map.get(senders[i]) + cnt);\\n            }else{\\n                map.put(senders[i],cnt);\\n            }\\n        }\\n        int pos = -1 , max = 0;\\n        for(int i = 0; i < senders.length;i++){\\n            if(map.get(senders[i]) > max){\\n                pos = i;\\n                max = map.get(senders[i]);\\n            }else if(map.get(senders[i]) == max && sum(senders[i],senders[pos]) == 1){\\n                pos = i;\\n            }\\n        }\\n        return senders[pos];\\n    }\\n    // If there is more than one sender with the largest word count, return the one with the lexicographically largest name.\\n    public static int sum(String str1, String str2) {\\n        int minLength = Math.min(str1.length(), str2.length());\\n\\n        for (int i = 0; i < minLength; i++) {\\n            char char1 = str1.charAt(i);\\n            char char2 = str2.charAt(i);\\n\\n            if (char1 < char2) {\\n                return -1;\\n            } else if (char1 > char2) {\\n                return 1;\\n            }\\n        }\\n\\n        // N\\u1EBFu c\\xE1c k\\xFD t\\u1EF1 cho \\u0111\\u1EBFn \\u0111\\u1ED9 d\\xE0i ng\\u1EAFn nh\\u1EA5t gi\\u1ED1ng nhau\\n        if (str1.length() < str2.length()) {\\n            return -1;\\n        } else if (str1.length() > str2.length()) {\\n            return 1;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < messages.length ; i++){\\n            int cnt = 0;\\n            for(int j = 0 ; j < messages[i].length() ;j++){\\n                if(j == 0 || (j > 0 &&  messages[i].charAt(j - 1) == \\' \\')){\\n                    cnt++;\\n                }\\n            }\\n            if(map.containsKey(senders[i])){\\n                map.put(senders[i],map.get(senders[i]) + cnt);\\n            }else{\\n                map.put(senders[i],cnt);\\n            }\\n        }\\n        int pos = -1 , max = 0;\\n        for(int i = 0; i < senders.length;i++){\\n            if(map.get(senders[i]) > max){\\n                pos = i;\\n                max = map.get(senders[i]);\\n            }else if(map.get(senders[i]) == max && sum(senders[i],senders[pos]) == 1){\\n                pos = i;\\n            }\\n        }\\n        return senders[pos];\\n    }\\n    // If there is more than one sender with the largest word count, return the one with the lexicographically largest name.\\n    public static int sum(String str1, String str2) {\\n        int minLength = Math.min(str1.length(), str2.length());\\n\\n        for (int i = 0; i < minLength; i++) {\\n            char char1 = str1.charAt(i);\\n            char char2 = str2.charAt(i);\\n\\n            if (char1 < char2) {\\n                return -1;\\n            } else if (char1 > char2) {\\n                return 1;\\n            }\\n        }\\n\\n        // N\\u1EBFu c\\xE1c k\\xFD t\\u1EF1 cho \\u0111\\u1EBFn \\u0111\\u1ED9 d\\xE0i ng\\u1EAFn nh\\u1EA5t gi\\u1ED1ng nhau\\n        if (str1.length() < str2.length()) {\\n            return -1;\\n        } else if (str1.length() > str2.length()) {\\n            return 1;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942496,
                "title": "c-easy-solution-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint wordcount(string s)\\n{\\n    int res = 0;\\n    for(int i = 0; i < s.length(); i++)\\n    {\\n        if(s[i] == \\' \\')\\n        {\\n            res++;\\n        }\\n    }\\n    return ++res;\\n}\\nstring largestWordCount(vector<string>& messages, vector<string>& senders) \\n{\\n        map <string, int> mp;\\n        for(int i = 0; i < senders.size(); i++)\\n        {\\n            mp[senders[i]] += wordcount(messages[i]);\\n        }\\n\\n        int maxi = 0;\\n        string res;\\n        map <string, int> :: iterator it;\\n\\n        for(it = mp.begin(); it != mp.end(); it++)\\n        {\\n            if(it->second > maxi)\\n            {\\n                res = it->first;\\n                maxi = it->second;\\n            }\\n            else if(it->second == maxi)\\n            {\\n                if(res.compare(it->first) < 0)\\n                {\\n                    res = it->first;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint wordcount(string s)\\n{\\n    int res = 0;\\n    for(int i = 0; i < s.length(); i++)\\n    {\\n        if(s[i] == \\' \\')\\n        {\\n            res++;\\n        }\\n    }\\n    return ++res;\\n}\\nstring largestWordCount(vector<string>& messages, vector<string>& senders) \\n{\\n        map <string, int> mp;\\n        for(int i = 0; i < senders.size(); i++)\\n        {\\n            mp[senders[i]] += wordcount(messages[i]);\\n        }\\n\\n        int maxi = 0;\\n        string res;\\n        map <string, int> :: iterator it;\\n\\n        for(it = mp.begin(); it != mp.end(); it++)\\n        {\\n            if(it->second > maxi)\\n            {\\n                res = it->first;\\n                maxi = it->second;\\n            }\\n            else if(it->second == maxi)\\n            {\\n                if(res.compare(it->first) < 0)\\n                {\\n                    res = it->first;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931550,
                "title": "beginner-friendly-clear-and-easy-approach-java",
                "content": "# PLEASE UPVOTE\\n\\n\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String,Integer> map=new HashMap<String,Integer>();\\n        int max=0;\\n        int currentcount=0;\\n        String output=\"\";\\n        for(int i=0;i<messages.length;i++){\\n            currentcount=count(messages[i]);\\n            if(map.containsKey(senders[i])){\\n                map.put(senders[i],map.get(senders[i])+currentcount);\\n            }else{\\n                map.put(senders[i],currentcount);\\n            }\\n        }\\n        for(int j=0;j<messages.length;j++){\\n            if(max<map.get(senders[j])){\\n                max=map.get(senders[j]);\\n                output=senders[j];\\n            }\\n            else if(max==map.get(senders[j])){\\n               int x= output.compareTo(senders[j]);\\n               if(x<=0){\\n                   output=senders[j];\\n               }else{\\n                   output=output;\\n               }\\n            }\\n        }\\n        return output;\\n    }\\n    private int count(String s){\\n        String []words=s.split(\" \");\\n        return words.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String,Integer> map=new HashMap<String,Integer>();\\n        int max=0;\\n        int currentcount=0;\\n        String output=\"\";\\n        for(int i=0;i<messages.length;i++){\\n            currentcount=count(messages[i]);\\n            if(map.containsKey(senders[i])){\\n                map.put(senders[i],map.get(senders[i])+currentcount);\\n            }else{\\n                map.put(senders[i],currentcount);\\n            }\\n        }\\n        for(int j=0;j<messages.length;j++){\\n            if(max<map.get(senders[j])){\\n                max=map.get(senders[j]);\\n                output=senders[j];\\n            }\\n            else if(max==map.get(senders[j])){\\n               int x= output.compareTo(senders[j]);\\n               if(x<=0){\\n                   output=senders[j];\\n               }else{\\n                   output=output;\\n               }\\n            }\\n        }\\n        return output;\\n    }\\n    private int count(String s){\\n        String []words=s.split(\" \");\\n        return words.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923719,
                "title": "sender-with-largest-word-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        ArrayList<String> arr = new ArrayList<String>();\\n        HashMap<String,Integer> hs = new HashMap<String,Integer>();\\n        for(int i=0;i<senders.length;i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<messages[i].length();j++)\\n            {\\n                if(messages[i].charAt(j)==\\' \\')\\n                count++;\\n            }\\n            if(hs.containsKey(senders[i]))\\n            hs.put(senders[i],hs.get(senders[i])+(count+1));\\n            else\\n            hs.put(senders[i],hs.getOrDefault(senders[i],0)+(count+1));\\n        }\\n        String str = new String();\\n        int max = Integer.MIN_VALUE;\\n        for(Map.Entry<String,Integer> e:hs.entrySet())\\n        {\\n            max = Math.max(max,e.getValue());\\n        }\\n        for(Map.Entry<String,Integer> e:hs.entrySet())\\n        {\\n            if(e.getValue()==max)\\n            arr.add(e.getKey());\\n        }\\n        Collections.sort(arr);\\n        return arr.get(arr.size()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        ArrayList<String> arr = new ArrayList<String>();\\n        HashMap<String,Integer> hs = new HashMap<String,Integer>();\\n        for(int i=0;i<senders.length;i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<messages[i].length();j++)\\n            {\\n                if(messages[i].charAt(j)==\\' \\')\\n                count++;\\n            }\\n            if(hs.containsKey(senders[i]))\\n            hs.put(senders[i],hs.get(senders[i])+(count+1));\\n            else\\n            hs.put(senders[i],hs.getOrDefault(senders[i],0)+(count+1));\\n        }\\n        String str = new String();\\n        int max = Integer.MIN_VALUE;\\n        for(Map.Entry<String,Integer> e:hs.entrySet())\\n        {\\n            max = Math.max(max,e.getValue());\\n        }\\n        for(Map.Entry<String,Integer> e:hs.entrySet())\\n        {\\n            if(e.getValue()==max)\\n            arr.add(e.getKey());\\n        }\\n        Collections.sort(arr);\\n        return arr.get(arr.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912926,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        int arr[]= new int [messages.length];\\n        for(int i=0;i<messages.length;i++){\\n            String[]a=messages[i].split(\" \");\\n            arr[i]=a.length;\\n        }\\n        HashMap<String, Integer>mp= new HashMap<>();\\n        for (int i=0 ;i<senders.length;i++){\\n            if(mp.containsKey(senders[i])){\\n                mp.put(senders[i],mp.get(senders[i])+arr[i]);\\n            }\\n            else {\\n                mp.put(senders[i],arr[i]);\\n            }\\n        }\\n        int max =-1;\\n        String ans=\"\";\\n        for (String val : mp.keySet()){\\n            if (mp.get(val)>max){\\n                max = mp.get(val);\\n                ans= val;\\n            }\\n            else if(mp.get(val)==max){\\n              if(ans.compareTo(val) < 0) {\\n                  ans=val;\\n              }\\n               \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        int arr[]= new int [messages.length];\\n        for(int i=0;i<messages.length;i++){\\n            String[]a=messages[i].split(\" \");\\n            arr[i]=a.length;\\n        }\\n        HashMap<String, Integer>mp= new HashMap<>();\\n        for (int i=0 ;i<senders.length;i++){\\n            if(mp.containsKey(senders[i])){\\n                mp.put(senders[i],mp.get(senders[i])+arr[i]);\\n            }\\n            else {\\n                mp.put(senders[i],arr[i]);\\n            }\\n        }\\n        int max =-1;\\n        String ans=\"\";\\n        for (String val : mp.keySet()){\\n            if (mp.get(val)>max){\\n                max = mp.get(val);\\n                ans= val;\\n            }\\n            else if(mp.get(val)==max){\\n              if(ans.compareTo(val) < 0) {\\n                  ans=val;\\n              }\\n               \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909858,
                "title": "same-as-leetcode-692",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) { \\n       \\n        HashMap<String,Integer> hm = new HashMap<>();\\n\\n        for(int i = 0 ; i<senders.length ; i++ ){\\n             String[] words = messages[i].split(\" \");\\n             int len = words.length;\\n            hm.put(senders[i] , hm.getOrDefault(senders[i] ,0)+len);\\n        }\\n        class customsort implements Comparator<String>{\\n         public int compare(String s1,String s2){\\n             if(hm.get(s2)==hm.get(s1)) return s2.compareTo(s1); \\n             else  {return hm.get(s2)-hm.get(s1) ;}\\n         }\\n     }\\n     Queue<String> pq= new PriorityQueue<>(new customsort());\\n     for(Map.Entry<String ,Integer> entry : hm.entrySet()){\\n         pq.add(entry.getKey());\\n       \\n     }\\n     \\n     String ans = pq.poll();\\n         return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) { \\n       \\n        HashMap<String,Integer> hm = new HashMap<>();\\n\\n        for(int i = 0 ; i<senders.length ; i++ ){\\n             String[] words = messages[i].split(\" \");\\n             int len = words.length;\\n            hm.put(senders[i] , hm.getOrDefault(senders[i] ,0)+len);\\n        }\\n        class customsort implements Comparator<String>{\\n         public int compare(String s1,String s2){\\n             if(hm.get(s2)==hm.get(s1)) return s2.compareTo(s1); \\n             else  {return hm.get(s2)-hm.get(s1) ;}\\n         }\\n     }\\n     Queue<String> pq= new PriorityQueue<>(new customsort());\\n     for(Map.Entry<String ,Integer> entry : hm.entrySet()){\\n         pq.add(entry.getKey());\\n       \\n     }\\n     \\n     String ans = pq.poll();\\n         return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868291,
                "title": "swift-easy-solution-100-beat-in-time-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func largestWordCount(_ messages: [String], _ senders: [String]) -> String {\\n    \\n        var dict = [String: Int]()\\n        \\n        for (i,val) in senders.enumerated() {\\n            dict[val,default: 0] += messages[i].components(separatedBy: \" \").count\\n        }\\n        \\n        var arr = dict.sorted(by: {$0.value > $1.value})\\n        var newArr = arr.filter({$0.value == arr.first?.value})\\n        newArr.sort(by: {$0.key > $1.key})\\n        \\n        return newArr.first?.key ?? \"\"\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestWordCount(_ messages: [String], _ senders: [String]) -> String {\\n    \\n        var dict = [String: Int]()\\n        \\n        for (i,val) in senders.enumerated() {\\n            dict[val,default: 0] += messages[i].components(separatedBy: \" \").count\\n        }\\n        \\n        var arr = dict.sorted(by: {$0.value > $1.value})\\n        var newArr = arr.filter({$0.value == arr.first?.value})\\n        newArr.sort(by: {$0.key > $1.key})\\n        \\n        return newArr.first?.key ?? \"\"\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847967,
                "title": "simple-python3-solution-upto-98-faster",
                "content": "![image.png](https://assets.leetcode.com/users/images/1f1184a9-8a14-4d6d-b59a-3f9090afb949_1690893148.8542502.png)\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        word_name_dict = defaultdict(int)\\n        m = 0\\n        for sent, name in zip(messages,senders):\\n            c = len(sent.split(\" \"))\\n\\n            word_name_dict[name] += c\\n\\n            if m < word_name_dict[name]:\\n                m = word_name_dict[name]\\n\\n        res = \"\"\\n        for name,v in word_name_dict.items():\\n            if v == m:\\n                if res < name:\\n                    res = name\\n        \\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        word_name_dict = defaultdict(int)\\n        m = 0\\n        for sent, name in zip(messages,senders):\\n            c = len(sent.split(\" \"))\\n\\n            word_name_dict[name] += c\\n\\n            if m < word_name_dict[name]:\\n                m = word_name_dict[name]\\n\\n        res = \"\"\\n        for name,v in word_name_dict.items():\\n            if v == m:\\n                if res < name:\\n                    res = name\\n        \\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835645,
                "title": "python-4-liner-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        sdict = defaultdict(int)\\n        for x, y in zip(senders, messages):\\n            sdict[x] += len(y.split(\\' \\'))\\n        return max(sdict.items(), key=lambda x: (x[1], x[0]))[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        sdict = defaultdict(int)\\n        for x, y in zip(senders, messages):\\n            sdict[x] += len(y.split(\\' \\'))\\n        return max(sdict.items(), key=lambda x: (x[1], x[0]))[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827847,
                "title": "easy-python-solution-with-explanation-beats-100-in-python",
                "content": "# Approach\\nThe code uses a defaultdict to store the total length of messages for each sender. It does this by iterating through the \"senders\" and \"messages\" lists together using the zip function.\\nThe length of each message is calculated by splitting the message string using the space character and finding the length of the resulting list of words. The length is then added to the corresponding sender\\'s total message length in the defaultdict.\\nThe code then iterates through the defaultdict again to find the maximum message length.\\nIt stores the sender(s) with the maximum message length in a list called \"l.\"\\nFinally, it returns the sender with the maximum message length from the sorted list \"l.\"\\n\\n# Complexity\\n- Time complexity:O(n+m log m)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d=defaultdict(int)\\n        for i,j in zip(senders,messages):\\n            d[i]+=len(j.split(\\' \\'))\\n        #print(d)\\n        w=0\\n        for i in d:\\n            if d[i]>w:\\n                w=d[i]\\n        l=[]\\n        for i in d:\\n            if d[i]==w:\\n                l.append(i)\\n        return sorted(l)[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d=defaultdict(int)\\n        for i,j in zip(senders,messages):\\n            d[i]+=len(j.split(\\' \\'))\\n        #print(d)\\n        w=0\\n        for i in d:\\n            if d[i]>w:\\n                w=d[i]\\n        l=[]\\n        for i in d:\\n            if d[i]==w:\\n                l.append(i)\\n        return sorted(l)[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820789,
                "title": "solution-using-hashmap-dictionary",
                "content": "# Intuition\\nStore tha count in a dictionary and finally compare all the senders with count equal to the maximum value and return the highest one\\n\\n# Approach\\nCreate a dictionary and loop through the senders and store the count of the words in it.then loop again to find the maximum lexicographically.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d={}\\n        for i in range(len(senders)):\\n            d[senders[i]]=d.get(senders[i],0)+len(messages[i].split())\\n        a=max(d.values())\\n        res=[]\\n        m=\"\"\\n        for i in d:\\n            if d[i]==a:\\n                if i>m:\\n                    m=i\\n        return m\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        d={}\\n        for i in range(len(senders)):\\n            d[senders[i]]=d.get(senders[i],0)+len(messages[i].split())\\n        a=max(d.values())\\n        res=[]\\n        m=\"\"\\n        for i in d:\\n            if d[i]==a:\\n                if i>m:\\n                    m=i\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804918,
                "title": "java-easy-to-understand-solution-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> ans = new TreeMap<>(); // Using treemap for its Default Natural Sorting Order to tackle Lexicography.\\n\\t\\tList<String> res = new ArrayList<>(); \\n\\t\\tint n = messages.length;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (ans.containsKey(senders[i])) {\\n\\t\\t\\t\\tint sum = ans.get(senders[i]) + messages[i].split(\" \").length; // When the sender is already present add the subsequent message word lengths to current word length.\\n\\t\\t\\t\\tans.put(senders[i], sum);\\n\\t\\t\\t} else\\n\\t\\t\\t\\tans.put(senders[i], messages[i].split(\" \").length);\\n\\t\\t}\\n\\t\\tint max = 0;\\n\\t\\tfor (int i : ans.values()) {\\n\\t\\t\\tif (max < i)\\n\\t\\t\\t\\tmax = i; // Find the longest message value. \\n\\t\\t}\\n\\t\\tfor (String s : ans.keySet()) {\\n\\t\\t\\tif (ans.get(s) == max)\\n\\t\\t\\t\\tres.add(s); // Take all the Lexicographically ordered string in a list without disturbing the order.\\n\\t\\t}\\n\\t\\treturn res.get(res.size() - 1); // Always the last string would be the Lexicographically longest.\\n    }\\n}\\n```\\n\\nPlease upvote if you like this solution. Thanks.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> ans = new TreeMap<>(); // Using treemap for its Default Natural Sorting Order to tackle Lexicography.\\n\\t\\tList<String> res = new ArrayList<>(); \\n\\t\\tint n = messages.length;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (ans.containsKey(senders[i])) {\\n\\t\\t\\t\\tint sum = ans.get(senders[i]) + messages[i].split(\" \").length; // When the sender is already present add the subsequent message word lengths to current word length.\\n\\t\\t\\t\\tans.put(senders[i], sum);\\n\\t\\t\\t} else\\n\\t\\t\\t\\tans.put(senders[i], messages[i].split(\" \").length);\\n\\t\\t}\\n\\t\\tint max = 0;\\n\\t\\tfor (int i : ans.values()) {\\n\\t\\t\\tif (max < i)\\n\\t\\t\\t\\tmax = i; // Find the longest message value. \\n\\t\\t}\\n\\t\\tfor (String s : ans.keySet()) {\\n\\t\\t\\tif (ans.get(s) == max)\\n\\t\\t\\t\\tres.add(s); // Take all the Lexicographically ordered string in a list without disturbing the order.\\n\\t\\t}\\n\\t\\treturn res.get(res.size() - 1); // Always the last string would be the Lexicographically longest.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798346,
                "title": "defaultdict-and-max",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        counts = defaultdict(int)\\n        for i, sender in enumerate(senders):\\n            counts[sender] += len(messages[i].split())\\n        return max(counts.items(), key=lambda x: (x[1], x[0]))[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        counts = defaultdict(int)\\n        for i, sender in enumerate(senders):\\n            counts[sender] += len(messages[i].split())\\n        return max(counts.items(), key=lambda x: (x[1], x[0]))[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789842,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        \\n        \\n        Map<String, Integer> map = new TreeMap<>();\\n        for (int i = 0; i< messages.length; i++) {\\n\\n            String key = senders[i];\\n            String[] vArr = messages[i].split(\" \");\\n            Integer v = map.getOrDefault(key, 0) + vArr.length;\\n            map.put(key, v);\\n        }\\n        \\n        String result = senders[0];\\n        int count = map.values().stream().mapToInt(i->i).max().orElse(0);\\n\\n        Set<String> set = new TreeSet<>((s1, s2) -> (s2.compareTo(s1)));\\n        for (Map.Entry<String, Integer> kv : map.entrySet()) {\\n            if (count == kv.getValue()) {\\n                set.add(kv.getKey());\\n            }\\n        }\\n\\n        return set.stream()\\n            .sorted( (s1, s2) -> (s2.compareTo(s1)) )\\n            .findFirst().orElse(\"\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        \\n        \\n        Map<String, Integer> map = new TreeMap<>();\\n        for (int i = 0; i< messages.length; i++) {\\n\\n            String key = senders[i];\\n            String[] vArr = messages[i].split(\" \");\\n            Integer v = map.getOrDefault(key, 0) + vArr.length;\\n            map.put(key, v);\\n        }\\n        \\n        String result = senders[0];\\n        int count = map.values().stream().mapToInt(i->i).max().orElse(0);\\n\\n        Set<String> set = new TreeSet<>((s1, s2) -> (s2.compareTo(s1)));\\n        for (Map.Entry<String, Integer> kv : map.entrySet()) {\\n            if (count == kv.getValue()) {\\n                set.add(kv.getKey());\\n            }\\n        }\\n\\n        return set.stream()\\n            .sorted( (s1, s2) -> (s2.compareTo(s1)) )\\n            .findFirst().orElse(\"\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789563,
                "title": "easy-priority-queue-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nstatic bool cmp(pair<string,int> &a,pair<string,int> &b){\\n        if(a.second==b.second) return a.first<b.first;\\n\\n        return a.second>b.second;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string,int> mp;\\n\\n        for(int i=0;i<messages.size();i++){\\n            mp[senders[i]]+=count(messages[i].begin(),messages[i].end(),\\' \\')+1;\\n        }\\n\\n        priority_queue<pair<int,string>> q;\\n\\n        for(auto x:mp){\\n            q.push({x.second,x.first});\\n        }\\n        \\n\\n        return q.top().second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstatic bool cmp(pair<string,int> &a,pair<string,int> &b){\\n        if(a.second==b.second) return a.first<b.first;\\n\\n        return a.second>b.second;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string,int> mp;\\n\\n        for(int i=0;i<messages.size();i++){\\n            mp[senders[i]]+=count(messages[i].begin(),messages[i].end(),\\' \\')+1;\\n        }\\n\\n        priority_queue<pair<int,string>> q;\\n\\n        for(auto x:mp){\\n            q.push({x.second,x.first});\\n        }\\n        \\n\\n        return q.top().second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788274,
                "title": "using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n\\n        HashMap<String ,Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<messages.length; i++)\\n        {\\n            String s = messages[i];\\n            String st[] = s.split(\" \");\\n            int count = 0;\\n            for(int j=0; j<st.length; j++)\\n            {\\n                if(st[j]!=\" \")\\n                {\\n                    count++;\\n                }\\n            }\\n\\n            map.put(senders[i], map.getOrDefault(senders[i],0)+count);\\n\\n        }\\n\\n        int maxsum = Integer.MIN_VALUE;\\n        String ans =\"\";\\n\\n        for(Map.Entry<String, Integer> entry: map.entrySet())\\n        {\\n            if(entry.getValue()>maxsum)\\n            {\\n                maxsum = entry.getValue();\\n                ans = entry.getKey();\\n\\n            }\\n\\n            else if(entry.getValue()==maxsum)\\n            {\\n                maxsum = entry.getValue();\\n                String s1 = ans;\\n                String s2 = entry.getKey();\\n                if(s1.compareTo(s2)>0)\\n                {\\n                    ans = s1;\\n                }\\n                else if(s1.compareTo(s2)<0)\\n                {\\n                    ans = s2;\\n                }\\n\\n            }\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n\\n        HashMap<String ,Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<messages.length; i++)\\n        {\\n            String s = messages[i];\\n            String st[] = s.split(\" \");\\n            int count = 0;\\n            for(int j=0; j<st.length; j++)\\n            {\\n                if(st[j]!=\" \")\\n                {\\n                    count++;\\n                }\\n            }\\n\\n            map.put(senders[i], map.getOrDefault(senders[i],0)+count);\\n\\n        }\\n\\n        int maxsum = Integer.MIN_VALUE;\\n        String ans =\"\";\\n\\n        for(Map.Entry<String, Integer> entry: map.entrySet())\\n        {\\n            if(entry.getValue()>maxsum)\\n            {\\n                maxsum = entry.getValue();\\n                ans = entry.getKey();\\n\\n            }\\n\\n            else if(entry.getValue()==maxsum)\\n            {\\n                maxsum = entry.getValue();\\n                String s1 = ans;\\n                String s2 = entry.getKey();\\n                if(s1.compareTo(s2)>0)\\n                {\\n                    ans = s1;\\n                }\\n                else if(s1.compareTo(s2)<0)\\n                {\\n                    ans = s2;\\n                }\\n\\n            }\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779830,
                "title": "easy-o-n",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        peopleToNum = defaultdict(int)\\n        maxPerson = None\\n        maxMessages = 0\\n        for i, message in enumerate(messages):\\n            sender = senders[i]\\n            numWords = len(message.split(\" \"))\\n            peopleToNum[sender] += numWords\\n            if peopleToNum[sender] == maxMessages:\\n                maxPerson = max(maxPerson, sender)\\n            elif peopleToNum[sender] > maxMessages:\\n                maxPerson = sender\\n                maxMessages = peopleToNum[sender]\\n            else:\\n                continue\\n        return maxPerson\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        peopleToNum = defaultdict(int)\\n        maxPerson = None\\n        maxMessages = 0\\n        for i, message in enumerate(messages):\\n            sender = senders[i]\\n            numWords = len(message.split(\" \"))\\n            peopleToNum[sender] += numWords\\n            if peopleToNum[sender] == maxMessages:\\n                maxPerson = max(maxPerson, sender)\\n            elif peopleToNum[sender] > maxMessages:\\n                maxPerson = sender\\n                maxMessages = peopleToNum[sender]\\n            else:\\n                continue\\n        return maxPerson\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776600,
                "title": "5-lines-of-code-simple-easy-python-3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        a = sorted(list(zip(senders,messages)), key=lambda x: x[0], reverse=True)\\n        d = defaultdict(int)\\n        for i in range(len(a)):\\n            d[a[i][0]] += len(a[i][1].split(\\' \\'))\\n        return heapq.nlargest(1,a,key=lambda x: d[x[0]])[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        a = sorted(list(zip(senders,messages)), key=lambda x: x[0], reverse=True)\\n        d = defaultdict(int)\\n        for i in range(len(a)):\\n            d[a[i][0]] += len(a[i][1].split(\\' \\'))\\n        return heapq.nlargest(1,a,key=lambda x: d[x[0]])[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763338,
                "title": "java-with-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> senderMessages = new HashMap<>();\\n        int mostWords = 0;\\n        String mostTalkativeSender = null;\\n        for (int i = 0; i < messages.length; i++) {\\n            int words = messages[i].split(\" \").length;\\n            String sender = senders[i];\\n            senderMessages.merge(sender, words, Integer::sum);\\n            Integer senderTotalWords = senderMessages.get(sender);\\n            if (senderTotalWords > mostWords) {\\n                mostWords = senderTotalWords;\\n                mostTalkativeSender = sender;\\n            } else if (senderTotalWords == mostWords) {\\n                mostTalkativeSender = mostTalkativeSender.compareTo(sender) > 0 ? mostTalkativeSender : sender;\\n            }\\n        }\\n        return mostTalkativeSender;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        Map<String, Integer> senderMessages = new HashMap<>();\\n        int mostWords = 0;\\n        String mostTalkativeSender = null;\\n        for (int i = 0; i < messages.length; i++) {\\n            int words = messages[i].split(\" \").length;\\n            String sender = senders[i];\\n            senderMessages.merge(sender, words, Integer::sum);\\n            Integer senderTotalWords = senderMessages.get(sender);\\n            if (senderTotalWords > mostWords) {\\n                mostWords = senderTotalWords;\\n                mostTalkativeSender = sender;\\n            } else if (senderTotalWords == mostWords) {\\n                mostTalkativeSender = mostTalkativeSender.compareTo(sender) > 0 ? mostTalkativeSender : sender;\\n            }\\n        }\\n        return mostTalkativeSender;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759202,
                "title": "cpp-easy-implementation-clean-code",
                "content": "\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wordcont(string w){\\n        string word;\\n        int count=0;\\n        stringstream iss(w);\\n        while(1){\\n            if(iss>>word)count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string,int,greater<string>>m;\\n        int n=senders.size();\\n        for(int i=0;i<n;i++){\\n            m[senders[i]]=0;\\n        }\\n        for(int i=0;i<n;i++){\\n            m[senders[i]]+=wordcont(messages[i]);\\n        }\\n            string str=\"\";\\n            int mx=INT_MIN;\\n            for(auto e:m){\\n                if(e.second>mx){\\n                    str=e.first;\\n                    mx=max(mx,e.second);\\n                }\\n            }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordcont(string w){\\n        string word;\\n        int count=0;\\n        stringstream iss(w);\\n        while(1){\\n            if(iss>>word)count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string,int,greater<string>>m;\\n        int n=senders.size();\\n        for(int i=0;i<n;i++){\\n            m[senders[i]]=0;\\n        }\\n        for(int i=0;i<n;i++){\\n            m[senders[i]]+=wordcont(messages[i]);\\n        }\\n            string str=\"\";\\n            int mx=INT_MIN;\\n            for(auto e:m){\\n                if(e.second>mx){\\n                    str=e.first;\\n                    mx=max(mx,e.second);\\n                }\\n            }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709057,
                "title": "c-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public string LargestWordCount(string[] messages, string[] senders) {\\n        var map = new Dictionary<string, int>();\\n        for(int idx = 0; idx < messages.Length; idx++) {\\n            if(!map.ContainsKey(senders[idx]))\\n                map[senders[idx]] = 0;\\n            \\n            map[senders[idx]] += messages[idx].Split(\\' \\').Length;\\n        }\\n\\n         return map.OrderByDescending(m => m.Value)\\n                    .ThenByDescending(m => m.Key, StringComparer.Ordinal)\\n                    .First()\\n                    .Key;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public string LargestWordCount(string[] messages, string[] senders) {\\n        var map = new Dictionary<string, int>();\\n        for(int idx = 0; idx < messages.Length; idx++) {\\n            if(!map.ContainsKey(senders[idx]))\\n                map[senders[idx]] = 0;\\n            \\n            map[senders[idx]] += messages[idx].Split(\\' \\').Length;\\n        }\\n\\n         return map.OrderByDescending(m => m.Value)\\n                    .ThenByDescending(m => m.Key, StringComparer.Ordinal)\\n                    .First()\\n                    .Key;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698289,
                "title": "c-map-stringstream-comparator-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<string,int>& a, pair<string,int>& b) {\\n        if (a.second == b.second) {\\n            return a.first > b.first;\\n        } else {\\n            return a.second > b.second;\\n        }\\n    }\\n\\n    int wordscount(string s) {\\n        int count = 0;\\n        string temp = \"\";\\n        stringstream ss(s);\\n        while(ss >> s) {\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        vector<int> count;\\n        for (int i = 0; i < messages.size(); i++) {\\n            int temp = wordscount(messages[i]);\\n            count.push_back(temp);\\n        }\\n\\n        unordered_map<string, int> mp;\\n        for (int i = 0; i < senders.size(); i++) {\\n            mp[senders[i]] += count[i];\\n        }\\n\\n        vector<pair<string, int>> nums;\\n        for (auto it = mp.begin(); it != mp.end(); it++) {\\n            nums.push_back({it->first, it->second});\\n        }\\n\\n        sort(nums.begin(), nums.end(), cmp);\\n        return nums[0].first;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<string,int>& a, pair<string,int>& b) {\\n        if (a.second == b.second) {\\n            return a.first > b.first;\\n        } else {\\n            return a.second > b.second;\\n        }\\n    }\\n\\n    int wordscount(string s) {\\n        int count = 0;\\n        string temp = \"\";\\n        stringstream ss(s);\\n        while(ss >> s) {\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        vector<int> count;\\n        for (int i = 0; i < messages.size(); i++) {\\n            int temp = wordscount(messages[i]);\\n            count.push_back(temp);\\n        }\\n\\n        unordered_map<string, int> mp;\\n        for (int i = 0; i < senders.size(); i++) {\\n            mp[senders[i]] += count[i];\\n        }\\n\\n        vector<pair<string, int>> nums;\\n        for (auto it = mp.begin(); it != mp.end(); it++) {\\n            nums.push_back({it->first, it->second});\\n        }\\n\\n        sort(nums.begin(), nums.end(), cmp);\\n        return nums[0].first;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648266,
                "title": "simple-c-solution-using-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        string res=\"\";\\n        map<string,int> mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]=0;\\n        }\\n        for(int i=0;i<m.size();i++){\\n            int cnt=1;\\n            for(int j=0;j<m[i].length();j++){\\n                if(m[i][j]==\\' \\'){\\n                    cnt++;\\n                }\\n            }\\n            mp[s[i]]+=cnt;\\n           \\n        }\\n        int maxi=0;\\n        for(auto it :mp){\\n            if(it.second>maxi){\\n                maxi=it.second;\\n                res=it.first;\\n            }\\n            else if(it.second==maxi){\\n                res=res>it.first?res:it.first;\\n            }\\n        }\\n       return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        string res=\"\";\\n        map<string,int> mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]=0;\\n        }\\n        for(int i=0;i<m.size();i++){\\n            int cnt=1;\\n            for(int j=0;j<m[i].length();j++){\\n                if(m[i][j]==\\' \\'){\\n                    cnt++;\\n                }\\n            }\\n            mp[s[i]]+=cnt;\\n           \\n        }\\n        int maxi=0;\\n        for(auto it :mp){\\n            if(it.second>maxi){\\n                maxi=it.second;\\n                res=it.first;\\n            }\\n            else if(it.second==maxi){\\n                res=res>it.first?res:it.first;\\n            }\\n        }\\n       return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587093,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) \\n    {\\n        //to use min priority queue you would need to write\\n        //priority_queue<pair<int,string>,vector<pair<int,string>>,greater<pair<int,string>>>\\n        unordered_map<string,int> freq;\\n        pair<int,string> ans;\\n\\n        for(int i=0;i<messages.size();i++)\\n        {\\n            freq[senders[i]]+=count(messages[i].begin(),messages[i].end(),\\' \\')+1;\\n            \\n            if((freq[senders[i]]>ans.first) || (freq[senders[i]]==ans.first && senders[i]>ans.second))\\n            {\\n                ans={freq[senders[i]],senders[i]};\\n            }\\n        } \\n\\n        return ans.second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) \\n    {\\n        //to use min priority queue you would need to write\\n        //priority_queue<pair<int,string>,vector<pair<int,string>>,greater<pair<int,string>>>\\n        unordered_map<string,int> freq;\\n        pair<int,string> ans;\\n\\n        for(int i=0;i<messages.size();i++)\\n        {\\n            freq[senders[i]]+=count(messages[i].begin(),messages[i].end(),\\' \\')+1;\\n            \\n            if((freq[senders[i]]>ans.first) || (freq[senders[i]]==ans.first && senders[i]>ans.second))\\n            {\\n                ans={freq[senders[i]],senders[i]};\\n            }\\n        } \\n\\n        return ans.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582736,
                "title": "c-easy-solution-hashmap",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string, int> m;\\n        for(int i = 0; i<messages.size(); ++i){\\n            int words = count(begin(messages[i]), end(messages[i]), \\' \\')+1;\\n            m[senders[i]]+=words;\\n        }\\n        string ans;\\n        int temp=0;\\n        for(auto it:m){\\n            if(it.second >= temp){\\n                ans=it.first;\\n                temp=it.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string, int> m;\\n        for(int i = 0; i<messages.size(); ++i){\\n            int words = count(begin(messages[i]), end(messages[i]), \\' \\')+1;\\n            m[senders[i]]+=words;\\n        }\\n        string ans;\\n        int temp=0;\\n        for(auto it:m){\\n            if(it.second >= temp){\\n                ans=it.first;\\n                temp=it.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558888,
                "title": "easy-c-solution-using-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string,int> mp;\\n        int n = messages.size();\\n        for(int i=0;i<n;i++){\\n            string sender_name = senders[i];\\n            // using stringstream to break the sentence into words\\n            istringstream ss(messages[i]);\\n            string word;\\n            int cnt=0;\\n            while(ss>>word){\\n                cnt++;\\n            }\\n            // adding the words in message sent by sender\\n            mp[sender_name]+=cnt;\\n        }\\n        // storing sender_name and word count \\n        vector<pair<string,int>> vp;\\n        for(auto it:mp){\\n            vp.push_back({it.first,it.second});\\n        }\\n        // sorting the vector according to the required condition\\n        sort(vp.begin(),vp.end(),[&](pair<string,int>&a,pair<string,int>&b)->bool{\\n            // if word count is same then lexicographically largest name will be considered\\n            if(a.second==b.second){\\n                return a.first>b.first;\\n            }\\n            // when word is different consider largest count sender\\n            return a.second>b.second;\\n        });\\n        // first will be answer because we are sorting in decreasing order\\n        return vp[0].first;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string,int> mp;\\n        int n = messages.size();\\n        for(int i=0;i<n;i++){\\n            string sender_name = senders[i];\\n            // using stringstream to break the sentence into words\\n            istringstream ss(messages[i]);\\n            string word;\\n            int cnt=0;\\n            while(ss>>word){\\n                cnt++;\\n            }\\n            // adding the words in message sent by sender\\n            mp[sender_name]+=cnt;\\n        }\\n        // storing sender_name and word count \\n        vector<pair<string,int>> vp;\\n        for(auto it:mp){\\n            vp.push_back({it.first,it.second});\\n        }\\n        // sorting the vector according to the required condition\\n        sort(vp.begin(),vp.end(),[&](pair<string,int>&a,pair<string,int>&b)->bool{\\n            // if word count is same then lexicographically largest name will be considered\\n            if(a.second==b.second){\\n                return a.first>b.first;\\n            }\\n            // when word is different consider largest count sender\\n            return a.second>b.second;\\n        });\\n        // first will be answer because we are sorting in decreasing order\\n        return vp[0].first;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558047,
                "title": "python-easy-to-understand-dictionary-hash-map",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        dic={}\\n        for i in range(len(messages)):\\n            messages[i]=len(messages[i].rsplit())\\n        for j in range(len(senders)):\\n            if senders[j] in dic:\\n                dic[senders[j]]+=messages[j]\\n            else:\\n                dic[senders[j]]=messages[j]\\n        maxVal=0\\n        for i in dic:\\n            if dic[i]>=maxVal:\\n                if dic[i]==maxVal:\\n                    sender.append(i)\\n                else:\\n                    maxVal=dic[i]\\n                    sender=[i]\\n        return(max(sender))\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        dic={}\\n        for i in range(len(messages)):\\n            messages[i]=len(messages[i].rsplit())\\n        for j in range(len(senders)):\\n            if senders[j] in dic:\\n                dic[senders[j]]+=messages[j]\\n            else:\\n                dic[senders[j]]=messages[j]\\n        maxVal=0\\n        for i in dic:\\n            if dic[i]>=maxVal:\\n                if dic[i]==maxVal:\\n                    sender.append(i)\\n                else:\\n                    maxVal=dic[i]\\n                    sender=[i]\\n        return(max(sender))\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553342,
                "title": "very-easy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n         map<string,int>mp;\\n        for(int i=0;i<messages.size();i++){\\n            string s=messages[i];\\n            int j=0,len=1;;\\n            while(j<s.size()){\\n                if(s[j]==\\' \\'){\\n                    len++;\\n                }\\n                j++;\\n            }\\n            mp[senders[i]]+=len;\\n            len=1;\\n        }\\n        string ans=\"\";\\n        int maxi=0;\\n        for(auto it:mp){\\n            if(it.second>=maxi){\\n                ans=it.first;\\n                maxi=it.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n         map<string,int>mp;\\n        for(int i=0;i<messages.size();i++){\\n            string s=messages[i];\\n            int j=0,len=1;;\\n            while(j<s.size()){\\n                if(s[j]==\\' \\'){\\n                    len++;\\n                }\\n                j++;\\n            }\\n            mp[senders[i]]+=len;\\n            len=1;\\n        }\\n        string ans=\"\";\\n        int maxi=0;\\n        for(auto it:mp){\\n            if(it.second>=maxi){\\n                ans=it.first;\\n                maxi=it.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553168,
                "title": "easy-best-solution-in-c",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n## PLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int countWords(string str){\\n        int n = str.size(),count = 1;\\n        for(int i=0; i<n ; i++){\\n            if(str[i] == \\' \\')\\n                count++;\\n        }\\n        return count;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        int m = messages.size(), maxi = 0;\\n        string ans = \"\";\\n        map<string,int> mp;\\n        for(int i=0; i<m ; i++)\\n            mp[senders[i]] += countWords(messages[i]); \\n        for(auto it:mp){\\n            if(it.second >= maxi){\\n                ans = it.first;\\n                maxi = it.second;\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countWords(string str){\\n        int n = str.size(),count = 1;\\n        for(int i=0; i<n ; i++){\\n            if(str[i] == \\' \\')\\n                count++;\\n        }\\n        return count;\\n    }\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        int m = messages.size(), maxi = 0;\\n        string ans = \"\";\\n        map<string,int> mp;\\n        for(int i=0; i<m ; i++)\\n            mp[senders[i]] += countWords(messages[i]); \\n        for(auto it:mp){\\n            if(it.second >= maxi){\\n                ans = it.first;\\n                maxi = it.second;\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551723,
                "title": "c-easy-understand",
                "content": "# Complexity\\n- Time complexity: O(n*m)\\n- n:sender\\n- m:message length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string, int> m;\\n        int w;\\n        for(int i = 0; i < senders.size(); i++){\\n            w = 1;\\n            for(auto s : messages[i]){\\n                if(s == \\' \\'){\\n                    w++;\\n                }\\n            }\\n            m[senders[i]] += w;\\n        }\\n        int max = 0;\\n        string ans = senders[0];\\n        for(auto mm : m){\\n            if(mm.second > max){\\n                ans = mm.first;\\n                max = mm.second;\\n            }\\n            else if(mm.second == max){\\n                ans = mm.first > ans ? mm.first : ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string, int> m;\\n        int w;\\n        for(int i = 0; i < senders.size(); i++){\\n            w = 1;\\n            for(auto s : messages[i]){\\n                if(s == \\' \\'){\\n                    w++;\\n                }\\n            }\\n            m[senders[i]] += w;\\n        }\\n        int max = 0;\\n        string ans = senders[0];\\n        for(auto mm : m){\\n            if(mm.second > max){\\n                ans = mm.first;\\n                max = mm.second;\\n            }\\n            else if(mm.second == max){\\n                ans = mm.first > ans ? mm.first : ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540001,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        mapping = {}\\n\\n        for i in range(len(senders)):\\n            mapping[senders[i]] = mapping.get(senders[i], 0) + len(messages[i].split())\\n\\n        return sorted(mapping.items(), key=lambda x: (x[1],x[0]))[-1][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        mapping = {}\\n\\n        for i in range(len(senders)):\\n            mapping[senders[i]] = mapping.get(senders[i], 0) + len(messages[i].split())\\n\\n        return sorted(mapping.items(), key=lambda x: (x[1],x[0]))[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512538,
                "title": "rust-iterator-chaining",
                "content": "# Intuition\\nWhen in doubt, use a hashmap. \\n\\n# Approach\\nCount the words in each message using split() and count(). Zip with the sender to get an iterator of pairs, then fold them into Hashmap to get the count of all words by sender. Iterate over the hashmap and sort ascending by word count and sender (in that order) and take the maximum.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of messages. While we do two iterations (one over messages, one over senders) the number of senders is <= the number of messages so it\\'s at most 2x the number of messages, which we ignore in big-O.\\n\\n- Space complexity: O(m), where m is the number of senders. We store a hashmap with one entry per sender.\\n \\n# Code\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn largest_word_count(messages: Vec<String>, senders: Vec<String>) -> String {\\n        messages\\n        .iter()\\n        .map(|message| message.trim().split(\\' \\').count())\\n        .zip(senders.into_iter())\\n        .fold(\\n            HashMap::<String, usize>::new(),\\n            |mut sender_words, (message_words, sender)| {\\n                *sender_words.entry(sender).or_default() += message_words;\\n                sender_words\\n            }\\n        )\\n        .into_iter()\\n        .map(|(sender, words)| (words, sender))\\n        .max()\\n        .unwrap()\\n        .1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn largest_word_count(messages: Vec<String>, senders: Vec<String>) -> String {\\n        messages\\n        .iter()\\n        .map(|message| message.trim().split(\\' \\').count())\\n        .zip(senders.into_iter())\\n        .fold(\\n            HashMap::<String, usize>::new(),\\n            |mut sender_words, (message_words, sender)| {\\n                *sender_words.entry(sender).or_default() += message_words;\\n                sender_words\\n            }\\n        )\\n        .into_iter()\\n        .map(|(sender, words)| (words, sender))\\n        .max()\\n        .unwrap()\\n        .1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477508,
                "title": "sender-with-largest-word-count",
                "content": "----------------- Easy C++ Solution --------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n    int n = messages.size();\\n    string ans;\\n    int maxWordsSent = 0;\\n    unordered_map<string, int> count;\\n\\n    for (int i = 0; i < n; ++i) {\\n      string& message = messages[i];\\n      string& sender = senders[i];\\n      int wordsCount = std::count(begin(message), end(message), \\' \\') + 1;\\n      count[sender] += wordsCount;\\n      int numWordsSent = count[sender];\\n      if (numWordsSent > maxWordsSent) {\\n        ans = sender;\\n        maxWordsSent = numWordsSent;\\n      } else if (numWordsSent == maxWordsSent && sender > ans) {\\n        ans = sender;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n    int n = messages.size();\\n    string ans;\\n    int maxWordsSent = 0;\\n    unordered_map<string, int> count;\\n\\n    for (int i = 0; i < n; ++i) {\\n      string& message = messages[i];\\n      string& sender = senders[i];\\n      int wordsCount = std::count(begin(message), end(message), \\' \\') + 1;\\n      count[sender] += wordsCount;\\n      int numWordsSent = count[sender];\\n      if (numWordsSent > maxWordsSent) {\\n        ans = sender;\\n        maxWordsSent = numWordsSent;\\n      } else if (numWordsSent == maxWordsSent && sender > ans) {\\n        ans = sender;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475575,
                "title": "beats-95-java-easy-to-understand-o-n-time-complexity-hashmap",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n\\n        HashMap<String,Integer> map=new HashMap<String,Integer>();\\n        int max=Integer.MIN_VALUE;\\n        String result=\"\";\\n\\n        for(int i=0;i<messages.length;i++){\\n\\n            int c = map.getOrDefault(senders[i], 0);\\n            c += countWord(messages[i]);\\n            map.put(senders[i], c);\\n\\n            if(c>max){\\n                max=c;\\n                result=senders[i];\\n            }else if(c==max){\\n                if(senders[i].compareTo(result)>0){\\n                    result=senders[i];\\n                }\\n            }\\n        }\\n\\n        return result;\\n        \\n    }\\n\\n\\n    private static int countWord(String str) {\\n        int space = 0;\\n        for (int i=0; i<str.length(); i++) {\\n            if (str.charAt(i) == \\' \\') {\\n                space++;\\n            }\\n        }\\n\\n        return space + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n\\n        HashMap<String,Integer> map=new HashMap<String,Integer>();\\n        int max=Integer.MIN_VALUE;\\n        String result=\"\";\\n\\n        for(int i=0;i<messages.length;i++){\\n\\n            int c = map.getOrDefault(senders[i], 0);\\n            c += countWord(messages[i]);\\n            map.put(senders[i], c);\\n\\n            if(c>max){\\n                max=c;\\n                result=senders[i];\\n            }else if(c==max){\\n                if(senders[i].compareTo(result)>0){\\n                    result=senders[i];\\n                }\\n            }\\n        }\\n\\n        return result;\\n        \\n    }\\n\\n\\n    private static int countWord(String str) {\\n        int space = 0;\\n        for (int i=0; i<str.length(); i++) {\\n            if (str.charAt(i) == \\' \\') {\\n                space++;\\n            }\\n        }\\n\\n        return space + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472900,
                "title": "neat-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) \\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cin.tie(NULL);\\n\\n       string res;\\n       unordered_map<string,int> mp ;\\n\\n       for(int i = 0; i<messages.size();i++)\\n       {\\n           string word  = messages[i]; \\n        \\n           int count = 0; \\n           for(int j = 0 ; j<word.size();j++)\\n           if(isspace(word[j]))// counting no of spaces\\n           count++; \\n           mp[senders[i]] += count + 1;// no of words = no of space + 1 sincee there are no extraa space\\n        }\\n        int mx = -1 ; \\n        for(auto x:mp)\\n        cout<<x.first<<\" \"<<x.second<<endl;\\n        for(auto x:mp)\\n        {\\n            if(x.second>mx)\\n            {\\n                res = x.first;\\n                mx = x.second; \\n            }\\n            if(x.second==mx && x.first>res)\\n            res = x.first;\\n        }\\n\\n\\n       return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) \\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cin.tie(NULL);\\n\\n       string res;\\n       unordered_map<string,int> mp ;\\n\\n       for(int i = 0; i<messages.size();i++)\\n       {\\n           string word  = messages[i]; \\n        \\n           int count = 0; \\n           for(int j = 0 ; j<word.size();j++)\\n           if(isspace(word[j]))// counting no of spaces\\n           count++; \\n           mp[senders[i]] += count + 1;// no of words = no of space + 1 sincee there are no extraa space\\n        }\\n        int mx = -1 ; \\n        for(auto x:mp)\\n        cout<<x.first<<\" \"<<x.second<<endl;\\n        for(auto x:mp)\\n        {\\n            if(x.second>mx)\\n            {\\n                res = x.first;\\n                mx = x.second; \\n            }\\n            if(x.second==mx && x.first>res)\\n            res = x.first;\\n        }\\n\\n\\n       return res; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3466457,
                "title": "easy-and-readable-code-using-map",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCounting the number of spaces in the message. \\nUsing a Map to store word count for each sender.\\nIterating through the map to find the sender with max count.\\nIf there are multiple values, using compare function to find the greater one.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        int l=senders.size();\\n\\n        map<string,int> mp;\\n        \\n        for(int i=0;i<l;i++)\\n        {\\n            int count=0;\\n            int n=messages[i].length();\\n            for(int j=0;j<n;j++)\\n                if(messages[i][j]==32)\\n                    count++;\\n\\n                mp[senders[i]]+=(count+1);\\n        }\\n        string ans=\"\";\\n        int mx=INT_MIN;\\n        for(auto it:mp)\\n        {   \\n            if(mx<it.second)\\n            {\\n                ans=it.first;\\n                mx=it.second;\\n            }\\n            else if(mx==it.second&&it.first.compare(ans)>0)\\n                ans=it.first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        int l=senders.size();\\n\\n        map<string,int> mp;\\n        \\n        for(int i=0;i<l;i++)\\n        {\\n            int count=0;\\n            int n=messages[i].length();\\n            for(int j=0;j<n;j++)\\n                if(messages[i][j]==32)\\n                    count++;\\n\\n                mp[senders[i]]+=(count+1);\\n        }\\n        string ans=\"\";\\n        int mx=INT_MIN;\\n        for(auto it:mp)\\n        {   \\n            if(mx<it.second)\\n            {\\n                ans=it.first;\\n                mx=it.second;\\n            }\\n            else if(mx==it.second&&it.first.compare(ans)>0)\\n                ans=it.first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464041,
                "title": "use-map-c",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string, vector<string>> mp;\\n\\n        for(int i=0; i<senders.size(); i++)\\n          mp[senders[i]].push_back(messages[i]);\\n\\n        int maxm = INT_MIN;\\n        int count=0;\\n        string ans;\\n\\n        for(auto i:mp)\\n        {\\n          count = 0;\\n          for(auto j:i.second)\\n          {\\n            /*String stream will help us in counting the words present \\n            in the current message.*/\\n\\n              stringstream s(j);\\n              string word;\\n\\n              while(s>>word)\\n                  count++;\\n          }\\n\\n          if(count >= maxm)\\n              ans = i.first;\\n\\n          maxm = max(maxm, count);\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/d730f286-26e8-4b42-9422-0ff4d5f00e9c_1682700474.9206955.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        map<string, vector<string>> mp;\\n\\n        for(int i=0; i<senders.size(); i++)\\n          mp[senders[i]].push_back(messages[i]);\\n\\n        int maxm = INT_MIN;\\n        int count=0;\\n        string ans;\\n\\n        for(auto i:mp)\\n        {\\n          count = 0;\\n          for(auto j:i.second)\\n          {\\n            /*String stream will help us in counting the words present \\n            in the current message.*/\\n\\n              stringstream s(j);\\n              string word;\\n\\n              while(s>>word)\\n                  count++;\\n          }\\n\\n          if(count >= maxm)\\n              ans = i.first;\\n\\n          maxm = max(maxm, count);\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450704,
                "title": "java-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i=0; i<senders.length; i++){\\n            String[] s = messages[i].split(\" \");\\n            int len = s.length;\\n            int v = map.getOrDefault(senders[i], 0);\\n            map.put(senders[i], len+v);\\n        }\\n        int max = 0;\\n        for(int it: map.values())\\n            max = Math.max(max, it);\\n        List<String> list = new ArrayList<>();\\n        for(String s: map.keySet())\\n            if(map.get(s) == max)\\n                list.add(s);\\n        Collections.sort(list);\\n        return list.get(list.size()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i=0; i<senders.length; i++){\\n            String[] s = messages[i].split(\" \");\\n            int len = s.length;\\n            int v = map.getOrDefault(senders[i], 0);\\n            map.put(senders[i], len+v);\\n        }\\n        int max = 0;\\n        for(int it: map.values())\\n            max = Math.max(max, it);\\n        List<String> list = new ArrayList<>();\\n        for(String s: map.keySet())\\n            if(map.get(s) == max)\\n                list.add(s);\\n        Collections.sort(list);\\n        return list.get(list.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422223,
                "title": "sender-with-largest-word-count",
                "content": "# Code\\n```\\nclass Solution:\\n    def largestWordCount(self, m: List[str], s: List[str]) -> str:\\n        dic = {}\\n        l = []\\n        for i in range(len(m)):\\n            if s[i] in dic:\\n                dic[s[i]] += len(m[i].split(\" \"))\\n            else:\\n                dic[s[i]] = len(m[i].split(\" \"))\\n        # print(dic)\\n        d = sorted(dic.values(),reverse = True)\\n        a = d[0]\\n        for i in dic:\\n            if dic[i]==a:\\n                l.append(i)\\n        l.sort()\\n        return l[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, m: List[str], s: List[str]) -> str:\\n        dic = {}\\n        l = []\\n        for i in range(len(m)):\\n            if s[i] in dic:\\n                dic[s[i]] += len(m[i].split(\" \"))\\n            else:\\n                dic[s[i]] = len(m[i].split(\" \"))\\n        # print(dic)\\n        d = sorted(dic.values(),reverse = True)\\n        a = d[0]\\n        for i in dic:\\n            if dic[i]==a:\\n                l.append(i)\\n        l.sort()\\n        return l[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408226,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func largestWordCount(_ messages: [String], _ senders: [String]) -> String {\\n        \\n        let tbl = senders.indices.reduce(into: [String: Int]()) {\\n            $0[senders[$1], default: 0] += messages[$1].components(separatedBy: \" \").count\\n        }\\n\\n        let ma = tbl.values.max()!\\n\\n        return tbl\\n            .filter { $0.value == ma }\\n            .map { $0.key }\\n            .sorted()\\n            .last!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestWordCount(_ messages: [String], _ senders: [String]) -> String {\\n        \\n        let tbl = senders.indices.reduce(into: [String: Int]()) {\\n            $0[senders[$1], default: 0] += messages[$1].components(separatedBy: \" \").count\\n        }\\n\\n        let ma = tbl.values.max()!\\n\\n        return tbl\\n            .filter { $0.value == ma }\\n            .map { $0.key }\\n            .sorted()\\n            .last!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406565,
                "title": "simple-o-nl-solution-faster-than-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nl) where l is the length of the word\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        int maxWords = 0;\\n\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < messages.length;i++){\\n            int words = 1;\\n            String name = senders[i];\\n            char[] cs = messages[i].toCharArray();\\n            for(int j = 0; j < cs.length;j++){\\n                if (cs[j] == \\' \\') words++;\\n            }\\n            int totalWords = map.getOrDefault(name, 0) + words;\\n            map.put(name, totalWords);\\n            maxWords = Math.max(maxWords, totalWords);\\n        }\\n\\n        String name = \"\";\\n\\n        for(Map.Entry<String, Integer> entry : map.entrySet()){\\n            String candidate = entry.getKey();\\n            if (entry.getValue() == maxWords) {\\n                if (name.equals(\"\")) name = candidate;\\n                else if (name.compareTo(candidate) < 0) name = candidate;\\n            }\\n        }\\n\\n        return name;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        int maxWords = 0;\\n\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < messages.length;i++){\\n            int words = 1;\\n            String name = senders[i];\\n            char[] cs = messages[i].toCharArray();\\n            for(int j = 0; j < cs.length;j++){\\n                if (cs[j] == \\' \\') words++;\\n            }\\n            int totalWords = map.getOrDefault(name, 0) + words;\\n            map.put(name, totalWords);\\n            maxWords = Math.max(maxWords, totalWords);\\n        }\\n\\n        String name = \"\";\\n\\n        for(Map.Entry<String, Integer> entry : map.entrySet()){\\n            String candidate = entry.getKey();\\n            if (entry.getValue() == maxWords) {\\n                if (name.equals(\"\")) name = candidate;\\n                else if (name.compareTo(candidate) < 0) name = candidate;\\n            }\\n        }\\n\\n        return name;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391776,
                "title": "c-unordered-map-and-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        int size = messages.size();\\n        unordered_map<string, int> counter;\\n        priority_queue<pair<int, string>> q;\\n        for(int i = 0; i < size; ++i) {\\n            auto& message = messages[i];\\n            auto& sender = senders[i];\\n            counter[sender] += count(begin(message), end(message), \\' \\') + 1;\\n        }\\n        for(auto& [sender, num]: counter) {\\n            q.push({num, sender});\\n        }\\n        return q.top().second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        int size = messages.size();\\n        unordered_map<string, int> counter;\\n        priority_queue<pair<int, string>> q;\\n        for(int i = 0; i < size; ++i) {\\n            auto& message = messages[i];\\n            auto& sender = senders[i];\\n            counter[sender] += count(begin(message), end(message), \\' \\') + 1;\\n        }\\n        for(auto& [sender, num]: counter) {\\n            q.push({num, sender});\\n        }\\n        return q.top().second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387614,
                "title": "python-easy-solution-using-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def largestWordCount(self, messages, senders):\\n        \"\"\"\\n        :type messages: List[str]\\n        :type senders: List[str]\\n        :rtype: str\\n        \"\"\"\\n        dict1={}\\n        for i in range(len(senders)):\\n            \\n            list1=messages[i].split()\\n            if senders[i] not in dict1:\\n                dict1[senders[i]]=len(list1)\\n            else:\\n                dict1[senders[i]]=dict1[senders[i]]+len(list1)\\n\\n        max1=max(int(x) for x in dict1.values())\\n        for i in sorted(dict1,reverse=True):\\n            if dict1[i]==max1:\\n                return i\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def largestWordCount(self, messages, senders):\\n        \"\"\"\\n        :type messages: List[str]\\n        :type senders: List[str]\\n        :rtype: str\\n        \"\"\"\\n        dict1={}\\n        for i in range(len(senders)):\\n            \\n            list1=messages[i].split()\\n            if senders[i] not in dict1:\\n                dict1[senders[i]]=len(list1)\\n            else:\\n                dict1[senders[i]]=dict1[senders[i]]+len(list1)\\n\\n        max1=max(int(x) for x in dict1.values())\\n        for i in sorted(dict1,reverse=True):\\n            if dict1[i]==max1:\\n                return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382552,
                "title": "simple-hash-table-solution-cpp",
                "content": "# Intuition and Approach\\n* maintain a map for the count of words for each person.\\n* now traverse the message array and senders array simaltaneously.\\n* count the \\' \\' in each message and add to its word count in map.\\n* simaltaneously check for the user with max word count.\\n* at the end return ans.\\n\\n# Complexity\\n- Time complexity:O(n*lenght of longest message)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        map<string,int>mp;\\n        int maxi=0;\\n        string ans=\"\";\\n        for(int i=0;i<m.size();i++){\\n            mp[s[i]]+=(count(m[i].begin(), m[i].end(),\\' \\')+1);\\n            if(mp[s[i]]==maxi){\\n                ans=max(ans,s[i]);\\n            }\\n            if(mp[s[i]]>maxi){\\n                ans=s[i];\\n                maxi=mp[s[i]];\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        map<string,int>mp;\\n        int maxi=0;\\n        string ans=\"\";\\n        for(int i=0;i<m.size();i++){\\n            mp[s[i]]+=(count(m[i].begin(), m[i].end(),\\' \\')+1);\\n            if(mp[s[i]]==maxi){\\n                ans=max(ans,s[i]);\\n            }\\n            if(mp[s[i]]>maxi){\\n                ans=s[i];\\n                maxi=mp[s[i]];\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377758,
                "title": "java-solution-using-hashmap-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) \\n    {\\n        HashMap<String,Integer>map=new HashMap<>();\\n        int max=0;\\n        int k=0;\\n        for(int i=0;i<messages.length;i++)\\n        {\\n            String str[]=messages[i].split(\" \");\\n            int l=str.length;\\n\\n\\n            if(map.containsKey(senders[i]))\\n            {\\n                int ans=map.get(senders[i]);\\n                map.put(senders[i],(ans+l));\\n\\n            }\\n\\n            else\\n            {\\n            map.put(senders[i],l);\\n            }\\n        \\n\\n        }\\n        for(int i=0;i<senders.length;i++)\\n        {\\n            int l=map.get(senders[i]);\\n            if(l>max)\\n            {\\n                max=l;\\n                k=i;\\n\\n            }\\n            if(l==max)\\n            {\\n                String str1=senders[k];\\n                String s2=senders[i];\\n                int len=str1.compareTo(s2);\\n                if(len<0)\\n                k=i; \\n\\n            }\\n        }\\n        return senders[k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) \\n    {\\n        HashMap<String,Integer>map=new HashMap<>();\\n        int max=0;\\n        int k=0;\\n        for(int i=0;i<messages.length;i++)\\n        {\\n            String str[]=messages[i].split(\" \");\\n            int l=str.length;\\n\\n\\n            if(map.containsKey(senders[i]))\\n            {\\n                int ans=map.get(senders[i]);\\n                map.put(senders[i],(ans+l));\\n\\n            }\\n\\n            else\\n            {\\n            map.put(senders[i],l);\\n            }\\n        \\n\\n        }\\n        for(int i=0;i<senders.length;i++)\\n        {\\n            int l=map.get(senders[i]);\\n            if(l>max)\\n            {\\n                max=l;\\n                k=i;\\n\\n            }\\n            if(l==max)\\n            {\\n                String str1=senders[k];\\n                String s2=senders[i];\\n                int len=str1.compareTo(s2);\\n                if(len<0)\\n                k=i; \\n\\n            }\\n        }\\n        return senders[k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367994,
                "title": "python-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        # initializing a HashMap\\n        hashMap = {}\\n        # initializing a list to store senders with the largest word count and to sort  Lexigograhicaly\\n        sender_ls = []\\n\\n        for idx, word in enumerate(messages):\\n            if senders[idx] not in hashMap:\\n                hashMap[senders[idx]] = len(word.split())\\n            else:\\n                hashMap[senders[idx]] += len(word.split())\\n\\n        max_val = max(hashMap.values())\\n        for k, v in hashMap.items():\\n            if v == max_val:\\n                sender_ls.append(k)\\n        if len(sender_ls) == 1:\\n            return sender_ls.pop()\\n        else:\\n            sender_ls = sorted(sender_ls)[::-1]\\n            return sender_ls[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        # initializing a HashMap\\n        hashMap = {}\\n        # initializing a list to store senders with the largest word count and to sort  Lexigograhicaly\\n        sender_ls = []\\n\\n        for idx, word in enumerate(messages):\\n            if senders[idx] not in hashMap:\\n                hashMap[senders[idx]] = len(word.split())\\n            else:\\n                hashMap[senders[idx]] += len(word.split())\\n\\n        max_val = max(hashMap.values())\\n        for k, v in hashMap.items():\\n            if v == max_val:\\n                sender_ls.append(k)\\n        if len(sender_ls) == 1:\\n            return sender_ls.pop()\\n        else:\\n            sender_ls = sorted(sender_ls)[::-1]\\n            return sender_ls[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367993,
                "title": "python-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        # initializing a HashMap\\n        hashMap = {}\\n        # initializing a list to store senders with the largest word count and to sort  Lexigograhicaly\\n        sender_ls = []\\n\\n        for idx, word in enumerate(messages):\\n            if senders[idx] not in hashMap:\\n                hashMap[senders[idx]] = len(word.split())\\n            else:\\n                hashMap[senders[idx]] += len(word.split())\\n\\n        max_val = max(hashMap.values())\\n        for k, v in hashMap.items():\\n            if v == max_val:\\n                sender_ls.append(k)\\n        if len(sender_ls) == 1:\\n            return sender_ls.pop()\\n        else:\\n            sender_ls = sorted(sender_ls)[::-1]\\n            return sender_ls[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        # initializing a HashMap\\n        hashMap = {}\\n        # initializing a list to store senders with the largest word count and to sort  Lexigograhicaly\\n        sender_ls = []\\n\\n        for idx, word in enumerate(messages):\\n            if senders[idx] not in hashMap:\\n                hashMap[senders[idx]] = len(word.split())\\n            else:\\n                hashMap[senders[idx]] += len(word.split())\\n\\n        max_val = max(hashMap.values())\\n        for k, v in hashMap.items():\\n            if v == max_val:\\n                sender_ls.append(k)\\n        if len(sender_ls) == 1:\\n            return sender_ls.pop()\\n        else:\\n            sender_ls = sorted(sender_ls)[::-1]\\n            return sender_ls[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367992,
                "title": "python-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        # initializing a HashMap\\n        hashMap = {}\\n        # initializing a list to store senders with the largest word count and to sort  Lexigograhicaly\\n        sender_ls = []\\n\\n        for idx, word in enumerate(messages):\\n            if senders[idx] not in hashMap:\\n                hashMap[senders[idx]] = len(word.split())\\n            else:\\n                hashMap[senders[idx]] += len(word.split())\\n\\n        max_val = max(hashMap.values())\\n        for k, v in hashMap.items():\\n            if v == max_val:\\n                sender_ls.append(k)\\n        if len(sender_ls) == 1:\\n            return sender_ls.pop()\\n        else:\\n            sender_ls = sorted(sender_ls)[::-1]\\n            return sender_ls[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        # initializing a HashMap\\n        hashMap = {}\\n        # initializing a list to store senders with the largest word count and to sort  Lexigograhicaly\\n        sender_ls = []\\n\\n        for idx, word in enumerate(messages):\\n            if senders[idx] not in hashMap:\\n                hashMap[senders[idx]] = len(word.split())\\n            else:\\n                hashMap[senders[idx]] += len(word.split())\\n\\n        max_val = max(hashMap.values())\\n        for k, v in hashMap.items():\\n            if v == max_val:\\n                sender_ls.append(k)\\n        if len(sender_ls) == 1:\\n            return sender_ls.pop()\\n        else:\\n            sender_ls = sorted(sender_ls)[::-1]\\n            return sender_ls[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354524,
                "title": "java-easy-hashmap",
                "content": "# Approach\\nThe approach involves using a HashMap to keep track of the number of words sent by each sender.\\n\\nThe largestWordCount method takes two arrays as input - messages and senders. The length of both arrays is assumed to be the same. The messages array contains messages sent by different senders, and the senders array contains the name of the sender for each message.\\n\\nIn the first for loop, the wordcount function is called to count the number of words in each message. The wordcount function takes a string as input and returns the number of words in it. The count is then added to the sender\\'s entry in the HashMap using map.put() method. If the sender\\'s entry is not present in the HashMap, it is added with a default value of 0.\\n\\nIn the second for loop, the HashMap entries are iterated using map.entrySet(). The sender with the largest number of words is found by comparing the value (word count) of each entry with the current maximum res. If the current value is greater than res, it is assigned to res, and the corresponding sender is assigned to ans. If the current value is equal to res, then the sender with the lexicographically smaller name is assigned to ans.\\n\\nThe final result is the sender with the largest number of words, which is returned by the largestWordCount method.\\n\\nOverall, the solution has a time complexity of O(n), where n is the length of the messages and senders arrays, since each message needs to be processed once to count its words, and each sender needs to be updated once in the HashMap.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        int n = messages.length;\\n        HashMap<String,Integer> map = new HashMap<String,Integer>();\\n        for(int i=0;i<n;i++){\\n            int words_count = wordcount(messages[i]);\\n            map.put(senders[i],map.getOrDefault(senders[i],0)+words_count);\\n        }\\n        String ans = \"\";\\n        int res = Integer.MIN_VALUE;\\n        for(Map.Entry<String,Integer> entry: map.entrySet()){\\n            if(entry.getValue()>res){\\n                res = entry.getValue();\\n                ans = entry.getKey();\\n            }else if(entry.getValue()==res){\\n                if(ans.compareTo(entry.getKey())<0){\\n                    ans = entry.getKey();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    static int wordcount(String string)  {  \\n          int count=0;  \\n      \\n            char ch[]= new char[string.length()];     \\n            for(int i=0;i<string.length();i++)  \\n            {  \\n                ch[i]= string.charAt(i);  \\n                if( ((i>0)&&(ch[i]!=\\' \\')&&(ch[i-1]==\\' \\')) || ((ch[0]!=\\' \\')&&(i==0)) )  \\n                    count++;  \\n            }  \\n            return count;  \\n    }  \\n\\n \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        int n = messages.length;\\n        HashMap<String,Integer> map = new HashMap<String,Integer>();\\n        for(int i=0;i<n;i++){\\n            int words_count = wordcount(messages[i]);\\n            map.put(senders[i],map.getOrDefault(senders[i],0)+words_count);\\n        }\\n        String ans = \"\";\\n        int res = Integer.MIN_VALUE;\\n        for(Map.Entry<String,Integer> entry: map.entrySet()){\\n            if(entry.getValue()>res){\\n                res = entry.getValue();\\n                ans = entry.getKey();\\n            }else if(entry.getValue()==res){\\n                if(ans.compareTo(entry.getKey())<0){\\n                    ans = entry.getKey();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    static int wordcount(String string)  {  \\n          int count=0;  \\n      \\n            char ch[]= new char[string.length()];     \\n            for(int i=0;i<string.length();i++)  \\n            {  \\n                ch[i]= string.charAt(i);  \\n                if( ((i>0)&&(ch[i]!=\\' \\')&&(ch[i-1]==\\' \\')) || ((ch[0]!=\\' \\')&&(i==0)) )  \\n                    count++;  \\n            }  \\n            return count;  \\n    }  \\n\\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351156,
                "title": "by-using-map-in-c-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        vector<int> word;\\n        for(int i=0;i<messages.size();i++){\\n            int count=0;\\n            for(int j=0;j<messages[i].size();j++){\\n                if(messages[i][j]==\\' \\')\\n                count++;\\n            }\\n            word.push_back(count+1);\\n        }\\n        map<string,int> mp;\\n        for(int i=0;i<senders.size();i++){\\n            if(mp[senders[i]]>0)\\n            mp[senders[i]]=mp[senders[i]]+word[i];\\n            else\\n            mp[senders[i]]=word[i];\\n        }\\n        vector<int> ans_count;\\n        for(auto it:mp){\\n            ans_count.push_back(it.second);\\n        }\\n        int k=*max_element(ans_count.begin(),ans_count.end());\\n        vector<string> ans;\\n        for(auto it:mp){\\n            if(it.second==k)\\n            ans.push_back(it.first);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[ans.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        vector<int> word;\\n        for(int i=0;i<messages.size();i++){\\n            int count=0;\\n            for(int j=0;j<messages[i].size();j++){\\n                if(messages[i][j]==\\' \\')\\n                count++;\\n            }\\n            word.push_back(count+1);\\n        }\\n        map<string,int> mp;\\n        for(int i=0;i<senders.size();i++){\\n            if(mp[senders[i]]>0)\\n            mp[senders[i]]=mp[senders[i]]+word[i];\\n            else\\n            mp[senders[i]]=word[i];\\n        }\\n        vector<int> ans_count;\\n        for(auto it:mp){\\n            ans_count.push_back(it.second);\\n        }\\n        int k=*max_element(ans_count.begin(),ans_count.end());\\n        vector<string> ans;\\n        for(auto it:mp){\\n            if(it.second==k)\\n            ans.push_back(it.first);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[ans.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321835,
                "title": "python3-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        mapping = dict()\\n        for i in range(len(senders)):\\n            if(senders[i] in mapping.keys()):\\n                mapping[senders[i]] += len(messages[i].split())\\n            else:\\n                mapping[senders[i]] = len(messages[i].split())\\n       \\n        highestCount = max(mapping.values())\\n        highestSenders = []\\n        for key,value in mapping.items():\\n            if(value==highestCount):\\n                highestSenders.append(key)\\n        \\n        return max(highestSenders)\\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestWordCount(self, messages: List[str], senders: List[str]) -> str:\\n        mapping = dict()\\n        for i in range(len(senders)):\\n            if(senders[i] in mapping.keys()):\\n                mapping[senders[i]] += len(messages[i].split())\\n            else:\\n                mapping[senders[i]] = len(messages[i].split())\\n       \\n        highestCount = max(mapping.values())\\n        highestSenders = []\\n        for key,value in mapping.items():\\n            if(value==highestCount):\\n                highestSenders.append(key)\\n        \\n        return max(highestSenders)\\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317561,
                "title": "java-solution-beats-90",
                "content": "# Code\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n\\n        //map storing key: sender name, value: total number of words sent by them\\n\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i=0; i<messages.length; i++){\\n            String str = messages[i];\\n            int count = 1;\\n            for(int j=0; j<str.length(); j++){\\n                if(str.charAt(j) == \\' \\'){\\n                    count++;\\n                }\\n            }\\n            map.put(senders[i], map.getOrDefault(senders[i], 0)+count);\\n        }\\n\\n        //finding the maximum number of words occurrence by a sender\\n\\n        int maxm = Integer.MIN_VALUE;\\n        for(String str: map.keySet()){\\n            int temp = map.get(str);\\n            if(temp>maxm){\\n                maxm = temp;\\n            }\\n        }\\n\\n        //PriorityQueue(maxheap) storing all senders with value maxm\\n\\n        PriorityQueue<String> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(String str: map.keySet()){\\n            if(map.get(str) == maxm){\\n                pq.add(str);\\n            }\\n        }\\n\\n        //queue head contains lexicographically larger string\\n\\n        return pq.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n\\n        //map storing key: sender name, value: total number of words sent by them\\n\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i=0; i<messages.length; i++){\\n            String str = messages[i];\\n            int count = 1;\\n            for(int j=0; j<str.length(); j++){\\n                if(str.charAt(j) == \\' \\'){\\n                    count++;\\n                }\\n            }\\n            map.put(senders[i], map.getOrDefault(senders[i], 0)+count);\\n        }\\n\\n        //finding the maximum number of words occurrence by a sender\\n\\n        int maxm = Integer.MIN_VALUE;\\n        for(String str: map.keySet()){\\n            int temp = map.get(str);\\n            if(temp>maxm){\\n                maxm = temp;\\n            }\\n        }\\n\\n        //PriorityQueue(maxheap) storing all senders with value maxm\\n\\n        PriorityQueue<String> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(String str: map.keySet()){\\n            if(map.get(str) == maxm){\\n                pq.add(str);\\n            }\\n        }\\n\\n        //queue head contains lexicographically larger string\\n\\n        return pq.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316860,
                "title": "java-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String,Integer> map = new HashMap<String,Integer>();\\n        for(int i=0;i<senders.length;i++){\\n            if(map.containsKey(senders[i])){\\n                map.put(senders[i],map.get(senders[i])+findWords(messages[i]));\\n            }else{\\n                map.put(senders[i],findWords(messages[i]));\\n            }\\n        }\\n        String res=null;\\n        int maxL = -1;\\n        for (int i = 0; i < senders.length; i++) {\\n            if(map.get(senders[i])>maxL|| (map.get(senders[i])==maxL && (res == null || senders[i].compareTo(res) > 0))) {\\n                res = senders[i];\\n                maxL = map.get(senders[i]);\\n            }\\n        }\\n        return res;\\n    }\\n    public static int findWords(String s){\\n        int c=1;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\' \\'){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public String largestWordCount(String[] messages, String[] senders) {\\n        HashMap<String,Integer> map = new HashMap<String,Integer>();\\n        for(int i=0;i<senders.length;i++){\\n            if(map.containsKey(senders[i])){\\n                map.put(senders[i],map.get(senders[i])+findWords(messages[i]));\\n            }else{\\n                map.put(senders[i],findWords(messages[i]));\\n            }\\n        }\\n        String res=null;\\n        int maxL = -1;\\n        for (int i = 0; i < senders.length; i++) {\\n            if(map.get(senders[i])>maxL|| (map.get(senders[i])==maxL && (res == null || senders[i].compareTo(res) > 0))) {\\n                res = senders[i];\\n                maxL = map.get(senders[i]);\\n            }\\n        }\\n        return res;\\n    }\\n    public static int findWords(String s){\\n        int c=1;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\' \\'){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1791782,
                "content": [
                    {
                        "username": "TIskiv",
                        "content": "Could you explain, when we have 2 senders with same count of messages, why correct answer is ubIEXAO, but not YMQDBkOWy ?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question IMO"
                    },
                    {
                        "username": "Rhythm_1383",
                        "content": "can you please help me \\nthis code gives correct output on every other ide but on leetcode its giving incorrect output for the followinf test case:\\n\\nmessages =\\n[\"nT\",\"y Mx p iD Lo\",\"xVg Ak IyQ u MG lmS Hq q e mb\",\"N Qf i y\",\"Zrs sbc tKE GGx xM D\",\"wo UEZ uPf Xi XjE\",\"tL y n\",\"ac Up cy znC uw I\",\"Dx vVW qa vxm\",\"spz D MEB pq\",\"ktu buy\",\"Mau Y ob J gqD jVZ B pXS\",\"q dB bdC Zd p dpr Np N\",\"Qqx O umB j iO hM eMW Nt\",\"T Vo C pnD r Dso PP qA q\",\"u s vPx c LeH ju z\",\"W Dee VQG a e\"]\\nsenders =\\n[\"dhOKiI\",\"OfOpYKCNku\",\"zyh\",\"hr\",\"o\",\"jDklz\",\"lre\",\"Zpi\",\"doorY\",\"OfOpYKCNku\",\"doorY\",\"b\",\"wjAC\",\"fBsUhoLpG\",\"Zpi\",\"wjAC\",\"Owwx\"]\\n\\nUse Testcase\\nOutput\\n\"Zpi\"\\nExpected\\n\"wjAC\"\\n\\n\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        unordered_map<string, int> senderWordCounts;\\n\\n        for (int i = 0; i < m.size(); i++) {\\n            char ch = \\' \\';\\n            int counter = count(m[i].begin(), m[i].end(), ch);\\n            senderWordCounts[s[i]] += counter + 1;\\n        }\\n\\n        int maxCount = INT_MIN;\\n        string result;\\n\\n        for (const auto& entry : senderWordCounts) {\\n            if (entry.second > maxCount) {\\n                maxCount = entry.second;\\n                result = entry.first;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "HashMap\\uD83D\\uDE43"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Time complexity of computing hash of a string in Java is proportional to the length of the string. To optimize, compute the hash for only time when updating: \n`int curCount = count.merge(senders[i], wordCount, (a, b) -> a + b);`\n\nWe can then use `curCount` for later comparison. This trick decreases my elapsed time from 57ms to 29ms."
                    },
                    {
                        "username": "harinath_10",
                        "content": "use map and vector<pair<int,string>>"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "///Easy Approach using map\\n`````\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string, vector<string>> mp;\\n\\n        for(int i=0;i< senders.size();i++){\\n            string y=messages[i];\\n                \\n                    stringstream s(y);\\n                    string word;\\n                    while(s>>word){\\n                            mp[senders[i]].push_back(word);\\n                    }\\n        }\\n        int mx=0;\\n        for( auto it= mp.begin(); it!=mp.end(); it++){\\n            if(mx<it->second.size())\\n                mx=it->second.size();\\n        }\\n        vector<string> ans;\\n        for(auto it= mp.begin();it!=mp.end();it++){\\n            if(mx==it->second.size()){\\n                ans.push_back(it->first);\\n            }\\n        }\\n\\n        sort(ans.begin(), ans.end());\\n        return ans[ans.size()-1];\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Why tf you post solution on discuss tab"
                    }
                ]
            },
            {
                "id": 1977855,
                "content": [
                    {
                        "username": "TIskiv",
                        "content": "Could you explain, when we have 2 senders with same count of messages, why correct answer is ubIEXAO, but not YMQDBkOWy ?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question IMO"
                    },
                    {
                        "username": "Rhythm_1383",
                        "content": "can you please help me \\nthis code gives correct output on every other ide but on leetcode its giving incorrect output for the followinf test case:\\n\\nmessages =\\n[\"nT\",\"y Mx p iD Lo\",\"xVg Ak IyQ u MG lmS Hq q e mb\",\"N Qf i y\",\"Zrs sbc tKE GGx xM D\",\"wo UEZ uPf Xi XjE\",\"tL y n\",\"ac Up cy znC uw I\",\"Dx vVW qa vxm\",\"spz D MEB pq\",\"ktu buy\",\"Mau Y ob J gqD jVZ B pXS\",\"q dB bdC Zd p dpr Np N\",\"Qqx O umB j iO hM eMW Nt\",\"T Vo C pnD r Dso PP qA q\",\"u s vPx c LeH ju z\",\"W Dee VQG a e\"]\\nsenders =\\n[\"dhOKiI\",\"OfOpYKCNku\",\"zyh\",\"hr\",\"o\",\"jDklz\",\"lre\",\"Zpi\",\"doorY\",\"OfOpYKCNku\",\"doorY\",\"b\",\"wjAC\",\"fBsUhoLpG\",\"Zpi\",\"wjAC\",\"Owwx\"]\\n\\nUse Testcase\\nOutput\\n\"Zpi\"\\nExpected\\n\"wjAC\"\\n\\n\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        unordered_map<string, int> senderWordCounts;\\n\\n        for (int i = 0; i < m.size(); i++) {\\n            char ch = \\' \\';\\n            int counter = count(m[i].begin(), m[i].end(), ch);\\n            senderWordCounts[s[i]] += counter + 1;\\n        }\\n\\n        int maxCount = INT_MIN;\\n        string result;\\n\\n        for (const auto& entry : senderWordCounts) {\\n            if (entry.second > maxCount) {\\n                maxCount = entry.second;\\n                result = entry.first;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "HashMap\\uD83D\\uDE43"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Time complexity of computing hash of a string in Java is proportional to the length of the string. To optimize, compute the hash for only time when updating: \n`int curCount = count.merge(senders[i], wordCount, (a, b) -> a + b);`\n\nWe can then use `curCount` for later comparison. This trick decreases my elapsed time from 57ms to 29ms."
                    },
                    {
                        "username": "harinath_10",
                        "content": "use map and vector<pair<int,string>>"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "///Easy Approach using map\\n`````\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string, vector<string>> mp;\\n\\n        for(int i=0;i< senders.size();i++){\\n            string y=messages[i];\\n                \\n                    stringstream s(y);\\n                    string word;\\n                    while(s>>word){\\n                            mp[senders[i]].push_back(word);\\n                    }\\n        }\\n        int mx=0;\\n        for( auto it= mp.begin(); it!=mp.end(); it++){\\n            if(mx<it->second.size())\\n                mx=it->second.size();\\n        }\\n        vector<string> ans;\\n        for(auto it= mp.begin();it!=mp.end();it++){\\n            if(mx==it->second.size()){\\n                ans.push_back(it->first);\\n            }\\n        }\\n\\n        sort(ans.begin(), ans.end());\\n        return ans[ans.size()-1];\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Why tf you post solution on discuss tab"
                    }
                ]
            },
            {
                "id": 2029529,
                "content": [
                    {
                        "username": "TIskiv",
                        "content": "Could you explain, when we have 2 senders with same count of messages, why correct answer is ubIEXAO, but not YMQDBkOWy ?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question IMO"
                    },
                    {
                        "username": "Rhythm_1383",
                        "content": "can you please help me \\nthis code gives correct output on every other ide but on leetcode its giving incorrect output for the followinf test case:\\n\\nmessages =\\n[\"nT\",\"y Mx p iD Lo\",\"xVg Ak IyQ u MG lmS Hq q e mb\",\"N Qf i y\",\"Zrs sbc tKE GGx xM D\",\"wo UEZ uPf Xi XjE\",\"tL y n\",\"ac Up cy znC uw I\",\"Dx vVW qa vxm\",\"spz D MEB pq\",\"ktu buy\",\"Mau Y ob J gqD jVZ B pXS\",\"q dB bdC Zd p dpr Np N\",\"Qqx O umB j iO hM eMW Nt\",\"T Vo C pnD r Dso PP qA q\",\"u s vPx c LeH ju z\",\"W Dee VQG a e\"]\\nsenders =\\n[\"dhOKiI\",\"OfOpYKCNku\",\"zyh\",\"hr\",\"o\",\"jDklz\",\"lre\",\"Zpi\",\"doorY\",\"OfOpYKCNku\",\"doorY\",\"b\",\"wjAC\",\"fBsUhoLpG\",\"Zpi\",\"wjAC\",\"Owwx\"]\\n\\nUse Testcase\\nOutput\\n\"Zpi\"\\nExpected\\n\"wjAC\"\\n\\n\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        unordered_map<string, int> senderWordCounts;\\n\\n        for (int i = 0; i < m.size(); i++) {\\n            char ch = \\' \\';\\n            int counter = count(m[i].begin(), m[i].end(), ch);\\n            senderWordCounts[s[i]] += counter + 1;\\n        }\\n\\n        int maxCount = INT_MIN;\\n        string result;\\n\\n        for (const auto& entry : senderWordCounts) {\\n            if (entry.second > maxCount) {\\n                maxCount = entry.second;\\n                result = entry.first;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "HashMap\\uD83D\\uDE43"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Time complexity of computing hash of a string in Java is proportional to the length of the string. To optimize, compute the hash for only time when updating: \n`int curCount = count.merge(senders[i], wordCount, (a, b) -> a + b);`\n\nWe can then use `curCount` for later comparison. This trick decreases my elapsed time from 57ms to 29ms."
                    },
                    {
                        "username": "harinath_10",
                        "content": "use map and vector<pair<int,string>>"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "///Easy Approach using map\\n`````\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string, vector<string>> mp;\\n\\n        for(int i=0;i< senders.size();i++){\\n            string y=messages[i];\\n                \\n                    stringstream s(y);\\n                    string word;\\n                    while(s>>word){\\n                            mp[senders[i]].push_back(word);\\n                    }\\n        }\\n        int mx=0;\\n        for( auto it= mp.begin(); it!=mp.end(); it++){\\n            if(mx<it->second.size())\\n                mx=it->second.size();\\n        }\\n        vector<string> ans;\\n        for(auto it= mp.begin();it!=mp.end();it++){\\n            if(mx==it->second.size()){\\n                ans.push_back(it->first);\\n            }\\n        }\\n\\n        sort(ans.begin(), ans.end());\\n        return ans[ans.size()-1];\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Why tf you post solution on discuss tab"
                    }
                ]
            },
            {
                "id": 1906338,
                "content": [
                    {
                        "username": "TIskiv",
                        "content": "Could you explain, when we have 2 senders with same count of messages, why correct answer is ubIEXAO, but not YMQDBkOWy ?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question IMO"
                    },
                    {
                        "username": "Rhythm_1383",
                        "content": "can you please help me \\nthis code gives correct output on every other ide but on leetcode its giving incorrect output for the followinf test case:\\n\\nmessages =\\n[\"nT\",\"y Mx p iD Lo\",\"xVg Ak IyQ u MG lmS Hq q e mb\",\"N Qf i y\",\"Zrs sbc tKE GGx xM D\",\"wo UEZ uPf Xi XjE\",\"tL y n\",\"ac Up cy znC uw I\",\"Dx vVW qa vxm\",\"spz D MEB pq\",\"ktu buy\",\"Mau Y ob J gqD jVZ B pXS\",\"q dB bdC Zd p dpr Np N\",\"Qqx O umB j iO hM eMW Nt\",\"T Vo C pnD r Dso PP qA q\",\"u s vPx c LeH ju z\",\"W Dee VQG a e\"]\\nsenders =\\n[\"dhOKiI\",\"OfOpYKCNku\",\"zyh\",\"hr\",\"o\",\"jDklz\",\"lre\",\"Zpi\",\"doorY\",\"OfOpYKCNku\",\"doorY\",\"b\",\"wjAC\",\"fBsUhoLpG\",\"Zpi\",\"wjAC\",\"Owwx\"]\\n\\nUse Testcase\\nOutput\\n\"Zpi\"\\nExpected\\n\"wjAC\"\\n\\n\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        unordered_map<string, int> senderWordCounts;\\n\\n        for (int i = 0; i < m.size(); i++) {\\n            char ch = \\' \\';\\n            int counter = count(m[i].begin(), m[i].end(), ch);\\n            senderWordCounts[s[i]] += counter + 1;\\n        }\\n\\n        int maxCount = INT_MIN;\\n        string result;\\n\\n        for (const auto& entry : senderWordCounts) {\\n            if (entry.second > maxCount) {\\n                maxCount = entry.second;\\n                result = entry.first;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "HashMap\\uD83D\\uDE43"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Time complexity of computing hash of a string in Java is proportional to the length of the string. To optimize, compute the hash for only time when updating: \n`int curCount = count.merge(senders[i], wordCount, (a, b) -> a + b);`\n\nWe can then use `curCount` for later comparison. This trick decreases my elapsed time from 57ms to 29ms."
                    },
                    {
                        "username": "harinath_10",
                        "content": "use map and vector<pair<int,string>>"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "///Easy Approach using map\\n`````\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string, vector<string>> mp;\\n\\n        for(int i=0;i< senders.size();i++){\\n            string y=messages[i];\\n                \\n                    stringstream s(y);\\n                    string word;\\n                    while(s>>word){\\n                            mp[senders[i]].push_back(word);\\n                    }\\n        }\\n        int mx=0;\\n        for( auto it= mp.begin(); it!=mp.end(); it++){\\n            if(mx<it->second.size())\\n                mx=it->second.size();\\n        }\\n        vector<string> ans;\\n        for(auto it= mp.begin();it!=mp.end();it++){\\n            if(mx==it->second.size()){\\n                ans.push_back(it->first);\\n            }\\n        }\\n\\n        sort(ans.begin(), ans.end());\\n        return ans[ans.size()-1];\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Why tf you post solution on discuss tab"
                    }
                ]
            },
            {
                "id": 1826623,
                "content": [
                    {
                        "username": "TIskiv",
                        "content": "Could you explain, when we have 2 senders with same count of messages, why correct answer is ubIEXAO, but not YMQDBkOWy ?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question IMO"
                    },
                    {
                        "username": "Rhythm_1383",
                        "content": "can you please help me \\nthis code gives correct output on every other ide but on leetcode its giving incorrect output for the followinf test case:\\n\\nmessages =\\n[\"nT\",\"y Mx p iD Lo\",\"xVg Ak IyQ u MG lmS Hq q e mb\",\"N Qf i y\",\"Zrs sbc tKE GGx xM D\",\"wo UEZ uPf Xi XjE\",\"tL y n\",\"ac Up cy znC uw I\",\"Dx vVW qa vxm\",\"spz D MEB pq\",\"ktu buy\",\"Mau Y ob J gqD jVZ B pXS\",\"q dB bdC Zd p dpr Np N\",\"Qqx O umB j iO hM eMW Nt\",\"T Vo C pnD r Dso PP qA q\",\"u s vPx c LeH ju z\",\"W Dee VQG a e\"]\\nsenders =\\n[\"dhOKiI\",\"OfOpYKCNku\",\"zyh\",\"hr\",\"o\",\"jDklz\",\"lre\",\"Zpi\",\"doorY\",\"OfOpYKCNku\",\"doorY\",\"b\",\"wjAC\",\"fBsUhoLpG\",\"Zpi\",\"wjAC\",\"Owwx\"]\\n\\nUse Testcase\\nOutput\\n\"Zpi\"\\nExpected\\n\"wjAC\"\\n\\n\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        unordered_map<string, int> senderWordCounts;\\n\\n        for (int i = 0; i < m.size(); i++) {\\n            char ch = \\' \\';\\n            int counter = count(m[i].begin(), m[i].end(), ch);\\n            senderWordCounts[s[i]] += counter + 1;\\n        }\\n\\n        int maxCount = INT_MIN;\\n        string result;\\n\\n        for (const auto& entry : senderWordCounts) {\\n            if (entry.second > maxCount) {\\n                maxCount = entry.second;\\n                result = entry.first;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "HashMap\\uD83D\\uDE43"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Time complexity of computing hash of a string in Java is proportional to the length of the string. To optimize, compute the hash for only time when updating: \n`int curCount = count.merge(senders[i], wordCount, (a, b) -> a + b);`\n\nWe can then use `curCount` for later comparison. This trick decreases my elapsed time from 57ms to 29ms."
                    },
                    {
                        "username": "harinath_10",
                        "content": "use map and vector<pair<int,string>>"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "///Easy Approach using map\\n`````\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string, vector<string>> mp;\\n\\n        for(int i=0;i< senders.size();i++){\\n            string y=messages[i];\\n                \\n                    stringstream s(y);\\n                    string word;\\n                    while(s>>word){\\n                            mp[senders[i]].push_back(word);\\n                    }\\n        }\\n        int mx=0;\\n        for( auto it= mp.begin(); it!=mp.end(); it++){\\n            if(mx<it->second.size())\\n                mx=it->second.size();\\n        }\\n        vector<string> ans;\\n        for(auto it= mp.begin();it!=mp.end();it++){\\n            if(mx==it->second.size()){\\n                ans.push_back(it->first);\\n            }\\n        }\\n\\n        sort(ans.begin(), ans.end());\\n        return ans[ans.size()-1];\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Why tf you post solution on discuss tab"
                    }
                ]
            },
            {
                "id": 1704566,
                "content": [
                    {
                        "username": "TIskiv",
                        "content": "Could you explain, when we have 2 senders with same count of messages, why correct answer is ubIEXAO, but not YMQDBkOWy ?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question IMO"
                    },
                    {
                        "username": "Rhythm_1383",
                        "content": "can you please help me \\nthis code gives correct output on every other ide but on leetcode its giving incorrect output for the followinf test case:\\n\\nmessages =\\n[\"nT\",\"y Mx p iD Lo\",\"xVg Ak IyQ u MG lmS Hq q e mb\",\"N Qf i y\",\"Zrs sbc tKE GGx xM D\",\"wo UEZ uPf Xi XjE\",\"tL y n\",\"ac Up cy znC uw I\",\"Dx vVW qa vxm\",\"spz D MEB pq\",\"ktu buy\",\"Mau Y ob J gqD jVZ B pXS\",\"q dB bdC Zd p dpr Np N\",\"Qqx O umB j iO hM eMW Nt\",\"T Vo C pnD r Dso PP qA q\",\"u s vPx c LeH ju z\",\"W Dee VQG a e\"]\\nsenders =\\n[\"dhOKiI\",\"OfOpYKCNku\",\"zyh\",\"hr\",\"o\",\"jDklz\",\"lre\",\"Zpi\",\"doorY\",\"OfOpYKCNku\",\"doorY\",\"b\",\"wjAC\",\"fBsUhoLpG\",\"Zpi\",\"wjAC\",\"Owwx\"]\\n\\nUse Testcase\\nOutput\\n\"Zpi\"\\nExpected\\n\"wjAC\"\\n\\n\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        unordered_map<string, int> senderWordCounts;\\n\\n        for (int i = 0; i < m.size(); i++) {\\n            char ch = \\' \\';\\n            int counter = count(m[i].begin(), m[i].end(), ch);\\n            senderWordCounts[s[i]] += counter + 1;\\n        }\\n\\n        int maxCount = INT_MIN;\\n        string result;\\n\\n        for (const auto& entry : senderWordCounts) {\\n            if (entry.second > maxCount) {\\n                maxCount = entry.second;\\n                result = entry.first;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "HashMap\\uD83D\\uDE43"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Time complexity of computing hash of a string in Java is proportional to the length of the string. To optimize, compute the hash for only time when updating: \n`int curCount = count.merge(senders[i], wordCount, (a, b) -> a + b);`\n\nWe can then use `curCount` for later comparison. This trick decreases my elapsed time from 57ms to 29ms."
                    },
                    {
                        "username": "harinath_10",
                        "content": "use map and vector<pair<int,string>>"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "///Easy Approach using map\\n`````\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string, vector<string>> mp;\\n\\n        for(int i=0;i< senders.size();i++){\\n            string y=messages[i];\\n                \\n                    stringstream s(y);\\n                    string word;\\n                    while(s>>word){\\n                            mp[senders[i]].push_back(word);\\n                    }\\n        }\\n        int mx=0;\\n        for( auto it= mp.begin(); it!=mp.end(); it++){\\n            if(mx<it->second.size())\\n                mx=it->second.size();\\n        }\\n        vector<string> ans;\\n        for(auto it= mp.begin();it!=mp.end();it++){\\n            if(mx==it->second.size()){\\n                ans.push_back(it->first);\\n            }\\n        }\\n\\n        sort(ans.begin(), ans.end());\\n        return ans[ans.size()-1];\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Why tf you post solution on discuss tab"
                    }
                ]
            },
            {
                "id": 1670621,
                "content": [
                    {
                        "username": "TIskiv",
                        "content": "Could you explain, when we have 2 senders with same count of messages, why correct answer is ubIEXAO, but not YMQDBkOWy ?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question IMO"
                    },
                    {
                        "username": "Rhythm_1383",
                        "content": "can you please help me \\nthis code gives correct output on every other ide but on leetcode its giving incorrect output for the followinf test case:\\n\\nmessages =\\n[\"nT\",\"y Mx p iD Lo\",\"xVg Ak IyQ u MG lmS Hq q e mb\",\"N Qf i y\",\"Zrs sbc tKE GGx xM D\",\"wo UEZ uPf Xi XjE\",\"tL y n\",\"ac Up cy znC uw I\",\"Dx vVW qa vxm\",\"spz D MEB pq\",\"ktu buy\",\"Mau Y ob J gqD jVZ B pXS\",\"q dB bdC Zd p dpr Np N\",\"Qqx O umB j iO hM eMW Nt\",\"T Vo C pnD r Dso PP qA q\",\"u s vPx c LeH ju z\",\"W Dee VQG a e\"]\\nsenders =\\n[\"dhOKiI\",\"OfOpYKCNku\",\"zyh\",\"hr\",\"o\",\"jDklz\",\"lre\",\"Zpi\",\"doorY\",\"OfOpYKCNku\",\"doorY\",\"b\",\"wjAC\",\"fBsUhoLpG\",\"Zpi\",\"wjAC\",\"Owwx\"]\\n\\nUse Testcase\\nOutput\\n\"Zpi\"\\nExpected\\n\"wjAC\"\\n\\n\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& m, vector<string>& s) {\\n        unordered_map<string, int> senderWordCounts;\\n\\n        for (int i = 0; i < m.size(); i++) {\\n            char ch = \\' \\';\\n            int counter = count(m[i].begin(), m[i].end(), ch);\\n            senderWordCounts[s[i]] += counter + 1;\\n        }\\n\\n        int maxCount = INT_MIN;\\n        string result;\\n\\n        for (const auto& entry : senderWordCounts) {\\n            if (entry.second > maxCount) {\\n                maxCount = entry.second;\\n                result = entry.first;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n"
                    },
                    {
                        "username": "kartik_dehru",
                        "content": "HashMap\\uD83D\\uDE43"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Time complexity of computing hash of a string in Java is proportional to the length of the string. To optimize, compute the hash for only time when updating: \n`int curCount = count.merge(senders[i], wordCount, (a, b) -> a + b);`\n\nWe can then use `curCount` for later comparison. This trick decreases my elapsed time from 57ms to 29ms."
                    },
                    {
                        "username": "harinath_10",
                        "content": "use map and vector<pair<int,string>>"
                    },
                    {
                        "username": "physicsgtx",
                        "content": "///Easy Approach using map\\n`````\\nclass Solution {\\npublic:\\n    string largestWordCount(vector<string>& messages, vector<string>& senders) {\\n        unordered_map<string, vector<string>> mp;\\n\\n        for(int i=0;i< senders.size();i++){\\n            string y=messages[i];\\n                \\n                    stringstream s(y);\\n                    string word;\\n                    while(s>>word){\\n                            mp[senders[i]].push_back(word);\\n                    }\\n        }\\n        int mx=0;\\n        for( auto it= mp.begin(); it!=mp.end(); it++){\\n            if(mx<it->second.size())\\n                mx=it->second.size();\\n        }\\n        vector<string> ans;\\n        for(auto it= mp.begin();it!=mp.end();it++){\\n            if(mx==it->second.size()){\\n                ans.push_back(it->first);\\n            }\\n        }\\n\\n        sort(ans.begin(), ans.end());\\n        return ans[ans.size()-1];\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Why tf you post solution on discuss tab"
                    }
                ]
            }
        ]
    }
]