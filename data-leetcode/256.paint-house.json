[
    {
        "title": "Merge Intervals",
        "question_content": "Given an array&nbsp;of intervals&nbsp;where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n&nbsp;\nExample 1:\n\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\nExample 2:\n\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n\n&nbsp;\nConstraints:\n\n\t1 <= intervals.length <= 104\n\tintervals[i].length == 2\n\t0 <= starti <= endi <= 104",
        "solutions": [
            {
                "id": 21222,
                "title": "a-simple-java-solution",
                "content": "The idea is to sort the intervals by their starting points. Then, we take the first interval and compare its end with the next intervals starts. As long as they overlap, we update the end to be the max end of the overlapping intervals. Once we find a non overlapping interval, we can add the previous \"extended\" interval and start over.\\n\\nSorting takes O(n log(n)) and merging the intervals takes O(n). So, the resulting algorithm takes O(n log(n)).\\n\\nI used a lambda comparator (Java 8) and a for-each loop to try to keep the code clean and simple.\\n\\nEDIT: The function signature changed in april 2019.\\nHere is a new version of the algorithm with arrays. To make more memory efficient, I reused the initial array (sort of \"in-place\") but it would be easy to create new subarrays if you wanted to keep the initial data.\\nIt takes less memory than 99% of the other solutions (sometimes 90% depending on the run) and is more than 10 times faster than the previous version with lists.\\n\\n\\tclass Solution {\\n\\t\\tpublic int[][] merge(int[][] intervals) {\\n\\t\\t\\tif (intervals.length <= 1)\\n\\t\\t\\t\\treturn intervals;\\n\\n\\t\\t\\t// Sort by ascending starting point\\n\\t\\t\\tArrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0]));\\n\\n\\t\\t\\tList<int[]> result = new ArrayList<>();\\n\\t\\t\\tint[] newInterval = intervals[0];\\n\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\tfor (int[] interval : intervals) {\\n\\t\\t\\t\\tif (interval[0] <= newInterval[1]) // Overlapping intervals, move the end if needed\\n\\t\\t\\t\\t\\tnewInterval[1] = Math.max(newInterval[1], interval[1]);\\n\\t\\t\\t\\telse {                             // Disjoint intervals, add the new interval to the list\\n\\t\\t\\t\\t\\tnewInterval = interval;\\n\\t\\t\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result.toArray(new int[result.size()][]);\\n\\t\\t}\\n\\t}\\n\\nPrevious version with lists.\\n\\n    public List<Interval> merge(List<Interval> intervals) {\\n        if (intervals.size() <= 1)\\n            return intervals;\\n        \\n        // Sort by ascending starting point using an anonymous Comparator\\n        intervals.sort((i1, i2) -> Integer.compare(i1.start, i2.start));\\n        \\n        List<Interval> result = new LinkedList<Interval>();\\n        int start = intervals.get(0).start;\\n        int end = intervals.get(0).end;\\n        \\n        for (Interval interval : intervals) {\\n            if (interval.start <= end) // Overlapping intervals, move the end if needed\\n                end = Math.max(end, interval.end);\\n            else {                     // Disjoint intervals, add the previous one and reset bounds\\n                result.add(new Interval(start, end));\\n                start = interval.start;\\n                end = interval.end;\\n            }\\n        }\\n        \\n        // Add the last interval\\n        result.add(new Interval(start, end));\\n        return result;\\n    }\\n\\nEDIT: Updated with Java 8 lambda comparator.\\nEDIT 25/05/2019: Updated for new method signature.",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] merge(int[][] intervals) {\\n\\t\\t\\tif (intervals.length <= 1)\\n\\t\\t\\t\\treturn intervals;\\n\\n\\t\\t\\t// Sort by ascending starting point\\n\\t\\t\\tArrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0]));\\n\\n\\t\\t\\tList<int[]> result = new ArrayList<>();\\n\\t\\t\\tint[] newInterval = intervals[0];\\n\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\tfor (int[] interval : intervals) {\\n\\t\\t\\t\\tif (interval[0] <= newInterval[1]) // Overlapping intervals, move the end if needed\\n\\t\\t\\t\\t\\tnewInterval[1] = Math.max(newInterval[1], interval[1]);\\n\\t\\t\\t\\telse {                             // Disjoint intervals, add the new interval to the list\\n\\t\\t\\t\\t\\tnewInterval = interval;\\n\\t\\t\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 21227,
                "title": "7-lines-easy-python",
                "content": "Just go through the intervals sorted by start coordinate and either combine the current interval with the previous one if they overlap, or add it to the output by itself if they don't.\\n\\n    def merge(self, intervals):\\n        out = []\\n        for i in sorted(intervals, key=lambda i: i.start):\\n            if out and i.start <= out[-1].end:\\n                out[-1].end = max(out[-1].end, i.end)\\n            else:\\n                out += i,\\n        return out",
                "solutionTags": [
                    "Python"
                ],
                "code": "Just go through the intervals sorted by start coordinate and either combine the current interval with the previous one if they overlap, or add it to the output by itself if they don't.\\n\\n    def merge(self, intervals):\\n        out = []\\n        for i in sorted(intervals, key=lambda i: i.start):\\n            if out and i.start <= out[-1].end:\\n                out[-1].end = max(out[-1].end, i.end)\\n            else:\\n                out += i,\\n        return out",
                "codeTag": "Python3"
            },
            {
                "id": 3161191,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n      if(intervals.size()==1)\\n         return intervals;\\n      vector<pair<int,int>> p;\\n      for(int i=0;i<intervals.size();i++)\\n      {\\n          p.push_back({intervals[i][0],intervals[i][1]});\\n      } \\n      sort(p.begin(),p.end());\\n\\n      vector<vector<int>> ans;\\n      int f=p[0].first,s=p[0].second;\\n      for(int i=0;i<p.size()-1;i++)\\n      {\\n          vector<int> a(2);\\n          if(s>=p[i+1].first)\\n          {\\n              s=max(s,p[i+1].second);\\n          }\\n          else\\n          {\\n              a[0]=f;\\n              a[1]=s;\\n              f=p[i+1].first;\\n              s=p[i+1].second;\\n              ans.push_back(a);\\n          }\\n      } \\n      int n=intervals.size();\\n      ans.push_back({f,s});\\n      return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x: x [0])\\n\\n        ans = []\\n\\n        for interval in intervals:\\n            if not ans or ans[-1][1] < interval[0]:\\n                ans.append(interval)\\n            else:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n        \\n        return ans\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\tmin = Math.min(min, intervals[i][0]);\\n\\t\\t\\tmax = Math.max(max, intervals[i][0]);\\n\\t\\t}\\n\\t\\t\\n\\t\\tint[] range = new int[max - min + 1];\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\trange[intervals[i][0] - min] = Math.max(intervals[i][1] - min, range[intervals[i][0] - min]); \\n\\t\\t}\\n\\t\\t\\n\\t\\tint start = 0, end = 0;\\n\\t\\tLinkedList<int[]> result = new LinkedList<>();\\n\\t\\tfor (int i = 0; i < range.length; i++) {\\n\\t\\t\\tif (range[i] == 0) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (i <= end) {\\n\\t\\t\\t\\tend = Math.max(range[i], end);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult.add(new int[] {start + min, end + min});\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\tend = range[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.add(new int[] {start + min, end + min});\\n\\t\\treturn result.toArray(new int[result.size()][]);\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n      if(intervals.size()==1)\\n         return intervals;\\n      vector<pair<int,int>> p;\\n      for(int i=0;i<intervals.size();i++)\\n      {\\n          p.push_back({intervals[i][0],intervals[i][1]});\\n      } \\n      sort(p.begin(),p.end());\\n\\n      vector<vector<int>> ans;\\n      int f=p[0].first,s=p[0].second;\\n      for(int i=0;i<p.size()-1;i++)\\n      {\\n          vector<int> a(2);\\n          if(s>=p[i+1].first)\\n          {\\n              s=max(s,p[i+1].second);\\n          }\\n          else\\n          {\\n              a[0]=f;\\n              a[1]=s;\\n              f=p[i+1].first;\\n              s=p[i+1].second;\\n              ans.push_back(a);\\n          }\\n      } \\n      int n=intervals.size();\\n      ans.push_back({f,s});\\n      return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x: x [0])\\n\\n        ans = []\\n\\n        for interval in intervals:\\n            if not ans or ans[-1][1] < interval[0]:\\n                ans.append(interval)\\n            else:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n        \\n        return ans\\n```\n```Java []\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\tmin = Math.min(min, intervals[i][0]);\\n\\t\\t\\tmax = Math.max(max, intervals[i][0]);\\n\\t\\t}\\n\\t\\t\\n\\t\\tint[] range = new int[max - min + 1];\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\trange[intervals[i][0] - min] = Math.max(intervals[i][1] - min, range[intervals[i][0] - min]); \\n\\t\\t}\\n\\t\\t\\n\\t\\tint start = 0, end = 0;\\n\\t\\tLinkedList<int[]> result = new LinkedList<>();\\n\\t\\tfor (int i = 0; i < range.length; i++) {\\n\\t\\t\\tif (range[i] == 0) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (i <= end) {\\n\\t\\t\\t\\tend = Math.max(range[i], end);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult.add(new int[] {start + min, end + min});\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\tend = range[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.add(new int[] {start + min, end + min});\\n\\t\\treturn result.toArray(new int[result.size()][]);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21242,
                "title": "c-10-line-solution-easing-understanding",
                "content": "    vector<Interval> merge(vector<Interval>& ins) {\\n        if (ins.empty()) return vector<Interval>{};\\n        vector<Interval> res;\\n        sort(ins.begin(), ins.end(), [](Interval a, Interval b){return a.start < b.start;});\\n        res.push_back(ins[0]);\\n        for (int i = 1; i < ins.size(); i++) {\\n            if (res.back().end < ins[i].start) res.push_back(ins[i]);\\n            else\\n                res.back().end = max(res.back().end, ins[i].end);\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    vector<Interval> merge(vector<Interval>& ins) {\\n        if (ins.empty()) return vector<Interval>{};\\n        vector<Interval> res;\\n        sort(ins.begin(), ins.end(), [](Interval a, Interval b){return a.start < b.start;});\\n        res.push_back(ins[0]);\\n        for (int i = 1; i < ins.size(); i++) {\\n            if (res.back().end < ins[i].start) res.push_back(ins[i]);\\n            else\\n                res.back().end = max(res.back().end, ins[i].end);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 482195,
                "title": "c-9-lines-99-run-time-easy-to-understand-solution",
                "content": "```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size()<=1) return intervals;\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n        output.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++) {\\n            if(output.back()[1] >= intervals[i][0]) output.back()[1] = max(output.back()[1] , intervals[i][1]);\\n            else output.push_back(intervals[i]); \\n        }\\n        return output;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size()<=1) return intervals;\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n        output.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++) {\\n            if(output.back()[1] >= intervals[i][0]) output.back()[1] = max(output.back()[1] , intervals[i][1]);\\n            else output.push_back(intervals[i]); \\n        }\\n        return output;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21223,
                "title": "beat-98-java-sort-start-end-respectively",
                "content": "  The idea is that for the result distinct Interval, the latter one's start must > previous one's end.\\n\\n    public List<Interval> merge(List<Interval> intervals) {\\n\\t\\t// sort start&end\\n\\t\\tint n = intervals.size();\\n\\t\\tint[] starts = new int[n];\\n\\t\\tint[] ends = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tstarts[i] = intervals.get(i).start;\\n\\t\\t\\tends[i] = intervals.get(i).end;\\n\\t\\t}\\n\\t\\tArrays.sort(starts);\\n\\t\\tArrays.sort(ends);\\n\\t\\t// loop through\\n\\t\\tList<Interval> res = new ArrayList<Interval>();\\n\\t\\tfor (int i = 0, j = 0; i < n; i++) { // j is start of interval.\\n\\t\\t\\tif (i == n - 1 || starts[i + 1] > ends[i]) {\\n\\t\\t\\t\\tres.add(new Interval(starts[j], ends[i]));\\n\\t\\t\\t\\tj = i + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "solutionTags": [],
                "code": "  The idea is that for the result distinct Interval, the latter one's start must > previous one's end.\\n\\n    public List<Interval> merge(List<Interval> intervals) {\\n\\t\\t// sort start&end\\n\\t\\tint n = intervals.size();\\n\\t\\tint[] starts = new int[n];\\n\\t\\tint[] ends = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tstarts[i] = intervals.get(i).start;\\n\\t\\t\\tends[i] = intervals.get(i).end;\\n\\t\\t}\\n\\t\\tArrays.sort(starts);\\n\\t\\tArrays.sort(ends);\\n\\t\\t// loop through\\n\\t\\tList<Interval> res = new ArrayList<Interval>();\\n\\t\\tfor (int i = 0, j = 0; i < n; i++) { // j is start of interval.\\n\\t\\t\\tif (i == n - 1 || starts[i + 1] > ends[i]) {\\n\\t\\t\\t\\tres.add(new Interval(starts[j], ends[i]));\\n\\t\\t\\t\\tj = i + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1644017,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanations",
                "content": "# **Two Types of Code || Normal & Solely relying on built in methods of STL library**\\n\\n**Intuition:-**\\nAfter reading the question we get that we need to merge the over lapping intervals and return the result by keeping the rest of the elements as it is.\\nTo find the overlapping intervals the intervals should be atleast sorted think about this .\\nThus for solving we need to sort and then check the consecutive intervals.  Once we find the overlapping interval. we will take the max element from it.\\n\\n**Algorithm:-**\\n1. Firstly, the base case : if there are no intervals return [] .\\n2. Sort the intervals .\\n3. While traversing the intervals vector we will come accross two coditions\\n* First condition : if there is a overlapping between the intervals then just take out the max element from the ending point and thus we merged them \\neg:- [1,4],[2,8]  =Mergerd intervals will be> [1,8]\\n* second condition : if there is no overlapping then simply push those interval to our resultant vector .\\n4. Now let\\'s move our finger\\'s to coding :)\\n \\n**Code type 1:-**\\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& interval) {\\n        vector<vector<int>> result;\\n        //base case when threr are no intervals\\n        if(interval.size()==0)return result;\\n        //sort takes O(nlogn) time\\n        sort(interval.begin(),interval.end());\\n        //insert the the the first interval in the result\\n        result.push_back(interval[0]);\\n        int j=0;\\n        //Traverse the whole vector .Takes O(n) time\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            //if intevals are overlapping\\n            if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Code type 2:-**\\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        //base case\\n        if(intervals.size()<=1) return intervals;\\n        //resultan vector\\n        vector<vector<int>> result;\\n        //sort takes O(nlogn) time\\n        sort(intervals.begin(), intervals.end()); \\n        //insert the the the first interval in the result\\n        result.push_back(intervals[0]);\\n         //Traverse the whole vector .Takes O(n) time\\n        for(int i=1; i<intervals.size(); i++) {\\n             //if intevals are overlapping\\n            if(result.back()[1] >= intervals[i][0]) result.back()[1] = max(result.back()[1] , intervals[i][1]);\\n            //else they are not overlapping\\n            else result.push_back(intervals[i]); \\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Time complexity :** *`O(nlogn) [for using the sort function] + O(n) [for traversing the interval] = O(nlogn)`*\\n**Space Complexity :** *`O(n) [For our resultant vector]`*\\n***\\n**Feel free to comment if you have some suggestions or upvote if you liked it.**\\n***\\nHere\\'s my [github link](https://github.com/Jatin-Shihora) where I keep my solutions.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& interval) {\\n        vector<vector<int>> result;\\n        //base case when threr are no intervals\\n        if(interval.size()==0)return result;\\n        //sort takes O(nlogn) time\\n        sort(interval.begin(),interval.end());\\n        //insert the the the first interval in the result\\n        result.push_back(interval[0]);\\n        int j=0;\\n        //Traverse the whole vector .Takes O(n) time\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            //if intevals are overlapping\\n            if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        //base case\\n        if(intervals.size()<=1) return intervals;\\n        //resultan vector\\n        vector<vector<int>> result;\\n        //sort takes O(nlogn) time\\n        sort(intervals.begin(), intervals.end()); \\n        //insert the the the first interval in the result\\n        result.push_back(intervals[0]);\\n         //Traverse the whole vector .Takes O(n) time\\n        for(int i=1; i<intervals.size(); i++) {\\n             //if intevals are overlapping\\n            if(result.back()[1] >= intervals[i][0]) result.back()[1] = max(result.back()[1] , intervals[i][1]);\\n            //else they are not overlapping\\n            else result.push_back(intervals[i]); \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350272,
                "title": "python3-sort-o-nlog-n",
                "content": "```\\nintervals [[1, 3], [2, 6], [8, 10], [15, 18]]\\nintervals.sort [[1, 3], [2, 6], [8, 10], [15, 18]]\\n\\ninterval = [1,3]\\nmerged =[]\\nnot merged:\\n\\tmerged =[ [1,3] ]\\n\\ninterval =[2,6]\\nmerged = [ [1,3] ]\\nmerged[-1][-1] = 3 > interval[0] = 2:\\n\\tmerged[-1][-1] = max(merged[-1][-1] = 3 ,interval[-1] = 6) =6\\nmerged = [[1,6]]\\n```\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key =lambda x: x[0])\\n        merged =[]\\n        for i in intervals:\\n\\t\\t\\t# if the list of merged intervals is empty \\n\\t\\t\\t# or if the current interval does not overlap with the previous,\\n\\t\\t\\t# simply append it.\\n            if not merged or merged[-1][-1] < i[0]:\\n                merged.append(i)\\n\\t\\t\\t# otherwise, there is overlap,\\n\\t\\t\\t#so we merge the current and previous intervals.\\n            else:\\n                merged[-1][-1] = max(merged[-1][-1], i[-1])\\n        return merged\\n```\\n\\n* Time complexity:\\n\\tIn python, use sort method to a list costs [O(nlogn)](https://wiki.python.org/moin/TimeComplexity), where n is the length of the list.\\n\\tThe for-loop used to merge intervals, costs O(n).\\n\\tO(nlogn)+O(n) = O(nlogn)\\n\\tSo the total time complexity is O(nlogn).\\n* Space complexity\\n\\tThe algorithm used a merged list and a variable i.\\n\\tIn the worst case, the merged list is equal to the length of the input intervals list. So the space complexity is O(n), where n is the length of the input list.\\n\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()\\n        merged = []\\n        for i in range(len(intervals)):\\n            if merged == []:\\n                merged.append(intervals[i])\\n            else:\\n                previous_end = merged[-1][1]\\n                current_start = intervals[i][0]\\n                current_end = intervals[i][1]\\n                if previous_end >= current_start: # overlap\\n                    merged[-1][1] = max(previous_end,current_end)\\n                else:\\n                    merged.append(intervals[i])\\n        return merged\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nintervals [[1, 3], [2, 6], [8, 10], [15, 18]]\\nintervals.sort [[1, 3], [2, 6], [8, 10], [15, 18]]\\n\\ninterval = [1,3]\\nmerged =[]\\nnot merged:\\n\\tmerged =[ [1,3] ]\\n\\ninterval =[2,6]\\nmerged = [ [1,3] ]\\nmerged[-1][-1] = 3 > interval[0] = 2:\\n\\tmerged[-1][-1] = max(merged[-1][-1] = 3 ,interval[-1] = 6) =6\\nmerged = [[1,6]]\\n```\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key =lambda x: x[0])\\n        merged =[]\\n        for i in intervals:\\n\\t\\t\\t# if the list of merged intervals is empty \\n\\t\\t\\t# or if the current interval does not overlap with the previous,\\n\\t\\t\\t# simply append it.\\n            if not merged or merged[-1][-1] < i[0]:\\n                merged.append(i)\\n\\t\\t\\t# otherwise, there is overlap,\\n\\t\\t\\t#so we merge the current and previous intervals.\\n            else:\\n                merged[-1][-1] = max(merged[-1][-1], i[-1])\\n        return merged\\n```\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()\\n        merged = []\\n        for i in range(len(intervals)):\\n            if merged == []:\\n                merged.append(intervals[i])\\n            else:\\n                previous_end = merged[-1][1]\\n                current_start = intervals[i][0]\\n                current_end = intervals[i][1]\\n                if previous_end >= current_start: # overlap\\n                    merged[-1][1] = max(previous_end,current_end)\\n                else:\\n                    merged.append(intervals[i])\\n        return merged\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186112,
                "title": "best-c-solution-ever-sorting-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Array + Sorting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(NlogN), Sorting the array(intervals) costs O(NlogN). Where N is the size of the Vector(intervals).\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), Constant Space. Extra space is only allocated for the Vector(output) which can go upto size N , however the output does not count towards the space complexity.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(NlogN), Sorting the array(intervals) costs O(NlogN). Where N is the size of\\n    the Vector(intervals).\\n\\n    Space Complexity : O(1), Constant Space. Extra space is only allocated for the Vector(output)\\n    which can go upto size N , however the output does not count towards the space complexity.\\n\\n    Solved using Array + Sorting.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n        for(auto interval : intervals){\\n            if(output.empty() || output.back()[1] < interval[0]){\\n                output.push_back(interval);\\n            }\\n            else{\\n                output.back()[1] = max(output.back()[1], interval[1]);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(NlogN), Sorting the array(intervals) costs O(NlogN). Where N is the size of\\n    the Vector(intervals).\\n\\n    Space Complexity : O(1), Constant Space. Extra space is only allocated for the Vector(output)\\n    which can go upto size N , however the output does not count towards the space complexity.\\n\\n    Solved using Array + Sorting.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n        for(auto interval : intervals){\\n            if(output.empty() || output.back()[1] < interval[0]){\\n                output.push_back(interval);\\n            }\\n            else{\\n                output.back()[1] = max(output.back()[1], interval[1]);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600013,
                "title": "c-solution-with-detailed-explanation",
                "content": "```\\nInitially sort the array and then push the first element into the answer for speculation.\\nWe have two condition if the first elements second part of ans array is greater than or equal to the second element first part of the \\ninterval array.\\nThe other condition we have to tackle is what if its not? then we push the particular element into the ans array which will be then be under speculation.\\ninterval: [[1,3],[2,6],[8,10],[15,18]]\\n             i\\nWe initally push the 1st element into the ans array:\\nans=[[1,3]]\\n      j        j points to the latest pushed element\\nThen we i is incremented.\\n[[1,3],[2,6],[8,10],[15,18]]\\n         i\\nNow the ans[j][1]>interval[i][0] this means there is a possiblity of merging so we merger them\\nRemember the way we merge is to take the second element as max(ans[j][1],interval[i][1])\\ncuz imagine we have this\\n[1,7][2,4] --->merge should be ---->[1,7]\\n\\nans=[[1,6]]\\n\\nthen we move i forward\\n\\n[[1,3],[2,6],[8,10],[15,18]]\\n               i\\nSince ans[j][1]<interval[i][0] thus not contributing to the merge.\\nThus we will push this into the ans array and speculate.\\n\\nans=[[1,6][8,10]]\\n            j   <----j is moved forward\\ni is moved forward \\n[[1,3],[2,6],[8,10],[15,18]]\\n                       i\\nSince ans[j][1]<interval[i][0] thus not contributing to the merge.\\nans=[[1,6][8,10][15,18]]\\n                  j\\n\\nThus yielding our final answer.\\n\\n    vector<vector<int>> merge(vector<vector<int>>& interval) {\\n        vector<vector<int>> ans;\\n        if(interval.size()==0)return ans;\\n        sort(interval.begin(),interval.end());\\n        ans.push_back(interval[0]);\\n        int j=0;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            if(ans[j][1]>=interval[i][0])\\n                ans[j][1]=max(ans[j][1],interval[i][1]);\\n            else\\n            {\\n                j++;\\n                ans.push_back(interval[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nInitially sort the array and then push the first element into the answer for speculation.\\nWe have two condition if the first elements second part of ans array is greater than or equal to the second element first part of the \\ninterval array.\\nThe other condition we have to tackle is what if its not? then we push the particular element into the ans array which will be then be under speculation.\\ninterval: [[1,3],[2,6],[8,10],[15,18]]\\n             i\\nWe initally push the 1st element into the ans array:\\nans=[[1,3]]\\n      j        j points to the latest pushed element\\nThen we i is incremented.\\n[[1,3],[2,6],[8,10],[15,18]]\\n         i\\nNow the ans[j][1]>interval[i][0] this means there is a possiblity of merging so we merger them\\nRemember the way we merge is to take the second element as max(ans[j][1],interval[i][1])\\ncuz imagine we have this\\n[1,7][2,4] --->merge should be ---->[1,7]\\n\\nans=[[1,6]]\\n\\nthen we move i forward\\n\\n[[1,3],[2,6],[8,10],[15,18]]\\n               i\\nSince ans[j][1]<interval[i][0] thus not contributing to the merge.\\nThus we will push this into the ans array and speculate.\\n\\nans=[[1,6][8,10]]\\n            j   <----j is moved forward\\ni is moved forward \\n[[1,3],[2,6],[8,10],[15,18]]\\n                       i\\nSince ans[j][1]<interval[i][0] thus not contributing to the merge.\\nans=[[1,6][8,10][15,18]]\\n                  j\\n\\nThus yielding our final answer.\\n\\n    vector<vector<int>> merge(vector<vector<int>>& interval) {\\n        vector<vector<int>> ans;\\n        if(interval.size()==0)return ans;\\n        sort(interval.begin(),interval.end());\\n        ans.push_back(interval[0]);\\n        int j=0;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            if(ans[j][1]>=interval[i][0])\\n                ans[j][1]=max(ans[j][1],interval[i][1]);\\n            else\\n            {\\n                j++;\\n                ans.push_back(interval[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355318,
                "title": "fully-explained-and-clean-interval-tree-for-facebook-follow-up-no-sorting",
                "content": "Inspired by https://leetcode.com/problems/merge-intervals/discuss/21452/Share-my-interval-tree-solution-no-sorting\\n\\n**Question**: How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\\n\\nWe need to have two functions for the tree (`add` interval and `query` tree). \\n\\n##### Implementation Details\\n`TreeNode` - On top of the left child, right child, start boundary, and end boundary, we have a **`middle` field** that determines whether a new interval goes to the left child, right right or merged with the current node.\\n\\n`add` - If the new interval touches or crosses the `middle` of the current node, we update the current node. Otherwise, we put the new interval into the left subtree or right subtree. \\n- Why do we use `middle` for comparison and not `start` or `end` boundaries? \\nThe reason is that we can use merge-sort technique to `query` the merged intervals result when the left subtree does not overlap with the right subtree. \\n\\n`query` - Use merge-sort technique by retrieving the merged intervals of the left subtree (i.e. `left_intervals`) and those of the right subtree (i.e. `right_intervals`). Because of the implementation of `add`, we can guarantee that\\n- if there\\'s an interval in the `left_intervals` that overlaps with the current node, then we know that all the intervals after that interval overlaps with the current node.\\n- The first few intervals or zero intervals in the `right_intervals` overlap with the current node.  \\n\\nHere\\'s the visualization:\\n```\\nleft_res = [ (intervals that do not overlap), (intervals that overlap with current node) ]\\nright_res = [ (intervals that overlap with current node), (intervals that do not overlap) ]\\n```\\n\\n##### Code\\n\\n```python\\nclass TreeNode:\\n    def __init__(self, start, end, middle):\\n        self.start = start\\n        self.end = end\\n        self.middle = middle\\n        self.left = self.right = None\\n\\nclass Solution:\\n    def __init__(self):\\n        self.root = None\\n    \\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if not intervals:\\n            return []\\n        \\n        for start, end in intervals:\\n            if not self.root:\\n                self.root = TreeNode(start, end, (start + end) // 2)\\n            else:\\n                self.add(self.root, start, end)\\n        \\n        return self.query(self.root)\\n    \\n    \\n    def add(self, node, start, end):     \\n        if end < node.middle:\\n            if node.left:\\n                self.add(node.left, start, end)\\n            else:\\n                node.left = TreeNode(start, end, (start + end) // 2)\\n        \\n        elif start > node.middle:\\n            if node.right:\\n                self.add(node.right, start, end)\\n            else:\\n                node.right = TreeNode(start, end, (start + end) // 2)\\n        \\n        else:\\n            node.start = min(node.start, start)\\n            node.end = max(node.end, end)\\n    \\n    def query(self, node):\\n        if not node:\\n            return []\\n        \\n        # merge-sort divide and conquer\\n        left_intervals = self.query(node.left)\\n        right_intervals = self.query(node.right)\\n        res = []\\n        \\n        inserted = False\\n        \\n        for lres in left_intervals:\\n            if lres[1] < node.start:\\n                res.append(lres)\\n            else:\\n                res.append([min(lres[0], node.start), node.end])\\n                inserted = True\\n                break\\n        \\n        if not inserted:\\n            res.append([node.start, node.end])\\n        \\n        for rres in right_intervals:\\n            if rres[0] <= node.end:\\n                res[-1][1] = max(node.end, rres[1])\\n            else:\\n                res.append(rres)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nleft_res = [ (intervals that do not overlap), (intervals that overlap with current node) ]\\nright_res = [ (intervals that overlap with current node), (intervals that do not overlap) ]\\n```\n```python\\nclass TreeNode:\\n    def __init__(self, start, end, middle):\\n        self.start = start\\n        self.end = end\\n        self.middle = middle\\n        self.left = self.right = None\\n\\nclass Solution:\\n    def __init__(self):\\n        self.root = None\\n    \\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if not intervals:\\n            return []\\n        \\n        for start, end in intervals:\\n            if not self.root:\\n                self.root = TreeNode(start, end, (start + end) // 2)\\n            else:\\n                self.add(self.root, start, end)\\n        \\n        return self.query(self.root)\\n    \\n    \\n    def add(self, node, start, end):     \\n        if end < node.middle:\\n            if node.left:\\n                self.add(node.left, start, end)\\n            else:\\n                node.left = TreeNode(start, end, (start + end) // 2)\\n        \\n        elif start > node.middle:\\n            if node.right:\\n                self.add(node.right, start, end)\\n            else:\\n                node.right = TreeNode(start, end, (start + end) // 2)\\n        \\n        else:\\n            node.start = min(node.start, start)\\n            node.end = max(node.end, end)\\n    \\n    def query(self, node):\\n        if not node:\\n            return []\\n        \\n        # merge-sort divide and conquer\\n        left_intervals = self.query(node.left)\\n        right_intervals = self.query(node.right)\\n        res = []\\n        \\n        inserted = False\\n        \\n        for lres in left_intervals:\\n            if lres[1] < node.start:\\n                res.append(lres)\\n            else:\\n                res.append([min(lres[0], node.start), node.end])\\n                inserted = True\\n                break\\n        \\n        if not inserted:\\n            res.append([node.start, node.end])\\n        \\n        for rres in right_intervals:\\n            if rres[0] <= node.end:\\n                res[-1][1] = max(node.end, rres[1])\\n            else:\\n                res.append(rres)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644409,
                "title": "c-python-simple-solutions-w-explanation-sort-merge-o-nlogn-count-sort-o-n-r",
                "content": "We are given array of intervals and we need to merge all the overlapping intervals\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Sort & Merge)***\\n\\nTwo intervals `i1` and `i2` overlap only if `i1[1] >= i2[0]` and `i2[1] >= i1[0]` or vice-versa. So, whenever we find two such intervals, we need to merge them as `[min(i1[0], i2[0]), max(i1[1], i2[1])]`. However, directly using this approach would require us compare each pair of intervals, merge them if they overlap and restart the same process & continue the same till we dont find any overlapping between any pairs. This would lead to more than `O(N^2)` time complexity.\\n\\nA better approach would be to sort the given intervals first. This would allow us to iterate one by one and only compare between adjacent pair of intervals instead of every pair. We can maintain a sorted list and merge/insert new intervals one by one. Since, we have sorted the intervals, one of the condition of overlap is already satisfied - `i2[1] >= i1[0]` (since `i2[0] >= i1[0]` after sort & `i2[1] >= i2[0]`). \\n\\nThus, we only need to check if the new interval\\'s start (`i[0]` in below code) is <= last interval of sorted list (`ans.back()[1]`) formed till now. If it is overlapping, then we merge the two intervals by updating the last interval of the sorted list. If the intervals dont overlap, we can just add the new interval to the end of sorted list.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        sort(begin(I), end(I));\\n        vector<vector<int>> ans {I[0]};                        // adding 1st interval to avoid checking ans.empty() each time in loop\\n        for(auto i : I)\\n            if(i[0] <= ans.back()[1])                          // merge intervals if they overlap\\n                ans.back()[1] = max(ans.back()[1], i[1]);\\n            else                                               // else insert new interval\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def merge(self, I):\\n        I.sort()\\n        ans = [I[0]]\\n        for i in I:\\n            if i[0] <= ans[-1][1]:\\n                ans[-1][1] = max(ans[-1][1], i[1])\\n            else:\\n                ans.append(i)\\n        return ans\\n```\\n\\n***Time Complexity :*** <code>O(NlogN)</code>\\n***Space Complexity :*** `O(sort)`, required for in-built sort algortihm. The extra space used for output is generally not included in space complexity.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Inplace Merge)***\\n\\nYou could further optimize on space if you are allowed to modify the input itself in which case you can directly merge in-place. We could keep track of length of sorted sub-list in `I` in an variable `R` (denoting right end of sorted list formed till now). The rest of logic would be same as above. We would just replace last interval of sorted list denoted by `ans.back()` in previous approach with `I[R]` since we are merge inplace.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        sort(begin(I), end(I));\\n        int R = 0;\\n        for(auto i : I)\\n            if(i[0] <= I[R][1])                          \\n                I[R][1] = max(I[R][1], i[1]);\\n            else                                              \\n                I[++R] = i;\\n        I.resize(R+1);\\n        return I;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def merge(self, I):\\n        I.sort()\\n        R = 0\\n        for i in I:\\n            if i[0] <= I[R][1]:\\n                I[R][1] = max(I[R][1], i[1])\\n            else:\\n                I[(R := R + 1)] = i\\n        return I[:R+1]\\n```\\n\\n***Time Complexity :*** <code>O(NlogN)</code>\\n***Space Complexity :*** `O(sort)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Counting Sort & Merge)***\\n\\nWe can sort the intervals using counting sort as well. This approach would be more efficient if the number of intervals are greater but the range is small. \\n\\nWe declare an array `ends` of length equal to greatest start of an interval. `ends[i]` will store the array of ends of interval starting at `i`. Once we fill `ends` using intervals from `I`, we can update intervals back into `I` in a sorted order. The rest of the code remains the same\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    void countingSort(vector<vector<int>>& I) {\\n        int range = 1 + (*max_element(begin(I), end(I), [](auto& i1, auto& i2){return i1[0] < i2[0];}))[0];\\n        vector<vector<int>> ends(range);          // ends[i] stores array of ends of interval starting at i\\n        for(auto& i : I) \\n            ends[i[0]].push_back(i[1]);\\n        for(int i = 0, j = 0; i < range; i++)     // insert intervals back into I in sorted order\\n            for(auto end : ends[i])\\n                I[j++] = {i, end};\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        countingSort(I);\\n        int R = 0;\\n        for(auto i : I)\\n            if(i[0] <= I[R][1])\\n                I[R][1] = max(I[R][1], i[1]);\\n            else               \\n                I[++R] = i;\\n        I.resize(R+1);\\n        return I;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def merge(self, I):\\n        def countingSort():\\n            ends, j = defaultdict(list), 0\\n            for i in I:\\n                ends[i[0]].append(i[1])\\n            for i in range(1 + max(I, key = lambda i : i[0])[0]):\\n                for end in ends[i]:\\n                    I[j] = [i, end]\\n                    j += 1\\n                    \\n        countingSort()\\n        R = 0\\n        for i in I:\\n            if i[0] <= I[R][1]:\\n                I[R][1] = max(I[R][1], i[1])\\n            else:\\n                I[(R := R + 1)] = i\\n        return I[:R+1]\\n```\\n\\n***Time Complexity :*** <code>O(N + R)</code>, where `R` is the range of intervals determined by largest start value of an interval\\n***Space Complexity :*** `O(R)`, required for storing `ends`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        sort(begin(I), end(I));\\n        vector<vector<int>> ans {I[0]};                        // adding 1st interval to avoid checking ans.empty() each time in loop\\n        for(auto i : I)\\n            if(i[0] <= ans.back()[1])                          // merge intervals if they overlap\\n                ans.back()[1] = max(ans.back()[1], i[1]);\\n            else                                               // else insert new interval\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def merge(self, I):\\n        I.sort()\\n        ans = [I[0]]\\n        for i in I:\\n            if i[0] <= ans[-1][1]:\\n                ans[-1][1] = max(ans[-1][1], i[1])\\n            else:\\n                ans.append(i)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        sort(begin(I), end(I));\\n        int R = 0;\\n        for(auto i : I)\\n            if(i[0] <= I[R][1])                          \\n                I[R][1] = max(I[R][1], i[1]);\\n            else                                              \\n                I[++R] = i;\\n        I.resize(R+1);\\n        return I;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def merge(self, I):\\n        I.sort()\\n        R = 0\\n        for i in I:\\n            if i[0] <= I[R][1]:\\n                I[R][1] = max(I[R][1], i[1])\\n            else:\\n                I[(R := R + 1)] = i\\n        return I[:R+1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void countingSort(vector<vector<int>>& I) {\\n        int range = 1 + (*max_element(begin(I), end(I), [](auto& i1, auto& i2){return i1[0] < i2[0];}))[0];\\n        vector<vector<int>> ends(range);          // ends[i] stores array of ends of interval starting at i\\n        for(auto& i : I) \\n            ends[i[0]].push_back(i[1]);\\n        for(int i = 0, j = 0; i < range; i++)     // insert intervals back into I in sorted order\\n            for(auto end : ends[i])\\n                I[j++] = {i, end};\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        countingSort(I);\\n        int R = 0;\\n        for(auto i : I)\\n            if(i[0] <= I[R][1])\\n                I[R][1] = max(I[R][1], i[1]);\\n            else               \\n                I[++R] = i;\\n        I.resize(R+1);\\n        return I;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def merge(self, I):\\n        def countingSort():\\n            ends, j = defaultdict(list), 0\\n            for i in I:\\n                ends[i[0]].append(i[1])\\n            for i in range(1 + max(I, key = lambda i : i[0])[0]):\\n                for end in ends[i]:\\n                    I[j] = [i, end]\\n                    j += 1\\n                    \\n        countingSort()\\n        R = 0\\n        for i in I:\\n            if i[0] <= I[R][1]:\\n                I[R][1] = max(I[R][1], i[1])\\n            else:\\n                I[(R := R + 1)] = i\\n        return I[:R+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21452,
                "title": "share-my-interval-tree-solution-no-sorting",
                "content": "I want to do it without sorting, because:\\nhttps://leetcode.com/discuss/67748/share-my-bst-interval-tree-solution-c-no-sorting?show=67748#q67748\\n\\nIn that post, I used BST of intervals. However, as you can see from that post, if each node is an interval, it is very difficult to keep each node disjoint. Although that code achieved this, it is hard to read. \\n\\nSo, I use interval tree in this post. You can google and find its variations, I am using the basic structure. Basically, each node will maintains a lot of intervals, depending on whether the interval intersect the middle of the node. It is easy to insert/delete an interval. The only difficult is: given an interval tree, how to get the final result, how to merge them in the final step?\\n\\n    class IntervalTree{\\n    public:\\n        int middle;\\n        int start, end;\\n        IntervalTree *left, *right;\\n        IntervalTree(int s, int e): start(s), end(e), middle((s+e)/2){\\n            this->left=this->right=NULL;\\n        }\\n};\\n\\n\\n    void InsertInterval(IntervalTree *node, Interval \\xa4tInterval){\\n    if(node == NULL)\\n        return;\\n\\n    if(currentInterval.end<node->middle){\\n        if(node->left)\\n            return InsertInterval(node->left, currentInterval);\\n        else{\\n            IntervalTree *newnode = new IntervalTree(currentInterval.start, currentInterval.end);\\n            node->left = newnode;\\n            return;\\n        }\\n    }\\n\\n    if(currentInterval.start>node->middle){\\n        if(node->right)\\n            return InsertInterval(node->right, currentInterval);\\n        else{\\n            IntervalTree *newnode = new IntervalTree(currentInterval.start, currentInterval.end);\\n            node->right = newnode;\\n            return;\\n        }\\n    }\\n\\n    //insert it to current node\\n    node->start=min(node->start, currentInterval.start);\\n    node->end=max(node->end, currentInterval.end);\\n\\n}\\n\\nSo, when you want to merge the intervals, you will do something like below:\\n\\n    void QueryInterval(vector<Interval> &retV, IntervalTree *node){\\n    //retV is the return vector\\n    vector<Interval> leftIntervals;\\n    vector<Interval> rightIntervals;\\n\\n    bool mergeleft = false; //whether current node merge with any intervals from left child. \\n    if(node->left){\\n        //return the merge of all intervals in left child. \\n        QueryInterval(leftIntervals, node->left);\\n        //merge left interval with myself. \\n        MergeLeftInterval(leftIntervals, node, retV, mergeleft);\\n    }\\n    if(!mergeleft){ //if we did not merge left intervals, add a new one\\n        Interval newinterval;\\n        newinterval.start = node->start;\\n        newinterval.end = node->end;\\n        retV.push_back(newinterval);\\n    }\\n    \\n    if(node->right){\\n        QueryInterval(rightIntervals, node->right);\\n        MergeRightInterval(rightIntervals, node, retV);\\n    }\\n    \\n    return;\\n}\\n\\n\\nAnd finally, the 2 child functions used above:\\n\\n    void MergeLeftInterval(vector<Interval> &leftIntervals, IntervalTree *node, vector<Interval> &retV, bool &merged){\\n    for(int i=0; i<leftIntervals.size(); i++){\\n        if(leftIntervals[i].end>=node->start){\\n            Interval newinterval;\\n            newinterval.start = min(leftIntervals[i].start, node->start);\\n            newinterval.end = node->end;\\n            retV.push_back(newinterval);\\n            merged = true;\\n            break;\\n        }\\n        else{\\n            retV.push_back(leftIntervals[i]);\\n        }\\n    }\\n}\\n\\nvoid MergeRightInterval(vector<Interval> &rightIntervals, IntervalTree *node, vector<Interval> &retV){\\n    for(int i=0; i<rightIntervals.size(); i++){\\n        if(rightIntervals[i].start<=node->end){\\n            retV[retV.size()-1].end = max(rightIntervals[i].end, node->end);\\n        }\\n        else{\\n            retV.push_back(rightIntervals[i]);\\n        }\\n    }\\n}",
                "solutionTags": [
                    "C++"
                ],
                "code": "I want to do it without sorting, because:\\nhttps://leetcode.com/discuss/67748/share-my-bst-interval-tree-solution-c-no-sorting?show=67748#q67748\\n\\nIn that post, I used BST of intervals. However, as you can see from that post, if each node is an interval, it is very difficult to keep each node disjoint. Although that code achieved this, it is hard to read. \\n\\nSo, I use interval tree in this post. You can google and find its variations, I am using the basic structure. Basically, each node will maintains a lot of intervals, depending on whether the interval intersect the middle of the node. It is easy to insert/delete an interval. The only difficult is: given an interval tree, how to get the final result, how to merge them in the final step?\\n\\n    class IntervalTree{\\n    public:\\n        int middle;\\n        int start, end;\\n        IntervalTree *left, *right;\\n        IntervalTree(int s, int e): start(s), end(e), middle((s+e)/2){\\n            this->left=this->right=NULL;\\n        }\\n};\\n\\n\\n    void InsertInterval(IntervalTree *node, Interval \\xa4tInterval){\\n    if(node == NULL)\\n        return;\\n\\n    if(currentInterval.end<node->middle){\\n        if(node->left)\\n            return InsertInterval(node->left, currentInterval);\\n        else{\\n            IntervalTree *newnode = new IntervalTree(currentInterval.start, currentInterval.end);\\n            node->left = newnode;\\n            return;\\n        }\\n    }\\n\\n    if(currentInterval.start>node->middle){\\n        if(node->right)\\n            return InsertInterval(node->right, currentInterval);\\n        else{\\n            IntervalTree *newnode = new IntervalTree(currentInterval.start, currentInterval.end);\\n            node->right = newnode;\\n            return;\\n        }\\n    }\\n\\n    //insert it to current node\\n    node->start=min(node->start, currentInterval.start);\\n    node->end=max(node->end, currentInterval.end);\\n\\n}\\n\\nSo, when you want to merge the intervals, you will do something like below:\\n\\n    void QueryInterval(vector<Interval> &retV, IntervalTree *node){\\n    //retV is the return vector\\n    vector<Interval> leftIntervals;\\n    vector<Interval> rightIntervals;\\n\\n    bool mergeleft = false; //whether current node merge with any intervals from left child. \\n    if(node->left){\\n        //return the merge of all intervals in left child. \\n        QueryInterval(leftIntervals, node->left);\\n        //merge left interval with myself. \\n        MergeLeftInterval(leftIntervals, node, retV, mergeleft);\\n    }\\n    if(!mergeleft){ //if we did not merge left intervals, add a new one\\n        Interval newinterval;\\n        newinterval.start = node->start;\\n        newinterval.end = node->end;\\n        retV.push_back(newinterval);\\n    }\\n    \\n    if(node->right){\\n        QueryInterval(rightIntervals, node->right);\\n        MergeRightInterval(rightIntervals, node, retV);\\n    }\\n    \\n    return;\\n}\\n\\n\\nAnd finally, the 2 child functions used above:\\n\\n    void MergeLeftInterval(vector<Interval> &leftIntervals, IntervalTree *node, vector<Interval> &retV, bool &merged){\\n    for(int i=0; i<leftIntervals.size(); i++){\\n        if(leftIntervals[i].end>=node->start){\\n            Interval newinterval;\\n            newinterval.start = min(leftIntervals[i].start, node->start);\\n            newinterval.end = node->end;\\n            retV.push_back(newinterval);\\n            merged = true;\\n            break;\\n        }\\n        else{\\n            retV.push_back(leftIntervals[i]);\\n        }\\n    }\\n}\\n\\nvoid MergeRightInterval(vector<Interval> &rightIntervals, IntervalTree *node, vector<Interval> &retV){\\n    for(int i=0; i<rightIntervals.size(); i++){\\n        if(rightIntervals[i].start<=node->end){\\n            retV[retV.size()-1].end = max(rightIntervals[i].end, node->end);\\n        }\\n        else{\\n            retV.push_back(rightIntervals[i]);\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 21276,
                "title": "a-clean-java-solution",
                "content": "    public class Solution {\\n        public List<Interval> merge(List<Interval> intervals) {\\n            Collections.sort(intervals, new Comparator<Interval>(){\\n                @Override\\n                public int compare(Interval obj0, Interval obj1) {\\n                    return obj0.start - obj1.start;\\n                }\\n            });\\n    \\n            List<Interval> ret = new ArrayList<>();\\n            Interval prev = null;\\n            for (Interval inter : intervals) {\\n                if (  prev==null || inter.start>prev.end ) {\\n                    ret.add(inter);\\n                    prev = inter;\\n                } else if (inter.end>prev.end) {\\n                    // Modify the element already in list\\n                    prev.end = inter.end;\\n                }\\n            }\\n            return ret;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Interval> merge(List<Interval> intervals) {\\n            Collections.sort(intervals, new Comparator<Interval>(){\\n                @Override\\n                public int compare(Interval obj0, Interval obj1) {\\n                    return obj0.start - obj1.start;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 179876,
                "title": "thinking-process",
                "content": "In order to merge overlapped intervals, we should be able to tell whether two intervals are overlapped.\\n\\nGiven two intervals `[a, b]` and `[c, d]`, they do not overlap with each other if `b < c or d < a`.\\n\\nSo they overlap if `a <= d and c <= b` as below examples:\\n```\\n1)\\n-----\\na   b\\n\\n  -----\\n  c   d\\n2)\\n\\t-----\\n\\ta   b\\n\\n  -----\\n  c   d\\n```\\n\\nIf we sort intervals by starts of both intervals, then `a <= c`, since `c < d`, so `a < d` -- one requirement of overlapped intervals is met.\\n\\nThus, after we sort intervals by starts, two intervals overlap if `c <= b`.\\n\\nAll in all, we sort the intervals given in the problem by starts, and then iterate through the sorted intervals - we merge overlapped intervals on the fly.\\n\\nIs that one-pass enough to merge over-lapped intervals? Yes, since intervals[i + 1] cannot overlap with intervals[i - 1] if intervals[i] doesn\\'t in the sorted sequence.\\n****\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda interval : interval[0])\\n        res = [intervals[0]]\\n        for [start, end] in intervals:\\n            prev_start, prev_end = res[-1]\\n            if start <= prev_end:  # overlap\\n                res.pop()\\n                res.append([prev_start, max(prev_end, end)])\\n            else:\\n                res.append([start, end])\\n        return res\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n1)\\n-----\\na   b\\n\\n  -----\\n  c   d\\n2)\\n\\t-----\\n\\ta   b\\n\\n  -----\\n  c   d\\n```\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda interval : interval[0])\\n        res = [intervals[0]]\\n        for [start, end] in intervals:\\n            prev_start, prev_end = res[-1]\\n            if start <= prev_end:  # overlap\\n                res.pop()\\n                res.append([prev_start, max(prev_end, end)])\\n            else:\\n                res.append([start, end])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21332,
                "title": "short-python-solution",
                "content": "Sort the list first. Check if the new interval overlaps with the previous one in the output list. If yes, update it. Otherwise, append the new one.\\n\\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            if len(intervals) == 0: return []\\n            intervals = sorted(intervals, key = lambda x: x.start)\\n            res = [intervals[0]]\\n            for n in intervals[1:]:\\n                if n.start <= res[-1].end: res[-1].end = max(n.end, res[-1].end)\\n                else: res.append(n)\\n            return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "Sort the list first. Check if the new interval overlaps with the previous one in the output list. If yes, update it. Otherwise, append the new one.\\n\\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            if len(intervals) == 0: return []\\n            intervals = sorted(intervals, key = lambda x: x.start)\\n            res = [intervals[0]]\\n            for n in intervals[1:]:\\n                if n.start <= res[-1].end: res[-1].end = max(n.end, res[-1].end)\\n                else: res.append(n)\\n            return res",
                "codeTag": "Java"
            },
            {
                "id": 1644169,
                "title": "java-simple-steps-explained-simple-sort",
                "content": "# \\u2705 Approach 1 : Sorting \\n\\n---\\n\\n> ##### Sort by start of intervals, keep track of merging interval\\n\\n\\nOur task in this question is to merge the intervals which can merge:\\n* Only those intervals can merge whose start lies between the start and end of other interval .\\n*  I1 =  [1,5]   and I2 = [2,8] ,these intervals can merge as the start of I2 is lies between then interval range of I1\\n*  Now inorder to know adjacent interval which  can possibly merge we will sort all interval on the basis of start \\n\\n\\n**Steps :**\\n\\n---\\n* **Take some initial range** ( taking 0th index interval as initial range)\\n* Now, start iterating from 1 index in intervals array\\n* if its start lies in intial range , then increase your range by \\n```\\t \\t \\n\\t\\t\\t\\t\\t end =  Math.max(end,interval[i][1])                       `\\t\\t \\n```\\n * if there is no intersection of this interval with our range then add this range in ans arraylis and intialize new range by current index interval\\n \\n ####  Lets see code for more better understanding \\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83D\\uDCBB\\uD83D\\uDCBB :\\n ---\\n \\n ```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        \\n\\t\\t// sort our intervals \\n      Arrays.sort(intervals, (o1,o2)->o1[0]-o2[0]);\\n   \\n        ArrayList<int[]> ans  =  new ArrayList<>();\\n\\t\\t// intial range \\n        int start  =  intervals[0][0];\\n        int end =  intervals[0][1]; \\n        \\n        int  i =1;\\n        while(i<intervals.length){\\n            int s = intervals[i][0];\\n            int e = intervals[i][1];\\n            // next interval start is smaller than prev end and array is sorted\\n            // so these two internal can merge\\n            if( s<=end  ) { \\n                // so merge both intervals \\n                end =  Math.max(end,e);\\n            }\\n            else{ // if merge not possible , then insert prev interval into list\\n                ans.add(new int[]{start,end});\\n                start = s;\\n                end =  e;                \\n            }\\n           i++;\\n        }\\n        \\n        ans.add(new int[] {start,end});\\n\\t\\t\\n\\t\\t  int arr[][] =  new int[ans.size()][];\\n\\t        for(int i=0;i<ans.size();i++) {\\n\\t        \\tint a[] =  new int[2];\\n\\t        \\tfor(int j=0;j<2;j++) {\\n\\t        \\t\\ta[j] =  ans.get(i).get(j);\\n\\t        \\t}\\n\\t        \\tarr[i] =  a;\\n\\t        }\\n\\t        \\n\\t        return   arr;\\n\\t\\t\\n\\t\\t // or \\n\\t\\t //  return ans.toArray(new int[0][]);\\n        \\n        \\n        \\n    }\\n}\\n```\\n\\n\\n\\n\\n---\\n\\n# **\\u2705** Approach 2 : Using TreeSet\\n\\n\\n\\n\\n```\\nclass Solution {\\n\\n    public int[][] merge(int[][] intervals) {       \\n        for (int interval[] : intervals) {\\n            add(interval[0], interval[1]);\\n        }\\n        int i = 0;\\n        int ans[][] = new int[map.size()][2];\\n        for (Map.Entry<Integer, Integer> it : map.entrySet()) {\\n            ans[i++] = new int[] { it.getKey(), it.getValue() };\\n        }\\n        return ans;\\n    }\\n\\n\\t// storing , {start,end} of interval \\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n    public void add(int left, int right) {\\n\\t\\t// finding greatest , smaller key than right \\n        if (map.floorKey(right) == null || map.get(map.floorKey(right)) < left) {\\n            map.put(left, right);\\n        } else {\\n            int start = left, end = right;\\n            while (true) {\\n                int l = map.floorKey(end);\\n                int r = map.get(l);\\n                start = Math.min(l, start);\\n                end = Math.max(r, end);\\n\\n                map.remove(l);\\n\\t\\t\\t\\t// if no longer merge can be done then break\\n                if (map.floorKey(end) == null || map.get(map.floorKey(end)) < start) {\\n                    break;\\n                }\\n            }\\n\\n            map.put(start, end);\\n        }\\n    }\\n}\\n\\n```\\n\\n >**Time Complexity** : **n*logn** , (each add operation  armotrised logn  )\\n >**space : O(n)**\\n >\\n\\n\\n### Do upvote if found useful\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\t \\t \\n\\t\\t\\t\\t\\t end =  Math.max(end,interval[i][1])                       `\\t\\t \\n```\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        \\n\\t\\t// sort our intervals \\n      Arrays.sort(intervals, (o1,o2)->o1[0]-o2[0]);\\n   \\n        ArrayList<int[]> ans  =  new ArrayList<>();\\n\\t\\t// intial range \\n        int start  =  intervals[0][0];\\n        int end =  intervals[0][1]; \\n        \\n        int  i =1;\\n        while(i<intervals.length){\\n            int s = intervals[i][0];\\n            int e = intervals[i][1];\\n            // next interval start is smaller than prev end and array is sorted\\n            // so these two internal can merge\\n            if( s<=end  ) { \\n                // so merge both intervals \\n                end =  Math.max(end,e);\\n            }\\n            else{ // if merge not possible , then insert prev interval into list\\n                ans.add(new int[]{start,end});\\n                start = s;\\n                end =  e;                \\n            }\\n           i++;\\n        }\\n        \\n        ans.add(new int[] {start,end});\\n\\t\\t\\n\\t\\t  int arr[][] =  new int[ans.size()][];\\n\\t        for(int i=0;i<ans.size();i++) {\\n\\t        \\tint a[] =  new int[2];\\n\\t        \\tfor(int j=0;j<2;j++) {\\n\\t        \\t\\ta[j] =  ans.get(i).get(j);\\n\\t        \\t}\\n\\t        \\tarr[i] =  a;\\n\\t        }\\n\\t        \\n\\t        return   arr;\\n\\t\\t\\n\\t\\t // or \\n\\t\\t //  return ans.toArray(new int[0][]);\\n        \\n        \\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public int[][] merge(int[][] intervals) {       \\n        for (int interval[] : intervals) {\\n            add(interval[0], interval[1]);\\n        }\\n        int i = 0;\\n        int ans[][] = new int[map.size()][2];\\n        for (Map.Entry<Integer, Integer> it : map.entrySet()) {\\n            ans[i++] = new int[] { it.getKey(), it.getValue() };\\n        }\\n        return ans;\\n    }\\n\\n\\t// storing , {start,end} of interval \\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n    public void add(int left, int right) {\\n\\t\\t// finding greatest , smaller key than right \\n        if (map.floorKey(right) == null || map.get(map.floorKey(right)) < left) {\\n            map.put(left, right);\\n        } else {\\n            int start = left, end = right;\\n            while (true) {\\n                int l = map.floorKey(end);\\n                int r = map.get(l);\\n                start = Math.min(l, start);\\n                end = Math.max(r, end);\\n\\n                map.remove(l);\\n\\t\\t\\t\\t// if no longer merge can be done then break\\n                if (map.floorKey(end) == null || map.get(map.floorKey(end)) < start) {\\n                    break;\\n                }\\n            }\\n\\n            map.put(start, end);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21451,
                "title": "share-my-bst-interval-tree-solution-c-no-sorting",
                "content": "I share this solution because my friend was asked in his FB interview. He was asked to do it without sorting, for a large stream of intervals. The solution can be interval tree, but that is too complicated. Here I maintain a BST of distinct intervals. We dont need to maintain all the intervals like interval tree. We will merge intervals while we inserting. The code did not balance the tree. That is why performance is still 500+ms. \\n\\nSuppose we already have a BST of disjoint intervals. Given a new interval A, it will first find the toppest interval that has overlapping with A. Suppose it is B. Until now everything is easy. We simply traversed tree to reach this. \\n\\nThen, it will try to expand interval B. Now it becomes tricky. There are 3 cases. 1 case is simple. For the other 2 cases, you will need to delete currentNode, because it is already merged. You need to always correctly maintain prevNode and direction, in order to merge correctly in next round. For 1 case, you can end there. For another case, you need to continue exploration. \\nThe 2nd and 3rd case have duplicate code. However, I just keep it for better understanding.\\n\\nThe whole reason we can do this, is because: we will never meet a situation that we delete 1 node with 2 children but still keep its 2 children. If we remove 1 node, that means either his left or right is deleted. So, this is not really traditional node deletion in BST!!!!!! \\n\\nI only share my code that insert a new interval to a BST. Other parts are simple. \\nPlease see notes when we exploring left Children, comments are omitted when exploring right children.\\n\\n    void InsertInterval(BSTInterval *node, Interval \\xa4tInterval, BSTInterval *prev, int sign){\\n    //sign=1 if prev->left = node, sign=-1 if prev->right=node. \\n    \\n    int start=currentInterval.start, end = currentInterval.end;\\n    if(node==NULL){\\n        BSTInterval *newnode = new BSTInterval(start, end);\\n        if(sign==1){\\n            prev->left = newnode;\\n            return;\\n        }\\n        else{\\n            prev->right = newnode;\\n            return;\\n        }\\n    }\\n    if (node->start<=start && node->end>=end)\\n        return;\\n        \\n    if (node->start>end){\\n        InsertInterval(node->left, currentInterval, node, 1);\\n        return;\\n    }\\n    if (node->end<start){\\n        InsertInterval(node->right, currentInterval, node, -1);\\n        return;\\n    }\\n    \\n    \\n    /* Now we find the node that overlap with the interval we want to insert. \\n       We start from here and merge intervals. */\\n    //newLeft is always the new start after explore. \\n    int newLeft=min(start, node->start);\\n    if(start<node->start){\\n        BSTInterval * currentNode = node;\\n        BSTInterval * prevNode = NULL;\\n        while(currentNode != NULL){\\n            if (newLeft>currentNode->end){\\n                //apparently need to explore right direction. \\n                prevNode = currentNode;\\n                currentNode = currentNode->right;\\n                sign = -1;\\n            }\\n            else if (newLeft>currentNode->start){\\n                //apparently currentNode is not node, otherwise will not hit here\\n                //so, it is safe to delete currentNode\\n                //also, in this case, no need to explore more nodes, why?\\n                newLeft=currentNode->start;\\n                clear(currentNode->right);\\n                currentNode->right=NULL;\\n                if(sign==1) \\n                    prevNode->left = currentNode->left;\\n                else\\n                    prevNode->right = currentNode->left;\\n                //we don't need to explore. \\n                delete currentNode;\\n                break;//no need to continue, why?\\n            }\\n            else{ \\n                //be careful: currentNode will be deleted if it is not node\\n                //then, we need to update prevNode and sign directly\\n                //otherwise we can not properly delete next node!!!\\n                //this case still needs exploration.\\n                BSTInterval *leftChild = currentNode->left;\\n                if(currentNode!=node){\\n                    //prevNode and sign not changed. Just delete currentNode\\n                    clear(currentNode->right);\\n                    currentNode->right=NULL;\\n                    if(sign==1)\\n                        prevNode->left = leftChild;\\n                    else\\n                        prevNode->right = leftChild;\\n                    delete currentNode;\\n                }\\n                else{\\n                    //prevNode and sign changed. \\n                    prevNode = currentNode;\\n                    sign = 1;\\n                }\\n                currentNode=leftChild;\\n            }\\n        }\\n    }\\n    node->start = newLeft;\\n\\n    int newRight=max(end, node->end);\\n    if(end>node->end){\\n        BSTInterval * currentNode = node;\\n        BSTInterval * prevNode = NULL;\\n        while(currentNode != NULL){\\n            if (newRight<currentNode->start){\\n                prevNode = currentNode;\\n                currentNode = currentNode->left;\\n                sign = +1;\\n            }\\n            else if (newRight<currentNode->end){\\n                newRight=currentNode->end;\\n                clear(currentNode->left);\\n                currentNode->left=NULL;\\n                if(sign==1) \\n                    prevNode->left = currentNode->right;\\n                else\\n                    prevNode->right = currentNode->right;\\n                delete currentNode;\\n                break;\\n            }\\n            else{ \\n                BSTInterval *rightChild = currentNode->right;\\n                if(currentNode!=node){\\n                    clear(currentNode->left);\\n                    currentNode->left=NULL;\\n                    if(sign==1)\\n                        prevNode->left = rightChild;\\n                    else\\n                        prevNode->right = rightChild;\\n                    delete currentNode;\\n                }\\n                else{\\n                    prevNode = currentNode;\\n                    sign = -1;\\n                }\\n                currentNode=rightChild;                    \\n            }\\n        }\\n    }\\n    node->end = newRight;\\n\\n    return;\\n}",
                "solutionTags": [],
                "code": "I share this solution because my friend was asked in his FB interview. He was asked to do it without sorting, for a large stream of intervals. The solution can be interval tree, but that is too complicated. Here I maintain a BST of distinct intervals. We dont need to maintain all the intervals like interval tree. We will merge intervals while we inserting. The code did not balance the tree. That is why performance is still 500+ms. \\n\\nSuppose we already have a BST of disjoint intervals. Given a new interval A, it will first find the toppest interval that has overlapping with A. Suppose it is B. Until now everything is easy. We simply traversed tree to reach this. \\n\\nThen, it will try to expand interval B. Now it becomes tricky. There are 3 cases. 1 case is simple. For the other 2 cases, you will need to delete currentNode, because it is already merged. You need to always correctly maintain prevNode and direction, in order to merge correctly in next round. For 1 case, you can end there. For another case, you need to continue exploration. \\nThe 2nd and 3rd case have duplicate code. However, I just keep it for better understanding.\\n\\nThe whole reason we can do this, is because: we will never meet a situation that we delete 1 node with 2 children but still keep its 2 children. If we remove 1 node, that means either his left or right is deleted. So, this is not really traditional node deletion in BST!!!!!! \\n\\nI only share my code that insert a new interval to a BST. Other parts are simple. \\nPlease see notes when we exploring left Children, comments are omitted when exploring right children.\\n\\n    void InsertInterval(BSTInterval *node, Interval \\xa4tInterval, BSTInterval *prev, int sign){\\n    //sign=1 if prev->left = node, sign=-1 if prev->right=node. \\n    \\n    int start=currentInterval.start, end = currentInterval.end;\\n    if(node==NULL){\\n        BSTInterval *newnode = new BSTInterval(start, end);\\n        if(sign==1){\\n            prev->left = newnode;\\n            return;\\n        }\\n        else{\\n            prev->right = newnode;\\n            return;\\n        }\\n    }\\n    if (node->start<=start && node->end>=end)\\n        return;\\n        \\n    if (node->start>end){\\n        InsertInterval(node->left, currentInterval, node, 1);\\n        return;\\n    }\\n    if (node->end<start){\\n        InsertInterval(node->right, currentInterval, node, -1);\\n        return;\\n    }\\n    \\n    \\n    /* Now we find the node that overlap with the interval we want to insert. \\n       We start from here and merge intervals. */\\n    //newLeft is always the new start after explore. \\n    int newLeft=min(start, node->start);\\n    if(start<node->start){\\n        BSTInterval * currentNode = node;\\n        BSTInterval * prevNode = NULL;\\n        while(currentNode != NULL){\\n            if (newLeft>currentNode->end){\\n                //apparently need to explore right direction. \\n                prevNode = currentNode;\\n                currentNode = currentNode->right;\\n                sign = -1;\\n            }\\n            else if (newLeft>currentNode->start){\\n                //apparently currentNode is not node, otherwise will not hit here\\n                //so, it is safe to delete currentNode\\n                //also, in this case, no need to explore more nodes, why?\\n                newLeft=currentNode->start;\\n                clear(currentNode->right);\\n                currentNode->right=NULL;\\n                if(sign==1) \\n                    prevNode->left = currentNode->left;\\n                else\\n                    prevNode->right = currentNode->left;\\n                //we don't need to explore. \\n                delete currentNode;\\n                break;//no need to continue, why?\\n            }\\n            else{ \\n                //be careful: currentNode will be deleted if it is not node\\n                //then, we need to update prevNode and sign directly\\n                //otherwise we can not properly delete next node!!!\\n                //this case still needs exploration.\\n                BSTInterval *leftChild = currentNode->left;\\n                if(currentNode!=node){\\n                    //prevNode and sign not changed. Just delete currentNode\\n                    clear(currentNode->right);\\n                    currentNode->right=NULL;\\n                    if(sign==1)\\n                        prevNode->left = leftChild;\\n                    else\\n                        prevNode->right = leftChild;\\n                    delete currentNode;\\n                }\\n                else{\\n                    //prevNode and sign changed. \\n                    prevNode = currentNode;\\n                    sign = 1;\\n                }\\n                currentNode=leftChild;\\n            }\\n        }\\n    }\\n    node->start = newLeft;\\n\\n    int newRight=max(end, node->end);\\n    if(end>node->end){\\n        BSTInterval * currentNode = node;\\n        BSTInterval * prevNode = NULL;\\n        while(currentNode != NULL){\\n            if (newRight<currentNode->start){\\n                prevNode = currentNode;\\n                currentNode = currentNode->left;\\n                sign = +1;\\n            }\\n            else if (newRight<currentNode->end){\\n                newRight=currentNode->end;\\n                clear(currentNode->left);\\n                currentNode->left=NULL;\\n                if(sign==1) \\n                    prevNode->left = currentNode->right;\\n                else\\n                    prevNode->right = currentNode->right;\\n                delete currentNode;\\n                break;\\n            }\\n            else{ \\n                BSTInterval *rightChild = currentNode->right;\\n                if(currentNode!=node){\\n                    clear(currentNode->left);\\n                    currentNode->left=NULL;\\n                    if(sign==1)\\n                        prevNode->left = rightChild;\\n                    else\\n                        prevNode->right = rightChild;\\n                    delete currentNode;\\n                }\\n                else{\\n                    prevNode = currentNode;\\n                    sign = -1;\\n                }\\n                currentNode=rightChild;                    \\n            }\\n        }\\n    }\\n    node->end = newRight;\\n\\n    return;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 738403,
                "title": "python3-solution-with-a-detailed-explanation",
                "content": "\\n\\nI\\'ve found [this](https://leetcode.com/problems/merge-intervals/discuss/350272/Python3-Sort-O(Nlog(N))) and [this](https://leetcode.com/problems/merge-intervals/discuss/21332/Short-python-solution) solutions super helpful. \\n\\nWhat we\\'re trying to do is to merge intervals with overlap right? One a piece of paper try to merge `a = [1,3]` and `b = [2,5]`. How will you do that? If the right side of `a` (basically `a[1]`) is larger than the left side of `b` (meaning `b[0]`), then you can merge them. Otherwise, you can\\'t. Makes sense? So basically, you go overe all the intervals in `intervals` list, check them one by one and see whether they have overlap or not. Merge them if they had overlap, otherwise, add them to the `res` variable without any change. \\n\\nNote that if there is no interval in `intervals`, we don\\'t need to do anythingm right? (line `#1`), we return `[]`. In order to formalize this, we first `sort` the array (line `#2`). Check [sorted](https://realpython.com/python-sort/). Unlike to `sort()`, `sorted` accepts a key by which you can do useful stuff. We sort here by first element of each interval. Does this make sense? Once we sort it, we add the first interval to the output `res`. Note that, the first element of first interval should have the least amount of all. Let\\'s say `res = [[c,d]]. Now, we check the rest of `intervals` (line `#4`). Let\\'s say the next interval is `[e,f]`. There are two possibilities! Either `e <= d` or `e > d`, right? If `e > d`, the intervals don\\'t have any overlap. But, if `e <=d`, there is an overlap for sure (or at least we have `e = d` which still means that if `f > e`, we should merge the two intervals. That\\'s what we\\'re doing here. \\n\\n\\n`current` interval is compared with the last interval in the `res`, why? Because the last interval is an interval without any overlap to the interval before it in `res` except if there\\'s only one interval in `res`, and since we\\'ve sorted the list initially, current should not have any overlap with intervals before `res[-1]`. Makes sense? So if ` e <= d`, we change `d` with `f` (line `#6`). Otherwise, we append the `current` interval to `res`. We keep doing it until the last interval in `intervals` is visited. \\n\\n\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0: #1\\n            return []\\n        \\n        intervals = sorted(intervals, key = lambda x: x[0]) #2\\n        res = [intervals[0]] #3\\n        \\n        for current in intervals[1:]: #4\\n            if current[0] <= res[-1][1]: #5\\n                res[-1][1] = max(current[1], res[-1][1]) #6\\n            else: \\n                res.append(current) #7\\n        return res #1\\n```\\n\\nThis explanation from [here](https://leetcode.com/problems/merge-intervals/discuss/350272/Python3-Sort-O(Nlog(N))) is super helpful to understand the procedure:\\n\\n```\\nintervals [[1, 3], [2, 6], [8, 10], [15, 18]]\\nintervals.sort [[1, 3], [2, 6], [8, 10], [15, 18]]\\n\\ninterval = [1,3]\\nmerged =[]\\nnot merged:\\n\\tmerged =[ [1,3] ]\\n\\ninterval =[2,6]\\nmerged = [ [1,3] ]\\nmerged[-1][-1] = 3 > interval[0] = 2:\\n\\tmerged[-1][-1] = max(merged[-1][-1] = 3 ,interval[-1] = 6) =6\\nmerged = [[1,6]]\\n```\\n\\n\\n\\n===============================================================\\nFinal note: Please let me know if you found any typo/error/etc. I\\'ll try to fix it\\n\\nFinal note 2: I\\'m doing this writing since I think explaining something in a simple way to others would help me to understand better. Thanks for reading.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0: #1\\n            return []\\n        \\n        intervals = sorted(intervals, key = lambda x: x[0]) #2\\n        res = [intervals[0]] #3\\n        \\n        for current in intervals[1:]: #4\\n            if current[0] <= res[-1][1]: #5\\n                res[-1][1] = max(current[1], res[-1][1]) #6\\n            else: \\n                res.append(current) #7\\n        return res #1\\n```\n```\\nintervals [[1, 3], [2, 6], [8, 10], [15, 18]]\\nintervals.sort [[1, 3], [2, 6], [8, 10], [15, 18]]\\n\\ninterval = [1,3]\\nmerged =[]\\nnot merged:\\n\\tmerged =[ [1,3] ]\\n\\ninterval =[2,6]\\nmerged = [ [1,3] ]\\nmerged[-1][-1] = 3 > interval[0] = 2:\\n\\tmerged[-1][-1] = max(merged[-1][-1] = 3 ,interval[-1] = 6) =6\\nmerged = [[1,6]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338834,
                "title": "python-3-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Heap**\\n```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        minHeap = intervals\\n        heapify(minHeap)  # Heapify in increasing by the starting time order\\n        ans = []\\n        while minHeap:\\n            start, end = heappop(minHeap)\\n            while minHeap and minHeap[0][0] <= end:\\n                end = max(end, heappop(minHeap)[1])\\n            ans.append([start, end])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(NlogN)`\\n- Extra Space (without counting output as space): `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Sort (Version 1)**\\n```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()  # Sort in increasing order by the starting time\\n        ans = []\\n        n, i = len(intervals), 0\\n        while i < n:\\n            start, end = intervals[i]\\n            i += 1\\n            while i < n and intervals[i][0] <= end:\\n                end = max(end, intervals[i][1])\\n                i += 1\\n            ans.append([start, end])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(NlogN)`\\n- Extra Space (without counting output as space): `O(logN)`, for sorting.\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Sort (Version 2)**\\n```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()  # Sort in increasing order by the starting time\\n \\n        lastStart = lastEnd = intervals[0][0]\\n        ans = []\\n        for s, e in intervals:\\n            if s <= lastEnd:\\n                lastEnd = max(lastEnd, e)\\n            else:\\n                ans.append([lastStart, lastEnd])\\n                lastStart = s\\n                lastEnd = e\\n        ans.append([lastStart, lastEnd])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(NlogN)`\\n- Extra Space (without counting output as space): `O(logN)`, for sorting.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        minHeap = intervals\\n        heapify(minHeap)  # Heapify in increasing by the starting time order\\n        ans = []\\n        while minHeap:\\n            start, end = heappop(minHeap)\\n            while minHeap and minHeap[0][0] <= end:\\n                end = max(end, heappop(minHeap)[1])\\n            ans.append([start, end])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()  # Sort in increasing order by the starting time\\n        ans = []\\n        n, i = len(intervals), 0\\n        while i < n:\\n            start, end = intervals[i]\\n            i += 1\\n            while i < n and intervals[i][0] <= end:\\n                end = max(end, intervals[i][1])\\n                i += 1\\n            ans.append([start, end])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()  # Sort in increasing order by the starting time\\n \\n        lastStart = lastEnd = intervals[0][0]\\n        ans = []\\n        for s, e in intervals:\\n            if s <= lastEnd:\\n                lastEnd = max(lastEnd, e)\\n            else:\\n                ans.append([lastStart, lastEnd])\\n                lastStart = s\\n                lastEnd = e\\n        ans.append([lastStart, lastEnd])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21507,
                "title": "javascript-solution",
                "content": "    function merge(intervals) {\\n      if (!intervals.length) return intervals\\n      intervals.sort((a, b) => a.start !== b.start ? a.start - b.start : a.end - b.end)\\n      var prev = intervals[0]\\n      var res = [prev]\\n      for (var curr of intervals) {\\n        if (curr.start <= prev.end) {\\n          prev.end = Math.max(prev.end, curr.end)\\n        } else {\\n          res.push(curr)\\n          prev = curr\\n        }\\n      }\\n      return res\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function merge(intervals) {\\n      if (!intervals.length) return intervals\\n      intervals.sort((a, b) => a.start !== b.start ? a.start - b.start : a.end - b.end)\\n      var prev = intervals[0]\\n      var res = [prev]\\n      for (var curr of intervals) {\\n        if (curr.start <= prev.end) {\\n          prev.end = Math.max(prev.end, curr.end)\\n        } else {\\n          res.push(curr)\\n          prev = curr\\n        }\\n      }\\n      return res\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1553054,
                "title": "56-merge-intervals-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> answer = new ArrayList<>();\\n        \\n        if(intervals.length != 0 || intervals != null){\\n            Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n            \\n            int start = intervals[0][0];\\n            int end = intervals[0][1];\\n            for(int[] i: intervals){\\n                if(i[0] <= end){\\n                    end = Math.max(end, i[1]);\\n                } else {\\n                    answer.add(new int[]{start,end});\\n                    start = i[0];\\n                    end = i[1];\\n                }\\n            }\\n            answer.add(new int[]{start,end}); \\n            \\n        }\\n        \\n        return answer.toArray(new int[0][]); \\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> answer = new ArrayList<>();\\n        \\n        if(intervals.length != 0 || intervals != null){\\n            Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n            \\n            int start = intervals[0][0];\\n            int end = intervals[0][1];\\n            for(int[] i: intervals){\\n                if(i[0] <= end){\\n                    end = Math.max(end, i[1]);\\n                } else {\\n                    answer.add(new int[]{start,end});\\n                    start = i[0];\\n                    end = i[1];\\n                }\\n            }\\n            answer.add(new int[]{start,end}); \\n            \\n        }\\n        \\n        return answer.toArray(new int[0][]); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462187,
                "title": "clean-and-concise-java-code-with-comments",
                "content": "``` java\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0)\\n            return intervals;\\n        \\n        // sort intervals by starting value\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\\n        \\n\\t\\t// if end of previous interval is more than the start of current interval then there is a overlap\\n        LinkedList<int[]> mergedIntervals = new LinkedList<>();\\n        for(int[] curr : intervals) {\\n            //  if list empty or no overlap simply add current interval\\n            if(mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])\\n                mergedIntervals.add(curr);\\n            // else if overlap exists then merge curren tinterval with the previous interval\\n            else \\n                mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);\\n        }\\n        \\n        return mergedIntervals.toArray(new int[0][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0)\\n            return intervals;\\n        \\n        // sort intervals by starting value\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\\n        \\n\\t\\t// if end of previous interval is more than the start of current interval then there is a overlap\\n        LinkedList<int[]> mergedIntervals = new LinkedList<>();\\n        for(int[] curr : intervals) {\\n            //  if list empty or no overlap simply add current interval\\n            if(mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])\\n                mergedIntervals.add(curr);\\n            // else if overlap exists then merge curren tinterval with the previous interval\\n            else \\n                mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);\\n        }\\n        \\n        return mergedIntervals.toArray(new int[0][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400090,
                "title": "c-easy-beginner-friendly-detailed-explaination",
                "content": "\\n\\n# Code : \\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n\\n        vector<vector<int>> ans;\\n        ans.push_back({arr[0][0], arr[0][1]});\\n        int i = 0;\\n        int merge = 0;\\n\\n        for(; i < n - 1; i++){\\n            int j = i+1;\\n            if(ans[i - merge][1] >= arr[j][0]){\\n                ans[i - merge][1] = max(arr[j][1], ans[i - merge][1]);\\n                merge++;\\n            }else{\\n                ans.push_back({arr[j][0], arr[j][1]});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n---\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. $$Sort$$ the $$intervals$$ based on their start times so that we can easily identify which $$intervals$$ $$overlap$$.\\n2. $$Iterate$$ through the $$sorted$$ $$intervals$$ and $$merge$$ $$overlapping$$ $$intervals$$ into a $$single$$ $$interval$$.\\n3. $$Return$$ the $$merged$$ intervals.\\n   This approach would require $$iterating$$ over the intervals $$twice$$ - once for $$sorting$$ and once for $$merging$$. However, it should be noted that there may be more efficient ways to solve the problem, and the approach may need to be modified based on the specifics of the input and output requirements.\\n\\n\\n---\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The first step is to $$sort$$ the $$intervals$$ by their start time. We use the $$sort()$$ function from the $$STL$$ $$library$$ to do this. This is done to simplify the merging process as we will compare only adjacent intervals to determine if they overlap or not.\\n \\n```\\n    sort(arr.begin(), arr.end());\\n```\\n\\n2. Next, we $$initialize$$ $$an$$ $$empty$$ $$vector$$ ans to store the merged intervals. We then push the first interval to ans, as it cannot overlap with any other interval. \\n\\n```\\n    vector<vector<int>> ans;\\n    ans.push_back({arr[0][0], arr[0][1]});\\n```\\n\\n3. We then $$iterate$$ over the $$remaining$$ $$intervals$$, starting from index 1. If the current interval overlaps with the last interval in ans, we update the ending time of the last interval in ans to the maximum of its original ending time and the ending time of the current interval. We also increment a variable merge to keep track of the number of merged intervals.\\n\\n```\\n    int i = 0;\\n    int merge = 0;\\n    for(; i < n - 1; i++){\\n        int j = i+1;\\n        if(ans[i - merge][1] >= arr[j][0]){\\n            ans[i - merge][1] = max(arr[j][1], ans[i - merge][1]);\\n            merge++;\\n        }\\n\\n```\\n\\n4. If the current interval does not overlap with the last interval in ans, we add the current interval to ans.\\n\\n```\\n    else {\\n        ans.push_back({arr[j][0], arr[j][1]});\\n    }\\n```\\n\\n5. Finally, we return ans, which contains the merged intervals.\\n\\n```\\n     return ans;\\n```\\n\\n\\n---\\n\\n\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The code sorts the given vector of intervals based on their starting position using sort().\\n`Time complexity: O(n log n)`\\n- It initializes a new vector ans to store the merged intervals and pushes the first interval to ans.\\n`Time complexity: O(1)`\\n- It iterates through the remaining intervals and checks if they overlap with the last interval in ans.\\n`Time complexity: O(n)`\\n- If the intervals overlap, it updates the ending position of the last interval in ans to the maximum of its original ending position and the ending position of the current interval.\\n`Time complexity: O(1)`\\n- If the intervals do not overlap, it adds the current interval to ans.\\n`Time complexity: O(1)`\\n- Finally, it returns ans containing the merged intervals.\\n`Time complexity: O(n)`\\n\\n- **To summarize, the given code implements a simple and efficient solution to merge overlapping intervals in $$O(n log n) $$time. Its clear and concise implementation makes it easy to understand and maintain. It\\'s definitely a good solution to upload in LeetCode\\'s solution section.**\\n\\n\\n---\\n\\n\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity of the approach I outlined is O(n), where n is the number of intervals. This is because we need to store the merged intervals in a vector. In the worst case scenario where none of the intervals overlap, the merged vector would be the same size as the input vector. However, in practice, the number of merged intervals will be less than or equal to the number of input intervals. Overall, the space complexity of the approach is linear in the size of the input.\\n\\n---\\n\\n![cat upvote.png](https://assets.leetcode.com/users/images/9e396fb7-dcf4-4c24-b108-9239ca73718d_1681118559.9426527.png)\\n\\n\\n![upvote.png](https://assets.leetcode.com/users/images/62c16602-a9cc-4762-b53e-ec2417f76648_1687507600.6519113.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n\\n        vector<vector<int>> ans;\\n        ans.push_back({arr[0][0], arr[0][1]});\\n        int i = 0;\\n        int merge = 0;\\n\\n        for(; i < n - 1; i++){\\n            int j = i+1;\\n            if(ans[i - merge][1] >= arr[j][0]){\\n                ans[i - merge][1] = max(arr[j][1], ans[i - merge][1]);\\n                merge++;\\n            }else{\\n                ans.push_back({arr[j][0], arr[j][1]});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\n    sort(arr.begin(), arr.end());\\n```\n```\\n    vector<vector<int>> ans;\\n    ans.push_back({arr[0][0], arr[0][1]});\\n```\n```\\n    int i = 0;\\n    int merge = 0;\\n    for(; i < n - 1; i++){\\n        int j = i+1;\\n        if(ans[i - merge][1] >= arr[j][0]){\\n            ans[i - merge][1] = max(arr[j][1], ans[i - merge][1]);\\n            merge++;\\n        }\\n\\n```\n```\\n    else {\\n        ans.push_back({arr[j][0], arr[j][1]});\\n    }\\n```\n```\\n     return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810795,
                "title": "python-js-go-c-by-sort-merge-w-visualization",
                "content": "**Diagram and Visualization**\\n\\nAfter soring on endpoint pair, there are 3 possible cases for interval pairs during merging\\n\\n![image](https://assets.leetcode.com/users/images/8fee36e8-d9d4-4efb-8e91-05d3b0240a4f_1598347860.5559268.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/f6550399-4197-4ec4-8eeb-7c38de6672e8_1598347895.2212944.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/07c2b4fa-bd43-46df-b6a4-259840c0649b_1598347927.5255473.png)\\n\\n---\\n\\n**Implementation** by sort-and-merge\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        \\n        # predefined constant for start (left endpoint), and end (right endpoint)\\n        START, END = 0, 1\\n        \\n        result = []\\n        \\n        # make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n        intervals.sort( key = lambda x: (x[START], x[END] ) ) \\n        \\n        for interval in intervals:\\n            \\n            if not result or ( result[-1][END] < interval[START] ):\\n\\t\\t\\t\\t# no overlapping\\n                result.append( interval )\\n            \\n            else:\\n\\t\\t\\t\\t# has overlapping\\n\\t\\t\\t\\t# merge with previous interval\\n                result[-1][END] = max(result[-1][END], interval[END])\\n                \\n        return result\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar merge = function(intervals) {\\n    \\n    // predefined constant for start (left endpoint), as well as end (right endpoint)\\n    const [START, END] = [0, 1];\\n    \\n    let result = [];\\n    \\n    // make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n    intervals.sort( (a, b) => a[START] != b[START] ? a[START] - b[START] : a[END] - b[END] );\\n    \\n    for( const curInterval of intervals){\\n        \\n        if( (result.length == 0) || ( result[result.length-1][END] < curInterval[START]) ){\\n            // no overlapping\\n            result.push( curInterval );\\n\\n            \\n        \\n        }else{\\n            // has overlapping\\n            // merge with previous interval\\n            result[result.length-1][END] = Math.max( result[result.length-1][END], curInterval[END] );\\n\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc max(x, y int) int {\\n    \\n    if x >= y {\\n        return x\\n    }else{\\n        return y\\n    }\\n    \\n}\\n\\n//---------------------\\n\\n\\nfunc merge(intervals [][]int) [][]int {\\n\\n    // predefined constant for start (left endpoint), as well as end (right endpoint)\\n    const START, END = 0, 1\\n    \\n    result := make( [][]int, 0);\\n    \\n    sort.Slice(intervals, func(a, b int) bool {\\n        return (intervals[a][0] < intervals[b][0]) || ( (intervals[a][0] == intervals[b][0]) && (intervals[a][1] < intervals[b][1]) )\\n    })\\n    \\n    for _, curInterval := range intervals{\\n        \\n        if ( len(result) == 0 ) || ( result[len(result)-1][END] < curInterval[START] ){\\n            \\n            // no overlapping\\n            result = append(result, curInterval)\\n            \\n        }else{\\n            \\n            // has overlapping\\n            // merge with previous interval\\n            result[len(result)-1][END] = max( result[len(result)-1][END], curInterval[END] )\\n        }\\n        \\n    }\\n    \\n    return result\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        // predefined constant for start (left endpoint), as well as end ( right endpoint)\\n        const int START=0, END=1;   \\n        \\n        vector< vector<int> > result;\\n    \\n        // make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n        sort( intervals.begin(), intervals.end() );\\n        \\n        for( auto const &curInterval : intervals ){\\n            \\n            if ( (result.size() == 0 ) || (result.back()[END] < curInterval[START] ) ){\\n                // no overlapping\\n                result.push_back( curInterval );\\n                \\n            }else{\\n                // has overlapping\\n                // merge with previous interval\\n                result.back()[END] = max( result.back()[END], curInterval[END] );\\n                \\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        \\n        # predefined constant for start (left endpoint), and end (right endpoint)\\n        START, END = 0, 1\\n        \\n        result = []\\n        \\n        # make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n        intervals.sort( key = lambda x: (x[START], x[END] ) ) \\n        \\n        for interval in intervals:\\n            \\n            if not result or ( result[-1][END] < interval[START] ):\\n\\t\\t\\t\\t# no overlapping\\n                result.append( interval )\\n            \\n            else:\\n\\t\\t\\t\\t# has overlapping\\n\\t\\t\\t\\t# merge with previous interval\\n                result[-1][END] = max(result[-1][END], interval[END])\\n                \\n        return result\\n```\n```\\nvar merge = function(intervals) {\\n    \\n    // predefined constant for start (left endpoint), as well as end (right endpoint)\\n    const [START, END] = [0, 1];\\n    \\n    let result = [];\\n    \\n    // make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n    intervals.sort( (a, b) => a[START] != b[START] ? a[START] - b[START] : a[END] - b[END] );\\n    \\n    for( const curInterval of intervals){\\n        \\n        if( (result.length == 0) || ( result[result.length-1][END] < curInterval[START]) ){\\n            // no overlapping\\n            result.push( curInterval );\\n\\n            \\n        \\n        }else{\\n            // has overlapping\\n            // merge with previous interval\\n            result[result.length-1][END] = Math.max( result[result.length-1][END], curInterval[END] );\\n\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\n```\\nfunc max(x, y int) int {\\n    \\n    if x >= y {\\n        return x\\n    }else{\\n        return y\\n    }\\n    \\n}\\n\\n//---------------------\\n\\n\\nfunc merge(intervals [][]int) [][]int {\\n\\n    // predefined constant for start (left endpoint), as well as end (right endpoint)\\n    const START, END = 0, 1\\n    \\n    result := make( [][]int, 0);\\n    \\n    sort.Slice(intervals, func(a, b int) bool {\\n        return (intervals[a][0] < intervals[b][0]) || ( (intervals[a][0] == intervals[b][0]) && (intervals[a][1] < intervals[b][1]) )\\n    })\\n    \\n    for _, curInterval := range intervals{\\n        \\n        if ( len(result) == 0 ) || ( result[len(result)-1][END] < curInterval[START] ){\\n            \\n            // no overlapping\\n            result = append(result, curInterval)\\n            \\n        }else{\\n            \\n            // has overlapping\\n            // merge with previous interval\\n            result[len(result)-1][END] = max( result[len(result)-1][END], curInterval[END] )\\n        }\\n        \\n    }\\n    \\n    return result\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        // predefined constant for start (left endpoint), as well as end ( right endpoint)\\n        const int START=0, END=1;   \\n        \\n        vector< vector<int> > result;\\n    \\n        // make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n        sort( intervals.begin(), intervals.end() );\\n        \\n        for( auto const &curInterval : intervals ){\\n            \\n            if ( (result.size() == 0 ) || (result.back()[END] < curInterval[START] ) ){\\n                // no overlapping\\n                result.push_back( curInterval );\\n                \\n            }else{\\n                // has overlapping\\n                // merge with previous interval\\n                result.back()[END] = max( result.back()[END], curInterval[END] );\\n                \\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716744,
                "title": "javascript-clean-code",
                "content": "```javascript\\nvar merge = function(intervals) {\\n    if(!intervals.length) return [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n    \\n    const result = [intervals[0]];\\n    \\n    for(let [start, end] of intervals) {\\n        const endPrev = result.at(-1)[1]\\n        if(start <= endPrev) result.at(-1)[1] = Math.max(end, endPrev);\\n        else result.push([start, end]);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar merge = function(intervals) {\\n    if(!intervals.length) return [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n    \\n    const result = [intervals[0]];\\n    \\n    for(let [start, end] of intervals) {\\n        const endPrev = result.at(-1)[1]\\n        if(start <= endPrev) result.at(-1)[1] = Math.max(end, endPrev);\\n        else result.push([start, end]);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21488,
                "title": "my-easy-c-solution",
                "content": "    static bool comp(const Interval& a, const Interval& b){\\n        return a.start < b.start;\\n    }\\n    vector<Interval> merge(vector<Interval> &intervals) {\\n        vector<Interval> result;\\n        if(intervals.empty()){\\n            return result;\\n        }\\n        sort(intervals.begin(), intervals.end(), comp);\\n        result.push_back(intervals[0]);\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i].start <= result.back().end){\\n                Interval temp(result.back().start, max(result.back().end, intervals[i].end));\\n                result.pop_back();\\n                result.push_back(temp);\\n            }\\n            else{\\n                result.push_back(intervals[i]);\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    static bool comp(const Interval& a, const Interval& b){\\n        return a.start < b.start;\\n    }\\n    vector<Interval> merge(vector<Interval> &intervals) {\\n        vector<Interval> result;\\n        if(intervals.empty()){\\n            return result;\\n        }\\n        sort(intervals.begin(), intervals.end(), comp);\\n        result.push_back(intervals[0]);\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i].start <= result.back().end){\\n                Interval temp(result.back().start, max(result.back().end, intervals[i].end));\\n                result.pop_back();\\n                result.push_back(temp);\\n            }\\n            else{\\n                result.push_back(intervals[i]);\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1528228,
                "title": "multiple-c-solution",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n# Method 01\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        \\n        sort(v.begin(),v.end());\\n        vector<vector<int>>ans;\\n   \\n        ans.push_back(v[0]);\\n\\n        int first = ans[0][0];\\n        int last = ans[0][1];\\n        int k=0;\\n\\n        for(int i=1;i<v.size();i++)\\n        {\\n\\n            if(v[i][0]<=last)\\n            {\\n                ans[k][1] = max(v[i][1],last);\\n                ans[k][0] =  min(v[i][0],first);\\n                first = ans[k][0];\\n                last = ans[k][1];\\n            }\\n            else{\\n\\n                vector<int>temp;\\n                temp.push_back(v[i][0]);\\n                temp.push_back(v[i][1]);\\n\\n                ans.push_back(temp);\\n\\n                k++;\\n                first =  ans[k][0];\\n                last =  ans[k][1];\\n\\n            }\\n    }\\n            return ans;\\n    }\\n\\n};\\n```\\n# Method 02\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>>ans;\\n        int n = intervals.size();\\n        ans.push_back({intervals[0][0],intervals[0][1]});\\n       \\n        if(n==1)\\n            return ans;\\n        \\n        int a=0, b=0, i=1;\\n        while(i<n){\\n            if(ans[a][1]>=intervals[i][0]){\\n                ans[a][1]= max(ans[a][1],intervals[i][1]);\\n                i++;\\n            }\\n            else{\\n                ans.push_back({intervals[i][0],intervals[i][1]});\\n                a++;\\n            }\\n        }\\n        return ans;     \\n    }\\n};\\n```\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        \\n        sort(v.begin(),v.end());\\n        vector<vector<int>>ans;\\n   \\n        ans.push_back(v[0]);\\n\\n        int first = ans[0][0];\\n        int last = ans[0][1];\\n        int k=0;\\n\\n        for(int i=1;i<v.size();i++)\\n        {\\n\\n            if(v[i][0]<=last)\\n            {\\n                ans[k][1] = max(v[i][1],last);\\n                ans[k][0] =  min(v[i][0],first);\\n                first = ans[k][0];\\n                last = ans[k][1];\\n            }\\n            else{\\n\\n                vector<int>temp;\\n                temp.push_back(v[i][0]);\\n                temp.push_back(v[i][1]);\\n\\n                ans.push_back(temp);\\n\\n                k++;\\n                first =  ans[k][0];\\n                last =  ans[k][1];\\n\\n            }\\n    }\\n            return ans;\\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>>ans;\\n        int n = intervals.size();\\n        ans.push_back({intervals[0][0],intervals[0][1]});\\n       \\n        if(n==1)\\n            return ans;\\n        \\n        int a=0, b=0, i=1;\\n        while(i<n){\\n            if(ans[a][1]>=intervals[i][0]){\\n                ans[a][1]= max(ans[a][1],intervals[i][1]);\\n                i++;\\n            }\\n            else{\\n                ans.push_back({intervals[i][0],intervals[i][1]});\\n                a++;\\n            }\\n        }\\n        return ans;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939998,
                "title": "python-sort-and-traverse-explained",
                "content": "Let us sort our intervals by its starts and then iterate them one by one: we can have two options:\\n\\n1. The current ending point in our `ans` is less than `beg` of new interval: it means that we have a gap and we need to add new interval to our answer.\\n2. In the opposite case our intervals are overlapping, so we need to update the end for last interval we created.\\n\\n**Complexity:** time complexity is `O(n log n)` to sort intervals and space complexity is `O(n)` to keep sorted intervals and answer.\\n\\n```\\nclass Solution:\\n    def merge(self, intervals):\\n        ans = []\\n        \\n        for beg, end in sorted(intervals):\\n            if not ans or ans[-1][1] < beg:\\n                ans += [[beg, end]]\\n            else:\\n                ans[-1][1] = max(ans[-1][1], end)\\n\\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals):\\n        ans = []\\n        \\n        for beg, end in sorted(intervals):\\n            if not ans or ans[-1][1] < beg:\\n                ans += [[beg, end]]\\n            else:\\n                ans[-1][1] = max(ans[-1][1], end)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358410,
                "title": "c-brute-force-optimal-solution-commented-time-o-nlogn-auxiliary-space-o-1",
                "content": "**Brute Force Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n        int len=intervals.size();\\n        if(len<=1)\\n            return intervals;\\n        sort(intervals.begin(),intervals.end()); // Time taken by sort() is O(NlogN)\\n        vector<vector<int>> res;\\n        for(int i=0;i<len;i++){\\n            int a=intervals[i][0];\\n            int b=intervals[i][1];\\n            // for loop inside for loop takes time of O(N^2)\\n            for(int j=i+1;j<len;j++){\\n                int c=intervals[j][0];\\n                int d=intervals[j][1];\\n                if(b>=c){ \\n                    // Comparing pairs : (a,b) & (c,d)\\n                    // Interval overlap condition example - a=3,b=7,c=5,d=9\\n                    //  Real Line---a(3)------c(5)******b(7)-------d(9)----\\n                    // (a,max(b,d)) should be inserted in result(res) vector.\\n                    // b will only get updated if there is an overlap \\n                    // so as to merge maximum number of intervals\\n                    b=max(b,d);\\n                    // i pointer should now point to the pair pointed by j \\n                    // and in next iteration of j loop, j will point to the \\n                    // pair next to the one pointed by this i\\n                    i=j;\\n                }\\n            } \\n            res.push_back({a,b});\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Optimal Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        // Optimal Solution Time O(NlogN) & Auxiliary Space O(1)\\n        int len=intervals.size();\\n        if(len<=1)\\n            return intervals;\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res; // result vector\\n        // insert the first element into the result vector\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<len;i++){\\n            if(res.back()[1]>=intervals[i][0])\\n                // back() points to the final element of the vector.\\n                // Update the endpoint of final element of result \\n                // vector if there is an overlap with intervals[i]\\n                res.back()[1]=max(res.back()[1], intervals[i][1]);\\n            else\\n                // If no overlap, insert intervals[i]\\n                res.push_back(intervals[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n        int len=intervals.size();\\n        if(len<=1)\\n            return intervals;\\n        sort(intervals.begin(),intervals.end()); // Time taken by sort() is O(NlogN)\\n        vector<vector<int>> res;\\n        for(int i=0;i<len;i++){\\n            int a=intervals[i][0];\\n            int b=intervals[i][1];\\n            // for loop inside for loop takes time of O(N^2)\\n            for(int j=i+1;j<len;j++){\\n                int c=intervals[j][0];\\n                int d=intervals[j][1];\\n                if(b>=c){ \\n                    // Comparing pairs : (a,b) & (c,d)\\n                    // Interval overlap condition example - a=3,b=7,c=5,d=9\\n                    //  Real Line---a(3)------c(5)******b(7)-------d(9)----\\n                    // (a,max(b,d)) should be inserted in result(res) vector.\\n                    // b will only get updated if there is an overlap \\n                    // so as to merge maximum number of intervals\\n                    b=max(b,d);\\n                    // i pointer should now point to the pair pointed by j \\n                    // and in next iteration of j loop, j will point to the \\n                    // pair next to the one pointed by this i\\n                    i=j;\\n                }\\n            } \\n            res.push_back({a,b});\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        // Optimal Solution Time O(NlogN) & Auxiliary Space O(1)\\n        int len=intervals.size();\\n        if(len<=1)\\n            return intervals;\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res; // result vector\\n        // insert the first element into the result vector\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<len;i++){\\n            if(res.back()[1]>=intervals[i][0])\\n                // back() points to the final element of the vector.\\n                // Update the endpoint of final element of result \\n                // vector if there is an overlap with intervals[i]\\n                res.back()[1]=max(res.back()[1], intervals[i][1]);\\n            else\\n                // If no overlap, insert intervals[i]\\n                res.push_back(intervals[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200549,
                "title": "faster-than-99-86-c-submissions-with-explanation",
                "content": "```\\n// There can be three cases with two intervals \\n// Casee 1:- No overlap\\n\\n//  _______________        ________________\\n// | left interval |      | right interval |\\n// |_______________|      |________________|\\n\\n//Case 2:- Partial overlap\\n\\n//  _______________\\n// | left interval |\\n// |_______________|\\n//            ________________\\n//           | right interval |\\n//           |________________|\\n\\n// Case 3:- Full overlap\\n\\n//  _____________________\\n// |    left interval    |\\n// |_____________________|\\n//    ________________\\n//   | right interval |\\n//   |________________|\\n\\n\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        // Sort the intervals so that the comparison between two intervals becomes easier \\n        sort(v.begin(),v.end());\\n        int n=v.size(),left=0,right=1;\\n        vector<vector<int>>ans; // For storing the result\\n        while(left<n && right<n)\\n        {\\n            // Case 1(No overlap so proceed)\\n            if(v[left][1]<v[right][0])\\n            {\\n                left=right;\\n                right++;\\n            }\\n            // Else overlap occurs (Case 2 or Case 3)\\n            else\\n            {\\n                // Case 3(Full overlap)\\n                if(v[left][1]>=v[right][1])\\n                {\\n                    // Mark the fully overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n                // Case 2(partial overlap)\\n                else\\n                {\\n                    // Extend the end point of the left interval( by making end point of left interval=end point of right interval) so that the intervals can be merged \\n                    v[left][1]=v[right][1];\\n                    // Mark the partially overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n            }\\n        }\\n        // Now we\\'ll traverse the intervals again and populate the ans vector i.e the result vector\\n        for(int i=0;i<n;i++)\\n        {\\n            // If any interval is marked then don\\'t push it to the ans vector cause after merging marked intervals can\\'t have their existence\\n            if(v[i][0]!=-1)\\n            {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        // Finally return the answer\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n// There can be three cases with two intervals \\n// Casee 1:- No overlap\\n\\n//  _______________        ________________\\n// | left interval |      | right interval |\\n// |_______________|      |________________|\\n\\n//Case 2:- Partial overlap\\n\\n//  _______________\\n// | left interval |\\n// |_______________|\\n//            ________________\\n//           | right interval |\\n//           |________________|\\n\\n// Case 3:- Full overlap\\n\\n//  _____________________\\n// |    left interval    |\\n// |_____________________|\\n//    ________________\\n//   | right interval |\\n//   |________________|\\n\\n\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        // Sort the intervals so that the comparison between two intervals becomes easier \\n        sort(v.begin(),v.end());\\n        int n=v.size(),left=0,right=1;\\n        vector<vector<int>>ans; // For storing the result\\n        while(left<n && right<n)\\n        {\\n            // Case 1(No overlap so proceed)\\n            if(v[left][1]<v[right][0])\\n            {\\n                left=right;\\n                right++;\\n            }\\n            // Else overlap occurs (Case 2 or Case 3)\\n            else\\n            {\\n                // Case 3(Full overlap)\\n                if(v[left][1]>=v[right][1])\\n                {\\n                    // Mark the fully overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n                // Case 2(partial overlap)\\n                else\\n                {\\n                    // Extend the end point of the left interval( by making end point of left interval=end point of right interval) so that the intervals can be merged \\n                    v[left][1]=v[right][1];\\n                    // Mark the partially overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n            }\\n        }\\n        // Now we\\'ll traverse the intervals again and populate the ans vector i.e the result vector\\n        for(int i=0;i<n;i++)\\n        {\\n            // If any interval is marked then don\\'t push it to the ans vector cause after merging marked intervals can\\'t have their existence\\n            if(v[i][0]!=-1)\\n            {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        // Finally return the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733718,
                "title": "python-using-start-and-end-easy-to-understand",
                "content": "Instead of using start and end use [0] and [1]. It works\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0: \\n            return []\\n        intervals.sort() #sort the list according to start index\\n        stack = [intervals[0]] #push the first element into the stack\\n        for current in intervals[1:]:\\n            if current[0] <= stack[-1][1]: #if the start of current element is less than or equal to the end of top element of stack then set\\n                #stack top element end = max( current end, stack top end)\\n                stack[-1][1] = max(current[1], stack[-1][1])\\n            else: \\n                #else append the current element into stack\\n                stack.append(current)\\n        return stack\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0: \\n            return []\\n        intervals.sort() #sort the list according to start index\\n        stack = [intervals[0]] #push the first element into the stack\\n        for current in intervals[1:]:\\n            if current[0] <= stack[-1][1]: #if the start of current element is less than or equal to the end of top element of stack then set\\n                #stack top element end = max( current end, stack top end)\\n                stack[-1][1] = max(current[1], stack[-1][1])\\n            else: \\n                #else append the current element into stack\\n                stack.append(current)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683624,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int[][] Merge(int[][] intervals) {\\n        if (intervals == null || intervals.Length == 0 || intervals.Length == 1)\\n            return intervals;\\n        \\n        List<int[]> res = new List<int[]>();\\n        \\n        intervals = intervals.OrderBy(x => x[0]).ToArray();\\n        \\n        int s = intervals[0][0],\\n            e = intervals[0][1];\\n        \\n        for (int i = 1; i < intervals.Length; i++)\\n            if (intervals[i][0] > e)\\n            {\\n                res.Add(new int[] { s, e });\\n                s = intervals[i][0];\\n                e = intervals[i][1];\\n            }\\n            else\\n                e = Math.Max(e, intervals[i][1]);\\n        \\n        res.Add(new int[] { s, e });\\n        \\n        return res.ToArray();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] Merge(int[][] intervals) {\\n        if (intervals == null || intervals.Length == 0 || intervals.Length == 1)\\n            return intervals;\\n        \\n        List<int[]> res = new List<int[]>();\\n        \\n        intervals = intervals.OrderBy(x => x[0]).ToArray();\\n        \\n        int s = intervals[0][0],\\n            e = intervals[0][1];\\n        \\n        for (int i = 1; i < intervals.Length; i++)\\n            if (intervals[i][0] > e)\\n            {\\n                res.Add(new int[] { s, e }",
                "codeTag": "Java"
            },
            {
                "id": 3462073,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# My youtube channel - KeetCode(Ex-Amazon)\\nI create 158 videos for leetcode questions as of April 28, 2023. I believe my channel helps you prepare for the coming technical interviews. Please subscribe my channel!\\n\\n### Please subscribe my channel - KeetCode(Ex-Amazon) from here.\\n\\n**I created a video for this question. I believe you can understand easily with visualization.** \\n\\n**My youtube channel - KeetCode(Ex-Amazon)**\\nThere is my channel link under picture in LeetCode profile.\\n\\nhttps://youtu.be/IuzSG0YEdXU\\n\\n---\\n\\n# Intuition\\nSort intervals with start points. It takes advantage of the fact that the intervals are sorted by start point, which allows us to avoid comparing every interval to every other interval.\\n\\n# Approach\\nThis is based on Python code. Other languages might be different.\\n\\n1. The merge method takes a list of lists as an argument. Each inner list represents an interval, and the first element of the inner list is the start point, and the second element is the end point.\\n\\n2. Check if the given list is empty, if yes, return an empty list.\\n\\n3. Initialize an empty list named merged to store the merged intervals.\\n\\n4. Sort the given list of intervals by the first element of each interval using the sort method and a lambda function.\\n\\n5. Set the variable prev to the first interval of the sorted intervals list.\\n\\n6. Iterate over the sorted intervals list, starting from the second interval.\\n\\n7. Check if the start point of the current interval is less than or equal to the end point of the previous interval.\\n\\n8. If yes, then update the end point of the previous interval with the maximum of the current interval\\'s end point and the previous interval\\'s end point.\\n9. If no, then append the previous interval to the merged list and set prev to the current interval.\\n\\n10. After the loop, append the last interval (prev) to the merged list.\\nReturn the merged list containing the merged intervals.\\n\\n# Complexity\\nThis is based on Python code. Other languages might be different.\\n\\n- Time complexity: O(n log n)\\nn is the length of the input list \\'intervals\\'. This is because the code sorts the intervals list in O(n log n) time using the built-in Python sorting algorithm, and then iterates over the sorted list once in O(n) time to merge overlapping intervals.\\n\\n- Space complexity: O(n)\\nn is the length of the input list \\'intervals\\'. This is because the code creates a new list \\'merged\\' to store the merged intervals, which can contain up to n elements if there are no overlapping intervals. Additionally, the code uses a constant amount of space to store the \\'prev\\' variable and other temporary variables, which does not depend on the size of the input.\\n\\n---\\n\\n**My youtube channel - KeetCode(Ex-Amazon)**\\nThere is my channel link under picture in LeetCode profile.\\nhttps://leetcode.com/niits/\\n\\n---\\n\\n# Python\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if not intervals:\\n            return []\\n        \\n        merged = []\\n        intervals.sort(key=lambda x: x[0])\\n\\n        prev = intervals[0]\\n\\n        for interval in intervals[1:]:\\n            if interval[0] <= prev[1]:\\n                prev[1] = max(prev[1], interval[1])\\n            else:\\n                merged.append(prev)\\n                prev = interval\\n        \\n        merged.append(prev)\\n\\n        return merged\\n```\\n# JavaScript\\n```\\n/**\\n * @param {number[][]} intervals\\n * @return {number[][]}\\n */\\nvar merge = function(intervals) {\\n    if (!intervals || intervals.length === 0) {\\n        return [];\\n    }\\n\\n    let merged = [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    let mergedInterval = intervals[0];\\n\\n    for (let i = 1; i < intervals.length; i++) {\\n        let interval = intervals[i];\\n\\n        if (interval[0] <= mergedInterval[1]) {\\n            mergedInterval[1] = Math.max(mergedInterval[1], interval[1]);\\n        } else {\\n            merged.push(mergedInterval);\\n            mergedInterval = interval;\\n        }\\n    }\\n\\n    merged.push(mergedInterval);\\n\\n    return merged;    \\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals == null || intervals.length == 0) {\\n            return new int[0][];\\n        }\\n\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\\n\\n        List<int[]> merged = new ArrayList<>();\\n        int[] mergedInterval = intervals[0];\\n\\n        for (int i = 1; i < intervals.length; i++) {\\n            int[] interval = intervals[i];\\n            \\n            if (interval[0] <= mergedInterval[1]) {\\n                mergedInterval[1] = Math.max(mergedInterval[1], interval[1]);\\n            } else {\\n                merged.add(mergedInterval);\\n                mergedInterval = interval; \\n            }\\n        }\\n\\n        merged.add(mergedInterval);\\n\\n        return merged.toArray(new int[merged.size()][]);        \\n    }\\n}\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if (intervals.empty()) {\\n            return {};\\n        }\\n\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0];\\n        });\\n\\n        vector<vector<int>> merged;\\n        vector<int> mergedInterval = intervals[0];\\n\\n        for (int i = 1; i < intervals.size(); i++) {\\n            const vector<int>& interval = intervals[i];\\n            \\n            if (interval[0] <= mergedInterval[1]) {\\n                mergedInterval[1] = max(mergedInterval[1], interval[1]);\\n            } else {\\n                merged.push_back(mergedInterval);\\n                mergedInterval = interval;\\n            }\\n        }\\n\\n        merged.push_back(mergedInterval);\\n\\n        return merged;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if not intervals:\\n            return []\\n        \\n        merged = []\\n        intervals.sort(key=lambda x: x[0])\\n\\n        prev = intervals[0]\\n\\n        for interval in intervals[1:]:\\n            if interval[0] <= prev[1]:\\n                prev[1] = max(prev[1], interval[1])\\n            else:\\n                merged.append(prev)\\n                prev = interval\\n        \\n        merged.append(prev)\\n\\n        return merged\\n```\n```\\n/**\\n * @param {number[][]} intervals\\n * @return {number[][]}\\n */\\nvar merge = function(intervals) {\\n    if (!intervals || intervals.length === 0) {\\n        return [];\\n    }\\n\\n    let merged = [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    let mergedInterval = intervals[0];\\n\\n    for (let i = 1; i < intervals.length; i++) {\\n        let interval = intervals[i];\\n\\n        if (interval[0] <= mergedInterval[1]) {\\n            mergedInterval[1] = Math.max(mergedInterval[1], interval[1]);\\n        } else {\\n            merged.push(mergedInterval);\\n            mergedInterval = interval;\\n        }\\n    }\\n\\n    merged.push(mergedInterval);\\n\\n    return merged;    \\n};\\n```\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals == null || intervals.length == 0) {\\n            return new int[0][];\\n        }\\n\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\\n\\n        List<int[]> merged = new ArrayList<>();\\n        int[] mergedInterval = intervals[0];\\n\\n        for (int i = 1; i < intervals.length; i++) {\\n            int[] interval = intervals[i];\\n            \\n            if (interval[0] <= mergedInterval[1]) {\\n                mergedInterval[1] = Math.max(mergedInterval[1], interval[1]);\\n            } else {\\n                merged.add(mergedInterval);\\n                mergedInterval = interval; \\n            }\\n        }\\n\\n        merged.add(mergedInterval);\\n\\n        return merged.toArray(new int[merged.size()][]);        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if (intervals.empty()) {\\n            return {};\\n        }\\n\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0];\\n        });\\n\\n        vector<vector<int>> merged;\\n        vector<int> mergedInterval = intervals[0];\\n\\n        for (int i = 1; i < intervals.size(); i++) {\\n            const vector<int>& interval = intervals[i];\\n            \\n            if (interval[0] <= mergedInterval[1]) {\\n                mergedInterval[1] = max(mergedInterval[1], interval[1]);\\n            } else {\\n                merged.push_back(mergedInterval);\\n                mergedInterval = interval;\\n            }\\n        }\\n\\n        merged.push_back(mergedInterval);\\n\\n        return merged;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319024,
                "title": "98-96-super-easy-understand-javascript-solution-with-explains",
                "content": "```\\nvar merge = function(intervals) {\\n    if(intervals.length < 2) return intervals; \\n    intervals.sort((a,b) => a[0] - b[0]) //Arr have smaller element come first\\n    for(let i = 1; i < intervals.length; i += 1){\\n        curr = intervals[i];\\n        prev = intervals[i-1];\\n        if(curr[0] <= prev[1]){\\n            intervals[i] = [Math.min(prev[0],curr[0]), Math.max(prev[1],curr[1])]\\n            intervals.splice(i-1,1);\\n            i -= 1  // After merge, the arr become shorter\\n        }\\n    }\\n    return intervals\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n    if(intervals.length < 2) return intervals; \\n    intervals.sort((a,b) => a[0] - b[0]) //Arr have smaller element come first\\n    for(let i = 1; i < intervals.length; i += 1){\\n        curr = intervals[i];\\n        prev = intervals[i-1];\\n        if(curr[0] <= prev[1]){\\n            intervals[i] = [Math.min(prev[0],curr[0]), Math.max(prev[1],curr[1])]\\n            intervals.splice(i-1,1);\\n            i -= 1  // After merge, the arr become shorter\\n        }\\n    }\\n    return intervals\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 287714,
                "title": "new-c-solution-o-nlogn-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comparator( vector<int>& a, vector<int>& b )\\n    {\\n        return a[0] < b[0];\\n    }\\n    \\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        //Handle Edge cases\\n        if( intervals.empty() )\\n        {\\n            return res;\\n        }\\n        \\n        if( intervals.size() == 1 )\\n        {\\n            res.push_back( intervals[0]);\\n            return res;\\n        }\\n        \\n        //Sort the inetrvals first based on the start of interval\\n        sort( intervals.begin(), intervals.end(), comparator );\\n        \\n        //Push the first interval into the result\\n        res.push_back( intervals[0] );\\n        int i = 1;\\n        while( i < intervals.size() )\\n        {\\n            vector<int>& last = res.back();\\n            //Check for overlapping boundaries in the intervals and merge them suitably\\n            if( last[1] < intervals[i][0] )\\n            {\\n                res.push_back( intervals[i] );\\n            }\\n            else\\n            {\\n                last[1] = max( last[1], intervals[i][1] );\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comparator( vector<int>& a, vector<int>& b )\\n    {\\n        return a[0] < b[0];\\n    }\\n    \\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        //Handle Edge cases\\n        if( intervals.empty() )\\n        {\\n            return res;\\n        }\\n        \\n        if( intervals.size() == 1 )\\n        {\\n            res.push_back( intervals[0]);\\n            return res;\\n        }\\n        \\n        //Sort the inetrvals first based on the start of interval\\n        sort( intervals.begin(), intervals.end(), comparator );\\n        \\n        //Push the first interval into the result\\n        res.push_back( intervals[0] );\\n        int i = 1;\\n        while( i < intervals.size() )\\n        {\\n            vector<int>& last = res.back();\\n            //Check for overlapping boundaries in the intervals and merge them suitably\\n            if( last[1] < intervals[i][0] )\\n            {\\n                res.push_back( intervals[i] );\\n            }\\n            else\\n            {\\n                last[1] = max( last[1], intervals[i][1] );\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780416,
                "title": "c-100-east-9-lines-code-o-nlogn",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhat we are going to do is first we will push the first interval in the vector and will iterate over all the other intervals in the array.\\n\\nconsidering each interval[a,b] in the array we will check if the start of the interval is smaller than the end of the last interval[x,y] present in our vector i.e. y>a\\nif it is so then we will update the end value we will update the end value y with max(y,b)\\n\\nif y!>a then we will simply push the interval in the vector\\n\\nfollow the same steps for rest of the array elements and return the vector after reaching at the end\\n\\n\\n# Dry Run:\\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\\n1 ) push(1,3) int the ans vector\\n\\n2 ) check if end point of the last interval present in the ans vector is greater than the start point of the next interval  if(ans.back()[1] >= intervals[i][0]) i.e. if(3>=2) ...if yes then update the end point of the last interval of the vector..ans.back()[1] = max(ans.back()[1] , intervals[i][1]);   i.e max(3,6)\\nnow out vector ans = {(1,6)}\\n\\nif(ans.back()[1] >= intervals[i][0]) is now true then simply push that element int ans vector\\n\\n3)follow step 2 for all other elements of interval array and return ans at the end of the program\\n\\n\\n\\n# Code\\n```\\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\\n    {\\n        if(intervals.size()<=1) return intervals;\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(ans.back()[1] >= intervals[i][0]) ans.back()[1] = max(ans.back()[1] , intervals[i][1]);\\n            else ans.push_back(intervals[i]); \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\\n    {\\n        if(intervals.size()<=1) return intervals;\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(ans.back()[1] >= intervals[i][0]) ans.back()[1] = max(ans.back()[1] , intervals[i][1]);\\n            else ans.push_back(intervals[i]); \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1558586,
                "title": "best-and-simple-c-solution",
                "content": "Just take two pointers \"**start**\" and \"**end**\" pointing to the first index.\\nIterate through the vector:\\n\\t1. Update the **end** if the current index can merge with the \"**start**\" and \"**end**\" else\\n\\t2. Push the {start, end} into the answer, and make \"**start**\" and \"**end**\" pointing to current index.\\n\\n```\\nvector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        sort(v.begin(), v.end());\\t\\t\\n        int start = v[0][0];\\n        int end = v[0][1];        \\n\\t\\tvector<vector<int>> ans;\\n        \\n\\t\\tfor(int i=1;i<v.size();i++)\\n        {\\n            if(v[i][0] > end)\\n            {\\n                ans.push_back({start, end});\\n                start = v[i][0];\\n                end = v[i][1];\\n            }\\n            else if(v[i][0] <= end)\\n            {\\n                end = max(end, v[i][1]);\\n            }\\n        }\\n        ans.push_back({start, end});\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        sort(v.begin(), v.end());\\t\\t\\n        int start = v[0][0];\\n        int end = v[0][1];        \\n\\t\\tvector<vector<int>> ans;\\n        \\n\\t\\tfor(int i=1;i<v.size();i++)\\n        {\\n            if(v[i][0] > end)\\n            {\\n                ans.push_back({start, end});\\n                start = v[i][0];\\n                end = v[i][1];\\n            }\\n            else if(v[i][0] <= end)\\n            {\\n                end = max(end, v[i][1]);\\n            }\\n        }\\n        ans.push_back({start, end});\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349104,
                "title": "c-o-n-log-n-sort-by-start-time-and-merge-intervals",
                "content": "``` csharp\\nclass Interval\\n{\\n    public readonly int Start;\\n    public readonly int End;\\n    \\n    public Interval(int start, int end)\\n    {\\n        Start = start;\\n        End = end;\\n    }\\n}\\n\\npublic class Solution \\n{\\n    public int[][] Merge(int[][] input) \\n    {\\n        if(input == null || input.GetLength(0) <= 1)\\n        {\\n            return input;\\n        }\\n        \\n        List<Interval> intervals = new List<Interval>();\\n        List<int[]> result = new List<int[]>();\\n        \\n        for(int i = 0; i < input.GetLength(0); i++)\\n        {\\n            intervals.Add(new Interval(input[i][0], input[i][1]));\\n        }\\n        \\n        intervals = intervals.OrderBy(x => x.Start).ThenBy(x => x.End).ToList();\\n        \\n        int start = 0;\\n        int end = 0;        \\n        int j = 0;\\n        \\n        while(j < intervals.Count)\\n        {\\n            start = intervals[j].Start;\\n            end = intervals[j].End;\\n            j++;\\n            \\n            while(j < intervals.Count && intervals[j].Start <= end)\\n            {\\n                end = Math.Max(end, intervals[j].End);   \\n                j++;\\n            }       \\n            result.Add(new int[] { start, end});           \\n        }                \\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "``` csharp\\nclass Interval\\n{\\n    public readonly int Start;\\n    public readonly int End;\\n    \\n    public Interval(int start, int end)\\n    {\\n        Start = start;\\n        End = end;\\n    }\\n}\\n\\npublic class Solution \\n{\\n    public int[][] Merge(int[][] input) \\n    {\\n        if(input == null || input.GetLength(0) <= 1)\\n        {\\n            return input;\\n        }\\n        \\n        List<Interval> intervals = new List<Interval>();\\n        List<int[]> result = new List<int[]>();\\n        \\n        for(int i = 0; i < input.GetLength(0); i++)\\n        {\\n            intervals.Add(new Interval(input[i][0], input[i][1]));\\n        }\\n        \\n        intervals = intervals.OrderBy(x => x.Start).ThenBy(x => x.End).ToList();\\n        \\n        int start = 0;\\n        int end = 0;        \\n        int j = 0;\\n        \\n        while(j < intervals.Count)\\n        {\\n            start = intervals[j].Start;\\n            end = intervals[j].End;\\n            j++;\\n            \\n            while(j < intervals.Count && intervals[j].Start <= end)\\n            {\\n                end = Math.Max(end, intervals[j].End);   \\n                j++;\\n            }       \\n            result.Add(new int[] { start, end});           \\n        }                \\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651683,
                "title": "solution-swift-merge-intervals",
                "content": "```swift\\nclass Solution {\\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\\n        \\n        let sorted = intervals.sorted(by: {$0[0] < $1[0]})\\n        guard let first = sorted.first else { return [[Int]]() }\\n\\n        var merged = [first]\\n        \\n        for current in sorted {\\n            guard let last = merged.last else { continue }\\n\\n            let prev = last[0]\\n            let penult = last[1]\\n            \\n            let start = current[0], end = current[1]\\n            \\n            if penult >= start {\\n                merged[merged.count - 1] = [prev, max(penult, end)]\\n            } else {\\n                merged.append(current)\\n            }\\n        }\\n        return merged\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\\n        \\n        let sorted = intervals.sorted(by: {$0[0] < $1[0]})\\n        guard let first = sorted.first else { return [[Int]]() }\\n\\n        var merged = [first]\\n        \\n        for current in sorted {\\n            guard let last = merged.last else { continue }\\n\\n            let prev = last[0]\\n            let penult = last[1]\\n            \\n            let start = current[0], end = current[1]\\n            \\n            if penult >= start {\\n                merged[merged.count - 1] = [prev, max(penult, end)]\\n            } else {\\n                merged.append(current)\\n            }\\n        }\\n        return merged\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325159,
                "title": "c-solution-with-easy-complete-explaination",
                "content": "**Time complexity - O(n logn) + O(n)**  \\n **space complexity - O(n)** \\n \\n steps:\\n 1. sort the given intervals on the basis of the starting point \\n    suppose- [3,5] 3 is the starting point(0) and  5 is the ending point(1) \\n2. After sorting there will be 3 cases coming up:\\n   case 1:\\n   If there is no overlapping in the intervals. in this take the max of the       ending points\\n   case 2:\\n   if there is partial overapping\\n   case 3 : \\n   when there is no overlapping\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n            \\n        vector<vector<int>> mergedIntervals;\\n        if(intervals.size()==0)\\n            return mergedIntervals;\\n        \\n        sort(intervals.begin(),intervals.end());// sort\\n        vector<int> pre_interval = intervals[0];\\n        // 0 is starting point\\n        //1 is ending point\\n        \\n        for(auto interval:intervals)\\n        {\\n            if(interval[0]<=pre_interval[1])// means there is overlapping of intervals\\n            {\\n                pre_interval[1]=max(interval[1],pre_interval[1]); // need to check which has max ending points hence we will make ending point of pre_interval to max\\n            }\\n            else\\n            { // if there is no overlapping\\n                mergedIntervals.push_back(pre_interval); // simplely push pre-interval to mergedintervals vector\\n                pre_interval=interval;\\n            }     \\n        }\\n        \\n        mergedIntervals.push_back(pre_interval);\\n        return mergedIntervals;\\n    }\\n};\\n```\\n***Please upvote if you like the solution and comment if have doubts***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n            \\n        vector<vector<int>> mergedIntervals;\\n        if(intervals.size()==0)\\n            return mergedIntervals;\\n        \\n        sort(intervals.begin(),intervals.end());// sort\\n        vector<int> pre_interval = intervals[0];\\n        // 0 is starting point\\n        //1 is ending point\\n        \\n        for(auto interval:intervals)\\n        {\\n            if(interval[0]<=pre_interval[1])// means there is overlapping of intervals\\n            {\\n                pre_interval[1]=max(interval[1],pre_interval[1]); // need to check which has max ending points hence we will make ending point of pre_interval to max\\n            }\\n            else\\n            { // if there is no overlapping\\n                mergedIntervals.push_back(pre_interval); // simplely push pre-interval to mergedintervals vector\\n                pre_interval=interval;\\n            }     \\n        }\\n        \\n        mergedIntervals.push_back(pre_interval);\\n        return mergedIntervals;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186514,
                "title": "python3-line-sweep-for-merge-interval-and-employee-free-time",
                "content": "`Merge Interval` and `Employee Free Time` are opposite to each other. \\nThe former computes the `occupied time`; the latter computes the `free time`. \\n\\nBoth questions can be solved using line-sweep method. \\n\\nSuppose `schedule = [[1,3],[6,7],[2,4],[2,5],[9,12]]`, \\nwe can represent it as a sorted array: `1( 2( 2( 3) 4) 5) 6( 7) 9( 12)`\\nIgnoring numbers, we have a schedule structure like `((())),(),()`\\nThe merged interval would be `(--),(--),(--)`\\nThe free time would be `(),--(),--()`\\n\\n``` python\\n\"\"\" Merge Interval\"\"\"\\nclass Solution:\\n    def merge(self, intervals):        \\n        START, END = 0, 1   # open first at same time\\n        events = []\\n        for iv in intervals:\\n            events.append((iv.start, START))\\n            events.append((iv.end, END))\\n        events.sort()\\n\\n        res = []\\n        balance = 0\\n        for i, (t, ev) in enumerate(events):\\n            if balance == 0: prev = t\\n            balance += (1 if ev == START else -1)\\n            if balance == 0: res.append(Interval(prev, t))\\n                \\n        return res\\n```\\n\\n``` python\\n\"\"\" Free Time\"\"\"\\nclass Solution:\\n    def employeeFreeTime(self, schedule):\\n        START, END = 0, 1    # open first at same time\\n        events = []\\n        for emp in schedule:\\n            for iv in emp:\\n                events.append((iv.start, START))\\n                events.append((iv.end, END))\\n        events.sort()\\n\\n        res = []\\n        balance = 0\\n        prev = None\\n        for t, event in events:\\n            if balance == 0 and prev is not None: res.append(Interval(prev, t))\\n            balance += (1 if event == START else -1)\\n            if balance == 0: prev = t\\n        return res\\n```",
                "solutionTags": [],
                "code": "``` python\\n\"\"\" Merge Interval\"\"\"\\nclass Solution:\\n    def merge(self, intervals):        \\n        START, END = 0, 1   # open first at same time\\n        events = []\\n        for iv in intervals:\\n            events.append((iv.start, START))\\n            events.append((iv.end, END))\\n        events.sort()\\n\\n        res = []\\n        balance = 0\\n        for i, (t, ev) in enumerate(events):\\n            if balance == 0: prev = t\\n            balance += (1 if ev == START else -1)\\n            if balance == 0: res.append(Interval(prev, t))\\n                \\n        return res\\n```\n``` python\\n\"\"\" Free Time\"\"\"\\nclass Solution:\\n    def employeeFreeTime(self, schedule):\\n        START, END = 0, 1    # open first at same time\\n        events = []\\n        for emp in schedule:\\n            for iv in emp:\\n                events.append((iv.start, START))\\n                events.append((iv.end, END))\\n        events.sort()\\n\\n        res = []\\n        balance = 0\\n        prev = None\\n        for t, event in events:\\n            if balance == 0 and prev is not None: res.append(Interval(prev, t))\\n            balance += (1 if event == START else -1)\\n            if balance == 0: prev = t\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520772,
                "title": "c-java-python-javascript-array-tc-o-n-log-n-easy-to-understand-solution",
                "content": "# Intuition:\\nThe idea is to sort the intervals by their start time, and then merge them by checking if the end time of the previous interval is greater than or equal to the start time of the current interval. If so, we merge the intervals by updating the end time of the previous interval to be the maximum of its current end time and the end time of the current interval. Otherwise, we add the previous interval to the answer vector and update the previous interval to be the current interval.\\n\\n# Approach:\\n1. Sort the intervals based on their start time.\\n2. Initialize an empty vector of vectors to store the merged intervals.\\n3. Initialize a temporary vector to store the first interval from the sorted input vector.\\n4. Iterate over the input intervals from the second interval.\\n5. If the start time of the current interval is less than or equal to the end time of the temporary interval, update the end time of the temporary interval to be the maximum of its current end time and the end time of the current interval.\\n6. Otherwise, add the temporary interval to the answer vector and update the temporary interval to be the current interval.\\n7. After the loop, add the last temporary interval to the answer vector.\\n8. Return the answer vector.\\n# Complexity:\\n- Time Complexity:\\nThe time complexity of this approach is O(n log n) due to the sorting operation, where n is the number of intervals. The for loop takes O(n) time to iterate over all intervals, and the inner operations take constant time.\\n\\n- Space Complexity:\\nThe space complexity of this approach is O(n) to store the answer vector and the temporary vector.\\n\\n---\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        if(intervals.size()==0){\\n            return ans;\\n        }\\n        vector <int> temp = intervals[0];\\n        for(int i=0;i<intervals.size();i++){\\n            if(intervals[i][0]<=temp[1]){\\n                temp[1]=max(temp[1],intervals[i][1]);\\n            }\\n            else{\\n                ans.push_back(temp);\\n                temp=intervals[i];\\n            }\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```\\n---\\n# Java\\n```java\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> ans = new ArrayList<>();\\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\\n\\n        if (intervals.length == 0) {\\n            return ans.toArray(new int[0][]);\\n        }\\n\\n        int[] temp = intervals[0];\\n        for (int i = 0; i < intervals.length; i++) {\\n            if (intervals[i][0] <= temp[1]) {\\n                temp[1] = Math.max(temp[1], intervals[i][1]);\\n            } else {\\n                ans.add(temp);\\n                temp = intervals[i];\\n            }\\n        }\\n        ans.add(temp);\\n\\n        return ans.toArray(new int[0][]);\\n    }\\n}\\n```\\n---\\n# Python\\n```py\\nclass Solution(object):\\n    def merge(self, intervals):\\n        ans = []\\n        intervals.sort()\\n\\n        if len(intervals) == 0:\\n            return ans\\n\\n        temp = intervals[0]\\n        for interval in intervals:\\n            if interval[0] <= temp[1]:\\n                temp[1] = max(temp[1], interval[1])\\n            else:\\n                ans.append(temp)\\n                temp = interval\\n        ans.append(temp)\\n\\n        return ans\\n\\n```\\n---\\n# JavaScript\\n```js\\nvar merge = function(intervals) {\\n    let ans = [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    if (intervals.length === 0) {\\n        return ans;\\n    }\\n\\n    let temp = intervals[0];\\n    for (let i = 0; i < intervals.length; i++) {\\n        if (intervals[i][0] <= temp[1]) {\\n            temp[1] = Math.max(temp[1], intervals[i][1]);\\n        } else {\\n            ans.push(temp);\\n            temp = intervals[i];\\n        }\\n    }\\n    ans.push(temp);\\n\\n    return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        if(intervals.size()==0){\\n            return ans;\\n        }\\n        vector <int> temp = intervals[0];\\n        for(int i=0;i<intervals.size();i++){\\n            if(intervals[i][0]<=temp[1]){\\n                temp[1]=max(temp[1],intervals[i][1]);\\n            }\\n            else{\\n                ans.push_back(temp);\\n                temp=intervals[i];\\n            }\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> ans = new ArrayList<>();\\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\\n\\n        if (intervals.length == 0) {\\n            return ans.toArray(new int[0][]);\\n        }\\n\\n        int[] temp = intervals[0];\\n        for (int i = 0; i < intervals.length; i++) {\\n            if (intervals[i][0] <= temp[1]) {\\n                temp[1] = Math.max(temp[1], intervals[i][1]);\\n            } else {\\n                ans.add(temp);\\n                temp = intervals[i];\\n            }\\n        }\\n        ans.add(temp);\\n\\n        return ans.toArray(new int[0][]);\\n    }\\n}\\n```\n```py\\nclass Solution(object):\\n    def merge(self, intervals):\\n        ans = []\\n        intervals.sort()\\n\\n        if len(intervals) == 0:\\n            return ans\\n\\n        temp = intervals[0]\\n        for interval in intervals:\\n            if interval[0] <= temp[1]:\\n                temp[1] = max(temp[1], interval[1])\\n            else:\\n                ans.append(temp)\\n                temp = interval\\n        ans.append(temp)\\n\\n        return ans\\n\\n```\n```js\\nvar merge = function(intervals) {\\n    let ans = [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    if (intervals.length === 0) {\\n        return ans;\\n    }\\n\\n    let temp = intervals[0];\\n    for (let i = 0; i < intervals.length; i++) {\\n        if (intervals[i][0] <= temp[1]) {\\n            temp[1] = Math.max(temp[1], intervals[i][1]);\\n        } else {\\n            ans.push(temp);\\n            temp = intervals[i];\\n        }\\n    }\\n    ans.push(temp);\\n\\n    return ans;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454316,
                "title": "java-treemap-simple-solution-with-explanation",
                "content": "The idea is to use both starts and ends as keys, but +1 for a start and -1 for an end as values. So, going by sorted keys and gathering sum of values we will know for sure when current interval finishes (we have + 1 at start and -1 at finish -> 0 when interval finishes). \\nIn case of overlaps starts will sum up (3 starts crossed -> 3) and eventually at the last finish(3 finishes crossed -> 3 -3 = 0) it became 0 nevertheless. \\n\\nComplexity is n(log(n)) due to the nature of tree map.\\n\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> list = new LinkedList<>();\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        \\n        for (int[] interval : intervals) {\\n            map.put(interval[0], map.getOrDefault(interval[0], 0) + 1);\\n            map.put(interval[1], map.getOrDefault(interval[1], 0) - 1);\\n        }\\n        \\n        int activeInterval = 0;\\n        int start = 0;\\n        for (int key: map.keySet()) {\\n            if (activeInterval == 0) {\\n                start = key;\\n            }    \\n            activeInterval += map.get(key);\\n            if (activeInterval == 0) {\\n                list.add(new int[]{start, key});\\n            }\\n        }\\n        \\n        return listToArray(list);\\n    }\\n    \\n    private int[][] listToArray(List<int[]> list) {\\n        int[][] result = new int[list.size()][2];\\n        for (int i = 0; i < list.size(); i++) {\\n            result[i] = list.get(i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> list = new LinkedList<>();\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        \\n        for (int[] interval : intervals) {\\n            map.put(interval[0], map.getOrDefault(interval[0], 0) + 1);\\n            map.put(interval[1], map.getOrDefault(interval[1], 0) - 1);\\n        }\\n        \\n        int activeInterval = 0;\\n        int start = 0;\\n        for (int key: map.keySet()) {\\n            if (activeInterval == 0) {\\n                start = key;\\n            }    \\n            activeInterval += map.get(key);\\n            if (activeInterval == 0) {\\n                list.add(new int[]{start, key});\\n            }\\n        }\\n        \\n        return listToArray(list);\\n    }\\n    \\n    private int[][] listToArray(List<int[]> list) {\\n        int[][] result = new int[list.size()][2];\\n        for (int i = 0; i < list.size(); i++) {\\n            result[i] = list.get(i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 438042,
                "title": "simple-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) {\\n\\t\\t\\treturn intervals;\\n        }\\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));\\n        \\n        List<int[]> result = new ArrayList<>();\\n\\t\\tfor (int[] interval : intervals) {\\n            // if list is empty or does not overlap with the previous, just append\\n            if (result.isEmpty() || result.get(result.size() - 1)[1] < interval[0]) {\\n                result.add(interval);\\n            } else {\\n                // if overlap, merge the current and previous intervals\\n                result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], interval[1]);\\n            }\\n\\t\\t}\\n\\n\\t\\treturn result.toArray(new int[result.size()][]);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) {\\n\\t\\t\\treturn intervals;\\n        }\\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));\\n        \\n        List<int[]> result = new ArrayList<>();\\n\\t\\tfor (int[] interval : intervals) {\\n            // if list is empty or does not overlap with the previous, just append\\n            if (result.isEmpty() || result.get(result.size() - 1)[1] < interval[0]) {\\n                result.add(interval);\\n            } else {\\n                // if overlap, merge the current and previous intervals\\n                result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], interval[1]);\\n            }\\n\\t\\t}\\n\\n\\t\\treturn result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928341,
                "title": "easy-js-solution",
                "content": "```\\nvar merge = function(intervals) {\\n    if (intervals.length == 0) return [];\\n    \\n    intervals.sort((a,b) => a[0] - b[0]);\\n    let stack = [];\\n    stack.push(intervals[0]);\\n    \\n    for (let i = 1; i < intervals.length; i++) {\\n        let prev = stack.pop();\\n        let cur = intervals[i];\\n        if (prev[1] >= cur[0]) {\\n            stack.push( [prev[0], Math.max(prev[1], cur[1])] );\\n        } else {\\n            stack.push(prev, cur);\\n        }\\n    }\\n    \\n    return stack;\\n    // Time Complexity: O(Nlog(N))\\n    // Space Complexity: O(N)\\n};\\n\\n// (1) [[1,3], [2,6]] => [[1,6]]\\n// (2) [[1,4],[2,3]] => [[1,4]]\\n// Two possible cases to perform merger:\\n// 1st case: we merge two arrays and obtain a bigger interval\\n// 2nd case: one array absorbs another array and the size doesn\\'t change.\\n// Therefore, to cover both cases, when we merge two arrays, we perform the following:\\n// [start of first arr, max(end of first arr, end of second arr)]\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n    if (intervals.length == 0) return [];\\n    \\n    intervals.sort((a,b) => a[0] - b[0]);\\n    let stack = [];\\n    stack.push(intervals[0]);\\n    \\n    for (let i = 1; i < intervals.length; i++) {\\n        let prev = stack.pop();\\n        let cur = intervals[i];\\n        if (prev[1] >= cur[0]) {\\n            stack.push( [prev[0], Math.max(prev[1], cur[1])] );\\n        } else {\\n            stack.push(prev, cur);\\n        }\\n    }\\n    \\n    return stack;\\n    // Time Complexity: O(Nlog(N))\\n    // Space Complexity: O(N)\\n};\\n\\n// (1) [[1,3], [2,6]] => [[1,6]]\\n// (2) [[1,4],[2,3]] => [[1,4]]\\n// Two possible cases to perform merger:\\n// 1st case: we merge two arrays and obtain a bigger interval\\n// 2nd case: one array absorbs another array and the size doesn\\'t change.\\n// Therefore, to cover both cases, when we merge two arrays, we perform the following:\\n// [start of first arr, max(end of first arr, end of second arr)]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21560,
                "title": "fast-ana-simple-java-code",
                "content": "\\n The idea is to sort intervals based on start and iterate all itervals to merge them if:\\n\\n    curr.end >= iter.start\\n\\nThe time complexity is : sort nO(logn)+ merge: O(n) = nO(logn)\\n\\nNo Extra space except necessary result : )\\n\\n       public class Solution {\\n            public List<Interval> merge(List<Interval> intervals) {\\n                List<Interval> res = new LinkedList<Interval>();\\n                if(intervals.size()<2) return intervals;\\n                Collections.sort(intervals, new Comparator<Interval>() {\\n                @Override\\n                    public int compare(Interval o1, Interval o2) {\\n                        return o1.start-o2.start;\\n                    }\\n                });\\n                Interval curr = intervals.get(0);\\n                for(Interval iter: intervals) {\\n                    if(curr.end >= iter.start) {\\n                        curr.end = Math.max(curr.end,iter.end);\\n                    }else {\\n                        res.add(curr);\\n                        curr = iter;\\n                    }\\n                }\\n                res.add(curr);\\n                return res;\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public List<Interval> merge(List<Interval> intervals) {\\n                List<Interval> res = new LinkedList<Interval>();\\n                if(intervals.size()<2) return intervals;\\n                Collections.sort(intervals, new Comparator<Interval>() {\\n                @Override\\n                    public int compare(Interval o1, Interval o2) {\\n                        return o1.start-o2.start;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3732852,
                "title": "most-optimal-solution-with-explanation-c-and-java-code",
                "content": "\\n\\n# Approach\\n- First, the intervals are sorted in ascending order based on their start times using the sort function. This is important for efficient merging.\\n\\n- A new vector called ans is created to store the merged intervals.\\n\\n- The solution iterates through each interval in the sorted intervals array.\\n\\n- If ans is empty or the start time of the current interval is greater than the end time of the last interval in ans, it means there is no overlap. In this case, the current interval is added to ans as a new non-overlapping interval.\\n\\n- If there is an overlap, the end time of the last interval in ans is updated to be the maximum of the current interval\\'s end time and the end time of the last interval in ans. This ensures that the merged interval covers the maximum range.\\n\\n- After iterating through all intervals, the function returns the ans vector, which contains the merged non-overlapping intervals.\\n\\nOverall, the solution works by sorting the intervals based on start times and then merging them iteratively, updating the end time as needed. This approach ensures that all overlapping intervals are merged, resulting in a set of non-overlapping intervals that cover the entire input array.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn + n)\\n\\n- Space complexity:\\nO(1). O(n) to store the answer\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        for(int i = 0; i< intervals.size(); i++){\\n            if(ans.empty() || intervals[i][0]>ans.back()[1]){\\n                ans.push_back(intervals[i]);\\n            }\\n            else {\\n                ans.back()[1] = max(intervals[i][1], ans.back()[1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# JAVA Code\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\\n        List<int[]> ans = new ArrayList<>();\\n        \\n        for (int[] interval : intervals) {\\n            if (ans.isEmpty() || interval[0] > ans.get(ans.size() - 1)[1]) {\\n                ans.add(interval);\\n            } else {\\n                ans.get(ans.size() - 1)[1] = Math.max(interval[1], ans.get(ans.size() - 1)[1]);\\n            }\\n        }\\n        \\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        for(int i = 0; i< intervals.size(); i++){\\n            if(ans.empty() || intervals[i][0]>ans.back()[1]){\\n                ans.push_back(intervals[i]);\\n            }\\n            else {\\n                ans.back()[1] = max(intervals[i][1], ans.back()[1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\\n        List<int[]> ans = new ArrayList<>();\\n        \\n        for (int[] interval : intervals) {\\n            if (ans.isEmpty() || interval[0] > ans.get(ans.size() - 1)[1]) {\\n                ans.add(interval);\\n            } else {\\n                ans.get(ans.size() - 1)[1] = Math.max(interval[1], ans.get(ans.size() - 1)[1]);\\n            }\\n        }\\n        \\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311657,
                "title": "simplest-way-to-solve-easy-java-code-o-nlogn",
                "content": "class Solution {\\n\\n    public int[][] merge(int[][] intervals) {\\n        \\n        Arrays.sort(intervals, (o1,o2)->Integer.compare(o1[0],o2[0]));          //sort the array on the basis of first interval\\n        ArrayList<int[]> list = new ArrayList<>();                              //to store the merge intervals\\n        int start = intervals[0][0];                                            //initialize start and end by the interval of the first row\\n        int end = intervals[0][1];\\n        \\n        for(int i=1;i<intervals.length;i++){                    //initialize i by 1, zeorth index intervals  already stored in start & end\\n           int s = intervals[i][0];                             //now store the intervals to compare with the previous one\\n            int e = intervals[i][1];\\n            \\n            if(s<=end){                                         //Now compare if the start (s) interval is less than the previous end interval then \\n                end=Math.max(end,e);                            //merge them, means update our end by the greater value of the end interval\\n            }else{                                              //if not means that interval is not overlapping in the current interval               \\n                list.add(new int[]{start,end});                 //add that previous merged interval into list and update start & end by the current intervals\\n                start = s;\\n                end = e;\\n            }\\n            \\n        }\\n        \\n        list.add(new int[]{start,end});                         //Don\\'t forget to add the last updated interval\\n        \\n        // int[][] res = new int[list.size()][2];               //we have to return the ans int 2D array format, you can do this or can also return directly\\n        // int i=0;\\n        // for(int[] ans : list){\\n        //     res[i] = ans;\\n        //     i++;\\n        // }\\n        \\n        return list.toArray(new int[list.size()][2]);            //by using toArray in built function BOTH are correct!\\n    }\\n}\\n\\n***Note: Kindly Upvote this article, if you found it helpful. Thanks For Reading!!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[][] merge(int[][] intervals) {\\n        \\n        Arrays.sort(intervals, (o1,o2)->Integer.compare(o1[0],o2[0]));          //sort the array on the basis of first interval\\n        ArrayList<int[]> list = new ArrayList<>();                              //to store the merge intervals\\n        int start = intervals[0][0];                                            //initialize start and end by the interval of the first row\\n        int end = intervals[0][1];\\n        \\n        for(int i=1;i<intervals.length;i++){                    //initialize i by 1, zeorth index intervals  already stored in start & end\\n           int s = intervals[i][0];                             //now store the intervals to compare with the previous one\\n            int e = intervals[i][1];\\n            \\n            if(s<=end){                                         //Now compare if the start (s) interval is less than the previous end interval then \\n                end=Math.max(end,e);                            //merge them, means update our end by the greater value of the end interval\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1805268,
                "title": "go-clean-code-with-explanation-and-visual-10ms-100",
                "content": "Hello Gophers!\\n\\n\\n## [Problem: Merge Intervals](https://leetcode.com/problems/merge-intervals/)\\n\\n> Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\\n\\nWe want to merge all overlapping intervals, here is a quick example:\\n\\nParams: `[][]int{{x1, y1}, {x2, y2}, {x3, y3}}`  \\n```\\n|-----------|\\nx1          y1\\n     |-----------|\\n     x2          y2\\n\\t                    |-----------|\\n                        x3          y3\\n```\\n\\nAs you can see, the two first intervals `{x1, y1}` and `{x2, y2}` are overlapping (`{x2, y1}`), so we need to merge them.\\n\\nResponse: `[][]int{{x1, y2}, {x3, y3}}`  \\n```\\n|----------------|\\nx1              y2\\n\\t                    |-----------|\\n                        x3          y3\\n```\\n\\nThe goal is to have a slice (array) of non-overlapping intervals.\\n\\n### Constraints\\n\\n1. `1 <= intervals.length <= 104`\\n2. `intervals[i].length == 2`\\n3. `0 <= starti <= endi <= 104`\\n\\n\\n## Definitions\\n\\nAn interval `[x, y]` is \"overlapping\" with the interval `[a, b]` if `x` <= `b` && `y` >= `a` (or `y` >= `a` && `x` >= `b`):\\n\\n```\\n|-----------|           |          |-----------|\\nx           y           |          x           y \\n     |-----------|      |     |-----------| \\n     a           b      |     a           b \\n```\\n\\nAn interval `[x, y]` is \"completely overlapping\" with the interval `[a, b]` if `x` <= `a` && `y` >= `b`:\\n\\n```\\n|----------------|\\nx                y\\n     |-----|\\n     a     b\\n```\\n\\n\\n## Algorithm\\n\\nThe algorithm is simple, let\\'s say an interval has two items `{x, y}`:\\n1. Sort the slice (array) of intervals `intervals`\\n2. We create a new slice of intervals (from the first interval of `intervals`) nammed `mergedIntervals` (it will be the returned value)\\n3. We iterate on every items (except the first one) of the `intervals` slice (let\\'s call it `interval`)  \\nand we compare it with the last item of the `mergedIntervals` slice (let\\'s call it `top`)\\n\\t4. **If the `interval` \"completely overlap\" `top`**: change `interval` for `top`\\n\\t5. **Else if`interval` \"overlap\" (but not completely) `top`**: change the `y` value of `interval` for the `y` value of `top`\\n\\t6. **Else**: do nothing\\n\\n### Solution (code)\\n\\nTime: `O(nlogn)`\\nSpace: `O(n)`\\n\\n```go\\n// Time: O(nlogn + n) = O(nlogn)\\n// Space: O(n)\\nfunc merge(intervals [][]int) [][]int {\\n    if len(intervals) <= 1 {\\n        return intervals\\n    }\\n\\n\\t// Time: O(nlogn)\\n    sortIntervals(intervals)\\n    \\n\\t// Space: O(n)\\n    mergedIntervals := make([][]int, 0, len(intervals))\\n    mergedIntervals = append(mergedIntervals, intervals[0])\\n\\n\\t// Time: O(n)\\n    for _, interval := range intervals[1:] {        \\n        if top := mergedIntervals[len(mergedIntervals)-1]; interval[0] > top[1] {\\n            mergedIntervals = append(mergedIntervals, interval)\\n        } else if interval[1] > top[1] {\\n            top[1] = interval[1]\\n        }\\n    }\\n    \\n    return mergedIntervals\\n}\\n\\n// If an interval is {x, y},\\n// sortIntervals sorts the intervals by their \"x\" value.\\n// Time: O(nlogn)\\n// Space: O(1)\\nfunc sortIntervals(intervals [][]int) {\\n\\t// Time: O(nlogn)\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n}\\n```\\n\\n## Example\\n\\n`intervals`: `[][]int{{1, 4}, {0, 3}, {5, 7}, {1, 2}}`  \\n```\\n    |---------------|\\n    1               4\\n|--------------|\\n0              3\\n\\t                      |-----------|\\n                          5           7\\n    |------|\\n    1      2\\n```\\n\\n`intervals` sorted with `sortIntervals(...)`: `[][]int{{0, 3}, {1, 4}, {1, 2}, {5, 7}}`  \\n```\\n|--------------|\\n0              3\\n    |---------------|\\n    1               4\\n    |------|\\n    1      2\\n\\t                      |-----------|\\n                          5           7\\n```\\n\\n`mergedIntervals` creation with the first item of `intervals`: `[][]int{{0, 3}}`  \\n\\n```\\n|--------------|\\n0              3\\n```\\n\\n`mergedIntervals` after second `interval` `{1, 4}`: `[][]int{{0, 4}}`  (`{0, 3}` overlaps `{1, 4}`)\\n\\n```\\n|-------------------|\\n0                   4\\n```\\n\\n`mergedIntervals` after third `interval` `{1, 2}`: `[][]int{{0, 4}}`    (`{0, 4}` completely overlaps `{1, 4}`)\\n\\n```\\n|-------------------|\\n0                   4\\n```\\n\\n`mergedIntervals` after fourth `interval` `{5, 7}`: `[][]int{{0, 4}, {5, 7}}`   (no overlapping)\\n\\n```\\n|-------------------|\\n0                   4\\n\\t                      |-----------|\\n                          5           7\\n```\\n\\n## Follow-up\\n\\nA way to not have `O(n)` as space complexity would be to update the intervals sent in params (instead of creating a new one).\\n\\n## Similar Questions\\n\\n1. [[Medium] 56. Merge Intervals](https://leetcode.com/problems/merge-intervals/discuss/1805268/Go-Clean-Code-with-explanation-and-visual-(10ms-100)) **(this problem)**\\n2. [[Easy] 495. Teemo Attacking](https://leetcode.com/problems/teemo-attacking/discuss/1805603/Go-Clean-code-with-comments-(30ms-98))\\n3. [[Medium] 57. Insert Interval](https://leetcode.com/problems/insert-interval/discuss/1807161/Go-Clean-Code-with-visual-(1ms-100))\\n4. [[Medium] 986. Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/discuss/1823039/Go-Clean-Code-with-explanation-and-visual-(10ms-100))\\n5. [[Easy] 252. Meeting Rooms](https://leetcode.com/problems/meeting-rooms/discuss/1512776/Go-Meeting-Rooms-Clean-solution)\\n6. [[Medium] 253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/discuss/1826838/Go-Multiple-Solutions-(0ms-100)) \\n7. [[Medium] 435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/discuss/1843676/Go-Clean-solution-(185ms-100))\\n8. [[Medium] 763. Partition Labels](https://leetcode.com/problems/partition-labels/discuss/2027004/Go-Merge-and-Sort-Intervals-0ms-(100))\\n9. [[Medium] Single-Threaded CPU](https://leetcode.com/problems/single-threaded-cpu/)\\n10. [[Hard] 759. Employee Free Time](https://leetcode.com/problems/employee-free-time/)\\n\\nI hope it helped! :)",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n|-----------|\\nx1          y1\\n     |-----------|\\n     x2          y2\\n\\t                    |-----------|\\n                        x3          y3\\n```\n```\\n|----------------|\\nx1              y2\\n\\t                    |-----------|\\n                        x3          y3\\n```\n```\\n|-----------|           |          |-----------|\\nx           y           |          x           y \\n     |-----------|      |     |-----------| \\n     a           b      |     a           b \\n```\n```\\n|----------------|\\nx                y\\n     |-----|\\n     a     b\\n```\n```go\\n// Time: O(nlogn + n) = O(nlogn)\\n// Space: O(n)\\nfunc merge(intervals [][]int) [][]int {\\n    if len(intervals) <= 1 {\\n        return intervals\\n    }\\n\\n\\t// Time: O(nlogn)\\n    sortIntervals(intervals)\\n    \\n\\t// Space: O(n)\\n    mergedIntervals := make([][]int, 0, len(intervals))\\n    mergedIntervals = append(mergedIntervals, intervals[0])\\n\\n\\t// Time: O(n)\\n    for _, interval := range intervals[1:] {        \\n        if top := mergedIntervals[len(mergedIntervals)-1]; interval[0] > top[1] {\\n            mergedIntervals = append(mergedIntervals, interval)\\n        } else if interval[1] > top[1] {\\n            top[1] = interval[1]\\n        }\\n    }\\n    \\n    return mergedIntervals\\n}\\n\\n// If an interval is {x, y},\\n// sortIntervals sorts the intervals by their \"x\" value.\\n// Time: O(nlogn)\\n// Space: O(1)\\nfunc sortIntervals(intervals [][]int) {\\n\\t// Time: O(nlogn)\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n}\\n```\n```\\n    |---------------|\\n    1               4\\n|--------------|\\n0              3\\n\\t                      |-----------|\\n                          5           7\\n    |------|\\n    1      2\\n```\n```\\n|--------------|\\n0              3\\n    |---------------|\\n    1               4\\n    |------|\\n    1      2\\n\\t                      |-----------|\\n                          5           7\\n```\n```\\n|--------------|\\n0              3\\n```\n```\\n|-------------------|\\n0                   4\\n```\n```\\n|-------------------|\\n0                   4\\n```\n```\\n|-------------------|\\n0                   4\\n\\t                      |-----------|\\n                          5           7\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1912536,
                "title": "100-fastest-swift-solution-time-o-n-log-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log(n)), where n is the number of intervals.\\n    //   - space: O(n), where n is the number of intervals.\\n    \\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\\n        guard !intervals.isEmpty else { return [] }\\n        var intervals = intervals.sorted(by: { $0[0] < $1[0] })\\n        \\n        var ans = [[Int]]()\\n        var start = intervals[0][0]\\n        var end = intervals[0][1]\\n        \\n        for interval in intervals {\\n            guard end < interval[0] else {\\n                end = max(end, interval[1])\\n                continue\\n            }\\n            ans.append([start, end])\\n            start = interval[0]\\n            end = interval[1]\\n        }\\n        \\n        ans.append([start, end])\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log(n)), where n is the number of intervals.\\n    //   - space: O(n), where n is the number of intervals.\\n    \\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\\n        guard !intervals.isEmpty else { return [] }\\n        var intervals = intervals.sorted(by: { $0[0] < $1[0] })\\n        \\n        var ans = [[Int]]()\\n        var start = intervals[0][0]\\n        var end = intervals[0][1]\\n        \\n        for interval in intervals {\\n            guard end < interval[0] else {\\n                end = max(end, interval[1])\\n                continue\\n            }\\n            ans.append([start, end])\\n            start = interval[0]\\n            end = interval[1]\\n        }\\n        \\n        ans.append([start, end])\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810276,
                "title": "simple-java-solution",
                "content": "#### ***PLS UPVOTE :)***\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        \\n        //declaring an array list to store the pairs\\n        ArrayList<int[]> list=new ArrayList<>();\\n        \\n        //sorting the given interval array based on starting point\\n        Arrays.sort(intervals,(a,b)->a[0]-b[0]);\\n        \\n        //defining start and end point\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        \\n        //we will iterate through the 2d array intervals so in each iteration we will get a row[1D array] as i\\n        \\n        for(int[] i:intervals){\\n            //check if end point of 1st pair if greater than the starting point of the 2nd pair or not, basically we check it\\'s in overlapping condition or not\\n            \\n            if(i[0]<=end){\\n                end=Math.max(end,i[1]);\\n            }\\n            \\n            //otherwise add it in the list\\n            else{\\n                list.add(new int[]{start,end});\\n                start=i[0];\\n                end=i[1];\\n            }\\n            \\n        }\\n        \\n        list.add(new int[]{start,end});\\n        return list.toArray(new int[0][]);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        \\n        //declaring an array list to store the pairs\\n        ArrayList<int[]> list=new ArrayList<>();\\n        \\n        //sorting the given interval array based on starting point\\n        Arrays.sort(intervals,(a,b)->a[0]-b[0]);\\n        \\n        //defining start and end point\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        \\n        //we will iterate through the 2d array intervals so in each iteration we will get a row[1D array] as i\\n        \\n        for(int[] i:intervals){\\n            //check if end point of 1st pair if greater than the starting point of the 2nd pair or not, basically we check it\\'s in overlapping condition or not\\n            \\n            if(i[0]<=end){\\n                end=Math.max(end,i[1]);\\n            }\\n            \\n            //otherwise add it in the list\\n            else{\\n                list.add(new int[]{start,end});\\n                start=i[0];\\n                end=i[1];\\n            }\\n            \\n        }\\n        \\n        list.add(new int[]{start,end});\\n        return list.toArray(new int[0][]);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351533,
                "title": "a-java-sorting-solution",
                "content": "The basic idea is to compare current end time with next start time, if next start time is smaller than current end time, then there is a collapse. In order to achieve this approach, we need to \\n\\n1.  Seperate start time and end time into different arrays and sort them in ascending order.\\n2.  For each end time, compare it with next start time. We use j to mark start time and i to mark end time.  When collapse appears, record start time and end time, and move j to next end time(which is i++) as the new start.\\n3.  Since this approach will miss the last stat time, add the last time section with start time j and the final end time.\\n```\\npublic int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0){\\n            return new int[0][];\\n        }\\n\\t\\t// seperate start and end \\n        int[] start = new int[intervals.length];\\n        int[] end = new int[intervals.length];\\n        List<int[]> res = new LinkedList<>();\\n        for(int i = 0; i < intervals.length; i++){\\n            start[i] = intervals[i][0];\\n            end[i] = intervals[i][1];\\n        }\\n\\t\\t\\n\\t\\t// sort start[] end[] respectively\\n        Arrays.sort(start);\\n        Arrays.sort(end);\\n\\t\\t\\n        int j = 0; // start time\\n        for(int i = 0; i < intervals.length - 1; i++) { // iterate end time\\n            if(start[i + 1] > end[i]) { // when collapse appears\\n                res.add(new int[] {start[j], end[i]}); // record\\n                j = i + 1; // move previous start time \\n            }    \\n        }\\n        res.add(new int[] {start[j], end[intervals.length - 1]}); // add last one\\n        return res.toArray(new int[res.size()][]);\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "The basic idea is to compare current end time with next start time, if next start time is smaller than current end time, then there is a collapse. In order to achieve this approach, we need to \\n\\n1.  Seperate start time and end time into different arrays and sort them in ascending order.\\n2.  For each end time, compare it with next start time. We use j to mark start time and i to mark end time.  When collapse appears, record start time and end time, and move j to next end time(which is i++) as the new start.\\n3.  Since this approach will miss the last stat time, add the last time section with start time j and the final end time.\\n```\\npublic int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0){\\n            return new int[0][];\\n        }\\n\\t\\t// seperate start and end \\n        int[] start = new int[intervals.length];\\n        int[] end = new int[intervals.length];\\n        List<int[]> res = new LinkedList<>();\\n        for(int i = 0; i < intervals.length; i++){\\n            start[i] = intervals[i][0];\\n            end[i] = intervals[i][1];\\n        }\\n\\t\\t\\n\\t\\t// sort start[] end[] respectively\\n        Arrays.sort(start);\\n        Arrays.sort(end);\\n\\t\\t\\n        int j = 0; // start time\\n        for(int i = 0; i < intervals.length - 1; i++) { // iterate end time\\n            if(start[i + 1] > end[i]) { // when collapse appears\\n                res.add(new int[] {start[j], end[i]}); // record\\n                j = i + 1; // move previous start time \\n            }    \\n        }\\n        res.add(new int[] {start[j], end[intervals.length - 1]}); // add last one\\n        return res.toArray(new int[res.size()][]);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 299582,
                "title": "clean-python-beats-95",
                "content": "```\\ndef merge(self, intervals: \\'List[Interval]\\') -> \\'List[Interval]\\':\\n\\tif not intervals: return []\\n\\tintervals.sort()\\n\\n\\tunique = []\\n\\tlast = intervals[0]\\n\\tfor cur in intervals:\\n\\t\\tif cur[0] <= last[1]:\\n\\t\\t\\tlast[1] = max(last[1], cur[1])\\n\\t\\telse:\\n\\t\\t\\tunique.append(last)\\n\\t\\t\\tlast = cur\\n\\n\\tunique.append(last)\\n\\treturn unique\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef merge(self, intervals: \\'List[Interval]\\') -> \\'List[Interval]\\':\\n\\tif not intervals: return []\\n\\tintervals.sort()\\n\\n\\tunique = []\\n\\tlast = intervals[0]\\n\\tfor cur in intervals:\\n\\t\\tif cur[0] <= last[1]:\\n\\t\\t\\tlast[1] = max(last[1], cur[1])\\n\\t\\telse:\\n\\t\\t\\tunique.append(last)\\n\\t\\t\\tlast = cur\\n\\n\\tunique.append(last)\\n\\treturn unique\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3129464,
                "title": "95-javascript-fast-very-very-easy-to-understand-solution-with-video-explanation-en-kr",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nEnglish video!\\n\\nhttps://youtu.be/EqL8ce_yZbI\\n\\nKorean video!\\n\\nhttps://youtu.be/CYGaPW7S5v4\\n# Code\\n```\\n/**\\n * @param {number[][]} intervals\\n * @return {number[][]}\\n */\\nvar merge = function(intervals) {\\n    intervals.sort((a,b)=>a[0]-b[0])\\n    for(let i =1; i<intervals.length;i++){\\n        let [x,y] = intervals[i]\\n        let [prevX,prevY] = intervals[i-1]\\n        if(x <= prevY) {\\n            intervals[i-1][1] = Math.max(y,prevY);\\n            intervals.splice(i,1)\\n            i--\\n        }\\n    }\\n    return intervals    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @return {number[][]}\\n */\\nvar merge = function(intervals) {\\n    intervals.sort((a,b)=>a[0]-b[0])\\n    for(let i =1; i<intervals.length;i++){\\n        let [x,y] = intervals[i]\\n        let [prevX,prevY] = intervals[i-1]\\n        if(x <= prevY) {\\n            intervals[i-1][1] = Math.max(y,prevY);\\n            intervals.splice(i,1)\\n            i--\\n        }\\n    }\\n    return intervals    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21404,
                "title": "easy-python-first-sort-with-start",
                "content": "    # Definition for an interval.\\n    # class Interval(object):\\n    #     def __init__(self, s=0, e=0):\\n    #         self.start = s\\n    #         self.end = e\\n    \\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            intervals = sorted(intervals, key=lambda x: x.start)\\n            n=len(intervals)\\n            if n==0:\\n                return []\\n            re=[]\\n            re.append(intervals[0])\\n            for i in range(1,n):\\n                a=re[-1]\\n                b=intervals[i]\\n                if b.start>a.end:\\n                    re.append(b)\\n                else:\\n                    re[-1].end=max(a.end,b.end)\\n            return re",
                "solutionTags": [],
                "code": "    # Definition for an interval.\\n    # class Interval(object):\\n    #     def __init__(self, s=0, e=0):\\n    #         self.start = s\\n    #         self.end = e\\n    \\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            intervals = sorted(intervals, key=lambda x: x.start)\\n            n=len(intervals)\\n            if n==0:\\n                return []\\n            re=[]\\n            re.append(intervals[0])\\n            for i in range(1,n):\\n                a=re[-1]\\n                b=intervals[i]\\n                if b.start>a.end:\\n                    re.append(b)\\n                else:\\n                    re[-1].end=max(a.end,b.end)\\n            return re",
                "codeTag": "Java"
            },
            {
                "id": 3707961,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(ans.back()[1]>=intervals[i][0])\\n            ans.back()[1]=max(ans.back()[1],intervals[i][1]);\\n            else ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```Please upvote to motivate me write more solution",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(ans.back()[1]>=intervals[i][0])\\n            ans.back()[1]=max(ans.back()[1],intervals[i][1]);\\n            else ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788731,
                "title": "c-easy-solution",
                "content": "\\n```\\nvector<vector<int>> merge(vector<vector<int>>& v) // v = intervals; \\n    {\\n        const int n = v.size();\\n        //now sort the vector such that v[i][0]\\'s will be in decreasing order and\\n        //                              v[i][1]\\'s will be in increasing order\\n        sort(v.begin(), v.end(), [&] (const vector<int> &a, const vector<int> &b)\\n        {\\n            if(a[0] != b[0])\\n                return a[0] < b[0];\\n            else\\n                return a[1] > b[1];\\n        });\\n        \\n        vector<vector<int>> ans;\\n        \\n        int start = v[0][0];\\n        int end = v[0][1];\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(v[i][0] > end)\\n            {\\n                ans.push_back({start, end});\\n                start = v[i][0];\\n                end = v[i][1];\\n            }\\n            else if(v[i][1] > end)\\n            {\\n                end = v[i][1];\\n            }\\n        }\\n        ans.push_back({start, end});\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& v) // v = intervals; \\n    {\\n        const int n = v.size();\\n        //now sort the vector such that v[i][0]\\'s will be in decreasing order and\\n        //                              v[i][1]\\'s will be in increasing order\\n        sort(v.begin(), v.end(), [&] (const vector<int> &a, const vector<int> &b)\\n        {\\n            if(a[0] != b[0])\\n                return a[0] < b[0];\\n            else\\n                return a[1] > b[1];\\n        });\\n        \\n        vector<vector<int>> ans;\\n        \\n        int start = v[0][0];\\n        int end = v[0][1];\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(v[i][0] > end)\\n            {\\n                ans.push_back({start, end});\\n                start = v[i][0];\\n                end = v[i][1];\\n            }\\n            else if(v[i][1] > end)\\n            {\\n                end = v[i][1];\\n            }\\n        }\\n        ans.push_back({start, end});\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1089761,
                "title": "python-easy-solutions-with-explanation",
                "content": "\\n      #So here we have taken 0 and 1. Where 0 means the starting index and 1 means the ending index.\\n\\n         intervals.sort(key = lambda x:x[0])\\n         i = 1\\n        while i < len(intervals):\\n            if intervals[i][0]<= intervals[i-1][1]:\\n            \\n        #This is to see which is min between 1, 2 . Checking the starting index of both arrays\\n                intervals[i-1][0] = min(intervals[i-1][0], intervals[i][0])\\n            \\n            \\n         #Similarly finding the max value for ending pos\\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n                \\n                intervals.pop(i) #deleteing the i the part after merging \\n            \\n            \\n            else:\\n                i+=1\\n                continue\\n                \\n                \\n        return intervals\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n#If you find it helpful please upvote \\n#for any questions comment down I will reply asap",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n      #So here we have taken 0 and 1. Where 0 means the starting index and 1 means the ending index.\\n\\n         intervals.sort(key = lambda x:x[0])\\n         i = 1\\n        while i < len(intervals):\\n            if intervals[i][0]<= intervals[i-1][1]:\\n            \\n        #This is to see which is min between 1, 2 . Checking the starting index of both arrays\\n                intervals[i-1][0] = min(intervals[i-1][0], intervals[i][0])\\n            \\n            \\n         #Similarly finding the max value for ending pos\\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n                \\n                intervals.pop(i) #deleteing the i the part after merging \\n            \\n            \\n            else:\\n                i+=1\\n                continue\\n                \\n                \\n        return intervals\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n#If you find it helpful please upvote \\n#for any questions comment down I will reply asap",
                "codeTag": "Unknown"
            },
            {
                "id": 1083890,
                "title": "7-lines-c-simplest-solution-with-complete-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        \\n        // sorting intervals by their starting time\\n        sort(intervals.begin(), intervals.end());\\n        \\n        // keeping track of starting and ending of current interval \\n        int startingInterval = intervals[0][0], endingInterval = intervals[0][1];\\n        \\n        // starting from index 1 because we will start comparing current interval from the\\n        // last interval we have processed so far\\n        \\n        for(int i = 1; i < intervals.size(); ++i) {\\n            \\n            // if starting of current interval is less then or equal to ending of last \\n            // processed interval\\n            // then will update endingInterval so that it could be considered as merged\\n            if(intervals[i][0] <= endingInterval)\\n                endingInterval = max(endingInterval, intervals[i][1]);\\n            \\n            // inserting interval as till now we have minimum starting interval and maximum ending\\n            // interval which is merged so far, and updating our startingInterval and endingInterval\\n            // with the bounds of current interval\\n            else {\\n                ans.push_back({startingInterval , endingInterval});\\n                startingInterval = intervals[i][0];\\n                endingInterval  = intervals[i][1];\\n            }\\n        }\\n        \\n        // adding last pair which is left because loop will terminate at intervals size\\n        ans.push_back({startingInterval, endingInterval});\\n        return ans;\\n    }\\n};\\n```\\nKindly upvote if you understood the solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        \\n        // sorting intervals by their starting time\\n        sort(intervals.begin(), intervals.end());\\n        \\n        // keeping track of starting and ending of current interval \\n        int startingInterval = intervals[0][0], endingInterval = intervals[0][1];\\n        \\n        // starting from index 1 because we will start comparing current interval from the\\n        // last interval we have processed so far\\n        \\n        for(int i = 1; i < intervals.size(); ++i) {\\n            \\n            // if starting of current interval is less then or equal to ending of last \\n            // processed interval\\n            // then will update endingInterval so that it could be considered as merged\\n            if(intervals[i][0] <= endingInterval)\\n                endingInterval = max(endingInterval, intervals[i][1]);\\n            \\n            // inserting interval as till now we have minimum starting interval and maximum ending\\n            // interval which is merged so far, and updating our startingInterval and endingInterval\\n            // with the bounds of current interval\\n            else {\\n                ans.push_back({startingInterval , endingInterval});\\n                startingInterval = intervals[i][0];\\n                endingInterval  = intervals[i][1];\\n            }\\n        }\\n        \\n        // adding last pair which is left because loop will terminate at intervals size\\n        ans.push_back({startingInterval, endingInterval});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940596,
                "title": "c-5-lines-o-1-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& a) {\\n        sort(a.begin(), a.end());\\n        int i = 0, n = a.size();\\n        for (int j = 1; j < n; j++) \\n            if (a[j][0] > a[i][1]) a[++i] = a[j];\\n            else a[i][1] = max(a[i][1], a[j][1]);\\n        while (--n > i) a.pop_back(); \\n        return a;\\n    }\\n};\\n```\\nO(N) modified space :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& a) {\\n        sort(a.begin(), a.end());\\n        int i = 0, n = a.size();\\n        for (int j = 1; j < n; j++) \\n            if (a[j][0] > a[i][1]) a[++i] = a[j];\\n            else a[i][1] = max(a[i][1], a[j][1]);\\n        while (--n > i) a.pop_back(); \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940325,
                "title": "c-python-linear-scan",
                "content": "Approach 1: C++\\n```\\nclass Solution { // Linear scan\\npublic: // Time/Space: O(NlogN); O(N)\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        //sort(intervals.begin(), intervals.end(), [](auto& a, auto& b){return a[0] < b[0];});\\n\\t\\tsort(intervals.begin(), intervals.end()); // same as above above line\\n        vector<vector<int>> ans;\\n        for(auto& e: intervals){\\n            if(ans.empty() || e[0] > ans.back()[1]) ans.push_back(e);\\n            else ans.back()[1] = max(ans.back()[1], e[1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nApproach 2: Python\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:        \\n        ans = []        \\n        for i in sorted(intervals):\\n            if not ans or ans[-1][1]< i[0]:  ans.append(i)\\n            else:  ans[-1][1] = max(ans[-1][1], i[1])\\n        return ans             \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution { // Linear scan\\npublic: // Time/Space: O(NlogN); O(N)\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        //sort(intervals.begin(), intervals.end(), [](auto& a, auto& b){return a[0] < b[0];});\\n\\t\\tsort(intervals.begin(), intervals.end()); // same as above above line\\n        vector<vector<int>> ans;\\n        for(auto& e: intervals){\\n            if(ans.empty() || e[0] > ans.back()[1]) ans.push_back(e);\\n            else ans.back()[1] = max(ans.back()[1], e[1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:        \\n        ans = []        \\n        for i in sorted(intervals):\\n            if not ans or ans[-1][1]< i[0]:  ans.append(i)\\n            else:  ans[-1][1] = max(ans[-1][1], i[1])\\n        return ans             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 21467,
                "title": "my-c-o-nlogn-solution-580ms",
                "content": "Just copy the input to res and do sorting (in ascending order of start). Then try to merge the sorted interval: cur is the last processed interval and i is the current to-be-processed interval. if cur is ahead of i and no overlapping, just copy i to cur+1, and update cur to cur+1, otherwise, merge interval cur and i and move to i+1. At last, we need to resize res to remove the redundent intervals.  \\n\\n    class Solution {\\n    public:\\n        vector<Interval> merge(vector<Interval>& intervals) {\\n            int len = intervals.size(),i,cur;\\n            vector<Interval> res(intervals);\\n            if(len>1)\\n            {\\n                std::sort(res.begin(), res.end(), [](Interval i, Interval j){return i.start<j.start;});\\n                for(cur=0, i=1;i<len; ++i)\\n                    if(res[cur].end<res[i].start) res[++cur] = res[i]; // no overlapping, copy to cur+1, \\n                    else res[cur].end = max(res[cur].end, res[i].end); // cur and i overlap with each other, merge\\n                res.resize(cur+1); // resize to remove redundant intervals\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<Interval> merge(vector<Interval>& intervals) {\\n            int len = intervals.size(),i,cur;\\n            vector<Interval> res(intervals);\\n            if(len>1)\\n            {\\n                std::sort(res.begin(), res.end(), [](Interval i, Interval j){return i.start<j.start;}",
                "codeTag": "Java"
            },
            {
                "id": 1036776,
                "title": "simple-sorting-python-solution-o-n-log-n-time",
                "content": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals = sorted(intervals)\\n        \\n        ans = []\\n        start = intervals[0][0]\\n        end = intervals[0][1]\\n        for i in intervals:\\n            if i[0] > end:\\n                ans.append([start, end])\\n                start, end = i[0], i[1]\\n            else:\\n                end = max(end, i[1])\\n        ans.append([start, end])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals = sorted(intervals)\\n        \\n        ans = []\\n        start = intervals[0][0]\\n        end = intervals[0][1]\\n        for i in intervals:\\n            if i[0] > end:\\n                ans.append([start, end])\\n                start, end = i[0], i[1]\\n            else:\\n                end = max(end, i[1])\\n        ans.append([start, end])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030287,
                "title": "9-line-javascript-solution",
                "content": "Sort the intervals by the start index in ascending order. We can tell if the current interval overlap with the previous one if the current start value > the previous end value. Update the previous interval accordingly. \\n\\n```\\nvar merge = function(intervals) {\\n  intervals.sort((a, b) => a[0] - b[0])\\n  const res = [intervals[0]]\\n  for (let curr of intervals) {\\n    prev = res[res.length - 1]\\n    if (prev[1] >= curr[0]) {\\n      prev[1] = Math.max(curr[1], prev[1])\\n    } else {\\n      res.push(curr)\\n    }\\n  }\\n  return res\\n};\\n```\\n*Note that modifying prev array also modifies the original res array due to JavaScript object copying properties.",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n  intervals.sort((a, b) => a[0] - b[0])\\n  const res = [intervals[0]]\\n  for (let curr of intervals) {\\n    prev = res[res.length - 1]\\n    if (prev[1] >= curr[0]) {\\n      prev[1] = Math.max(curr[1], prev[1])\\n    } else {\\n      res.push(curr)\\n    }\\n  }\\n  return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855286,
                "title": "brute-force-approach-for-simple-understanding-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        int m = intervals.size();\\n        if(m==0)\\n            return res;\\n        int n = intervals[0].size();\\n\\n        \\n        for(int i=0; i<intervals.size(); i++){\\n            int tru = 0;\\n            \\n            for(int j=i+1; j<intervals.size(); j++){\\n                \\n                int a = intervals[i][0];\\n                int b = intervals[i][1];\\n                \\n                int c = intervals[j][0];\\n                int d = intervals[j][1];\\n                \\n                if((a>=c && a<=d) || (b>=c && b<=d) || (c>=a && c<=b) || (d>=a && d<=b)){\\n                    intervals.erase(intervals.begin()+i);\\n                    intervals.erase(intervals.begin()+j-1);\\n                    intervals.push_back({min(a,c), max(b,d)});\\n                    i--;\\n                    tru = 1;\\n                    break;\\n                }                                            \\n            }\\n            if(tru==0)\\n                res.push_back({intervals[i][0], intervals[i][1]});\\n        }\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        int m = intervals.size();\\n        if(m==0)\\n            return res;\\n        int n = intervals[0].size();\\n\\n        \\n        for(int i=0; i<intervals.size(); i++){\\n            int tru = 0;\\n            \\n            for(int j=i+1; j<intervals.size(); j++){\\n                \\n                int a = intervals[i][0];\\n                int b = intervals[i][1];\\n                \\n                int c = intervals[j][0];\\n                int d = intervals[j][1];\\n                \\n                if((a>=c && a<=d) || (b>=c && b<=d) || (c>=a && c<=b) || (d>=a && d<=b)){\\n                    intervals.erase(intervals.begin()+i);\\n                    intervals.erase(intervals.begin()+j-1);\\n                    intervals.push_back({min(a,c), max(b,d)});\\n                    i--;\\n                    tru = 1;\\n                    break;\\n                }                                            \\n            }\\n            if(tru==0)\\n                res.push_back({intervals[i][0], intervals[i][1]});\\n        }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717511,
                "title": "cpp-c-solution-log-n-linear",
                "content": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {  \\n        ios_base::sync_with_stdio(false); \\n        cin.tie(NULL); \\n      //  cout.tie(NULL);\\n        vector<vector<int>>ans;  \\n        if(intervals.size()==0)\\n            return ans;\\n        sort(intervals.begin(),intervals.end()); \\n        int f=intervals[0][0]; \\n        int e=intervals[0][1]; \\n        for(int i=0;i<intervals.size();i++)\\n        {\\n            int f2=intervals[i][0]; \\n            int e2=intervals[i][1]; \\n            if(max(f,f2)<=min(e,e2))//overlapping happens here\\n            {\\n                f=min(f,f2); \\n                e=max(e,e2);\\n            } \\n            else\\n            {\\n                ans.push_back({f,e}); \\n                f=f2; \\n                e=e2;\\n            }\\n\\n        } \\n        ans.push_back({f,e});\\n        return ans;\\n    }\\n\\t``` \\n\\tPlease upvote if you like my solution.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {  \\n        ios_base::sync_with_stdio(false); \\n        cin.tie(NULL); \\n      //  cout.tie(NULL);\\n        vector<vector<int>>ans;  \\n        if(intervals.size()==0)\\n            return ans;\\n        sort(intervals.begin(),intervals.end()); \\n        int f=intervals[0][0]; \\n        int e=intervals[0][1]; \\n        for(int i=0;i<intervals.size();i++)\\n        {\\n            int f2=intervals[i][0]; \\n            int e2=intervals[i][1]; \\n            if(max(f,f2)<=min(e,e2))//overlapping happens here\\n            {\\n                f=min(f,f2); \\n                e=max(e,e2);\\n            } \\n            else\\n            {\\n                ans.push_back({f,e}); \\n                f=f2; \\n                e=e2;\\n            }\\n\\n        } \\n        ans.push_back({f,e});\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 281356,
                "title": "c-sort-then-merge",
                "content": "```\\npublic class Solution {\\n    public int[][] Merge(int[][] intervals) {\\n        var n = intervals.Length;\\n\\n        if (n <= 1) {\\n            return intervals;\\n        }\\n\\n        /* NOTE:\\n            better, because it does not modify the input (try best to immutability)\\n            but Time Limit Exceeded :(\\n        */ \\n        // var sortedIntervals = intervals.OrderBy(interval => interval[0]);\\n        Array.Sort(intervals, (a, b) => a[0] - b[0]);\\n\\n        var result = new List<int[]>();\\n        result.Add(intervals.ElementAt(0));\\n        for (int i = 1; i < n; i++) {\\n            var cur = intervals.ElementAt(i);\\n            var lastFromResult = result.Last();\\n\\n            if (lastFromResult[1] >= cur[0]) {\\n                lastFromResult[1] = Math.Max(lastFromResult[1], cur[1]);\\n            } else {\\n                result.Add(cur);\\n            }\\n        }\\n\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] Merge(int[][] intervals) {\\n        var n = intervals.Length;\\n\\n        if (n <= 1) {\\n            return intervals;\\n        }\\n\\n        /* NOTE:\\n            better, because it does not modify the input (try best to immutability)\\n            but Time Limit Exceeded :(\\n        */ \\n        // var sortedIntervals = intervals.OrderBy(interval => interval[0]);\\n        Array.Sort(intervals, (a, b) => a[0] - b[0]);\\n\\n        var result = new List<int[]>();\\n        result.Add(intervals.ElementAt(0));\\n        for (int i = 1; i < n; i++) {\\n            var cur = intervals.ElementAt(i);\\n            var lastFromResult = result.Last();\\n\\n            if (lastFromResult[1] >= cur[0]) {\\n                lastFromResult[1] = Math.Max(lastFromResult[1], cur[1]);\\n            } else {\\n                result.Add(cur);\\n            }\\n        }\\n\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21510,
                "title": "c-vanilla",
                "content": "Sort `intervals` according to `start`, scan from left to right and merge overlapping ones.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](Interval& l, Interval& r) {return l.start < r.start;});\\n        vector<Interval> ans;\\n        for (Interval& interval : intervals) {\\n            if (!ans.empty() && ans.back().end >= interval.start) {\\n                ans.back().end = max(ans.back().end, interval.end);\\n            } else {\\n                ans.push_back(interval);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](Interval& l, Interval& r) {return l.start < r.start;});\\n        vector<Interval> ans;\\n        for (Interval& interval : intervals) {\\n            if (!ans.empty() && ans.back().end >= interval.start) {\\n                ans.back().end = max(ans.back().end, interval.end);\\n            } else {\\n                ans.push_back(interval);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008939,
                "title": "super-easily-understandable-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n    Arrays.sort(intervals,(a,b) -> Integer.compare(a[0],b[0]));\\n        List<int[]> res=new ArrayList<>();\\n        int low=intervals[0][0];\\n        int high=intervals[0][1];\\n\\n        for(int i=1;i<intervals.length;i++)\\n        {\\n           if(intervals[i][0]<=high){\\n               if(high<intervals[i][1])\\n               high=intervals[i][1];\\n           }\\n           else{\\n               res.add(new int[]{low,high});\\n               low=intervals[i][0];\\n               high=intervals[i][1];\\n           }\\n        }\\n        res.add(new int[]{low,high});  \\n       return res.toArray(new int[0][]);     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n    Arrays.sort(intervals,(a,b) -> Integer.compare(a[0],b[0]));\\n        List<int[]> res=new ArrayList<>();\\n        int low=intervals[0][0];\\n        int high=intervals[0][1];\\n\\n        for(int i=1;i<intervals.length;i++)\\n        {\\n           if(intervals[i][0]<=high){\\n               if(high<intervals[i][1])\\n               high=intervals[i][1];\\n           }\\n           else{\\n               res.add(new int[]{low,high});\\n               low=intervals[i][0];\\n               high=intervals[i][1];\\n           }\\n        }\\n        res.add(new int[]{low,high});  \\n       return res.toArray(new int[0][]);     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693730,
                "title": "java-easy-approach-with-comments-merge-intervals",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)-> Integer.compare(a[0],b[0]));\\n        Stack<int[]> stack = new Stack();\\n        stack.add(intervals[0]);    //pushing 1st interval\\n        \\n        //2nd interval se compare krenge\\n        for(int i=1;i<intervals.length;i++){\\n            \\n            int startpoint2 = intervals[i][0];  //2nd interval ka start point isliye 2\\n            int endpoint2 = intervals[i][1];\\n            \\n            //first interval stack mai h toh usse pop kro\\n            int poparray[] = stack.pop();\\n            \\n            int startpoint1 = poparray[0];\\n            int endpoint1 = poparray[1];\\n            \\n            //1 3\\n            //2 6  inko comapre\\n            int endmax = Math.max(endpoint2,endpoint1);\\n                \\n            if(endpoint1 >= startpoint2){\\n                int [] merge = new int[]{startpoint1,endmax};\\n                stack.add(merge);      //merge karne ke baad stack mai dal do \\n            }else{\\n                stack.add(poparray);\\n                 stack. add(intervals[i]);\\n            }        \\n        }\\n        int [][] output = new int [stack.size()][2];\\n        for(int i=output.length-1;i>=0;i--){\\n            int []poparray = stack.pop();\\n            output[i][0] = poparray[0];\\n            output[i][1] = poparray[1];\\n        }\\n        return output;\\n    }                           \\n}\\n```\\n![image](https://assets.leetcode.com/users/images/848bc7b1-68bc-433d-b411-03b6fca15cd8_1665573877.8034868.png)\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)-> Integer.compare(a[0],b[0]));\\n        Stack<int[]> stack = new Stack();\\n        stack.add(intervals[0]);    //pushing 1st interval\\n        \\n        //2nd interval se compare krenge\\n        for(int i=1;i<intervals.length;i++){\\n            \\n            int startpoint2 = intervals[i][0];  //2nd interval ka start point isliye 2\\n            int endpoint2 = intervals[i][1];\\n            \\n            //first interval stack mai h toh usse pop kro\\n            int poparray[] = stack.pop();\\n            \\n            int startpoint1 = poparray[0];\\n            int endpoint1 = poparray[1];\\n            \\n            //1 3\\n            //2 6  inko comapre\\n            int endmax = Math.max(endpoint2,endpoint1);\\n                \\n            if(endpoint1 >= startpoint2){\\n                int [] merge = new int[]{startpoint1,endmax};\\n                stack.add(merge);      //merge karne ke baad stack mai dal do \\n            }else{\\n                stack.add(poparray);\\n                 stack. add(intervals[i]);\\n            }        \\n        }\\n        int [][] output = new int [stack.size()][2];\\n        for(int i=output.length-1;i>=0;i--){\\n            int []poparray = stack.pop();\\n            output[i][0] = poparray[0];\\n            output[i][1] = poparray[1];\\n        }\\n        return output;\\n    }                           \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914800,
                "title": "python-simple-explanation-8-line",
                "content": "Create a temporary list and add elements when there is no overlap. If there is then perfrom merge.\\n\\n    def merge(self, l: List[List[int]]) -> List[List[int]]:\\n        k = []\\n        l.sort()\\n        for i in l:\\n            if not k or k[-1][1] < i[0]:\\n                k.append(i)\\n            else:\\n                k[-1][1] = max(k[-1][1],i[1])\\n        return k\\n\\t\\t\\n\\t\\t\\nRuntime: 163 ms\\nMemory Usage: 18.1 MB\\n\\n**Upvote if you found it useful**",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "Create a temporary list and add elements when there is no overlap. If there is then perfrom merge.\\n\\n    def merge(self, l: List[List[int]]) -> List[List[int]]:\\n        k = []\\n        l.sort()\\n        for i in l:\\n            if not k or k[-1][1] < i[0]:\\n                k.append(i)\\n            else:\\n                k[-1][1] = max(k[-1][1],i[1])\\n        return k\\n\\t\\t\\n\\t\\t\\nRuntime: 163 ms\\nMemory Usage: 18.1 MB\\n\\n**Upvote if you found it useful**",
                "codeTag": "Python3"
            },
            {
                "id": 1444462,
                "title": "followup-bst-implementation-c",
                "content": "# **Facebook Followup - Stream of Intervals**\\n**General Question**: What if the data comes as a stream in real time - No meaningful sorting can be done.\\n\\nImplementation based on Interval based BSTs so that we can `query` multiple times. We also create an `insert` method that we will need for the interval tree.\\n\\n### Implementation Details & Code \\n \\n- `IntervalTree` is the new class that we need to define, and we will use it to define `start`, `end` and `mid` points for each node.\\n- `insertInterval` method - if the interval to be added touches or crosses the `middle` of the current node, we merge them directly, else we insert the new interval in the `left` or `right` subtree.\\n```\\nvoid insertInterval(IntervalTree *node, Interval *currentInterval) {\\n    if (currentInterval->end < node->middle) { // Check if the entire interval is included before middle.\\n        if (node->left) {\\n            insertInterval(node->left, currentInterval);\\n        } else {\\n            IntervalTree *newNode = new IntervalTree(currentInterval->start, currentInterval->end);\\n            node->left = newNode;\\n        }\\n    }\\n    else if (currentInterval->start > node->middle) { // Check if the entire interval is included after middle.\\n        if (node->right) {\\n            insertInterval(node->right, currentInterval);\\n        } else {\\n            IntervalTree *newNode = new IntervalTree(currentInterval->start, currentInterval->end);\\n            node->right = newNode;\\n        }\\n    }\\n    else { // Merge directly if the new interval does not fit before OR after the middle point.\\n        node->start = min(node->start, currentInterval->start);\\n        node->end = max(node->end, currentInterval->end);\\n    }\\n}\\n```\\n- `queryInterval` method - retrieve merged intervals of the `left` subtree, `leftIntervals` and those of the `right` subtree `rightIntervals`. \\n```\\nvoid queryInterval(vector<Interval *> &retV, IntervalTree *node) { \\n    // retV is the collection vector.\\n    vector<Interval *> leftIntervals;\\n    vector<Interval *> rightIntervals;\\n    \\n    // Check if we can merge the current node with intervals from the left subtree.\\n    bool mergeLeft = false; \\n    \\n    if (node->left) {\\n        queryInterval(leftIntervals, node->left); // Merge all the intervals in left subtree.\\n        mergeLeftInterval(leftIntervals, node, retV, mergeLeft); // Find the merge point with the leftIntervals.\\n    }\\n    \\n    if (!mergeLeft) { // If we didn\\'t merge left, create a new interval.\\n        Interval *newInterval = new Interval(node->start, node->end);\\n        retV.push_back(newInterval);\\n    }\\n    \\n    if (node->right) {\\n        queryInterval(rightIntervals, node->right); //Merge all the intervals in the right subtree.\\n        mergeRightInterval(rightIntervals, node, retV); // Find the merge point with the rightIntervals.\\n    }\\n}\\n```\\n- the two merge methods `mergeLeftInterval` and `mergeRightInterval` are implemented similarly\\n\\t- if we find an interval that overlaps with the current `node`, we know that everything after will overlap\\n\\t- the first intervals that overlap will be all merged and the rest inserted at the end\\n```\\nvoid mergeLeftInterval(vector<Interval *> &leftIntervals, IntervalTree *node, \\n                       vector<Interval *> &retV, bool &merged) {\\n    for (int i = 0; i < leftIntervals.size(); i++) { \\n\\t\\t// If any of the left intervals intersects with the current interval, we merge it and break.\\n        if (leftIntervals[i]->end >= node->start) { \\n            Interval *newInterval = new Interval(min(leftIntervals[i]->start, node->start), node->end); \\n            retV.push_back(newInterval);\\n            merged = true;\\n            break;\\n        } else {\\n\\t\\t\\t// Else we push the interval directly.\\n            retV.push_back(leftIntervals[i]);\\n        }\\n    }\\n}\\n```\\n```\\nvoid mergeRightInterval(vector<Interval *> &rightIntervals, IntervalTree *node,\\n                        vector<Interval *> &retV) {\\n    for (int i = 0; i < rightIntervals.size(); i++) {\\n        if (rightIntervals[i]->start <= node->end) {\\n\\t\\t\\t// We extend the right end of the last appended interval whenever an intersection takes place.\\n            retV[retV.size() - 1]->end = max(rightIntervals[i]->end, node->end); \\n        } else {\\n\\t\\t\\t// Else we push the interval directly.\\n            retV.push_back(rightIntervals[i]); \\n        }\\n    }\\n}\\n```\\n\\nInspiration comes from this post: https://leetcode.com/problems/merge-intervals/discuss/21452/Share-my-interval-tree-solution-no-sorting\\n\\nAnd the explanation in [yongzx](https://leetcode.com/yongzx/) \\'s comment at the bottom of the solution tab. \\n\\nI am thankful to both of them for posting about this problem / followup! \\n\\n",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nvoid insertInterval(IntervalTree *node, Interval *currentInterval) {\\n    if (currentInterval->end < node->middle) { // Check if the entire interval is included before middle.\\n        if (node->left) {\\n            insertInterval(node->left, currentInterval);\\n        } else {\\n            IntervalTree *newNode = new IntervalTree(currentInterval->start, currentInterval->end);\\n            node->left = newNode;\\n        }\\n    }\\n    else if (currentInterval->start > node->middle) { // Check if the entire interval is included after middle.\\n        if (node->right) {\\n            insertInterval(node->right, currentInterval);\\n        } else {\\n            IntervalTree *newNode = new IntervalTree(currentInterval->start, currentInterval->end);\\n            node->right = newNode;\\n        }\\n    }\\n    else { // Merge directly if the new interval does not fit before OR after the middle point.\\n        node->start = min(node->start, currentInterval->start);\\n        node->end = max(node->end, currentInterval->end);\\n    }\\n}\\n```\n```\\nvoid queryInterval(vector<Interval *> &retV, IntervalTree *node) { \\n    // retV is the collection vector.\\n    vector<Interval *> leftIntervals;\\n    vector<Interval *> rightIntervals;\\n    \\n    // Check if we can merge the current node with intervals from the left subtree.\\n    bool mergeLeft = false; \\n    \\n    if (node->left) {\\n        queryInterval(leftIntervals, node->left); // Merge all the intervals in left subtree.\\n        mergeLeftInterval(leftIntervals, node, retV, mergeLeft); // Find the merge point with the leftIntervals.\\n    }\\n    \\n    if (!mergeLeft) { // If we didn\\'t merge left, create a new interval.\\n        Interval *newInterval = new Interval(node->start, node->end);\\n        retV.push_back(newInterval);\\n    }\\n    \\n    if (node->right) {\\n        queryInterval(rightIntervals, node->right); //Merge all the intervals in the right subtree.\\n        mergeRightInterval(rightIntervals, node, retV); // Find the merge point with the rightIntervals.\\n    }\\n}\\n```\n```\\nvoid mergeLeftInterval(vector<Interval *> &leftIntervals, IntervalTree *node, \\n                       vector<Interval *> &retV, bool &merged) {\\n    for (int i = 0; i < leftIntervals.size(); i++) { \\n\\t\\t// If any of the left intervals intersects with the current interval, we merge it and break.\\n        if (leftIntervals[i]->end >= node->start) { \\n            Interval *newInterval = new Interval(min(leftIntervals[i]->start, node->start), node->end); \\n            retV.push_back(newInterval);\\n            merged = true;\\n            break;\\n        } else {\\n\\t\\t\\t// Else we push the interval directly.\\n            retV.push_back(leftIntervals[i]);\\n        }\\n    }\\n}\\n```\n```\\nvoid mergeRightInterval(vector<Interval *> &rightIntervals, IntervalTree *node,\\n                        vector<Interval *> &retV) {\\n    for (int i = 0; i < rightIntervals.size(); i++) {\\n        if (rightIntervals[i]->start <= node->end) {\\n\\t\\t\\t// We extend the right end of the last appended interval whenever an intersection takes place.\\n            retV[retV.size() - 1]->end = max(rightIntervals[i]->end, node->end); \\n        } else {\\n\\t\\t\\t// Else we push the interval directly.\\n            retV.push_back(rightIntervals[i]); \\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1398334,
                "title": "c-simple-with-explanation-pattern-for-interval-problems",
                "content": "There are some interval based problems which are not really associated with any other data structure or algorithm but are all solved using a similar technique: Sort the intervals + One pass to update/calculate greedily.\\n\\n**1. Merge Intervals**\\n\\nWe want to merge any overlapping intervals. Let us start with the interval with the least left end. Then, we don\\'t want to miss any intervals that start immediately before it ends. If we sort the intervals by starting index, we will not miss any intervals while iterating over the sorted intervals. \\n\\nHow to merge greedily? First set **start** and **end** to the limits of the first interval in the sorted list. Then, if for an element i, starting[i] <= end, we know it overlaps because sorting by the first interval means start < starting[i] (so it means start < starting[i] <= end). Now, since we know the interval overlaps, we have to update the present interval. The start value doesn\\'t have to be updated since it is already the leftmost index possible in all the overlapping arrays. However the end index should be the rightmost index possible in all overlapping arrays, so end should be updated with the maximum of itself and ending[i].\\n\\nIf while iterating, starting[i] > end, we can add the range covered by {start,end} to the merged array, and restart merging like at i = 0 by setting start = starting[i] and end = ending[i].\\n\\nOnce we have completed traversal, the final merged element needs to be added (since we add an element only after the next interval does not overlap, but for the last element we cannot do this check). This completes merge intervals.\\n\\n```\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[0] < b[0];});\\n        \\n        vector<vector<int>> merged;\\n        \\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] <= end)\\n            {\\n                end = max(end, intervals[i][1]);\\n            }\\n            else\\n            {\\n                merged.push_back({start,end});\\n                \\n                start = intervals[i][0];\\n                end = intervals[i][1];\\n            }\\n        }\\n        \\n        merged.push_back({start,end});\\n        \\n        return merged;\\n    }\\n```\\n\\n**2. Non-overlapping Intervals**\\n\\nThe problem asks to find \"*the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping*\". First is the sorting step. Suppose we sort like with merged intervals based on first index. Then, when we find overlapping intervals, which one should we delete? If we choose the interval which ends earlier we will have more space to accommodate more intervals. Hence we maintain only the earliest ending interval out of all overlapping intervals. \\n\\n```\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[0] < b[0];});\\n        \\n        int end = intervals[0][1];\\n        \\n        int remove = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] < end)\\n            {\\n                remove++;\\n                \\n                if(intervals[i][1] < end)\\n                {\\n                    end = intervals[i][1];\\n                }\\n            }\\n            else\\n            {\\n                end = intervals[i][1];   \\n            }\\n        }\\n        \\n        return remove;\\n    }\\n```\\n\\nIf we sort by the second index, then the intervals are already arranged in least ending first order, so we can process the intervals more simply, on finding an overlap we can just remove the present interval (guaranteed to have a later ending than the one being compared to). \\n\\nHence another solution is to sort by the second index and then pick the first interval, remove all intervals in front of it overlapping with it, then update to the next interval and do the same, similar to how the intervals were processed for merging but with the second index.\\n\\n```\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[1] < b[1];});\\n        \\n        int end = intervals[0][1];\\n        \\n        int remove = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] < end)\\n            {\\n                remove++;\\n            }\\n            else\\n            {\\n                end = intervals[i][1];\\n            }\\n        }\\n        \\n        return remove;\\n    }\\n```\\n\\nOther problems based on interval pattern (sort + greedy processing)\\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/ (already discussed)\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/ (similar to non overlapping intervals)\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/\\nhttps://leetcode.com/problems/insert-interval/ (only greedy processing, good to familiarize with interval processing)",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[0] < b[0];});\\n        \\n        vector<vector<int>> merged;\\n        \\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] <= end)\\n            {\\n                end = max(end, intervals[i][1]);\\n            }\\n            else\\n            {\\n                merged.push_back({start,end});\\n                \\n                start = intervals[i][0];\\n                end = intervals[i][1];\\n            }\\n        }\\n        \\n        merged.push_back({start,end});\\n        \\n        return merged;\\n    }\\n```\n```\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[0] < b[0];});\\n        \\n        int end = intervals[0][1];\\n        \\n        int remove = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] < end)\\n            {\\n                remove++;\\n                \\n                if(intervals[i][1] < end)\\n                {\\n                    end = intervals[i][1];\\n                }\\n            }\\n            else\\n            {\\n                end = intervals[i][1];   \\n            }\\n        }\\n        \\n        return remove;\\n    }\\n```\n```\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[1] < b[1];});\\n        \\n        int end = intervals[0][1];\\n        \\n        int remove = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] < end)\\n            {\\n                remove++;\\n            }\\n            else\\n            {\\n                end = intervals[i][1];\\n            }\\n        }\\n        \\n        return remove;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21498,
                "title": "clean-java-sort-solution-using-comparator",
                "content": "    public List<Interval> merge(List<Interval> intervals) {\\n\\t\\tif (intervals.isEmpty())\\n\\t\\t\\treturn intervals;\\n\\n\\t\\tCollections.sort(intervals, new Comparator<Interval>() {\\n\\t\\t\\tpublic int compare(Interval a, Interval b) {\\n\\t\\t\\t\\t// TODO Auto-generated method stub\\n\\t\\t\\t\\treturn a.start - b.start;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tList<Interval> ans = new LinkedList<Interval>();\\n\\t\\tInterval hold = intervals.get(0);\\n\\t\\tfor (int i = 1; i < intervals.size(); i++) {\\n\\t\\t\\tInterval current = intervals.get(i);\\n\\t\\t\\tif (hold.end >= current.start) {\\n\\t\\t\\t\\thold.end = Math.max(current.end, hold.end);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans.add(hold);\\n\\t\\t\\t\\thold = current;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!ans.contains(hold))\\n\\t\\t\\tans.add(hold);\\n\\n\\t\\treturn ans;\\n\\t}",
                "solutionTags": [],
                "code": "    public List<Interval> merge(List<Interval> intervals) {\\n\\t\\tif (intervals.isEmpty())\\n\\t\\t\\treturn intervals;\\n\\n\\t\\tCollections.sort(intervals, new Comparator<Interval>() {\\n\\t\\t\\tpublic int compare(Interval a, Interval b) {\\n\\t\\t\\t\\t// TODO Auto-generated method stub\\n\\t\\t\\t\\treturn a.start - b.start;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tList<Interval> ans = new LinkedList<Interval>();\\n\\t\\tInterval hold = intervals.get(0);\\n\\t\\tfor (int i = 1; i < intervals.size(); i++) {\\n\\t\\t\\tInterval current = intervals.get(i);\\n\\t\\t\\tif (hold.end >= current.start) {\\n\\t\\t\\t\\thold.end = Math.max(current.end, hold.end);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans.add(hold);\\n\\t\\t\\t\\thold = current;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!ans.contains(hold))\\n\\t\\t\\tans.add(hold);\\n\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3713888,
                "title": "java-striver-easy-understanding",
                "content": "**Time Complexity:** O(nlogn)\\n**Space Complexity:** O(n)\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) return intervals;\\n\\n        Arrays.sort(intervals, (arr1, arr2) - > Integer.compare(arr1[0], arr2[0]));\\n\\n        List < int[] > output_arr = new ArrayList < > ();\\n        int[] current_interval = intervals[0];\\n        output_arr.add(current_interval);\\n\\n        for (int[] interval: intervals) {\\n            int current_begin = current_interval[0];\\n            int current_end = current_interval[1];\\n            int next_begin = interval[0];\\n            int next_end = interval[1];\\n\\n            if (current_end >= next_begin) {\\n                current_interval[1] = Math.max(current_end, next_end);\\n            } else {\\n                current_interval = interval;\\n                output_arr.add(current_interval);\\n            }\\n        }\\n        return output_arr.toArray(new int[output_arr.size()][]);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) return intervals;\\n\\n        Arrays.sort(intervals, (arr1, arr2) - > Integer.compare(arr1[0], arr2[0]));\\n\\n        List < int[] > output_arr = new ArrayList < > ();\\n        int[] current_interval = intervals[0];\\n        output_arr.add(current_interval);\\n\\n        for (int[] interval: intervals) {\\n            int current_begin = current_interval[0];\\n            int current_end = current_interval[1];\\n            int next_begin = interval[0];\\n            int next_end = interval[1];\\n\\n            if (current_end >= next_begin) {\\n                current_interval[1] = Math.max(current_end, next_end);\\n            } else {\\n                current_interval = interval;\\n                output_arr.add(current_interval);\\n            }\\n        }\\n        return output_arr.toArray(new int[output_arr.size()][]);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320349,
                "title": "c-fast-simple-sorting-169-ms-beats-82-2-51-1-mb-beats-83-68",
                "content": "# Approach\\nThe code is very simple at first we will sort the 2D array based on the first column. after that we will create a list of array and add the first row from the sorted 2D array. then we will just loop the 2D array and check if the list last array\\'s last element is greater than the current sorted array\\'s first element if yes then we will change the list element based on value, else we will add the element to the list.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] Merge(int[][] intervals) \\n    {\\n        List<int[]> output = new List<int[]>();\\n\\n        Array.Sort(intervals, (a,b)=>{return a[0]-b[0];});\\n\\n        output.Add(intervals[0]);\\n\\n        for(int i = 1; i < intervals.Length; i++)\\n        {\\n            if(output[output.Count - 1][1] >= intervals[i][0])\\n            {\\n                if(output[output.Count - 1][1] <= intervals[i][1]) \\n                    output[output.Count - 1][1] = intervals[i][1];\\n            }\\n            else output.Add(intervals[i]);\\n        }\\n\\n        return output.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Sort"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] Merge(int[][] intervals) \\n    {\\n        List<int[]> output = new List<int[]>();\\n\\n        Array.Sort(intervals, (a,b)=>{return a[0]-b[0];});\\n\\n        output.Add(intervals[0]);\\n\\n        for(int i = 1; i < intervals.Length; i++)\\n        {\\n            if(output[output.Count - 1][1] >= intervals[i][0])\\n            {\\n                if(output[output.Count - 1][1] <= intervals[i][1]) \\n                    output[output.Count - 1][1] = intervals[i][1];\\n            }\\n            else output.Add(intervals[i]);\\n        }\\n\\n        return output.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215453,
                "title": "simple-c-solution",
                "content": "If you find it to be helpful please like and upvote \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        ans.push_back(intervals[0]);\\n        int j=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(ans[j][1]>=intervals[i][0])\\n            {\\n                ans[j][1]=max(ans[j][1],intervals[i][1]);\\n            }\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }           \\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        ans.push_back(intervals[0]);\\n        int j=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(ans[j][1]>=intervals[i][0])\\n            {\\n                ans[j][1]=max(ans[j][1],intervals[i][1]);\\n            }\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }           \\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205936,
                "title": "c-detailed-explaination-beats-100-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Explanation:**\\n* Sort the 2D vector.\\n* Then initialize a temp variable with the 1st pair from the intervals.\\n* Now we take each pair and compare its 1st element to the 2nd element of the temp to check whether it intersects with the pair.\\n* If it\\'s <= then we take max of temp\\'s 2nd element and the pair\\'s 2nd element and update it to the 2nd element of the temp.\\n* Else we just push temp to answer vector and update temp with the current pair from the loop.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        if(intervals.size()==0) \\n            return ans;\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        vector<int> temp=intervals[0];\\n        \\n        for(auto it: intervals)\\n        {\\n            if(it[0]<=temp[1])\\n            {\\n                temp[1]=max(it[1],temp[1]);\\n            }\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp=it;\\n            }\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```\\n\\nT.C -> `O(Nlog(N)) +O(N)`\\nS.C=`O(N)`\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        if(intervals.size()==0) \\n            return ans;\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        vector<int> temp=intervals[0];\\n        \\n        for(auto it: intervals)\\n        {\\n            if(it[0]<=temp[1])\\n            {\\n                temp[1]=max(it[1],temp[1]);\\n            }\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp=it;\\n            }\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871008,
                "title": "c-very-very-simple-code-easy-to-understand",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        int n=intervals.size(),start=intervals[0][0],end=intervals[0][1];\\n        for(int i=1;i<n;++i){\\n            if(intervals[i][0]<=end) end=max(end,intervals[i][1]);\\n            else res.push_back({start,end}),start=intervals[i][0],end=intervals[i][1];\\n        }\\n        res.push_back({start,end});\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        int n=intervals.size(),start=intervals[0][0],end=intervals[0][1];\\n        for(int i=1;i<n;++i){\\n            if(intervals[i][0]<=end) end=max(end,intervals[i][1]);\\n            else res.push_back({start,end}),start=intervals[i][0],end=intervals[i][1];\\n        }\\n        res.push_back({start,end});\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1644276,
                "title": "python-java-c-2-simple-solutions-o-n-r-and-o-nlogn-image-visualized-explanation",
                "content": "**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!** \\uD83D\\uDE01\\n\\n* **step 1: sort the intervals**\\n\\t* that means` intervals[i][0] >= intervals[i - 1][0]` after sorting\\n* **step 2: for each interval `[x, y]` in `intervals`:**\\n\\t* compare `[x, y]` and `ans.back() or ans[-1]`\\n\\t* There are 3 possible situations as shown in the figure below\\n\\t\\t* 1st: nothing to do\\n\\t\\t* 2nd: enlarge the `ans[-1][1] = y`\\n\\t\\t* 3rd: append `[x, y]` to `ans`\\n\\n![image](https://assets.leetcode.com/users/images/fba68a60-56fb-4158-b66a-dcb8c235242d_1640323116.0364041.jpeg)\\n\\n* **The difference between 2 solutions focus on the sort approach.**\\n\\t* **Solusion 1 O(NlogN)**\\n\\t\\t* use some standard sort approach like quick sort cost `O(NlogN)`\\n\\t* **Solution 2 O(N+R)**\\n\\t\\t* Fortunately, since `0 <= start_i <= end_i <= 10000`, we can use Hash Sort with hash bucket `R = max(start_i)` cost `O(N)` time.\\n\\t\\t\\t```\\n\\t\\t        R = max([x for [x, _] in intervals]) + 1\\n\\t\\t\\t\\tdata = [[] for x in range(R)]\\n\\t\\t\\t\\tfor [x, y] in intervals:\\n\\t\\t\\t\\t\\tdata[x].append(y)\\n\\t\\t\\t```\\n\\t\\t* Then traverse all `intervals` cost `O(N+R)` time\\n\\n\\n**C++ O(NlogN) Runtime: 12 ms, faster than 98.58%**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < intervals.size(); i ++) {\\n            int x = intervals[i][0], y = intervals[i][1];\\n            if (ans.empty() || x > ans.back()[1])\\n                ans.push_back(intervals[i]);\\n            else if (ans.back()[1] < y)\\n                ans.back()[1] = y;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Python O(NlogN) Runtime: 56 ms, faster than 98.37%**\\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        ans = []\\n        for [x, y] in sorted(intervals):\\n            if not ans or x > ans[-1][1]:\\n                ans.append([x, y])\\n            elif ans[-1][1] < y:\\n                ans[-1][1] = y\\n        return ans\\n```\\n**Python O(N+R) Runtime: 60 ms, faster than 94.11%**\\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        R = max([x for [x, _] in intervals]) + 1\\n        data = [[] for x in range(R)]\\n        for [x, y] in intervals:\\n            data[x].append(y)\\n        ans = []\\n        for x in range(R):\\n            for y in data[x]:\\n                if not ans or x > ans[-1][1]:\\n                    ans.append([x, y])\\n                elif ans[-1][1] < y:\\n                    ans[-1][1] = y\\n        return ans\\n```\\n\\n**Java O(NlogN) Runtime: 5 ms, faster than 95.64%**\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\\n        ArrayList<int[]> ans = new ArrayList<>(intervals.length);  \\n        for (int i = 0; i < intervals.length; i ++) {\\n            int x = intervals[i][0], y = intervals[i][1];\\n            if (ans.isEmpty() || x > ans.get(ans.size() - 1)[1])\\n                ans.add(intervals[i]);\\n            else if (ans.get(ans.size() - 1)[1] < y)\\n                ans.get(ans.size() - 1)[1] = y;\\n        }\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "solutionTags": [],
                "code": "```\\n\\t\\t        R = max([x for [x, _] in intervals]) + 1\\n\\t\\t\\t\\tdata = [[] for x in range(R)]\\n\\t\\t\\t\\tfor [x, y] in intervals:\\n\\t\\t\\t\\t\\tdata[x].append(y)\\n\\t\\t\\t```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < intervals.size(); i ++) {\\n            int x = intervals[i][0], y = intervals[i][1];\\n            if (ans.empty() || x > ans.back()[1])\\n                ans.push_back(intervals[i]);\\n            else if (ans.back()[1] < y)\\n                ans.back()[1] = y;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        ans = []\\n        for [x, y] in sorted(intervals):\\n            if not ans or x > ans[-1][1]:\\n                ans.append([x, y])\\n            elif ans[-1][1] < y:\\n                ans[-1][1] = y\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        R = max([x for [x, _] in intervals]) + 1\\n        data = [[] for x in range(R)]\\n        for [x, y] in intervals:\\n            data[x].append(y)\\n        ans = []\\n        for x in range(R):\\n            for y in data[x]:\\n                if not ans or x > ans[-1][1]:\\n                    ans.append([x, y])\\n                elif ans[-1][1] < y:\\n                    ans[-1][1] = y\\n        return ans\\n```\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\\n        ArrayList<int[]> ans = new ArrayList<>(intervals.length);  \\n        for (int i = 0; i < intervals.length; i ++) {\\n            int x = intervals[i][0], y = intervals[i][1];\\n            if (ans.isEmpty() || x > ans.get(ans.size() - 1)[1])\\n                ans.add(intervals[i]);\\n            else if (ans.get(ans.size() - 1)[1] < y)\\n                ans.get(ans.size() - 1)[1] = y;\\n        }\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643943,
                "title": "python3-easy-to-understand-explained",
                "content": "First of all, we have to sort the input intervals by the start value. That will let us easily merge overlapping intervals. We just iterate over sorted intervals and compare the start and the end of adjacent intervals. If the end of the previous interval is greater or equal to the start of the next one, that means we can merge them. To merge two intervals we just expand the end of the previous interval to the end of the next.\\n\\nTime: **O(NlogN)** - sorting\\nSpace: **O(N)** - sorting in Python\\n\\nRuntime: 76 ms, faster than **97.62%** of Python3 online submissions for Merge Intervals.\\nMemory Usage: 16.2 MB, less than **10.13%** of Python3 online submissions for Merge Intervals.\\n\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        sortedInt = sorted(intervals, key = lambda i: i[0])\\n        res = list()\\n\\n        for start, end in sortedInt:\\n            if res and res[-1][1] >= start:\\n                res[-1][1] = max(res[-1][1], end)\\n            else:\\n                res.append([start, end])\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        sortedInt = sorted(intervals, key = lambda i: i[0])\\n        res = list()\\n\\n        for start, end in sortedInt:\\n            if res and res[-1][1] >= start:\\n                res[-1][1] = max(res[-1][1], end)\\n            else:\\n                res.append([start, end])\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408247,
                "title": "simple-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        int n = intervals.length;\\n        if(n==0) return new int[0][0];\\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n        List<int[]> res = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            int[] temp = intervals[i];\\n            int j = i+1;\\n            while(j<n && intervals[j][0]<=temp[1]){\\n                temp[1] = Math.max(temp[1], intervals[j][1]);\\n                j+=1;\\n            }\\n            i = j - 1;\\n            res.add(temp);\\n        }\\n        int m = res.size();\\n        return res.toArray(new int[m][2]);\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        int n = intervals.length;\\n        if(n==0) return new int[0][0];\\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n        List<int[]> res = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            int[] temp = intervals[i];\\n            int j = i+1;\\n            while(j<n && intervals[j][0]<=temp[1]){\\n                temp[1] = Math.max(temp[1], intervals[j][1]);\\n                j+=1;\\n            }\\n            i = j - 1;\\n            res.add(temp);\\n        }\\n        int m = res.size();\\n        return res.toArray(new int[m][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577210,
                "title": "go",
                "content": "```\\nfunc merge(intervals [][]int) [][]int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    var res [][]int\\n    i := 0\\n    for i < len(intervals) {\\n        left, right := intervals[i][0], intervals[i][1]\\n        j := i+1\\n        for j < len(intervals) && intervals[j][0] <= right {\\n            right = max(right, intervals[j][1])\\n            j++\\n        }\\n        res = append(res, []int{left, right})\\n        i = j\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc merge(intervals [][]int) [][]int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    var res [][]int\\n    i := 0\\n    for i < len(intervals) {\\n        left, right := intervals[i][0], intervals[i][1]\\n        j := i+1\\n        for j < len(intervals) && intervals[j][0] <= right {\\n            right = max(right, intervals[j][1])\\n            j++\\n        }\\n        res = append(res, []int{left, right})\\n        i = j\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 387369,
                "title": "simple-java-o-n-log-n-solution-for-slow-learners-like-myself",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals == null || intervals.length == 0)\\n            return new int[0][0];\\n        \\n        Arrays.sort(intervals, ((x, y) -> x[0] - y[0]));\\n        List<int[]> merged = new ArrayList<>();\\n        int[] current = intervals[0];\\n        for (int i = 1; i < intervals.length; i++) {\\n            if (current[1] >= intervals[i][0])\\n                current[1] = Math.max(current[1], intervals[i][1]);\\n            else {\\n                merged.add(current);\\n                current = intervals[i];                \\n            }\\n        }\\n        merged.add(current);\\n        return merged.toArray(new int[0][0]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals == null || intervals.length == 0)\\n            return new int[0][0];\\n        \\n        Arrays.sort(intervals, ((x, y) -> x[0] - y[0]));\\n        List<int[]> merged = new ArrayList<>();\\n        int[] current = intervals[0];\\n        for (int i = 1; i < intervals.length; i++) {\\n            if (current[1] >= intervals[i][0])\\n                current[1] = Math.max(current[1], intervals[i][1]);\\n            else {\\n                merged.add(current);\\n                current = intervals[i];                \\n            }\\n        }\\n        merged.add(current);\\n        return merged.toArray(new int[0][0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153979,
                "title": "elegant-c-solutions-one-without-modifying-intervals-and-one-inplace",
                "content": "# Without modifying `intervals`\\nSince we can\\'t sort interval, we want to instead ensure our destination vector is sorted. A insertion sort is required then. Insertion should be done as follows;\\n1. Find first destination interval that _ends_ after the incoming interval _starts_. Called _it_\\n2. If no such interval is found or the incoming interval _end_ is less than found intervals _start_ then we can just insert and be done.\\n3. Otherwise there must be an overlap, but it could be more than one. Do another search, this time for the first interval whose _start_ is greater than incoming interval _end_. Called _last_\\n4. Everything from [_it_, _last_) can be merged together with incoming interval into a single interval\\n\\n```cpp\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n      std::vector<Interval> ret;\\n      \\n      for (auto& interval : intervals) {\\n        auto it = std::lower_bound(ret.begin(), ret.end(), interval.start, [](const Interval& l, int r) { return l.end < r; });\\n        \\n        if (it == ret.end() || interval.end < it->start) \\n          // No overlap, insert as is\\n          ret.insert(it, interval);\\n        else {\\n          // There is an overlap, there might be more, so find the upper bound too\\n          it->start = std::min(it->start, interval.start);\\n          auto last = std::upper_bound(it, ret.end(), interval.end, [](int l, const Interval& r) { return l < r.start; });\\n          it->end = std::max((last - 1)->end, interval.end);\\n          ret.erase(it + 1, last);\\n        }\\n      }\\n      return ret;\\n    }\\n```\\n\\n# Modifying `intervals`\\nIt would be helpful if the question specified whether or not the intervals are sorted, since the examples provided are sorted (by start). Never the less, once you get over that, and sort the list yourself, there is really only two options to consider.\\n\\n1. Two adjacent intervals don\\'t overlap\\n2. Two adjacent intervals overlap\\n\\nWell the first case is simple, there is nothing to see and we can just move alone to the next pair.\\nIn the second case, we know that _a[i].end_ is greater than or equal to _a[i + 1].start_ or there would be no overlap. Therefore the intervals can and should be merged into one. The merge is quite simple, we know that _a[i].start_ is less or equal to _a[i + 1].start_ since we sorted it that way. Hence the merged interval must start with _a[i].start_. The only other thing to consider is which interval ends last and do a simple max.\\n\\n```cpp\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n      if (1 >= intervals.size()) {\\n        return intervals;\\n      }\\n      \\n      std::sort(intervals.begin(), intervals.end(), [](const Interval& l, const Interval& r) { return l.start < r.start; });\\n      \\n      auto curr = intervals.begin();\\n      auto next = curr;\\n      while (++next != intervals.end()) {\\n        if (curr->end >= next->start) {\\n          // There is an overlap, merge the two into the current\\n          curr->end = std::max(curr->end, next->end);\\n        } else {\\n          // There is no overlap, move the next to the end of our accepted intervals\\n          // If one or more preceeding intervals are no longer required, then one will be overwritten here\\n          *(++curr) = *next;\\n        }\\n      }\\n      // Mop up the rest\\n      intervals.erase(curr + 1, intervals.end());\\n      return intervals;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n      std::vector<Interval> ret;\\n      \\n      for (auto& interval : intervals) {\\n        auto it = std::lower_bound(ret.begin(), ret.end(), interval.start, [](const Interval& l, int r) { return l.end < r; });\\n        \\n        if (it == ret.end() || interval.end < it->start) \\n          // No overlap, insert as is\\n          ret.insert(it, interval);\\n        else {\\n          // There is an overlap, there might be more, so find the upper bound too\\n          it->start = std::min(it->start, interval.start);\\n          auto last = std::upper_bound(it, ret.end(), interval.end, [](int l, const Interval& r) { return l < r.start; });\\n          it->end = std::max((last - 1)->end, interval.end);\\n          ret.erase(it + 1, last);\\n        }\\n      }\\n      return ret;\\n    }\\n```\n```cpp\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n      if (1 >= intervals.size()) {\\n        return intervals;\\n      }\\n      \\n      std::sort(intervals.begin(), intervals.end(), [](const Interval& l, const Interval& r) { return l.start < r.start; });\\n      \\n      auto curr = intervals.begin();\\n      auto next = curr;\\n      while (++next != intervals.end()) {\\n        if (curr->end >= next->start) {\\n          // There is an overlap, merge the two into the current\\n          curr->end = std::max(curr->end, next->end);\\n        } else {\\n          // There is no overlap, move the next to the end of our accepted intervals\\n          // If one or more preceeding intervals are no longer required, then one will be overwritten here\\n          *(++curr) = *next;\\n        }\\n      }\\n      // Mop up the rest\\n      intervals.erase(curr + 1, intervals.end());\\n      return intervals;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3811263,
                "title": "5-line-easy-code-simple-line-by-line-code-explanation-sorting",
                "content": "# \\u2705Intuition \\u2705\\nif the ending time of current intervals is greater than or eqaul to starting time of next interval, in this case overlapping of intervals occuring. in this case we merge these both intervals together.\\nexample:\\n[2,4] [3,6] [7,13] [10,12]\\n\\n1. in above example interval 1 and 2 will be overlap as ending time of 1st interval(which is 4) is greater than starting time of 2nd interval(which is 3). now merged interval range will be [2,6]\\nwe take max(4,6) for find ending  time of merged interval.so intetval will be [2,6]\\n\\n2. now we start comparing of new formed interval to next interval.\\n\\n3. In this time we have to compare [2,6] with [7,13] ,since 6 is less than 7 so here is no interval.\\n\\n4. Last we have [7,13] and [10,12] , since 10 is less than 13 so here will be overlapping. now we have to merge these both intervals but there is question that what will be ending time of merged interval.\\n\\nending time of merged interval will be :: max(13,12) which is 13.\\n \\nso, in this case final merged interval will be [7,13].\\n \\n\\n# Approach\\u2705\\n  Carefully read above intitution part you will find complete answer. how we have to approach this question\\u2705.\\n\\n\\n **if you find helpful, kindly upvote \\uD83D\\uDE80 ... Thanks** \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>>ans;\\n        for(int i = 0 ; i<n ;i++){\\n            if(ans.empty()){//1st time ans will be empty then simply push_back intervals in ans\\n                ans.push_back(intervals[i]);\\n            }\\n            else{\\n                vector<int>&v = ans.back();\\n                int y = v[1]; // end time of previous intervals compare y with i\\'s start time\\n                //intervals[i][0] ---> means start time || intervals[i][1] --> end time \\n             //in case of overlapping of intervals   \\n             if(intervals[i][0] <= y){//start time next interv. is <=prev. interval(overlap)\\n                //[2,4] [3,5] ---->merged interval will[2,5],end point will be max(4,5) \\n                   v[1] = max(intervals[i][1] , y);\\n                }\\n                // in case of no overlapping\\n                else{\\n                   ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Brainteaser",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>>ans;\\n        for(int i = 0 ; i<n ;i++){\\n            if(ans.empty()){//1st time ans will be empty then simply push_back intervals in ans\\n                ans.push_back(intervals[i]);\\n            }\\n            else{\\n                vector<int>&v = ans.back();\\n                int y = v[1]; // end time of previous intervals compare y with i\\'s start time\\n                //intervals[i][0] ---> means start time || intervals[i][1] --> end time \\n             //in case of overlapping of intervals   \\n             if(intervals[i][0] <= y){//start time next interv. is <=prev. interval(overlap)\\n                //[2,4] [3,5] ---->merged interval will[2,5],end point will be max(4,5) \\n                   v[1] = max(intervals[i][1] , y);\\n                }\\n                // in case of no overlapping\\n                else{\\n                   ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777963,
                "title": "c-sc-o-1-without-using-another-data-structure-i-e-in-place-solution",
                "content": "# Complexity\\n- Time complexity:O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end());\\n\\n        for(int i = 1;i < v.size();){\\n            if(v[i - 1][1] >= v[i][0]){\\n                v[i - 1][1] = max(v[i][1],v[i - 1][1]);\\n                v.erase(v.begin() + i);\\n            }\\n            else i++;\\n            // why i++ in else (dry run this TC)\\n            // [0,2],[1,4],[3,5]\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end());\\n\\n        for(int i = 1;i < v.size();){\\n            if(v[i - 1][1] >= v[i][0]){\\n                v[i - 1][1] = max(v[i][1],v[i - 1][1]);\\n                v.erase(v.begin() + i);\\n            }\\n            else i++;\\n            // why i++ in else (dry run this TC)\\n            // [0,2],[1,4],[3,5]\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452633,
                "title": "c-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size()<=1){\\n            return intervals;\\n        } \\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        output.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++) {\\n            if(output.back()[1] >= intervals[i][0]){\\n                output.back()[1] = max(output.back()[1] , intervals[i][1]);\\n            } \\n            else{\\n                output.push_back(intervals[i]); \\n            }\\n        }\\n        return output;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size()<=1){\\n            return intervals;\\n        } \\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        output.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++) {\\n            if(output.back()[1] >= intervals[i][0]){\\n                output.back()[1] = max(output.back()[1] , intervals[i][1]);\\n            } \\n            else{\\n                output.push_back(intervals[i]); \\n            }\\n        }\\n        return output;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058812,
                "title": "simple-c-sorting-merging",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all we should sort so that we can do linear search ,otherwise we have to do it in O(n^2) because if unsorted then some intervals will be left at end some will be at begining so if we sort we will have contiguous intervals and then we can merge them in linear fashion.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo just check if intervals are overlapping and if are then just merge \\nand this can be done by two operations :\\n- `min(a[1], b[1]) - max(a[0], b[0]) >= 0;` can be used to detect if some element is common between two intervals u can just take an exapmple and dry run it.\\n- `{min(a[0], b[0]), max(a[1], b[1])};` gives us the resulting merged interval.\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n bool doesIntervalsOverlap(vector<int>& a, vector<int>& b) {\\n        return min(a[1], b[1]) - max(a[0], b[0]) >= 0;\\n    }\\n\\n     vector<int> mergeIntervals(vector<int>& a, vector<int>& b) {\\n        return {min(a[0], b[0]), max(a[1], b[1])};\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& inv) {\\n        int n=inv.size();\\n        vector<vector<int>>v;\\n        int i=0;\\n        sort(inv.begin(),inv.end());\\n        while(i<n){\\n            vector<int>curr=inv[i++];\\n            vector<int>merge=curr;\\n           while(i<n and doesIntervalsOverlap(curr,inv[i])){\\n               merge=mergeIntervals(curr,inv[i]);\\n               curr=merge;\\n               i++;\\n           }\\n           v.push_back(merge);\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n bool doesIntervalsOverlap(vector<int>& a, vector<int>& b) {\\n        return min(a[1], b[1]) - max(a[0], b[0]) >= 0;\\n    }\\n\\n     vector<int> mergeIntervals(vector<int>& a, vector<int>& b) {\\n        return {min(a[0], b[0]), max(a[1], b[1])};\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& inv) {\\n        int n=inv.size();\\n        vector<vector<int>>v;\\n        int i=0;\\n        sort(inv.begin(),inv.end());\\n        while(i<n){\\n            vector<int>curr=inv[i++];\\n            vector<int>merge=curr;\\n           while(i<n and doesIntervalsOverlap(curr,inv[i])){\\n               merge=mergeIntervals(curr,inv[i]);\\n               curr=merge;\\n               i++;\\n           }\\n           v.push_back(merge);\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051071,
                "title": "c-easy-solution-with-explanation",
                "content": "\\n# Approach\\nSort the given array intervals.\\nConsider a new array answer. Insert into it the first elements of intervals. Now consider the next elements of intervals. If the smaller number of next elements of intervals is less than or equal to larger number of previous elements, update the larger number of previous elements by maximum of the larger number of both elements.\\nOtherwise, simply insert the next elements in the answer.   \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        \\n        int i=0;\\n        int j=0;\\n        sort(intervals.begin(),intervals.end());\\n        ans.push_back(intervals[0]);//insert the first element\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=ans[j][1]){\\n                //update previous element\\n                ans[j][1]=max(ans[j][1],intervals[i][1]);\\n            }\\n            else{\\n                //add new element to answer\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        \\n        int i=0;\\n        int j=0;\\n        sort(intervals.begin(),intervals.end());\\n        ans.push_back(intervals[0]);//insert the first element\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=ans[j][1]){\\n                //update previous element\\n                ans[j][1]=max(ans[j][1],intervals[i][1]);\\n            }\\n            else{\\n                //add new element to answer\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285879,
                "title": "c-easy-explanation-brute-to-optimal-interview-prep",
                "content": "# Intuition\\n- First we will check if the array of intervals given is already `sorted or not`.\\n- If not then we will `sort` it .\\n- Then we for merging we will check if the `first index of second interval is less than second index of first interval`.\\n- If the above case satisfies then we will merge them otherwise we will push that interval as it is in the result and use it for further comparison.\\n- The above logic is more explained in the approaches below.\\n# Approaches\\n## 1.Brute Force\\n- `Sorting` the intervals in ascending order.\\n- Using `2 loops` for $$iterating$$ and `linear searching of interval`.\\n- `Outer loop` is for iterating the array .\\n- `Inner Loop` is for linear search that if the any interval is overlapping with the interval of the current iteration.\\n### Code\\n```cpp\\nvector<vector<int>> merge(vector<vector<int>>& arr) {\\n    int n = arr.size(); // Get the size of the input vector\\n    sort(arr.begin(), arr.end()); // Sort the intervals based on their starting points\\n    vector<vector<int>> ans; // Initialize an empty vector to store the merged intervals\\n\\n    for (int i = 0; i < n; i++) { // Iterate through each interval\\n        int start = arr[i][0], end = arr[i][1];\\n\\n        // If the last interval in the merged intervals vector overlaps with the current interval, skip the current interval\\n        if (!ans.empty()) {\\n            if (start <= ans.back()[1]) {\\n                continue;\\n            }\\n        }\\n\\n        // Iterate through the remaining intervals and merge overlapping intervals\\n        for (int j = i + 1; j < n; j++) {\\n            if (arr[j][0] <= end) {\\n                end = max(end, arr[j][1]);\\n            }\\n        }\\n\\n        // Store the merged interval in the answer vector\\n        end = max(end, arr[i][1]);\\n        ans.push_back({start, end});\\n    }\\n\\n    return ans; // Return the merged intervals\\n}\\n```\\n### Complexity\\n- **Time Complexity** - $O(NlogN)+O(N*N). O(NlogN)$\\n- **Space Complexity** - $O(N)$\\n## 2. Optimal Approach\\n- Linearly iterate over the array if the data structure is empty insert the interval in the data structure.\\n- If the last element in the data structure overlaps with the current interval we merge the intervals by updating the last element in the data structure, and if the current interval does not overlap with the last element in the data structure simply insert it into the data structure.\\n- Since we have sorted the intervals, the intervals which will be merging are bound to be adjacent. \\n- We `kept on merging simultaneously` as we were traversing through the array and when the element was non-overlapping we simply inserted the element in our data structure.\\n### Code\\n```cpp\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    vector<vector<int>> mergedInterval; // Initialize an empty vector to store merged intervals\\n    if(intervals.size()==0)\\n      {\\n        return mergedInterval;\\n      }\\n    sort(intervals.begin(),intervals.end()); // Sort the input intervals based on the start time\\n\\n    vector<int> tempInterval = intervals[0]; // Initialize a temporary interval with the first interval in the sorted list\\n\\n    for(auto i:intervals)\\n    {\\n        if(i[0]<= tempInterval[1]) // If the current interval\\'s start time is less than or equal to the end time of the temporary interval\\n        {\\n            tempInterval[1]=max(i[1],tempInterval[1]); // Update the end time of the temporary interval with the maximum of the end times of current interval and the temporary interval\\n        }\\n        else\\n        {\\n            mergedInterval.push_back(tempInterval); // If the current interval\\'s start time is greater than the end time of the temporary interval, push the temporary interval into the merged intervals vector\\n            tempInterval = i; // Update the temporary interval with the current interval\\n        }\\n    }\\n    mergedInterval.push_back(tempInterval); // Push the last temporary interval into the merged intervals vector\\n    return mergedInterval; // Return the merged intervals vector\\n}\\n```\\n### Complexity\\n- **Time Complexity -** $O(NlogN) + O(N). O(NlogN)$\\n- **Space Complexity -** $O(N)$\\n\\n**Thank You!** for reading . Do upvote\\uD83D\\uDC4Dif you like the explanantion and if there is any scope of improvement do mention it in the comments  \\uD83D\\uDE01.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```cpp\\nvector<vector<int>> merge(vector<vector<int>>& arr) {\\n    int n = arr.size(); // Get the size of the input vector\\n    sort(arr.begin(), arr.end()); // Sort the intervals based on their starting points\\n    vector<vector<int>> ans; // Initialize an empty vector to store the merged intervals\\n\\n    for (int i = 0; i < n; i++) { // Iterate through each interval\\n        int start = arr[i][0], end = arr[i][1];\\n\\n        // If the last interval in the merged intervals vector overlaps with the current interval, skip the current interval\\n        if (!ans.empty()) {\\n            if (start <= ans.back()[1]) {\\n                continue;\\n            }\\n        }\\n\\n        // Iterate through the remaining intervals and merge overlapping intervals\\n        for (int j = i + 1; j < n; j++) {\\n            if (arr[j][0] <= end) {\\n                end = max(end, arr[j][1]);\\n            }\\n        }\\n\\n        // Store the merged interval in the answer vector\\n        end = max(end, arr[i][1]);\\n        ans.push_back({start, end});\\n    }\\n\\n    return ans; // Return the merged intervals\\n}\\n```\n```cpp\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    vector<vector<int>> mergedInterval; // Initialize an empty vector to store merged intervals\\n    if(intervals.size()==0)\\n      {\\n        return mergedInterval;\\n      }\\n    sort(intervals.begin(),intervals.end()); // Sort the input intervals based on the start time\\n\\n    vector<int> tempInterval = intervals[0]; // Initialize a temporary interval with the first interval in the sorted list\\n\\n    for(auto i:intervals)\\n    {\\n        if(i[0]<= tempInterval[1]) // If the current interval\\'s start time is less than or equal to the end time of the temporary interval\\n        {\\n            tempInterval[1]=max(i[1],tempInterval[1]); // Update the end time of the temporary interval with the maximum of the end times of current interval and the temporary interval\\n        }\\n        else\\n        {\\n            mergedInterval.push_back(tempInterval); // If the current interval\\'s start time is greater than the end time of the temporary interval, push the temporary interval into the merged intervals vector\\n            tempInterval = i; // Update the temporary interval with the current interval\\n        }\\n    }\\n    mergedInterval.push_back(tempInterval); // Push the last temporary interval into the merged intervals vector\\n    return mergedInterval; // Return the merged intervals vector\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1755996,
                "title": "merge-intervals",
                "content": "class Solution{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& a)\\n\\t{\\n         vector<vector<int>> res;\\n        \\n         if (a.size() == 0)\\n            return res;\\n        \\n        sort(a.begin(), a.end());\\n        res.push_back(a[0]);\\n        int j = 0;\\n        for (int i = 1; i < a.size(); i++)\\n        {\\n            if (res[j][1] >= a[i][0])\\n            {\\n                res[j][1] = max(res[j][1], a[i][1]);\\n            }\\n            else\\n            {\\n                res.push_back(a[i]);\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& a)\\n\\t{\\n         vector<vector<int>> res;\\n        \\n         if (a.size() == 0)\\n            return res;\\n        \\n        sort(a.begin(), a.end());\\n        res.push_back(a[0]);\\n        int j = 0;\\n        for (int i = 1; i < a.size(); i++)\\n        {\\n            if (res[j][1] >= a[i][0])\\n            {\\n                res[j][1] = max(res[j][1], a[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1660021,
                "title": "java-simple-and-clean-solution-understandable-explanation",
                "content": "1) First we sort the list based on interval[i][0];\\n2) Compare end of current to start of next -\\n\\ti) if end of current is larger than start of next then we merge the interval but not add to list to check further intervals(we track this with s,e,start and end variables)\\n\\tii) if above condition is not met then we add interval to list(start,end).\\n3. we convert list to array and return.\\n\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals,(o1,o2)->Integer.compare(o1[0], o2[0]));\\n        List<int[]> ansList = new ArrayList<int[]>();\\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        int e,s;\\n        int i =0;\\n        int[] newInterval = intervals[0];\\n        while(i<intervals.length)\\n        {\\n            s = intervals[i][0];\\n            e = intervals[i][1];\\n            if(s<=end)\\n                end = Math.max(end,e);\\n            else\\n            {\\n                ansList.add(new int[]{start,end});\\n                start = s;\\n                end =  e;  \\n            }\\n            i++;\\n        }\\n        ansList.add(new int[] {start,end});\\n        return ansList.toArray(new int[ansList.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals,(o1,o2)->Integer.compare(o1[0], o2[0]));\\n        List<int[]> ansList = new ArrayList<int[]>();\\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        int e,s;\\n        int i =0;\\n        int[] newInterval = intervals[0];\\n        while(i<intervals.length)\\n        {\\n            s = intervals[i][0];\\n            e = intervals[i][1];\\n            if(s<=end)\\n                end = Math.max(end,e);\\n            else\\n            {\\n                ansList.add(new int[]{start,end});\\n                start = s;\\n                end =  e;  \\n            }\\n            i++;\\n        }\\n        ansList.add(new int[] {start,end});\\n        return ansList.toArray(new int[ansList.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067545,
                "title": "python-beats-90",
                "content": "```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not intervals or len(intervals) == 1:\\n            return intervals\\n        \\n        intervals = sorted(intervals, key=lambda x: x[0])\\n        \\n        mergedIntervals = []\\n        \\n        for interval in intervals:\\n            if not mergedIntervals or interval[0] > mergedIntervals[-1][1]:\\n                mergedIntervals.append(interval)\\n            else:\\n                mergedIntervals[-1][1] = max(interval[1], mergedIntervals[-1][1])\\n        \\n        return mergedIntervals\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not intervals or len(intervals) == 1:\\n            return intervals\\n        \\n        intervals = sorted(intervals, key=lambda x: x[0])\\n        \\n        mergedIntervals = []\\n        \\n        for interval in intervals:\\n            if not mergedIntervals or interval[0] > mergedIntervals[-1][1]:\\n                mergedIntervals.append(interval)\\n            else:\\n                mergedIntervals[-1][1] = max(interval[1], mergedIntervals[-1][1])\\n        \\n        return mergedIntervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940485,
                "title": "simple-o-nlogn-solution-sort-and-merge",
                "content": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        result = []\\n        intervals.sort(key=lambda x: x[0])\\n        begin, end = intervals[0][0], intervals[0][1]\\n        for interval in intervals[1:]:\\n            if interval[0] <= end:\\n                end = max(end, interval[1])\\n            else:\\n                result.append([begin, end])\\n                begin, end = interval[0], interval[1]\\n        result.append([begin, end])\\n        return result\\n```\\n\\nExplanation:-\\n```\\n1. sort the input, where key is starting time/frist value\\n2. We pick the first interval from the input and iterate over remaining intervals to see which of the following intervals can we merge with the previous interval\\n3. since intervals were sorted based on first value we try to find the overlap by comparing start value of new interval with end value of previous interval\\n4. if there is no overlapping portion, we append previous interval to the output/answer and we reset what is considered to be previous interval\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        result = []\\n        intervals.sort(key=lambda x: x[0])\\n        begin, end = intervals[0][0], intervals[0][1]\\n        for interval in intervals[1:]:\\n            if interval[0] <= end:\\n                end = max(end, interval[1])\\n            else:\\n                result.append([begin, end])\\n                begin, end = interval[0], interval[1]\\n        result.append([begin, end])\\n        return result\\n```\n```\\n1. sort the input, where key is starting time/frist value\\n2. We pick the first interval from the input and iterate over remaining intervals to see which of the following intervals can we merge with the previous interval\\n3. since intervals were sorted based on first value we try to find the overlap by comparing start value of new interval with end value of previous interval\\n4. if there is no overlapping portion, we append previous interval to the output/answer and we reset what is considered to be previous interval\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874757,
                "title": "help-please-line-1052-char-9-runtime-error-reference-binding-to-null-pointer-of-type",
                "content": "\\nMy code is failing at the 168th test case and I\\'m getting this error, I\\'m not sure why this error is coming, this error is generally encountered due to out of bounds exception, but I don\\'t think there is any problem in my code? Can someone please help me identify the error and help me understand it. Thank you.\\n\\nExact Error: Line 1052: Char 9: runtime error: reference binding to null pointer of type \\'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type\\' (aka \\'const int\\') (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9\\n\\n\\n```\\n bool myComp(const vector<int>& v1, const vector<int>& v2) {\\n        if (v1[0] != v2[0]) {\\n            return v1[0] < v2[0];\\n        } else if (v1[1] != v2[1]) {\\n            return v1[1] < v2[1];\\n        }\\n        return true;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    \\n   \\n    \\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        \\n        \\n        if (intervals.empty()) {\\n            return intervals;\\n        }\\n        if (intervals.size() <= 1) {\\n            return intervals;\\n        }\\n        \\n         vector<vector<int>> out;\\n      \\n        sort(intervals.begin(), intervals.end(), myComp);\\n        \\n        \\n        \\n        out.push_back(intervals[0]);\\n        \\n        vector<int> currInterval = intervals[0];\\n        \\n        for (int i = 1; i < intervals.size(); i++) {\\n            \\n            \\n            if (intervals[i][0] <= currInterval[1]) {\\n                \\n                out[out.size()-1][1] = max(currInterval[1], intervals[i][1]);\\n                currInterval = out[out.size()-1];\\n                \\n            } else {\\n                out.push_back(intervals[i]);\\n                currInterval = intervals[i];\\n            }\\n            \\n        }\\n        return out;\\n        \\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n bool myComp(const vector<int>& v1, const vector<int>& v2) {\\n        if (v1[0] != v2[0]) {\\n            return v1[0] < v2[0];\\n        } else if (v1[1] != v2[1]) {\\n            return v1[1] < v2[1];\\n        }\\n        return true;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    \\n   \\n    \\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        \\n        \\n        if (intervals.empty()) {\\n            return intervals;\\n        }\\n        if (intervals.size() <= 1) {\\n            return intervals;\\n        }\\n        \\n         vector<vector<int>> out;\\n      \\n        sort(intervals.begin(), intervals.end(), myComp);\\n        \\n        \\n        \\n        out.push_back(intervals[0]);\\n        \\n        vector<int> currInterval = intervals[0];\\n        \\n        for (int i = 1; i < intervals.size(); i++) {\\n            \\n            \\n            if (intervals[i][0] <= currInterval[1]) {\\n                \\n                out[out.size()-1][1] = max(currInterval[1], intervals[i][1]);\\n                currInterval = out[out.size()-1];\\n                \\n            } else {\\n                out.push_back(intervals[i]);\\n                currInterval = intervals[i];\\n            }\\n            \\n        }\\n        return out;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590996,
                "title": "my-c-code",
                "content": "inplace\\n```\\nint cmpfunc(int** a, int** b)\\n{\\n    return (*a)[0] - (*b)[0];\\n}\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){\\n    int* temp=NULL;\\n    int i;\\n    int count = 0;\\n    \\n    if((intervals==NULL) || (intervalsSize==0))\\n    {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    qsort(intervals, intervalsSize,sizeof(int*),cmpfunc);\\n    \\n    temp = intervals[0];\\n    for(i=1;i<intervalsSize;i++)\\n    {\\n        if(temp[1] >= intervals[i][0])\\n        {\\n            temp[1] = (temp[1] > intervals[i][1])?temp[1]:intervals[i][1];\\n        }\\n        else\\n        {\\n            intervals[count][0] = temp[0];\\n            intervals[count][1] = temp[1];\\n            count++;\\n            temp = intervals[i];\\n        }\\n    }\\n    intervals[count][0] = temp[0];\\n    intervals[count][1] = temp[1];\\n    count++;\\n\\n    *returnSize = count;\\n    (*returnColumnSizes) = (int*)malloc(count*sizeof(int));\\n    for(i=0;i<count;i++)\\n    {\\n        (*returnColumnSizes)[i] = 2;\\n    }\\n    return intervals;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cmpfunc(int** a, int** b)\\n{\\n    return (*a)[0] - (*b)[0];\\n}\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){\\n    int* temp=NULL;\\n    int i;\\n    int count = 0;\\n    \\n    if((intervals==NULL) || (intervalsSize==0))\\n    {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    qsort(intervals, intervalsSize,sizeof(int*),cmpfunc);\\n    \\n    temp = intervals[0];\\n    for(i=1;i<intervalsSize;i++)\\n    {\\n        if(temp[1] >= intervals[i][0])\\n        {\\n            temp[1] = (temp[1] > intervals[i][1])?temp[1]:intervals[i][1];\\n        }\\n        else\\n        {\\n            intervals[count][0] = temp[0];\\n            intervals[count][1] = temp[1];\\n            count++;\\n            temp = intervals[i];\\n        }\\n    }\\n    intervals[count][0] = temp[0];\\n    intervals[count][1] = temp[1];\\n    count++;\\n\\n    *returnSize = count;\\n    (*returnColumnSizes) = (int*)malloc(count*sizeof(int));\\n    for(i=0;i<count;i++)\\n    {\\n        (*returnColumnSizes)[i] = 2;\\n    }\\n    return intervals;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 365871,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals.length <= 1)\\n            return intervals;\\n        \\n        Arrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0]));\\n        \\n        List<int[]> result = new ArrayList<>();\\n        int[] newInterval = intervals[0];\\n        result.add(newInterval);\\n        for(int[] interval : intervals){\\n            if(newInterval[1] >= interval[0])\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            else{\\n                newInterval = interval;\\n                result.add(newInterval);\\n            }\\n        }\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```\\n\\nRuntime: 38 ms, faster than 25.25% of Java online submissions for Merge Intervals.\\nMemory Usage: 37.4 MB, less than 98.55% of Java online submissions for Merge Intervals.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals.length <= 1)\\n            return intervals;\\n        \\n        Arrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0]));\\n        \\n        List<int[]> result = new ArrayList<>();\\n        int[] newInterval = intervals[0];\\n        result.add(newInterval);\\n        for(int[] interval : intervals){\\n            if(newInterval[1] >= interval[0])\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            else{\\n                newInterval = interval;\\n                result.add(newInterval);\\n            }\\n        }\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354775,
                "title": "python-short-and-easy-to-understand-solution-0-nlog-n",
                "content": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        for i in sorted(intervals, key=lambda x:x[0]):\\n            if res and i[0]<=res[-1][1]:\\n                 res[-1][1] = max(i[1], res[-1][1])\\n            else:\\n                res +=[i]\\n        return res\\n\\t\\t\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        for i in sorted(intervals, key=lambda x:x[0]):\\n            if res and i[0]<=res[-1][1]:\\n                 res[-1][1] = max(i[1], res[-1][1])\\n            else:\\n                res +=[i]\\n        return res\\n\\t\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 295485,
                "title": "two-java-solutions-with-updated-input",
                "content": "The input of this question has been changed from `List<Interval>` to `int[][] intervals`. \\nHere are two solutions based on sorting the input. \\nTheoretically, both of their runtimes are `O(nlogn)` from sorting. \\nI personally like Solution1, but somehow Solution2 runs faster. \\n\\nSolution 1: \\n```\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length <= 1) return intervals;   \\n        int len = intervals.length; \\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0])); // O(nlogn)\\n        int start = intervals[0][0]; \\n        int end = intervals[0][1]; \\n        \\n        List<int[]> result = new ArrayList<>(); \\n        \\n        for(int[] interval : intervals){\\n            if(interval[0] <= end){\\n                end = Math.max(end, interval[1]); \\n            }\\n            else{\\n                result.add(new int[]{start, end}); \\n                start = interval[0]; \\n                end = interval[1]; \\n            }\\n        }\\n        result.add(new int[]{start, end}); \\n\\t\\t\\n        return result.toArray(new int[result.size()][2]); \\n    }\\n```\\n\\nSolution2: \\n```\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length <= 1) return intervals;\\n        \\n        int len = intervals.length; \\n        int[] starts = new int[len]; \\n        int[] ends = new int[len]; \\n        \\n        for(int i = 0; i < len; i++){\\n            starts[i] = intervals[i][0]; \\n            ends[i] = intervals[i][1]; \\n        }\\n        \\n        Arrays.sort(starts); // O(nlogn)\\n        Arrays.sort(ends); \\n        \\n        int i = 0;   // i -> index for starts[]\\n        int j = 0;   // j -> index for ends[]\\n        List<int[]> result = new ArrayList<>(); \\n        \\n        while(j < len){   // j will be the index that travals faster. No need to worry about i here\\n            if(j == len - 1 || starts[j + 1] > ends[j]){   // if j reaches the end, add the last interval to result\\n                result.add(new int[]{starts[i], ends[j]}); \\n                i = j + 1; \\n            }\\n            j++; \\n        }\\n        \\n        return result.toArray(new int[result.size()][2]); \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length <= 1) return intervals;   \\n        int len = intervals.length; \\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0])); // O(nlogn)\\n        int start = intervals[0][0]; \\n        int end = intervals[0][1]; \\n        \\n        List<int[]> result = new ArrayList<>(); \\n        \\n        for(int[] interval : intervals){\\n            if(interval[0] <= end){\\n                end = Math.max(end, interval[1]); \\n            }\\n            else{\\n                result.add(new int[]{start, end}); \\n                start = interval[0]; \\n                end = interval[1]; \\n            }\\n        }\\n        result.add(new int[]{start, end}); \\n\\t\\t\\n        return result.toArray(new int[result.size()][2]); \\n    }\\n```\n```\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length <= 1) return intervals;\\n        \\n        int len = intervals.length; \\n        int[] starts = new int[len]; \\n        int[] ends = new int[len]; \\n        \\n        for(int i = 0; i < len; i++){\\n            starts[i] = intervals[i][0]; \\n            ends[i] = intervals[i][1]; \\n        }\\n        \\n        Arrays.sort(starts); // O(nlogn)\\n        Arrays.sort(ends); \\n        \\n        int i = 0;   // i -> index for starts[]\\n        int j = 0;   // j -> index for ends[]\\n        List<int[]> result = new ArrayList<>(); \\n        \\n        while(j < len){   // j will be the index that travals faster. No need to worry about i here\\n            if(j == len - 1 || starts[j + 1] > ends[j]){   // if j reaches the end, add the last interval to result\\n                result.add(new int[]{starts[i], ends[j]}); \\n                i = j + 1; \\n            }\\n            j++; \\n        }\\n        \\n        return result.toArray(new int[result.size()][2]); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21241,
                "title": "swift-o-n-log-n-solution-with-inline-comments",
                "content": "Brief Swift implementation with step by step comments.\\n```\\nclass Solution {\\n    func merge(_ intervals: [Interval]) -> [Interval] {\\n        var result: [Interval] = []\\n        // sort the intervals by start so we can test for overlaps sequentially\\n        let intervalsSorted = intervals.sorted(by: {$0.start < $1.start})\\n        \\n        // iterate the intervals\\n        for interval in intervalsSorted {\\n            // does the current interval overlap the last\\n            if !result.isEmpty && interval.start <= result.last!.end {\\n                // there is overlap, rewrite the last interval with the\\n                // higher end value, the start value must be <= current\\n                // due to the prior sort\\n                result.last!.end = max(result.last!.end, interval.end)\\n            } else {\\n                // no overlap (or no last), append current interval\\n                result.append(interval)\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func merge(_ intervals: [Interval]) -> [Interval] {\\n        var result: [Interval] = []\\n        // sort the intervals by start so we can test for overlaps sequentially\\n        let intervalsSorted = intervals.sorted(by: {$0.start < $1.start})\\n        \\n        // iterate the intervals\\n        for interval in intervalsSorted {\\n            // does the current interval overlap the last\\n            if !result.isEmpty && interval.start <= result.last!.end {\\n                // there is overlap, rewrite the last interval with the\\n                // higher end value, the start value must be <= current\\n                // due to the prior sort\\n                result.last!.end = max(result.last!.end, interval.end)\\n            } else {\\n                // no overlap (or no last), append current interval\\n                result.append(interval)\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21474,
                "title": "14ms-java-in-place-merge-solution",
                "content": "    public class Solution {\\n    public List<Interval> merge(List<Interval> intervals) {\\n        int N = intervals.size();\\n        Collections.sort(intervals, new Comparator<Interval>(){\\n        \\tpublic int compare(Interval i, Interval j){\\n                    return i.end - j.end;\\n        \\t}\\n        });\\n        for(int i = N-1; i>0;i--){\\n            Interval inter1 = intervals.get(i-1);\\n\\t        Interval inter2 = intervals.get(i);\\n\\t        if(inter1.end >= inter2.start){\\n\\t            inter1.start = Math.min(inter1.start, inter2.start);\\n\\t            inter1.end = inter2.end; //inter1.end is always smaller than inter2.end because of the sort, so no need to use Math.max()\\n\\t            intervals.remove(i);\\n\\t        }\\n\\t    }\\n        return intervals;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Interval> merge(List<Interval> intervals) {\\n        int N = intervals.size();\\n        Collections.sort(intervals, new Comparator<Interval>(){\\n        \\tpublic int compare(Interval i, Interval j){\\n                    return i.end - j.end;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3432844,
                "title": "easy-python-solution-with-linear-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals=sorted(intervals)\\n        res=[intervals[0]]\\n        for start,end in intervals[1:]:\\n            lastEnd=res[-1][1]\\n            if lastEnd>=start:\\n                res[-1][1]=max(lastEnd,end)\\n            else:\\n                res.append([start,end])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals=sorted(intervals)\\n        res=[intervals[0]]\\n        for start,end in intervals[1:]:\\n            lastEnd=res[-1][1]\\n            if lastEnd>=start:\\n                res[-1][1]=max(lastEnd,end)\\n            else:\\n                res.append([start,end])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425508,
                "title": "awesome-logic-problems",
                "content": "\\n\\n# Python solutions\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x:x[0])\\n        list1=[intervals[0]]\\n        for i ,j in intervals[1:]:\\n            if list1[-1][1]>=i:\\n                list1[-1][1]=max(list1[-1][1],j)\\n            else:\\n                list1.append([i,j])\\n        return list1\\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x:x[0])\\n        list1=[intervals[0]]\\n        for i ,j in intervals[1:]:\\n            if list1[-1][1]>=i:\\n                list1[-1][1]=max(list1[-1][1],j)\\n            else:\\n                list1.append([i,j])\\n        return list1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379595,
                "title": "best-o-nlogn-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort (intervals.begin(), intervals.end());\\n        vector<vector<int>> merged;\\n        for (int i = 0; i < n; i++) {\\n            int start = intervals[i][0], end = intervals[i][1];\\n            if (!merged.empty()) {\\n                auto last = merged.back();\\n                if (end <= last[1])\\n                    continue;\\n            }  \\n            for (int j = i + 1; j < n; j++) {\\n                if (intervals[j][0] <= end) \\n                    end = max (intervals[j][1], end);\\n            }\\n            merged.push_back({start, end});\\n        }\\n        return merged;\\n    }\\n};\\n```\\n\\n# Approach 2\\nSorting\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> merged;\\n        if (intervals.size() == 0)\\n            return merged;\\n        sort (intervals.begin(), intervals.end());\\n        vector <int> cur = intervals[0];\\n        for (auto it : intervals) {\\n            if (it[0] <= cur[1]) {\\n                cur[1] = max (it[1], cur[1]);\\n            } else {\\n                merged.push_back(cur);\\n                cur = it;\\n            }\\n        }\\n        merged.push_back(cur);\\n        return merged;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort (intervals.begin(), intervals.end());\\n        vector<vector<int>> merged;\\n        for (int i = 0; i < n; i++) {\\n            int start = intervals[i][0], end = intervals[i][1];\\n            if (!merged.empty()) {\\n                auto last = merged.back();\\n                if (end <= last[1])\\n                    continue;\\n            }  \\n            for (int j = i + 1; j < n; j++) {\\n                if (intervals[j][0] <= end) \\n                    end = max (intervals[j][1], end);\\n            }\\n            merged.push_back({start, end});\\n        }\\n        return merged;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> merged;\\n        if (intervals.size() == 0)\\n            return merged;\\n        sort (intervals.begin(), intervals.end());\\n        vector <int> cur = intervals[0];\\n        for (auto it : intervals) {\\n            if (it[0] <= cur[1]) {\\n                cur[1] = max (it[1], cur[1]);\\n            } else {\\n                merged.push_back(cur);\\n                cur = it;\\n            }\\n        }\\n        merged.push_back(cur);\\n        return merged;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338016,
                "title": "you-got-it-in-single-sight",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>&ii) {\\n        sort(ii.begin(),ii.end());\\n        vector<vector<int>>ans;\\n        int n=ii.size();\\n        int a=ii[0][0];\\n        int b=ii[0][1];\\n        for(int i=1;i<n;i++){\\n            if(ii[i][0]<=b){\\n                b=max(b,ii[i][1]);\\n            }\\n            else{\\n                ans.push_back({a,b});\\n                a=ii[i][0];\\n                b=ii[i][1];\\n\\n            }\\n        }\\n        ans.push_back({a,b});\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>&ii) {\\n        sort(ii.begin(),ii.end());\\n        vector<vector<int>>ans;\\n        int n=ii.size();\\n        int a=ii[0][0];\\n        int b=ii[0][1];\\n        for(int i=1;i<n;i++){\\n            if(ii[i][0]<=b){\\n                b=max(b,ii[i][1]);\\n            }\\n            else{\\n                ans.push_back({a,b});\\n                a=ii[i][0];\\n                b=ii[i][1];\\n\\n            }\\n        }\\n        ans.push_back({a,b});\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321081,
                "title": "best-c-solution-using-by-reference-vector-and-implementation",
                "content": "# Intuition :\\nObserve the pattern is more clear in case of sorted vector.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : \\nImplementation based \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)+O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n      sort(intervals.begin(), intervals.end());//So that it becomes easier to merge all the smaller intervals first\\n        vector<vector<int>>ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n          vector<int> &temp= ans.back();//Accessing last element fo ans vector\\n          if(temp[1]>=intervals[i][0]){\\n            //updating it . This change will also get reflected in ans vector as we have taken temp vector as by reference \\n            temp[1]=max(temp[1], intervals[i][1]);\\n          }\\n          else ans.push_back(intervals[i]);// Just push the element if condition doesn\\'t matched or satisfied\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n      sort(intervals.begin(), intervals.end());//So that it becomes easier to merge all the smaller intervals first\\n        vector<vector<int>>ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n          vector<int> &temp= ans.back();//Accessing last element fo ans vector\\n          if(temp[1]>=intervals[i][0]){\\n            //updating it . This change will also get reflected in ans vector as we have taken temp vector as by reference \\n            temp[1]=max(temp[1], intervals[i][1]);\\n          }\\n          else ans.push_back(intervals[i]);// Just push the element if condition doesn\\'t matched or satisfied\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016465,
                "title": "java-solution-using-stack-and-sorting-o-nlogn",
                "content": "# Complexity\\n- Time complexity: O(NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    // 8 Jaynary 2023\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a1,a2)-> a1[0]-a2[0]); // O(NlogN)\\n\\n        Stack<int[]> stack = new Stack<>(); //O(N)\\n        stack.push(intervals[0]);\\n        int i=1;\\n        while(!stack.isEmpty() && i < intervals.length){ //O(N)\\n            int[] current = stack.peek();\\n            int[] next = intervals[i++];\\n            if(current[1]>=next[0]){\\n                stack.pop();\\n                current[1] = Math.max(current[1], next[1]);\\n                stack.push(current);\\n            }else{\\n                stack.push(next);\\n            }\\n        }\\n\\n        return stack.toArray(new int[stack.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    // 8 Jaynary 2023\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a1,a2)-> a1[0]-a2[0]); // O(NlogN)\\n\\n        Stack<int[]> stack = new Stack<>(); //O(N)\\n        stack.push(intervals[0]);\\n        int i=1;\\n        while(!stack.isEmpty() && i < intervals.length){ //O(N)\\n            int[] current = stack.peek();\\n            int[] next = intervals[i++];\\n            if(current[1]>=next[0]){\\n                stack.pop();\\n                current[1] = Math.max(current[1], next[1]);\\n                stack.push(current);\\n            }else{\\n                stack.push(next);\\n            }\\n        }\\n\\n        return stack.toArray(new int[stack.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848227,
                "title": "intuitive-c-solution-tc-o-nlogn-sc-o-n-single-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf two intervals are overlapping, the new interval will start from the starting time of the first interval and end at the ending time of the maximum end time of the two intervals.\\n\\nThis approach can be generalised for n intervals: If n intervals are overlapping, the resultant interval will start at the starting time of the first interval and end at the ending time of the maximum end time of the n intervals.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the given \\'intervals\\' array. This will ensure that the interval with the lowest starting time is at the beginning.\\n\\nIterate the entire array and initialize a variable \\'maxEnd\\' as the ending value of the ith interval. Also, initialize another variable \\'j\\' with the value after the ith interval.\\n\\nNow, while j is less than the size of the array and the starting time of j is less than (or equal to) maxEnd, assign maxEnd the maximum value of maxEnd and ending time. Finally, increment j.\\n\\nOnce loop is exited (upon either or both conditions being false), pushback into the solution the starting value of i and maxEnd as the starting and ending times of the new interval respectively.\\n\\nSince i will eventually get incremented (due to it being in for loop) and j is now pointing to the new interval, re-initialize i as the value prior to j.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n=intervals.size();\\n        vector<vector<int>> sol;\\n\\n        sort(intervals.begin(), intervals.end());\\n\\n        for(int i=0;i<n;i++){\\n            int maxEnd=intervals[i][1];\\n            int j=i+1;\\n\\n            while((j<n)&&(intervals[j][0]<=maxEnd)){\\n                maxEnd=max(maxEnd, intervals[j][1]);\\n                j++;\\n            }\\n            sol.push_back({intervals[i][0], maxEnd});\\n            i=j-1;\\n        }   \\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy",
                    "Sort",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n=intervals.size();\\n        vector<vector<int>> sol;\\n\\n        sort(intervals.begin(), intervals.end());\\n\\n        for(int i=0;i<n;i++){\\n            int maxEnd=intervals[i][1];\\n            int j=i+1;\\n\\n            while((j<n)&&(intervals[j][0]<=maxEnd)){\\n                maxEnd=max(maxEnd, intervals[j][1]);\\n                j++;\\n            }\\n            sol.push_back({intervals[i][0], maxEnd});\\n            i=j-1;\\n        }   \\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567482,
                "title": "c-easy-and-fast-solution-o-nlog-n",
                "content": "\\t\\t//\\uD83D\\uDD25\\u2705 PLEASE UPVOTE IF YOU LIKE THIS SOLUTION\\uD83D\\uDD25\\u2705\\n\\t\\tsort(in.begin(),in.end());\\n        vector<vector<int>>vec; int first,last;\\n            first=in[0][0];  last=in[0][1];\\n        for(int i=1;i<in.size();i++)\\n        {\\n            if(in[i][1]<=last) continue;\\n            else if(in[i][0]<=last and last<=in[i][1]) last=in[i][1];\\n            else \\n            {\\n                vec.push_back({first,last});  \\n                first=in[i][0];  last=in[i][1];\\n            }\\n        }\\n        vec.push_back({first,last});\\n        return vec;\\n\\t\\t//\\uD83D\\uDD25\\u2705 PLEASE UPVOTE IF YOU LIKE THIS SOLUTION\\uD83D\\uDD25\\u2705",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t\\t//\\uD83D\\uDD25\\u2705 PLEASE UPVOTE IF YOU LIKE THIS SOLUTION\\uD83D\\uDD25\\u2705\\n\\t\\tsort(in.begin(),in.end());\\n        vector<vector<int>>vec; int first,last;\\n            first=in[0][0];  last=in[0][1];\\n        for(int i=1;i<in.size();i++)\\n        {\\n            if(in[i][1]<=last) continue;\\n            else if(in[i][0]<=last and last<=in[i][1]) last=in[i][1];\\n            else \\n            {\\n                vec.push_back({first,last});  \\n                first=in[i][0];  last=in[i][1];\\n            }\\n        }\\n        vec.push_back({first,last});\\n        return vec;\\n\\t\\t//\\uD83D\\uDD25\\u2705 PLEASE UPVOTE IF YOU LIKE THIS SOLUTION\\uD83D\\uDD25\\u2705",
                "codeTag": "Unknown"
            },
            {
                "id": 2413048,
                "title": "c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(ans.back()[1]>=intervals[i][0]){\\n                ans.back()[1] = max(ans.back()[1],intervals[i][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(ans.back()[1]>=intervals[i][0]){\\n                ans.back()[1] = max(ans.back()[1],intervals[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2002088,
                "title": "easy-to-follow-javascript-solution",
                "content": "```\\nvar merge = function(intervals) {\\n    let sorted = intervals.sort((a, b) => a[0] - b[0]);\\n    let res = [sorted[0]]\\n    \\n    for (let i = 1; i < sorted.length; i++) {\\n      let currStart = sorted[i][0]\\n      let currEnd = sorted[i][1];\\n      let lastEnd = res[res.length - 1][1];\\n      \\n      if (currStart <= lastEnd) {\\n        res[res.length - 1][1] = Math.max(lastEnd, currEnd);\\n      }\\n      else {\\n        res.push(sorted[i])\\n      }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n    let sorted = intervals.sort((a, b) => a[0] - b[0]);\\n    let res = [sorted[0]]\\n    \\n    for (let i = 1; i < sorted.length; i++) {\\n      let currStart = sorted[i][0]\\n      let currEnd = sorted[i][1];\\n      let lastEnd = res[res.length - 1][1];\\n      \\n      if (currStart <= lastEnd) {\\n        res[res.length - 1][1] = Math.max(lastEnd, currEnd);\\n      }\\n      else {\\n        res.push(sorted[i])\\n      }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1693265,
                "title": "java-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n  /**\\n   * Time O(n)\\n   * Space O(n)\\n   */\\n  public int[][] merge(int[][] intervals) {\\n    int[] start = new int[10000];\\n    int[] end = new int[10000];\\n    List<int[]> retList = new ArrayList<>();\\n    Stack<Integer> stack = new Stack<>();\\n    int max = 0;\\n    \\n    // Time O(n)\\n    for (int i = 0; i < intervals.length; i++) {\\n      start[intervals[i][0]]++;\\n      end[intervals[i][1]]++;\\n      max = Math.max(max, intervals[i][1]);\\n    }\\n\\n    // Time O(n)\\n    int[] range = new int[2];\\n    for (int i = 0; i <= max; i++) {\\n      if (start[i] > 0) {\\n        if (stack.isEmpty()) {\\n          range = new int[2];\\n          range[0] = i;\\n          retList.add(range);\\n        }\\n        for (int j = 0; j < start[i]; j++) stack.push(i);\\n      }\\n      \\n      if (end[i] > 0) {\\n        for (int j = 0; j < end[i]; j++) stack.pop();\\n        if (stack.isEmpty()) {\\n          range[1] = i;\\n          retList.set(retList.size() - 1, range);\\n        }\\n      }\\n    }\\n\\n    // Time O(n)\\n    return retList.toArray(new int[retList.size()][]);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  /**\\n   * Time O(n)\\n   * Space O(n)\\n   */\\n  public int[][] merge(int[][] intervals) {\\n    int[] start = new int[10000];\\n    int[] end = new int[10000];\\n    List<int[]> retList = new ArrayList<>();\\n    Stack<Integer> stack = new Stack<>();\\n    int max = 0;\\n    \\n    // Time O(n)\\n    for (int i = 0; i < intervals.length; i++) {\\n      start[intervals[i][0]]++;\\n      end[intervals[i][1]]++;\\n      max = Math.max(max, intervals[i][1]);\\n    }\\n\\n    // Time O(n)\\n    int[] range = new int[2];\\n    for (int i = 0; i <= max; i++) {\\n      if (start[i] > 0) {\\n        if (stack.isEmpty()) {\\n          range = new int[2];\\n          range[0] = i;\\n          retList.add(range);\\n        }\\n        for (int j = 0; j < start[i]; j++) stack.push(i);\\n      }\\n      \\n      if (end[i] > 0) {\\n        for (int j = 0; j < end[i]; j++) stack.pop();\\n        if (stack.isEmpty()) {\\n          range[1] = i;\\n          retList.set(retList.size() - 1, range);\\n        }\\n      }\\n    }\\n\\n    // Time O(n)\\n    return retList.toArray(new int[retList.size()][]);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644466,
                "title": "c-solution-using-inplace",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& nums) \\n    {\\n        int n=nums.size();\\n        if(n==0)\\n        {\\n            return {};\\n        }\\n        int j=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[j][1]>=nums[i][0])\\n            {\\n                nums[j][1]=max({nums[j][1],nums[i][1]});\\n            }\\n            else\\n            {\\n                nums[++j]=nums[i];\\n            }\\n        }\\n        return vector<vector<int>>(nums.begin(),nums.begin()+j+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& nums) \\n    {\\n        int n=nums.size();\\n        if(n==0)\\n        {\\n            return {};\\n        }\\n        int j=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[j][1]>=nums[i][0])\\n            {\\n                nums[j][1]=max({nums[j][1],nums[i][1]});\\n            }\\n            else\\n            {\\n                nums[++j]=nums[i];\\n            }\\n        }\\n        return vector<vector<int>>(nums.begin(),nums.begin()+j+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628093,
                "title": "java-solution",
                "content": "```\\n/**\\ncases: edge overlapping, full overlapping, none\\n[[1,3],[2,4],[4,5],[6,7],[8,12],[10,11]]\\ntime: O(nlogn) - length of interval array\\nspace: O(n)\\n*/\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) {\\n            return intervals;\\n        }\\n        Arrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0])); // sort by start point\\n\\n        List<int[]> result = new ArrayList<>();\\n        int[] currInterval = intervals[0]; // grab first interval to compare\\n        \\n        int i = 1;\\n        while (i < intervals.length) {\\n            if (intervals[i][0] > currInterval[1]) { // no overlap\\n                result.add(currInterval);\\n                currInterval = intervals[i]; // move to the next interval if no overlap\\n                if (i == intervals.length-1) { // edge case if we hit last\\n                    result.add(currInterval);\\n                }\\n            }\\n            else if (currInterval[1] >= intervals[i][0]) { // if overlap\\n                currInterval[0] = Math.min(currInterval[0], intervals[i][0]);\\n                currInterval[1] = Math.max(currInterval[1], intervals[i][1]);\\n                // result.add(currInterval); // no need to add, we are just expanding interval\\n                if (i == intervals.length-1) { // edge case if we hit last\\n                    result.add(currInterval);\\n                }\\n            }\\n            i++;\\n        }\\n        return result.toArray(new int[result.size()][]); // convert parent List to array\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\ncases: edge overlapping, full overlapping, none\\n[[1,3],[2,4],[4,5],[6,7],[8,12],[10,11]]\\ntime: O(nlogn) - length of interval array\\nspace: O(n)\\n*/\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) {\\n            return intervals;\\n        }\\n        Arrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0])); // sort by start point\\n\\n        List<int[]> result = new ArrayList<>();\\n        int[] currInterval = intervals[0]; // grab first interval to compare\\n        \\n        int i = 1;\\n        while (i < intervals.length) {\\n            if (intervals[i][0] > currInterval[1]) { // no overlap\\n                result.add(currInterval);\\n                currInterval = intervals[i]; // move to the next interval if no overlap\\n                if (i == intervals.length-1) { // edge case if we hit last\\n                    result.add(currInterval);\\n                }\\n            }\\n            else if (currInterval[1] >= intervals[i][0]) { // if overlap\\n                currInterval[0] = Math.min(currInterval[0], intervals[i][0]);\\n                currInterval[1] = Math.max(currInterval[1], intervals[i][1]);\\n                // result.add(currInterval); // no need to add, we are just expanding interval\\n                if (i == intervals.length-1) { // edge case if we hit last\\n                    result.add(currInterval);\\n                }\\n            }\\n            i++;\\n        }\\n        return result.toArray(new int[result.size()][]); // convert parent List to array\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531770,
                "title": "python-using-heap",
                "content": "```\\nfrom heapq import heappop, heappush\\nclass Solution(object):\\n    def merge(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        heap =[]\\n        res = []\\n        intervals.sort()\\n        for i in intervals:\\n            if not heap:\\n                heapq.heappush(heap, i)\\n            elif heap[0][1]>=i[0]:\\n                    m, n = heapq.heappop(heap)\\n                    \\n                    heapq.heappush( heap, [min(m, i[0]), max(i[1], n)])\\n            else:\\n                res.append(heapq.heappop(heap))\\n                heapq.heappush(heap, i)\\n        \\n        if heap:\\n            res.extend(heap)\\n        print(res)\\n        return res\\n                    \\n                    \\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappop, heappush\\nclass Solution(object):\\n    def merge(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        heap =[]\\n        res = []\\n        intervals.sort()\\n        for i in intervals:\\n            if not heap:\\n                heapq.heappush(heap, i)\\n            elif heap[0][1]>=i[0]:\\n                    m, n = heapq.heappop(heap)\\n                    \\n                    heapq.heappush( heap, [min(m, i[0]), max(i[1], n)])\\n            else:\\n                res.append(heapq.heappop(heap))\\n                heapq.heappush(heap, i)\\n        \\n        if heap:\\n            res.extend(heap)\\n        print(res)\\n        return res\\n                    \\n                    \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461378,
                "title": "c-comments-merge-intervals",
                "content": "```\\n// There can be three cases with two intervals \\n// Case 1:- No overlap\\n//  [1,           2]      [3,             4]\\n//  _______________        ________________\\n// | left interval |      | right interval |\\n// |_______________|      |________________|\\n\\n//Case 2:- Partial overlap\\n// [1,             3]      \\n//  _______________\\n// | left interval |\\n// |_______________|\\n//           [2,            4]\\n//            ________________\\n//           | right interval |\\n//           |________________|\\n\\n// Case 3:- Full overlap\\n//  [1,                 4]\\n//  _____________________\\n// |    left interval    |\\n// |_____________________|\\n//   [2,             3]\\n//    ________________\\n//   | right interval |\\n//   |________________|\\n\\n\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        // sort intervals on basis of start value\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n\\t\\tint left=0,right=1;\\n        vector<vector<int>>ans; // For storing the result\\n\\t\\t\\n        while(left<n && right<n)\\n        {\\n            if(v[left][1]<v[right][0])    // Case 1 : (No overlap )\\n            {\\n                left=right;\\n                right++;\\n            }\\n            //  overlap occurs (Case 2 or Case 3)\\n            else\\n            {\\n                if(v[left][1]>=v[right][1])  // Case 3: (Full overlap)\\n                {\\n                    // Mark the fully overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n                // Case 2: (partial overlap)\\n                else\\n                {\\n                    // Extend the end point of the left interval( by making end point of left interval=end point of right interval) so that the intervals can be merged \\n                    v[left][1]=v[right][1];\\n                    // Mark the partially overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            // If any interval is marked then don\\'t push it to the ans vector cause after merging marked intervals can\\'t have their existence\\n            if(v[i][0]!=-1)\\n            {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n// There can be three cases with two intervals \\n// Case 1:- No overlap\\n//  [1,           2]      [3,             4]\\n//  _______________        ________________\\n// | left interval |      | right interval |\\n// |_______________|      |________________|\\n\\n//Case 2:- Partial overlap\\n// [1,             3]      \\n//  _______________\\n// | left interval |\\n// |_______________|\\n//           [2,            4]\\n//            ________________\\n//           | right interval |\\n//           |________________|\\n\\n// Case 3:- Full overlap\\n//  [1,                 4]\\n//  _____________________\\n// |    left interval    |\\n// |_____________________|\\n//   [2,             3]\\n//    ________________\\n//   | right interval |\\n//   |________________|\\n\\n\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        // sort intervals on basis of start value\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n\\t\\tint left=0,right=1;\\n        vector<vector<int>>ans; // For storing the result\\n\\t\\t\\n        while(left<n && right<n)\\n        {\\n            if(v[left][1]<v[right][0])    // Case 1 : (No overlap )\\n            {\\n                left=right;\\n                right++;\\n            }\\n            //  overlap occurs (Case 2 or Case 3)\\n            else\\n            {\\n                if(v[left][1]>=v[right][1])  // Case 3: (Full overlap)\\n                {\\n                    // Mark the fully overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n                // Case 2: (partial overlap)\\n                else\\n                {\\n                    // Extend the end point of the left interval( by making end point of left interval=end point of right interval) so that the intervals can be merged \\n                    v[left][1]=v[right][1];\\n                    // Mark the partially overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            // If any interval is marked then don\\'t push it to the ans vector cause after merging marked intervals can\\'t have their existence\\n            if(v[i][0]!=-1)\\n            {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367823,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var merge = function(intervals) {\\n        if(intervals.length == 0) return []    // edge cases\\n        else if(intervals.length == 1) return intervals // edge cases\\n    \\n        intervals.sort((a,b) => {\\n            return a[0]-b[0];\\n        })\\n    \\n        let result = [intervals[0]]\\n    \\n        for(let interval of intervals) {\\n            let recentInterval = result[result.length-1]\\n            if(recentInterval[1] >= interval[0]) {\\n                recentInterval[1] = Math.max(recentInterval[1], interval[1])\\n            } else {\\n                result.push(interval)\\n            }\\n        }\\n        return result\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n    var merge = function(intervals) {\\n        if(intervals.length == 0) return []    // edge cases\\n        else if(intervals.length == 1) return intervals // edge cases\\n    \\n        intervals.sort((a,b) => {\\n            return a[0]-b[0];\\n        })\\n    \\n        let result = [intervals[0]]\\n    \\n        for(let interval of intervals) {\\n            let recentInterval = result[result.length-1]\\n            if(recentInterval[1] >= interval[0]) {\\n                recentInterval[1] = Math.max(recentInterval[1], interval[1])\\n            } else {\\n                result.push(interval)\\n            }\\n        }\\n        return result\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1261003,
                "title": "zero-bullshit-c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        sort(intervals.begin(),intervals.end());\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]>res.back()[1])\\n                res.push_back(intervals[i]);\\n            else\\n                res.back()[1]=max(res.back()[1],intervals[i][1]);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        sort(intervals.begin(),intervals.end());\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]>res.back()[1])\\n                res.push_back(intervals[i]);\\n            else\\n                res.back()[1]=max(res.back()[1],intervals[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1246685,
                "title": "easy-to-understand-clean-well-explained-every-step-with-comments-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) \\n    {\\n        //Checking if there is only one interval\\n        if(intervals.size()<=1)return intervals;\\n        \\n        //Sorting the intervals on the basis of starting time\\n        sort(intervals.begin(),intervals.end());\\n        \\n        //Creating vector of vectors to store the intervals\\n        vector<vector<int>>ans;\\n        \\n        //Storing the 1st interval in temp vector(It will containg start time and end time)\\n        vector<int>temp=intervals[0];\\n        \\n        //It will be vector of intervals start and end time\\n        for(auto it:intervals)\\n        {\\n            //if EndTime of Ith Interval is greate than start of i+1th Interval\\n            //We\\'ll merge the interval The End Time of merged interval Will be  \\n            //Max of end time of both the ith and i+1th interval\\n            if(temp[1]>=it[0])\\n            {\\n                temp[1]=max(temp[1],it[1]);\\n                \\n            }\\n            //If Merging is not possible we\\'ll put the i+1th interval in ans\\n            //And we\\'ll update the temp with i+1th interval and repeat the process for next\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp=it;\\n            }\\n        }\\n        //Putting the Last Interval in the ans array\\n        ans.push_back(temp);\\n         \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) \\n    {\\n        //Checking if there is only one interval\\n        if(intervals.size()<=1)return intervals;\\n        \\n        //Sorting the intervals on the basis of starting time\\n        sort(intervals.begin(),intervals.end());\\n        \\n        //Creating vector of vectors to store the intervals\\n        vector<vector<int>>ans;\\n        \\n        //Storing the 1st interval in temp vector(It will containg start time and end time)\\n        vector<int>temp=intervals[0];\\n        \\n        //It will be vector of intervals start and end time\\n        for(auto it:intervals)\\n        {\\n            //if EndTime of Ith Interval is greate than start of i+1th Interval\\n            //We\\'ll merge the interval The End Time of merged interval Will be  \\n            //Max of end time of both the ith and i+1th interval\\n            if(temp[1]>=it[0])\\n            {\\n                temp[1]=max(temp[1],it[1]);\\n                \\n            }\\n            //If Merging is not possible we\\'ll put the i+1th interval in ans\\n            //And we\\'ll update the temp with i+1th interval and repeat the process for next\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp=it;\\n            }\\n        }\\n        //Putting the Last Interval in the ans array\\n        ans.push_back(temp);\\n         \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213592,
                "title": "easiest-and-best-c-solution-beats-99-submissions",
                "content": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        res.push_back(intervals[0]);\\n        for(int i = 1 ; i < intervals.size() ; i++){\\n            if(res.back()[1] >= (intervals[i])[0]){\\n                res.back()[1] = max(res.back()[1],(intervals[i])[1]);\\n            }\\n            else{\\n                res.push_back(intervals[i]);\\n            }\\n        }\\n        return res;\\n    }\\n```\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        res.push_back(intervals[0]);\\n        for(int i = 1 ; i < intervals.size() ; i++){\\n            if(res.back()[1] >= (intervals[i])[0]){\\n                res.back()[1] = max(res.back()[1],(intervals[i])[1]);\\n            }\\n            else{\\n                res.push_back(intervals[i]);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081743,
                "title": "clean-streaming-solution-for-followup",
                "content": "```\\n// use a balanced binary search tree to store intervals in sorted order as they come in\\n// if we add a new one, we need to iterate over all intervals and merge as needed\\n// as we iterate, if newInterval and current interval overlap, then remove currentInterval and merge\\n// keep removing and merging until we have no overlap, add merged interval back in\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        TreeSet<int[]> bbst = new TreeSet<int[]>((a, b) -> a[0]-b[0]);\\n        for(int[] interval: intervals) {\\n            Iterator<int[]> itr = bbst.iterator();\\n            while(itr.hasNext()) {\\n                int[] currInterval = itr.next();\\n                if(overlap(currInterval, interval)) {\\n                    interval = merge(currInterval, interval);\\n                    itr.remove();\\n                }\\n            }\\n            bbst.add(interval);\\n        }\\n        \\n        int size = bbst.size();\\n        int[][] res = new int[size][2];\\n        int idx = 0;\\n        for(int[] interval: bbst) {\\n            res[idx] = interval;\\n            idx++;\\n        }\\n        return res;\\n    }\\n    \\n    public boolean overlap(int[] intervalA, int[] intervalB) {\\n        return Math.max(intervalA[0], intervalB[0]) <= Math.min(intervalA[1], intervalB[1]);\\n    }\\n    \\n    public int[] merge(int[] intervalA, int[] intervalB) {\\n        int start = Math.min(intervalA[0], intervalB[0]);\\n        int end = Math.max(intervalA[1], intervalB[1]);\\n        return new int[]{start, end};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// use a balanced binary search tree to store intervals in sorted order as they come in\\n// if we add a new one, we need to iterate over all intervals and merge as needed\\n// as we iterate, if newInterval and current interval overlap, then remove currentInterval and merge\\n// keep removing and merging until we have no overlap, add merged interval back in\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        TreeSet<int[]> bbst = new TreeSet<int[]>((a, b) -> a[0]-b[0]);\\n        for(int[] interval: intervals) {\\n            Iterator<int[]> itr = bbst.iterator();\\n            while(itr.hasNext()) {\\n                int[] currInterval = itr.next();\\n                if(overlap(currInterval, interval)) {\\n                    interval = merge(currInterval, interval);\\n                    itr.remove();\\n                }\\n            }\\n            bbst.add(interval);\\n        }\\n        \\n        int size = bbst.size();\\n        int[][] res = new int[size][2];\\n        int idx = 0;\\n        for(int[] interval: bbst) {\\n            res[idx] = interval;\\n            idx++;\\n        }\\n        return res;\\n    }\\n    \\n    public boolean overlap(int[] intervalA, int[] intervalB) {\\n        return Math.max(intervalA[0], intervalB[0]) <= Math.min(intervalA[1], intervalB[1]);\\n    }\\n    \\n    public int[] merge(int[] intervalA, int[] intervalB) {\\n        int start = Math.min(intervalA[0], intervalB[0]);\\n        int end = Math.max(intervalA[1], intervalB[1]);\\n        return new int[]{start, end};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963251,
                "title": "golang-solution",
                "content": "```\\nfunc merge(intervals [][]int) [][]int {\\n    res := make([][]int, 0)\\n    sort.Slice(intervals, func(a, b int)bool {\\n        return intervals[a][0] < intervals[b][0]\\n    })\\n    \\n    res = append(res, intervals[0])\\n    \\n    for i := 1; i < len(intervals); i++ {\\n        if intervals[i][0] <= res[len(res) - 1][1] {\\n            //update last range in result case\\n            res[len(res) - 1][1] = max(res[len(res) - 1][1], intervals[i][1])\\n        } else {\\n            //insert new range into result case\\n            res = append(res, intervals[i])\\n        }\\n    }\\n    return res\\n}\\n\\nfunc max(a, b int)int {\\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc merge(intervals [][]int) [][]int {\\n    res := make([][]int, 0)\\n    sort.Slice(intervals, func(a, b int)bool {\\n        return intervals[a][0] < intervals[b][0]\\n    })\\n    \\n    res = append(res, intervals[0])\\n    \\n    for i := 1; i < len(intervals); i++ {\\n        if intervals[i][0] <= res[len(res) - 1][1] {\\n            //update last range in result case\\n            res[len(res) - 1][1] = max(res[len(res) - 1][1], intervals[i][1])\\n        } else {\\n            //insert new range into result case\\n            res = append(res, intervals[i])\\n        }\\n    }\\n    return res\\n}\\n\\nfunc max(a, b int)int {\\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 845362,
                "title": "java-sol-sort-and-merge-intervals",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> res = new ArrayList<>();\\n        \\n        if (intervals == null || intervals.length == 0) {\\n            return res.toArray(new int[][] {});\\n        }\\n        \\n        // Sort intervals ascending by start value\\n        Arrays.sort(intervals, (pair1, pair2) -> {\\n            return pair1[0] - pair2[0];\\n        });\\n        \\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        for (int i = 1; i < intervals.length; i++) {\\n            if (intervals[i][1] < end) {\\n                // Ignore current interval, it is a subset of the previous\\n                continue;\\n            }\\n            \\n            if (intervals[i][0] > end) {\\n                res.add(new int[]{ start, end });\\n                \\n                start = intervals[i][0];\\n            }\\n            \\n            end = intervals[i][1];\\n        }\\n        \\n        res.add(new int[]{ start, end });\\n        \\n        return res.toArray(new int[][] {});\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> res = new ArrayList<>();\\n        \\n        if (intervals == null || intervals.length == 0) {\\n            return res.toArray(new int[][] {});\\n        }\\n        \\n        // Sort intervals ascending by start value\\n        Arrays.sort(intervals, (pair1, pair2) -> {\\n            return pair1[0] - pair2[0];\\n        });\\n        \\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        for (int i = 1; i < intervals.length; i++) {\\n            if (intervals[i][1] < end) {\\n                // Ignore current interval, it is a subset of the previous\\n                continue;\\n            }\\n            \\n            if (intervals[i][0] > end) {\\n                res.add(new int[]{ start, end });\\n                \\n                start = intervals[i][0];\\n            }\\n            \\n            end = intervals[i][1];\\n        }\\n        \\n        res.add(new int[]{ start, end });\\n        \\n        return res.toArray(new int[][] {});\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578912,
                "title": "go-runtime-99-39-mem-100",
                "content": "```\\nfunc merge(intervals [][]int) [][]int {\\n    sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })\\n    \\n    res := [][]int{}\\n    for i, interval := range intervals {\\n        if i == 0 {\\n            res = append(res, interval)\\n            continue\\n        }\\n        \\n        r := res[len(res)-1]\\n        if interval[0] <= r[1] && r[1] < interval[1] {\\n            res[len(res)-1] = []int{r[0], interval[1]}\\n        }\\n        if r[1] < interval[0] {\\n            res = append(res, interval)\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc merge(intervals [][]int) [][]int {\\n    sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })\\n    \\n    res := [][]int{}\\n    for i, interval := range intervals {\\n        if i == 0 {\\n            res = append(res, interval)\\n            continue\\n        }\\n        \\n        r := res[len(res)-1]\\n        if interval[0] <= r[1] && r[1] < interval[1] {\\n            res[len(res)-1] = []int{r[0], interval[1]}\\n        }\\n        if r[1] < interval[0] {\\n            res = append(res, interval)\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 524522,
                "title": "python-3-simple-and-easy-solution",
                "content": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0:\\n            return []\\n        \\n        sorted_intervals = sorted(intervals, key=lambda l:l[0])\\n        \\n        res = [sorted_intervals[0]]\\n        for interval in sorted_intervals[1:]:\\n            if res[-1][1] >= interval[0]:\\n                res[-1][1] = max(res[-1][1], interval[1])\\n            else:\\n                res.append(interval)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0:\\n            return []\\n        \\n        sorted_intervals = sorted(intervals, key=lambda l:l[0])\\n        \\n        res = [sorted_intervals[0]]\\n        for interval in sorted_intervals[1:]:\\n            if res[-1][1] >= interval[0]:\\n                res[-1][1] = max(res[-1][1], interval[1])\\n            else:\\n                res.append(interval)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293571,
                "title": "c-why-do-i-get-runtime-error-depending-on-whenther-sort-comp-function-is-or",
                "content": "The following fails when comp function is a[0]<=b[0]\\nrun time error is reference binding to null pointer of type \\'value_type\\' (stl_vector.h)\\n```\\nclass Solution {\\nprivate:\\n    static int comp(vector<int> a, vector<int> b){\\n        return a[0]<=b[0];\\n    }\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int n=intervals.size();\\n        vector<vector<int>> merged;\\n        if (n==0) return merged;\\n        for (int i=0;i<n;i++) {\\n            if (merged.empty() || merged.back()[1]<intervals[i][0])\\n                merged.push_back(intervals[i]);\\n            else\\n                merged.back()[1]=max(merged.back()[1], intervals[i][1]);\\n        }\\n        return merged;\\n    }\\n};\\n```\\nBut this comp function a[0]<b[0] solution succeeds\\n```\\nclass Solution {\\nprivate:\\n    static int comp(vector<int> a, vector<int> b){\\n        return a[0]<b[0];\\n    }\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int n=intervals.size();\\n        vector<vector<int>> merged;\\n        if (n==0) return merged;\\n        for (int i=0;i<n;i++) {\\n            if (merged.empty() || merged.back()[1]<intervals[i][0])\\n                merged.push_back(intervals[i]);\\n            else\\n                merged.back()[1]=max(merged.back()[1], intervals[i][1]);\\n        }\\n        return merged;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    static int comp(vector<int> a, vector<int> b){\\n        return a[0]<=b[0];\\n    }\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int n=intervals.size();\\n        vector<vector<int>> merged;\\n        if (n==0) return merged;\\n        for (int i=0;i<n;i++) {\\n            if (merged.empty() || merged.back()[1]<intervals[i][0])\\n                merged.push_back(intervals[i]);\\n            else\\n                merged.back()[1]=max(merged.back()[1], intervals[i][1]);\\n        }\\n        return merged;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    static int comp(vector<int> a, vector<int> b){\\n        return a[0]<b[0];\\n    }\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int n=intervals.size();\\n        vector<vector<int>> merged;\\n        if (n==0) return merged;\\n        for (int i=0;i<n;i++) {\\n            if (merged.empty() || merged.back()[1]<intervals[i][0])\\n                merged.push_back(intervals[i]);\\n            else\\n                merged.back()[1]=max(merged.back()[1], intervals[i][1]);\\n        }\\n        return merged;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21305,
                "title": "c-sort-by-start-simple-5-lines",
                "content": "Iterate over the array sorted by start and compare the start of each element to the end of the last item on your output.  Either extend the last element of the output or add a new element to the output.\\n\\n```\\n    public IList<Interval> Merge(IList<Interval> intervals) \\n    {\\n        IList<Interval> res = new List<Interval>();\\n        foreach (Interval curr in intervals.OrderBy(x => x.start))\\n        {\\n            if (res.Count == 0 || res[res.Count-1].end < curr.start) res.Add(new Interval(curr.start, curr.end));\\n            else res[res.Count-1].end = Math.Max(res[res.Count-1].end, curr.end);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<Interval> Merge(IList<Interval> intervals) \\n    {\\n        IList<Interval> res = new List<Interval>();\\n        foreach (Interval curr in intervals.OrderBy(x => x.start))\\n        {\\n            if (res.Count == 0 || res[res.Count-1].end < curr.start) res.Add(new Interval(curr.start, curr.end));\\n            else res[res.Count-1].end = Math.Max(res[res.Count-1].end, curr.end);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21359,
                "title": "clean-treeset-solution-in-java",
                "content": "```\\npublic class Solution {\\n    public List<Interval> merge(List<Interval> intervals) {\\n        \\n        TreeSet<Interval> tree = new TreeSet<Interval>(new Comparator<Interval>() {\\n            @Override\\n            public int compare(Interval i1, Interval i2) {\\n                if (i1.end < i2.start) return -1;\\n                else if (i1.start > i2.end) return 1;\\n                else return 0;\\n            }\\n        });\\n        \\n        for (Interval i: intervals) {\\n            while (tree.contains(i)) {\\n                Interval x = tree.ceiling(i);\\n                tree.remove(x);\\n                i = new Interval(Math.min(i.start, x.start), Math.max(i.end, x.end));\\n            }\\n            tree.add(i);\\n        }\\n        \\n        return new ArrayList<Interval>(tree);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Interval> merge(List<Interval> intervals) {\\n        \\n        TreeSet<Interval> tree = new TreeSet<Interval>(new Comparator<Interval>() {\\n            @Override\\n            public int compare(Interval i1, Interval i2) {\\n                if (i1.end < i2.start) return -1;\\n                else if (i1.start > i2.end) return 1;\\n                else return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 21485,
                "title": "concise-python-code-easy-understanding",
                "content": "\\n\\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            intervals = sorted(intervals, key=lambda interval:interval.start)\\n            result = []\\n            interval, l = intervals[0], len(intervals)\\n            for i in range(1, l):\\n                interval2 = intervals[i]\\n                if interval2.start > interval.end:\\n                    result.append(interval)\\n                    interval = interval2\\n                else:\\n                    interval.end = max\\uff08interval.end, interval2.end)\\n            \\n            result.append(interval)\\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            intervals = sorted(intervals, key=lambda interval:interval.start)\\n            result = []\\n            interval, l = intervals[0], len(intervals)\\n            for i in range(1, l):\\n                interval2 = intervals[i]\\n                if interval2.start > interval.end:\\n                    result.append(interval)\\n                    interval = interval2\\n                else:\\n                    interval.end = max\\uff08interval.end, interval2.end)\\n            \\n            result.append(interval)\\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 21551,
                "title": "sort-function-problems",
                "content": "I use the sort function to sort the starting points of all intervals,\\n\\n    sort(intervals.begin(),intervals.end(),compareInterval); \\n\\nHowever, when I am trying to use\\n\\n    bool compareInterval(Interval a, Interval b)\\n    {\\n        return (a.start<=b.start);\\n    }\\n\\nthe compiler outputs some Runtime error, however, the compiler accepts the code if I use\\n\\n    bool compareInterval(Interval a, Interval b)\\n    {\\n        return (a.start<b.start);\\n    }\\n\\nany genius here have some ideas?",
                "solutionTags": [],
                "code": "I use the sort function to sort the starting points of all intervals,\\n\\n    sort(intervals.begin(),intervals.end(),compareInterval); \\n\\nHowever, when I am trying to use\\n\\n    bool compareInterval(Interval a, Interval b)\\n    {\\n        return (a.start<=b.start);\\n    }\\n\\nthe compiler outputs some Runtime error, however, the compiler accepts the code if I use\\n\\n    bool compareInterval(Interval a, Interval b)\\n    {\\n        return (a.start<b.start);\\n    }\\n\\nany genius here have some ideas?",
                "codeTag": "Unknown"
            },
            {
                "id": 3908055,
                "title": "easy-c-solution-using-sorting-basic-approach-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& nums) {\\n       vector<vector<int>>v;\\n       int start;\\n       int end;\\n       int i;\\n        sort(nums.begin(), nums.end(), [](const vector<int>& a, const vector<int>& b) {\\n           return a[0] < b[0];\\n       });\\n       \\n       for( i=0;i<nums.size();i++)\\n       {\\n           int start=nums[i][0];\\n           int end=nums[i][1]; \\n            while(i!=nums.size()-1 && end>=nums[i+1][0])\\n           {\\n               end= max(end,nums[i+1][1]);\\n               i++;\\n           }\\n           \\n           \\n           vector<int> temp={start,end};\\n           v.push_back(temp);\\n       } \\n       return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& nums) {\\n       vector<vector<int>>v;\\n       int start;\\n       int end;\\n       int i;\\n        sort(nums.begin(), nums.end(), [](const vector<int>& a, const vector<int>& b) {\\n           return a[0] < b[0];\\n       });\\n       \\n       for( i=0;i<nums.size();i++)\\n       {\\n           int start=nums[i][0];\\n           int end=nums[i][1]; \\n            while(i!=nums.size()-1 && end>=nums[i+1][0])\\n           {\\n               end= max(end,nums[i+1][1]);\\n               i++;\\n           }\\n           \\n           \\n           vector<int> temp={start,end};\\n           v.push_back(temp);\\n       } \\n       return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760303,
                "title": "fast-solution-beats-99-simple-code-self-explanatory-with-comments",
                "content": "Solution:\\n\\n    class Solution(object):\\n\\n        def merge(self, intervals):\\n            \\n            #sort the intervals\\n            intervals.sort()\\n\\n            #base case \\n            if len(intervals)==1:\\n                return intervals\\n\\n            #the answer array\\n            ans = [intervals[0]]\\n            for i in range(1, len(intervals)):\\n\\n                #if the intervals are non overlapping \\n                if intervals[i][0]>ans[-1][1]:\\n                    ans.append(intervals[i])\\n\\n                #if two intervals overlap\\n                else:\\n                    new = [min(intervals[i][0], ans[-1][0]), max(intervals[i][1], ans[-1][1])]\\n                    ans.pop()\\n                    ans.append(new)\\n\\n            return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Solution:\\n\\n    class Solution(object):\\n\\n        def merge(self, intervals):\\n            \\n            #sort the intervals\\n            intervals.sort()\\n\\n            #base case \\n            if len(intervals)==1:\\n                return intervals\\n\\n            #the answer array\\n            ans = [intervals[0]]\\n            for i in range(1, len(intervals)):\\n\\n                #if the intervals are non overlapping \\n                if intervals[i][0]>ans[-1][1]:\\n                    ans.append(intervals[i])\\n\\n                #if two intervals overlap\\n                else:\\n                    new = [min(intervals[i][0], ans[-1][0]), max(intervals[i][1], ans[-1][1])]\\n                    ans.pop()\\n                    ans.append(new)\\n\\n            return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2964594,
                "title": "c-easy-to-understand-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, two array will be taken arr1 for all intervals[i][0]\\nand second array arr2 for all intervals[i][1] then sortboth of them.Therefore, only one condition in for loop: if arr2[i]<arr2[i+1]...\\n\\nKindly like this solution if you are able to understand.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>>ans;\\n        vector<int>res;\\n        vector<int>arr1;\\n        vector<int>arr2;\\n        for(int i =0;i<intervals.size();i++){\\n            arr1.push_back(intervals[i][0]);\\n            arr2.push_back(intervals[i][1]);\\n        }\\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n\\nres.push_back(arr1[0]);\\nfor(int i =0;i<intervals.size()-1;i++){\\nif(arr2[i]<arr1[i+1]){\\nres.push_back(arr2[i]);\\nans.push_back(res);\\nres.clear();\\nres.push_back(arr1[i+1]);\\n}\\n}\\nres.push_back(arr2[arr2.size()-1]);\\nans.push_back(res);\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>>ans;\\n        vector<int>res;\\n        vector<int>arr1;\\n        vector<int>arr2;\\n        for(int i =0;i<intervals.size();i++){\\n            arr1.push_back(intervals[i][0]);\\n            arr2.push_back(intervals[i][1]);\\n        }\\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n\\nres.push_back(arr1[0]);\\nfor(int i =0;i<intervals.size()-1;i++){\\nif(arr2[i]<arr1[i+1]){\\nres.push_back(arr2[i]);\\nans.push_back(res);\\nres.clear();\\nres.push_back(arr1[i+1]);\\n}\\n}\\nres.push_back(arr2[arr2.size()-1]);\\nans.push_back(res);\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951764,
                "title": "python-simple-solution",
                "content": "# Approach\\nSort by the start of the interval. Then check if the end of an interval is equal to or greater than the start of the next interval. If yes merge it, and remove that interval, otherwise continue. Return the array after parsing through.\\n\\n# Complexity\\n- Time complexity: O(n * logn)\\n\\n- Space complexity: O(1)?\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x: x[0])\\n        index = 0\\n        while index < len(intervals)-1:\\n            if intervals[index][1] >= intervals[index+1][0]:\\n                intervals[index][1] = max(intervals[index+1][1],intervals[index][1])\\n                intervals.remove(intervals[index+1])\\n            else:\\n                index += 1\\n        return intervals\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x: x[0])\\n        index = 0\\n        while index < len(intervals)-1:\\n            if intervals[index][1] >= intervals[index+1][0]:\\n                intervals[index][1] = max(intervals[index+1][1],intervals[index][1])\\n                intervals.remove(intervals[index+1])\\n            else:\\n                index += 1\\n        return intervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856777,
                "title": "easy-and-swift-python-solution",
                "content": "- Sort the array based on the order of first element.\\n- Check if the second element of each nested array is within the range of prev array.\\n- Combine the arrays if necessary.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if intervals == []:\\n            return\\n        \\n        intervals.sort(key = lambda x: x[0])\\n        res = [intervals[0]]\\n        \\n        for i in range(1, len(intervals)):\\n\\n            if intervals[i][0] <= res[-1][1]:\\n                res[-1][1] = max(intervals[i][1], res[-1][1])\\n                continue\\n            \\n            res.append(intervals[i])\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if intervals == []:\\n            return\\n        \\n        intervals.sort(key = lambda x: x[0])\\n        res = [intervals[0]]\\n        \\n        for i in range(1, len(intervals)):\\n\\n            if intervals[i][0] <= res[-1][1]:\\n                res[-1][1] = max(intervals[i][1], res[-1][1])\\n                continue\\n            \\n            res.append(intervals[i])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773288,
                "title": "python-solution-onlogn",
                "content": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x: (x[0]))\\n        mergedIntervals = []\\n        mergedIntervalIndex = 0\\n        mergedIntervals.append(intervals[0])\\n        for i in range(1,len(intervals)):\\n            currentInterval = intervals[i]\\n            currentMergedInterval = mergedIntervals[mergedIntervalIndex]\\n            if currentInterval[0] <= currentMergedInterval[1] and currentInterval[1] >= currentMergedInterval[0]:\\n                mergedIntervals[mergedIntervalIndex] = [min(currentMergedInterval[0], currentInterval[0]), max(currentInterval[1], currentMergedInterval[1])]\\n            else:\\n                mergedIntervals.append(currentInterval)\\n                mergedIntervalIndex += 1\\n        return mergedIntervals\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x: (x[0]))\\n        mergedIntervals = []\\n        mergedIntervalIndex = 0\\n        mergedIntervals.append(intervals[0])\\n        for i in range(1,len(intervals)):\\n            currentInterval = intervals[i]\\n            currentMergedInterval = mergedIntervals[mergedIntervalIndex]\\n            if currentInterval[0] <= currentMergedInterval[1] and currentInterval[1] >= currentMergedInterval[0]:\\n                mergedIntervals[mergedIntervalIndex] = [min(currentMergedInterval[0], currentInterval[0]), max(currentInterval[1], currentMergedInterval[1])]\\n            else:\\n                mergedIntervals.append(currentInterval)\\n                mergedIntervalIndex += 1\\n        return mergedIntervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726014,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n\\t\\tint n=intervals.size();\\n        vector<vector<int>>ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<n;i++){\\n            if(ans[ans.size()-1][1]<intervals[i][0]){\\n                ans.push_back(intervals[i]);\\n            }\\n            else{\\n                ans[ans.size()-1][1]=max(ans[ans.size()-1][1],intervals[i][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n\\t\\tint n=intervals.size();\\n        vector<vector<int>>ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<n;i++){\\n            if(ans[ans.size()-1][1]<intervals[i][0]){\\n                ans.push_back(intervals[i]);\\n            }\\n            else{\\n                ans[ans.size()-1][1]=max(ans[ans.size()-1][1],intervals[i][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2664674,
                "title": "90-time-beats-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intr) {\\n        sort(intr.begin(),intr.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intr[0]);\\n        for(int i = 1; i < intr.size(); i++){\\n            if(intr[i][0]>ans[ans.size()-1][1]){\\n                ans.push_back(intr[i]);\\n            }else{\\n                ans[ans.size()-1][1] = max(intr[i][1],ans[ans.size()-1][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intr) {\\n        sort(intr.begin(),intr.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intr[0]);\\n        for(int i = 1; i < intr.size(); i++){\\n            if(intr[i][0]>ans[ans.size()-1][1]){\\n                ans.push_back(intr[i]);\\n            }else{\\n                ans[ans.size()-1][1] = max(intr[i][1],ans[ans.size()-1][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538215,
                "title": "c-easy-to-understand-solution-95-faster",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> merge(vector<vector<int>>& arr) {\\n\\t\\t\\tsort(arr.begin(),arr.end());\\n\\t\\t\\tvector<vector<int>> ans = {arr[0]};\\n\\t\\t\\tfor(int i = 0 ; i < arr.size() ; i++){\\n\\t\\t\\t\\tint s = arr[i][0] , e = arr[i][1];\\n\\t\\t\\t\\tint as = ans[ans.size()-1][0] , ae = ans[ans.size()-1][1];\\n\\t\\t\\t\\tif(as <= s and s <= ae) {\\n\\t\\t\\t\\t\\tans[ans.size()-1][1] = max(e,ae); \\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tans.push_back({s,e});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> merge(vector<vector<int>>& arr) {\\n\\t\\t\\tsort(arr.begin(),arr.end());\\n\\t\\t\\tvector<vector<int>> ans = {arr[0]}",
                "codeTag": "Java"
            },
            {
                "id": 2516355,
                "title": "c-8-line-simplest-solution-with-linear-time-complexity",
                "content": "Hey Guys,\\nHope you all are doing well!\\nIn this post, I\\'ve provided one of the easiest approach to merge all overlapping intervals in a given array.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        vector<vector<int>>ans;\\n        sort(v.begin(),v.end());\\n        for(int i=0; i<v.size(); i++){\\n            if(ans.size()==0 || v[i][0]>ans.back()[1])\\n                ans.push_back(v[i]);\\n            else ans.back()[1]=max(ans.back()[1],v[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\nPlease upvote if you found the solution useful.\\nHappy Coding!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        vector<vector<int>>ans;\\n        sort(v.begin(),v.end());\\n        for(int i=0; i<v.size(); i++){\\n            if(ans.size()==0 || v[i][0]>ans.back()[1])\\n                ans.push_back(v[i]);\\n            else ans.back()[1]=max(ans.back()[1],v[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375726,
                "title": "a-simple-c-solution",
                "content": "**Runtime: 24 ms, faster than 99.96% of C++ online submissions for Merge Intervals.\\nMemory Usage: 19.1 MB, less than 44.98% of C++ online submissions for Merge Intervals.**\\n```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\tsort(intervals.begin(),intervals.end());\\n\\tvector<vector<int>> ans;\\n\\tint start=intervals[0][0],end=intervals[0][1];\\n\\tfor(int i=1;i<intervals.size();i++){\\n\\t\\tif(intervals[i][0]<=end){\\n\\t\\t\\tend=max(end,intervals[i][1]);\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tans.push_back({start,end});\\n\\t\\t\\tstart=intervals[i][0],end=intervals[i][1];\\n\\t\\t}\\n\\t}\\n\\tans.push_back({start,end});\\n\\treturn ans;\\n}\\n```\\n\\nKeep Coding.\\nPlease do Upvote.",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\tsort(intervals.begin(),intervals.end());\\n\\tvector<vector<int>> ans;\\n\\tint start=intervals[0][0],end=intervals[0][1];\\n\\tfor(int i=1;i<intervals.size();i++){\\n\\t\\tif(intervals[i][0]<=end){\\n\\t\\t\\tend=max(end,intervals[i][1]);\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tans.push_back({start,end});\\n\\t\\t\\tstart=intervals[i][0],end=intervals[i][1];\\n\\t\\t}\\n\\t}\\n\\tans.push_back({start,end});\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329982,
                "title": "interview-ready-with-explanation",
                "content": "```\\nclass Solution {\\n    //Time: O(n log n) for sorting the given intervals\\n    //Space O(n) where n represent the length of given intervals\\n    public int[][] merge(int[][] intervals) {\\n\\t\\t//Edge case\\n\\t\\tif(intervals.length == 1) return intervals;\\n\\t\\n        //sort by intervals start time\\n        Arrays.sort(intervals, (a,b)-> a[0] - b[0]);\\n        \\n        //create a list of int[]\\n        List<int[]> result = new ArrayList<>();\\n        \\n        //get the first interval from intervals\\n        int aStart = intervals[0][0],\\n            aEnd = intervals[0][1];\\n        \\n        //loop through the rest of intervals\\n        for(int i = 1; i < intervals.length; i++){\\n            //if b.Start <= aEnd meaning it is overlapping\\n            if(intervals[i][0] <= aEnd){\\n                //find the new max\\n                aEnd = Math.max(aEnd, intervals[i][1]);\\n            }\\n            else{\\n                //if not add it to the result and change the a.start and a.end\\n                result.add(new int[]{aStart, aEnd});\\n                aStart = intervals[i][0];\\n                aEnd = intervals[i][1];\\n            }\\n        }\\n        \\n        //add the last values\\n        result.add(new int[]{aStart, aEnd});\\n        \\n        //return the result\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    //Time: O(n log n) for sorting the given intervals\\n    //Space O(n) where n represent the length of given intervals\\n    public int[][] merge(int[][] intervals) {\\n\\t\\t//Edge case\\n\\t\\tif(intervals.length == 1) return intervals;\\n\\t\\n        //sort by intervals start time\\n        Arrays.sort(intervals, (a,b)-> a[0] - b[0]);\\n        \\n        //create a list of int[]\\n        List<int[]> result = new ArrayList<>();\\n        \\n        //get the first interval from intervals\\n        int aStart = intervals[0][0],\\n            aEnd = intervals[0][1];\\n        \\n        //loop through the rest of intervals\\n        for(int i = 1; i < intervals.length; i++){\\n            //if b.Start <= aEnd meaning it is overlapping\\n            if(intervals[i][0] <= aEnd){\\n                //find the new max\\n                aEnd = Math.max(aEnd, intervals[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2274410,
                "title": "beginner-friendly-javascript-python-solution",
                "content": "**Time Complexity : O(n)**\\n**JavaScript**\\n```\\nvar merge = function(intervals) {\\n    intervals.sort((a,b) => a[0] - b[0])\\n    let merged = [], len = 0\\n    for(let i of intervals){\\n        if(merged.length > 0 && merged[len-1][1] >= i[0]){\\n            merged[len-1][1] = Math.max(merged[len-1][1], i[1])\\n        }else{\\n            merged.push(i)\\n            len++\\n        }\\n    }\\n    return merged\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        intervals.sort()\\n        merged = []\\n        n = 0\\n        for i in intervals:\\n            if len(merged) > 0 and merged[n-1][1] >= i[0]:\\n                merged[n-1][1] = max(merged[n-1][1], i[1])\\n            else:\\n                merged.append(i)\\n                n += 1\\n        return merged\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n    intervals.sort((a,b) => a[0] - b[0])\\n    let merged = [], len = 0\\n    for(let i of intervals){\\n        if(merged.length > 0 && merged[len-1][1] >= i[0]){\\n            merged[len-1][1] = Math.max(merged[len-1][1], i[1])\\n        }else{\\n            merged.push(i)\\n            len++\\n        }\\n    }\\n    return merged\\n};\\n```\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        intervals.sort()\\n        merged = []\\n        n = 0\\n        for i in intervals:\\n            if len(merged) > 0 and merged[n-1][1] >= i[0]:\\n                merged[n-1][1] = max(merged[n-1][1], i[1])\\n            else:\\n                merged.append(i)\\n                n += 1\\n        return merged\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105757,
                "title": "simple-javascript",
                "content": "Hi,\\nhere is my javascript solution.\\n\\n```\\nvar merge = function(intervals) {\\n    intervals.sort((a,b) => a[0] - b[0]);\\n    const results = [];\\n    for(let interval of intervals) {\\n        const prev = results.at(-1);\\n        if (!results.length || prev[1] < interval[0]) {\\n            results.push(interval);\\n        } else {\\n            prev[1] = Math.max(prev[1], interval[1])\\n        }\\n    }\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n    intervals.sort((a,b) => a[0] - b[0]);\\n    const results = [];\\n    for(let interval of intervals) {\\n        const prev = results.at(-1);\\n        if (!results.length || prev[1] < interval[0]) {\\n            results.push(interval);\\n        } else {\\n            prev[1] = Math.max(prev[1], interval[1])\\n        }\\n    }\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2025008,
                "title": "easy-c-sorting-o-nlogn",
                "content": "***DO UPVOTE IF IT HELPS!!!!***\\n\\n\\tvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        vector<vector<int>> ans;\\n        int n=intervals.size();\\n               \\n        int res=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<=intervals[res][1]){\\n                intervals[res][0]=min (intervals[res][0],intervals[i][0]);\\n                intervals[res][1]=max(intervals[res][1],intervals[i][1]);\\n            }\\n            else{\\n                res++;\\n                intervals[res]=intervals[i];\\n            }\\n        }\\n        \\n        for(int i=0;i<=res;i++){\\n            ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "***DO UPVOTE IF IT HELPS!!!!***\\n\\n\\tvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        vector<vector<int>> ans;\\n        int n=intervals.size();\\n               \\n        int res=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<=intervals[res][1]){\\n                intervals[res][0]=min (intervals[res][0],intervals[i][0]);\\n                intervals[res][1]=max(intervals[res][1],intervals[i][1]);\\n            }\\n            else{\\n                res++;\\n                intervals[res]=intervals[i];\\n            }\\n        }\\n        \\n        for(int i=0;i<=res;i++){\\n            ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1996645,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int lengthOfIntervals = intervals.size();\\n\\t\\tif(lengthOfIntervals == 0)return {{}};\\n\\n\\t\\tsort(intervals.begin(),intervals.end(),[](vector<int> firstInterval, vector<int> secondInterval){\\n\\t\\t\\treturn firstInterval[0]<secondInterval[0];\\n\\t\\t});\\n\\n\\t\\tvector<vector<int>> mergedIntervals;\\n\\t\\tmergedIntervals.push_back(intervals[0]);\\t\\n\\n\\t\\tfor(int i = 1;i<lengthOfIntervals;i++){\\n\\t\\t\\tvector<int> lastPushedIntervalInTheResult = mergedIntervals.back();\\n\\t\\t\\tif(intervals[i][0]>lastPushedIntervalInTheResult[1])\\n\\t\\t\\t\\tmergedIntervals.push_back(intervals[i]);\\n\\t\\t\\telse{\\n\\t\\t\\t\\tmergedIntervals.back()[1] = max(mergedIntervals.back()[1],intervals[i][1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn mergedIntervals;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int lengthOfIntervals = intervals.size();\\n\\t\\tif(lengthOfIntervals == 0)return {{}};\\n\\n\\t\\tsort(intervals.begin(),intervals.end(),[](vector<int> firstInterval, vector<int> secondInterval){\\n\\t\\t\\treturn firstInterval[0]<secondInterval[0];\\n\\t\\t});\\n\\n\\t\\tvector<vector<int>> mergedIntervals;\\n\\t\\tmergedIntervals.push_back(intervals[0]);\\t\\n\\n\\t\\tfor(int i = 1;i<lengthOfIntervals;i++){\\n\\t\\t\\tvector<int> lastPushedIntervalInTheResult = mergedIntervals.back();\\n\\t\\t\\tif(intervals[i][0]>lastPushedIntervalInTheResult[1])\\n\\t\\t\\t\\tmergedIntervals.push_back(intervals[i]);\\n\\t\\t\\telse{\\n\\t\\t\\t\\tmergedIntervals.back()[1] = max(mergedIntervals.back()[1],intervals[i][1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn mergedIntervals;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966180,
                "title": "c-simple-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    //compartor for sorting the intervals\\n    static bool compare(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0]){\\n            return a[1]<b[1];\\n        }\\n        return a[0]<b[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& nums) {\\n        sort(nums.begin(),nums.end(),compare);\\n        // sorting the intervals\\n        vector<vector<int>> res;\\n        res.push_back(nums[0]);\\n        // pushing 1st interval to result\\n        for(int i=1;i<nums.size();i++){\\n            // checking if current interval overlaps with last interval\\n            if(res[res.size()-1][1] >= nums[i][0]){\\n\\t\\t\\t\\t// we just update out interval\\n\\t\\t\\t\\t// y here should be there larger of 2 intervals\\n                res[res.size()-1][1]=max(res[res.size()-1][1],nums[i][1]);\\n            }else{\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nUpvote if you found it helpful.",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //compartor for sorting the intervals\\n    static bool compare(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0]){\\n            return a[1]<b[1];\\n        }\\n        return a[0]<b[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& nums) {\\n        sort(nums.begin(),nums.end(),compare);\\n        // sorting the intervals\\n        vector<vector<int>> res;\\n        res.push_back(nums[0]);\\n        // pushing 1st interval to result\\n        for(int i=1;i<nums.size();i++){\\n            // checking if current interval overlaps with last interval\\n            if(res[res.size()-1][1] >= nums[i][0]){\\n\\t\\t\\t\\t// we just update out interval\\n\\t\\t\\t\\t// y here should be there larger of 2 intervals\\n                res[res.size()-1][1]=max(res[res.size()-1][1],nums[i][1]);\\n            }else{\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846983,
                "title": "simple-kotlin-solution-with-explanation",
                "content": "Here is a simple Kotlin solution.\\nThe logic is simple.\\n1. Sort the intervals using the start value (O(NlogN))\\n2. Loop through the array of intervals (O(N))\\n3. Given an interval, \\n   1) no overlap case - if the start value is greater than end value of the last `result` interval then add the interval to `result `\\n   2) overlap case -  just get the Max end value of a) last `result` interval or b) the current interval (this covers edge case where current interval falls within the last `result` interval)\\n\\n* checking result is empty is a special case for 1) no overlap\\n\\n```kotlin\\nfun mergeIntervals2(intervals: Array<IntArray>): Array<IntArray> {\\n        intervals.sortBy{ it[0] }\\n        val result = mutableListOf<IntArray>()\\n        intervals.forEach{\\n            if(result.isEmpty() || result.last()[1] < it[0]) {\\n                result.add(it)\\n            } else {\\n                result.last()[1] = maxOf(result.last()[1], it[1])\\n            }\\n        }\\n        return result.toTypedArray()\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nfun mergeIntervals2(intervals: Array<IntArray>): Array<IntArray> {\\n        intervals.sortBy{ it[0] }\\n        val result = mutableListOf<IntArray>()\\n        intervals.forEach{\\n            if(result.isEmpty() || result.last()[1] < it[0]) {\\n                result.add(it)\\n            } else {\\n                result.last()[1] = maxOf(result.last()[1], it[1])\\n            }\\n        }\\n        return result.toTypedArray()\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1573219,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1849602,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1575835,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566121,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566835,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566131,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1574619,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576565,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568394,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565574,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1573219,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1849602,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1575835,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566121,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566835,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566131,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1574619,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576565,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568394,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565574,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1573399,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1573375,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1572372,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1571138,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1571139,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 2001699,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1758109,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1734797,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1572810,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1571140,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1567581,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2076035,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2052436,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2037298,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2037269,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2032857,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2001692,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 1980319,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 1964672,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 1959146,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 1952091,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1922819,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1915199,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1898059,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1887702,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1885784,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1844220,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1807815,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1807019,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1804679,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1801156,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1799815,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1791113,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1791112,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1775220,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1766551,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1755485,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1742517,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1738835,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1735110,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1729146,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1720918,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1714398,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1710364,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1707869,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1707650,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1680562,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1648697,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1637633,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1631126,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Upside Down",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1575643,
                "content": [
                    {
                        "username": "elangovan911",
                        "content": "Am I missing something in this problem? the description says \"it is guaranteed that every node in the given tree has either 0 or 2 children.\" but the 3rd test case is [1,2]!!! Where is the right child and why does the root node get to have only one child? Also, there is no clear description given that says ignore the right subtree from this rearrangement. for the testcase of [1,2,3,4,5,6,7,8,9,10] i would expect 10 to become the root of 5 at the end but the final solution tree is same as original i.e. 5 is still the root of 10."
                    },
                    {
                        "username": "siulungdlaw",
                        "content": "The question is ambiguous.\n\nIn the case where the tree is \n1\n2, 3\n4,5, 6, 7\nThen what is parent of 3 after the transformation?\nOn one hand, 2 is supposed the parent because it is the right child of 1.\nOn the other hand, 6 is supposed the parent because 6 is the left child of 3.\n\n\n\n"
                    }
                ]
            },
            {
                "id": 1756545,
                "content": [
                    {
                        "username": "elangovan911",
                        "content": "Am I missing something in this problem? the description says \"it is guaranteed that every node in the given tree has either 0 or 2 children.\" but the 3rd test case is [1,2]!!! Where is the right child and why does the root node get to have only one child? Also, there is no clear description given that says ignore the right subtree from this rearrangement. for the testcase of [1,2,3,4,5,6,7,8,9,10] i would expect 10 to become the root of 5 at the end but the final solution tree is same as original i.e. 5 is still the root of 10."
                    },
                    {
                        "username": "siulungdlaw",
                        "content": "The question is ambiguous.\n\nIn the case where the tree is \n1\n2, 3\n4,5, 6, 7\nThen what is parent of 3 after the transformation?\nOn one hand, 2 is supposed the parent because it is the right child of 1.\nOn the other hand, 6 is supposed the parent because 6 is the left child of 3.\n\n\n\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Paint House",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1564574,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1569675,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1576970,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1574974,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1571998,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1968722,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1921476,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            }
        ]
    }
]