[
    {
        "title": "Binary Tree Tilt",
        "question_content": "Given the root of a binary tree, return the sum of every tree node's tilt.\nThe tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values. If a node does not have a left child, then the sum of the left subtree node values is treated as 0. The rule is similar if the node does not have a right child.\n&nbsp;\nExample 1:\n\nInput: root = [1,2,3]\nOutput: 1\nExplanation: \nTilt of node 2 : |0-0| = 0 (no children)\nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\nSum of every tilt : 0 + 0 + 1 = 1\n\nExample 2:\n\nInput: root = [4,2,9,3,5,null,7]\nOutput: 15\nExplanation: \nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 5 : |0-0| = 0 (no children)\nTilt of node 7 : |0-0| = 0 (no children)\nTilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)\nTilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)\nTilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)\nSum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15\n\nExample 3:\n\nInput: root = [21,7,14,1,1,2,2,3,3]\nOutput: 9\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [0, 104].\n\t-1000 <= Node.val <= 1000",
        "solutions": [
            {
                "id": 102334,
                "title": "java-solution-post-order-traversal",
                "content": "```\\npublic class Solution {\\n    int result = 0;\\n    \\n    public int findTilt(TreeNode root) {\\n        postOrder(root);\\n        return result;\\n    }\\n    \\n    private int postOrder(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        int left = postOrder(root.left);\\n        int right = postOrder(root.right);\\n        \\n        result += Math.abs(left - right);\\n        \\n        return left + right + root.val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int result = 0;\\n    \\n    public int findTilt(TreeNode root) {\\n        postOrder(root);\\n        return result;\\n    }\\n    \\n    private int postOrder(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        int left = postOrder(root.left);\\n        int right = postOrder(root.right);\\n        \\n        result += Math.abs(left - right);\\n        \\n        return left + right + root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102321,
                "title": "python-simple-with-explanation",
                "content": "If we had each node's subtree sum, our answer would look like this psuedocode:  ```for each node: ans += abs(node.left.subtreesum - node.right.subtreesum)```.  Let ```_sum(node)``` be the node's subtree sum.  We can find it by adding the subtree sum of the left child, plus the subtree sum of the right child, plus the node's value.  While we are visiting the node (each node is visited exactly once), we might as well do the ```ans += abs(left_sum - right_sum)``` part.\\n```\\ndef findTilt(self, root):\\n    self.ans = 0\\n    def _sum(node):\\n        if not node: return 0\\n        left, right = _sum(node.left), _sum(node.right)\\n        self.ans += abs(left - right)\\n        return node.val + left + right\\n    _sum(root)\\n    return self.ans\\n```",
                "solutionTags": [],
                "code": "```for each node: ans += abs(node.left.subtreesum - node.right.subtreesum)```\n```_sum(node)```\n```ans += abs(left_sum - right_sum)```\n```\\ndef findTilt(self, root):\\n    self.ans = 0\\n    def _sum(node):\\n        if not node: return 0\\n        left, right = _sum(node.left), _sum(node.right)\\n        self.ans += abs(left - right)\\n        return node.val + left + right\\n    _sum(root)\\n    return self.ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1617503,
                "title": "c-python-simple-solution-w-explanation-post-order-dfs-traversal",
                "content": "We are given a binary tree and we need to return sum of tilts of all nodes in the tree. A tilt is absolute difference between sum of left & right subtree.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (PostOrder DFS)***\\n\\nTo calculate the tilt of a node, we require the sum of its left and right subtrees. We can perform a simple DFS traversal which returns the sum of subtree starting at a given node. Thus, we can call DFS on left & right child nodes to get left & right subtree sums respectively and the tilt of current node would be absolute difference between these sum.\\n\\nMoreover, since we need to sum of tilts of each node, instead of doing this separately for each node which would lead to <code>O(N<sup>2</sup>)</code>, we can do it in a single recursive call starting at `root`. In every `dfs(node)` call, \\n* We recurse & get `leftSum = dfs(node->left)` & `rightSum = dfs(node->right)` which is sum of left & right subtree respectively. \\n* The tilt of current node `abs(leftSum - rightSum)` is added to a global variable `tiltSum`.\\n* Finally, we return `leftSum + rightSum + root -> val` which ensures that current DFS call returns sum of subtree rooted at `node` & thus this process can be recursively carried out all the way up till root node.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int tiltSum = 0;\\n    int findTilt(TreeNode* root) {\\n        DFS(root);\\n        return tiltSum;\\n    }\\n    int DFS(TreeNode* root) {\\n        if(!root) return 0;\\n        int leftSum = DFS(root -> left);                // sum of left subtree\\n        int rightSum = DFS(root -> right);              // sum of right subtree\\n        tiltSum += abs(leftSum - rightSum);             // add tilt of current node to overall tiltSum\\n        return leftSum + rightSum + root -> val;        // returns sum of subtree starting at \\'root\\'\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def findTilt(self, root):\\n        self.tilt_sum = 0\\n        def DFS(root):\\n            if not root: return 0\\n            left_sum, right_sum = DFS(root.left), DFS(root.right)\\n            self.tilt_sum += abs(left_sum - right_sum)\\n            return left_sum + right_sum + root.val\\n        DFS(root)\\n        return self.tilt_sum\\n```\\n\\n\\n***Time Complexity :*** <code>O(N)</code>, where `N` is the number of nodes in the given tree. We are traversing over each ndoe of the tree only once\\n***Space Complexity :*** `O(H)`, required for recursive stack. In case of skewed tree, this would be `O(N)`, while in case of balanced tree, this would be `O(logN)`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int tiltSum = 0;\\n    int findTilt(TreeNode* root) {\\n        DFS(root);\\n        return tiltSum;\\n    }\\n    int DFS(TreeNode* root) {\\n        if(!root) return 0;\\n        int leftSum = DFS(root -> left);                // sum of left subtree\\n        int rightSum = DFS(root -> right);              // sum of right subtree\\n        tiltSum += abs(leftSum - rightSum);             // add tilt of current node to overall tiltSum\\n        return leftSum + rightSum + root -> val;        // returns sum of subtree starting at \\'root\\'\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findTilt(self, root):\\n        self.tilt_sum = 0\\n        def DFS(root):\\n            if not root: return 0\\n            left_sum, right_sum = DFS(root.left), DFS(root.right)\\n            self.tilt_sum += abs(left_sum - right_sum)\\n            return left_sum + right_sum + root.val\\n        DFS(root)\\n        return self.tilt_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102369,
                "title": "python-straightforward-solution",
                "content": "Think about a recursive function. Beside the tilt of subtrees, we also need to get the sum of subtrees. \\nSo I came up with the idea of sub function ````tilt(root)````, which returns the tuple  ````(sum, tilt)```` of tree\\n```````\\ndef findTilt(self, root):\\n        def tilt(root):\\n            # return (sum, tilt) of tree\\n            if not root: return (0, 0)\\n            left = tilt(root.left)\\n            right = tilt(root.right)\\n            return (left[0] + right[0] + root.val, abs(left[0] - right[0]) + left[1] + right[1])\\n        return tilt(root)[1]",
                "solutionTags": [],
                "code": "````tilt(root)```\n````(sum, tilt)```\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 927899,
                "title": "python-short-dfs-solution-explained",
                "content": "Just traverse tree, using `dfs`, where we keep two values: sum of all tilts of current subtree and sum of nodes in current subtree. Then:\\n\\n1. If we in `None` node, we return `[0, 0]`: we do nat have any subtree and tilt.\\n2. Let `t1, s1` be tilt and sum of nodef for left subtree and `t2, s2` for right subtree. Then how we can ealuate final sum of tilts for given node: it is `abs(s1-s2)` plus tilts for its children. To evaluate sum of all values in subtree we just need to evaluate `s1+s2+node.val`.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(h)`.\\n\\n```\\nclass Solution:\\n    def findTilt(self, root):\\n        def dfs(node):\\n            if not node: return [0,0]\\n            t1, s1 = dfs(node.left)\\n            t2, s2 = dfs(node.right)\\n            return [t1+t2+abs(s1-s2), s1+s2+node.val]\\n        return dfs(root)[0]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root):\\n        def dfs(node):\\n            if not node: return [0,0]\\n            t1, s1 = dfs(node.left)\\n            t2, s2 = dfs(node.right)\\n            return [t1+t2+abs(s1-s2), s1+s2+node.val]\\n        return dfs(root)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617477,
                "title": "c-easy-to-solve-solution-beginner-friendly-algo-with-detailed-explanations",
                "content": "**Depressed doge digging algortihm || DFS Algorithm  :** \\n\\nAfter reading this question, the first intuition that we get is that we have to use depth first search for digging the depths of the tree i.e for finding the` tilt( | left-right | )` .Now let\\'s see how to apply this :)\\n\\n**Algorithm :-** \\n1. Everytime we go to a node we see whether that node has a child nodes or not \\n2. If no nodes were to be found we make the leaf nodes as 0\\n3. If there are some child nodes then we find out the absolute difference of it i.e (|left-right|) and put this inside a `result` variable\\n4. The 2 and 3 process will be repeated till the end\\n5. In the end return the total sum .\\n\\n**Code**\\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    int result = 0;\\n    int depthfirstsearch(TreeNode *root) {\\n\\t\\t//Checking if there are some child tree and if its true dfs it or else the node is leaf node therfore make it 0\\n        int left = (root->left ? depthfirstsearch(root->left) : 0), right = (root->right ? depthfirstsearch(root->right) : 0);\\n        // Finding the current tilt( |left-right| )\\n\\t\\tresult += abs(left - right);\\n\\t\\t// returning the total sum\\n        return left + right + root->val;\\n    }\\n    int findTilt(TreeNode* root) {\\n        if (root) depthfirstsearch(root);\\n        return result;\\n    }\\n};\\n```\\n\\n\\n ..... *Continuation from the previous posts,\\nAs the legends told that, there was a another Dr Cheems whose mind was deepfreezed during 1947. So to find this out there were some excavation done on his landmark and the archaeologists found some old laboratory\\'s with some ruins and there was a laboratory which was sealed by a mysterious cage of doors. Archaeologists tried to open it but they weren\\'t able to open that door.Then a mysterious call came to one of the archaeologist . To be continued in the next post* ......\\n\\n***If you have suggestions or doubts feel free to comment ;)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    int result = 0;\\n    int depthfirstsearch(TreeNode *root) {\\n\\t\\t//Checking if there are some child tree and if its true dfs it or else the node is leaf node therfore make it 0\\n        int left = (root->left ? depthfirstsearch(root->left) : 0), right = (root->right ? depthfirstsearch(root->right) : 0);\\n        // Finding the current tilt( |left-right| )\\n\\t\\tresult += abs(left - right);\\n\\t\\t// returning the total sum\\n        return left + right + root->val;\\n    }\\n    int findTilt(TreeNode* root) {\\n        if (root) depthfirstsearch(root);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102327,
                "title": "simple-java-solution-without-global-variable",
                "content": "To avoid using global variable, you can take use of size-1 array or any other objects.  \\n\\n```\\npublic int findTilt(TreeNode root) {\\n    int[] ret = new int[1];\\n    helper(root, ret);\\n    return ret[0];\\n}\\n    \\nprivate int helper(TreeNode node, int[] ret){\\n    if(node == null){\\n        return 0;\\n    }\\n    int l_sum = helper(node.left, ret);\\n    int r_sum = helper(node.right, ret);\\n    ret[0] += Math.abs(l_sum - r_sum);\\n    return l_sum + r_sum + node.val\\n}\\n````",
                "solutionTags": [],
                "code": "```\\npublic int findTilt(TreeNode root) {\\n    int[] ret = new int[1];\\n    helper(root, ret);\\n    return ret[0];\\n}\\n    \\nprivate int helper(TreeNode node, int[] ret){\\n    if(node == null){\\n        return 0;\\n    }\\n    int l_sum = helper(node.left, ret);\\n    int r_sum = helper(node.right, ret);\\n    ret[0] += Math.abs(l_sum - r_sum);\\n    return l_sum + r_sum + node.val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102350,
                "title": "c-postorder-traverse-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int findTilt(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        \\n        int res = 0;\\n        \\n        postorder(root, res);\\n        \\n        return res;\\n    }\\nprivate:\\n    int postorder(TreeNode* root, int& res){\\n        if(root == NULL) return 0;\\n        \\n        int leftsum= postorder(root->left,res);\\n        \\n        int rightsum = postorder(root->right,res);\\n        \\n        res += abs(leftsum - rightsum);\\n        \\n        return leftsum + rightsum + root->val;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findTilt(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        \\n        int res = 0;\\n        \\n        postorder(root, res);\\n        \\n        return res;\\n    }\\nprivate:\\n    int postorder(TreeNode* root, int& res){\\n        if(root == NULL) return 0;\\n        \\n        int leftsum= postorder(root->left,res);\\n        \\n        int rightsum = postorder(root->right,res);\\n        \\n        res += abs(leftsum - rightsum);\\n        \\n        return leftsum + rightsum + root->val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617355,
                "title": "java-brute-force-to-optimization-postorder-detailed-explanation-using-image",
                "content": "**Intution:** The idea is to find the sum of left and rigt subtree at every node and and keep adding their absolute diffrence\\nExample:\\n![image](https://assets.leetcode.com/users/images/76b40923-4956-4b9f-9881-06def4681d4c_1638924013.4716578.png)\\n\\nTilt of node 3 : |0-0| = 0 (no children)\\nTilt of node 5 : |0-0| = 0 (no children)\\nTilt of node 7 : |0-0| = 0 (no children)\\nTilt of node 2 : |3-5| = 2 \\nTilt of node 9 : |0-7| = 7 \\nTilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6\\n\\n**Approach1: Brute Force(Finding Sum at every Node)** \\n**Explanation:** Find the sum of left subtree and right subtree using findSum function and take its absolute difference. So we will return the sum of absolute diff and leftSubtree tilt and right subtree tilt which will be your total tilt of the tree.\\n\\n```\\nclass Solution {\\n    int findSum(TreeNode root){\\n        if(root==null) return 0;\\n        return root.val + findSum(root.left) + findSum(root.right);\\n    }\\n    public int findTilt(TreeNode root) {\\n        if(root==null) return 0;\\n        \\n        int left = findTilt(root.left);\\n        int right = findTilt(root.right);\\n        \\n        return Math.abs(findSum(root.left)-findSum(root.right))+left+right;\\n        \\n    }\\n}\\n\\n```\\n\\n**Approach2: PostOrder Traversal**\\n**Explanation:** During PostOrder Traversal do both the work together, return the total sum and store the tilt value in a global variable.\\n![image](https://assets.leetcode.com/users/images/79a242f9-bd88-47ec-95e2-ce015a2ebbed_1638924995.3899744.jpeg)\\n\\n\\n```\\nclass Solution {\\n    \\n    int ans = 0;\\n\\n    public int findTilt(TreeNode root) {\\n        postOrder(root);\\n        return ans;\\n        \\n    }\\n    \\n    int postOrder(TreeNode root){\\n        if(root==null) return 0;\\n        \\n        int left = postOrder(root.left);\\n        int right = postOrder(root.right);\\n        \\n        ans += Math.abs(left-right);\\n        \\n        return root.val+ left + right;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int findSum(TreeNode root){\\n        if(root==null) return 0;\\n        return root.val + findSum(root.left) + findSum(root.right);\\n    }\\n    public int findTilt(TreeNode root) {\\n        if(root==null) return 0;\\n        \\n        int left = findTilt(root.left);\\n        int right = findTilt(root.right);\\n        \\n        return Math.abs(findSum(root.left)-findSum(root.right))+left+right;\\n        \\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    \\n    int ans = 0;\\n\\n    public int findTilt(TreeNode root) {\\n        postOrder(root);\\n        return ans;\\n        \\n    }\\n    \\n    int postOrder(TreeNode root){\\n        if(root==null) return 0;\\n        \\n        int left = postOrder(root.left);\\n        int right = postOrder(root.right);\\n        \\n        ans += Math.abs(left-right);\\n        \\n        return root.val+ left + right;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102371,
                "title": "javascript-solution-using-dfs",
                "content": "```\\nvar findTilt = function(root) {\\n    const tilt = { val: 0 };\\n    dfs(root, tilt);\\n    return tilt.val;\\n};\\n\\nfunction dfs(root, tilt) {\\n    if (!root) return 0;\\n    let left = dfs(root.left, tilt);\\n    let right = dfs(root.right, tilt);\\n    tilt.val += Math.abs(left - right);\\n    return root.val + left + right;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findTilt = function(root) {\\n    const tilt = { val: 0 };\\n    dfs(root, tilt);\\n    return tilt.val;\\n};\\n\\nfunction dfs(root, tilt) {\\n    if (!root) return 0;\\n    let left = dfs(root.left, tilt);\\n    let right = dfs(root.right, tilt);\\n    tilt.val += Math.abs(left - right);\\n    return root.val + left + right;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1617476,
                "title": "simple-c-code",
                "content": "//smjh\\n\\n```  \\nclass Solution {\\n    int findsum(TreeNode * root, int &tilt){\\n        if(!root) return 0;\\n        int l =findsum(root->left,tilt);\\n        int r = findsum( root->right,tilt);\\n        tilt +=abs(l-r);\\n        return l + r + root->val;\\n    }\\npublic:\\n    int findTilt(TreeNode* root) {\\n      int tilt = 0;\\n      findsum(root,tilt);\\n        return tilt;\\n    }\\n};\\n\\n\\n//Do upvote if you find it helpful......",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    int findsum(TreeNode * root, int &tilt){\\n        if(!root) return 0;\\n        int l =findsum(root->left,tilt);\\n        int r = findsum( root->right,tilt);\\n        tilt +=abs(l-r);\\n        return l + r + root->val;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 190499,
                "title": "i-don-t-understand-this-test-case",
                "content": "Here is my code, however, it does not work for one of the test case....eventhough I dont understand why the expected result should but 11, but not 10.... \n\n```\nclass Solution {\n    public int findTilt(TreeNode root) {\n        if(root == null) return 0;\n        List<Integer> nums = new ArrayList<>();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int res = 0; \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                TreeNode cur = queue.poll();\n                int left = 0;\n                int right = 0; \n                int diff = 0; \n                if(cur.left!= null){\n                    left = cur.left.val;\n                    queue.offer(cur.left);\n                }\n                if(cur.right!= null){\n                    right = cur.right.val;\n                    queue.offer(cur.right);\n                }\n                diff = Math.abs(right - left);\n                nums.add(diff);\n            }\n        }\n        \n        for(int i = 0; i < nums.size(); i++){\n            res+=nums.get(i);\n        }\n        return res; \n        \n    }\n}\n```\n\n![image](https://assets.leetcode.com/users/littlerainrain/image_1541565124.png)\n",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int findTilt(TreeNode root) {\n        if(root == null) return 0;\n        List<Integer> nums = new ArrayList<>();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int res = 0; \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                TreeNode cur = queue.poll();\n                int left = 0;\n                int right = 0; \n                int diff = 0; \n                if(cur.left!= null){\n                    left = cur.left.val;\n                    queue.offer(cur.left);\n                }\n                if(cur.right!= null){\n                    right = cur.right.val;\n                    queue.offer(cur.right);\n                }\n                diff = Math.abs(right - left);\n                nums.add(diff);\n            }\n        }\n        \n        for(int i = 0; i < nums.size(); i++){\n            res+=nums.get(i);\n        }\n        return res; \n        \n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617704,
                "title": "python-step-by-step-from-naive-solution-to-post-order-dfs-beginner-friendly",
                "content": "**Solution 1** Start with thinking the **Naive approach**. We will just do what the question says.\\n\\n**Step 1**: Question says we need to **find absolute difference between left_subtree  and Right_subtree**; For this we will define a function named ***subtree_sum*** which will accept a node as parameter and returns the sum of all nodes in that subtree. We calculate abs difference as follows  :\\n```\\nabs(subtree_sum(root.left) - subtree_sum(root.right))\\n```\\n\\n**Step 2**: Question says we **need to do step 1 for each and every node(not just root)**. So we call function *findTilt* on every node as follows:\\n```\\nself.findTilt(root.left) + self.findTilt(root.right)\\n```\\nWe just combine step1 and step2 to get the answer:\\n\\n```\\n return abs(subtree_sum(root.left) - subtree_sum(root.right)) + self.findTilt(root.left) + self.findTilt(root.right)\\n```\\n\\nHere is the full code:\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        \\n        def subtree_sum(root):\\n            if not root:\\n                return 0;\\n            left = subtree_sum(root.left)\\n            right = subtree_sum(root.right)\\n            return left + right + root.val\\n        \\n        \\n        if not root:\\n            return 0\\n        return abs(subtree_sum(root.left) - subtree_sum(root.right)) + self.findTilt(root.left) + self.findTilt(root.right)\\n```\\n\\n**pls make a note of the funtion *subtree_sum* above.**\\n\\n**Solution 2**: **Post-order dfs Traversal.**\\n\\nJust **add one extra line to *subtree_sum* function above and you have your well optimised solution ready.**\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        \\n        def subtree_sum(root):\\n            if not root:\\n                return 0;\\n            left = subtree_sum(root.left)\\n            right = subtree_sum(root.right)\\n            # \"\"\"\\n            # Just add this line.\\n            # This line is replacement of what we were calling \\n            # findTilt function on every subnode. Calculate here itself.\\n            # \"\"\"\\n            subtree_sum.total_tilt += abs(left-right)\\n            return left + right + root.val\\n        \\n        subtree_sum.total_tilt = 0\\n        subtree_sum(root)\\n        return subtree_sum.total_tilt\\n```\\n\\n**Explanation** : We would have already calculated the left and right subtree sum values of the lower nodes while we were calculating the subtree_sum for root. So instead of calling *findTilt* function on every subnode; We just calculate it when we are finding subtree_sum for root node.\\n\\nThanks for Reading.\\npls do upvote|comment|share if you find it useful. Any Suggestions/improvements/mistakes are welcomed.\\n",
                "solutionTags": [],
                "code": "```\\nabs(subtree_sum(root.left) - subtree_sum(root.right))\\n```\n```\\nself.findTilt(root.left) + self.findTilt(root.right)\\n```\n```\\n return abs(subtree_sum(root.left) - subtree_sum(root.right)) + self.findTilt(root.left) + self.findTilt(root.right)\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        \\n        def subtree_sum(root):\\n            if not root:\\n                return 0;\\n            left = subtree_sum(root.left)\\n            right = subtree_sum(root.right)\\n            return left + right + root.val\\n        \\n        \\n        if not root:\\n            return 0\\n        return abs(subtree_sum(root.left) - subtree_sum(root.right)) + self.findTilt(root.left) + self.findTilt(root.right)\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        \\n        def subtree_sum(root):\\n            if not root:\\n                return 0;\\n            left = subtree_sum(root.left)\\n            right = subtree_sum(root.right)\\n            # \"\"\"\\n            # Just add this line.\\n            # This line is replacement of what we were calling \\n            # findTilt function on every subnode. Calculate here itself.\\n            # \"\"\"\\n            subtree_sum.total_tilt += abs(left-right)\\n            return left + right + root.val\\n        \\n        subtree_sum.total_tilt = 0\\n        subtree_sum(root)\\n        return subtree_sum.total_tilt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617650,
                "title": "java-code-without-class-variable-indirect-pointer-simple-dfs",
                "content": "\\nTo Solve Tree Question in which our root ans depends on subtree ans:\\n**General pattern used is :**\\n**Step1 :** Take ans from all childs subtree by doing recursive call, keep faith all child give correct answer.\\n**step2 :** and, then do work on root in post area of recursive calls.\\n**step3 :** and, then return ans for tree till that Node. \\nQuestion on similar pattern : \\n* **Maximum Node in tree**\\n* **Count of Node of Tree**\\n* **Height of Tree**\\n\\n\\n---\\n > **Approch 1 :**  Moving top to bottom in tree and doing our work in post area of recursion.\\n* Here we are returning two values from tree one is **newTreeSum** and other **oldTreeSum**.\\n* We can made pair class also to return ans, but using two size 1-d array much faster to implement .\\n```    \\n    public int findTilt(TreeNode root) {       \\n        return findTiltHelper(root)[0];                        \\n    }\\n    \\n    // int [] ans= {newtreesum,oldtreesum};\\n    private int[] findTiltHelper(TreeNode root){\\n         if(root==null){\\n            return new int[]{0,0};\\n        }\\n        \\n        int leftsum[] = findTiltHelper(root.left);\\n        int rightsum[] =  findTiltHelper(root.right);\\n        int oldTreeSum = leftsum[1]+rightsum[1]+root.val;         \\n                \\n        \\n        int newTreeSum = leftsum[0]+rightsum[0]+Math.abs(leftsum[1]-rightsum[1]);         \\n        \\n        return  new int[]{newTreeSum,oldTreeSum};\\n        \\n        \\n    }\\n```\\n\\n---\\n> ####  **Approch 2: USing class Variable**\\n\\n```\\npublic int findTilt(TreeNode root) {\\n       \\n        \\n        findTiltHelper(root);\\n        return sum;                \\n    }\\n\\t\\nint sum=0;\\n    \\nprivate int findTiltHelper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n        int leftsum =   findTiltHelper(root.left);\\n        int rightsum =  findTiltHelper(root.right);\\n        sum+= Math.abs(leftsum-rightsum);// our ans is  sum of diff of leftsum and rightsum at each Node\\n        return leftsum+rightsum +root.val;\\n        \\n    }\\n    \\n```\\n\\n\\n\\n##  Without using class variable \\n\\n\\n\\n```\\npublic int findTilt(TreeNode root) {      \\n        int sum[] =  new int[1];\\n        findTiltHelper(root,sum);\\n        return sum[0];                \\n    }\\n    \\n    \\n    private int findTiltHelper(TreeNode root,int []sum){\\n        if(root==null){\\n            return 0;\\n        }\\n        int leftsum =   findTiltHelper(root.left,sum);\\n        int rightsum =  findTiltHelper(root.right,sum);\\n        sum[0]+= Math.abs(leftsum-rightsum);\\n        return leftsum+rightsum +root.val;\\n        \\n    }\\n```\\n\\n\\n### Please Upvote  \\uD83E\\uDD84",
                "solutionTags": [
                    "Java"
                ],
                "code": "```    \\n    public int findTilt(TreeNode root) {       \\n        return findTiltHelper(root)[0];                        \\n    }\\n    \\n    // int [] ans= {newtreesum,oldtreesum};\\n    private int[] findTiltHelper(TreeNode root){\\n         if(root==null){\\n            return new int[]{0,0};\\n        }\\n        \\n        int leftsum[] = findTiltHelper(root.left);\\n        int rightsum[] =  findTiltHelper(root.right);\\n        int oldTreeSum = leftsum[1]+rightsum[1]+root.val;         \\n                \\n        \\n        int newTreeSum = leftsum[0]+rightsum[0]+Math.abs(leftsum[1]-rightsum[1]);         \\n        \\n        return  new int[]{newTreeSum,oldTreeSum};\\n        \\n        \\n    }\\n```\n```\\npublic int findTilt(TreeNode root) {\\n       \\n        \\n        findTiltHelper(root);\\n        return sum;                \\n    }\\n\\t\\nint sum=0;\\n    \\nprivate int findTiltHelper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n        int leftsum =   findTiltHelper(root.left);\\n        int rightsum =  findTiltHelper(root.right);\\n        sum+= Math.abs(leftsum-rightsum);// our ans is  sum of diff of leftsum and rightsum at each Node\\n        return leftsum+rightsum +root.val;\\n        \\n    }\\n    \\n```\n```\\npublic int findTilt(TreeNode root) {      \\n        int sum[] =  new int[1];\\n        findTiltHelper(root,sum);\\n        return sum[0];                \\n    }\\n    \\n    \\n    private int findTiltHelper(TreeNode root,int []sum){\\n        if(root==null){\\n            return 0;\\n        }\\n        int leftsum =   findTiltHelper(root.left,sum);\\n        int rightsum =  findTiltHelper(root.right,sum);\\n        sum[0]+= Math.abs(leftsum-rightsum);\\n        return leftsum+rightsum +root.val;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102352,
                "title": "java-solution-no-globle-varible-easy-and-clean",
                "content": "I don't understand the question when I do it at the first time.\\nBut now I got it.\\nFor example:\\n&nbsp;&nbsp;&nbsp;&nbsp;1\\n&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;\\\\\\\\\\n&nbsp;&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;3\\n&nbsp;/&nbsp;\\\\\\\\ &nbsp;&nbsp;&nbsp;/\\n  4&nbsp;&nbsp;#&nbsp;5\\n\\nOutput: 11\\nExplanation: \\nTilt of node 4 : 0\\nTilt of node 5 : 0\\nTilt of node 2 : |4-0| = 4\\nTilt of node 3 : |5-0| = 5\\nTilt of node 1 : |sum(2,4)-sum(3,5)| = |6-8| = 2\\nTilt of binary tree : 0 + 0 + 4 + 5 + 2 = 11\\n```\\n    public int findTilt(TreeNode root) {\\n        if (root == null) return 0;\\n        int curVal = 0;\\n        curVal = Math.abs(sumSubTree(root.left) - sumSubTree(root.right));\\n        return curVal + findTilt(root.left) + findTilt(root.right);\\n    }\\n\\n    private int sumSubTree(TreeNode root) {\\n        if (root == null) return 0;\\n        return root.val + sumSubTree(root.left) + sumSubTree(root.right);\\n    }",
                "solutionTags": [],
                "code": "I don't understand the question when I do it at the first time.\\nBut now I got it.\\nFor example:\\n&nbsp;&nbsp;&nbsp;&nbsp;1\\n&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;\\\\\\\\\\n&nbsp;&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;3\\n&nbsp;/&nbsp;\\\\\\\\ &nbsp;&nbsp;&nbsp;/\\n  4&nbsp;&nbsp;#&nbsp;5\\n\\nOutput: 11\\nExplanation: \\nTilt of node 4 : 0\\nTilt of node 5 : 0\\nTilt of node 2 : |4-0| = 4\\nTilt of node 3 : |5-0| = 5\\nTilt of node 1 : |sum(2,4)-sum(3,5)| = |6-8| = 2\\nTilt of binary tree : 0 + 0 + 4 + 5 + 2 = 11\\n```\\n    public int findTilt(TreeNode root) {\\n        if (root == null) return 0;\\n        int curVal = 0;\\n        curVal = Math.abs(sumSubTree(root.left) - sumSubTree(root.right));\\n        return curVal + findTilt(root.left) + findTilt(root.right);\\n    }\\n\\n    private int sumSubTree(TreeNode root) {\\n        if (root == null) return 0;\\n        return root.val + sumSubTree(root.left) + sumSubTree(root.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 928838,
                "title": "c-recursive-solution-explained-100-time-80-space",
                "content": "I think today\\'s problem is more of a medium than an easy, but okay.\\n\\nIn order to solve it, our main function will just check if we have a `root` (ie: the tree is non empty) and if so call a `dfs` helper function; `res`, a class variable initially set to `0`, will always be returned.\\n\\nThe core of our logic is of course `dfs` and in this function we will:\\n* compute the values of the `left` and `right` sub sums, recursively;\\n* update `res` as the absolute value of `left - right`;\\n* finally return the value of the cumulated sum of all the nodes up to here (current node included), as `left + right + root->val`.\\n\\nNotice that using ternary operators, we make sure that the recursive calls are never made on a `NULL` node.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int dfs(TreeNode *root) {\\n\\t\\t// computing local left and right sub sums\\n        int left = (root->left ? dfs(root->left) : 0), right = (root->right ? dfs(root->right) : 0);\\n        // count the current tilt\\n\\t\\tres += abs(left - right);\\n\\t\\t// return the sum so far\\n        return left + right + root->val;\\n    }\\n    int findTilt(TreeNode* root) {\\n        if (root) dfs(root);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int res = 0;\\n    int dfs(TreeNode *root) {\\n\\t\\t// computing local left and right sub sums\\n        int left = (root->left ? dfs(root->left) : 0), right = (root->right ? dfs(root->right) : 0);\\n        // count the current tilt\\n\\t\\tres += abs(left - right);\\n\\t\\t// return the sum so far\\n        return left + right + root->val;\\n    }\\n    int findTilt(TreeNode* root) {\\n        if (root) dfs(root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102314,
                "title": "an-iterative-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int findTilt(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int tilt = 0;\\n        Stack<TreeNode> stack = new Stack<>();\\n        Map<TreeNode, Integer> map = new HashMap<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.peek();\\n            if ((node.left == null || map.containsKey(node.left)) &&\\n                (node.right == null || map.containsKey(node.right))) {\\n                stack.pop();\\n                int left = map.containsKey(node.left) ? map.get(node.left) : 0;\\n                int right = map.containsKey(node.right) ? map.get(node.right) : 0;\\n                tilt += Math.abs(left - right);\\n                map.put(node, left + right + node.val);\\n            } else {\\n                if (node.left != null && !map.containsKey(node.left)) {\\n                    stack.push(node.left); \\n                }\\n                \\n                if (node.right != null && !map.containsKey(node.right)) {\\n                    stack.push(node.right);\\n                }      \\n            }\\n        }\\n        return tilt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int findTilt(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int tilt = 0;\\n        Stack<TreeNode> stack = new Stack<>();\\n        Map<TreeNode, Integer> map = new HashMap<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.peek();\\n            if ((node.left == null || map.containsKey(node.left)) &&\\n                (node.right == null || map.containsKey(node.right))) {\\n                stack.pop();\\n                int left = map.containsKey(node.left) ? map.get(node.left) : 0;\\n                int right = map.containsKey(node.right) ? map.get(node.right) : 0;\\n                tilt += Math.abs(left - right);\\n                map.put(node, left + right + node.val);\\n            } else {\\n                if (node.left != null && !map.containsKey(node.left)) {\\n                    stack.push(node.left); \\n                }\\n                \\n                if (node.right != null && !map.containsKey(node.right)) {\\n                    stack.push(node.right);\\n                }      \\n            }\\n        }\\n        return tilt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102323,
                "title": "c-easy-and-clean-soluion",
                "content": "```\\n    int res=0;\\n    int findTilt(TreeNode* root) {\\n        DFS(root);\\n        return res;\\n    }\\n    \\n    int DFS(TreeNode* n) {\\n        if(n==NULL) return 0;\\n        int l=DFS(n->left);\\n        int r=DFS(n->right);\\n        res+=abs(l-r);\\n        return l+r+n->val;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int res=0;\\n    int findTilt(TreeNode* root) {\\n        DFS(root);\\n        return res;\\n    }\\n    \\n    int DFS(TreeNode* n) {\\n        if(n==NULL) return 0;\\n        int l=DFS(n->left);\\n        int r=DFS(n->right);\\n        res+=abs(l-r);\\n        return l+r+n->val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 928171,
                "title": "binary-tree-tilt",
                "content": "This is a simple recursion problem, that needs a bit more attention. All you need to do is store the tilt of a particular node in a vector, and then calculate the sum of all elements of the vector. To calculate the tilt of a node, you need the help of separate helper function that calculates the sum of left and right subtrees of the node, so that you can find the absolute difference of the sum of left and right subtrees. The calculation of the tilt of all nodes can be done using simple tree traversal algorithms. Following is my code for better understanding in C++. Note that my code is not space optimized, I know it can be optimized further, but I\\'m too lazy to do that :)\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    vector<int> tilts;\\n    int sums(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        return sums(root->left)+sums(root->right)+root->val;\\n    }\\n    void tilt(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return ;\\n        int x=abs(sums(root->left)-sums(root->right));\\n        //cout<<x<<\"\\\\n\";\\n        tilts.push_back(x);\\n        tilt(root->left);\\n        tilt(root->right);\\n        \\n            \\n        \\n    }\\n    int findTilt(TreeNode* root) {\\n        tilt(root);\\n        for(int i:tilts)\\n            sum+=i;\\n        return sum;\\n    }\\n};\\n```\\nPlease upvote if you liked my answer, and it helped you understand tree traversal algorithms.",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    vector<int> tilts;\\n    int sums(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        return sums(root->left)+sums(root->right)+root->val;\\n    }\\n    void tilt(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return ;\\n        int x=abs(sums(root->left)-sums(root->right));\\n        //cout<<x<<\"\\\\n\";\\n        tilts.push_back(x);\\n        tilt(root->left);\\n        tilt(root->right);\\n        \\n            \\n        \\n    }\\n    int findTilt(TreeNode* root) {\\n        tilt(root);\\n        for(int i:tilts)\\n            sum+=i;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 928461,
                "title": "python-simple-short-dfs-solution",
                "content": "Return value: the sum of self value children values\\nAdd tilt value to ans\\n```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        def helper(root):\\n            if not root: return 0\\n            lv, rv = helper(root.left), helper(root.right)\\n            self.ans += abs(lv - rv)\\n            return root.val + lv + rv\\n        \\n        self.ans = 0\\n        helper(root)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        def helper(root):\\n            if not root: return 0\\n            lv, rv = helper(root.left), helper(root.right)\\n            self.ans += abs(lv - rv)\\n            return root.val + lv + rv\\n        \\n        self.ans = 0\\n        helper(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927901,
                "title": "c-c-super-simple-recursive-solution",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    int rec(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        int left = rec(root->left);\\n        int right = rec(root->right);\\n        int tilt = abs(left - right);\\n        res += tilt;\\n        return left + right + root->val;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        rec(root);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```\\n**C:**\\n```\\nint res = 0;\\n\\nint rec(struct TreeNode* root) {\\n    if (!root)\\n        return 0;\\n    int left = rec(root->left);\\n    int right = rec(root->right);\\n    int tilt = abs(left - right);\\n    res += tilt;\\n    return left + right + root->val;\\n}\\n\\nint findTilt(struct TreeNode* root){\\n    res = 0;\\n    rec(root);\\n    return res;\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        int left = rec(root->left);\\n        int right = rec(root->right);\\n        int tilt = abs(left - right);\\n        res += tilt;\\n        return left + right + root->val;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        rec(root);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```\n```\\nint res = 0;\\n\\nint rec(struct TreeNode* root) {\\n    if (!root)\\n        return 0;\\n    int left = rec(root->left);\\n    int right = rec(root->right);\\n    int tilt = abs(left - right);\\n    res += tilt;\\n    return left + right + root->val;\\n}\\n\\nint findTilt(struct TreeNode* root){\\n    res = 0;\\n    rec(root);\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617686,
                "title": "java-solution-using-post-order-traversal",
                "content": "```\\nclass Solution {\\n    private int ans=0 ; \\n    private int helper(TreeNode root){\\n        if(root==null){return 0; }\\n        \\n        int l= helper(root.left) ;\\n        int r= helper(root.right) ;\\n        \\n        ans+=Math.abs(l-r) ;\\n        \\n        return l+r+root.val; \\n        \\n    }\\n    public int findTilt(TreeNode root) {\\n       \\n         helper(root) ;\\n        \\n         return ans; \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private int ans=0 ; \\n    private int helper(TreeNode root){\\n        if(root==null){return 0; }\\n        \\n        int l= helper(root.left) ;\\n        int r= helper(root.right) ;\\n        \\n        ans+=Math.abs(l-r) ;\\n        \\n        return l+r+root.val; \\n        \\n    }\\n    public int findTilt(TreeNode root) {\\n       \\n         helper(root) ;\\n        \\n         return ans; \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134294,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def findTilt(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        self.tilt = 0\\n        self.findTiltHelper(root)\\n        return self.tilt\\n        \\n    def findTiltHelper(self, root):\\n        if not root:\\n            return 0\\n        left = self.findTiltHelper(root.left)\\n        right = self.findTiltHelper(root.right)\\n        self.tilt += abs(left - right)\\n        return left + right + root.val\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findTilt(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        self.tilt = 0\\n        self.findTiltHelper(root)\\n        return self.tilt\\n        \\n    def findTiltHelper(self, root):\\n        if not root:\\n            return 0\\n        left = self.findTiltHelper(root.left)\\n        right = self.findTiltHelper(root.right)\\n        self.tilt += abs(left - right)\\n        return left + right + root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298815,
                "title": "563-time-93-99-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Set the \"total_tilt\" attribute to 0 as we will be incrementally adding to this as we calculate the tilt of each node.\\n2. Define a helper function called \"calculate_tilt\" that takes in a node and returns an integer representing the sum of the node\\'s left and right subtrees and the node\\'s value.\\n3. In the \"calculate_tilt\" function, check if the node is None. If it is, return 0 as there is no subtree to sum.\\n4. Recursively call the \"calculate_tilt\" function on the node\\'s left and right children, storing the results in the \"left_sum\" and \"right_sum\" variables.\\n5. Calculate the tilt of the current node by taking the absolute difference between the left_sum and right_sum.\\n6. Increment the total_tilt by the current node\\'s tilt.\\n7. Return the sum of the left_sum, right_sum, and node\\'s value.\\n8. Call the \"calculate_tilt\" function on the root node to recursively calculate the tilt of every node in the binary tree.\\n9. Return the total_tilt as the result of the \"findTilt\" method.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        self.total_tilt = 0\\n        \\n        def calculate_tilt(node):\\n            if not node:\\n                return 0\\n            \\n            left_sum = calculate_tilt(node.left)\\n            right_sum = calculate_tilt(node.right)\\n            tilt = abs(left_sum - right_sum)\\n            \\n            self.total_tilt += tilt\\n            \\n            return left_sum + right_sum + node.val\\n        \\n        calculate_tilt(root)\\n        return self.total_tilt\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        self.total_tilt = 0\\n        \\n        def calculate_tilt(node):\\n            if not node:\\n                return 0\\n            \\n            left_sum = calculate_tilt(node.left)\\n            right_sum = calculate_tilt(node.right)\\n            tilt = abs(left_sum - right_sum)\\n            \\n            self.total_tilt += tilt\\n            \\n            return left_sum + right_sum + node.val\\n        \\n        calculate_tilt(root)\\n        return self.total_tilt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618293,
                "title": "c-easy-solution-with-example-and-explanation",
                "content": "Easy algorithm for binary tree tilt using dfs recursion ( going to the depth i.e last or leaf node and then step by step coming to top or root node)\\n\\nAlgorithm : \\n\\nstep 1 - Check if the root is empty or not, if yes then return 0.\\nstep 2 - if not then recurrsively reach the leaf node from left and right.\\nstep 3 - if the node does not have left or right child , then store 0 in left and right accordingly. \\nstep 4 - store tilt value in node as left + right + node - > val.\\nstep 4 - keep on adding value of |left -right| in the result till the reccursion reaches to its base condition.\\nstep 5 - return result.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int result = 0;\\n    int dfs(TreeNode *root) \\n    {\\n\\t\\t//Checking if there are child nodes \\n        //if its true dfs it or else the node is leaf node therfore make it 0\\n        int left=(root->left?dfs(root->left):0),right=(root->right?dfs(root->right):0);\\n        // Finding the current tilt( |left - right| )\\n\\t\\tresult += abs(left - right);\\n\\t\\t// returning the total sum\\n        return left + right + root->val;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        if (root) dfs(root);\\n        return result;\\n    }\\n};\\n```\\n\\n\\nExample :\\n\\n```\\n\\t\\t1                                                 5\\n\\t\\t/\\\\                                               /\\\\\\n\\t4     9               ----->                        4  7\\n\\t/\\\\    /                                            /\\\\  /\\n2    6  7                                             0 0 0\\n\\nOutput : 16\\nreccur 1 : left = 0,right =0 , result =0\\nreccur 2 : left = 0,right =0 , result =0\\nreccur 3 : left = 2, right =6 , result =4\\nreccur 4 : left = 4,right =9 , result =9\\nreccur 5 : left = 0,right =0 , result =9\\nreccur 6 : left = 7,right =0 , result =16\\n\\ntherefore , number of reccursion = number of nodes = 6\\nTime complexity = O(n) | n= number of nodes\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int result = 0;\\n    int dfs(TreeNode *root) \\n    {\\n\\t\\t//Checking if there are child nodes \\n        //if its true dfs it or else the node is leaf node therfore make it 0\\n        int left=(root->left?dfs(root->left):0),right=(root->right?dfs(root->right):0);\\n        // Finding the current tilt( |left - right| )\\n\\t\\tresult += abs(left - right);\\n\\t\\t// returning the total sum\\n        return left + right + root->val;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        if (root) dfs(root);\\n        return result;\\n    }\\n};\\n```\n```\\n\\t\\t1                                                 5\\n\\t\\t/\\\\                                               /\\\\\\n\\t4     9               ----->                        4  7\\n\\t/\\\\    /                                            /\\\\  /\\n2    6  7                                             0 0 0\\n\\nOutput : 16\\nreccur 1 : left = 0,right =0 , result =0\\nreccur 2 : left = 0,right =0 , result =0\\nreccur 3 : left = 2, right =6 , result =4\\nreccur 4 : left = 4,right =9 , result =9\\nreccur 5 : left = 0,right =0 , result =9\\nreccur 6 : left = 7,right =0 , result =16\\n\\ntherefore , number of reccursion = number of nodes = 6\\nTime complexity = O(n) | n= number of nodes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617584,
                "title": "get-the-idea-for-such-problems-easy-faster",
                "content": "**Approach:-**\\n* The only thing we need to maintain is *subtree sum for every node* right? Why?\\n* Since **our answer is the summation of absolute values of the difference between left and right child subtree sum for every node**.\\n* Wait, How do we calculate the subtree sum and sum of tilt\\'s value in one pass(one recursive step)?\\n* Maintain **pair<int, int>** for every node where *first element of the pair will be the sum of tilt\\'s value for left child subtree and the second element of the pair will be left child subtree sum*.\\n* Now, **our answer will be the first element of the pair of the root node obviously**.\\n* Also, The key step is what do we return to the parents of every node?\\n* **return {l.first+r.first+abs(l.second-r.second),l.second+r.second+root->val}**\\n* You can easily observe that *first value is the sum of tilt\\'s value of all nodes in the current subtree* and *the second element is subtree sum of the current node*.\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(n)\\n    // Space Complexity:- O(1) [neglecting the space due to recursion stack]\\n    pair<int,int> BinaryTreeTilt(TreeNode* root){\\n        if(!root)\\n            return {0,0};\\n        pair<int,int> l = BinaryTreeTilt(root->left); // {sum of tilt values for left child,left child subtree sum}\\n        pair<int,int> r = BinaryTreeTilt(root->right); // {sum of tilt values for right child,right child subtree sum}\\n        return {l.first+r.first+abs(l.second-r.second),l.second+r.second+root->val};\\n    }\\n    int findTilt(TreeNode* root) {\\n        return BinaryTreeTilt(root).first; // answer is first element of pair\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote!**",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(n)\\n    // Space Complexity:- O(1) [neglecting the space due to recursion stack]\\n    pair<int,int> BinaryTreeTilt(TreeNode* root){\\n        if(!root)\\n            return {0,0};\\n        pair<int,int> l = BinaryTreeTilt(root->left); // {sum of tilt values for left child,left child subtree sum}\\n        pair<int,int> r = BinaryTreeTilt(root->right); // {sum of tilt values for right child,right child subtree sum}\\n        return {l.first+r.first+abs(l.second-r.second),l.second+r.second+root->val};\\n    }\\n    int findTilt(TreeNode* root) {\\n        return BinaryTreeTilt(root).first; // answer is first element of pair\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617346,
                "title": "python3-recursion-explained",
                "content": "We can use here a helper recursive function that takes a node of the tree and returns a tuple consisting of the sum of all nodes and the current tilt. Inside the function, we call it recursively for every child and use the result for calculation sum and the tilt of the current subtree with the root at the given node.\\n\\nTime: **O(n)** - post-order tree traversal\\nSpace: **O(n)** - for the recursion stack\\n\\nRuntime: 49 ms, faster than **92.00%** of Python3 online submissions for Binary Tree Tilt.\\nMemory Usage: 16.3 MB, less than **49.93%** of Python3 online submissions for Binary Tree Tilt.\\n\\n```\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        def recurs(n):\\n            if not n:\\n                return (0, 0)\\n            \\n            l, r = n.left, n.right\\n            \\n            lSum, lTilt = recurs(l)\\n            rSum, rTilt = recurs(r)\\n            \\n            curTilt = abs(lSum - rSum)\\n            \\n            return (lSum + rSum + n.val, lTilt + rTilt + curTilt)\\n\\n        return recurs(root)[1]\\n```",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        def recurs(n):\\n            if not n:\\n                return (0, 0)\\n            \\n            l, r = n.left, n.right\\n            \\n            lSum, lTilt = recurs(l)\\n            rSum, rTilt = recurs(r)\\n            \\n            curTilt = abs(lSum - rSum)\\n            \\n            return (lSum + rSum + n.val, lTilt + rTilt + curTilt)\\n\\n        return recurs(root)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999891,
                "title": "0ms-fater-then-100-in-java",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public int findTilt(TreeNode root) {\\n        helper(root);\\n        return ans;\\n    }\\n    \\n    int helper(TreeNode root)\\n    {\\n        if(root==null)\\n            return 0;\\n        \\n        if(root.left==null && root.right==null)\\n            return root.val;\\n        \\n        int x = helper(root.left);\\n        int y = helper(root.right);\\n        ans+=Math.abs(x-y);\\n        root.val +=x+y; \\n        return root.val;\\n    } \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int ans = 0;\\n    public int findTilt(TreeNode root) {\\n        helper(root);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 837126,
                "title": "javascript-solution",
                "content": "```\\n */\\nvar findTilt = function(root) {\\n    let tot = 0;\\n    \\n    findSum(root);\\n    \\n    return tot;\\n    \\n    function findSum(node) {\\n        // base case\\n        if (node == null) return 0;\\n        \\n        const left = findSum(node.left);\\n        const right = findSum(node.right);\\n        \\n        const sum = left + right;\\n        \\n        tot += Math.abs(left - right);\\n        \\n        return sum + node.val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n */\\nvar findTilt = function(root) {\\n    let tot = 0;\\n    \\n    findSum(root);\\n    \\n    return tot;\\n    \\n    function findSum(node) {\\n        // base case\\n        if (node == null) return 0;\\n        \\n        const left = findSum(node.left);\\n        const right = findSum(node.right);\\n        \\n        const sum = left + right;\\n        \\n        tot += Math.abs(left - right);\\n        \\n        return sum + node.val;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 317905,
                "title": "java-iterative-with-dummy-node",
                "content": "```\\nclass Solution {\\n    \\n    public int findTilt(TreeNode root) {\\n        if (root == null) return 0;\\n        int tilt = 0;\\n        Stack<Integer> sums = new Stack<>();\\n        Stack<TreeNode> toVisit = new Stack<>();\\n        TreeNode calc = new TreeNode(0);\\n        toVisit.push(root);\\n        while(!toVisit.isEmpty()) {\\n            TreeNode node = toVisit.pop();\\n            if (node == calc) {\\n                int left = sums.pop(), right = sums.pop();\\n                tilt += Math.abs(left - right);\\n                sums.push(left + right + sums.pop());\\n                continue;\\n            }\\n            sums.push(node.val);\\n            toVisit.push(calc);\\n            if (node.left == null) {\\n                sums.push(0);\\n            } else {\\n                toVisit.push(node.left);\\n            }\\n            if (node.right == null) {\\n                sums.push(0);\\n            } else {\\n                toVisit.push(node.right);\\n            }\\n        }\\n        return tilt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int findTilt(TreeNode root) {\\n        if (root == null) return 0;\\n        int tilt = 0;\\n        Stack<Integer> sums = new Stack<>();\\n        Stack<TreeNode> toVisit = new Stack<>();\\n        TreeNode calc = new TreeNode(0);\\n        toVisit.push(root);\\n        while(!toVisit.isEmpty()) {\\n            TreeNode node = toVisit.pop();\\n            if (node == calc) {\\n                int left = sums.pop(), right = sums.pop();\\n                tilt += Math.abs(left - right);\\n                sums.push(left + right + sums.pop());\\n                continue;\\n            }\\n            sums.push(node.val);\\n            toVisit.push(calc);\\n            if (node.left == null) {\\n                sums.push(0);\\n            } else {\\n                toVisit.push(node.left);\\n            }\\n            if (node.right == null) {\\n                sums.push(0);\\n            } else {\\n                toVisit.push(node.right);\\n            }\\n        }\\n        return tilt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541232,
                "title": "c-easy-with-understand",
                "content": "1. Find sum subtree for every node\\n2. Find abs between sum for left and right node\\n3. Sum it\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSumSubTree(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        \\n        int sum = root->val;\\n        sum += findSumSubTree(root->left) + findSumSubTree(root->right);\\n\\n        return sum;\\n    }\\n\\n    int findTilt(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        \\n        int sum = abs(findSumSubTree(root->left) - findSumSubTree(root->right));\\n        sum += findTilt(root->left) + findTilt(root->right);\\n    \\n        return sum;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSumSubTree(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        \\n        int sum = root->val;\\n        sum += findSumSubTree(root->left) + findSumSubTree(root->right);\\n\\n        return sum;\\n    }\\n\\n    int findTilt(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        \\n        int sum = abs(findSumSubTree(root->left) - findSumSubTree(root->right));\\n        sum += findTilt(root->left) + findTilt(root->right);\\n    \\n        return sum;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269676,
                "title": "c-recursion-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int tilt=0;\\n    int findTilt(TreeNode* root) {\\n        fun(root);\\n        return tilt;\\n    }\\n    int fun(TreeNode* root){\\n        if(root==NULL)\\n            return 0;\\n        \\n        int left=fun(root->left); // sum of left subtree\\n        int right=fun(root->right); // sum of right subtree\\n        \\n        tilt+=abs(left-right); // add tilt\\n        return root->val+left+right; // return sum\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tilt=0;\\n    int findTilt(TreeNode* root) {\\n        fun(root);\\n        return tilt;\\n    }\\n    int fun(TreeNode* root){\\n        if(root==NULL)\\n            return 0;\\n        \\n        int left=fun(root->left); // sum of left subtree\\n        int right=fun(root->right); // sum of right subtree\\n        \\n        tilt+=abs(left-right); // add tilt\\n        return root->val+left+right; // return sum\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697476,
                "title": "java-easy-understanding-approach",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    public int findTilt(TreeNode root) {\\n        int l=0,r=0;\\n        if(root!=null){\\n          l = findSum(root.left);\\n          r = findSum(root.right);\\n        sum = sum + Math.abs(r-l);\\n        findTilt(root.left);\\n        findTilt(root.right);  \\n        }\\n        return sum ;   \\n    }\\n    \\n    public int findSum(TreeNode root){\\n        if(root==null)\\n            return 0;\\n        if(root.left==null && root.right==null)\\n            return root.val;\\n        return root.val+findSum(root.left)+findSum(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int sum = 0;\\n    public int findTilt(TreeNode root) {\\n        int l=0,r=0;\\n        if(root!=null){\\n          l = findSum(root.left);\\n          r = findSum(root.right);\\n        sum = sum + Math.abs(r-l);\\n        findTilt(root.left);\\n        findTilt(root.right);  \\n        }\\n        return sum ;   \\n    }\\n    \\n    public int findSum(TreeNode root){\\n        if(root==null)\\n            return 0;\\n        if(root.left==null && root.right==null)\\n            return root.val;\\n        return root.val+findSum(root.left)+findSum(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434440,
                "title": "c-o-n-recursion-easy-simple",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint ans = 0;\\n\\tint findTilt(TreeNode* root) {\\n\\t\\tsum(root);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tint sum(TreeNode* root)\\n\\t{\\n\\t\\tif (!root) return 0;\\n\\t\\tint l = sum(root->left);\\n\\t\\tint r = sum(root->right);\\n\\t\\tans += abs(l - r);\\n\\t\\treturn (l + r + root->val);\\n\\t}\\n};\\n```\\n\\n**If find helpful *Upvote It*\\uD83D\\uDC4D**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint ans = 0;\\n\\tint findTilt(TreeNode* root) {\\n\\t\\tsum(root);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tint sum(TreeNode* root)\\n\\t{\\n\\t\\tif (!root) return 0;\\n\\t\\tint l = sum(root->left);\\n\\t\\tint r = sum(root->right);\\n\\t\\tans += abs(l - r);\\n\\t\\treturn (l + r + root->val);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520397,
                "title": "python-o-n-by-dfs-90-with-hint-comment",
                "content": "Python O(n) by DFS.\\n\\n---\\n\\n**Hint**:\\n\\n**Update tilt of binary tree** during **DFS** traversal.\\n\\nFor each child node, **return sum of current sub-tree** to parent level.\\n\\n\\n---\\n\\n**Implementation**:\\n```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        \\n        tilt_sum = 0\\n        \\n        def helper( node: TreeNode):\\n            \\n            if not node:\\n\\t\\t\\t\\t# base case: empty node or empty tree\\n                return 0\\n            \\n            else:\\n                \\n                left_sum = helper(node.left)\\n                right_sum = helper(node.right)\\n                \\n\\t\\t\\t\\t# update tilt sum for whloe binary tree\\n                nonlocal tilt_sum\\n                tilt_sum += abs(left_sum - right_sum)\\n\\t\\t\\t\\t\\n                return left_sum + node.val + right_sum\\n        \\n        # ---------------------------------------------\\n        \\n        helper( root )\\n        return tilt_sum\\n```\\n\\n---\\n\\nAnother similar implementation with difference interface:\\n\\n```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        \\n        \\n        def helper( node: TreeNode)-> tuple:\\n            \\n            if not node:\\n                return 0, 0\\n            \\n            else:\\n                \\n                left_sum, left_tilt = helper(node.left)\\n                right_sum, right_tilt = helper(node.right)\\n                             \\n                current_tilt = abs(left_sum - right_sum)\\n                return ( (left_sum + node.val + right_sum), (left_tilt + current_tilt + right_tilt) )\\n        \\n        # ---------------------------------------------\\n        # first return item is the sum of current subtree\\n        # second return item is the tile of current subtree\\n        return helper(root)[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        \\n        tilt_sum = 0\\n        \\n        def helper( node: TreeNode):\\n            \\n            if not node:\\n\\t\\t\\t\\t# base case: empty node or empty tree\\n                return 0\\n            \\n            else:\\n                \\n                left_sum = helper(node.left)\\n                right_sum = helper(node.right)\\n                \\n\\t\\t\\t\\t# update tilt sum for whloe binary tree\\n                nonlocal tilt_sum\\n                tilt_sum += abs(left_sum - right_sum)\\n\\t\\t\\t\\t\\n                return left_sum + node.val + right_sum\\n        \\n        # ---------------------------------------------\\n        \\n        helper( root )\\n        return tilt_sum\\n```\n```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        \\n        \\n        def helper( node: TreeNode)-> tuple:\\n            \\n            if not node:\\n                return 0, 0\\n            \\n            else:\\n                \\n                left_sum, left_tilt = helper(node.left)\\n                right_sum, right_tilt = helper(node.right)\\n                             \\n                current_tilt = abs(left_sum - right_sum)\\n                return ( (left_sum + node.val + right_sum), (left_tilt + current_tilt + right_tilt) )\\n        \\n        # ---------------------------------------------\\n        # first return item is the sum of current subtree\\n        # second return item is the tile of current subtree\\n        return helper(root)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102354,
                "title": "javascript-solution-concise-es6-using-iife",
                "content": "Pretty much the JS equivalent of the top java solution.\\n\\n```javascript\\nfunction findTilt(root) {\\n    let tilt = 0;\\n    (function postTraversal(root) {\\n        if (!root) return 0;\\n        const left = postTraversal(root.left);\\n        const right = postTraversal(root.right);\\n        \\n        tilt += Math.abs(left - right);\\n        \\n        return left + right + root.val;\\n    })(root);\\n    return tilt;\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\nfunction findTilt(root) {\\n    let tilt = 0;\\n    (function postTraversal(root) {\\n        if (!root) return 0;\\n        const left = postTraversal(root.left);\\n        const right = postTraversal(root.right);\\n        \\n        tilt += Math.abs(left - right);\\n        \\n        return left + right + root.val;\\n    })(root);\\n    return tilt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102331,
                "title": "java-o-n-postorder-traversal",
                "content": "```\\npublic class Solution {\\n    \\n    int tilt = 0;\\n    \\n    public int findTilt(TreeNode root) {\\n        postorder(root);\\n        return tilt;\\n    }\\n    \\n    public int postorder(TreeNode root) {\\n        if (root == null) return 0;\\n        int leftSum = postorder(root.left);\\n        int rightSum = postorder(root.right);\\n        tilt += Math.abs(leftSum - rightSum);\\n        return leftSum + rightSum + root.val;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    int tilt = 0;\\n    \\n    public int findTilt(TreeNode root) {\\n        postorder(root);\\n        return tilt;\\n    }\\n    \\n    public int postorder(TreeNode root) {\\n        if (root == null) return 0;\\n        int leftSum = postorder(root.left);\\n        int rightSum = postorder(root.right);\\n        tilt += Math.abs(leftSum - rightSum);\\n        return leftSum + rightSum + root.val;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400059,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\nint sum=0;\\n    int findTilt(TreeNode* root) {\\n       fun(root);\\n       return sum;\\n    }\\n     int fun(TreeNode* root){\\n         if(root==NULL){\\n             return 0;\\n         }\\n         int left=fun(root->left);\\n         int right=fun(root->right);\\n\\n         sum=sum+abs(left-right);\\n         return root->val+left+right;\\n     } \\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n\\n        self.res = 0\\n        def f(root):\\n            \\n            if not root:\\n                return 0\\n\\n            l = f(root.left)\\n            r = f(root.right)\\n\\n            self.res += abs(l - r)\\n\\n            return root.val + l + r\\n\\n        f(root)\\n\\n        return self.res\\n```\\n\\n```Java []\\nclass Solution {\\n    int sum = 0;\\n    public int dfs(TreeNode root){\\n        if( root == null) return 0;\\n        int left = dfs(root.left);\\n        int right = dfs(root.right);\\n        int res = left+right+root.val;\\n        sum+=Math.abs(left-right);\\n        root.val = Math.abs(left-right);\\n        return res;\\n    }\\n    public int dfs2(TreeNode root){\\n        if( root == null) return 0;\\n        return root.val+dfs2(root.left)+dfs2(root.right);\\n    }\\n    public int findTilt(TreeNode root) {\\n        dfs(root);\\n        return sum;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\nint sum=0;\\n    int findTilt(TreeNode* root) {\\n       fun(root);\\n       return sum;\\n    }\\n     int fun(TreeNode* root){\\n         if(root==NULL){\\n             return 0;\\n         }\\n         int left=fun(root->left);\\n         int right=fun(root->right);\\n\\n         sum=sum+abs(left-right);\\n         return root->val+left+right;\\n     } \\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n\\n        self.res = 0\\n        def f(root):\\n            \\n            if not root:\\n                return 0\\n\\n            l = f(root.left)\\n            r = f(root.right)\\n\\n            self.res += abs(l - r)\\n\\n            return root.val + l + r\\n\\n        f(root)\\n\\n        return self.res\\n```\n```Java []\\nclass Solution {\\n    int sum = 0;\\n    public int dfs(TreeNode root){\\n        if( root == null) return 0;\\n        int left = dfs(root.left);\\n        int right = dfs(root.right);\\n        int res = left+right+root.val;\\n        sum+=Math.abs(left-right);\\n        root.val = Math.abs(left-right);\\n        return res;\\n    }\\n    public int dfs2(TreeNode root){\\n        if( root == null) return 0;\\n        return root.val+dfs2(root.left)+dfs2(root.right);\\n    }\\n    public int findTilt(TreeNode root) {\\n        dfs(root);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219060,
                "title": "best-java-solution-recursive-dfs-java-accepted",
                "content": "class Solution {\\n    \\n     int tilt = 0;\\n    \\n    public int findTilt(TreeNode root) {\\n        sum(root);\\n        return tilt;\\n    }\\n    \\n    public int sum(TreeNode root){\\n        \\n        if(root == null) return 0;\\n        \\n        int lSum = sum(root.left);\\n        int rSum = sum(root.right);\\n        \\n        tilt += Math.abs(lSum - rSum);\\n        \\n        return lSum + rSum + root.val;\\n    }\\n}",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    \\n     int tilt = 0;\\n    \\n    public int findTilt(TreeNode root) {\\n        sum(root);\\n        return tilt;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1618168,
                "title": "easy-enough-with-clean-code",
                "content": "**Please Upovte,it helps a lot**\\n```\\nclass Solution {\\n    int tiltSum = 0;\\n    public int findTilt(TreeNode root) {\\n        findans(root);\\n        return tiltSum;\\n    }\\n    \\n    private int findans(TreeNode root){\\n        if(root == null) return 0;\\n        int leftSubtreeSum = findans(root.left);\\n        int rightSubtreeSum = findans(root.right);\\n        tiltSum += Math.abs(leftSubtreeSum - rightSubtreeSum); //add the tilt to tiltSum\\n        \\n        return leftSubtreeSum + rightSubtreeSum + root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int tiltSum = 0;\\n    public int findTilt(TreeNode root) {\\n        findans(root);\\n        return tiltSum;\\n    }\\n    \\n    private int findans(TreeNode root){\\n        if(root == null) return 0;\\n        int leftSubtreeSum = findans(root.left);\\n        int rightSubtreeSum = findans(root.right);\\n        tiltSum += Math.abs(leftSubtreeSum - rightSubtreeSum); //add the tilt to tiltSum\\n        \\n        return leftSubtreeSum + rightSubtreeSum + root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617385,
                "title": "recursive-solution-python",
                "content": "Time complexity: O(N) because you need to check for every element once\\nSpace complexity: O(N) because of the recursion stack\\n\\n```\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        def rec(node):\\n            nonlocal res\\n            if not node:\\n                return 0\\n            left_sum = rec(node.left)\\n            right_sum = rec(node.right)\\n            res += abs(left_sum - right_sum)\\n            \\n            return left_sum + node.val + right_sum\\n        \\n        res = 0\\n        rec(root)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        def rec(node):\\n            nonlocal res\\n            if not node:\\n                return 0\\n            left_sum = rec(node.left)\\n            right_sum = rec(node.right)\\n            res += abs(left_sum - right_sum)\\n            \\n            return left_sum + node.val + right_sum\\n        \\n        res = 0\\n        rec(root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246323,
                "title": "c-4-lines-recursion-in-order-traversal",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int treesum(TreeNode *root)\\n    {\\n        if ( !root )    return 0;\\n        return root->val + treesum(root->left) + treesum(root->right);\\n    }\\n    \\n    int findTilt(TreeNode* root) \\n    {\\n        if ( !root )    return 0;\\n        return abs(treesum(root->left)-treesum(root->right)) + findTilt(root->left) + findTilt(root->right);\\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int treesum(TreeNode *root)\\n    {\\n        if ( !root )    return 0;\\n        return root->val + treesum(root->left) + treesum(root->right);\\n    }\\n    \\n    int findTilt(TreeNode* root) \\n    {\\n        if ( !root )    return 0;\\n        return abs(treesum(root->left)-treesum(root->right)) + findTilt(root->left) + findTilt(root->right);\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233799,
                "title": "java-easy-solution-faster-than-100",
                "content": "**Do upvote if you like it :)**\\n```\\nclass Solution {\\n    \\n    public int tilt = 0;\\n    \\n    public int findTilt(TreeNode root){\\n        findTiltUtil(root);\\n        return tilt;\\n    }\\n\\n    public int findTiltUtil(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n    \\n\\t    int leftSum = findTiltUtil(root.left);\\n\\t    int rightSum = findTiltUtil(root.right);\\n\\t    tilt += Math.abs(leftSum - rightSum);\\n\\t    return leftSum + rightSum + root.val;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int tilt = 0;\\n    \\n    public int findTilt(TreeNode root){\\n        findTiltUtil(root);\\n        return tilt;\\n    }\\n\\n    public int findTiltUtil(TreeNode root) {\\n        if(root == null)\\n            return 0;\\n    \\n\\t    int leftSum = findTiltUtil(root.left);\\n\\t    int rightSum = findTiltUtil(root.right);\\n\\t    tilt += Math.abs(leftSum - rightSum);\\n\\t    return leftSum + rightSum + root.val;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929145,
                "title": "python3-straightforward-solution-binary-tree-tilt",
                "content": "```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        def dfs(root):\\n            if not root:\\n                return 0, 0\\n            ls, lt = dfs(root.left)    \\n            rs, rt = dfs(root.right)    \\n            return root.val + ls + rs, abs(ls - rs) + lt + rt\\n        return dfs(root)[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        def dfs(root):\\n            if not root:\\n                return 0, 0\\n            ls, lt = dfs(root.left)    \\n            rs, rt = dfs(root.right)    \\n            return root.val + ls + rs, abs(ls - rs) + lt + rt\\n        return dfs(root)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928984,
                "title": "python-3-postorder-traversal",
                "content": "```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        \"\"\"\\n        Given the root to a binary tree, this program determines\\n        the tilt of the tree. In order to compute the tilt, this\\n        program recursively computes the sum of the nodes in each\\n        subtree.\\n\\n        :param root: root to a binary tree\\n        :type root: TreeNode\\n        :return: tilt value of binary tree\\n        :rtype: int\\n        \"\"\"\\n        self.tilt = 0\\n\\n        def compute_sum(root: TreeNode) -> int:\\n            \"\"\"\\n            This program recursively computes the sum of each\\n            subtree in the tree passed to this program.  It uses\\n            the subtree sums to determine the tilt of the tree.\\n\\n            :param root: root to a tree or subtree\\n            :type root: TreeNode\\n            :return: subtree sum\\n            :rtype: int\\n            \"\"\"\\n            if root == None:\\n                return 0\\n            left_sum = compute_sum(root.left)\\n            right_sum = compute_sum(root.right)\\n            self.tilt += abs(left_sum - right_sum)\\n            tree_sum = left_sum + root.val + right_sum\\n            return tree_sum\\n\\n        compute_sum(root)\\n        return self.tilt\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        \"\"\"\\n        Given the root to a binary tree, this program determines\\n        the tilt of the tree. In order to compute the tilt, this\\n        program recursively computes the sum of the nodes in each\\n        subtree.\\n\\n        :param root: root to a binary tree\\n        :type root: TreeNode\\n        :return: tilt value of binary tree\\n        :rtype: int\\n        \"\"\"\\n        self.tilt = 0\\n\\n        def compute_sum(root: TreeNode) -> int:\\n            \"\"\"\\n            This program recursively computes the sum of each\\n            subtree in the tree passed to this program.  It uses\\n            the subtree sums to determine the tilt of the tree.\\n\\n            :param root: root to a tree or subtree\\n            :type root: TreeNode\\n            :return: subtree sum\\n            :rtype: int\\n            \"\"\"\\n            if root == None:\\n                return 0\\n            left_sum = compute_sum(root.left)\\n            right_sum = compute_sum(root.right)\\n            self.tilt += abs(left_sum - right_sum)\\n            tree_sum = left_sum + root.val + right_sum\\n            return tree_sum\\n\\n        compute_sum(root)\\n        return self.tilt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928052,
                "title": "clean-java-bottom-up-solution-with-explanation-one-pass-0ms-100",
                "content": "Here is a basic idea of the solution. You iterate through every node of the tree and determine two key factor of the sub-tree. \\n\\n1. The total tilt of the subtree\\n2. The total sum of the subtree (including the current node)  \\n \\nAfter determining the 2 key factor, you can determine a relationship between the parent and the children node when computing the 2 factor.\\nOne thing to notice is that \\n`total tilt = left total tilt + right total tilt + abs(left sum - right sum)`\\nAnother thing you notice is that the total sum also have a simular relationship\\n`total sum = left sum + right sum + current node value`\\nThis relationship makes it perfect for bottom up approach which can be implemented using post order traversal. For my implementation, I used the recursive approach.\\nHere is the code\\n```\\nclass Solution {\\n    public int findTilt(TreeNode root) {\\n        return helper(root)[0];\\n    }\\n    // [tilt, node-sum]\\n    public int[] helper(TreeNode root){\\n        int[] res = {0,0};\\n        if(root == null) return res;\\n        int[] left = helper(root.left);\\n        int[] right = helper(root.right);\\n        res[0] = left[0] + right[0] + Math.abs(left[1]-right[1]);\\n        res[1] = left[1] + right[1] + root.val;\\n        return res;\\n    }\\n}\\n```\\nIf you enjoyed this explaination, feel free to **upvote it** and leave a **comment** if you have any question. I will be happy to answer.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int findTilt(TreeNode root) {\\n        return helper(root)[0];\\n    }\\n    // [tilt, node-sum]\\n    public int[] helper(TreeNode root){\\n        int[] res = {0,0};\\n        if(root == null) return res;\\n        int[] left = helper(root.left);\\n        int[] right = helper(root.right);\\n        res[0] = left[0] + right[0] + Math.abs(left[1]-right[1]);\\n        res[1] = left[1] + right[1] + root.val;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928017,
                "title": "rust-tuple-solution-0-ms-2-6-mb",
                "content": "```rust\\npub fn find_tilt(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n\\tlet (_, tilt) = Solution::step(&root);\\n\\ttilt\\n}\\n\\n// step does a step in dfs, returns sum of tree values and sum of tree tilts.\\nfn step(node: &Option<Rc<RefCell<TreeNode>>>) -> (i32, i32) {\\n\\tlet node = match node {\\n\\t\\tSome(node) => node.borrow(),\\n\\t\\tNone => return (0, 0),\\n\\t};\\n\\n\\tlet (left_sum, left_tilt) = Solution::step(&node.left);\\n\\tlet (right_sum, right_tilt) = Solution::step(&node.right);\\n\\n\\t(\\n\\t\\tnode.val + left_sum + right_sum,\\n\\t\\t(left_sum - right_sum).abs() + left_tilt + right_tilt,\\n\\t)\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\npub fn find_tilt(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n\\tlet (_, tilt) = Solution::step(&root);\\n\\ttilt\\n}\\n\\n// step does a step in dfs, returns sum of tree values and sum of tree tilts.\\nfn step(node: &Option<Rc<RefCell<TreeNode>>>) -> (i32, i32) {\\n\\tlet node = match node {\\n\\t\\tSome(node) => node.borrow(),\\n\\t\\tNone => return (0, 0),\\n\\t};\\n\\n\\tlet (left_sum, left_tilt) = Solution::step(&node.left);\\n\\tlet (right_sum, right_tilt) = Solution::step(&node.right);\\n\\n\\t(\\n\\t\\tnode.val + left_sum + right_sum,\\n\\t\\t(left_sum - right_sum).abs() + left_tilt + right_tilt,\\n\\t)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 479288,
                "title": "rust",
                "content": "```rust\\nimpl Solution {\\n    pub fn find_tilt(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut s = 0;\\n        Self::h(&root, &mut s);\\n        s\\n    }\\n\\n    fn h(n: &Option<Rc<RefCell<TreeNode>>>, s: &mut i32) -> i32 {\\n        if let Some(n) = n {\\n            let n = n.borrow();\\n            let l = Self::h(&n.left, s);\\n            let r = Self::h(&n.right, s);\\n            *s += (l - r).abs();\\n            n.val + l + r\\n        } else {\\n            0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn find_tilt(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut s = 0;\\n        Self::h(&root, &mut s);\\n        s\\n    }\\n\\n    fn h(n: &Option<Rc<RefCell<TreeNode>>>, s: &mut i32) -> i32 {\\n        if let Some(n) = n {\\n            let n = n.borrow();\\n            let l = Self::h(&n.left, s);\\n            let r = Self::h(&n.right, s);\\n            *s += (l - r).abs();\\n            n.val + l + r\\n        } else {\\n            0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 365734,
                "title": "simple-javascript-solution-faster-than-99-63",
                "content": "```javascript\\nvar findTilt = function(root) {\\n    function postOrderTraversal(node) {\\n        if(!node) return 0\\n        const sumOfLeft = postOrderTraversal(node.left)\\n        const sumOfRight = postOrderTraversal(node.right)\\n        ans += Math.abs(sumOfLeft - sumOfRight)\\n        return sumOfLeft + sumOfRight + node.val\\n    }\\n    let ans = 0\\n    postOrderTraversal(root)\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\nvar findTilt = function(root) {\\n    function postOrderTraversal(node) {\\n        if(!node) return 0\\n        const sumOfLeft = postOrderTraversal(node.left)\\n        const sumOfRight = postOrderTraversal(node.right)\\n        ans += Math.abs(sumOfLeft - sumOfRight)\\n        return sumOfLeft + sumOfRight + node.val\\n    }\\n    let ans = 0\\n    postOrderTraversal(root)\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 263156,
                "title": "java-simple-but-stupid-solution-to-a-stupid-question-three-1-liner-recursive-methods",
                "content": "This problem is very badly stated, because they use two different contradictory definitions for the same term, the \"tilt\" of a tree.  They should have used two different terms for the 2 different things.  Anyway, I just used 2 different methods, one to actually get the \"tilt\" per the first definition, and the other to get the other \"tilt\" per the second definition.  The recursive functions fall naturally out of the defininitions, as long as you\\'re extra careful to be sure which contradictory definition they\\'re talking about.\\n\\nYes, this isn\\'t the most efficient implementation, but I don\\'t care because it\\'s a stupid problem.  When they put more time into writing their problem, I\\'ll put more time into writing my answer.\\n```\\n    public int findTilt(TreeNode root) {\\n        return actuallyFindTiltOfTree(root)+((root==null)?0:findTilt(root.left)+findTilt(root.right));\\n    }\\n    \\n    public int actuallyFindTiltOfTree(TreeNode root) {\\n        return root==null?0:Math.abs(sum(root.left)-sum(root.right));\\n    }\\n    \\n    public int sum(TreeNode root) {\\n        return root==null?0:root.val+sum(root.left)+sum(root.right);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findTilt(TreeNode root) {\\n        return actuallyFindTiltOfTree(root)+((root==null)?0:findTilt(root.left)+findTilt(root.right));\\n    }\\n    \\n    public int actuallyFindTiltOfTree(TreeNode root) {\\n        return root==null?0:Math.abs(sum(root.left)-sum(root.right));\\n    }\\n    \\n    public int sum(TreeNode root) {\\n        return root==null?0:root.val+sum(root.left)+sum(root.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 207722,
                "title": "python-solution",
                "content": "Time complexity: O(n), space complexity: O(h)\\n```\\nclass Solution:\\n    def findTilt(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0, 0\\n            l = dfs(root.left)\\n            r = dfs(root.right)\\n            tilt = abs(l[1]-r[1])\\n            return l[0]+r[0]+tilt,l[1]+r[1]+root.val\\n        return dfs(root)[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0, 0\\n            l = dfs(root.left)\\n            r = dfs(root.right)\\n            tilt = abs(l[1]-r[1])\\n            return l[0]+r[0]+tilt,l[1]+r[1]+root.val\\n        return dfs(root)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644852,
                "title": "c-efficient-solution-100-faster-0ms-runtime",
                "content": "***RECURSIVE POSTORDER TRAVERSAL :\\nTime Complexity : O(n)\\nSpace Complexity : O(n)***\\n\\n**UPVOTE IF YOU LIKE** \\uD83D\\uDE0A\\u2705\\n```\\nclass Solution {\\npublic:\\n    int solve(TreeNode*root,int &res){\\n        if(!root)return 0;\\n        int left=solve(root->left,res);   // \\u2190 \\u2190 \\u2190 get left subtree sum\\n        int right=solve(root->right,res); // \\u2190 \\u2190 \\u2190 get right subtree sum\\n        res+=abs(right-left);             // \\u2190 \\u2190 \\u2190 add tilt to the result\\n        return left+right+root->val;      // \\u2190 \\u2190 \\u2190 return the subtree sum \\u2B50\\n    }\\n    int findTilt(TreeNode* root) {\\n        if(!root)return 0;\\n        int res=0;\\n        solve(root,res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode*root,int &res){\\n        if(!root)return 0;\\n        int left=solve(root->left,res);   // \\u2190 \\u2190 \\u2190 get left subtree sum\\n        int right=solve(root->right,res); // \\u2190 \\u2190 \\u2190 get right subtree sum\\n        res+=abs(right-left);             // \\u2190 \\u2190 \\u2190 add tilt to the result\\n        return left+right+root->val;      // \\u2190 \\u2190 \\u2190 return the subtree sum \\u2B50\\n    }\\n    int findTilt(TreeNode* root) {\\n        if(!root)return 0;\\n        int res=0;\\n        solve(root,res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989755,
                "title": "easy-and-intutive-approach-using-dfs-traversal-clean-c-solution",
                "content": "**Easy approach using DFS :**\\n\\nclass Solution {\\n\\n```\\npublic:\\n    int ans = 0;\\n    int helper(TreeNode* root){\\n        if(!root){\\n            return 0;\\n        }\\n        \\n        int leftsum = helper(root -> left);\\n        int rightsum = helper(root -> right);\\n        \\n        ans += abs(leftsum - rightsum);\\n        return leftsum + rightsum + root->val; \\n    }\\n    int findTilt(TreeNode* root) {\\n         helper(root);\\n         return ans;\\n    }\\n```\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\npublic:\\n    int ans = 0;\\n    int helper(TreeNode* root){\\n        if(!root){\\n            return 0;\\n        }\\n        \\n        int leftsum = helper(root -> left);\\n        int rightsum = helper(root -> right);\\n        \\n        ans += abs(leftsum - rightsum);\\n        return leftsum + rightsum + root->val; \\n    }\\n    int findTilt(TreeNode* root) {\\n         helper(root);\\n         return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786013,
                "title": "c-code-easy-to-understand-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint ans = 0;\\n\\tint findTilt(TreeNode* root) {\\n\\t\\tsum(root);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tint sum(TreeNode* root)\\n\\t{\\n\\t\\tif (!root) return 0;\\n\\t\\tint left = sum(root->left);\\n\\t\\tint right = sum(root->right);\\n\\t\\tans += abs(left - right);\\n\\t\\treturn (left + right + root->val);\\n\\t}\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\tint ans = 0;\\n\\tint findTilt(TreeNode* root) {\\n\\t\\tsum(root);\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1641294,
                "title": "js-post-order-recursive-dfs",
                "content": "Linear time, logarithmic space:\\n```javascript\\nfunction findTilt(root) {\\n    return dfs(root).tilt;\\n}\\n\\nfunction dfs(root) {\\n    if (!root) {\\n        return {tilt: 0, sum: 0};\\n    }\\n\\n    const left = dfs(root.left);\\n    const right = dfs(root.right);\\n\\n    return {\\n        tilt: Math.abs(left.sum - right.sum) + left.tilt + right.tilt,\\n        sum: root.val + left.sum + right.sum\\n    };\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```javascript\\nfunction findTilt(root) {\\n    return dfs(root).tilt;\\n}\\n\\nfunction dfs(root) {\\n    if (!root) {\\n        return {tilt: 0, sum: 0};\\n    }\\n\\n    const left = dfs(root.left);\\n    const right = dfs(root.right);\\n\\n    return {\\n        tilt: Math.abs(left.sum - right.sum) + left.tilt + right.tilt,\\n        sum: root.val + left.sum + right.sum\\n    };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1617999,
                "title": "swift-binary-tree-tilt",
                "content": "```swift\\nclass Solution {\\n    func findTilt(_ root: TreeNode?) -> Int {\\n        guard root != nil else { return 0 }\\n        var value = 0\\n        dfs(root, &value)\\n        return value\\n    }\\n    private func dfs(_ root: TreeNode?, _ val: inout Int) {\\n        guard let root = root else { return }\\n        dfs(root.left, &val)\\n        dfs(root.right, &val)\\n        val += abs((root.left?.val ?? 0) - (root.right?.val ?? 0))\\n        root.val += (root.left?.val ?? 0) + (root.right?.val ?? 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func findTilt(_ root: TreeNode?) -> Int {\\n        guard root != nil else { return 0 }\\n        var value = 0\\n        dfs(root, &value)\\n        return value\\n    }\\n    private func dfs(_ root: TreeNode?, _ val: inout Int) {\\n        guard let root = root else { return }\\n        dfs(root.left, &val)\\n        dfs(root.right, &val)\\n        val += abs((root.left?.val ?? 0) - (root.right?.val ?? 0))\\n        root.val += (root.left?.val ?? 0) + (root.right?.val ?? 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617379,
                "title": "java-easy-clean-and-concise-recursive-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public int findTilt(TreeNode root) {\\n        find(root);\\n        return ans;\\n    }\\n    \\n    public int find(TreeNode root){\\n        if(root == null)\\n            return 0;\\n        int left = find(root.left);\\n        int right = find(root.right);\\n        ans += Math.abs(left - right);\\n        return left + right + root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int findTilt(TreeNode root) {\\n        find(root);\\n        return ans;\\n    }\\n    \\n    public int find(TreeNode root){\\n        if(root == null)\\n            return 0;\\n        int left = find(root.left);\\n        int right = find(root.right);\\n        ans += Math.abs(left - right);\\n        return left + right + root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543738,
                "title": "c-video-explanation-clean-code",
                "content": "**Look in comment section for *Video Solution***\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int helper(TreeNode* root){\\n        if(!root)\\n          return 0;\\n\\n        // Faith : will return left\\'s sum and change ans for left side\\n        int ls = helper(root->left);\\n        // Faith : will return right\\'s sum and change ans for right side\\n        int rs = helper(root->right);\\n\\n        int ltilt = abs(ls - rs);\\n        ans += ltilt;\\n        int sum = ls + rs + root->val;\\n        return sum;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int helper(TreeNode* root){\\n        if(!root)\\n          return 0;\\n\\n        // Faith : will return left\\'s sum and change ans for left side\\n        int ls = helper(root->left);\\n        // Faith : will return right\\'s sum and change ans for right side\\n        int rs = helper(root->right);\\n\\n        int ltilt = abs(ls - rs);\\n        ans += ltilt;\\n        int sum = ls + rs + root->val;\\n        return sum;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413081,
                "title": "java-solution-100-faster",
                "content": "```\\nclass Solution {\\n  \\n  int sum=0;\\n    public int findTilt(TreeNode root) {\\n    \\n      find(root);\\n      return sum;\\n    }\\n  \\n  int find(TreeNode root)\\n  {\\n    if(root==null)\\n      return 0;\\n    \\n    int ls=find(root.left);\\n    int rs=find(root.right);\\n    \\n    sum+=Math.abs(ls-rs);\\n    \\n    return ls+rs+root.val;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  \\n  int sum=0;\\n    public int findTilt(TreeNode root) {\\n    \\n      find(root);\\n      return sum;\\n    }\\n  \\n  int find(TreeNode root)\\n  {\\n    if(root==null)\\n      return 0;\\n    \\n    int ls=find(root.left);\\n    int rs=find(root.right);\\n    \\n    sum+=Math.abs(ls-rs);\\n    \\n    return ls+rs+root.val;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240226,
                "title": "simple-recursive-o-n-time-space-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTilt(TreeNode* root) {\\n        int ans=0;\\n        findSum(root,ans);\\n        return ans;\\n    }\\n    \\n    int findSum(TreeNode* root, int& ans){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int x = root->val;\\n        int a = findSum(root->left,ans);\\n        int b = findSum(root->right,ans);\\n        root->val = abs(a-b);\\n        ans+=root->val;\\n        return a+b+x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTilt(TreeNode* root) {\\n        int ans=0;\\n        findSum(root,ans);\\n        return ans;\\n    }\\n    \\n    int findSum(TreeNode* root, int& ans){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int x = root->val;\\n        int a = findSum(root->left,ans);\\n        int b = findSum(root->right,ans);\\n        root->val = abs(a-b);\\n        ans+=root->val;\\n        return a+b+x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220490,
                "title": "6-line-easy-code-easy-to-understand",
                "content": "int sum=0;\\n    int rec(TreeNode *root) {\\n        if(root == NULL) return 0;\\n        \\n        int l = rec(root->left);\\n        int r = rec(root->right);\\n        sum += abs(l-r);\\n        return root->val + l + r;\\n    }\\n    int findTilt(TreeNode* root) {\\n        sum=0;\\n        // check(root);\\n        rec(root);\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "int sum=0;\\n    int rec(TreeNode *root) {\\n        if(root == NULL) return 0;\\n        \\n        int l = rec(root->left);\\n        int r = rec(root->right);\\n        sum += abs(l-r);\\n        return root->val + l + r;\\n    }\\n    int findTilt(TreeNode* root) {\\n        sum=0;\\n        // check(root);\\n        rec(root);\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1215970,
                "title": "c-postorder-traversal-o-n-beats-91-72",
                "content": "**Explaination**\\n\\nTraverse the tree in post order manner.\\nInitialized our resultant `res` variable.\\nUpdate tree node values (except leaf nodes as they don\\'t have any contribution in our result) with `left.val + right.val + self.val` and add up our `res` variable by `abs(left.val - right.val)`\\nIf either of nodes are not present `res += present node val` and `node.val += present node val`\\n\\n**Complexity**\\n\\nTime `O(n)`\\nSpace `O(heightofStack)`\\n\\n**C++ Code**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int res = 0;\\n    \\n    void postOrder(TreeNode* root) {\\n        if(root) {\\n            postOrder(root->left);\\n            postOrder(root->right);\\n            if(root->left && root->right) {\\n                res += abs(root->left->val - root->right->val);\\n                root->val += root->left->val + root->right->val;\\n            } else if(root->left && !root->right) {\\n                res += abs(root->left->val);\\n                root->val += root->left->val;\\n            } else if(!root->left && root->right) {\\n                res += abs(root->right->val);\\n                root->val += root->right->val;\\n            }\\n        }\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        postOrder(root);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int res = 0;\\n    \\n    void postOrder(TreeNode* root) {\\n        if(root) {\\n            postOrder(root->left);\\n            postOrder(root->right);\\n            if(root->left && root->right) {\\n                res += abs(root->left->val - root->right->val);\\n                root->val += root->left->val + root->right->val;\\n            } else if(root->left && !root->right) {\\n                res += abs(root->left->val);\\n                root->val += root->left->val;\\n            } else if(!root->left && root->right) {\\n                res += abs(root->right->val);\\n                root->val += root->right->val;\\n            }\\n        }\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        postOrder(root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1209453,
                "title": "python-3-pure-recursion",
                "content": "\\n\\tclass Solution:\\n\\t\\tdef findTilt(self, root: TreeNode) -> int:\\n\\t\\t\\treturn self.traverse(root)[1]\\n\\n\\t\\tdef traverse(self,root):\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn 0,0\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\tlvsum & rvsum --> Sum of **values** all left and right children nodes respectively\\n\\t\\t\\tltsum & rtsum --> Sum of **tilt** of all left and right children nodes respectively  \\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\tlvsum,ltsum = self.traverse(root.left)\\n\\t\\t\\trvsum,rtsum = self.traverse(root.right)\\n\\t\\t\\tval_sum = root.val+lvsum+rvsum\\n\\t\\t\\ttilt_sum = ltsum + rtsum + abs(lvsum - rvsum)\\n\\t\\t\\treturn val_sum,tilt_sum",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "\\n\\tclass Solution:\\n\\t\\tdef findTilt(self, root: TreeNode) -> int:\\n\\t\\t\\treturn self.traverse(root)[1]\\n\\n\\t\\tdef traverse(self,root):\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn 0,0\\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\tlvsum & rvsum --> Sum of **values** all left and right children nodes respectively\\n\\t\\t\\tltsum & rtsum --> Sum of **tilt** of all left and right children nodes respectively  \\n\\t\\t\\t\\'\\'\\'\\n\\t\\t\\tlvsum,ltsum = self.traverse(root.left)\\n\\t\\t\\trvsum,rtsum = self.traverse(root.right)\\n\\t\\t\\tval_sum = root.val+lvsum+rvsum\\n\\t\\t\\ttilt_sum = ltsum + rtsum + abs(lvsum - rvsum)\\n\\t\\t\\treturn val_sum,tilt_sum",
                "codeTag": "Java"
            },
            {
                "id": 1170996,
                "title": "python-easy-solution",
                "content": "```\\ndef findTilt(self, root: TreeNode) -> int:\\n        tilt = [0]\\n        self.helper(root,tilt)\\n        return tilt[0]\\n    \\n    \\n    def helper(self,root,tilt):\\n        if root is None:\\n            return 0\\n        if root.left is root.right:\\n            return root.val\\n        lt = self.helper(root.left,tilt)\\n        rt = self.helper(root.right,tilt)\\n        tilt[0] = tilt[0]+abs(lt-rt)\\n        return lt+rt+root.val\\n```\\nGuys please if you got any problem do let me know. Someone is systematically downvoting the solutions.",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\ndef findTilt(self, root: TreeNode) -> int:\\n        tilt = [0]\\n        self.helper(root,tilt)\\n        return tilt[0]\\n    \\n    \\n    def helper(self,root,tilt):\\n        if root is None:\\n            return 0\\n        if root.left is root.right:\\n            return root.val\\n        lt = self.helper(root.left,tilt)\\n        rt = self.helper(root.right,tilt)\\n        tilt[0] = tilt[0]+abs(lt-rt)\\n        return lt+rt+root.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1095778,
                "title": "java-faster-and-simpler-than-100",
                "content": "[JAVA] faster and simpler than 100%\\n```\\nint sum=0;\\n    public int findTilt(TreeNode root) {\\n        sumTilt(root);\\n        return sum;\\n    }\\n    \\n    public int sumTilt(TreeNode root){\\n        if(root == null) return 0;\\n        int l = sumTilt(root.left);\\n        int r = sumTilt(root.right);\\n        sum += Math.abs(l-r);\\n        return root.val + l + r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint sum=0;\\n    public int findTilt(TreeNode root) {\\n        sumTilt(root);\\n        return sum;\\n    }\\n    \\n    public int sumTilt(TreeNode root){\\n        if(root == null) return 0;\\n        int l = sumTilt(root.left);\\n        int r = sumTilt(root.right);\\n        sum += Math.abs(l-r);\\n        return root.val + l + r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1053460,
                "title": "simple-java-solution-thread-safety",
                "content": "```\\nclass Solution {\\n    // int sum = 0; // it\\'s not thread-safety way\\n    public int findTilt(TreeNode root) {\\n        int[] sum = new int[1];\\n        search(root, sum);\\n        return sum[0];\\n    }\\n\\n    public int search(TreeNode root, int[] sum) {\\n        if(root == null) return 0;\\n        int leftSum = search(root.left, sum);\\n        int rightSum = search(root.right, sum);\\n        sum[0] += leftSum < rightSum ? rightSum - leftSum : leftSum - rightSum;\\n        return leftSum + rightSum + root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    // int sum = 0; // it\\'s not thread-safety way\\n    public int findTilt(TreeNode root) {\\n        int[] sum = new int[1];\\n        search(root, sum);\\n        return sum[0];\\n    }\\n\\n    public int search(TreeNode root, int[] sum) {\\n        if(root == null) return 0;\\n        int leftSum = search(root.left, sum);\\n        int rightSum = search(root.right, sum);\\n        sum[0] += leftSum < rightSum ? rightSum - leftSum : leftSum - rightSum;\\n        return leftSum + rightSum + root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934982,
                "title": "c-4ms-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int calculate_tilt(TreeNode* node, int& sum) {\\n        if (!node)\\n            return 0;\\n        \\n        int leftVal = calculate_tilt(node->left, sum);\\n        int rightVal = calculate_tilt(node->right, sum);\\n        \\n        sum += abs(leftVal - rightVal);\\n        return leftVal + rightVal + node->val;\\n    }\\n    \\npublic:\\n    int findTilt(TreeNode* root) {\\n        int sum = 0;\\n        calculate_tilt(root, sum);\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\nprivate:\\n    int calculate_tilt(TreeNode* node, int& sum) {\\n        if (!node)\\n            return 0;\\n        \\n        int leftVal = calculate_tilt(node->left, sum);\\n        int rightVal = calculate_tilt(node->right, sum);\\n        \\n        sum += abs(leftVal - rightVal);\\n        return leftVal + rightVal + node->val;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 929067,
                "title": "clean-c-recursion-minimum-lines-2-step-method-find-the-sums-find-the-differences",
                "content": "The comments explain everything\\n\\nFirst we replace each node by the sum of it\\'s sub tree\\n\\nThen we travel the tree and find the differences ( to do traveling in one line I have written that coonfusing part where tilt returns the sum, just felt lazy to write cases for left child right child etc, but you can do that for cleaner code)\\n\\n```\\nclass Solution {\\npublic:\\n    int totalTilt;\\n    \\n    int summer(TreeNode *root) {\\n        if (not root) return 0;\\n\\n        return root->val += summer(root->left) + summer(root->right);\\n    }\\n    \\n    int tilt(TreeNode *root) {\\n        if (not root) return 0;\\n        \\n        totalTilt += abs(tilt(root->left) - tilt(root->right));\\n        // this might be a little confusing, but I am making the subsequent calls and returning the \\n        // SUM of the subtrees, so it is like a two in one (no need to check if not ->left, not ->right)\\n        // everything get\\'s validated recursively by the if (not root) statement\\n        return root->val;\\n    }\\n    \\n    int findTilt(TreeNode *root) {\\n        // first replace all values by the sum\\n        summer(root);\\n        \\n        // now travel the tree and find the tilt of each root\\n        totalTilt = 0;\\n        tilt(root);\\n        return totalTilt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalTilt;\\n    \\n    int summer(TreeNode *root) {\\n        if (not root) return 0;\\n\\n        return root->val += summer(root->left) + summer(root->right);\\n    }\\n    \\n    int tilt(TreeNode *root) {\\n        if (not root) return 0;\\n        \\n        totalTilt += abs(tilt(root->left) - tilt(root->right));\\n        // this might be a little confusing, but I am making the subsequent calls and returning the \\n        // SUM of the subtrees, so it is like a two in one (no need to check if not ->left, not ->right)\\n        // everything get\\'s validated recursively by the if (not root) statement\\n        return root->val;\\n    }\\n    \\n    int findTilt(TreeNode *root) {\\n        // first replace all values by the sum\\n        summer(root);\\n        \\n        // now travel the tree and find the tilt of each root\\n        totalTilt = 0;\\n        tilt(root);\\n        return totalTilt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928762,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        self.total = 0\\n        \\n        def dfs(node):\\n            if not node:\\n                return 0\\n            l = dfs(node.left)\\n            r = dfs(node.right)\\n            self.total += abs(l - r)\\n            return l + r + node.val\\n        \\n        dfs(root)\\n        return self.total\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        self.total = 0\\n        \\n        def dfs(node):\\n            if not node:\\n                return 0\\n            l = dfs(node.left)\\n            r = dfs(node.right)\\n            self.total += abs(l - r)\\n            return l + r + node.val\\n        \\n        dfs(root)\\n        return self.total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928651,
                "title": "binary-tree-tilt-java",
                "content": "```\\nclass Solution \\n{\\n    /* For the most part the solution is just a recursive method used to sum up the value of all \\n     * the nodes in the tree.  In addition the recursive method accepts a parameter which is a \\n     * single cell int array used to collect the sum of tilts.  The single cell array is simply a\\n     * way to get around Java\\'s restriction on pass by reference and allow the value to be passed\\n     * back out while the method is returning the sum of node values.\\n     *\\n     * Additionally a non-recursive method with the same name, but different signature, exists as\\n     * a clean way to create the single cell array and transition away from the sum of nodes to\\n     * returning the sum of tilts which is the value we wish to discover.\\n     */\\n    \\n    public int findTilt(TreeNode root) \\n    {\\n        return process( root );\\n    }\\n    \\n    // --- Non-recursive method to transition from sum of nodes to sum of tilts ---\\n    \\n    private static int process( TreeNode root )\\n    {\\n        if( root == null )  return 0;\\n    \\n        int[]   tlt = { 0 };\\n        int     l   = process( root.left,  tlt );\\n        int     r   = process( root.right, tlt );\\n        \\n        return tlt[ 0 ] += Math.abs( l - r );\\n    }\\n    \\n    // --- Recursive method to return sum of nodes and update sum of tilts ---\\n    \\n    private static int process( TreeNode root, int[] tlt )\\n    {\\n        if( root == null )  return 0;\\n        \\n        int     l = process( root.left,  tlt );\\n        int     r = process( root.right, tlt );\\n        \\n        tlt[ 0 ] += Math.abs( l - r );\\n        \\n        return l + r + root.val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    /* For the most part the solution is just a recursive method used to sum up the value of all \\n     * the nodes in the tree.  In addition the recursive method accepts a parameter which is a \\n     * single cell int array used to collect the sum of tilts.  The single cell array is simply a\\n     * way to get around Java\\'s restriction on pass by reference and allow the value to be passed\\n     * back out while the method is returning the sum of node values.\\n     *\\n     * Additionally a non-recursive method with the same name, but different signature, exists as\\n     * a clean way to create the single cell array and transition away from the sum of nodes to\\n     * returning the sum of tilts which is the value we wish to discover.\\n     */\\n    \\n    public int findTilt(TreeNode root) \\n    {\\n        return process( root );\\n    }\\n    \\n    // --- Non-recursive method to transition from sum of nodes to sum of tilts ---\\n    \\n    private static int process( TreeNode root )\\n    {\\n        if( root == null )  return 0;\\n    \\n        int[]   tlt = { 0 };\\n        int     l   = process( root.left,  tlt );\\n        int     r   = process( root.right, tlt );\\n        \\n        return tlt[ 0 ] += Math.abs( l - r );\\n    }\\n    \\n    // --- Recursive method to return sum of nodes and update sum of tilts ---\\n    \\n    private static int process( TreeNode root, int[] tlt )\\n    {\\n        if( root == null )  return 0;\\n        \\n        int     l = process( root.left,  tlt );\\n        int     r = process( root.right, tlt );\\n        \\n        tlt[ 0 ] += Math.abs( l - r );\\n        \\n        return l + r + root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928398,
                "title": "python-solution-with-recurrence-relation",
                "content": "```\\n\"\"\"\\nF(node) = Sum of all node-values in subtree starting with node                \\n\\nBase case:  F(none) = 0\\nRecurrence: F(node) = node.val + F(node.left) + F(node.right)\\n\\ntilt(node) = abs(F(node.left) - F(node.right))\\n\\nGobal Variable: tilt_sum = sum of tilts of all node in tree\\n\\nNote: F(node) != sum of tilts\\n\"\"\"\\n\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n           \\n        def recurse(node):\\n            nonlocal tilt_sum\\n            if not node: return 0\\n\\n            left_sum  = recurse(node.left)\\n            right_sum = recurse(node.right)\\n            \\n            tilt_sum += abs(left_sum - right_sum)\\n            \\n            return node.val + left_sum + right_sum\\n        \\n        tilt_sum = 0\\n        recurse(root)\\n        return tilt_sum\\n",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nF(node) = Sum of all node-values in subtree starting with node                \\n\\nBase case:  F(none) = 0\\nRecurrence: F(node) = node.val + F(node.left) + F(node.right)\\n\\ntilt(node) = abs(F(node.left) - F(node.right))\\n\\nGobal Variable: tilt_sum = sum of tilts of all node in tree\\n\\nNote: F(node) != sum of tilts\\n\"\"\"\\n\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n           \\n        def recurse(node):\\n            nonlocal tilt_sum\\n            if not node: return 0\\n\\n            left_sum  = recurse(node.left)\\n            right_sum = recurse(node.right)\\n            \\n            tilt_sum += abs(left_sum - right_sum)\\n            \\n            return node.val + left_sum + right_sum\\n        \\n        tilt_sum = 0\\n        recurse(root)\\n        return tilt_sum\\n",
                "codeTag": "Java"
            },
            {
                "id": 928283,
                "title": "using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTiltSum(TreeNode *root, \\n                    int &tilt) {\\n        if(!root)\\n            return 0;\\n        int left = findTiltSum(root->left, tilt);\\n        int right = findTiltSum(root->right, tilt);\\n        \\n        // compute current tilt sum\\n        tilt += abs(left - right);\\n        return left + right + root->val;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        int tilt = 0;\\n        findTiltSum(root, tilt);\\n        return tilt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTiltSum(TreeNode *root, \\n                    int &tilt) {\\n        if(!root)\\n            return 0;\\n        int left = findTiltSum(root->left, tilt);\\n        int right = findTiltSum(root->right, tilt);\\n        \\n        // compute current tilt sum\\n        tilt += abs(left - right);\\n        return left + right + root->val;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        int tilt = 0;\\n        findTiltSum(root, tilt);\\n        return tilt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928066,
                "title": "too-easy-do-it-iteratively",
                "content": "```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        \\n        EMPTY = None\\n        \\n        stack = [[root, EMPTY, EMPTY]]\\n        ans = 0\\n        \\n        while stack:\\n            node, left, right = stack[-1]\\n            \\n            if left == EMPTY:\\n                if node.left:\\n                    stack.append([node.left, EMPTY, EMPTY])\\n                else:\\n                    stack[-1][1] = 0\\n            elif right == EMPTY:\\n                if node.right:\\n                    stack.append([node.right, EMPTY, EMPTY])\\n                else:\\n                    stack[-1][2] = 0\\n            else:\\n                node, left, right = stack.pop()\\n                ans += abs(left - right)\\n                \\n                if not stack:\\n                    break\\n                \\n                subtree_sum = node.val + left + right\\n                \\n                if stack[-1][1] == EMPTY:\\n                    stack[-1][1] = subtree_sum\\n                else:\\n                    stack[-1][2] = subtree_sum\\n                    \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        \\n        EMPTY = None\\n        \\n        stack = [[root, EMPTY, EMPTY]]\\n        ans = 0\\n        \\n        while stack:\\n            node, left, right = stack[-1]\\n            \\n            if left == EMPTY:\\n                if node.left:\\n                    stack.append([node.left, EMPTY, EMPTY])\\n                else:\\n                    stack[-1][1] = 0\\n            elif right == EMPTY:\\n                if node.right:\\n                    stack.append([node.right, EMPTY, EMPTY])\\n                else:\\n                    stack[-1][2] = 0\\n            else:\\n                node, left, right = stack.pop()\\n                ans += abs(left - right)\\n                \\n                if not stack:\\n                    break\\n                \\n                subtree_sum = node.val + left + right\\n                \\n                if stack[-1][1] == EMPTY:\\n                    stack[-1][1] = subtree_sum\\n                else:\\n                    stack[-1][2] = subtree_sum\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898422,
                "title": "rust-0ms-100",
                "content": "```rust\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nimpl Solution {\\n    pub fn find_tilt(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        fn traverse(root: &Option<Rc<RefCell<TreeNode>>>, ans: &mut i32) -> i32 {\\n            match root {\\n                Some(node) => {\\n                    let node = node.borrow();\\n                    let left = traverse(&node.left, ans);\\n                    let right = traverse(&node.right, ans);\\n                    *ans += (left - right).abs();\\n                    left + right + node.val\\n                }\\n                None => 0,\\n            }\\n        }\\n        let mut ans = 0;\\n        traverse(&root, &mut ans);\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_find_tilt() {\\n        let root = Some(Rc::new(RefCell::new(TreeNode {\\n            val: 1,\\n            left: Some(Rc::new(RefCell::new(TreeNode {\\n                val: 2,\\n                left: None,\\n                right: None,\\n            }))),\\n            right: Some(Rc::new(RefCell::new(TreeNode::new(3)))),\\n        })));\\n        assert_eq!(Solution::find_tilt(root), 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nimpl Solution {\\n    pub fn find_tilt(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        fn traverse(root: &Option<Rc<RefCell<TreeNode>>>, ans: &mut i32) -> i32 {\\n            match root {\\n                Some(node) => {\\n                    let node = node.borrow();\\n                    let left = traverse(&node.left, ans);\\n                    let right = traverse(&node.right, ans);\\n                    *ans += (left - right).abs();\\n                    left + right + node.val\\n                }\\n                None => 0,\\n            }\\n        }\\n        let mut ans = 0;\\n        traverse(&root, &mut ans);\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_find_tilt() {\\n        let root = Some(Rc::new(RefCell::new(TreeNode {\\n            val: 1,\\n            left: Some(Rc::new(RefCell::new(TreeNode {\\n                val: 2,\\n                left: None,\\n                right: None,\\n            }))),\\n            right: Some(Rc::new(RefCell::new(TreeNode::new(3)))),\\n        })));\\n        assert_eq!(Solution::find_tilt(root), 1);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 572560,
                "title": "go-bottom-up-solution",
                "content": "Runtime: 8 ms, faster than 94.74% of Go online submissions for Binary Tree Tilt.\\nMemory Usage: 6 MB, less than 100.00% of Go online submissions for Binary Tree Tilt.\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc findTilt(root *TreeNode) int {\\n    _, res := tilt(root)\\n    return res\\n}\\n\\nfunc tilt(root *TreeNode) (int,int) {\\n    if root == nil {\\n        return 0, 0\\n    }\\n    left, s1 := tilt(root.Left)\\n    right, s2 := tilt(root.Right)\\n    return (root.Val+left+right), (abs(left-right)+s1+s2)\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return -a\\n    }\\n    return a\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc findTilt(root *TreeNode) int {\\n    _, res := tilt(root)\\n    return res\\n}\\n\\nfunc tilt(root *TreeNode) (int,int) {\\n    if root == nil {\\n        return 0, 0\\n    }\\n    left, s1 := tilt(root.Left)\\n    right, s2 := tilt(root.Right)\\n    return (root.Val+left+right), (abs(left-right)+s1+s2)\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return -a\\n    }\\n    return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 289426,
                "title": "python-postorder-traverse-beats-100",
                "content": "```python\\n    def __init__(self):\\n        self.result_lc563 = 0\\n    def findTilt(self, root):\\n        def postTraverse(root): # post order traverse, from bottom to top\\n            if not root:\\n                return 0\\n            left = postTraverse(root.left)\\n            right = postTraverse(root.right)\\n            self.result_lc563 += abs(right-left)\\n            return left+right+root.val\\n        postTraverse(root)\\n        return self.result_lc563\\n```\\nIf you like this, please vote for me. lol",
                "solutionTags": [],
                "code": "```python\\n    def __init__(self):\\n        self.result_lc563 = 0\\n    def findTilt(self, root):\\n        def postTraverse(root): # post order traverse, from bottom to top\\n            if not root:\\n                return 0\\n            left = postTraverse(root.left)\\n            right = postTraverse(root.right)\\n            self.result_lc563 += abs(right-left)\\n            return left+right+root.val\\n        postTraverse(root)\\n        return self.result_lc563\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 236762,
                "title": "swift-76ms",
                "content": "```swift\\nfunc tilting(_ root: TreeNode?, _ tilt: inout Int) -> Int {\\n\\tguard let node = root else { return 0 }\\n\\n\\tlet left = tilting(node.left, &tilt)\\n\\tlet right = tilting(node.right, &tilt)\\n\\ttilt += abs(left-right)\\n\\n\\treturn left + right + node.val\\n}\\n\\nfunc findTilt(_ root: TreeNode?) -> Int {\\n\\tguard root != nil else { return 0 }\\n\\tvar tilt = 0\\n\\ttilting(root, &tilt)\\n\\treturn tilt\\n}\\n```\\n\\t",
                "solutionTags": [],
                "code": "```swift\\nfunc tilting(_ root: TreeNode?, _ tilt: inout Int) -> Int {\\n\\tguard let node = root else { return 0 }\\n\\n\\tlet left = tilting(node.left, &tilt)\\n\\tlet right = tilting(node.right, &tilt)\\n\\ttilt += abs(left-right)\\n\\n\\treturn left + right + node.val\\n}\\n\\nfunc findTilt(_ root: TreeNode?) -> Int {\\n\\tguard root != nil else { return 0 }\\n\\tvar tilt = 0\\n\\ttilting(root, &tilt)\\n\\treturn tilt\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 184909,
                "title": "java-recursion-beats-100",
                "content": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    int tilt = 0;\n    public int findTilt(TreeNode root) {\n        solution(root);\n        return tilt;\n    }\n    \n    public int solution(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int left = solution(root.left);\n        int right = solution(root.right);\n        tilt += Math.abs(left - right);\n        return left + right + root.val;\n    }\n}",
                "solutionTags": [],
                "code": "class Solution {\n    int tilt = 0;\n    public int findTilt(TreeNode root) {\n        solution(root);\n        return tilt;\n    }",
                "codeTag": "Java"
            },
            {
                "id": 149278,
                "title": "java-beats-96-77-1-pass-o-n-no-global-variable",
                "content": "Idea comes from `337. House Robber III`\\nThe key is to return value sum and tilt sum in an int[2] array, so the information can bring up to the parent node at the same time\\n```\\n    public int findTilt(TreeNode root) {\\n        int[] res = find(root);\\n        return res[1];\\n    }\\n    public int[] find(TreeNode cur) {\\n        if (cur == null)\\n            return new int[]{0,0};\\n        int[] left = find(cur.left);\\n        int[] right = find(cur.right);\\n        int sum = cur.val + left[0] + right[0]; //value sum = cur value + value sum of left + value sum of right\\n        int tilt = Math.abs(left[0] - right[0]) + left[1] + right[1]; //tilt sum = current tilt + tilt sum of left + tilt sum of right\\n        return new int[]{sum, tilt};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findTilt(TreeNode root) {\\n        int[] res = find(root);\\n        return res[1];\\n    }\\n    public int[] find(TreeNode cur) {\\n        if (cur == null)\\n            return new int[]{0,0};\\n        int[] left = find(cur.left);\\n        int[] right = find(cur.right);\\n        int sum = cur.val + left[0] + right[0]; //value sum = cur value + value sum of left + value sum of right\\n        int tilt = Math.abs(left[0] - right[0]) + left[1] + right[1]; //tilt sum = current tilt + tilt sum of left + tilt sum of right\\n        return new int[]{sum, tilt};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102335,
                "title": "python-solution-easy-to-understand",
                "content": "First, write a function csum(root) which can sum up the sum of the whole nodes in this tree, then easy to calculate.\\n```\\nclass Solution(object):\\n    def findTilt(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if not root:\\n            return 0\\n        def csum(root):\\n            if not root:\\n                return 0\\n            return root.val+csum(root.left)+csum(root.right)\\n        return abs(csum(root.left)-csum(root.right))+self.findTilt(root.left)+self.findTilt(root.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findTilt(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if not root:\\n            return 0\\n        def csum(root):\\n            if not root:\\n                return 0\\n            return root.val+csum(root.left)+csum(root.right)\\n        return abs(csum(root.left)-csum(root.right))+self.findTilt(root.left)+self.findTilt(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065160,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    static int sum(TreeNode root){\\n        if(root==null) return 0;\\n        else return root.val + sum(root.left)+sum(root.right);\\n    }\\n\\n    static int helper(TreeNode root){\\n        if(root==null) return 0;\\n\\n        int a = sum(root.left);\\n        int b = sum(root.right);\\n\\n        int x = Math.abs(a-b);\\n        return x + helper(root.left)+helper(root.right);\\n    }\\n    public int findTilt(TreeNode root) {\\n        return helper(root);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    static int sum(TreeNode root){\\n        if(root==null) return 0;\\n        else return root.val + sum(root.left)+sum(root.right);\\n    }\\n\\n    static int helper(TreeNode root){\\n        if(root==null) return 0;\\n\\n        int a = sum(root.left);\\n        int b = sum(root.right);\\n\\n        int x = Math.abs(a-b);\\n        return x + helper(root.left)+helper(root.right);\\n    }\\n    public int findTilt(TreeNode root) {\\n        return helper(root);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771832,
                "title": "java-solution-beats-100-0ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static int ans;\\n    public int findTilt(TreeNode root) {\\n        ans=0;\\n        task(root);\\n        return ans;\\n    }\\n\\n    static int task(TreeNode root){\\n        if(root == null) return 0;\\n\\n        int leftSum = task(root.left);\\n\\n        int rightSum = task(root.right);\\n\\n        ans += Math.abs(leftSum - rightSum);\\n\\n        return root.val + leftSum + rightSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static int ans;\\n    public int findTilt(TreeNode root) {\\n        ans=0;\\n        task(root);\\n        return ans;\\n    }\\n\\n    static int task(TreeNode root){\\n        if(root == null) return 0;\\n\\n        int leftSum = task(root.left);\\n\\n        int rightSum = task(root.right);\\n\\n        ans += Math.abs(leftSum - rightSum);\\n\\n        return root.val + leftSum + rightSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709633,
                "title": "2-solutions-brute-optimal-time-beats-87-memory-beats-94-self-explanatory-comments",
                "content": "\\uD83D\\uDE0A \\uD835\\uDE4E\\uD835\\uDE5A\\uD835\\uDE61\\uD835\\uDE5B \\uD835\\uDE3E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE56\\uD835\\uDE69\\uD835\\uDE5A\\uD835\\uDE59 \\uD835\\uDE47\\uD835\\uDE64\\uD835\\uDE5C\\uD835\\uDE5E\\uD835\\uDE58 ~ \\uD835\\uDE52\\uD835\\uDE5E\\uD835\\uDE69\\uD835\\uDE5D \\u2764\\uFE0F \\uD835\\uDE57\\uD835\\uDE6E \\uD835\\uDE43\\uD835\\uDE5E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE63\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHey There! Its Easy Just Take A Look At The Code And Comments Within It, You\\'ll Get It.\\n\\nStill Got Doubts! Feel Free To Comment, I Will Definately Reply.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Both Accepted\\n\\n# Complexity\\n- Time complexity: Mentioned in the code\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Mentioned in the code\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nApproach 1 :- Brute Force (DFS)  \\n```\\n// #1 Method helper\\nint calculateTiltSum(Node* root, int& leftSum, int& rightSum) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return 0;\\n\\n    int leftSumTemp {0}, rightSumTemp {0};\\n\\n    // Recursively find and store the sum of the left and right subtree\\n    leftSum  = calculateTiltSum(root->left, leftSumTemp, rightSumTemp); \\n    rightSum = calculateTiltSum(root->right, leftSumTemp, rightSumTemp);\\n\\n    return (leftSum + root->val + rightSum);\\n}\\n    \\n// #1 Method to find the sum of every tree node\\'s tilt using dfs - O(N*N) & O(H)\\nint findTilt(Node* root) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return 0;\\n\\n    int currTiltSum {0};\\n    int leftSum {0}, rightSum {0};\\n\\n    // Find and calculate the tilt sum of the current node\\n    calculateTiltSum(root, leftSum, rightSum);\\n    currTiltSum += abs(leftSum - rightSum);\\n\\n    // Recursively find and store the tilt sum of both the subtrees\\n    int leftTiltSum  = findTilt(root->left);\\n    int rightTiltSum = findTilt(root->right);\\n\\n    return (leftTiltSum + currTiltSum + rightTiltSum);\\n}\\n```\\nApproach 2 :- Optimized (DFS)\\n```\\n// #2 Method helper\\nint calculateTiltSum(Node* root, int& tiltSum) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return 0;\\n\\n    // Recursively find and store the sum of the left and right subtree\\n    int leftSum  = calculateTiltSum(root->left, tiltSum);\\n    int rightSum = calculateTiltSum(root->right, tiltSum);\\n\\n    // Calculate and store the tilt sum of the current node\\n    tiltSum += abs(leftSum - rightSum);\\n\\n    return (leftSum + root->val + rightSum);\\n}\\n\\n// #2 Method to find the sum of every tree node\\'s tilt using dfs - O(N) & O(H)\\nint findTilt(Node* root) {\\n    int tiltSum {0};\\n    calculateTiltSum(root, tiltSum);\\n    return tiltSum;\\n}\\n```\\n\\uD835\\uDDE8\\uD835\\uDDE3\\uD835\\uDDE9\\uD835\\uDDE2\\uD835\\uDDE7\\uD835\\uDDD8 \\uD835\\uDDDC\\uD835\\uDDD9 \\uD835\\uDDEC\\uD835\\uDDE2\\uD835\\uDDE8 \\uD835\\uDDDF\\uD835\\uDDDC\\uD835\\uDDDE\\uD835\\uDDD8 \\uD835\\uDDE7\\uD835\\uDDDB\\uD835\\uDDD8 \\uD835\\uDDE6\\uD835\\uDDE2\\uD835\\uDDDF\\uD835\\uDDE8\\uD835\\uDDE7\\uD835\\uDDDC\\uD835\\uDDE2\\uD835\\uDDE1 \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// #1 Method helper\\nint calculateTiltSum(Node* root, int& leftSum, int& rightSum) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return 0;\\n\\n    int leftSumTemp {0}, rightSumTemp {0};\\n\\n    // Recursively find and store the sum of the left and right subtree\\n    leftSum  = calculateTiltSum(root->left, leftSumTemp, rightSumTemp); \\n    rightSum = calculateTiltSum(root->right, leftSumTemp, rightSumTemp);\\n\\n    return (leftSum + root->val + rightSum);\\n}\\n    \\n// #1 Method to find the sum of every tree node\\'s tilt using dfs - O(N*N) & O(H)\\nint findTilt(Node* root) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return 0;\\n\\n    int currTiltSum {0};\\n    int leftSum {0}, rightSum {0};\\n\\n    // Find and calculate the tilt sum of the current node\\n    calculateTiltSum(root, leftSum, rightSum);\\n    currTiltSum += abs(leftSum - rightSum);\\n\\n    // Recursively find and store the tilt sum of both the subtrees\\n    int leftTiltSum  = findTilt(root->left);\\n    int rightTiltSum = findTilt(root->right);\\n\\n    return (leftTiltSum + currTiltSum + rightTiltSum);\\n}\\n```\n```\\n// #2 Method helper\\nint calculateTiltSum(Node* root, int& tiltSum) {\\n    // Edge case: When the tree is empty\\n    if(!root)\\n        return 0;\\n\\n    // Recursively find and store the sum of the left and right subtree\\n    int leftSum  = calculateTiltSum(root->left, tiltSum);\\n    int rightSum = calculateTiltSum(root->right, tiltSum);\\n\\n    // Calculate and store the tilt sum of the current node\\n    tiltSum += abs(leftSum - rightSum);\\n\\n    return (leftSum + root->val + rightSum);\\n}\\n\\n// #2 Method to find the sum of every tree node\\'s tilt using dfs - O(N) & O(H)\\nint findTilt(Node* root) {\\n    int tiltSum {0};\\n    calculateTiltSum(root, tiltSum);\\n    return tiltSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3232882,
                "title": "javascript-splift-left-and-right-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar findTilt = function(root) {\\n    const tilt = { val: 0 };\\n    dfs(root, tilt);\\n    return tilt.val;\\n};\\n\\nfunction dfs(root, tilt) {\\n    if (!root) return 0;\\n    let left = dfs(root.left, tilt);\\n    let right = dfs(root.right, tilt);\\n    tilt.val += Math.abs(left - right);\\n    return root.val + left + right;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findTilt = function(root) {\\n    const tilt = { val: 0 };\\n    dfs(root, tilt);\\n    return tilt.val;\\n};\\n\\nfunction dfs(root, tilt) {\\n    if (!root) return 0;\\n    let left = dfs(root.left, tilt);\\n    let right = dfs(root.right, tilt);\\n    tilt.val += Math.abs(left - right);\\n    return root.val + left + right;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3042375,
                "title": "c-easy-solution-recursion",
                "content": "TC: O(N)\\nSC: Auxiliary Stack Space O(N)\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode* root){\\n        // base case\\n        if(root==NULL)return {0,0};\\n        \\n        pair<int,int> left  = solve(root->left);\\n        pair<int,int> right = solve(root->right);\\n        return {\\n                 left.first  + right.first + root->val ,\\n                 left.second + right.second + \\n                 abs(left.first - right.first)\\n               };\\n    }\\n    int findTilt(TreeNode* root) {\\n        \\n        pair<int,int>ans = solve(root);\\n        return ans.second;\\n    }\\n};\\n\\n\\n// pair<int,int> ans\\n// ans.first  = sum of all node value of its left/right subtree\\n// ans.second = sum of all tilt\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode* root){\\n        // base case\\n        if(root==NULL)return {0,0};\\n        \\n        pair<int,int> left  = solve(root->left);\\n        pair<int,int> right = solve(root->right);\\n        return {\\n                 left.first  + right.first + root->val ,\\n                 left.second + right.second + \\n                 abs(left.first - right.first)\\n               };\\n    }\\n    int findTilt(TreeNode* root) {\\n        \\n        pair<int,int>ans = solve(root);\\n        return ans.second;\\n    }\\n};\\n\\n\\n// pair<int,int> ans\\n// ans.first  = sum of all node value of its left/right subtree\\n// ans.second = sum of all tilt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007416,
                "title": "c-easy-solution-using-postorder-traversal",
                "content": "# Intuition\\nFor each node calculate the sum of node values in its left and right subtrees and accordingly calculate through binary tree traversal\\n\\n# Approach\\nUse postorder traversal to calculate the sum of values in right and left subtree.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int postorder(TreeNode* root,int& sum){\\n        if(root==NULL)\\n            return 0;\\n        int lsum=postorder(root->left,sum);\\n        int rsum=postorder(root->right,sum);\\n        sum+=abs(lsum-rsum);\\n        return lsum+rsum+root->val;\\n    }\\n    int findTilt(TreeNode* root) {\\n        int sum=0;\\n        postorder(root,sum);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int postorder(TreeNode* root,int& sum){\\n        if(root==NULL)\\n            return 0;\\n        int lsum=postorder(root->left,sum);\\n        int rsum=postorder(root->right,sum);\\n        sum+=abs(lsum-rsum);\\n        return lsum+rsum+root->val;\\n    }\\n    int findTilt(TreeNode* root) {\\n        int sum=0;\\n        postorder(root,sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530658,
                "title": "easy-python",
                "content": "```\\ndef findTilt(self, root: Optional[TreeNode]) -> int:\\n\\tans = 0\\n\\tdef getTilt(root):\\n\\t\\tnonlocal ans\\n\\t\\tif not root:\\n\\t\\t\\treturn 0\\n\\t\\tleftSub = getTilt(root.left)\\n\\t\\trightSub = getTilt(root.right)\\n\\t\\tans += abs(leftSub - rightSub)\\n\\t\\treturn root.val + leftSub + rightSub \\n\\tgetTilt(root)\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findTilt(self, root: Optional[TreeNode]) -> int:\\n\\tans = 0\\n\\tdef getTilt(root):\\n\\t\\tnonlocal ans\\n\\t\\tif not root:\\n\\t\\t\\treturn 0\\n\\t\\tleftSub = getTilt(root.left)\\n\\t\\trightSub = getTilt(root.right)\\n\\t\\tans += abs(leftSub - rightSub)\\n\\t\\treturn root.val + leftSub + rightSub \\n\\tgetTilt(root)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2526790,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        \\n        def helper(node):\\n            if not node:\\n                return 0, 0\\n            ls, lr = helper(node.left)\\n            rs, rr = helper(node.right)\\n            return ls + rs + node.val, lr + rr + abs(ls - rs)\\n        \\n        return helper(root)[1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        \\n        def helper(node):\\n            if not node:\\n                return 0, 0\\n            ls, lr = helper(node.left)\\n            rs, rr = helper(node.right)\\n            return ls + rs + node.val, lr + rr + abs(ls - rs)\\n        \\n        return helper(root)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506858,
                "title": "100-east-short-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n    int ans = 0;\\n\\t\\n    public int findTilt(TreeNode root) {\\n        dfs(root);\\n        return ans;\\n    }\\n    \\n    private int dfs(TreeNode root){\\n        if(root == null) return 0;\\n        \\n        int left = dfs(root.left);\\n        int right = dfs(root.right);\\n        ans += Math.abs(left - right);\\n        \\n        return root.val + left + right;\\n    }",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2404339,
                "title": "python-super-easy-using-dfs",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        \\n        ans = 0\\n        def dfs(root):\\n            if not root:\\n                return 0\\n            \\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            \\n            nonlocal ans\\n            ans += abs(left - right)\\n            \\n            return right + root.val + left\\n            \\n        \\n        dfs(root)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        \\n        ans = 0\\n        def dfs(root):\\n            if not root:\\n                return 0\\n            \\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            \\n            nonlocal ans\\n            ans += abs(left - right)\\n            \\n            return right + root.val + left\\n            \\n        \\n        dfs(root)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326672,
                "title": "java-easy-code",
                "content": "```\\nclass Solution {\\n    int result = 0;\\n    public int findTilt(TreeNode root) {\\n        postOrder(root);\\n        return result;\\n    }\\n    public int postOrder(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        int left = postOrder(root.left);\\n        int right = postOrder(root.right);\\n        result = result + Math.abs(left-right);\\n        return left + right + root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int result = 0;\\n    public int findTilt(TreeNode root) {\\n        postOrder(root);\\n        return result;\\n    }\\n    public int postOrder(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        int left = postOrder(root.left);\\n        int right = postOrder(root.right);\\n        result = result + Math.abs(left-right);\\n        return left + right + root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276232,
                "title": "easiest-concise",
                "content": "class Solution {\\npublic:\\n\\n    int sum(TreeNode *root)\\n    {\\n        if(!root)\\n            return 0;\\n        vector<int>v;\\n        inorder(v,root);\\n        int sum=0;\\n        for(int i=0;i<v.size();i++)\\n            sum+=v[i];\\n        return sum;\\n    }\\n    void inorder(vector<int>&v,TreeNode *root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            inorder(v,root->left);\\n            v.push_back(root->val);\\n            inorder(v,root->right);\\n        }\\n    }\\n    void level(TreeNode *root,int lvl,vector<TreeNode*>&v)\\n    {\\n        if(!root)\\n            return;\\n        else if(lvl==1)\\n            v.push_back(root);\\n        else\\n        {\\n            level(root->left,lvl-1,v);\\n            level(root->right,lvl-1,v);\\n        }\\n    }\\n    int height(TreeNode *root)\\n    {\\n        if(!root)\\n            return 0;\\n        else\\n        {\\n            int x=height(root->left)+1;\\n            int y=height(root->right)+1;\\n            return max(x,y);\\n        }\\n    }\\n    int findTilt(TreeNode* root) {\\n        vector<TreeNode*>v;\\n        int h=height(root);\\n        for(int i=0;i<h;i++)\\n        {\\n            level(root,i+1,v);\\n        }\\n        for(int i=0;i<v.size();i++)\\n        {\\n            TreeNode *t=v[i];\\n            int a=sum(t->left);\\n            int b=sum(t->right);\\n            t->val=abs(a-b);\\n        }\\n        int ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans+=v[i]->val;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int sum(TreeNode *root)\\n    {\\n        if(!root)\\n            return 0;\\n        vector<int>v;\\n        inorder(v,root);\\n        int sum=0;\\n        for(int i=0;i<v.size();i++)\\n            sum+=v[i];\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2223946,
                "title": "clean-python-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        def tilt(root):\\n            nonlocal sm\\n            \\n            if not root:\\n                return 0\\n            \\n            l = tilt(root.left)\\n            r = tilt(root.right)\\n            \\n            rt = root.val\\n            \\n            root.val = abs(l-r)\\n            sm+=root.val\\n            \\n            return l+r+rt\\n\\n        sm = 0\\n        tilt(root)\\n            \\n        return sm\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        def tilt(root):\\n            nonlocal sm\\n            \\n            if not root:\\n                return 0\\n            \\n            l = tilt(root.left)\\n            r = tilt(root.right)\\n            \\n            rt = root.val\\n            \\n            root.val = abs(l-r)\\n            sm+=root.val\\n            \\n            return l+r+rt\\n\\n        sm = 0\\n        tilt(root)\\n            \\n        return sm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2149914,
                "title": "java-recursive-fast-solution",
                "content": "\\nclass Solution {\\n\\n    int tilt = 0;\\n    public int findTilt(TreeNode root) {\\n        if(root == null)return 0;\\n        \\n        helper(root);\\n        \\n        return tilt;\\n    }\\n    public int helper(TreeNode root){\\n        if(root == null)return 0;\\n        \\n        int lh = helper(root.left);\\n        int rh = helper(root.right);\\n        \\n        tilt+=Math.abs(lh-rh);\\n        \\n        return lh+rh+root.val;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n    int tilt = 0;\\n    public int findTilt(TreeNode root) {\\n        if(root == null)return 0;\\n        \\n        helper(root);\\n        \\n        return tilt;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2145754,
                "title": "c-easy-solution",
                "content": "```\\n//return a pair which having first value as a sum of nodes and second is the ans\\npair<int,int> solve(TreeNode* root){\\n        if(!root)return {0,0};\\n        pair<int,int> p1 = solve(root->left);\\n        pair<int,int> p2 = solve(root->right);\\n        int ls = p1.first,rs = p2.first;\\n        int la = p1.second,ra = p2.second;\\n        return {(ls+rs+root->val),(la+ra+abs(ls-rs))};\\n    }\\n    int findTilt(TreeNode* root) {\\n        pair<int,int> p = solve(root);\\n        return p.second;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n//return a pair which having first value as a sum of nodes and second is the ans\\npair<int,int> solve(TreeNode* root){\\n        if(!root)return {0,0};\\n        pair<int,int> p1 = solve(root->left);\\n        pair<int,int> p2 = solve(root->right);\\n        int ls = p1.first,rs = p2.first;\\n        int la = p1.second,ra = p2.second;\\n        return {(ls+rs+root->val),(la+ra+abs(ls-rs))};\\n    }\\n    int findTilt(TreeNode* root) {\\n        pair<int,int> p = solve(root);\\n        return p.second;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2123789,
                "title": "c-easy-recursive-solution-with-comments",
                "content": "```\\n    int ans = 0;\\n    int helper(TreeNode *root){\\n         if(root == NULL) return 0;\\n        \\n        int leftAns = helper(root->left);       // call on left subtree\\n        int rightAns = helper(root->right);     // call on right subtree\\n        \\n        ans += abs(leftAns - rightAns);\\n        \\n        return (root->val + leftAns + rightAns);\\n    }\\n    int findTilt(TreeNode* root) {\\n         helper(root);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n    int ans = 0;\\n    int helper(TreeNode *root){\\n         if(root == NULL) return 0;\\n        \\n        int leftAns = helper(root->left);       // call on left subtree\\n        int rightAns = helper(root->right);     // call on right subtree\\n        \\n        ans += abs(leftAns - rightAns);\\n        \\n        return (root->val + leftAns + rightAns);\\n    }\\n    int findTilt(TreeNode* root) {\\n         helper(root);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2106855,
                "title": "2-different-approach-using-pair-and-global-variable",
                "content": "//Method 1: Using a global variable\\n//Note: Instead of using global variable you can also pass this variable as reference from the main function\\nclass Solution {\\npublic:\\n    \\n    int sum=0;\\n    int helper(TreeNode* root){\\n          if(root==NULL){\\n            return 0;\\n        }\\n        \\n        \\n        int lval=helper(root->left);\\n       int rval= helper(root->right);\\n        \\n        sum=sum+abs(lval-rval);\\n    \\nreturn root->val+lval+rval;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n      helper(root);\\n        return sum;\\n    }\\n};\\n\\n\\n//Method 2: (Using Pair in which we will contain both sum as well as tilt of every node)\\nclass Solution {\\npublic:\\n    \\n    pair<int,int> tiltfunction(TreeNode* root){\\n         if(root==NULL){\\n          pair<int,int> my;\\n             my.first=0;\\n             my.second=0;\\n             return my;\\n        }\\n        \\n      pair<int,int> lval= tiltfunction(root->left);\\n      pair<int,int> rval= tiltfunction(root->right);\\n        pair<int,int> mytilt;\\n        mytilt.first=lval.first+rval.first+root->val;\\n        \\n        if(root->right && root->left)\\n     mytilt.second=lval.second+rval.second+abs(lval.first-rval.first);\\n         else if(root->left)\\n           mytilt.second=lval.second+abs(lval.first);\\n              else if(root->right)\\n                  mytilt.second=rval.second+abs(rval.first);\\n       \\n        return mytilt;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n       pair<int,int> ans=tiltfunction(root);\\n        return ans.second;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int sum=0;\\n    int helper(TreeNode* root){\\n          if(root==NULL){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2099425,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int tilt=0;\\n    void pre(TreeNode* root){\\n        if(root==NULL) return;\\n        pre(root->left);\\n        pre(root->right);\\n        if(root->left!=NULL && root->right!=NULL){\\n            tilt=tilt+abs(root->left->val - root->right->val);\\n            root->val=root->val+ root->left->val+ root->right->val;\\n        }\\n        else if(root->left==NULL && root->right!=NULL){\\n            tilt=tilt+abs(0-root->right->val);\\n            root->val=root->val+ root->right->val;\\n            \\n        }\\n        else if(root->left!=NULL && root->right==NULL){\\n            tilt=tilt+abs(root->left->val-0);\\n            root->val=root->val + root->left->val;\\n        }\\n        \\n        \\n    }\\n    int findTilt(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        pre(root);\\n        return tilt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tilt=0;\\n    void pre(TreeNode* root){\\n        if(root==NULL) return;\\n        pre(root->left);\\n        pre(root->right);\\n        if(root->left!=NULL && root->right!=NULL){\\n            tilt=tilt+abs(root->left->val - root->right->val);\\n            root->val=root->val+ root->left->val+ root->right->val;\\n        }\\n        else if(root->left==NULL && root->right!=NULL){\\n            tilt=tilt+abs(0-root->right->val);\\n            root->val=root->val+ root->right->val;\\n            \\n        }\\n        else if(root->left!=NULL && root->right==NULL){\\n            tilt=tilt+abs(root->left->val-0);\\n            root->val=root->val + root->left->val;\\n        }\\n        \\n        \\n    }\\n    int findTilt(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        pre(root);\\n        return tilt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020584,
                "title": "js-simple-explained-recursive-post-order-traversal",
                "content": "# 563. Binary Tree Tilt \\uD83D\\uDE80\\n\\n### Solution Developed In:\\n![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)\\n\\n## The Question\\nFor this article we will be covering Leetcode\\'s \\'[563. Binary Tree Tilt](https://leetcode.com/problems/binary-tree-tilt/)\\' question. \\n\\nQuestion:\\n\\n> Given the `root` of a binary tree, return the `sum` of every tree node\\'s **tilt**.\\n>The tilt of a tree node is the **absolute difference** between the `sum` of all left subtree node values and all right subtree node values. If a node does not have a left child, then\\n> the sum of the left subtree node values is treated as `0`. The rule is similar if the node does not have a right child.\\n\\nExample:\\n\\n>![Example](https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg)\\n\\n```\\nInput: root = [1,2,3]\\nOutput: 1\\nExplanation: \\nTilt of node 2 : |0-0| = 0 (no children)\\nTilt of node 3 : |0-0| = 0 (no children)\\nTilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\\nSum of every tilt : 0 + 0 + 1 = 1\\n```\\n\\n## Explaining The Question\\nThis Question is rated **Easy**. Which I believe is ***completely in-accurate and misleading***. \\n\\nI believe that this question can only be considered easy is if you understand the ***Medium level concepts***. Like how to sum a binary tree, how to traverse a binary tree, and how to traverse a binary tree recursively. What [Post Order Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/) is and how we can use it to calculate tree sums. If you understand the **medium** level concepts, then you can easily understand this question, but the question itself is not for people who don\\'t know these concepts.\\n\\nWhat we\\'re being asked is to calculate the difference between every node\\'s left and right subtree sums. Which translates to:\\nAt every node we visit, get the sum of the left trees and right trees. Figure out the difference between the two. Then we can add that difference to the total sum. We repeat this process for every node in the entire tree.\\n\\n##  Recommended Knowledge\\n1. [Binary Tree](https://en.wikipedia.org/wiki/Binary_tree)\\n2. [Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search)\\n3. [Post Order Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/) \\n4. [Recursive Post Order Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)\\n\\n## What do we know?\\n1. We have a ***binary tree*** (Most times, it could be empty)\\n2. We need to calculate the **tilt** of each node in the tree.\\n3. We need to visit every **node** in the tree.\\n4. We\\'re going to need to use [Post Order Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/) to calculate the **tilt** of each node.\\n\\n## How we\\'re going to do it:\\n\\nWe\\'re going to use [Post Order Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/) to calculate the **tilt** of each node. We do this by calculating the sum of the left and right subtrees. Given the sum of the left and right subtrees, we can calculate the **tilt** of the current node.\\n\\nThe tilt is calculated by: \\n```\\ntilt = abs(left_subtree_sum - right_subtree_sum)\\n```\\n\\n1. We\\'re going to declare a `tilt_counter` that will be used to store the total tilt of all nodes in the tree. Lots of (`+=`) operations. \\n2. We\\'re going to perform a [Post Order Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/) \\n3. At each node, we get the `left_sum` and `right_sum` of the current node. Which represents the sum of the left and right subtrees. (Don\\'t worry if this makes no sense, it will soon be explained.)\\n4. We then calculate the `tilt` of the current node. We do this by calculating the absolute difference between the `left_sum` and `right_sum`. This value is then appended to the `tilt_counter`.\\n5. We then return the sum of the current node. The sum of a current node is calculated by (left_sum + right_sum + current node sum).\\n6. After calculating that, we return that value. Because we\\'re using [Post Order Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/), we can return the sum of the current node to it\\'s parent node within the tree. This is how we get the sub tree sums at point 3. \\n\\n\\n## Big O Notation:\\n* Time Complexity:   *O(**n**)* | Where ***n*** is the number of nodes in our ***Binary Tree*** | As we\\'re going to traverse all of the nodes within the tree.\\n  \\n* Space Complexity: *O(**h**)* | Where ***h*** is the height of our ***Binary Tree*** | As we\\'re going to store the height of the tree within the internal [call stack](https://en.wikipedia.org/wiki/Call_stack).\\n\\n\\n## Leetcode Results:\\n\\nSee Submission Link: \\n\\n* Runtime: 79 ms, faster than ***80.75%*** of JavaScript online submissions for Binary Tree Tilt.\\n* Memory Usage: 47 MB, less than ***85.45%*** of JavaScript online submissions for Binary Tree Tilt.\\n\\n[![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)](https://leetcode.com/submissions/detail/695684669/)\\n\\n\\n***\\n\\n# The Solution\\n```\\nvar findTilt = function (root) {\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                            563. Binary Tree Tilt                           */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @author  Samuel Hinchliffe\\n     * @see    {@link linkedin.com/in/samuel-hinchliffe-\\uD83D\\uDE80-2bb5801a5/ | Author\\'s Linkedin }\\n     * @see    {@link github.com/Samuel-Hinchliffe}\\n     */\\n\\n    // Our tilt counter (Keeps track of the diff between the left and right subtrees)\\n    let tilt_counter = 0;\\n\\n    // Recursive function to traverse the tree\\n    // In a post order fashion, get all the sums for all the subtrees\\n    // we then figure out the difference between the left and right subtrees\\n    // and add that to the tilt counter. \\n    const post_order_traversal = (node) => {\\n\\n        // If the node does not exist.\\n        // It has no value and therefore it\\'s a 0.\\n        if (!node) {\\n            return 0;\\n        }\\n\\n        // Post Order, get me their SUMS!!!\\n        let left_sum  = post_order_traversal(node.left);\\n        let right_sum = post_order_traversal(node.right);\\n\\n        // Figure out the difference between the left and right subtrees\\n        // We use the absolute value of the difference to keep track of the tilt\\n        tilt_counter += Math.abs(left_sum - right_sum);\\n\\n        // Return the value of the node and it\\'s subtrees.\\n        return left_sum + right_sum + node.val;\\n    };\\n\\n    post_order_traversal(root);\\n    return tilt_counter;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nInput: root = [1,2,3]\\nOutput: 1\\nExplanation: \\nTilt of node 2 : |0-0| = 0 (no children)\\nTilt of node 3 : |0-0| = 0 (no children)\\nTilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\\nSum of every tilt : 0 + 0 + 1 = 1\\n```\n```\\ntilt = abs(left_subtree_sum - right_subtree_sum)\\n```\n```\\nvar findTilt = function (root) {\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                            563. Binary Tree Tilt                           */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @author  Samuel Hinchliffe\\n     * @see    {@link linkedin.com/in/samuel-hinchliffe-\\uD83D\\uDE80-2bb5801a5/ | Author\\'s Linkedin }\\n     * @see    {@link github.com/Samuel-Hinchliffe}\\n     */\\n\\n    // Our tilt counter (Keeps track of the diff between the left and right subtrees)\\n    let tilt_counter = 0;\\n\\n    // Recursive function to traverse the tree\\n    // In a post order fashion, get all the sums for all the subtrees\\n    // we then figure out the difference between the left and right subtrees\\n    // and add that to the tilt counter. \\n    const post_order_traversal = (node) => {\\n\\n        // If the node does not exist.\\n        // It has no value and therefore it\\'s a 0.\\n        if (!node) {\\n            return 0;\\n        }\\n\\n        // Post Order, get me their SUMS!!!\\n        let left_sum  = post_order_traversal(node.left);\\n        let right_sum = post_order_traversal(node.right);\\n\\n        // Figure out the difference between the left and right subtrees\\n        // We use the absolute value of the difference to keep track of the tilt\\n        tilt_counter += Math.abs(left_sum - right_sum);\\n\\n        // Return the value of the node and it\\'s subtrees.\\n        return left_sum + right_sum + node.val;\\n    };\\n\\n    post_order_traversal(root);\\n    return tilt_counter;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1948559,
                "title": "c-easy-solution-beginner-friendly-with-explanation",
                "content": "explanation:-\\n----------------------------------------------------\\nin this code we going to need an helper fun sum() which will be give us \\nsum of valuse of all child nodes of given node we are going to calll sum for each node of tree \\nby level order traversal and in parallel we will add the difference of valuse of left and right childs of each node into ans variable and at last return ans.\\n\\n\\ncode:-\\n\\n----------------------------------------------------------------------------------------------------------\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int sum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        return sum(root->left)+sum(root->right)+root->val;\\n        \\n    }\\n    int findTilt(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int ans =0;\\n        while(q.size())\\n        {\\n            TreeNode *temp = q.front();\\n            q.pop();\\n            ans+= abs(sum(temp->left)-sum(temp->right));\\n            if(temp->left)\\n                q.push(temp->left);\\n            if(temp->right)\\n                q.push(temp->right);\\n            \\n            \\n        }\\n        \\n      return ans;  \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int sum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        return sum(root->left)+sum(root->right)+root->val;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1895220,
                "title": "post-order-traversal-c",
                "content": "Simply postorder traversal is used to solve this problem.\\njust find the left sum and rigt=ht sum store abs(leftsum-rightsum) in a variable\\nclass Solution {\\n    int helper(TreeNode *root)\\n    {\\n\\t\\n        if(!root) return 0;\\n        else{\\n            int leftval=helper(root->left);\\n            int rightval=helper(root->right);\\n            tiltsum+=abs(leftval-rightval);\\n            return leftval+rightval+root->val;\\n        }\\n    }\\npublic:\\n    int tiltsum;\\n    int findTilt(TreeNode* root) {\\n        \\n        helper(root);\\n        return tiltsum;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    int helper(TreeNode *root)\\n    {\\n\\t\\n        if(!root) return 0;\\n        else{\\n            int leftval=helper(root->left);\\n            int rightval=helper(root->right);\\n            tiltsum+=abs(leftval-rightval);\\n            return leftval+rightval+root->val;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1857902,
                "title": "java-100-faster",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n\\n    public int findTilt(TreeNode root) {\\n        go(root);\\n        return ans;\\n    }\\n\\n    private int go(TreeNode root) {\\n        if (root == null) return 0;\\n        int lsum = go(root.left);\\n        int rsum = go(root.right);\\n        ans += Math.abs(lsum - rsum);\\n        return lsum + rsum + root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n\\n    public int findTilt(TreeNode root) {\\n        go(root);\\n        return ans;\\n    }\\n\\n    private int go(TreeNode root) {\\n        if (root == null) return 0;\\n        int lsum = go(root.left);\\n        int rsum = go(root.right);\\n        ans += Math.abs(lsum - rsum);\\n        return lsum + rsum + root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800658,
                "title": "python-solution-with-comment",
                "content": "```\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        def helper(root): \\n            # calculate tree sum by sum up root and left sub tree and righ sub tree; \\n            # at the same time push tilt of root in to result\\n            if not root:\\n                return 0\\n            sl = helper(root.left)\\n            sr = helper(root.right)\\n            tilt.append(abs(sl-sr))\\n            return root.val+sl+sr\\n        tilt = [] # list keep tilts of all node include leaves\\n        helper(root)\\n        return sum(tilt)        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        def helper(root): \\n            # calculate tree sum by sum up root and left sub tree and righ sub tree; \\n            # at the same time push tilt of root in to result\\n            if not root:\\n                return 0\\n            sl = helper(root.left)\\n            sr = helper(root.right)\\n            tilt.append(abs(sl-sr))\\n            return root.val+sl+sr\\n        tilt = [] # list keep tilts of all node include leaves\\n        helper(root)\\n        return sum(tilt)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745294,
                "title": "self-understood-c-solution-using-recursion",
                "content": "***Basic approach is- first convert all the values in their Tilt values and then use another function to find the sum of all values***\\n```\\n// first function to change element value into Tilt value.\\n\\n    int change(TreeNode *root)\\n    {\\n        if(!root)\\n            return 0;\\n        if(!root->left && !root->right)\\n        {\\n            int temp= root->val;\\n            root->val=0;\\n            return temp;\\n        }\\n        int s1=change(root->left);\\n        int s2=change(root->right);\\n        int temp=root->val;\\n        root->val=abs(s1-s2);\\n        return s1+s2+temp;\\n    }\\n    // another function to calculate the sum of all Tilt values.\\n\\t\\n    int sum(TreeNode *root)\\n    {\\n        if(!root)\\n            return 0;\\n        int s1=sum(root->left);\\n       int s2=sum(root->right);\\n        return s1+s2+root->val;\\n    }\\n    \\n    \\n    int findTilt(TreeNode* root) {\\n        int temp=change(root);\\n        return sum(root);\\n    }\\n```\\n**Please upvote if you like the solution .\\nHappy Coding \\uD83D\\uDE0D\\uD83D\\uDE0D**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// first function to change element value into Tilt value.\\n\\n    int change(TreeNode *root)\\n    {\\n        if(!root)\\n            return 0;\\n        if(!root->left && !root->right)\\n        {\\n            int temp= root->val;\\n            root->val=0;\\n            return temp;\\n        }\\n        int s1=change(root->left);\\n        int s2=change(root->right);\\n        int temp=root->val;\\n        root->val=abs(s1-s2);\\n        return s1+s2+temp;\\n    }\\n    // another function to calculate the sum of all Tilt values.\\n\\t\\n    int sum(TreeNode *root)\\n    {\\n        if(!root)\\n            return 0;\\n        int s1=sum(root->left);\\n       int s2=sum(root->right);\\n        return s1+s2+root->val;\\n    }\\n    \\n    \\n    int findTilt(TreeNode* root) {\\n        int temp=change(root);\\n        return sum(root);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681187,
                "title": "recursion-o-n-easy-solution",
                "content": "```\\nclass Solution{\\n    int tilt=0;\\n    public int findTiltHelper(TreeNode node){\\n       if(node==null) return 0;\\n       int leftSum=findTiltHelper(node.left);\\n       int rightSum=findTiltHelper(node.right);\\n       int totalSum=leftSum+rightSum+node.val;\\n       tilt+=Math.abs(rightSum-leftSum);\\n       return totalSum; \\n    }\\n    public int findTilt(TreeNode root) {\\n        findTiltHelper(root);\\n        return tilt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    int tilt=0;\\n    public int findTiltHelper(TreeNode node){\\n       if(node==null) return 0;\\n       int leftSum=findTiltHelper(node.left);\\n       int rightSum=findTiltHelper(node.right);\\n       int totalSum=leftSum+rightSum+node.val;\\n       tilt+=Math.abs(rightSum-leftSum);\\n       return totalSum; \\n    }\\n    public int findTilt(TreeNode root) {\\n        findTiltHelper(root);\\n        return tilt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659938,
                "title": "c-one-possible-variation-we-can-avoid-using-an-instance-variable-recursion",
                "content": "```\\nint helper(TreeNode* root, int &ans){\\n        if(!root) return 0;\\n        int findsuml = helper(root->left, ans);       \\n        int findsumr = helper(root->right, ans);\\n        ans += abs(findsumr-findsuml);\\n        return findsuml+findsumr+root->val;\\n    }\\n    int findTilt(TreeNode* root) {\\n        int ans = 0;\\n        helper(root, ans);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nint helper(TreeNode* root, int &ans){\\n        if(!root) return 0;\\n        int findsuml = helper(root->left, ans);       \\n        int findsumr = helper(root->right, ans);\\n        ans += abs(findsumr-findsuml);\\n        return findsuml+findsumr+root->val;\\n    }\\n    int findTilt(TreeNode* root) {\\n        int ans = 0;\\n        helper(root, ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1649938,
                "title": "100-faster-java-recursive-solution",
                "content": "class Solution {\\n\\n    private int total = 0;\\n    public int findTilt(TreeNode root) {\\n        sum(root);\\n        return total;\\n    }\\n    \\n    public int sum(TreeNode root){\\n        if(root == null) return 0;\\n        int left = sum(root.left);\\n        int right = sum(root.right);\\n        total += Math.abs(left-right);\\n        return root.val + left + right;\\n        \\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    private int total = 0;\\n    public int findTilt(TreeNode root) {\\n        sum(root);\\n        return total;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1644863,
                "title": "easy-c-solution",
                "content": "\\n    int sumTree(TreeNode* root,int &sum)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        \\n        int l=sumTree(root->left,sum);\\n        int r=sumTree(root->right,sum);\\n        sum+=abs(l-r);\\n        \\n        return root->val+l+r;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        int sum=0;\\n        sumTree(root,sum);\\n        return sum;\\n    }\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "\\n    int sumTree(TreeNode* root,int &sum)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        \\n        int l=sumTree(root->left,sum);\\n        int r=sumTree(root->right,sum);\\n        sum+=abs(l-r);\\n        \\n        return root->val+l+r;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        int sum=0;\\n        sumTree(root,sum);\\n        return sum;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1623203,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    int tilt=0;\\n    public int findTilt(TreeNode root) {\\n        sum(root);\\n        return tilt;\\n    }\\n    \\n    int sum(TreeNode t){\\n        \\n        if(t==null) return 0;\\n        int current=t.val;\\n        int left=sum(t.left);\\n        int right=sum(t.right);\\n        tilt+=Math.abs(left-right);\\n        return sum+left+right;\\n            \\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int tilt=0;\\n    public int findTilt(TreeNode root) {\\n        sum(root);\\n        return tilt;\\n    }\\n    \\n    int sum(TreeNode t){\\n        \\n        if(t==null) return 0;\\n        int current=t.val;\\n        int left=sum(t.left);\\n        int right=sum(t.right);\\n        tilt+=Math.abs(left-right);\\n        return sum+left+right;\\n            \\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619187,
                "title": "uh-easy-problem",
                "content": "It\\'s a hard problem , if u thought u can solve the problem  only using findTilt function and without other global variable, cuz each recursion produce two value to return..  \"simple problem\" really miss leading me..  \\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction findTilt(root: TreeNode | null): number {\\n    this.total = 0;\\n    sumVal(root);\\n    return this.total;\\n};\\n\\n\\nfunction sumVal(root: TreeNode | null) : number {\\n    if(root == null) {\\n        return 0;\\n    }\\n    const leftSum =  sumVal(root.left);\\n    const rightSum= sumVal(root.right);\\n    this.total += Math.abs(leftSum- rightSum);\\n    return leftSum+ rightSum + root.val;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction findTilt(root: TreeNode | null): number {\\n    this.total = 0;\\n    sumVal(root);\\n    return this.total;\\n};\\n\\n\\nfunction sumVal(root: TreeNode | null) : number {\\n    if(root == null) {\\n        return 0;\\n    }\\n    const leftSum =  sumVal(root.left);\\n    const rightSum= sumVal(root.right);\\n    this.total += Math.abs(leftSum- rightSum);\\n    return leftSum+ rightSum + root.val;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619008,
                "title": "iterative-python-solution-less-memory-than-100",
                "content": "```python\\nfrom collections import deque\\ndef treeSum(root):\\n    stack = deque()\\n    result = 0\\n    stack.append(root)\\n    while stack:\\n        current = stack.pop()\\n        if current is None:\\n            continue\\n        result += current.val\\n        if current.left:\\n            stack.append(current.left)\\n        if current.right:\\n            stack.append(current.right)\\n    return result\\n\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        cache = {}\\n        tilts = 0\\n        stack = deque()\\n        stack.append(root)\\n        while stack:\\n            current = stack.pop()\\n            if current is None:\\n                continue\\n            elif current.left is None and current.right is None:\\n                continue\\n            elif current.left is None:\\n                tilts += abs(treeSum(current.right))\\n                stack.append(current.right)\\n            elif current.right is None:\\n                tilts += abs(treeSum(current.left))\\n                stack.append(current.left)\\n            else:\\n                tilts += abs(treeSum(current.left) - treeSum(current.right))\\n                stack.append(current.left)\\n                stack.append(current.right)\\n                \\n        return tilts\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```python\\nfrom collections import deque\\ndef treeSum(root):\\n    stack = deque()\\n    result = 0\\n    stack.append(root)\\n    while stack:\\n        current = stack.pop()\\n        if current is None:\\n            continue\\n        result += current.val\\n        if current.left:\\n            stack.append(current.left)\\n        if current.right:\\n            stack.append(current.right)\\n    return result\\n\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        cache = {}\\n        tilts = 0\\n        stack = deque()\\n        stack.append(root)\\n        while stack:\\n            current = stack.pop()\\n            if current is None:\\n                continue\\n            elif current.left is None and current.right is None:\\n                continue\\n            elif current.left is None:\\n                tilts += abs(treeSum(current.right))\\n                stack.append(current.right)\\n            elif current.right is None:\\n                tilts += abs(treeSum(current.left))\\n                stack.append(current.left)\\n            else:\\n                tilts += abs(treeSum(current.left) - treeSum(current.right))\\n                stack.append(current.left)\\n                stack.append(current.right)\\n                \\n        return tilts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618798,
                "title": "java-no-global-var-no-arrays-100-faster",
                "content": "Basically the same as everyone who is using an array, but using a typed class for clarity.\\n\\n```\\nclass Solution {\\n    \\n    public int findTilt(TreeNode root) {\\n        return helper(root).tiltSum;\\n    }\\n    \\n    \\n    private Tuple helper(TreeNode root){\\n        \\n        if (root == null){\\n            return new Tuple(0,0);\\n        }\\n        \\n        \\n        Tuple left = helper(root.left);\\n        Tuple right = helper(root.right);\\n        \\n        int rootVal = root.val;\\n        root.val = Math.abs(left.treeSum - right.treeSum);\\n        \\n        \\n        int tiltSum = root.val + left.tiltSum + right.tiltSum;\\n        int treeSum = rootVal + left.treeSum + right.treeSum;\\n            \\n        return new Tuple(treeSum, tiltSum);\\n        \\n    }\\n}\\n\\nclass Tuple{\\n    \\n    final int tiltSum;\\n    final int treeSum;\\n    \\n    Tuple(int treeSum, int tiltSum){\\n        this.treeSum = treeSum;\\n        this.tiltSum = tiltSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int findTilt(TreeNode root) {\\n        return helper(root).tiltSum;\\n    }\\n    \\n    \\n    private Tuple helper(TreeNode root){\\n        \\n        if (root == null){\\n            return new Tuple(0,0);\\n        }\\n        \\n        \\n        Tuple left = helper(root.left);\\n        Tuple right = helper(root.right);\\n        \\n        int rootVal = root.val;\\n        root.val = Math.abs(left.treeSum - right.treeSum);\\n        \\n        \\n        int tiltSum = root.val + left.tiltSum + right.tiltSum;\\n        int treeSum = rootVal + left.treeSum + right.treeSum;\\n            \\n        return new Tuple(treeSum, tiltSum);\\n        \\n    }\\n}\\n\\nclass Tuple{\\n    \\n    final int tiltSum;\\n    final int treeSum;\\n    \\n    Tuple(int treeSum, int tiltSum){\\n        this.treeSum = treeSum;\\n        this.tiltSum = tiltSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618585,
                "title": "easy-java-recursive-solution",
                "content": "```\\n\\nclass Solution {\\n    int totalTilt = 0;\\n    public int findTilt(TreeNode root) {\\n        helper(root);\\n        return totalTilt;\\n    }\\n    \\n    \\n    private int helper(TreeNode node){\\n                \\n        if(node == null)\\n            return 0;\\n        \\n        int left = helper(node.left);\\n        int right = helper(node.right);\\n        \\n        totalTilt += Math.abs(left - right);\\n            \\n        return left + right + node.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    int totalTilt = 0;\\n    public int findTilt(TreeNode root) {\\n        helper(root);\\n        return totalTilt;\\n    }\\n    \\n    \\n    private int helper(TreeNode node){\\n                \\n        if(node == null)\\n            return 0;\\n        \\n        int left = helper(node.left);\\n        int right = helper(node.right);\\n        \\n        totalTilt += Math.abs(left - right);\\n            \\n        return left + right + node.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618012,
                "title": "c-postorderd-traversal-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\npublic:\\n    \\n    int findTilt(TreeNode* root) {\\n        int ans = 0;\\n        solve(root,ans);\\n        return ans;\\n    }\\n    \\nprivate:\\n    \\n    int solve(TreeNode* root,int& ans)\\n    {\\n        if(!root) return 0;\\n        \\n        int left = solve(root->left,ans);\\n        int right = solve(root->right,ans);\\n        \\n        ans+= abs(left-right);\\n        \\n        return (root->val+left+right);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\npublic:\\n    \\n    int findTilt(TreeNode* root) {\\n        int ans = 0;\\n        solve(root,ans);\\n        return ans;\\n    }\\n    \\nprivate:\\n    \\n    int solve(TreeNode* root,int& ans)\\n    {\\n        if(!root) return 0;\\n        \\n        int left = solve(root->left,ans);\\n        int right = solve(root->right,ans);\\n        \\n        ans+= abs(left-right);\\n        \\n        return (root->val+left+right);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617857,
                "title": "c-c-simple-and-clean-recursive-solution",
                "content": "We calculate the sum of the left subtree and the right subtree, add the difference to `res` and go on with recursive calls.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(height-of-tree) for the recursive call stack.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int rec(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        int left = rec(root->left);\\n        int right = rec(root->right);\\n        int tilt = abs(left - right);\\n        res += tilt;\\n        return left + right + root->val;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        rec(root);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```\\n****\\n**C:**\\n```\\nint res = 0;\\n\\nint rec(struct TreeNode* root) {\\n    if (!root)\\n        return 0;\\n    int left = rec(root->left);\\n    int right = rec(root->right);\\n    int tilt = abs(left - right);\\n    res += tilt;\\n    return left + right + root->val;\\n}\\n\\nint findTilt(struct TreeNode* root){\\n    res = 0;\\n    rec(root);\\n    return res;\\n}\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        int left = rec(root->left);\\n        int right = rec(root->right);\\n        int tilt = abs(left - right);\\n        res += tilt;\\n        return left + right + root->val;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        rec(root);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```\n```\\nint res = 0;\\n\\nint rec(struct TreeNode* root) {\\n    if (!root)\\n        return 0;\\n    int left = rec(root->left);\\n    int right = rec(root->right);\\n    int tilt = abs(left - right);\\n    res += tilt;\\n    return left + right + root->val;\\n}\\n\\nint findTilt(struct TreeNode* root){\\n    res = 0;\\n    rec(root);\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617777,
                "title": "python3-recursive",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def getSubTreeSum(self, root : Optional[TreeNode]) -> int:\\n        if root:\\n            left = self.getSubTreeSum(root.left)         # left subtree sum\\n            right = self.getSubTreeSum(root.right)   # right subtree sum\\n            self.ans += abs(left - right)               #  left subtree sum - right subtree sum\\n            return root.val + left + right            # subtree sum\\n        return 0\\n        \\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        self.getSubTreeSum(root)\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def getSubTreeSum(self, root : Optional[TreeNode]) -> int:\\n        if root:\\n            left = self.getSubTreeSum(root.left)         # left subtree sum\\n            right = self.getSubTreeSum(root.right)   # right subtree sum\\n            self.ans += abs(left - right)               #  left subtree sum - right subtree sum\\n            return root.val + left + right            # subtree sum\\n        return 0\\n        \\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        self.getSubTreeSum(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617729,
                "title": "python3-postorder-dfs-time-o-n-space-o-h-optimal-solution",
                "content": "Below is the code, please let me know if you have any questions or comments!\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0\\n        \\n    def _dfs(self, root):\\n        if not root:\\n            return 0\\n        \\n        left = self._dfs(root.left)\\n        right = self._dfs(root.right)\\n        self.ans += abs(left - right)\\n        return left + right + root.val\\n    \\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        self._dfs(root)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0\\n        \\n    def _dfs(self, root):\\n        if not root:\\n            return 0\\n        \\n        left = self._dfs(root.left)\\n        right = self._dfs(root.right)\\n        self.ans += abs(left - right)\\n        return left + right + root.val\\n    \\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        self._dfs(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617701,
                "title": "c-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    int result = 0;\\n    \\n    public int Helper(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        \\n        int leftSum = Helper(root.left);\\n        int rightSum = Helper(root.right);\\n        \\n        result += Math.Abs(rightSum - leftSum);\\n        return root.val + leftSum + rightSum;\\n    }\\n    \\n    public int FindTilt(TreeNode root) {\\n        Helper(root);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    int result = 0;\\n    \\n    public int Helper(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        \\n        int leftSum = Helper(root.left);\\n        int rightSum = Helper(root.right);\\n        \\n        result += Math.Abs(rightSum - leftSum);\\n        return root.val + leftSum + rightSum;\\n    }\\n    \\n    public int FindTilt(TreeNode root) {\\n        Helper(root);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617688,
                "title": "c-dfs-both-brute-force-and-optimized-solutions",
                "content": "**BRUTE FORCE SOLUTION** *O(N^2) TIME AND O(H) SPACE* \\n```\\nclass Solution {\\nprivate:\\n    int sumNodes(TreeNode* root){\\n        if(root==NULL) return 0;\\n        return root->val+sumNodes(root->left)+sumNodes(root->right);\\n    }\\npublic:\\n    int findTilt(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        int ls=sumNodes(root->left);\\n        int rs=sumNodes(root->right);\\n        int ans=abs(ls-rs);\\n        return ans+findTilt(root->left)+findTilt(root->right);\\n    }\\n};\\n```\\n**OPTIMIZED SOLUTION** *O(N) TIME AND O(H) SPACE* \\n```\\nclass Solution {\\nprivate:\\n    int sumNodes(TreeNode* root, int &ans){\\n        if(root==NULL) return 0;\\n        int ls=sumNodes(root->left, ans);\\n        int rs=sumNodes(root->right, ans);\\n        ans+=abs(ls-rs);\\n        return root->val+ls+rs;\\n    }\\npublic:\\n    int findTilt(TreeNode* root) {\\n        int ans=0;\\n        sumNodes(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int sumNodes(TreeNode* root){\\n        if(root==NULL) return 0;\\n        return root->val+sumNodes(root->left)+sumNodes(root->right);\\n    }\\npublic:\\n    int findTilt(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        int ls=sumNodes(root->left);\\n        int rs=sumNodes(root->right);\\n        int ans=abs(ls-rs);\\n        return ans+findTilt(root->left)+findTilt(root->right);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int sumNodes(TreeNode* root, int &ans){\\n        if(root==NULL) return 0;\\n        int ls=sumNodes(root->left, ans);\\n        int rs=sumNodes(root->right, ans);\\n        ans+=abs(ls-rs);\\n        return root->val+ls+rs;\\n    }\\npublic:\\n    int findTilt(TreeNode* root) {\\n        int ans=0;\\n        sumNodes(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617607,
                "title": "my-rust-solution",
                "content": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn find_tilt(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut tilt_sum = 0;\\n        \\n        fn helper(node: Option<Rc<RefCell<TreeNode>>>, tilt_sum: &mut i32) -> i32 {\\n            if node.is_none() {\\n                return 0;\\n            }\\n            \\n            let inner = node.as_ref().unwrap();\\n            let left = helper(inner.borrow().left.clone(), tilt_sum);\\n            let right = helper(inner.borrow().right.clone(), tilt_sum);\\n            *tilt_sum += (left - right).abs();\\n            \\n            left + right + inner.borrow().val\\n        }\\n        \\n        helper(root, &mut tilt_sum);\\n        \\n        tilt_sum\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn find_tilt(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut tilt_sum = 0;\\n        \\n        fn helper(node: Option<Rc<RefCell<TreeNode>>>, tilt_sum: &mut i32) -> i32 {\\n            if node.is_none() {\\n                return 0;\\n            }\\n            \\n            let inner = node.as_ref().unwrap();\\n            let left = helper(inner.borrow().left.clone(), tilt_sum);\\n            let right = helper(inner.borrow().right.clone(), tilt_sum);\\n            *tilt_sum += (left - right).abs();\\n            \\n            left + right + inner.borrow().val\\n        }\\n        \\n        helper(root, &mut tilt_sum);\\n        \\n        tilt_sum\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1617371,
                "title": "python3-post-order-dfs",
                "content": "\\n```\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        mp = {None: 0}\\n        ans = 0 \\n        prev = None\\n        node = root\\n        stack = []\\n        while node or stack: \\n            if node: \\n                stack.append(node)\\n                node = node.left\\n            else: \\n                node = stack[-1]\\n                if node.right and prev != node.right: node = node.right \\n                else: \\n                    mp[node] = node.val + mp[node.left] + mp[node.right]\\n                    ans += abs(mp[node.left] - mp[node.right])\\n                    stack.pop()\\n                    prev = node \\n                    node = None \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        mp = {None: 0}\\n        ans = 0 \\n        prev = None\\n        node = root\\n        stack = []\\n        while node or stack: \\n            if node: \\n                stack.append(node)\\n                node = node.left\\n            else: \\n                node = stack[-1]\\n                if node.right and prev != node.right: node = node.right \\n                else: \\n                    mp[node] = node.val + mp[node.left] + mp[node.right]\\n                    ans += abs(mp[node.left] - mp[node.right])\\n                    stack.pop()\\n                    prev = node \\n                    node = None \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617354,
                "title": "c-easy-recursion",
                "content": "```int help(TreeNode* root,int &res){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            return root->val;\\n        }\\n        int left=help(root->left,res);\\n        int right=help(root->right,res);\\n        res+=abs(left-right);\\n        return left+right+root->val;\\n    }\\n    int findTilt(TreeNode* root) {\\n        int res=0;\\n        help(root,res);\\n        return res;\\n    }```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```int help(TreeNode* root,int &res){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            return root->val;\\n        }\\n        int left=help(root->left,res);\\n        int right=help(root->right,res);\\n        res+=abs(left-right);\\n        return left+right+root->val;\\n    }\\n    int findTilt(TreeNode* root) {\\n        int res=0;\\n        help(root,res);\\n        return res;\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 1617351,
                "title": "c-simple-solution-faster-than-99-1",
                "content": "Firstly, thanks for refering to my solution!\\n**APPROACH :**\\n* The idea is to recursively traverse tree and add all the tilts to get the final value. \\n* While traversing, we keep track of two things, sum of subtree rooted under current node, tilt of current node.\\n* Sum of the subtree is needed to compute tilt of parent. \\n\\n**Time Complexity :** O(N) - N = number of nodes in the tree - We traverse the tree once\\n**Auxiliary Space :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int findTilt(TreeNode* root) {\\n        int tilt = 0;\\n        traverse(root, &tilt);\\n        return tilt;\\n        \\n    }\\n    \\n    int traverse(TreeNode *root, int *tilt){\\n        if(!root) return 0;\\n        int left = traverse(root->left, tilt);\\n        int right = traverse(root->right, tilt);\\n        *tilt += abs(left-right);\\n        return root->val + left + right;\\n    }\\n};\\n```\\n\\n**If you like my solution, please upvote :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTilt(TreeNode* root) {\\n        int tilt = 0;\\n        traverse(root, &tilt);\\n        return tilt;\\n        \\n    }\\n    \\n    int traverse(TreeNode *root, int *tilt){\\n        if(!root) return 0;\\n        int left = traverse(root->left, tilt);\\n        int right = traverse(root->right, tilt);\\n        *tilt += abs(left-right);\\n        return root->val + left + right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616383,
                "title": "c-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int tilt = 0;\\n    int dfs(TreeNode* root)\\n    {\\n        if(!root) return 0;\\n        int a = dfs(root->left);\\n        int b = dfs(root->right);\\n        tilt += abs(a-b);\\n        return root->val + a + b;\\n    }\\n    int findTilt(TreeNode* root) {\\n        dfs(root);\\n        return tilt;\\n    }\\n};\\n``` \\nwe only need to remember the sum of previous nodes, and value of tilt does not depend on the previous tilt values and only depends on the sum of left and right nodes, we can store tilt as ans in global variable.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tilt = 0;\\n    int dfs(TreeNode* root)\\n    {\\n        if(!root) return 0;\\n        int a = dfs(root->left);\\n        int b = dfs(root->right);\\n        tilt += abs(a-b);\\n        return root->val + a + b;\\n    }\\n    int findTilt(TreeNode* root) {\\n        dfs(root);\\n        return tilt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596277,
                "title": "python-3-recursive-solution",
                "content": "```\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        self.res = 0\\n        def helper(root):\\n            if root is None:\\n                return 0\\n            \\n            left, right = helper(root.left), helper(root.right)\\n            self.res += abs(left - right)\\n            return root.val + left + right\\n        \\n        helper(root)\\n        return self.res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root: Optional[TreeNode]) -> int:\\n        self.res = 0\\n        def helper(root):\\n            if root is None:\\n                return 0\\n            \\n            left, right = helper(root.left), helper(root.right)\\n            self.res += abs(left - right)\\n            return root.val + left + right\\n        \\n        helper(root)\\n        return self.res",
                "codeTag": "Java"
            },
            {
                "id": 1459623,
                "title": "c-easy-intuitive-approach-clean-and-concise-code",
                "content": "\\nclass Solution {\\npublic:\\n    \\n    int sum(TreeNode*root){\\n        \\n        if(root==NULL){\\n            return 0;\\n        }\\n        \\n        return root->val+sum(root->left)+sum(root->right);\\n        \\n    }\\n    \\n    void func(TreeNode*root){\\n        \\n        if(root==NULL){\\n            return;\\n        }\\n        \\n        root->val=abs(sum(root->left)-sum(root->right));\\n        \\n        func(root->left);\\n        func(root->right);\\n        \\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        \\n      func(root);  \\n        \\n        return sum(root);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int sum(TreeNode*root){\\n        \\n        if(root==NULL){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1452207,
                "title": "java-0ms-faster-than-100-recursive-solution",
                "content": "```\\nclass Solution {\\n    int result = 0;\\n\\n    public int findTilt(TreeNode root) {\\n        sum(root);\\n        return result;\\n    }\\n\\n    public int sum(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int lt = sum(root.left);\\n        int rt = sum(root.right);\\n        result += Math.abs(lt - rt);\\n        return lt + rt + root.val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int result = 0;\\n\\n    public int findTilt(TreeNode root) {\\n        sum(root);\\n        return result;\\n    }\\n\\n    public int sum(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int lt = sum(root.left);\\n        int rt = sum(root.right);\\n        result += Math.abs(lt - rt);\\n        return lt + rt + root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347005,
                "title": "c-recursive-solution-by-kushalatolia",
                "content": "![image](https://assets.leetcode.com/users/images/0e0e0e1a-beb4-485a-9928-dcc2d9c1ab68_1626690712.7027647.jpeg)\\n```\\nclass Solution {\\npublic:\\n    int tilt=0;\\n    int findTilt(TreeNode* root) {\\n        traverse(root);\\n        return tilt;\\n    }\\n    int traverse(TreeNode *p)\\n    {\\n        if(p==NULL)\\n            return 0;\\n        int l= traverse(p->left);\\n        int r=traverse(p->right);\\n        tilt+=abs(l-r);\\n        return l+r+p->val;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tilt=0;\\n    int findTilt(TreeNode* root) {\\n        traverse(root);\\n        return tilt;\\n    }\\n    int traverse(TreeNode *p)\\n    {\\n        if(p==NULL)\\n            return 0;\\n        int l= traverse(p->left);\\n        int r=traverse(p->right);\\n        tilt+=abs(l-r);\\n        return l+r+p->val;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322702,
                "title": "simple-java-o-n-solution",
                "content": "```\\nclass Solution {\\n    //[tiltsum,sum]\\n    public int findTilt(TreeNode root) {\\n        int[] x=f(root);\\n        return x[0];\\n    }\\n    public int[] f(TreeNode root){\\n        if(root==null)return new int[]{0,0};\\n        int[] lt=f(root.left);\\n        int[] rt=f(root.right);\\n        int tiltsum=lt[0]+rt[0]+Math.abs(lt[1]-rt[1]);\\n        int sum=lt[1]+rt[1]+root.val;\\n        return new int[]{tiltsum,sum};\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    //[tiltsum,sum]\\n    public int findTilt(TreeNode root) {\\n        int[] x=f(root);\\n        return x[0];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1244413,
                "title": "step-by-step-explanation-with-live-code-link",
                "content": "***LIVE CODE LINK:***      [Samarth\\'s Live Code](https://onecompiler.com/java/3wz82mk5w)\\n\\nThe idea is to use the sum of forest, for every node, and calculate the tilt for that corresponding node by calculating the difference of the left forest and the right forest for a node, and finally summing up all such tilts for all the nodes in a master static variable.\\n\\nLEGENDS:\\n\\nThe master static variable is denoted by the name ```tilt``` herein.\\n\\nRest of the code walkthrough is in the form of code comments.\\n```\\n\\nclass Solution {\\n        static int tilt = 0;  // this will store the sum of all the tilts for all the nodes.\\n        public static int findTilt(TreeNode node) {\\n\\n\\t\\t\\t\\t\\ttilt = 0;  // this needs to be explicitly done so that the LeetCode online judge, manages to re-initialize the value for every test case.\\n                \\n                findTilt_Return_Sum(node);    // this is simply called, because its the findTilt_Return_Sum(TreeNode node) function that sets the value of tilt variable.\\n                return tilt;\\n\\n        }\\n        public static int findTilt_Return_Sum(TreeNode node) {  // this function actually finds the sum of nodes and nothing else, don\\'t go on its name, this basically finds sum of all nodes.\\n\\n                if (node == null)\\n                        return 0;\\n\\n                int leftCall = findTilt_Return_Sum(node.left); \\n                int rightCall = findTilt_Return_Sum(node.right);\\n\\n                int sub = leftCall - rightCall;  \\n                tilt += (sub < 0) ? -sub : sub;\\n\\t\\t\\t\\t\\n/*\\nthehe above two lines calculate the difference of the sums of the left forest and the right forest of a node,\\nwhich is basically the tilt of that node.\\nFinally the tilt value (which is stored in variable sub) gets added to our master tilt variable,\\nwhich finally stores the sum of all the tilts.  After thsi function is executed the master tilt variable is all set and good to be returned.\\n*/\\n\\n                return leftCall + rightCall + node.val;\\n\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```tilt```\n```\\n\\nclass Solution {\\n        static int tilt = 0;  // this will store the sum of all the tilts for all the nodes.\\n        public static int findTilt(TreeNode node) {\\n\\n\\t\\t\\t\\t\\ttilt = 0;  // this needs to be explicitly done so that the LeetCode online judge, manages to re-initialize the value for every test case.\\n                \\n                findTilt_Return_Sum(node);    // this is simply called, because its the findTilt_Return_Sum(TreeNode node) function that sets the value of tilt variable.\\n                return tilt;\\n\\n        }\\n        public static int findTilt_Return_Sum(TreeNode node) {  // this function actually finds the sum of nodes and nothing else, don\\'t go on its name, this basically finds sum of all nodes.\\n\\n                if (node == null)\\n                        return 0;\\n\\n                int leftCall = findTilt_Return_Sum(node.left); \\n                int rightCall = findTilt_Return_Sum(node.right);\\n\\n                int sub = leftCall - rightCall;  \\n                tilt += (sub < 0) ? -sub : sub;\\n\\t\\t\\t\\t\\n/*\\nthehe above two lines calculate the difference of the sums of the left forest and the right forest of a node,\\nwhich is basically the tilt of that node.\\nFinally the tilt value (which is stored in variable sub) gets added to our master tilt variable,\\nwhich finally stores the sum of all the tilts.  After thsi function is executed the master tilt variable is all set and good to be returned.\\n*/\\n\\n                return leftCall + rightCall + node.val;\\n\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237991,
                "title": "easy-c-recursive-solution",
                "content": "```\\nint sum(TreeNode* root){\\n        if(root==NULL) return 0;\\n        return (root->val + sum(root->left)+sum(root->right));\\n    }\\n    \\n    TreeNode* func(TreeNode* root){\\n        if(root==NULL) return NULL;\\n        root->val = abs(sum(root->left) - sum(root->right));\\n        root->left = func(root->left);\\n        root->right = func(root->right);\\n        return root;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        root= func(root);\\n        \\n        return sum(root);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint sum(TreeNode* root){\\n        if(root==NULL) return 0;\\n        return (root->val + sum(root->left)+sum(root->right));\\n    }\\n    \\n    TreeNode* func(TreeNode* root){\\n        if(root==NULL) return NULL;\\n        root->val = abs(sum(root->left) - sum(root->right));\\n        root->left = func(root->left);\\n        root->right = func(root->right);\\n        return root;\\n    }\\n    \\n    int findTilt(TreeNode* root) {\\n        if(root==NULL) return 0;\\n        root= func(root);\\n        \\n        return sum(root);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1215006,
                "title": "python-beats-96",
                "content": "```\\nclass Solution:\\n    tilt=0\\n    def findTilt(self, root: TreeNode) -> int:\\n        def helper(node): \\n            if node == None: \\n                return 0\\n            left=helper(node.left)\\n            right=helper(node.right)\\n            self.tilt+=abs(left-right)\\n            return node.val+left+right\\n        helper(root)\\n        return self.tilt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    tilt=0\\n    def findTilt(self, root: TreeNode) -> int:\\n        def helper(node): \\n            if node == None: \\n                return 0\\n            left=helper(node.left)\\n            right=helper(node.right)\\n            self.tilt+=abs(left-right)\\n            return node.val+left+right\\n        helper(root)\\n        return self.tilt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191073,
                "title": "python3",
                "content": "```\\ndef findTilt(self, root: TreeNode) -> int:\\n        self.ans=0\\n        \\n        def total(root):\\n            if not root:return 0\\n            return root.val+total(root.left)+total(root.right)\\n        \\n        def helper(root):\\n            if root:\\n                self.ans+=abs(total(root.left)-total(root.right))\\n                helper(root.left)\\n                helper(root.right)\\n        helper(root)\\n        \\n        return self.ans",
                "solutionTags": [],
                "code": "```\\ndef findTilt(self, root: TreeNode) -> int:\\n        self.ans=0\\n        \\n        def total(root):\\n            if not root:return 0\\n            return root.val+total(root.left)+total(root.right)\\n        \\n        def helper(root):\\n            if root:\\n                self.ans+=abs(total(root.left)-total(root.right))\\n                helper(root.left)\\n                helper(root.right)\\n        helper(root)\\n        \\n        return self.ans",
                "codeTag": "Python3"
            },
            {
                "id": 1182330,
                "title": "java-100-better-time-0ms-solution",
                "content": "class Solution {\\n\\n    int sum=0;\\n    public int findTilt(TreeNode root) {\\n      if(root==null)\\n          return 0;\\n       sumSubTree(root);\\n       return sum;  \\n    }\\n    int sumSubTree(TreeNode t)\\n    {\\n        if(t!=null)\\n        {\\n            int x=sumSubTree(t.right);\\n            int y=sumSubTree(t.left);\\n            sum+=Math.abs(x-y);\\n            return t.val+x+y;\\n        }\\n        return 0;\\n    }\\n\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\n    int sum=0;\\n    public int findTilt(TreeNode root) {\\n      if(root==null)\\n          return 0;\\n       sumSubTree(root);\\n       return sum;  \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1174426,
                "title": "smallest-faster-in-c",
                "content": "```\\nclass Solution {\\n    int findSum(TreeNode* root,int& tilt)\\n    {\\n        if(!root) return 0;\\n        int l = findSum(root->left,tilt);\\n        int r = findSum(root->right,tilt);\\n        tilt = tilt + abs(l - r);\\n        return l+r+root->val;\\n    }\\n    \\n    \\npublic:\\n    int findTilt(TreeNode* root) {\\n        \\n        int tilt=0;\\n        findSum(root,tilt);\\n        return tilt;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int findSum(TreeNode* root,int& tilt)\\n    {\\n        if(!root) return 0;\\n        int l = findSum(root->left,tilt);\\n        int r = findSum(root->right,tilt);\\n        tilt = tilt + abs(l - r);\\n        return l+r+root->val;\\n    }\\n    \\n    \\npublic:\\n    int findTilt(TreeNode* root) {\\n        \\n        int tilt=0;\\n        findSum(root,tilt);\\n        return tilt;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138481,
                "title": "java-post-order-traversal",
                "content": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int res = 0;\\n    public int findTilt(TreeNode root) {\\n       tilt(root);\\n       return res;\\n    }\\n    \\n    int tilt(TreeNode node) {\\n        if (node == null) return 0;\\n        int l = tilt(node.left);\\n        int r = tilt(node.right);\\n        res += Math.abs(r - l);\\n        return node.val + l + r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int res = 0;\\n    public int findTilt(TreeNode root) {\\n       tilt(root);\\n       return res;\\n    }\\n    \\n    int tilt(TreeNode node) {\\n        if (node == null) return 0;\\n        int l = tilt(node.left);\\n        int r = tilt(node.right);\\n        res += Math.abs(r - l);\\n        return node.val + l + r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134160,
                "title": "java-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int tilt_ = 0;\\n    public int findTilt(TreeNode root) {\\n        tilt(root);\\n        return tilt_;\\n    }\\n    public void tilt(TreeNode root){\\n        if(root == null)\\n            return ;\\n        tilt_ += Math.abs(sum(root.left) - sum(root.right));\\n        tilt(root.left);\\n        tilt(root.right);\\n    }\\n  public int sum(TreeNode root){\\n      if(root == null)return 0;\\n      return root.val+sum(root.left)+sum(root.right);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int tilt_ = 0;\\n    public int findTilt(TreeNode root) {\\n        tilt(root);\\n        return tilt_;\\n    }\\n    public void tilt(TreeNode root){\\n        if(root == null)\\n            return ;\\n        tilt_ += Math.abs(sum(root.left) - sum(root.right));\\n        tilt(root.left);\\n        tilt(root.right);\\n    }\\n  public int sum(TreeNode root){\\n      if(root == null)return 0;\\n      return root.val+sum(root.left)+sum(root.right);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127903,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(TreeNode *r,int &res)\\n    {\\n       if(r==NULL)\\n           return(0);\\n        int l=check(r->left,res);\\n        int ri=check(r->right,res);\\n        int p=abs(l-ri);\\n        res=res+p;\\n        int s=l+ri+r->val;\\n        return(s);\\n    }\\n    int findTilt(TreeNode* root) {\\n        int res=0,s=0;\\n        check(root,res);\\n        return(res);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(TreeNode *r,int &res)\\n    {\\n       if(r==NULL)\\n           return(0);\\n        int l=check(r->left,res);\\n        int ri=check(r->right,res);\\n        int p=abs(l-ri);\\n        res=res+p;\\n        int s=l+ri+r->val;\\n        return(s);\\n    }\\n    int findTilt(TreeNode* root) {\\n        int res=0,s=0;\\n        check(root,res);\\n        return(res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099960,
                "title": "runtime-8-ms-faster-than-99-56-of-c-online-submissions-for-binary-tree-tilt",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int findTilt(TreeNode* root) {\\n        getsum(root);\\n        return sum;\\n    }\\n    \\n    int getsum(TreeNode* root)\\n    {\\n        if(!root) return 0;\\n        int l = getsum(root->left);\\n        int r = getsum(root->right);\\n        int a = abs(l-r);\\n        sum = sum+a;\\n        return root->val+l+r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int findTilt(TreeNode* root) {\\n        getsum(root);\\n        return sum;\\n    }\\n    \\n    int getsum(TreeNode* root)\\n    {\\n        if(!root) return 0;\\n        int l = getsum(root->left);\\n        int r = getsum(root->right);\\n        int a = abs(l-r);\\n        sum = sum+a;\\n        return root->val+l+r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080304,
                "title": "python-dfs-intuitive-solution",
                "content": "```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        ans = 0\\n        def dfs(node):\\n            nonlocal ans\\n            if not node:\\n                return 0\\n            else:\\n                left = dfs(node.left)\\n                right = dfs(node.right)\\n                ans += abs(left - right)\\n                return node.val + left + right\\n        dfs(root)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        ans = 0\\n        def dfs(node):\\n            nonlocal ans\\n            if not node:\\n                return 0\\n            else:\\n                left = dfs(node.left)\\n                right = dfs(node.right)\\n                ans += abs(left - right)\\n                return node.val + left + right\\n        dfs(root)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080036,
                "title": "recursive-rust",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\ntype Node = Rc<RefCell<TreeNode>>;\\n\\nimpl Solution {\\n    pub fn find_tilt(root: Option<Node>) -> i32 {\\n        fn recursive(node: &Option<Node>, tilt: &mut i32) -> i32 {\\n            match node {\\n                Some(node) => {\\n                    let node = node.borrow();\\n                    let left = recursive(&node.left, tilt);\\n                    let right = recursive(&node.right, tilt);\\n\\n                    *tilt += i32::abs(left - right);\\n                    left + right + node.val\\n                }\\n                None => 0\\n            }\\n        }\\n        let mut tilt = 0;\\n        recursive(&root, &mut tilt);\\n        tilt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\ntype Node = Rc<RefCell<TreeNode>>;\\n\\nimpl Solution {\\n    pub fn find_tilt(root: Option<Node>) -> i32 {\\n        fn recursive(node: &Option<Node>, tilt: &mut i32) -> i32 {\\n            match node {\\n                Some(node) => {\\n                    let node = node.borrow();\\n                    let left = recursive(&node.left, tilt);\\n                    let right = recursive(&node.right, tilt);\\n\\n                    *tilt += i32::abs(left - right);\\n                    left + right + node.val\\n                }\\n                None => 0\\n            }\\n        }\\n        let mut tilt = 0;\\n        recursive(&root, &mut tilt);\\n        tilt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1066727,
                "title": "postorder-traversal-faster-than-99-in-time",
                "content": "```\\nclass Solution {\\nprivate:\\n    int totalTilt = 0;\\npublic:\\n    \\n    int findTiltHelper(TreeNode* root){\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int leftAns = findTiltHelper(root->left);\\n        int rightAns = findTiltHelper(root->right);\\n        \\n        totalTilt += abs(leftAns - rightAns);\\n        // we get sum of subtree on where call is made\\n        return root->val + leftAns + rightAns;\\n    }\\n    int findTilt(TreeNode* root) {\\n        int temp = findTiltHelper(root);\\n        return totalTilt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int totalTilt = 0;\\npublic:\\n    \\n    int findTiltHelper(TreeNode* root){\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int leftAns = findTiltHelper(root->left);\\n        int rightAns = findTiltHelper(root->right);\\n        \\n        totalTilt += abs(leftAns - rightAns);\\n        // we get sum of subtree on where call is made\\n        return root->val + leftAns + rightAns;\\n    }\\n    int findTilt(TreeNode* root) {\\n        int temp = findTiltHelper(root);\\n        return totalTilt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966384,
                "title": "python3-recursive-solution",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.tilt = 0\\n        \\n    def findTilt(self, root: TreeNode) -> int:\\n        def dive_deep(node):\\n            if not node: return 0\\n            sum_left = dive_deep(node.left)\\n            sum_right = dive_deep(node.right)\\n            self.tilt += abs(sum_left-sum_right)\\n            return sum_left+sum_right+node.val\\n        \\n        dive_deep(root)\\n        return self.tilt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.tilt = 0\\n        \\n    def findTilt(self, root: TreeNode) -> int:\\n        def dive_deep(node):\\n            if not node: return 0\\n            sum_left = dive_deep(node.left)\\n            sum_right = dive_deep(node.right)\\n            self.tilt += abs(sum_left-sum_right)\\n            return sum_left+sum_right+node.val\\n        \\n        dive_deep(root)\\n        return self.tilt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958814,
                "title": "javascript-typescript-solution",
                "content": "// JS\\n// Runtime: 96 ms, faster than 45.85% of JavaScript online submissions for Binary Tree Tilt.\\n// Memory Usage: 43.6 MB, less than 33.79% of JavaScript online submissions for Binary Tree Tilt.\\n```\\nvar findTilt = function (root) {\\n  let res = 0;\\n  const traverse = (node) => {\\n    if (!node) return 0;\\n    const left = traverse(node.left);\\n    const right = traverse(node.right);\\n    res += Math.abs(left - right);\\n\\n    return node.val + left + right;\\n  };\\n\\n  traverse(root);\\n\\n  return res;\\n};\\n```\\n\\n// TS\\n// Runtime: 84 ms, faster than 100.00% of TypeScript online submissions for Binary Tree Tilt.\\n// Memory Usage: 44.4 MB, less than 75.00% of TypeScript online submissions for Binary Tree Tilt.\\n```\\nfunction findTilt(root: TreeNode | null): number {\\n  let res = 0;\\n  const traverse = (node: TreeNode | null): number => {\\n    if (!node) return 0;\\n    const left = traverse(node.left);\\n    const right = traverse(node.right);\\n    res += Math.abs(left - right);\\n\\n    return node.val + left + right;\\n  };\\n\\n  traverse(root);\\n\\n  return res;\\n}\\n```\\n\\nMore leetcode TypeScript solutions at https://github.com/eddyhdzg/leetcode-typescript-solutions",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nvar findTilt = function (root) {\\n  let res = 0;\\n  const traverse = (node) => {\\n    if (!node) return 0;\\n    const left = traverse(node.left);\\n    const right = traverse(node.right);\\n    res += Math.abs(left - right);\\n\\n    return node.val + left + right;\\n  };\\n\\n  traverse(root);\\n\\n  return res;\\n};\\n```\n```\\nfunction findTilt(root: TreeNode | null): number {\\n  let res = 0;\\n  const traverse = (node: TreeNode | null): number => {\\n    if (!node) return 0;\\n    const left = traverse(node.left);\\n    const right = traverse(node.right);\\n    res += Math.abs(left - right);\\n\\n    return node.val + left + right;\\n  };\\n\\n  traverse(root);\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 934198,
                "title": "java-100-faster-and-100-less-memory",
                "content": "```\\nclass Solution {\\n    int sum=0;\\n    public int findTilt(TreeNode root) {\\n        findTiltHelper(root);\\n        return sum;\\n    }\\n\\n    private int findTiltHelper(TreeNode root) {\\n        if(root==null) return 0;\\n        int leftSum = findTiltHelper(root.left);\\n        int rightSum = findTiltHelper(root.right);\\n        sum += Math.abs(leftSum-rightSum);\\n        return leftSum+rightSum+root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public int findTilt(TreeNode root) {\\n        findTiltHelper(root);\\n        return sum;\\n    }\\n\\n    private int findTiltHelper(TreeNode root) {\\n        if(root==null) return 0;\\n        int leftSum = findTiltHelper(root.left);\\n        int rightSum = findTiltHelper(root.right);\\n        sum += Math.abs(leftSum-rightSum);\\n        return leftSum+rightSum+root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929113,
                "title": "solution-without-instance-variables",
                "content": "\\n```\\n# @param {TreeNode} root\\n# @return {Integer}\\ndef find_tilt(root)\\n  _, sum = dfs(root, 0)\\n  sum\\nend\\n\\n# takes sum of tilts\\n# returns weigth, sum of tilts\\ndef dfs(root, sum)\\n  return 0, sum if root.nil?\\n\\n  left, sum = dfs(root.left, sum)\\n  right, sum = dfs(root.right, sum)\\n  sum += (left - right).abs\\n\\n  [root.val + left + right, sum]\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {TreeNode} root\\n# @return {Integer}\\ndef find_tilt(root)\\n  _, sum = dfs(root, 0)\\n  sum\\nend\\n\\n# takes sum of tilts\\n# returns weigth, sum of tilts\\ndef dfs(root, sum)\\n  return 0, sum if root.nil?\\n\\n  left, sum = dfs(root.left, sum)\\n  right, sum = dfs(root.right, sum)\\n  sum += (left - right).abs\\n\\n  [root.val + left + right, sum]\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 928960,
                "title": "binary-tree-tilt-python-3",
                "content": "Keep track of sums/tilts with recursive function call that returns a tuple.\\n\\nTC: O(N) - we visit each node once\\nSC: O(N) - worst case we have a completely skewed tree and have N recursive calls on the stack\\n\\n```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        # Can have empty trees\\n        if not root: return 0\\n\\n        return self.rTilt(root)[0]\\n\\n    # We want to keep track of total sums on left and right sides,\\n    # as well as sum of tilts.\\n    # So let\\'s use a tuple!\\n    def rTilt(self, root):\\n        # Base case: return (0,0) if None\\n        if not root: return (0,0)\\n\\n        # Recursively get node sums & sum of tilts for each side\\n        leftTilt, leftSum =   self.rTilt(root.left)\\n        rightTilt, rightSum = self.rTilt(root.right)\\n\\n        # Add calling node\\'s tilt to children nodes\\' tilts, return in tuple with\\n        # sum of node vals\\n        tilt = abs(leftSum - rightSum)\\n\\n        return (leftTilt + rightTilt + tilt ,leftSum + rightSum + root.val)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTilt(self, root: TreeNode) -> int:\\n        # Can have empty trees\\n        if not root: return 0\\n\\n        return self.rTilt(root)[0]\\n\\n    # We want to keep track of total sums on left and right sides,\\n    # as well as sum of tilts.\\n    # So let\\'s use a tuple!\\n    def rTilt(self, root):\\n        # Base case: return (0,0) if None\\n        if not root: return (0,0)\\n\\n        # Recursively get node sums & sum of tilts for each side\\n        leftTilt, leftSum =   self.rTilt(root.left)\\n        rightTilt, rightSum = self.rTilt(root.right)\\n\\n        # Add calling node\\'s tilt to children nodes\\' tilts, return in tuple with\\n        # sum of node vals\\n        tilt = abs(leftSum - rightSum)\\n\\n        return (leftTilt + rightTilt + tilt ,leftSum + rightSum + root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928590,
                "title": "python-binary-tilt-tree-simple-recursion-with-memoization",
                "content": "Simple recursion with saving previously calculated sums of node\\'s children.\\n\\n```\\nclass Solution:\\n    sum_cache = {}\\n\\n    def findTilt(self, node: TreeNode) -> int:\\n        if node is None:\\n            return 0\\n\\n        sum_left = self.sum_children(node.left)\\n        sum_right = self.sum_children(node.right)\\n        return abs(sum_left - sum_right) + self.findTilt(node.left) + self.findTilt(node.right)\\n\\n    def sum_children(self, node):\\n        if node in self.sum_cache:\\n            return self.sum_cache[node]\\n\\n        if node is None:\\n            value = 0\\n        else:\\n            value = self.sum_children(node.left) + node.val + self.sum_children(node.right)\\n        self.sum_cache[node] = value\\n        return value\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    sum_cache = {}\\n\\n    def findTilt(self, node: TreeNode) -> int:\\n        if node is None:\\n            return 0\\n\\n        sum_left = self.sum_children(node.left)\\n        sum_right = self.sum_children(node.right)\\n        return abs(sum_left - sum_right) + self.findTilt(node.left) + self.findTilt(node.right)\\n\\n    def sum_children(self, node):\\n        if node in self.sum_cache:\\n            return self.sum_cache[node]\\n\\n        if node is None:\\n            value = 0\\n        else:\\n            value = self.sum_children(node.left) + node.val + self.sum_children(node.right)\\n        self.sum_cache[node] = value\\n        return value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928427,
                "title": "c-simple-o-n-single-pass-soln",
                "content": "```\\npublic class Solution {\\n    // Time O(n) || Space O(1) || 1 Pass\\n    public int FindTilt(TreeNode root) {\\n        int oldTreeSum = 0;\\n        return FindTiltUtil(root, ref oldTreeSum);\\n    }\\n    public static int FindTiltUtil(TreeNode root, ref int oldTreeSum)\\n    {\\n        if(root==null) return 0;\\n        int oldLeftTreeSum=0,oldRightTreeSum=0;\\n        \\n        int newLeftTreeSum = FindTiltUtil(root.left, ref oldLeftTreeSum);\\n        int newRightTreeSum = FindTiltUtil(root.right, ref oldRightTreeSum);\\n        \\n        oldTreeSum = root.val+ oldLeftTreeSum+ oldRightTreeSum;\\n        root.val = Math.Abs(oldLeftTreeSum- oldRightTreeSum);\\n        return root.val+newLeftTreeSum+newRightTreeSum;\\n    }\\n}\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    // Time O(n) || Space O(1) || 1 Pass\\n    public int FindTilt(TreeNode root) {\\n        int oldTreeSum = 0;\\n        return FindTiltUtil(root, ref oldTreeSum);\\n    }\\n    public static int FindTiltUtil(TreeNode root, ref int oldTreeSum)\\n    {\\n        if(root==null) return 0;\\n        int oldLeftTreeSum=0,oldRightTreeSum=0;\\n        \\n        int newLeftTreeSum = FindTiltUtil(root.left, ref oldLeftTreeSum);\\n        int newRightTreeSum = FindTiltUtil(root.right, ref oldRightTreeSum);\\n        \\n        oldTreeSum = root.val+ oldLeftTreeSum+ oldRightTreeSum;\\n        root.val = Math.Abs(oldLeftTreeSum- oldRightTreeSum);\\n        return root.val+newLeftTreeSum+newRightTreeSum;\\n    }\\n}\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928288,
                "title": "binary-tree-tilt-clean-recursion-explained",
                "content": "The most important thing to note here is that: **We don\\'t need to keep track of invidual tilts of nodes**\\nTherefore; Recursion Goes like this-\\nSum of node values= node->value + sum of values(left) + sum of values(right);\\nSum of tilt values= sum of tilts(left) + sum of tilts(right) + |sum of values(right) - sum of values(left)|\\n\\nSum of node values is returned to keep track of left subtree sum and right subtree sum of higher nodes as that is required to calculate tilt. In the code, I return both the sum of values upto this node and sum of tilts upto this node as a pair.\\n\\n```\\nclass Solution {\\npublic:\\n    int findTilt(TreeNode* root) \\n    {\\n        if(root == nullptr) return 0;\\n        \\n        pair<int, int> left, right;\\n        if(root->left != nullptr) left = sum(root->left);\\n        else left= make_pair(0,0);\\n        \\n        if(root->right != nullptr) right = sum(root->right);\\n        else right= make_pair(0,0);\\n        \\n        int leftsum= left.first;\\n        int rightsum= right.first;\\n        \\n        int tilt= left.second + right.second + abs(rightsum-leftsum);\\n        \\n        return tilt;\\n    }\\n    \\n    pair<int,int> sum(TreeNode* root)\\n    {\\n        pair<int, int> left, right;\\n        if(root->left != nullptr) left = sum(root->left);\\n        else left= make_pair(0,0);\\n        \\n        if(root->right != nullptr) right = sum(root->right);\\n        else right= make_pair(0,0);\\n        \\n        int leftsum= left.first;\\n        int rightsum= right.first;\\n        \\n        int tilt= left.second + right.second + abs(rightsum-leftsum);\\n        \\n        return make_pair(root->val+leftsum+rightsum, tilt);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTilt(TreeNode* root) \\n    {\\n        if(root == nullptr) return 0;\\n        \\n        pair<int, int> left, right;\\n        if(root->left != nullptr) left = sum(root->left);\\n        else left= make_pair(0,0);\\n        \\n        if(root->right != nullptr) right = sum(root->right);\\n        else right= make_pair(0,0);\\n        \\n        int leftsum= left.first;\\n        int rightsum= right.first;\\n        \\n        int tilt= left.second + right.second + abs(rightsum-leftsum);\\n        \\n        return tilt;\\n    }\\n    \\n    pair<int,int> sum(TreeNode* root)\\n    {\\n        pair<int, int> left, right;\\n        if(root->left != nullptr) left = sum(root->left);\\n        else left= make_pair(0,0);\\n        \\n        if(root->right != nullptr) right = sum(root->right);\\n        else right= make_pair(0,0);\\n        \\n        int leftsum= left.first;\\n        int rightsum= right.first;\\n        \\n        int tilt= left.second + right.second + abs(rightsum-leftsum);\\n        \\n        return make_pair(root->val+leftsum+rightsum, tilt);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564637,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 1565571,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 1574580,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 1569418,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 1569136,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 1570112,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 2023081,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 2040627,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 2003711,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 1911237,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 1564637,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 1565571,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 1574580,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 1569418,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 1569136,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 1570112,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 2023081,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 2040627,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 2003711,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            },
            {
                "id": 1911237,
                "content": [
                    {
                        "username": "igornovik",
                        "content": "I think that explanation and example provided are not sufficient. You need to have a biger tree to explain this problem:\\n\\nInput :\\n     4\\n     / \\\\\\\\\\n   2   9\\n   / \\\\     \\\\\\\\\\n 3   5   7\\nOutput : 15\\nExplanation: \\nTilt of node 3 : 0\\nTilt of node 5 : 0\\nTilt of node 7 : 0\\nTilt of node 2 : |3-5| = 2\\nTilt of node 9 : |0-7| = 7\\nTilt of node 4 : |(3+5+2)-(9+7)| = 6\\nTilt of binary tree : 0 + 0 + 0 + 2 + 7 + 6 = 15\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-tilt/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Post-Order DFS Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Hi All,\\nWanted to understand why this disliked most number of times.\\nwhat makes people to dislike this qn, seriously want to understand other people perspective"
                    },
                    {
                        "username": "kingmaker2211",
                        "content": "[@ajinkode](/ajinkode) Dont throw the statistical knowledge like a garbage. You may face a similar situation."
                    },
                    {
                        "username": "ajinkode",
                        "content": "They dislike it because they weren\\'t able to solve it despite the question being easy."
                    },
                    {
                        "username": "lydon",
                        "content": "![image](https://assets.leetcode.com/users/lydon/image_1548826457.png)\\nSo when this tree is visualized it looks like \\n\\n      1\\n  /      \\\\ \\n 2       3\\n/           \\\\\\n4          5\\n\\nSo we have 2 + 4 = 6 on the left and 3 + 5 = 8 on the right, and | 6 - 8 | = 2 so what am I missing here?"
                    },
                    {
                        "username": "isinha28",
                        "content": "That\\'s the tilt for the root node. You need to compute the tilts for all nodes and return the sum of all of these tilts."
                    },
                    {
                        "username": "f1re",
                        "content": "Link to problem: https://leetcode.com/problems/binary-tree-tilt/#/description\\n\\nTest case to explain: [1,2,3,4,null,5]\\nExpected O/P for test case: 11\\nMy O/P: 10\\n\\nKindly explain the approach arithmetically and program logic is not required."
                    },
                    {
                        "username": "isinha28",
                        "content": "Tilt for 4: 0 (since it has no left or right sub-trees)\nTilt for 2: 4 (since it has only one left sub-tree which has a sum of 4)\nTilt for 5: 0 (since it has no left or right sub-trees)\nTilt for 3: 5 (since it has only one left sub-tree which has a sum of 5)\nTilt for 1: 2 (since the sum of its left sub-tree is 6 and the sum of its right sub-tree is 8)\n\nSum of all tilts: 0 + 4 + 0 + 5 + 2 = 11"
                    },
                    {
                        "username": "AdityaKaushal",
                        "content": "This is stupid question. Don\\'t waste time if you don\\'t pass test cases. This question in poorly explained"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Why the hell 2.1k\\uD83D\\uDC4E\\uD83C\\uDFFC"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand why is hard to read, is pretty understandable And is probably the one that appear in interviews to filter a chunk of candidates. I honestly don\\'t think is easy-easy but more medium-easy and I don\\'t have an intuition to solve this, looks like DFS but idk"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Recursive Approach $O(N)$, Beats 100%:\\nhttps://leetcode.com/problems/binary-tree-tilt/solutions/3874463/recursive-approach-o-n-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "jpho",
                        "content": "whoever wrote this question should be fired!!!!!! jk, but seriously what the heck."
                    }
                ]
            }
        ]
    }
]