[
    {
        "title": "Construct K Palindrome Strings",
        "question_content": "Given a string s and an integer k, return true if you can use all the characters in s to construct k palindrome strings or false otherwise.\n&nbsp;\nExample 1:\n\nInput: s = \"annabelle\", k = 2\nOutput: true\nExplanation: You can construct two palindromes using all characters in s.\nSome possible constructions \"anna\" + \"elble\", \"anbna\" + \"elle\", \"anellena\" + \"b\"\n\nExample 2:\n\nInput: s = \"leetcode\", k = 3\nOutput: false\nExplanation: It is impossible to construct 3 palindromes using all the characters of s.\n\nExample 3:\n\nInput: s = \"true\", k = 4\nOutput: true\nExplanation: The only possible solution is to put each character in a separate string.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 105\n\ts consists of lowercase English letters.\n\t1 <= k <= 105",
        "solutions": [
            {
                "id": 563379,
                "title": "java-c-python-straight-forward",
                "content": "# **Intuition**\\nCondition 1. `odd characters <= k`\\nCount the occurrences of all characters.\\nIf one character has odd times occurrences,\\nthere must be at least one palindrome,\\nwith odd length and this character in the middle.\\nSo we count the characters that appear odd times,\\nthe number of odd character should not be bigger than `k`.\\n\\nCondition 2. `k <= s.length()`\\nAlso, if we have one character in each palindrome,\\nwe will have at most `s.length()`  palindromes,\\nso we need `k <= s.length()`.\\n\\nThe above two condition are necessary and sufficient conditions for this problem.\\nSo we return `odd <= k <= n`\\n<br>\\n\\n# **Construction**\\n@spjparmar immediately got a question like why this works always for all strings.\\nHe gave the some following dry runs. :)\\nFor any string with 0 odd character count , we can form k no. of palindrome strings for sure with k<=n\\n(This is why k<=n)\\n\\n**eg**\\naabb, k=1| abba\\naabb, k=2 | aa, bb\\naabb, k=3 | a, a, bb\\naabb, k=4 | a, a, b, b\\n\\nFor any string with odd character count <=k , we can always form k palindrome string for sure with k<=n\\n**eg2**\\naabbc, k=1 | aacbb\\naabbc, k=2 | aca, bb\\naabbc, k=3 | a,a, bcb\\naabbc, k=4 | a, a, c ,bb\\naabbc, k=5 | a, a, c, b, b\\n\\n**eg3**\\naabc, k=1 | N/A\\naabc, k=2 | aba, c\\naabc, k=3 | aa, b, c\\naabc, k=4 | a, a, b, c\\n\\nHope this helps somebody.\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0, n = s.length(), count[] = new int[26];\\n        for (int i = 0; i < n; ++i) {\\n            count[s.charAt(i) - \\'a\\'] ^= 1;\\n            odd += count[s.charAt(i) - \\'a\\'] > 0 ? 1 : -1;\\n        }\\n        return odd <= k && k <= n;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    bool canConstruct(string s, int k) {\\n        bitset<26> odd;\\n        for (char& c : s)\\n            odd.flip(c - \\'a\\');\\n        return odd.count() <= k && k <= s.length();\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def canConstruct(self, s, k):\\n        return sum(i & 1 for i in collections.Counter(s).values()) <= k <= len(s)\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0, n = s.length(), count[] = new int[26];\\n        for (int i = 0; i < n; ++i) {\\n            count[s.charAt(i) - \\'a\\'] ^= 1;\\n            odd += count[s.charAt(i) - \\'a\\'] > 0 ? 1 : -1;\\n        }\\n        return odd <= k && k <= n;\\n    }\\n```\n```cpp\\n    bool canConstruct(string s, int k) {\\n        bitset<26> odd;\\n        for (char& c : s)\\n            odd.flip(c - \\'a\\');\\n        return odd.count() <= k && k <= s.length();\\n    }\\n```\n```py\\n    def canConstruct(self, s, k):\\n        return sum(i & 1 for i in collections.Counter(s).values()) <= k <= len(s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 563298,
                "title": "java-python-3-count-odd-occurrences-2-codes-w-brief-explanation-and-analysis",
                "content": "**Explanation of the method** - credit to **@lionkingeatapple**\\nIf we need to construct `k` palindromes, and each palindrome at most has`1` character with odd times of occurrence. The oddest times of occurrence we can have is `1 * k = k`. Therefore, `oddNum <= k`. And it is impossible to construct `k` palindromes when the input string s\\'s length is less than `k`. So we can conclude that in order to construct `k` palindromes it must satisfy the condition `oddNum <= k` && `k <= s.length()`.\\n\\n----\\n\\n1. Each palindrome at most has one character with odd times of occurrence;\\n2. `Non-empty` means each  palindrome at least has one character, hence `k <= s.length()`.\\n\\n**Method 1:**\\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            ++count[s.charAt(i) - \\'a\\'];\\n        }\\n        int oddNum = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            oddNum += count[i] % 2;\\n        }\\n        return oddNum <= k && k <= s.length();\\n    }\\n```\\nOr make the above 2 for loops as 1:\\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int[] count = new int[26];\\n        int oddNum = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            oddNum += ++count[s.charAt(i) - \\'a\\'] % 2 == 0 ? -1 : 1;\\n        }\\n        return oddNum <= k && k <= s.length();\\n    }\\n```\\n```python\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return sum(v % 2 for v in collections.Counter(s).values()) <= k <= len(s)\\n```\\n\\n----\\n\\n**Method 2:**\\nOr use bit manipulation:\\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            odd ^= 1 << (s.charAt(i) - \\'a\\');\\n        }\\n        return Integer.bitCount(odd) <= k && k <= s.length();\\n    }\\n```\\n```python\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        odd = 0\\n        for c in s:\\n            odd ^= 1 << (ord(c) - ord(\\'a\\'))\\n        return bin(odd).count(\\'1\\') <= k <= len(s)\\n```\\n\\n**Analysis:**\\nTime: O(n), space: O(1), where n = s.length().",
                "solutionTags": [],
                "code": "```java\\n    public boolean canConstruct(String s, int k) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            ++count[s.charAt(i) - \\'a\\'];\\n        }\\n        int oddNum = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            oddNum += count[i] % 2;\\n        }\\n        return oddNum <= k && k <= s.length();\\n    }\\n```\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int[] count = new int[26];\\n        int oddNum = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            oddNum += ++count[s.charAt(i) - \\'a\\'] % 2 == 0 ? -1 : 1;\\n        }\\n        return oddNum <= k && k <= s.length();\\n    }\\n```\n```python\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return sum(v % 2 for v in collections.Counter(s).values()) <= k <= len(s)\\n```\n```java\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            odd ^= 1 << (s.charAt(i) - \\'a\\');\\n        }\\n        return Integer.bitCount(odd) <= k && k <= s.length();\\n    }\\n```\n```python\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        odd = 0\\n        for c in s:\\n            odd ^= 1 << (ord(c) - ord(\\'a\\'))\\n        return bin(odd).count(\\'1\\') <= k <= len(s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 809033,
                "title": "clear-python-3-solution-faster-than-91-with-explanation",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k > len(s):\\n            return False\\n        h = Counter(s)\\n        countOdd = 0\\n        for value in h.values():\\n            if value % 2:\\n                countOdd += 1\\n        if countOdd > k:\\n            return False\\n        return True\\n```\\nThe solution is based on the understanding that a string can be a palindrome only if it has **at most 1 character** whose frequency is odd. So if the number of characters having an odd frequency is greater than the number of palindromes we need to form, then naturally it\\'s impossible to do so.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k > len(s):\\n            return False\\n        h = Counter(s)\\n        countOdd = 0\\n        for value in h.values():\\n            if value % 2:\\n                countOdd += 1\\n        if countOdd > k:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337643,
                "title": "c-super-simple-solution-only-6-short-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (s.size() < k) return false;\\n        \\n        vector<int> freq(26);\\n        for (auto ch : s) freq[ch - \\'a\\']++;\\n        \\n        int odd = 0;\\n        for (auto f : freq) odd += (f % 2);\\n        \\n        return odd <= k;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (s.size() < k) return false;\\n        \\n        vector<int> freq(26);\\n        for (auto ch : s) freq[ch - \\'a\\']++;\\n        \\n        int odd = 0;\\n        for (auto f : freq) odd += (f % 2);\\n        \\n        return odd <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564236,
                "title": "java-counting-simple-explained",
                "content": "Idea is following: count of chars can be even or odd. Those that are even - they can be used in one of substrings to form the palindrome, so we don\\'t care about those.\\nIf character has odd frequency - it can be inserted only 1 or 3 or 5... etc. to form the palindrome. However number of such characters cannot be more than number of strings, in other words - only one such char is allowed per substring. \\nThis leads to solution - count all frequencies, count those that are odd. If number of such chars > then k - it\\'s not possible to balance it to form all palindromes.\\n\\nO(n) time - iterate over every char in string to count freq.\\nO(1) space - use fixed size array to count freq.\\n\\n```\\n  public boolean canConstruct(String s, int k) {\\n    if (s == null || s.isEmpty() || s.length() < k)\\n      return false;\\n    \\n    int[] count = new int[26];\\n    //count freq of every character\\n    for (char ch : s.toCharArray()) ++count[ch - \\'a\\'];\\n    //count chars that has odd freq\\n    int countOfOdd = 0;\\n    for (int i = 0; i < 26; i++) \\n      if (count[i] % 2 == 1)\\n        ++countOfOdd;\\n    return countOfOdd <= k;\\n  }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n  public boolean canConstruct(String s, int k) {\\n    if (s == null || s.isEmpty() || s.length() < k)\\n      return false;\\n    \\n    int[] count = new int[26];\\n    //count freq of every character\\n    for (char ch : s.toCharArray()) ++count[ch - \\'a\\'];\\n    //count chars that has odd freq\\n    int countOfOdd = 0;\\n    for (int i = 0; i < 26; i++) \\n      if (count[i] % 2 == 1)\\n        ++countOfOdd;\\n    return countOfOdd <= k;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563647,
                "title": "java-o-n-time-and-o-1-space-beats-100",
                "content": "We can just simply use a 26 bit integer to store the set bits and then use XOR to flip the bits. \\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            odd ^= 1 << (s.charAt(i) - \\'a\\');\\n        }\\n        \\n        return Integer.bitCount(odd) <= k && k <= s.length(); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int odd = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            odd ^= 1 << (s.charAt(i) - \\'a\\');\\n        }\\n        \\n        return Integer.bitCount(odd) <= k && k <= s.length(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563311,
                "title": "c-number-of-odd-frequency-character",
                "content": "If `k` is more than `n` then palindromes are never possible.\\nOtherwise, if the odd frequency character count is less than `k`, you can always make `k` palindromes.\\n\\nFor example : `s = Leetcode` and `k = 5`\\n\\nWe have odd freq characters : `{L, e, t, c, o, d}` , we can create 5 palindromes, but then atleast one of the characters from these odd frequency ones, will be left, Hence false.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(k > n)\\n            return 0;\\n        if(k == n)\\n            return 1;\\n        vector<int> f(26);\\n        for(int i = 0; i < n; i++)\\n            f[s[i] - \\'a\\']++;\\n        \\n        int c = 0;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            if(f[i] % 2 == 1)\\n                c++;\\n        }\\n        return c <= k;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(k > n)\\n            return 0;\\n        if(k == n)\\n            return 1;\\n        vector<int> f(26);\\n        for(int i = 0; i < n; i++)\\n            f[s[i] - \\'a\\']++;\\n        \\n        int c = 0;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            if(f[i] % 2 == 1)\\n                c++;\\n        }\\n        return c <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911162,
                "title": "c-easy-t-c-o-n-and-s-c-o-1-beats-98-4-in-t-c-and-95-in-s-c",
                "content": "# Intuition: \\nCount for the number of charachters having odd number of occurences\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\nIf the number of odd occurences of charachters are less than k, we can partition the string in k no.of palndromes.We are counting for odd occurences because eve occurences can be arranged in any order around the \\'centre\\' of the palindrome.And we need to check additionally, if the k is less than the length of the string to be partiotined, then we don\\'t have any way do partition it.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n\\n        int a[26];  // to store the count of charachters\\n        memset(a,0,sizeof(a));\\n        int n=s.length();\\n        if(k>n)return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            a[s[i]-\\'a\\']++;\\n        }\\n        int res=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            // if count is odd, then increment the resultant\\n            if(a[i]%2)res++;\\n        }\\n        return res<=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n\\n        int a[26];  // to store the count of charachters\\n        memset(a,0,sizeof(a));\\n        int n=s.length();\\n        if(k>n)return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            a[s[i]-\\'a\\']++;\\n        }\\n        int res=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            // if count is odd, then increment the resultant\\n            if(a[i]%2)res++;\\n        }\\n        return res<=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382658,
                "title": "easy-c-explaination-o-n-using-map",
                "content": "class Solution {\\npublic:\\n\\n//         we can have only odd number of a particular char only one time in a pallindrome\\n   ```\\n bool canConstruct(string s, int k) \\n{\\n\\t\\t if(s.size()<k)\\n\\t\\t\\t\\treturn false;\\n       unordered_map<char,int> frq;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                    frq[s[i]]++;\\n            }\\n            int cnt=0;\\n            for(auto x: frq)\\n                    \\n            {\\n                    if(x.second%2==1)\\n                            cnt++;\\n            }\\n            if(cnt>k)\\n                    return false;\\n           else\\n            return true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n//         we can have only odd number of a particular char only one time in a pallindrome\\n   ```\\n bool canConstruct(string s, int k) \\n{\\n\\t\\t if(s.size()<k)\\n\\t\\t\\t\\treturn false;\\n       unordered_map<char,int> frq;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                    frq[s[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1351209,
                "title": "simple-java-solution",
                "content": "-Count all odd number of characters in string and check whether they are less or equal to k\\n```\\npublic boolean canConstruct(String s, int k) {\\n\\t\\tif(s.length()<k) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character,Integer> map=new HashMap<>();\\n\\t\\tfor(char c:s.toCharArray()) {\\n\\t\\t\\tmap.put(c,map.getOrDefault(c, 0)+1);\\n\\t\\t}\\n\\t\\tint odd=0;\\n\\t\\tfor(int count:map.values()) {\\n\\t\\t\\tif(count%2==1) {\\n\\t\\t\\t\\todd++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn odd<=k;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canConstruct(String s, int k) {\\n\\t\\tif(s.length()<k) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tHashMap<Character,Integer> map=new HashMap<>();\\n\\t\\tfor(char c:s.toCharArray()) {\\n\\t\\t\\tmap.put(c,map.getOrDefault(c, 0)+1);\\n\\t\\t}\\n\\t\\tint odd=0;\\n\\t\\tfor(int count:map.values()) {\\n\\t\\t\\tif(count%2==1) {\\n\\t\\t\\t\\todd++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn odd<=k;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563330,
                "title": "python-count-odd",
                "content": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s) < k:\\n            return False\\n        \\n        dic = {}\\n        for x in s:\\n            if x not in dic:\\n                dic[x] = 1\\n            else:\\n                dic[x] += 1\\n        \\n        odd = 0\\n        for key,val in dic.items():        \\n            odd += val % 2\\n        even = len(dic) - odd\\n        \\n        \\n        return True if odd <= k else False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s) < k:\\n            return False\\n        \\n        dic = {}\\n        for x in s:\\n            if x not in dic:\\n                dic[x] = 1\\n            else:\\n                dic[x] += 1\\n        \\n        odd = 0\\n        for key,val in dic.items():        \\n            odd += val % 2\\n        even = len(dic) - odd\\n        \\n        \\n        return True if odd <= k else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566998,
                "title": "java-solution",
                "content": "class Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\t\\n        int n = s.length();\\n        \\n        if(n<k)\\n        {\\n            return false;\\n        }\\n        \\n        HashMap<Character,Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char c = s.charAt(i);\\n            map.put(c,map.getOrDefault(c,0)+1);\\n        }\\n        \\n        int ans = 0; \\n        \\n        for(Map.Entry<Character,Integer> e:map.entrySet())\\n        {\\n            int v = e.getValue();\\n            \\n            if(v%2!=0)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans<=k;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\t\\n        int n = s.length();\\n        \\n        if(n<k)\\n        {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1674075,
                "title": "beginner-friendly-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int>mp;\\n        int counte=0,counto=0;\\n        for(auto ch:s){\\n            mp[ch]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2==0){\\n                counte++;\\n            }else{\\n                counto++;\\n            }\\n        }\\n        if(k>=counto&&s.length()>=k){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int>mp;\\n        int counte=0,counto=0;\\n        for(auto ch:s){\\n            mp[ch]++;\\n        }\\n        for(auto it:mp){\\n            if(it.second%2==0){\\n                counte++;\\n            }else{\\n                counto++;\\n            }\\n        }\\n        if(k>=counto&&s.length()>=k){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419950,
                "title": "js-o-n-solution-with-comments",
                "content": "```\\nvar canConstruct = function(s, k) {\\n\\t// if string length is less than k, we cannot form k palindromes from the string, so return false\\n    if(k > s.length) {\\n        return false;\\n    }\\n\\t// created a map to keep count of each letter in the string\\n    const map = new Map();    // O(26)\\n    for(let i = 0; i < s.length; ++i) {    // O(n)\\n        map.set(s[i], map.has(s[i]) ? map.get(s[i]) + 1 : 1);\\n    }\\n\\t// check how many letters have odd count\\n    let oddCount = 0;\\n    map.forEach((value, key) => {    // O(26)\\n        if(value % 2 !== 0) {\\n            ++oddCount;\\n        }\\n    })\\n\\t// if letters with odd count are greater than k, that means more than k palindromes need to be formed to\\n\\t// make palindromes from the string where all the letters are utilised, so return false\\n\\t// palindrome can be of 2 form: `aaaaa` and `aabaa`, one letter can have odd and even occurences, but \\n\\t// there will be at least x palindromes if x letters are there with odd number of frequency\\n    if(oddCount > k) {\\n        return false;\\n    }\\n\\t// since the previous conditions do not hold, we can make k palindromes from the string, so return true\\n    return true;\\n};\\n```\\nTime Complexity = O(n)\\nSpace Complexity = O(26) ~ O(1)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConstruct = function(s, k) {\\n\\t// if string length is less than k, we cannot form k palindromes from the string, so return false\\n    if(k > s.length) {\\n        return false;\\n    }\\n\\t// created a map to keep count of each letter in the string\\n    const map = new Map();    // O(26)\\n    for(let i = 0; i < s.length; ++i) {    // O(n)\\n        map.set(s[i], map.has(s[i]) ? map.get(s[i]) + 1 : 1);\\n    }\\n\\t// check how many letters have odd count\\n    let oddCount = 0;\\n    map.forEach((value, key) => {    // O(26)\\n        if(value % 2 !== 0) {\\n            ++oddCount;\\n        }\\n    })\\n\\t// if letters with odd count are greater than k, that means more than k palindromes need to be formed to\\n\\t// make palindromes from the string where all the letters are utilised, so return false\\n\\t// palindrome can be of 2 form: `aaaaa` and `aabaa`, one letter can have odd and even occurences, but \\n\\t// there will be at least x palindromes if x letters are there with odd number of frequency\\n    if(oddCount > k) {\\n        return false;\\n    }\\n\\t// since the previous conditions do not hold, we can make k palindromes from the string, so return true\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 724516,
                "title": "c-solution-based-on-pidgeonhole-principle",
                "content": "If we have more odd frequency characters than palindromes, then at least 2 odd frequency characters must be in the same palindrome. Since this is not possible, we return true if we have fewer or equal to k odd frequency characters.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (s.size() < k) return false;\\n        \\n        vector<int> count(26, 0);\\n        for (char c: s)\\n            count[c-\\'a\\']++;\\n        \\n        int countOdd = count_if(count.begin(), count.end(), [](int i) {\\n            return i % 2;\\n        });\\n        \\n        // Pidgeonhole, 2 odd freq chars must be in a palindrome, which is impossible        \\n        return countOdd <= k;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (s.size() < k) return false;\\n        \\n        vector<int> count(26, 0);\\n        for (char c: s)\\n            count[c-\\'a\\']++;\\n        \\n        int countOdd = count_if(count.begin(), count.end(), [](int i) {\\n            return i % 2;\\n        });\\n        \\n        // Pidgeonhole, 2 odd freq chars must be in a palindrome, which is impossible        \\n        return countOdd <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692722,
                "title": "o-1-most-detailed-explanation",
                "content": "The problem is quite simple and interesting as well. Lets start from very basic:\\n\\n**Q.** Suppose we are given a string ```str```, and we are free to jumble the characters, and we need to tell that wheather ```str``` can be palindrome after jumbling.\\n* So, we will keep a track of frequency of each character appeared in ```str``` (with the help of hashmap or array of size 26)\\n*  **Now how to check**: \\uD83D\\uDC49 Even occurances of any character ```c``` is allowed. But there must be either 0 or 1 character with odd occurances\\n*  For example: \"abba\" is palindrome and there are no character with odd frequency. Similarly, \"abcba\" or \"abcccba\" is also a palindrome but there is 1 character with odd frequency.\\n\\nKeeping this in mind: \\n* We will store the frequency of each character in input string using hashmap (or array of size 26).\\n* We have no issue with even frequency character. As they will always from palindrome.\\n* We are concerned with odd freq character. Count that how many character has odd frequency. [say cnt]\\n* In order to split input string into \\'k\\' palindromic string, number of odd freq character must be less than equal to k [or cnt<=k], \\n* This is because then only we can distribute each of the odd frequency character in one of the \\'k\\' strings.\\n* Simple! We are done! We are just required to check this condition only.\\n\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k){ return false; } // obvious edge case\\n        \\n        unordered_map<char, int> m; // {char, freq}\\n        for(int i=0; i<s.size(); i++){  m[s[i]]++;  }\\n\\t\\t\\n        int cnt=0; // to count odd freq character\\n        for(auto& it: m){\\n            if(it.second%2==1){ cnt++; }\\n        }\\n        return (cnt<=k);\\n    }\\n};\\n```\\nTime Complexity: O(26) ~ O(1)  ||  Space Complexity: O(26) ~ O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```str```\n```str```\n```str```\n```c```\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k){ return false; } // obvious edge case\\n        \\n        unordered_map<char, int> m; // {char, freq}\\n        for(int i=0; i<s.size(); i++){  m[s[i]]++;  }\\n\\t\\t\\n        int cnt=0; // to count odd freq character\\n        for(auto& it: m){\\n            if(it.second%2==1){ cnt++; }\\n        }\\n        return (cnt<=k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814817,
                "title": "c-python3-solution-xor",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Python3\\n```\\nclass Solution:\\n    def canConstruct(self, S, K):\\n        return bin(reduce(operator.xor, map(lambda x: 1 << (ord(x) - 97), S))).count(\\'1\\') <= K <= len(S)\\n```\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int val = 0;\\n        for(char c: s) val ^= (1 << (c - \\'a\\'));\\n        return k <= s.length() && __builtin_popcount(val) <= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, S, K):\\n        return bin(reduce(operator.xor, map(lambda x: 1 << (ord(x) - 97), S))).count(\\'1\\') <= K <= len(S)\\n```\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int val = 0;\\n        for(char c: s) val ^= (1 << (c - \\'a\\'));\\n        return k <= s.length() && __builtin_popcount(val) <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105478,
                "title": "python-beats-97-with-reasoning",
                "content": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\'\\'\\'\\n        For a palindrome, its odd-count character has to be less than or eqaul to one. \\n        Then in order to get k many palindromic substrings, the number of odd-count chracters in s has to be less than\\n        or equal to k \\'\\'\\'\\n        \\n        if len(s) < k:\\n            return False\\n        freq = Counter(s)\\n        return sum(1 for val in freq.values() if val % 2 != 0) <= k\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\'\\'\\'\\n        For a palindrome, its odd-count character has to be less than or eqaul to one. \\n        Then in order to get k many palindromic substrings, the number of odd-count chracters in s has to be less than\\n        or equal to k \\'\\'\\'\\n        \\n        if len(s) < k:\\n            return False\\n        freq = Counter(s)\\n        return sum(1 for val in freq.values() if val % 2 != 0) <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070676,
                "title": "math-javascript",
                "content": "Code is self explantory.\\nBasically we will follow the below steps:\\n1. Calculate frequency of all the characters\\n2. Those characters whose frequency is odd, see if they are greater than 2. if > 2 then increment `evens` counts along\\n    with incrementing `odds`.\\n3. We **assume** \\tthat we will make palindromic string of size **1** only out of `odds` . \\n4. `k - odds` palindromic strings are required to be made out of `s.length - odds` characters. Which is possible as \\n    `k - odds < s.length - odds` which is resulted in (`odds` getting cancelled from both the side), `k < s.length` (which we are checking earlier in first line) \\n5. We can make `k - odds` strings out of `evens` which consitutes `s.length - odds` characters. \\n\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n    if (s.length < k) {\\n        /*\\n        * s = \\'cr\\', k = 7\\n        * Can not make 7 palindromic strings out of string length of 2\\n        *\\n        * In short, atleast k characters are required in the string.\\n        */\\n        return false;\\n    }\\n    \\n    if (s.length === k) {\\n        /*\\n        * s = \"true\", k = 4\\n        * Four palindromic strings of length 1 can be made out of s.\\n        */\\n        return true;\\n    }\\n    \\n    const hash = {};\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        hash[s[i]] || (hash[s[i]] = 0);\\n        hash[s[i]]++;\\n    }\\n    \\n    let odds = 0;\\n    let evens = 0;\\n    let key;\\n    \\n    const keys = Object.keys(hash);\\n    for(let i = 0; i < keys.length; i++) {\\n        key = keys[i];\\n        \\n        if (hash[key] % 2 === 0) {\\n            evens++;\\n        } else {\\n            if (Math.floor(hash[key] / 2) > 0) {\\n                /*\\n                * s = \"annabellebb\", b is 3 times, which is 2 + 1 => meaning, \\n                * there is only 1 b left hanging without getting paired. Which needs \\n                * chars around it to form palidromic sequence\\n                */\\n                evens++;\\n            }\\n            odds++;\\n        }\\n    }\\n    \\n    if (odds > k) {\\n        /*\\n        * s = \"leetcode\", k = 3\\n        * There are 5 chars with frequence 1. They can\\'t be clubbed together to form palindromic strings\\n        *\\n        * Return false if k > number of odds in `s`\\n        */\\n        return false;\\n    }\\n    \\n    /*\\n    * In any other cases where odds < k, we can fit all other evens as per requirement\\n    * For e.g. s = \"annabellebb\", k = 3.  \\n    * \\n    * evens => a, b, e, l, n.  odds => b\\n    * odds < k => 1 < 3. \\n    * We can make (k - odds) palindromic sequnce with given `evens`. \\n    * a = 2, b = 2, e = 2, l = 2, n = 2 => Total 10 characters except 1 loose `b`.\\n    * They can make (k - odds) => 5 - 1 => 4 palindromic strings easily. \\n    *\\n    * So, basically s.length - odds => 11 - 1 => 10 can be easily made by all evens together. s.length < k is already taken care of in start\\n    */\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n    if (s.length < k) {\\n        /*\\n        * s = \\'cr\\', k = 7\\n        * Can not make 7 palindromic strings out of string length of 2\\n        *\\n        * In short, atleast k characters are required in the string.\\n        */\\n        return false;\\n    }\\n    \\n    if (s.length === k) {\\n        /*\\n        * s = \"true\", k = 4\\n        * Four palindromic strings of length 1 can be made out of s.\\n        */\\n        return true;\\n    }\\n    \\n    const hash = {};\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        hash[s[i]] || (hash[s[i]] = 0);\\n        hash[s[i]]++;\\n    }\\n    \\n    let odds = 0;\\n    let evens = 0;\\n    let key;\\n    \\n    const keys = Object.keys(hash);\\n    for(let i = 0; i < keys.length; i++) {\\n        key = keys[i];\\n        \\n        if (hash[key] % 2 === 0) {\\n            evens++;\\n        } else {\\n            if (Math.floor(hash[key] / 2) > 0) {\\n                /*\\n                * s = \"annabellebb\", b is 3 times, which is 2 + 1 => meaning, \\n                * there is only 1 b left hanging without getting paired. Which needs \\n                * chars around it to form palidromic sequence\\n                */\\n                evens++;\\n            }\\n            odds++;\\n        }\\n    }\\n    \\n    if (odds > k) {\\n        /*\\n        * s = \"leetcode\", k = 3\\n        * There are 5 chars with frequence 1. They can\\'t be clubbed together to form palindromic strings\\n        *\\n        * Return false if k > number of odds in `s`\\n        */\\n        return false;\\n    }\\n    \\n    /*\\n    * In any other cases where odds < k, we can fit all other evens as per requirement\\n    * For e.g. s = \"annabellebb\", k = 3.  \\n    * \\n    * evens => a, b, e, l, n.  odds => b\\n    * odds < k => 1 < 3. \\n    * We can make (k - odds) palindromic sequnce with given `evens`. \\n    * a = 2, b = 2, e = 2, l = 2, n = 2 => Total 10 characters except 1 loose `b`.\\n    * They can make (k - odds) => 5 - 1 => 4 palindromic strings easily. \\n    *\\n    * So, basically s.length - odds => 11 - 1 => 10 can be easily made by all evens together. s.length < k is already taken care of in start\\n    */\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1797109,
                "title": "simple-c-java-python-solutions",
                "content": "### C++ Solution\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        vector<int> mapp(26, 0);\\n        for(char c : s) mapp[c-\\'a\\']++;\\n        \\n        int sum=0;\\n        for(int i=0; i<26; i++) sum+=(mapp[i]%2);\\n        \\n        return sum<=k;\\n    }\\n};\\n```\\n\\n### Java Solution\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length() < k) return false;\\n        int mapp[] = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            mapp[c-\\'a\\']++;\\n        }\\n        int sum=0;\\n        for(int i=0; i<26; i++) sum+=(mapp[i]%2);\\n        \\n        return sum<=k;\\n    }\\n}\\n```\\n\\n### Python Solution\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        mapp = [0]*26\\n        for c in s:\\n            mapp[ord(c) - ord(\\'a\\')]+=1\\n        \\n        summ = 0\\n        for i in range(26):\\n            summ += mapp[i]%2\\n        \\n        return summ<=k\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        vector<int> mapp(26, 0);\\n        for(char c : s) mapp[c-\\'a\\']++;\\n        \\n        int sum=0;\\n        for(int i=0; i<26; i++) sum+=(mapp[i]%2);\\n        \\n        return sum<=k;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length() < k) return false;\\n        int mapp[] = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            mapp[c-\\'a\\']++;\\n        }\\n        int sum=0;\\n        for(int i=0; i<26; i++) sum+=(mapp[i]%2);\\n        \\n        return sum<=k;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        mapp = [0]*26\\n        for c in s:\\n            mapp[ord(c) - ord(\\'a\\')]+=1\\n        \\n        summ = 0\\n        for i in range(26):\\n            summ += mapp[i]%2\\n        \\n        return summ<=k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737785,
                "title": "c-simple-with-intution",
                "content": "# you just need to check if the character that are present odd number of times are greater than k or not \\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.length();\\n        vector<int>A(26,0);\\n        int odd = 0;\\n        int even = 0;\\n        if(n < k)\\n            return false;\\n        for(char c : s)\\n            A[c - \\'a\\']++;\\n        for(int a : A)\\n        {\\n            if(a == 0)\\n                continue;\\n            if(a % 2 == 1)\\n                odd++;\\n            else\\n                even++;\\n        }\\n        if(odd > k)\\n            return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.length();\\n        vector<int>A(26,0);\\n        int odd = 0;\\n        int even = 0;\\n        if(n < k)\\n            return false;\\n        for(char c : s)\\n            A[c - \\'a\\']++;\\n        for(int a : A)\\n        {\\n            if(a == 0)\\n                continue;\\n            if(a % 2 == 1)\\n                odd++;\\n            else\\n                even++;\\n        }\\n        if(odd > k)\\n            return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617060,
                "title": "java-simple-code-with-detailed-explanation",
                "content": "## Explanation\\n\\nThe idea is quite simple, the core concept is separating the characters in 2 categories:\\n* The ones that have an even amount of occurrences \\n* The ones that have an odd amount of ocurrences.\\n\\n### Even characters\\nThe characters that appear an even number of times are not a problem at all. Why? Because we can add them at the beginning and end of the palindrome without breaking the palindrome condition.\\n\\nLet\\'s see an example where **A** appears an odd number of times:\\n\\n- **A**???**A**\\n- **AA**???**AA**\\n- **AAA**???**AAA**\\n\\nWe don\\'t care what\\'s inside of the sandwich where **A** is the bread.\\n\\n## Odd characters\\nThis is the limiting factor while forming palindromes. Odd characters **MUST** be in the middle of the palindrome , if not it wouldn\\'t be a palindrome.\\n\\n- ???**A**???\\n- ???**AAA**???\\n- ???**AAAAA**???\\n\\nAlso this kind of arrangement are valid but it changes nothing for us:\\n- **A**???**A**???**A**\\n\\nThe problem is that there can be **only middle section** (where we can use our odd characters) per palindrome. So everything gets reduced to counting the amount of odd characters and checking if we have less odd characters than the amount of palindromes __k__.\\n\\n\\n## Code\\nCode is very basic once you understand the idea.\\n\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (s == null || s.isEmpty() || s.length() < k) return false;\\n        int[] count = new int[26];\\n        int odd = 0;\\n\\n        // Count ocurrences\\n        for(char c : s.toCharArray()){\\n            count[c - \\'a\\']++;\\n        }\\n        \\n        // Count characters with odd number of occurrences\\n        for (int i = 0; i < 26 ; i++) {\\n            if (count[i] % 2 != 0) odd++;\\n        }\\n        \\n        return odd <= k;\\n    }\\n}\\n```\\n\\nHope you liked the post, and now some shameless self-promotion: My blog where I also post explanations to LeetCode challenges https://pablomusumeci.com/categories/#leetcode",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (s == null || s.isEmpty() || s.length() < k) return false;\\n        int[] count = new int[26];\\n        int odd = 0;\\n\\n        // Count ocurrences\\n        for(char c : s.toCharArray()){\\n            count[c - \\'a\\']++;\\n        }\\n        \\n        // Count characters with odd number of occurrences\\n        for (int i = 0; i < 26 ; i++) {\\n            if (count[i] % 2 != 0) odd++;\\n        }\\n        \\n        return odd <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442930,
                "title": "python-for-beginners",
                "content": "\\tclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        from collections import Counter\\n        if len(s)<k:\\n            return False\\n        v2=[v for v,b in Counter(s).items() if b%2==1]\\n        if len(v2)>k:\\n            return False    \\n        return True",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        from collections import Counter\\n        if len(s)<k:\\n            return False\\n        v2=[v for v,b in Counter(s).items() if b%2==1]\\n        if len(v2)>k:\\n            return False    \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1079757,
                "title": "javascript-solution-with-comments",
                "content": "```\\n    // return false if length of string is less than k\\n    if(s.length<k) {\\n        return false;\\n    }\\n    // compute frequency of each char in string\\n    let map = new Map();\\n    for(let letter of s) {\\n        map.set(letter,(map.get(letter)||0)+1);\\n    }\\n\\t// return true is size of map is equal to k\\n    if(map.size === k) {\\n        return true;\\n    }\\n\\t// return true or false based on if the odd char count is less than K, or greater than or equal to K.\\n    let count = 0;\\n    for(let key of map.keys()) {\\n        count += map.get(key)%2\\n    }\\n    return count<=k;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    // return false if length of string is less than k\\n    if(s.length<k) {\\n        return false;\\n    }\\n    // compute frequency of each char in string\\n    let map = new Map();\\n    for(let letter of s) {\\n        map.set(letter,(map.get(letter)||0)+1);\\n    }\\n\\t// return true is size of map is equal to k\\n    if(map.size === k) {\\n        return true;\\n    }\\n\\t// return true or false based on if the odd char count is less than K, or greater than or equal to K.\\n    let count = 0;\\n    for(let key of map.keys()) {\\n        count += map.get(key)%2\\n    }\\n    return count<=k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1029137,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar canConstruct = function(s, k) {\\n    if(k === s.length) return true;\\n    if(k > s.length) return false;\\n    \\n    const freq = Array(26).fill(0);\\n    \\n    for(let c of s) {\\n        const idx = c.charCodeAt() - \\'a\\'.charCodeAt();\\n        freq[idx]++;\\n    }\\n    const odds = freq.filter(x => x%2).length;\\n    return odds <= k;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar canConstruct = function(s, k) {\\n    if(k === s.length) return true;\\n    if(k > s.length) return false;\\n    \\n    const freq = Array(26).fill(0);\\n    \\n    for(let c of s) {\\n        const idx = c.charCodeAt() - \\'a\\'.charCodeAt();\\n        freq[idx]++;\\n    }\\n    const odds = freq.filter(x => x%2).length;\\n    return odds <= k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016580,
                "title": "python-counting-solution",
                "content": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        counter = collections.Counter(s)\\n        odd = sum([1 for val in counter.values() if val % 2])\\n        return odd <= k and len(s) >= k",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        counter = collections.Counter(s)\\n        odd = sum([1 for val in counter.values() if val % 2])\\n        return odd <= k and len(s) >= k",
                "codeTag": "Java"
            },
            {
                "id": 679084,
                "title": "java-count-num-of-odds",
                "content": "False if either:\\n1, s.length() < k;\\nor \\n2, number of odd count chars > k;  (at most k char can be in the center)\\n```\\n    public boolean canConstruct(String s, int k) {\\n        if (s == null || s.length() < k) return false;\\n        int odds = 0, cnt[] = new int[26];\\n        for (char c : s.toCharArray()) cnt[c - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) odds += cnt[i] % 2;\\n        return odds <= k;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canConstruct(String s, int k) {\\n        if (s == null || s.length() < k) return false;\\n        int odds = 0, cnt[] = new int[26];\\n        for (char c : s.toCharArray()) cnt[c - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) odds += cnt[i] % 2;\\n        return odds <= k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 647852,
                "title": "faster-and-simpler",
                "content": "\\t\\tk>len(s):\\n            return False\\n        \\n        \\n        dc=collections.Counter(s)\\n        \\n        cnt=0\\n        for key,v in dc.items():\\n            if  v&1:\\n                cnt+=1\\n        if cnt > k:\\n            return False\\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t\\tk>len(s):\\n            return False\\n        \\n        \\n        dc=collections.Counter(s)\\n        \\n        cnt=0\\n        for key,v in dc.items():\\n            if  v&1:\\n                cnt+=1\\n        if cnt > k:\\n            return False\\n        return True",
                "codeTag": "Unknown"
            },
            {
                "id": 598638,
                "title": "super-easy-python-solution-with-explanation",
                "content": "\\n```\\n# The approach of the problem is that -\\n# 1) even length palindromes will have even no. of characters\\n# 2) odd length palindromes will have odd no. of characters\\n# 3) we can have only one letter in odd length palindrome which has odd occurence. \\n\\n# For eg:\\n#     s=\"aabbcccdd\" Here, a->2     k=4\\n#                         b->2  \\n#                         c->3\\n#                         d->2\\n                \\n#     now, \"aa\", \"bb\", \"cc\", \"dcd\", So, each odd occurence character can be adjusted in only one string to make it an odd plaindrome string. So, if we have no. of odd occurence characters greater than k, then we cannot have k palindrome strings.           \\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s)==k:\\n            return True\\n        if len(set(s))==k:\\n            return True\\n        \\n        if len(s)<k:\\n            return False\\n        \\n        count=0\\n        d=collections.Counter(s)\\n        print(d)\\n        l=list(d.keys())\\n        for i in range(len(l)):\\n            if d[l[i]]%2==1:\\n                count+=1\\n        return count<=k        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The approach of the problem is that -\\n# 1) even length palindromes will have even no. of characters\\n# 2) odd length palindromes will have odd no. of characters\\n# 3) we can have only one letter in odd length palindrome which has odd occurence. \\n\\n# For eg:\\n#     s=\"aabbcccdd\" Here, a->2     k=4\\n#                         b->2  \\n#                         c->3\\n#                         d->2\\n                \\n#     now, \"aa\", \"bb\", \"cc\", \"dcd\", So, each odd occurence character can be adjusted in only one string to make it an odd plaindrome string. So, if we have no. of odd occurence characters greater than k, then we cannot have k palindrome strings.           \\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s)==k:\\n            return True\\n        if len(set(s))==k:\\n            return True\\n        \\n        if len(s)<k:\\n            return False\\n        \\n        count=0\\n        d=collections.Counter(s)\\n        print(d)\\n        l=list(d.keys())\\n        for i in range(len(l)):\\n            if d[l[i]]%2==1:\\n                count+=1\\n        return count<=k        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 570939,
                "title": "c-solution-using-the-concept-that-atmost-k-odd-frequency-character-are-possisble",
                "content": "If u think in a broad way then what we can say is in  a given palindromic string atmost only one character can have  odd frequency and that element would be the position about which that string would be palindrome \\nso for K palindromic strings atmost K elements can have odd freq\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k)\\n            return false;\\n        \\n        vector<int> freq(256,0);\\n        \\n        for(auto ele : s)\\n            freq[ele]++;\\n        \\n        for(auto ele : freq){\\n            if(ele&1)\\n                k--;\\n            if(k < 0)\\n                return false;\\n        }        \\n        return true;        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k)\\n            return false;\\n        \\n        vector<int> freq(256,0);\\n        \\n        for(auto ele : s)\\n            freq[ele]++;\\n        \\n        for(auto ele : freq){\\n            if(ele&1)\\n                k--;\\n            if(k < 0)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 565262,
                "title": "c-3-lines",
                "content": "# the key is \"the number of odd char\" should be less than k\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> count(26,0);\\n        for(char c : s) count[c-\\'a\\']++;\\n        return (s.length() < k)?false:(k >= count_if(count.begin(),count.end(),[](int i) {return i%2==1;}));        \\n    }\\n};\\n```\\n\\nanother version:\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> cnt(26);\\n        for(char c : s) cnt[c-\\'a\\'] ^= 1;\\n        return (s.length() < k)?false:(k >= count(cnt.begin(),cnt.end(),1));        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> count(26,0);\\n        for(char c : s) count[c-\\'a\\']++;\\n        return (s.length() < k)?false:(k >= count_if(count.begin(),count.end(),[](int i) {return i%2==1;}));        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> cnt(26);\\n        for(char c : s) cnt[c-\\'a\\'] ^= 1;\\n        return (s.length() < k)?false:(k >= count(cnt.begin(),cnt.end(),1));        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563375,
                "title": "python-1line",
                "content": "```\\nreturn len(s) >= k and sum(i % 2 for i in Counter(s).values()) <= k\\n```",
                "solutionTags": [],
                "code": "```\\nreturn len(s) >= k and sum(i % 2 for i in Counter(s).values()) <= k\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3487709,
                "title": "simplest-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        unordered_map<char,int> m ; \\n        if(s.size()<k)\\n        return false; \\n        for(auto x:s)\\n        m[x]++; \\n\\n        int count = 0; \\n        for(auto x:m)\\n        if(x.second%2==1)\\n        count++; \\n\\n        return count<=k;\\n\\n\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        unordered_map<char,int> m ; \\n        if(s.size()<k)\\n        return false; \\n        for(auto x:s)\\n        m[x]++; \\n\\n        int count = 0; \\n        for(auto x:m)\\n        if(x.second%2==1)\\n        count++; \\n\\n        return count<=k;\\n\\n\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235832,
                "title": "simple-solution-using-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k) return true;\\n    if(s.size()<k) return false;\\n    unordered_map<char,int>mp;\\n    for(auto x:s) mp[x]++;\\n    int odd_count=0;\\n    for(auto x:mp){\\n        if(x.second%2!=0){\\n            odd_count++;\\n        }\\n    }\\n    return odd_count<=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k) return true;\\n    if(s.size()<k) return false;\\n    unordered_map<char,int>mp;\\n    for(auto x:s) mp[x]++;\\n    int odd_count=0;\\n    for(auto x:mp){\\n        if(x.second%2!=0){\\n            odd_count++;\\n        }\\n    }\\n    return odd_count<=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845875,
                "title": "this-is-how-it-works",
                "content": "lets talk about the case when k<s.size() // coz it is confusing lol\\n\\nit means we have to do k partitions\\n\\nsuppose no of odd occuring characters be : o\\nassuming o<=k\\n\\n----- ----- ----- ----- ----- ----  -----\\nsuppose these are k partitions, of different lengths ( might be of same length too)\\ni am represeting them by ----  ----  ----- -----  , where a character is present at \\' - \\' \\n\\nnow there are 2 subcases , either all of the k partitions contain one odd character\\n\\nhere q->denotes any character with odd freq \\n---q1---  ---q2---  --q3--  --q4--  --q5-- \\n\\n---q1--- is one partition , while ---q2--- is another and so on\\n\\nsuppose character a and b have odd frequeny, so q1 can be a or b\\nand q2 can be b or a respectively\\n\\nso after eliminating \"odd frequency of odd occuring characters\"\\nWE KNOW know every character has even freq.\\n\\nnow we can fill remaining spaces with elements .\\n\\n---q1--- | ---q2--- | ---q3---| ---q4---\\n\\nthese are the partitions and we are left with characters having even freqency,\\nand the remaining length to be filled in all the partitions is s.size()-[q1+q2...(odd frequency)]\\nif any position of any partition is filled with any character,\\nwe know that characters have even freq , so corresponding palindromic [reverse right to left]\\nposition can be filled with same character.\\nand we have used 2 characters of same type, so we still have all the characters with even freq.\\n\\nthis is how we can fill all partitions.\\n\\nnow same ideology can be extended when o<k\\n\\n\\nsuppose we put one odd character in each partition\\nso new partitions formed = o\\n partitions we need to create =k-o\\nremaining characters left=s.size()-o\\n\\nnow the ques is can we form k-o palindromic paritions given that\\nwe are left with all even freqency characters\\n\\nnow there are further 2 subcases\\nwhen k-o is even\\nwe are left with s.size()-o characters where (size()-o>k-o)\\nwe know all the size()-o character has its sibling ( it occurs even number of time)\\n\\nwe need to create k-o ( even no. of partitions)\\nso what we can do, choose one character and its sibling, and you can create two new partitions\\nnow in last steps, you will be left with characters , having even freq.\\nand you can put it anywhere. [ in any partition]\\n\\n\\n\\nwhat if k-o is odd?\\n\\nwe know k-o-1 is even so first fill at the remaining k-o-1 places .\\nnow we want to create one new partition right?\\nplace all the remaining characters in that partition.\\n\\n\\nIT CAN BE SHOWED THAT WE CAN ALWAYS CONSTRUCT K-PALINDROMS!\\n;) THIS IS INDEPTH PROOF OF THE SOLUTION :D\\n\\ni\\'ve not considered the trivial cases when s.size()<k || s.size()==k ;) they are self explanatory!\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "lets talk about the case when k<s.size() // coz it is confusing lol\\n\\nit means we have to do k partitions\\n\\nsuppose no of odd occuring characters be : o\\nassuming o<=k\\n\\n----- ----- ----- ----- ----- ----  -----\\nsuppose these are k partitions, of different lengths ( might be of same length too)\\ni am represeting them by ----  ----  ----- -----  , where a character is present at \\' - \\' \\n\\nnow there are 2 subcases , either all of the k partitions contain one odd character\\n\\nhere q->denotes any character with odd freq \\n---q1---  ---q2---  --q3--  --q4--  --q5-- \\n\\n---q1--- is one partition , while ---q2--- is another and so on\\n\\nsuppose character a and b have odd frequeny, so q1 can be a or b\\nand q2 can be b or a respectively\\n\\nso after eliminating \"odd frequency of odd occuring characters\"\\nWE KNOW know every character has even freq.\\n\\nnow we can fill remaining spaces with elements .\\n\\n---q1--- | ---q2--- | ---q3---| ---q4---\\n\\nthese are the partitions and we are left with characters having even freqency,\\nand the remaining length to be filled in all the partitions is s.size()-[q1+q2...(odd frequency)]\\nif any position of any partition is filled with any character,\\nwe know that characters have even freq , so corresponding palindromic [reverse right to left]\\nposition can be filled with same character.\\nand we have used 2 characters of same type, so we still have all the characters with even freq.\\n\\nthis is how we can fill all partitions.\\n\\nnow same ideology can be extended when o<k\\n\\n\\nsuppose we put one odd character in each partition\\nso new partitions formed = o\\n partitions we need to create =k-o\\nremaining characters left=s.size()-o\\n\\nnow the ques is can we form k-o palindromic paritions given that\\nwe are left with all even freqency characters\\n\\nnow there are further 2 subcases\\nwhen k-o is even\\nwe are left with s.size()-o characters where (size()-o>k-o)\\nwe know all the size()-o character has its sibling ( it occurs even number of time)\\n\\nwe need to create k-o ( even no. of partitions)\\nso what we can do, choose one character and its sibling, and you can create two new partitions\\nnow in last steps, you will be left with characters , having even freq.\\nand you can put it anywhere. [ in any partition]\\n\\n\\n\\nwhat if k-o is odd?\\n\\nwe know k-o-1 is even so first fill at the remaining k-o-1 places .\\nnow we want to create one new partition right?\\nplace all the remaining characters in that partition.\\n\\n\\nIT CAN BE SHOWED THAT WE CAN ALWAYS CONSTRUCT K-PALINDROMS!\\n;) THIS IS INDEPTH PROOF OF THE SOLUTION :D\\n\\ni\\'ve not considered the trivial cases when s.size()<k || s.size()==k ;) they are self explanatory!\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2780659,
                "title": "cpp-solution-using-hashmap-and-counting",
                "content": "# Intuition\\nCount the Number of occurence of characters in the string then find the number of odd number of ocurrence of characters.\\n\\n# Approach\\n-> If String is \\'S\\' and if the size of the string is equal to k(integer) then our answer is \"true\" because we can break them into different characters\\n\\n-> If String\\'s size is less than the k then it is not possible to break then into k palindrome strings\\n\\n-> Now, Use a Hashmap to store the number of occurence of the characters of the string\\n\\n-> If the number of characters that have odd counts is > k then the minimum number of palindrome strings we can construct is > k and answer is false, Otherwise you can construct exactly k palindrome strings and answer is true \\n\\n> Why?...... Because if we take all even count character along with one single odd count character in a single string they can form a palindromic string\\n\\n>For Example- S= \"annnabellee\" and k=3 then, possible construction will be \"anlebelna\" ,\"b\" ,\"e\" (you can arrange them for more permutations), If k=2 then answer would be false.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k)\\n        return true;\\n        if(s.size()<k)\\n        return false;\\n        \\n        map<char,int> mp;\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n\\n        int cnt=0;\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            if(itr->second%2!=0)\\n              cnt++;\\n        }\\n        if(cnt>k)\\n         return false;\\n\\n\\n   return true; }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k)\\n        return true;\\n        if(s.size()<k)\\n        return false;\\n        \\n        map<char,int> mp;\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n\\n        int cnt=0;\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            if(itr->second%2!=0)\\n              cnt++;\\n        }\\n        if(cnt>k)\\n         return false;\\n\\n\\n   return true; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608282,
                "title": "c-80-faster-than-all-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n       \\n        int n = s.size(), map[26];\\n        memset(map, 0, sizeof(map));\\n        for (char c : s) map[c - \\'a\\']++;\\n        \\n        int count = 0;\\n        for (int i = 0; i < 26; i++) if (map[i] % 2) count++;\\n        \\n        k -= count;\\n        \\n        int pairs = (n - count) / 2;\\n        while (k > pairs) {\\n            pairs--;\\n            k -= 2;\\n        }\\n        return k >= 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n       \\n        int n = s.size(), map[26];\\n        memset(map, 0, sizeof(map));\\n        for (char c : s) map[c - \\'a\\']++;\\n        \\n        int count = 0;\\n        for (int i = 0; i < 26; i++) if (map[i] % 2) count++;\\n        \\n        k -= count;\\n        \\n        int pairs = (n - count) / 2;\\n        while (k > pairs) {\\n            pairs--;\\n            k -= 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2557672,
                "title": "count-odd-occurances",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.length();\\n        if(k>n)\\n            return false;\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        int cnt=0;\\n        for(auto i: mp)\\n        {\\n            if(i.second%2)\\n                cnt++;\\n        }\\n        \\n        if(cnt>k)\\n            return false;\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.length();\\n        if(k>n)\\n            return false;\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        int cnt=0;\\n        for(auto i: mp)\\n        {\\n            if(i.second%2)\\n                cnt++;\\n        }\\n        \\n        if(cnt>k)\\n            return false;\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527806,
                "title": "java-explained-logic-of-odd-chars-in-detail-tc-sc",
                "content": "// Understanding Palindorme: A palindromic string is a string, which when read from left to right or right to left spells same\\n\\n// So some observations from above definition\\n// 1. Even Length String\\n// 1.1 An even length string NEEDS to have ALL the characters in PAIR (meaning the freq of each char is even)\\n// 1.2 If a string of even length has ANY character with ODD freq, it CANNOT be a palindrome\\n// 2. Odd Length String\\n// 2.1 An odd length string can ATMOST have 1 character with ODD freq\\n// 2.2 If an odd length string has MORE THAN 1 charcter with ODD freq, it cannot be a Palindorme\\n\\n// Conclusion from above : ANY string can have ATMOST 1 charcter with ODD freq to make it eligible to be a PALINDROME\\n\\n// k = num of palindromes we need to form\\n// So, if the num of CHARS with ODD freq are GREATER THAN \\'k\\', then we CANNOT make \\'k\\' palindromes\\n// WHY ? Because of the established facts above that a string can have ATMOST 1 CHAR with ODD freq to become palindorme and so if we have MORE chars with ODD freq than \\'k\\', then this means in some string MORE THAN 1 char with ODD freq needs to adjust and hence we cannot make \\'k\\' palindromes\\n\\n// TC : O(M + 26); M = s.length()\\n// SC : O(26)\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {     \\n        if(k > s.length()) return false;\\n        \\n        int numOddFreqChars = 0;\\n        int len = s.length();\\n        int[] charFreq = new int[26];\\n        \\n        for(int i = 0; i < len; i++) {\\n            charFreq[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < 26; i++) {\\n            if(charFreq[i] % 2 == 1) {\\n                numOddFreqChars++;\\n            }\\n        }\\n        \\n        return numOddFreqChars <= k;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {     \\n        if(k > s.length()) return false;\\n        \\n        int numOddFreqChars = 0;\\n        int len = s.length();\\n        int[] charFreq = new int[26];\\n        \\n        for(int i = 0; i < len; i++) {\\n            charFreq[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < 26; i++) {\\n            if(charFreq[i] % 2 == 1) {\\n                numOddFreqChars++;\\n            }\\n        }\\n        \\n        return numOddFreqChars <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463838,
                "title": "c-space-98-beats-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string &s, int &k) {\\n        if(s.length()<k)return false;\\n        if(s.length()==k)return true;\\n        vector<int> v(26,0);\\n        for(auto &i: s){\\n            v[i-\\'a\\']++;\\n        }\\n        for(auto &i: v){\\n            if(i%2)k--;\\n        }\\n        return k<0?false:true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string &s, int &k) {\\n        if(s.length()<k)return false;\\n        if(s.length()==k)return true;\\n        vector<int> v(26,0);\\n        for(auto &i: s){\\n            v[i-\\'a\\']++;\\n        }\\n        for(auto &i: v){\\n            if(i%2)k--;\\n        }\\n        return k<0?false:true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453837,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-dictionary",
                "content": "```C#\\npublic class Solution {\\n    public bool CanConstruct(string s, int k) {\\n        if (s.Length < k) return false;\\n        \\n        Dictionary<char, int> d = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++) {\\n            if (!d.ContainsKey(s[i])) d[s[i]] = 0;\\n            d[s[i]]++;\\n        }\\n        \\n        int singles = 0;\\n        foreach (var (_, count) in d) {\\n            singles += count % 2;\\n        }\\n        \\n        if (singles > k) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```C#\\npublic class Solution {\\n    public bool CanConstruct(string s, int k) {\\n        if (s.Length < k) return false;\\n        \\n        Dictionary<char, int> d = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++) {\\n            if (!d.ContainsKey(s[i])) d[s[i]] = 0;\\n            d[s[i]]++;\\n        }\\n        \\n        int singles = 0;\\n        foreach (var (_, count) in d) {\\n            singles += count % 2;\\n        }\\n        \\n        if (singles > k) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131445,
                "title": "very-easy-java-solution-no-bitwise-no-complex-logic",
                "content": "```\\npublic boolean canConstruct(String s, int k) {\\n        int[] hashTable = new int[26];\\n        if(s.length() < k)  return false;\\n        \\n        for(char ch : s.toCharArray())\\n            hashTable[ch-\\'a\\']++;\\n        \\n        int distinctCharCount=0;\\n        for(int i=0;i<26;i++){\\n            if(hashTable[i] !=0 && hashTable[i] % 2 != 0){\\n                distinctCharCount++;\\n                if(distinctCharCount > k)   return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canConstruct(String s, int k) {\\n        int[] hashTable = new int[26];\\n        if(s.length() < k)  return false;\\n        \\n        for(char ch : s.toCharArray())\\n            hashTable[ch-\\'a\\']++;\\n        \\n        int distinctCharCount=0;\\n        for(int i=0;i<26;i++){\\n            if(hashTable[i] !=0 && hashTable[i] % 2 != 0){\\n                distinctCharCount++;\\n                if(distinctCharCount > k)   return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2024069,
                "title": "java-easy-to-understand-hashset",
                "content": "class Solution {\\n   \\n    public boolean canConstruct(String s, int k) {\\n         if(k>s.length()) return false;\\n        Set<Character> set = new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            if(set.contains(c))set.remove(c);\\n            else set.add(c);\\n        }\\n        return set.size()<=k;\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n   \\n    public boolean canConstruct(String s, int k) {\\n         if(k>s.length()) return false;\\n        Set<Character> set = new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            if(set.contains(c))set.remove(c);\\n            else set.add(c);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2004975,
                "title": "fully-commented-java-code",
                "content": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        \\n        int n = s.length();\\n        \\n        //Only two cases are possible for contruction of k palindrome to be false\\n        // 1) We dont have enough characters\\n        // 2) We are exceeding the max limit\\n        \\n        //We can only contruct atmost n palindrome for a n length string\\n        if(k>n){\\n            return false;\\n        }\\n        \\n        // Now that we are sure we can contruct a string\\n        // We can be sure we are not exceeding the limit while forming palindrome\\n        // If k is 1 and the string is eeaabb we can still form a string and\\n        // make sure it doesn\\'t exceed limit\\n        // but problem comes with odd number where we have to make sure\\n        // it is not more than the count\\n        \\n        int numOdd = 0;\\n        \\n        int[] count = new int[26];\\n        \\n        for(char c: s.toCharArray()){\\n            count[c-\\'a\\']++;\\n        }\\n        \\n        \\n        \\n        for(int i=0; i<26; i++){\\n            if(count[i] % 2 != 0){\\n                numOdd++;\\n            }\\n        }\\n        \\n        return (numOdd <= k) ? true : false;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        \\n        int n = s.length();\\n        \\n        //Only two cases are possible for contruction of k palindrome to be false\\n        // 1) We dont have enough characters\\n        // 2) We are exceeding the max limit\\n        \\n        //We can only contruct atmost n palindrome for a n length string\\n        if(k>n){\\n            return false;\\n        }\\n        \\n        // Now that we are sure we can contruct a string\\n        // We can be sure we are not exceeding the limit while forming palindrome\\n        // If k is 1 and the string is eeaabb we can still form a string and\\n        // make sure it doesn\\'t exceed limit\\n        // but problem comes with odd number where we have to make sure\\n        // it is not more than the count\\n        \\n        int numOdd = 0;\\n        \\n        int[] count = new int[26];\\n        \\n        for(char c: s.toCharArray()){\\n            count[c-\\'a\\']++;\\n        }\\n        \\n        \\n        \\n        for(int i=0; i<26; i++){\\n            if(count[i] % 2 != 0){\\n                numOdd++;\\n            }\\n        }\\n        \\n        return (numOdd <= k) ? true : false;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974120,
                "title": "java-easy-to-understand-90-beat",
                "content": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(k > s.length()) {\\n            return false;\\n        }\\n        if(k == s.length()) {\\n            return true;\\n        }\\n        int[] freqCount = new int[26];\\n        for(char letter: s.toCharArray()) {\\n            freqCount[letter - \\'a\\']++;\\n        }\\n        int count = 0;\\n        for(int x: freqCount) {\\n            if(x % 2 == 1) {\\n                count++;\\n            }\\n        }\\n        return count <= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(k > s.length()) {\\n            return false;\\n        }\\n        if(k == s.length()) {\\n            return true;\\n        }\\n        int[] freqCount = new int[26];\\n        for(char letter: s.toCharArray()) {\\n            freqCount[letter - \\'a\\']++;\\n        }\\n        int count = 0;\\n        for(int x: freqCount) {\\n            if(x % 2 == 1) {\\n                count++;\\n            }\\n        }\\n        return count <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958062,
                "title": "java-solution-using-hashmap-clean-code-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (k > s.length()) return false; \\n        HashMap<Character, Integer> hash = new HashMap<>(); \\n        for (int i = 0; i < s.length(); i++){\\n            hash.put(s.charAt(i), hash.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        List<Integer> list = new ArrayList<Integer>(hash.values()); \\n        int tbt = 0; \\n        for (int i = 0; i < list.size(); i++){\\n            tbt += (list.get(i) % 2); \\n        }\\n        if (tbt <= k) return true; \\n        return false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (k > s.length()) return false; \\n        HashMap<Character, Integer> hash = new HashMap<>(); \\n        for (int i = 0; i < s.length(); i++){\\n            hash.put(s.charAt(i), hash.getOrDefault(s.charAt(i), 0) + 1);\\n        }\\n        List<Integer> list = new ArrayList<Integer>(hash.values()); \\n        int tbt = 0; \\n        for (int i = 0; i < list.size(); i++){\\n            tbt += (list.get(i) % 2); \\n        }\\n        if (tbt <= k) return true; \\n        return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885494,
                "title": "c-leetcode-1400-count-number-of-odd-frequency-letters",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if((int)s.size()<k)return false;\\n        if((int)s.size()==k)return true;\\n        int odds = 0;\\n        map<char,int> m;\\n        for(char c : s)\\n            m[c]++;\\n        for(auto x : m){\\n            if(x.second%2)\\n                odds++;\\n        }\\n        if(odds<=k)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if((int)s.size()<k)return false;\\n        if((int)s.size()==k)return true;\\n        int odds = 0;\\n        map<char,int> m;\\n        for(char c : s)\\n            m[c]++;\\n        for(auto x : m){\\n            if(x.second%2)\\n                odds++;\\n        }\\n        if(odds<=k)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806250,
                "title": "python-solution",
                "content": "To construct a palindrome string, every character must have an even number of total count in the string. Only the character in the middle can have a total count of 1. eg: \\'abbcbba\\'. So, to construct k palindrome sub-strings from a single string (s), there should only be k or less than k number of characters having an odd total count in the string (s).\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k > len(s):\\n            return False\\n        dic = {}\\n        \\n        for i in s:\\n            if i not in dic:\\n                dic[i] = 1\\n            else:\\n                dic[i] += 1\\n        c = 0        \\n        for i in dic.values():\\n            if i % 2 == 1:\\n                c += 1\\n        \\n        if c > k:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k > len(s):\\n            return False\\n        dic = {}\\n        \\n        for i in s:\\n            if i not in dic:\\n                dic[i] = 1\\n            else:\\n                dic[i] += 1\\n        c = 0        \\n        for i in dic.values():\\n            if i % 2 == 1:\\n                c += 1\\n        \\n        if c > k:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672032,
                "title": "c-easy-to-understand-simple-solution-with-explaination",
                "content": "**The trick is to understand that the characters which occur for the odd number of times will form a separate palindromic string each time consisting either a sinle character or being present at the mid of a string. So, if the count of odd characters happens to be more than k , we return a false and likewise follows**\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> freq;\\n        for(char ch:s)\\n        {\\n            freq[ch]++;\\n        }\\n        int oddCount=0;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second%2)\\n            {\\n                oddCount++;\\n            }\\n        }\\n        return oddCount<=k&&k<=s.length();\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> freq;\\n        for(char ch:s)\\n        {\\n            freq[ch]++;\\n        }\\n        int oddCount=0;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second%2)\\n            {\\n                oddCount++;\\n            }\\n        }\\n        return oddCount<=k&&k<=s.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667062,
                "title": "easy-c-hashmap-solution",
                "content": "Here in the below code, oddCount is: No.of characters whose frequency is odd.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        int n = s.size();\\n        if(k > n)return false;\\n        \\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)m[s[i]]++;\\n        \\n        int oddCount = 0;\\n        for(auto i:m)\\n        {\\n            if((i.second)%2 != 0)oddCount++;\\n        }\\n        \\n        if(oddCount <= k)return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        int n = s.size();\\n        if(k > n)return false;\\n        \\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)m[s[i]]++;\\n        \\n        int oddCount = 0;\\n        for(auto i:m)\\n        {\\n            if((i.second)%2 != 0)oddCount++;\\n        }\\n        \\n        if(oddCount <= k)return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656887,
                "title": "simple-python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        ocr = Counter(s)\\n        od = 0\\n        ev = 0\\n        \\n        for i in ocr:\\n            if ocr[i] % 2 == 0:\\n                ev += 1\\n            else:\\n                od += 1\\n                \\n        if od == k:\\n            return True\\n        \\n        if k < od:\\n            return False\\n        \\n        if k > len(s):\\n            return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        ocr = Counter(s)\\n        od = 0\\n        ev = 0\\n        \\n        for i in ocr:\\n            if ocr[i] % 2 == 0:\\n                ev += 1\\n            else:\\n                od += 1\\n                \\n        if od == k:\\n            return True\\n        \\n        if k < od:\\n            return False\\n        \\n        if k > len(s):\\n            return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607563,
                "title": "lessons-learned",
                "content": "**Tricky problem**:\\n* One would only think in terms of **backtracking / dp** approach unless he knows the **greediness** involved in the definition of pallindrome:\\n\\t1.  **A word can be a pallindrome if it has atmost 1 odd count of chars**\\n\\t2.  A word is a pallindrome if \\'#1 is satisfied\\' and \\'chars are arranged in the pallindromic manner (read charAt(i++) == charAt(--j) until i and j meet)\\'.\\n#2 is well known. Whereas greediness is in #1. I never realized this hidden definition of pallindrome.\\n* So for 2 words to be both pallindromes, we can have atmost 1 oddCount from word1 and atmost1 oddCount from word2, totalling to atmost 2 oddCount from words 1 and 2. \\n**Generallizing, for k words to be pallindromes, validate the criteria of atmost k oddCount.**\\n\\n**Code**:\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int n = s.length();\\n        if (n == k) return true;\\n        if (k > n) return false;\\n        \\n        int[] charCountMap = new int[26];\\n        for (char c : s.toCharArray()) {\\n            ++charCountMap[c - \\'a\\'];\\n        }\\n        \\n        int oddCount = 0;\\n        for (int val : charCountMap) {\\n            if (val % 2 == 1) {\\n                ++oddCount;\\n                if (oddCount > k) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n/*\\n\\nif (s.length == k) return true;\\na, 1\\nab, 2\\n\\nabacdc, 2\\nabcdac, 2    - a:2, b:1, c:2, d:1\\nabbacddc, 2  - a:2, b:2, c:2, d:2\\n\\nabcabcabc, 3 - a:3, b:3, c:3\\nannabelle, 2 - a:2, n:2, b:1, e:2, l:2 \\n\\n\\nleetcode, 3 - l:1, t:1, c:1, o:1, d:1, e:3\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int n = s.length();\\n        if (n == k) return true;\\n        if (k > n) return false;\\n        \\n        int[] charCountMap = new int[26];\\n        for (char c : s.toCharArray()) {\\n            ++charCountMap[c - \\'a\\'];\\n        }\\n        \\n        int oddCount = 0;\\n        for (int val : charCountMap) {\\n            if (val % 2 == 1) {\\n                ++oddCount;\\n                if (oddCount > k) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n/*\\n\\nif (s.length == k) return true;\\na, 1\\nab, 2\\n\\nabacdc, 2\\nabcdac, 2    - a:2, b:1, c:2, d:1\\nabbacddc, 2  - a:2, b:2, c:2, d:2\\n\\nabcabcabc, 3 - a:3, b:3, c:3\\nannabelle, 2 - a:2, n:2, b:1, e:2, l:2 \\n\\n\\nleetcode, 3 - l:1, t:1, c:1, o:1, d:1, e:3\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530496,
                "title": "swift-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        var dict = [Character : Int]()\\n        for c in s {\\n            if dict[c] != nil {\\n                dict[c]! += 1\\n            } else {\\n                dict[c] = 1\\n            }\\n        }\\n        var numOdd = 0\\n        for val in dict.values {\\n            if val % 2 != 0 {\\n                numOdd += 1\\n            }\\n        }\\n        return k <= s.count && numOdd <= k\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        var dict = [Character : Int]()\\n        for c in s {\\n            if dict[c] != nil {\\n                dict[c]! += 1\\n            } else {\\n                dict[c] = 1\\n            }\\n        }\\n        var numOdd = 0\\n        for val in dict.values {\\n            if val % 2 != 0 {\\n                numOdd += 1\\n            }\\n        }\\n        return k <= s.count && numOdd <= k\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410197,
                "title": "short-java-solution",
                "content": "Just check number of characters with odd count. You need to create at least as many palindromic strings, since you can put at most 1 non-repeating character in a a palindromic string.\\n``` \\npublic boolean canConstruct(String s, int k) {\\n        int[] map = new int[26];\\n        for (int i = 0; i < s.length(); i++)\\n            map[s.charAt(i)-\\'a\\']++;\\n        int odd = 0;\\n        for (int i = 0; i < 26;i++)\\n            if (map[i]%2 == 1)\\n                odd++;\\n        \\n        return s.length() >= k && odd <= k;\\n    }\\n```\\n\\nOne pass solution\\n```\\npublic boolean canConstruct(String s, int k) {\\n        int[] map = new int[26];\\n         int odd = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            map[s.charAt(i)-\\'a\\']++;\\n            if (map[s.charAt(i)-\\'a\\']%2 == 1)\\n                odd++;\\n            else\\n                odd--;\\n        }\\n        return s.length() >= k && odd <= k;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\npublic boolean canConstruct(String s, int k) {\\n        int[] map = new int[26];\\n        for (int i = 0; i < s.length(); i++)\\n            map[s.charAt(i)-\\'a\\']++;\\n        int odd = 0;\\n        for (int i = 0; i < 26;i++)\\n            if (map[i]%2 == 1)\\n                odd++;\\n        \\n        return s.length() >= k && odd <= k;\\n    }\\n```\n```\\npublic boolean canConstruct(String s, int k) {\\n        int[] map = new int[26];\\n         int odd = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            map[s.charAt(i)-\\'a\\']++;\\n            if (map[s.charAt(i)-\\'a\\']%2 == 1)\\n                odd++;\\n            else\\n                odd--;\\n        }\\n        return s.length() >= k && odd <= k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1379866,
                "title": "97-53-time-efficient-simple-java-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k) return false;\\n        if(s.length()==k) return true;\\n        int[] f = new int[26];\\n        for(char ch : s.toCharArray())\\n            f[ch-\\'a\\']++;\\n        int oddCount=0, evenCount=0;\\n        for(int i=0; i<26; i++){\\n            if(f[i]%2!=0)\\n                oddCount++;\\n            else\\n                evenCount++;\\n        }\\n        return (evenCount != 0) && (oddCount<=k);\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k) return false;\\n        if(s.length()==k) return true;\\n        int[] f = new int[26];\\n        for(char ch : s.toCharArray())\\n            f[ch-\\'a\\']++;\\n        int oddCount=0, evenCount=0;\\n        for(int i=0; i<26; i++){\\n            if(f[i]%2!=0)\\n                oddCount++;\\n            else\\n                evenCount++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1347512,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return 0;\\n        map<int,int> freq;\\n        for(char i:s) freq[i]++;\\n        \\n        int singles=0,pairs=0;\\n        \\n        for(auto i:freq){\\n            if(i.second&1) {\\n                singles++;\\n                pairs=pairs+i.second/2;\\n            }\\n            else{\\n                pairs=pairs+i.second/2;\\n            }\\n        }\\n        \\n        if(singles>k) return 0;\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return 0;\\n        map<int,int> freq;\\n        for(char i:s) freq[i]++;\\n        \\n        int singles=0,pairs=0;\\n        \\n        for(auto i:freq){\\n            if(i.second&1) {\\n                singles++;\\n                pairs=pairs+i.second/2;\\n            }\\n            else{\\n                pairs=pairs+i.second/2;\\n            }\\n        }\\n        \\n        if(singles>k) return 0;\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277729,
                "title": "java-5-lines-of-code",
                "content": "Get char with odd count and if it greter then k return false else return true\\n\\n```\\npublic boolean canConstruct(String s, int k) {\\n      if(s.length() < k) return false;\\n      int[] arr = new int[26];\\n      for(int i = 0 ; i < s.length(); i++) arr[s.charAt(i) - \\'a\\']++;\\n      for(int i = 0 ; i < arr.length; i++) if(arr[i] % 2 != 0 && --k < 0) return false;\\n      return true; \\n    } \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canConstruct(String s, int k) {\\n      if(s.length() < k) return false;\\n      int[] arr = new int[26];\\n      for(int i = 0 ; i < s.length(); i++) arr[s.charAt(i) - \\'a\\']++;\\n      for(int i = 0 ; i < arr.length; i++) if(arr[i] % 2 != 0 && --k < 0) return false;\\n      return true; \\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1272281,
                "title": "java",
                "content": "class Solution {\\n\\n    public boolean canConstruct(String s, int k) {\\n        if(k>s.length())\\n            return false;\\n        if(k==s.length())\\n            return true;\\n        Map<Character,Integer> map=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        for(Map.Entry<Character,Integer> entry:map.entrySet()){\\n            if(entry.getValue() %2 !=0)\\n                count++;\\n        }\\n        if(count >k)\\n            return false;\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean canConstruct(String s, int k) {\\n        if(k>s.length())\\n            return false;\\n        if(k==s.length())\\n            return true;\\n        Map<Character,Integer> map=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        for(Map.Entry<Character,Integer> entry:map.entrySet()){\\n            if(entry.getValue() %2 !=0)\\n                count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1259128,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        int i,j,c,n;\\n        n=s.length();\\n        if(k>n)\\n            return false;\\n        int a[26]={0};\\n        for(i=0;i<n;++i)\\n        {\\n            j=s[i]-\\'a\\';\\n            ++a[j];\\n        }\\n        for(i=0;i<26;++i)\\n        {\\n            if(a[i]%2==1)\\n            {\\n                --k;\\n            }\\n        }\\n        return (k>=0);\\n    }\\n};\\n```\\n\\nA palidrome can have a maximum of one odd character.\\nSo we check the number of odd frequency alphabets\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        int i,j,c,n;\\n        n=s.length();\\n        if(k>n)\\n            return false;\\n        int a[26]={0};\\n        for(i=0;i<n;++i)\\n        {\\n            j=s[i]-\\'a\\';\\n            ++a[j];\\n        }\\n        for(i=0;i<26;++i)\\n        {\\n            if(a[i]%2==1)\\n            {\\n                --k;\\n            }\\n        }\\n        return (k>=0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248762,
                "title": "c-solution-100-faster-o-n-simple-with-explanation",
                "content": "Whether we can construct \"k\" palindrome strings or not depends on how many \"pairs\" of letters the orignal string have.\\nThe least of \"pairs\" is required, when there\\'re most of \"odd\" length of palindrome strings.\\n\\nExtremely, the first \"k-1\" palindrome strings have only \"one\" (odd) letter each, in total used \"k-1\" letters.\\nThe last palindrome string has \"n - (k - 1)\" letters, need at least \"(n - (k - 1)) / 2\" pairs of letters.\\n\\n```\\nbool canConstruct (char *s, int k) {\\n  int  n, pairs = 0;\\n  char map[128] = {0};\\n\\n  for (n = 0; s[n]; n++) {\\n    if (map[s[n]]) {\\n      pairs++;\\n      map[s[n]] = 0;\\n    } else {\\n      map[s[n]] = 1;\\n    }\\n  }\\n\\n  return (k >= n) && (pairs >= (n - k + 1) / 2);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConstruct (char *s, int k) {\\n  int  n, pairs = 0;\\n  char map[128] = {0};\\n\\n  for (n = 0; s[n]; n++) {\\n    if (map[s[n]]) {\\n      pairs++;\\n      map[s[n]] = 0;\\n    } else {\\n      map[s[n]] = 1;\\n    }\\n  }\\n\\n  return (k >= n) && (pairs >= (n - k + 1) / 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240733,
                "title": "c-simple-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        if(s.length() == k) return true;\\n        vector<int> alphabets(26,0);\\n        for(int i=0; i < s.length(); i++) alphabets[(int)s[i] - (int)\\'a\\']++;\\n        int oddCount = 0;\\n        for(int i=0; i<26; i++) if(alphabets[i]%2) oddCount++;\\n        if(oddCount > k) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        if(s.length() == k) return true;\\n        vector<int> alphabets(26,0);\\n        for(int i=0; i < s.length(); i++) alphabets[(int)s[i] - (int)\\'a\\']++;\\n        int oddCount = 0;\\n        for(int i=0; i<26; i++) if(alphabets[i]%2) oddCount++;\\n        if(oddCount > k) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206607,
                "title": "construct-k-palindrome-strings-explaination-with-diagram-comment-if-you-need-any-help",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length()<k)\\n            return false;\\n        int even{},odd{};\\n        map<char,int> m;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        if(m.size()==k)\\n            return true;\\n        for(auto x: m)\\n        {\\n            if(x.second%2==0)\\n                even++;\\n            else\\n                odd++;\\n        }\\n        if(odd>k)\\n            return false;\\n        return true;\\n       \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/850d9814-b390-458d-8277-2131dae16a10_1620923888.732838.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length()<k)\\n            return false;\\n        int even{},odd{};\\n        map<char,int> m;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        if(m.size()==k)\\n            return true;\\n        for(auto x: m)\\n        {\\n            if(x.second%2==0)\\n                even++;\\n            else\\n                odd++;\\n        }\\n        if(odd>k)\\n            return false;\\n        return true;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117334,
                "title": "python-1-liner",
                "content": "```py\\nfrom collections import Counter\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return len(s) >= k and sum([x%2 for x in Counter(s).values()]) <= k\\n```",
                "solutionTags": [],
                "code": "```py\\nfrom collections import Counter\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return len(s) >= k and sum([x%2 for x in Counter(s).values()]) <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111910,
                "title": "c-super-duper-simple-elegant-short-concise-easy-to-understand",
                "content": "C++ SUPER DUPER SIMPLE ELEGANT SHORT CONCISE EASY to UNDERSTAND \\n\\n```\\nclass Solution {\\n    \\npublic:\\n    bool canConstruct(string s, int k) {\\n        \\n        unordered_map<char,int> countMap;\\n        \\n        for(auto c : s)\\n            countMap[c]++;\\n        \\n        if(s.length() < k)\\n            return false;\\n        \\n        for(auto pr : countMap){\\n            k -= pr.second % 2==1 ? 1 : 0;\\n            if(k<0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    bool canConstruct(string s, int k) {\\n        \\n        unordered_map<char,int> countMap;\\n        \\n        for(auto c : s)\\n            countMap[c]++;\\n        \\n        if(s.length() < k)\\n            return false;\\n        \\n        for(auto pr : countMap){\\n            k -= pr.second % 2==1 ? 1 : 0;\\n            if(k<0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079932,
                "title": "python3-freq-table",
                "content": "**Algo**\\nCompute the frequency table of `s` and check if the count of odd occurrence `<= k`. Ofc, we need `k <= len(s)` as a prerequisite. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        freq = {}\\n        for c in s: \\n\\t\\t    freq[c] = 1 + freq.get(c, 0)\\n        return sum(freq[c]&1 for c in freq) <= k <= len(s)\\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        freq = {}\\n        for c in s: \\n\\t\\t    freq[c] = 1 + freq.get(c, 0)\\n        return sum(freq[c]&1 for c in freq) <= k <= len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078374,
                "title": "js-count-odd-occurrences-o-n-time-o-1-space-w-comments",
                "content": "The palindrome can be formed in a few ways:\\n1. One character at the middle and the same sequences but mirrored by both sides (abcda). There is only one odd character occurrence. Other cahracter occurrences are even.\\n2. Two same characters at the middle and the same but mirrored sequences by both sides (abccba). All characters occurrences are even.\\n\\nThat means that in worst case it\\'s still possible to form k palindromes if the number of odd character occurrences  are <= k.\\nThe idea is to count the number of occurrances for each character and compare it with k.\\nTime complexity is O(n).\\nSpace complexity is O(1).\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n    if (s.length < k) {\\n        // it\\'s not possible construct k non-empty palindromes if the number of characters in string is less than k\\n        return false;\\n    }\\n    // code of the first character in english alphabet\\n    const aCode = \\'a\\'.charCodeAt(0);\\n    // reserve and array for each possible character (26 in english alphabet)\\n    const counts = (new Array(26)).fill(0);\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        // substract the code of the first letter in the alpahbet from the code of current letter to make it fit in range of 0 - 25\\n        const code = s.charCodeAt(i) - aCode;\\n        // increment the character occurance\\n        counts[code]++;\\n    }\\n    let oddsCount = 0;\\n    for (let count of counts) {\\n        if (count % 2 === 1) {\\n            // count the number of odd characters\\n            oddsCount++;\\n        }\\n    }\\n    return oddsCount <= k;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n    if (s.length < k) {\\n        // it\\'s not possible construct k non-empty palindromes if the number of characters in string is less than k\\n        return false;\\n    }\\n    // code of the first character in english alphabet\\n    const aCode = \\'a\\'.charCodeAt(0);\\n    // reserve and array for each possible character (26 in english alphabet)\\n    const counts = (new Array(26)).fill(0);\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        // substract the code of the first letter in the alpahbet from the code of current letter to make it fit in range of 0 - 25\\n        const code = s.charCodeAt(i) - aCode;\\n        // increment the character occurance\\n        counts[code]++;\\n    }\\n    let oddsCount = 0;\\n    for (let count of counts) {\\n        if (count % 2 === 1) {\\n            // count the number of odd characters\\n            oddsCount++;\\n        }\\n    }\\n    return oddsCount <= k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1031277,
                "title": "c-check-odd-count-of-characters",
                "content": "A palindrome can be built in two ways:\\n1. Count of all characters is even, i.e. \"aabccbaa\" a->4, b->2, c->2\\n2. Only 1 character have odd count, i.e. \"aabcfcbaa\" a->4, b->2, c->2, f->1\\n\\nWe can check if at max we have k odd counts in the string if yes then we have the answer.\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k > s.size()) return false;\\n        unordered_map<char, int> mp;\\n        for(auto ch:s) {\\n            mp[ch]++;\\n        }\\n        int count = 0;\\n        for(auto m:mp) {\\n            if(m.second % 2 == 1) count++;\\n            if(count > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k > s.size()) return false;\\n        unordered_map<char, int> mp;\\n        for(auto ch:s) {\\n            mp[ch]++;\\n        }\\n        int count = 0;\\n        for(auto m:mp) {\\n            if(m.second % 2 == 1) count++;\\n            if(count > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968226,
                "title": "c-solution-beats-100-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string& s, int k) {\\n        ios_base::sync_with_stdio(0); cin.tie(0);\\n        if(s.size() < k)\\n            return false;\\n        \\n        int mask = 0;\\n        for(char c : s)\\n            mask ^= (1 << (c-\\'a\\'));\\n        \\n        return (__builtin_popcount(mask) <= k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string& s, int k) {\\n        ios_base::sync_with_stdio(0); cin.tie(0);\\n        if(s.size() < k)\\n            return false;\\n        \\n        int mask = 0;\\n        for(char c : s)\\n            mask ^= (1 << (c-\\'a\\'));\\n        \\n        return (__builtin_popcount(mask) <= k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956557,
                "title": "super-concise-and-clear-python-code-with-explanation",
                "content": "If there are not enough characters in s to make k palindromes, result = False. Edge case\\nFor all other cases:\\nFind the count of the each  letter in s. We now focus on letters that are odd in count. The letters with even count can form a new palidrome or wrap around an exisiting palindrome placing 2 at a time. \\nSo, the number of letters with odd count is what defines how many palindromes can be made.\\nAs long as the number of letters with odd count are less than or equal to k we can form k palindromes.\\n\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        count = collections.Counter(s)\\n        oddCount = sum(x%2 for x in count.values())\\n        return oddCount <= k\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        count = collections.Counter(s)\\n        oddCount = sum(x%2 for x in count.values())\\n        return oddCount <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931230,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k) return false;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char ch : s.toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        for (Character ch: map.keySet()) {\\n            if (map.get(ch) % 2 != 0) {\\n                k--;\\n            }\\n        }\\n        \\n        return k >= 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k) return false;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (char ch : s.toCharArray()) {\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        for (Character ch: map.keySet()) {\\n            if (map.get(ch) % 2 != 0) {\\n                k--;\\n            }\\n        }\\n        \\n        return k >= 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926801,
                "title": "c-solution-o-n-simple",
                "content": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int ar[26]={0};\\n        for(char c:s)\\n            ar[c-\\'a\\']++;\\n        int k1=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            k1+=ar[i]%2;\\n        }\\n        return (k>=k1 &&k<=s.size());\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int ar[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 913705,
                "title": "python-easy-to-understand",
                "content": "The logic being, to construct k palindrome strings, the number of letters with odd (or 1) counts need to be less than or equal to k (cause one palindrome string can only have 1 odd count letter in it) and length of s has to be greater than or equal to k.\\n\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        count=collections.Counter(list(s))\\n        c=0\\n        for v in count.values():\\n            if v%2!=0:\\n                c+=1\\n        if c<=k and len(s)>=k:\\n            return True\\n        else:\\n            return False",
                "solutionTags": [],
                "code": "The logic being, to construct k palindrome strings, the number of letters with odd (or 1) counts need to be less than or equal to k (cause one palindrome string can only have 1 odd count letter in it) and length of s has to be greater than or equal to k.\\n\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        count=collections.Counter(list(s))\\n        c=0\\n        for v in count.values():\\n            if v%2!=0:\\n                c+=1\\n        if c<=k and len(s)>=k:\\n            return True\\n        else:\\n            return False",
                "codeTag": "Python3"
            },
            {
                "id": 898912,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    //annabelle a=2 n=2 b=1 e=2 l=2 k=2 odd_char=1 true\\n    \\n    bool canConstruct(string s, int k) {\\n        if (k>s.size()) return false;\\n        unordered_map<char, int> char_map;\\n        for (auto x:s) {\\n            char_map[x]++;\\n        }\\n        int odd_char=0;\\n        for (auto y=char_map.begin(); y!=char_map.end(); y++) {\\n            if (y->second%2==1) {\\n                odd_char++;\\n                if (odd_char>k)\\n                    return false;\\n            }\\n        }\\n        return true;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //annabelle a=2 n=2 b=1 e=2 l=2 k=2 odd_char=1 true\\n    \\n    bool canConstruct(string s, int k) {\\n        if (k>s.size()) return false;\\n        unordered_map<char, int> char_map;\\n        for (auto x:s) {\\n            char_map[x]++;\\n        }\\n        int odd_char=0;\\n        for (auto y=char_map.begin(); y!=char_map.end(); y++) {\\n            if (y->second%2==1) {\\n                odd_char++;\\n                if (odd_char>k)\\n                    return false;\\n            }\\n        }\\n        return true;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878018,
                "title": "easy-o-n-java",
                "content": "```\\npublic boolean canConstruct(String s, int k) {\\n        if (k == s.length()) return true;\\n        if (s.length() < k) return false;\\n        int[] count = new int[26];\\n        for (char c : s.toCharArray()) count[c-\\'a\\']++;\\n        \\n        int countExceptions = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] % 2 == 1) { countExceptions++; }\\n            if (countExceptions > k) return false;\\n        }\\n        \\n        return true;\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "```\\npublic boolean canConstruct(String s, int k) {\\n        if (k == s.length()) return true;\\n        if (s.length() < k) return false;\\n        int[] count = new int[26];\\n        for (char c : s.toCharArray()) count[c-\\'a\\']++;\\n        \\n        int countExceptions = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] % 2 == 1) { countExceptions++; }\\n            if (countExceptions > k) return false;\\n        }\\n        \\n        return true;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 865794,
                "title": "consise-o-1-faster-than-100-c",
                "content": "You need to create seperate strings for odd count of characters only, also note that you can at most have 26 odd characters, so if 26<k<=s.size() doesn\\'t matter what characters you have in s you can always use all characters and create required palindromes.\\n```\\nclass Solution {\\n    int cnt[26];\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k>s.size())return 0;\\n        if(k>26)return 1;\\n        for(auto it:s)cnt[it-\\'a\\']++;\\n        int ans=0;\\n        for(auto it:cnt)if(it&1)ans++;\\n        return ans<=k;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int cnt[26];\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k>s.size())return 0;\\n        if(k>26)return 1;\\n        for(auto it:s)cnt[it-\\'a\\']++;\\n        int ans=0;\\n        for(auto it:cnt)if(it&1)ans++;\\n        return ans<=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 814496,
                "title": "very-very-simple-c-code-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k>s.length()){\\n            return false;\\n        }\\n        vector<int>count(26,0);\\n        for(int i=0;i<s.length();i++){\\n            count[s[i]-\\'a\\']++;\\n        }\\n        int odd=0;\\n        for(int i=0;i<26;i++){\\n            if(count[i]%2==1){\\n                odd++;\\n            }\\n        }\\n        if(odd>k){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k>s.length()){\\n            return false;\\n        }\\n        vector<int>count(26,0);\\n        for(int i=0;i<s.length();i++){\\n            count[s[i]-\\'a\\']++;\\n        }\\n        int odd=0;\\n        for(int i=0;i<26;i++){\\n            if(count[i]%2==1){\\n                odd++;\\n            }\\n        }\\n        if(odd>k){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784545,
                "title": "minimal-c-using-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (k > s.size())\\n            return false;\\n        \\n        uint mask = 0;\\n        for (auto c : s)\\n            mask ^= 1 << (c - \\'a\\');\\n        \\n        return (__builtin_popcount(mask) <= k);  // C++20 has std::popcount()\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (k > s.size())\\n            return false;\\n        \\n        uint mask = 0;\\n        for (auto c : s)\\n            mask ^= 1 << (c - \\'a\\');\\n        \\n        return (__builtin_popcount(mask) <= k);  // C++20 has std::popcount()\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752927,
                "title": "python-simple-soln",
                "content": "```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        \"\"\"\\n        For string to be pallindrome, it can either have 0 or 1 number of odd count characters.\\n        For string to have k pallindomes, it can have 0 - k number of odd count characters. \\n        \"\"\"\\n        if k > len(s):\\n            return False\\n        \\n        hashmap = collections.defaultdict(int)\\n        \\n        for ch in s:\\n            hashmap[ch] += 1\\n        \\n        odd_character_count = 0\\n        for key in hashmap:\\n            odd_character_count += 1 if hashmap[key] % 2 == 1 else 0\\n            \\n        if odd_character_count > k:\\n            return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        \"\"\"\\n        For string to be pallindrome, it can either have 0 or 1 number of odd count characters.\\n        For string to have k pallindomes, it can have 0 - k number of odd count characters. \\n        \"\"\"\\n        if k > len(s):\\n            return False\\n        \\n        hashmap = collections.defaultdict(int)\\n        \\n        for ch in s:\\n            hashmap[ch] += 1\\n        \\n        odd_character_count = 0\\n        for key in hashmap:\\n            odd_character_count += 1 if hashmap[key] % 2 == 1 else 0\\n            \\n        if odd_character_count > k:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723185,
                "title": "c-solution",
                "content": "```\\n    public bool CanConstruct(string s, int k) {\\n        if(s.Length<2)\\n            return k>0;\\n        int[] map=new int[26];\\n        foreach(var ch in s)\\n            map[ch-\\'a\\']++;\\n        int odd=0;\\n        foreach(var ch in map)\\n        {\\n            if(ch!=0&&ch%2!=0)\\n                odd++;\\n        }\\n        return odd<=k&&k<=s.Length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public bool CanConstruct(string s, int k) {\\n        if(s.Length<2)\\n            return k>0;\\n        int[] map=new int[26];\\n        foreach(var ch in s)\\n            map[ch-\\'a\\']++;\\n        int odd=0;\\n        foreach(var ch in map)\\n        {\\n            if(ch!=0&&ch%2!=0)\\n                odd++;\\n        }\\n        return odd<=k&&k<=s.Length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 653134,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k)\\n            return false;\\n        \\n        vector<int> freq(256,0);\\n        \\n        for(auto ele : s)\\n            freq[ele]++;\\n        \\n        for(auto ele : freq){\\n            if(ele&1)\\n                k--;\\n            if(k < 0)\\n                return false;\\n        }        \\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k)\\n            return false;\\n        \\n        vector<int> freq(256,0);\\n        \\n        for(auto ele : s)\\n            freq[ele]++;\\n        \\n        for(auto ele : freq){\\n            if(ele&1)\\n                k--;\\n            if(k < 0)\\n                return false;\\n        }        \\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629545,
                "title": "java-faster-than-99-01-and-less-than-100-00-using-bucket-sort",
                "content": "```\\npublic class Solution {\\n    public boolean canConstruct(String s, int k) {\\n     \\n    \\tif (k > s.length()) {\\n    \\t\\treturn false;\\n    \\t}\\n    \\tint[] count = new int[26];\\n    \\tfor (char c : s.toCharArray()) {\\n    \\t\\tcount[c - \\'a\\']++;\\n    \\t}\\n    \\t\\n    \\tint ones = 0;\\n    \\tfor (int i : count) {\\n    \\t\\tif ((i & 1) == 1) {\\n    \\t\\t\\tones++;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\treturn ones <= k;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bucket Sort"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean canConstruct(String s, int k) {\\n     \\n    \\tif (k > s.length()) {\\n    \\t\\treturn false;\\n    \\t}\\n    \\tint[] count = new int[26];\\n    \\tfor (char c : s.toCharArray()) {\\n    \\t\\tcount[c - \\'a\\']++;\\n    \\t}\\n    \\t\\n    \\tint ones = 0;\\n    \\tfor (int i : count) {\\n    \\t\\tif ((i & 1) == 1) {\\n    \\t\\t\\tones++;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\treturn ones <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597239,
                "title": "javascript-bitwise-beats-100-100-w-comments",
                "content": "```\\nfunction canConstruct(s, k) {\\n    // base case (s is less than k in length)\\n    if (s.length < k)\\n        return false;\\n\\t\\t\\n    // our 26 bit number to representing all 26 lowercase characters (each bit)\\n    let x = 0;\\n\\t\\n    // iterate thru string\\n    for (let i = 0; i < s.length; i++) {\\n        // flip bit corresponding to this lowercase char\\n        x ^= 1 << (s.charCodeAt(i) - 97);\\n    }\\n\\t\\n    // count set bits\\n    let c = 0;\\n    while (x > 0) {\\n        // inc c if rightmost bit is 1\\n        c += x & 1;\\n        // right shift\\n        x >>= 1;\\n    }\\n\\t\\n    // check if number of odds is less or equal to k\\n    return c <= k;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction canConstruct(s, k) {\\n    // base case (s is less than k in length)\\n    if (s.length < k)\\n        return false;\\n\\t\\t\\n    // our 26 bit number to representing all 26 lowercase characters (each bit)\\n    let x = 0;\\n\\t\\n    // iterate thru string\\n    for (let i = 0; i < s.length; i++) {\\n        // flip bit corresponding to this lowercase char\\n        x ^= 1 << (s.charCodeAt(i) - 97);\\n    }\\n\\t\\n    // count set bits\\n    let c = 0;\\n    while (x > 0) {\\n        // inc c if rightmost bit is 1\\n        c += x & 1;\\n        // right shift\\n        x >>= 1;\\n    }\\n\\t\\n    // check if number of odds is less or equal to k\\n    return c <= k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 575664,
                "title": "best-and-efficient-solution-with-explanation-c",
                "content": "Explanation: If you think about the pallindrome, you\\'ll eventually come at the conclusion that a pallindrome can hold atmost single, odd-occurrence alphabet. So, k pallindrome can hold at most k odd-occurrence alphabet and if the count of odd-occurrence alphabet will be more than k then it\\'s impossible to create k pallindrome.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        // corner case\\n        if (s.length() < k)\\n            return false;\\n        // to keep the occurrence of alphabets.\\n        int _hash = 0;\\n        \\n        // flip bit at position c - \\'a\\' \\n        for (char c : s)\\n            _hash ^= 1 << (c - \\'a\\');\\n        \\n        // count the number of set bit\\n        while(_hash != 0)\\n        {\\n            k--;\\n            _hash &= _hash - 1;\\n        }\\n        \\n        if (k < 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        // corner case\\n        if (s.length() < k)\\n            return false;\\n        // to keep the occurrence of alphabets.\\n        int _hash = 0;\\n        \\n        // flip bit at position c - \\'a\\' \\n        for (char c : s)\\n            _hash ^= 1 << (c - \\'a\\');\\n        \\n        // count the number of set bit\\n        while(_hash != 0)\\n        {\\n            k--;\\n            _hash &= _hash - 1;\\n        }\\n        \\n        if (k < 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 571843,
                "title": "java-68-using-frequency-count",
                "content": "```\\n  public boolean canConstruct(String s, int k) {\\n     if(s.length()<k) return false;\\n     int count[]=new int[26];int totalOddCount=0; \\n     for(int i=0;i<s.length();i++) count[s.charAt(i)-\\'a\\']++;   \\n     for(int i=0;i<count.length;i++)\\n         if(count[i]%2!=0)\\n             totalOddCount++;\\n        \\n     return totalOddCount<=k;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public boolean canConstruct(String s, int k) {\\n     if(s.length()<k) return false;\\n     int count[]=new int[26];int totalOddCount=0; \\n     for(int i=0;i<s.length();i++) count[s.charAt(i)-\\'a\\']++;   \\n     for(int i=0;i<count.length;i++)\\n         if(count[i]%2!=0)\\n             totalOddCount++;\\n        \\n     return totalOddCount<=k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 568881,
                "title": "most-detailed-java-explanation-for-beginners",
                "content": "```\\n public boolean canConstruct(String s, int k) {\\n        int n= s.length();\\n        \\n        //K has to be less than N becase\\n        //At max, we can make N palindromes from a String of length N\\n        //e.g. If all characters represent one palindrome, then we would have N palindromes\\n        //since in all others scenarios, atleast one of the palindromes can have more than 1 character\\n        //Hence maximum limit to number of palindromes generated in this case is N\\n        if(k>n){\\n            return false;\\n        }\\n        \\n        //We need to count odd numbered characters. Why?\\n        //Since any palindrome can contain at max 1 odd numbered character, that too in the center\\n        //If there are more odd nunmbered characters(O=K+C) then the number of palindromes \\n        //the given string can be broken into(K)\\n        //Then those extra odd numbered characters cannot be accomdated into those K palindroms\\n        //Hence we will not be able to makebreak the given String into K palindromes \\n\\t\\t//in case O=K+C; C>=1\\n        \\n        int oddNumberedCharacters=0;\\n        int[] count = new int[26];\\n        \\n        for(int i=0;i<s.length();i++){\\n           count[(s.charAt(i)-\\'a\\']++;    \\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            oddNumberedCharacters+=count[i]%2;\\n        }\\n        \\n        return  oddNumberedCharacters<=k;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n public boolean canConstruct(String s, int k) {\\n        int n= s.length();\\n        \\n        //K has to be less than N becase\\n        //At max, we can make N palindromes from a String of length N\\n        //e.g. If all characters represent one palindrome, then we would have N palindromes\\n        //since in all others scenarios, atleast one of the palindromes can have more than 1 character\\n        //Hence maximum limit to number of palindromes generated in this case is N\\n        if(k>n){\\n            return false;\\n        }\\n        \\n        //We need to count odd numbered characters. Why?\\n        //Since any palindrome can contain at max 1 odd numbered character, that too in the center\\n        //If there are more odd nunmbered characters(O=K+C) then the number of palindromes \\n        //the given string can be broken into(K)\\n        //Then those extra odd numbered characters cannot be accomdated into those K palindroms\\n        //Hence we will not be able to makebreak the given String into K palindromes \\n\\t\\t//in case O=K+C; C>=1\\n        \\n        int oddNumberedCharacters=0;\\n        int[] count = new int[26];\\n        \\n        for(int i=0;i<s.length();i++){\\n           count[(s.charAt(i)-\\'a\\']++;    \\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            oddNumberedCharacters+=count[i]%2;\\n        }\\n        \\n        return  oddNumberedCharacters<=k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 565472,
                "title": "c-3-lines-using-128-bits-register",
                "content": "```\\nclass Solution {\\npublic:    \\n    bool canConstruct(string s, int k) {\\n         __int128 ret = 0;\\n        for (char c : s) ret ^= ( __int128)1 << c;\\n        \\n        return __builtin_popcount(ret >> 96) <= k && (s.size() >= k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n    bool canConstruct(string s, int k) {\\n         __int128 ret = 0;\\n        for (char c : s) ret ^= ( __int128)1 << c;\\n        \\n        return __builtin_popcount(ret >> 96) <= k && (s.size() >= k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564240,
                "title": "c-100-100-one-pass-hashset",
                "content": "Explanation\\n-\\nIf we\\'ve seen a letter an even number of times, we can put it anywhere. We only care about the odd leftovers. Each one needs to be the middle letter of a palindrome. If we have more odds than ```k```, we can\\'t do it. We also need to check if there are actually enough letters in the string.\\n\\nAlgorithm\\n-\\n```\\npublic bool CanConstruct(string s, int k) {\\n\\tif (s.Length < k) return false;\\n\\tvar unpaired = new HashSet<char>();\\n\\tforeach (var letter in s)\\n\\t\\tif (unpaired.Contains(letter))\\n\\t\\t\\tunpaired.Remove(letter);\\n\\t\\telse\\n\\t\\t\\tunpaired.Add(letter);\\n\\treturn unpaired.Count <= k;\\n}\\n```\\n\\nProof\\n-\\n![image](https://assets.leetcode.com/users/laprade/image_1586058531.png)\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```k```\n```\\npublic bool CanConstruct(string s, int k) {\\n\\tif (s.Length < k) return false;\\n\\tvar unpaired = new HashSet<char>();\\n\\tforeach (var letter in s)\\n\\t\\tif (unpaired.Contains(letter))\\n\\t\\t\\tunpaired.Remove(letter);\\n\\t\\telse\\n\\t\\t\\tunpaired.Add(letter);\\n\\treturn unpaired.Count <= k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564194,
                "title": "with-explanation",
                "content": "Firstly if size < k then we must obviously return false.\\nIf size >= k and singles = 0. This means all are pairs. In this case:\\n\\t1: k == size, then we can create k palindrome, each palindrome will have single letter. e.g.: k = 4, s = \\'aabb\\' we can create 4 palindromes as: a, a, b, b.\\n\\t2: k > size: Since all characters are in pair (or even count) we can distribute first k characters as shown above and then remaining are all pairs, which can also be distributed. e.g.: k = 4, s= \\'aaaaaabb\\', palindromes can be constructed in steps as follows:  a, a, a, a => aaabb, a, a, a.\\n\\nIf size >= k and singles > 0. (note, when I say singles I mean number of odd chars, for example if s = \\'aaa\\', single = 1  == last \\'a\\' in \\'aa**a**\\'). Here there can be 2 cases:\\n\\t1: singles < k. In this case we can distribute singles among our palindromes. \\n\\te.g: k = 3, singles = 1 = \\'a\\' =>   --a, --, --. \\n\\tor   k=3, singles = 2 = \\'ab\\' => --a, --b, --.   \\n\\tOr k= 3, singles = 3 = \\'abd\\' => --a, --b, --d.\\n\\t2: singles > k. Continuing from above example, it is easy to see that after adding k singles into k palindromes, we have no place to put the k+1th single, so we must return false. \\n\\nThe c++ code for this is given below:\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if((int)s.size() < k )\\n            return 0;\\n        vector<int> cnt(26);\\n        for(char c: s)\\n            cnt[c-\\'a\\']++;\\n\\n        int singles = 0;\\n        for(int e: cnt)\\n           if(e %2 != 0)\\n               singles++;\\n\\n        return singles <= k;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if((int)s.size() < k )\\n            return 0;\\n        vector<int> cnt(26);\\n        for(char c: s)\\n            cnt[c-\\'a\\']++;\\n\\n        int singles = 0;\\n        for(int e: cnt)\\n           if(e %2 != 0)\\n               singles++;\\n\\n        return singles <= k;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563752,
                "title": "python",
                "content": "If you have X characters with odd counts, then you need at least X palindromes to accomodate them; so, other than making sure that s isn\\'t shorter than k, we only need to check that X <= K\\n\\n```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        if len(s) < k:\\n            return False\\n        \\n        char_counts = dict()\\n        \\n        for char in s:\\n            if char in char_counts:\\n                char_counts[char] += 1\\n            else:\\n                char_counts[char] = 1\\n        \\n        odd_counts = 0\\n        \\n        for char in char_counts:\\n            if char_counts[char] % 2 == 1:\\n                odd_counts += 1\\n        \\n        return odd_counts <= k",
                "solutionTags": [],
                "code": "If you have X characters with odd counts, then you need at least X palindromes to accomodate them; so, other than making sure that s isn\\'t shorter than k, we only need to check that X <= K\\n\\n```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        if len(s) < k:\\n            return False\\n        \\n        char_counts = dict()\\n        \\n        for char in s:\\n            if char in char_counts:\\n                char_counts[char] += 1\\n            else:\\n                char_counts[char] = 1\\n        \\n        odd_counts = 0\\n        \\n        for char in char_counts:\\n            if char_counts[char] % 2 == 1:\\n                odd_counts += 1\\n        \\n        return odd_counts <= k",
                "codeTag": "Java"
            },
            {
                "id": 563615,
                "title": "count-odd-numbers-javascript-solution-68-ms",
                "content": "```\\nvar canConstruct = function(s, k) {\\n    if (s.length / k < 1) {\\n        return false;\\n    }\\n    \\n    let counts = new Array(26).fill(0);\\n    const aCode = \"a\".charCodeAt();\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        counts[s.charCodeAt(i) - aCode]++;\\n    }\\n    \\n    let oddCount = 0;\\n    for (let i = 0; i < 26; ++i) {\\n        if (counts[i] % 2 === 1) {\\n            oddCount++;\\n        }\\n    }\\n    \\n    return oddCount <= k;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canConstruct = function(s, k) {\\n    if (s.length / k < 1) {\\n        return false;\\n    }\\n    \\n    let counts = new Array(26).fill(0);\\n    const aCode = \"a\".charCodeAt();\\n    \\n    for (let i = 0; i < s.length; ++i) {\\n        counts[s.charCodeAt(i) - aCode]++;\\n    }\\n    \\n    let oddCount = 0;\\n    for (let i = 0; i < 26; ++i) {\\n        if (counts[i] % 2 === 1) {\\n            oddCount++;\\n        }\\n    }\\n    \\n    return oddCount <= k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563474,
                "title": "cpp-fastest-easiest",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k){\\n            return true;\\n        }\\n        if(s.size()<k)return false;\\n        int arr[26]={0};\\n        for(int i=0;i<s.size();i++){\\n            arr[s[i]-\\'a\\']++;\\n        }\\n        int no=0,ne=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(arr[i]%2==0)ne++;\\n            else no++;\\n        }\\n        \\n        if(k<no){\\n            return false;\\n        }\\n        else return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k){\\n            return true;\\n        }\\n        if(s.size()<k)return false;\\n        int arr[26]={0};\\n        for(int i=0;i<s.size();i++){\\n            arr[s[i]-\\'a\\']++;\\n        }\\n        int no=0,ne=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(arr[i]%2==0)ne++;\\n            else no++;\\n        }\\n        \\n        if(k<no){\\n            return false;\\n        }\\n        else return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563440,
                "title": "python-one-liner",
                "content": "The first condition is easy: The input string needs to be least k characters long to form k palindromes.\\nThen we need to count the occurences of each character: If a character is included an even number of times we can create a new palindrome with it or use a pair of it as padding on an existing palindrome without increasing the total palindrome count (XXX -> aXXXa). We only need to watch out for odd character counts as each of those will create a new center. If there are more than k centers we can\\'t construct k palindromes.\\n\\nTime and space complexity: ```O(n)```\\n```python\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return len(s) >= k and sum(count % 2 for count in collections.Counter(s).values()) <= k\\n```",
                "solutionTags": [],
                "code": "```O(n)```\n```python\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        return len(s) >= k and sum(count % 2 for count in collections.Counter(s).values()) <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090307,
                "title": "python3-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, x: int) -> bool:\\n        \\n        \\n        freq=Counter(s)\\n        odd=0\\n        \\n        for k,v in freq.items():\\n            if v%2:\\n                odd+=1\\n                \\n        if odd>x:\\n            return False\\n        \\n        return len(s)>=x\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, x: int) -> bool:\\n        \\n        \\n        freq=Counter(s)\\n        odd=0\\n        \\n        for k,v in freq.items():\\n            if v%2:\\n                odd+=1\\n                \\n        if odd>x:\\n            return False\\n        \\n        return len(s)>=x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069749,
                "title": "c-solution-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char, int> mp;\\n        if(k==s.length()){\\n            return true;\\n        }\\n        else if(k>s.length()) return false;\\n\\n        else{\\n            int odd=0;\\n\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        for(auto i:mp){\\n            if(i.second%2 != 0) odd++;\\n        }\\n\\n        if(odd<=k){\\n            return true;\\n        }\\n        else return false;\\n\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char, int> mp;\\n        if(k==s.length()){\\n            return true;\\n        }\\n        else if(k>s.length()) return false;\\n\\n        else{\\n            int odd=0;\\n\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        for(auto i:mp){\\n            if(i.second%2 != 0) odd++;\\n        }\\n\\n        if(odd<=k){\\n            return true;\\n        }\\n        else return false;\\n\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022713,
                "title": "unordered-map-easy-solution-self-explanatory",
                "content": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        //leetcode - here how can we split leetcode into 3 palindromic strings\\n        //odd freq char we have  l,t,c,o,d\\n        //ete eoe so odd freq is more than the k we cannot construct k palindromic strings from this\\n        //true          here all 4 having odd frequency\\n        //we can successfully divide into 4 single palindromic strings\\n        int n=s.size();\\n        if(n<k) return false;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<s.size();i++) \\n            mp[s[i]]++;\\n          int t=0;\\n        for(auto x: mp) {\\n            if(x.second&1) {\\n                t++;\\n            }\\n        }\\n        return t<=k;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        //leetcode - here how can we split leetcode into 3 palindromic strings\\n        //odd freq char we have  l,t,c,o,d\\n        //ete eoe so odd freq is more than the k we cannot construct k palindromic strings from this\\n        //true          here all 4 having odd frequency\\n        //we can successfully divide into 4 single palindromic strings\\n        int n=s.size();\\n        if(n<k) return false;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<s.size();i++) \\n            mp[s[i]]++;\\n          int t=0;\\n        for(auto x: mp) {\\n            if(x.second&1) {\\n                t++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4003095,
                "title": "using-hashmap-o-n",
                "content": "# Approach\\nThe basic idea is to use a frequency map and counting\\nWe have to form \"k\" palindromes of ANY size\\nThat said \\n - each palindrome must have an EVEN number of letters\\n   example: aaaa, abaaba\\n - each palindrome can have an extra 1 letter\\n   example: aaBaa, abaEaba \\n\\nIt means we can for palindromes IF extra letters do not exceed \"k\"\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar canConstruct = function(s, k) {\\n    const fmap=new Map();\\n    if(s.length===k) return true;\\n    if(k>s.length) return false;\\n\\n    // build a map  \\n    for(let c of s) fmap.set(c,fmap.has(c)?fmap.get(c)+1:1);\\n    \\n    let lettersLeft=false;\\n    for(let [c,count] of fmap.entries()){\\n        if(count>1)\\n            // count extra letters, e.g aaaa=0,aa=0,aa=0 nothing left we can use all a\\'s\\n            // But yzyzy=1, we have extra \\'y\\' we can should use in this or other polindrome\\n            lettersLeft+=count%2; \\n        else\\n            lettersLeft+=count; // if we got here we have some extra letters we need to spread across all palindromes, rememner each palindrome can take only 1 extra letter  \\n        if(lettersLeft>k) // if there are too much extras we return false\\n            return false;\\n    }  \\n    return true;\\n  };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConstruct = function(s, k) {\\n    const fmap=new Map();\\n    if(s.length===k) return true;\\n    if(k>s.length) return false;\\n\\n    // build a map  \\n    for(let c of s) fmap.set(c,fmap.has(c)?fmap.get(c)+1:1);\\n    \\n    let lettersLeft=false;\\n    for(let [c,count] of fmap.entries()){\\n        if(count>1)\\n            // count extra letters, e.g aaaa=0,aa=0,aa=0 nothing left we can use all a\\'s\\n            // But yzyzy=1, we have extra \\'y\\' we can should use in this or other polindrome\\n            lettersLeft+=count%2; \\n        else\\n            lettersLeft+=count; // if we got here we have some extra letters we need to spread across all palindromes, rememner each palindrome can take only 1 extra letter  \\n        if(lettersLeft>k) // if there are too much extras we return false\\n            return false;\\n    }  \\n    return true;\\n  };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949898,
                "title": "c-explained-easy-clean-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        unordered_map<char,int>map;\\n        for(int i=0;i<s.size();i++){\\n            map[s[i]]++;\\n        }\\n        int odd =0;\\n        for(auto x:map){\\n            if(x.second % 2 != 0) odd++;\\n        }\\n        //means remember 1--> one odd could be only used in one string\\n        // 2--> That implies that if we have more odds and less string some odd will not be used\\n        if(odd > k) return false;\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        unordered_map<char,int>map;\\n        for(int i=0;i<s.size();i++){\\n            map[s[i]]++;\\n        }\\n        int odd =0;\\n        for(auto x:map){\\n            if(x.second % 2 != 0) odd++;\\n        }\\n        //means remember 1--> one odd could be only used in one string\\n        // 2--> That implies that if we have more odds and less string some odd will not be used\\n        if(odd > k) return false;\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947438,
                "title": "c-counting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        int freq[26] = {0};\\n        int odd = 0;\\n        for(char ch: s) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++) odd += freq[i] % 2;\\n        return odd <= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        int freq[26] = {0};\\n        int odd = 0;\\n        for(char ch: s) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++) odd += freq[i] % 2;\\n        return odd <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928949,
                "title": "counting-sort-beats-100",
                "content": "# Complexity\\n- Time complexity:\\nO(s.count)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    private static let aAscii = Character(\"a\").asciiValue!\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        let count = s.count\\n        if count < k { return false }\\n        var occurencies = Array(repeating: 0, count: 26)\\n        \\n        for char in s {\\n            occurencies[Int(char.asciiValue! - Self.aAscii)] += 1\\n        }\\n\\n        let numberOfOdds = occurencies.filter { $0 % 2 == 1 }.count\\n\\n        return numberOfOdds <= k\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    private static let aAscii = Character(\"a\").asciiValue!\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        let count = s.count\\n        if count < k { return false }\\n        var occurencies = Array(repeating: 0, count: 26)\\n        \\n        for char in s {\\n            occurencies[Int(char.asciiValue! - Self.aAscii)] += 1\\n        }\\n\\n        let numberOfOdds = occurencies.filter { $0 % 2 == 1 }.count\\n\\n        return numberOfOdds <= k\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928017,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nif a string has more than one letter whose frequency is odd then that string cannot form palindrome, hence keeping this in mind, we keep track of each letters frequency, if it is odd we increment num by 1 for every odd frequency. If num is Less than k value then we return true.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k >len(s):\\n            return False\\n        num = 0\\n        p = Counter(s).values()\\n        for i in p:\\n            if i % 2 == 1:\\n                num = num+1\\n        if num <= k:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if k >len(s):\\n            return False\\n        num = 0\\n        p = Counter(s).values()\\n        for i in p:\\n            if i % 2 == 1:\\n                num = num+1\\n        if num <= k:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897365,
                "title": "greedy-solution-odd-frequency-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(k > n) return 0;\\n        int cnt[26] = {};\\n        for(int i=0;i<n;i++){\\n            cnt[s[i]-\\'a\\']++;\\n        }\\n        int odd_frequency = 0;\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]%2)odd_frequency++;\\n        }\\n        if(k < odd_frequency) return 0;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(k > n) return 0;\\n        int cnt[26] = {};\\n        for(int i=0;i<n;i++){\\n            cnt[s[i]-\\'a\\']++;\\n        }\\n        int odd_frequency = 0;\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]%2)odd_frequency++;\\n        }\\n        if(k < odd_frequency) return 0;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894914,
                "title": "optimized-approach-in-c-time-o-n-space-o-1",
                "content": "# Approach\\nUse hashing to count number of occcurences specifically to get odd occuring alphabets in string.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(26) ~ O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        bool ans;\\n        if(k==s.length()){\\n            ans=true;\\n        }\\n        else if(k>s.length()){\\n            ans=false;\\n        }\\n        else{\\n            vector<int> count(26,0);\\n            for(auto i:s){\\n                count[i-\\'a\\']++;\\n            }\\n            int odd_count=0;\\n            for(auto i:count){\\n                if(i%2!=0){\\n                    odd_count++;\\n                }\\n            }\\n            if(odd_count>k){\\n                ans=false;\\n            }\\n            else{\\n                ans=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        bool ans;\\n        if(k==s.length()){\\n            ans=true;\\n        }\\n        else if(k>s.length()){\\n            ans=false;\\n        }\\n        else{\\n            vector<int> count(26,0);\\n            for(auto i:s){\\n                count[i-\\'a\\']++;\\n            }\\n            int odd_count=0;\\n            for(auto i:count){\\n                if(i%2!=0){\\n                    odd_count++;\\n                }\\n            }\\n            if(odd_count>k){\\n                ans=false;\\n            }\\n            else{\\n                ans=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865494,
                "title": "easy-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        \\n        unordered_map<char,int> mp;\\n\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n\\n        int count=0;\\n        for(auto num:mp)\\n        {\\n            if(num.second%2==1)count++;\\n        }\\n\\n\\n        return count>k || s.size()<k?false:true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        \\n        unordered_map<char,int> mp;\\n\\n        for(int i=0;i<s.size();i++)\\n        mp[s[i]]++;\\n\\n        int count=0;\\n        for(auto num:mp)\\n        {\\n            if(num.second%2==1)count++;\\n        }\\n\\n\\n        return count>k || s.size()<k?false:true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847816,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int n = s.length();\\n        if(k>n) return false;\\n        if(k==n) return true;\\n\\n        HashMap<Character,Integer> hp = new HashMap<>();\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(hp.containsKey(ch)) hp.put(ch,hp.get(ch)+1);\\n            else hp.put(ch,1);\\n        }\\n\\n        int odd = 0;\\n\\n        for(var a : hp.values()){\\n            if(a%2!=0) odd ++;\\n        }\\n\\n        if(odd>k) return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int n = s.length();\\n        if(k>n) return false;\\n        if(k==n) return true;\\n\\n        HashMap<Character,Integer> hp = new HashMap<>();\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(hp.containsKey(ch)) hp.put(ch,hp.get(ch)+1);\\n            else hp.put(ch,1);\\n        }\\n\\n        int odd = 0;\\n\\n        for(var a : hp.values()){\\n            if(a%2!=0) odd ++;\\n        }\\n\\n        if(odd>k) return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837757,
                "title": "1400-construct-k-palindrome-strings-java",
                "content": "# Intuition\\nAs a palindrome string can be of even length and odd length.\\nNow for even length it won\\'t be a problem but for odd length we need to keep one chracter in middle of the string so all the character with odd occurences is what will make a diffrence.\\n\\n# Approach\\nCount all the occurnces of the chracters in string and then count no of chracters with odd occurences if the occurnce is gretaer than k then we can not opartition the string.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: constant\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int l = s.length();\\n        if(k>l)\\n        return false;\\n        int[] arr = new int[26];\\n//count all characters occurence\\n        for(int i=0; i<l; i++){\\n            char ch = s.charAt(i);\\n            arr[ch-\\'a\\']++;\\n        }\\n\\n        int nOdd = 0;\\n\\n// count all Odd occurences because odd occurences are all that will make difference \\n        for(int i=0; i<26; i++) { \\n            if(arr[i]%2!=0)\\n                  nOdd++;\\n        }\\n\\n        if(nOdd>k)\\n        return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        int l = s.length();\\n        if(k>l)\\n        return false;\\n        int[] arr = new int[26];\\n//count all characters occurence\\n        for(int i=0; i<l; i++){\\n            char ch = s.charAt(i);\\n            arr[ch-\\'a\\']++;\\n        }\\n\\n        int nOdd = 0;\\n\\n// count all Odd occurences because odd occurences are all that will make difference \\n        for(int i=0; i<26; i++) { \\n            if(arr[i]%2!=0)\\n                  nOdd++;\\n        }\\n\\n        if(nOdd>k)\\n        return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823470,
                "title": "java-easy-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThinking a bit we can see that a pair of odd letters suppose \"abc\" , in such a case there are 3 odd letters and if k=1 or k=2 output shall be **false** but if k=3 output will be **true**.\\nSo what we can observe is:\\nA pair of even letters \"aa\" can make either 1 or 2 palindrome but a pair of odd letters \"ab\" can only make 2, it cannot make 1.\\nSo we just tracked odd nos, **if TotalOddNos<=k then ans will be true** , but **if there are more odd than k then ans will be****false**.(Try to dry run as many testcases possible for better understanding).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing a set we can have count of freq of odd nos;\\nif set already contains an char remove the char and continue , cause this char is now even.\\nIn the end set.size() will be total odd chars.\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n) (in worst case it will have to store all chars , eg: \"abcde\")\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k)\\n        return false;\\n        if(s.length()==k) return true;\\n        HashSet<Character> set=new HashSet<>();\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(set.contains(s.charAt(i)))\\n            {\\n                set.remove(s.charAt(i));\\n               continue;\\n            }\\n            else\\n            set.add(s.charAt(i));\\n        }\\n        if(set.size()<=k)\\n        return true;\\n        else\\n        return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length()<k)\\n        return false;\\n        if(s.length()==k) return true;\\n        HashSet<Character> set=new HashSet<>();\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(set.contains(s.charAt(i)))\\n            {\\n                set.remove(s.charAt(i));\\n               continue;\\n            }\\n            else\\n            set.add(s.charAt(i));\\n        }\\n        if(set.size()<=k)\\n        return true;\\n        else\\n        return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821414,
                "title": "c-easy-to-understand-straightforward-approach",
                "content": "# Intuition\\nwe need to ensure that each palindrome can have at most one character with an odd frequency, as all other characters with odd frequencies can be paired up to form palindromes. If the number of characters with odd frequencies exceeds `k`, it will not be possible to construct `k` palindromes.\\n\\n# Approach\\n1. If the length of the string `s` is less than `k`, it is not possible to construct `k` palindromes using all characters. Return false in this case.\\n2. Create an unordered map `mp` to store the frequency of each character in the string `s`.\\n3. Count the number of characters with odd frequencies (i.e., frequency % 2 == 1) in the `mp` map and store it in the variable `oddcnt`.\\n4. If `oddcnt` is greater than `k`, it is not possible to construct `k` palindromes using all characters. Return false in this case.\\n5. Otherwise, it is possible to construct `k` palindromes. Return true.\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach is O(n), where n is the length of the string `s`, as we need to iterate through the string to count the character frequencies.\\n- Space complexity: The space complexity is O(n), where n is the length of the string `s`, due to the unordered map `mp` storing character frequencies.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        \\n        int oddcnt = 0;\\n        unordered_map<char,int> mp;\\n\\n        for(auto each: s)\\n            mp[each]++;\\n\\n        for(auto each: mp){\\n            if(each.second % 2)\\n                oddcnt++;\\n        }\\n\\n        if(oddcnt > k) \\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        \\n        int oddcnt = 0;\\n        unordered_map<char,int> mp;\\n\\n        for(auto each: s)\\n            mp[each]++;\\n\\n        for(auto each: mp){\\n            if(each.second % 2)\\n                oddcnt++;\\n        }\\n\\n        if(oddcnt > k) \\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805888,
                "title": "c-99-simple-logic",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        int odds = 0;\\n        vector<int> char_map(26, 0);\\n\\n        for(auto &c : s) \\n            char_map[c - \\'a\\']++;\\n\\n        for(auto &i : char_map)\\n            if(i % 2 != 0) \\n                odds++;\\n\\n        return odds <= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.length() < k) return false;\\n        int odds = 0;\\n        vector<int> char_map(26, 0);\\n\\n        for(auto &c : s) \\n            char_map[c - \\'a\\']++;\\n\\n        for(auto &i : char_map)\\n            if(i % 2 != 0) \\n                odds++;\\n\\n        return odds <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771005,
                "title": "3-lines-c",
                "content": "```\\nbool canConstruct(string s, int k) {\\n  int mask = 0;\\n  for(auto c: s) { mask ^= (1U << (c-\\'a\\')); }        \\n  return (s.size()>=k) && (__builtin_popcount(mask)<=k);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConstruct(string s, int k) {\\n  int mask = 0;\\n  for(auto c: s) { mask ^= (1U << (c-\\'a\\')); }        \\n  return (s.size()>=k) && (__builtin_popcount(mask)<=k);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3766097,
                "title": "simple-java-solution-o-n-tc-explained-intuition",
                "content": "# Intuition\\nHere we dont have to create pallindrome we just need to check if it is possible or not so i followed some simple rules.\\n1. if all the elements are distinct that means \\'a\\' \\'b\\' \\'c\\' are all pallindrome so we can return true.\\n2. if size of string is less that no of required pallindrome then its obviously not possible so false.\\n3. at max the odd appearing character can be equal to k, coz in a pallindrome a odd appearing number has to \\'appear\\' in the middle else it can be a pallindrome so i check for odd occurruing elements \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        HashMap<Character, Integer> count = new HashMap<>();\\n        for(char c : s.toCharArray()) {\\n            count.put(c, count.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        if(count.size() == k) return true;\\n        if(s.length() < k) return false;\\n        \\n        int j = 0;\\n        for(char c : count.keySet()) {\\n            if(count.get(c) % 2 != 0) j++;\\n        }\\n        \\n        return j <= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        HashMap<Character, Integer> count = new HashMap<>();\\n        for(char c : s.toCharArray()) {\\n            count.put(c, count.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        if(count.size() == k) return true;\\n        if(s.length() < k) return false;\\n        \\n        int j = 0;\\n        for(char c : count.keySet()) {\\n            if(count.get(c) % 2 != 0) j++;\\n        }\\n        \\n        return j <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764709,
                "title": "super-simple-just-count-odd-count-character-less-or-eq-to-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s)<k: return False\\n        o=0\\n        for i in Counter(s).values():\\n            if i%2: o+=1\\n         \\n        return o<=k  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        \\n        if len(s)<k: return False\\n        o=0\\n        for i in Counter(s).values():\\n            if i%2: o+=1\\n         \\n        return o<=k  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733181,
                "title": "easy-way-no",
                "content": "# Easy way (no)\\n![image.png](https://assets.leetcode.com/users/images/73e9e1d6-77d5-4d4d-8609-71c5f5bc3a06_1688749631.1845062.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 45\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 97\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        d = {}\\n        for i in s:\\n            d[i] = d.get(i, 0) + 1\\n        odd_count = sum((1 for i in d if d[i] % 2 == 1))\\n        return odd_count <= k\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n        d = {}\\n        for i in s:\\n            d[i] = d.get(i, 0) + 1\\n        odd_count = sum((1 for i in d if d[i] % 2 == 1))\\n        return odd_count <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713758,
                "title": "python3-9-lines-t-s-o-n-o-1-t-100",
                "content": "# Intuition\\n\\nWe can first take ALL pairs of the same letter, and these pairs can go into any palindrome.\\n\\nAfter which, we will be left with one of each letter with odd count in `s`. These letters cannot belong to the same palindrome (since each palindrome can only have at most one odd-numbered letter; its center).\\n\\nHence, if `k` is greater than or equal to the number of odd-numbered letters, return `True`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nwhere `n` is the length of `s`\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n# Time: O(n)\\n# Space: O(1)\\n\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n\\n        # if there aren\\'t enough letters to make k palindromes\\n        if k > len(s): return False\\n\\n        # pigeonhole principle, since there are at most 26 alphabets,\\n        # there can be at most 26 odd-numbered letters\\n        if k >= 26: return True\\n\\n        # initialise bit-shift for each letter\\n        letters = {}\\n        for i, c in enumerate(\\'aquickbrownfoxjumpsoverthelazydog\\'):\\n            letters[c] = i\\n\\n        # use bit-string to represent if letter count is even/odd\\n        bs = 0\\n        for c in s:\\n            bs ^= 1 << letters[c]\\n\\n        return bs.bit_count() <= k\\n\\n```\\n\\nhttps://leetcode.com/problems/construct-k-palindrome-strings/submissions/985452122/",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Bitmask"
                ],
                "code": "```\\n# Time: O(n)\\n# Space: O(1)\\n\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n\\n        # if there aren\\'t enough letters to make k palindromes\\n        if k > len(s): return False\\n\\n        # pigeonhole principle, since there are at most 26 alphabets,\\n        # there can be at most 26 odd-numbered letters\\n        if k >= 26: return True\\n\\n        # initialise bit-shift for each letter\\n        letters = {}\\n        for i, c in enumerate(\\'aquickbrownfoxjumpsoverthelazydog\\'):\\n            letters[c] = i\\n\\n        # use bit-string to represent if letter count is even/odd\\n        bs = 0\\n        for c in s:\\n            bs ^= 1 << letters[c]\\n\\n        return bs.bit_count() <= k\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704019,
                "title": "hashmap-easy-c-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLets store no of occurrences of each alphabet.\\n\\nObservation I :\\n\\nIf any alphabet has odd occurence one of its letter should be the middle character in one of the pallindromes.\\n\\nObservation II :\\nIf the number of remaining letters is greater than or equal to the remaining k value there is a possibility.\\nWe can choose to break up pairs or not greedily.\\n\\n# Complexity\\n- Time complexity:\\n$$ O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$ O(1) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> cnt(26,0);\\n        for(auto x : s){\\n            cnt[x-\\'a\\']++;\\n        }\\n        int summ=0;\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]%2==1){\\n                k--;\\n                cnt[i]--;\\n            }\\n            summ+=cnt[i];\\n        }\\n        return (summ>=k && k>=0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        vector<int> cnt(26,0);\\n        for(auto x : s){\\n            cnt[x-\\'a\\']++;\\n        }\\n        int summ=0;\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]%2==1){\\n                k--;\\n                cnt[i]--;\\n            }\\n            summ+=cnt[i];\\n        }\\n        return (summ>=k && k>=0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678667,
                "title": "c-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for(char c : s) {\\n            m[c]++;\\n        }\\n        int ones = 0;\\n        for(auto x : m) {\\n            if(x.second %2 ==1) {\\n                ones++;\\n            }\\n        }\\n        int n = s.size();\\n        return ones <= k && n>=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for(char c : s) {\\n            m[c]++;\\n        }\\n        int ones = 0;\\n        for(auto x : m) {\\n            if(x.second %2 ==1) {\\n                ones++;\\n            }\\n        }\\n        int n = s.size();\\n        return ones <= k && n>=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677544,
                "title": "python-solution-time-complexity-o-n",
                "content": "Here is my solution.\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        counts, minimum, maximum = {}, 0, 0\\n\\n        for char in s:\\n            if counts.get(char) is not None:\\n                counts[char] += 1\\n            else:\\n                counts[char] = 1\\n\\n        for char, count in counts.items():\\n            if count % 2 == 0:\\n                maximum += count\\n            elif count % 2 == 1:\\n                minimum += 1\\n                maximum += count\\n\\n        return max(1, minimum) <= k <= maximum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        counts, minimum, maximum = {}, 0, 0\\n\\n        for char in s:\\n            if counts.get(char) is not None:\\n                counts[char] += 1\\n            else:\\n                counts[char] = 1\\n\\n        for char, count in counts.items():\\n            if count % 2 == 0:\\n                maximum += count\\n            elif count % 2 == 1:\\n                minimum += 1\\n                maximum += count\\n\\n        return max(1, minimum) <= k <= maximum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667991,
                "title": "hashmap-beginner-friendly",
                "content": "# Intuition\\njust count odd freq element as we know that even freq elements can make palindrome easily so ignore even freq element. A palindrome can contain at most one odd freq element, so if odd freq characters are greater than k its clear that we cant divide all characters of the string to form k palondrome as we will be left with some odd freq elements.....\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        if(s.size() == k)\\n            return true;\\n\\n        if(s.size() < k)\\n            return false;\\n        \\n        map<char, int> m;\\n\\n        for(int i=0; i<s.size(); i++)\\n            m[s[i]]++;\\n\\n        int cnt=0;\\n\\n        for(auto it=m.begin(); it!=m.end(); it++)\\n        {\\n            if(it->second%2 != 0)\\n                cnt++;\\n        }\\n\\n        if(cnt > k)\\n        {\\n            return false;\\n        }\\n        return true; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n        if(s.size() == k)\\n            return true;\\n\\n        if(s.size() < k)\\n            return false;\\n        \\n        map<char, int> m;\\n\\n        for(int i=0; i<s.size(); i++)\\n            m[s[i]]++;\\n\\n        int cnt=0;\\n\\n        for(auto it=m.begin(); it!=m.end(); it++)\\n        {\\n            if(it->second%2 != 0)\\n                cnt++;\\n        }\\n\\n        if(cnt > k)\\n        {\\n            return false;\\n        }\\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630491,
                "title": "java-simple-using-alphabet-array",
                "content": "# Intuition\\nIf the number of odd frequencies is more than k, then return false.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (s.length() == k) return true;\\n        if (s.length() < k) return false;\\n        int alph[] = new int[26], countOdd = 0;\\n        for (int i = 0; i < s.length(); i++) alph[s.charAt(i) - \\'a\\']++;\\n        for (int i = 0; i < alph.length; i++) if (alph[i] % 2 == 1) countOdd++;\\n        return countOdd <= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (s.length() == k) return true;\\n        if (s.length() < k) return false;\\n        int alph[] = new int[26], countOdd = 0;\\n        for (int i = 0; i < s.length(); i++) alph[s.charAt(i) - \\'a\\']++;\\n        for (int i = 0; i < alph.length; i++) if (alph[i] % 2 == 1) countOdd++;\\n        return countOdd <= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600834,
                "title": "easy-to-understand-with-simple-approach",
                "content": "# Intuition\\nLook into characters with odd frequency\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach-\\n1)If the size of string is less than k,return false.\\n2)Store the frequency of each character in a map\\n3)Count the number of elements having odd frequencies.\\n4)If the count<= k return true else false\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        unordered_map<char,int> mp;\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int numOfodd=0;\\n        for(auto i:mp){\\n           if(i.second%2!=0)\\n              numOfodd++;\\n        }\\n        return (numOfodd<=k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        unordered_map<char,int> mp;\\n        for(auto i:s)\\n        {\\n            mp[i]++;\\n        }\\n        int numOfodd=0;\\n        for(auto i:mp){\\n           if(i.second%2!=0)\\n              numOfodd++;\\n        }\\n        return (numOfodd<=k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593302,
                "title": "easy-trick-with-code",
                "content": "\\n# Approach\\n Easy Trick:\\n Edge case: if( length of s<k) return false;\\n1. Count the frequency of every character.\\n2. Count the number of character whose frequency is odd.\\n3. If no. of odd frequency character > k return false, else return true;\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int n=s.length();\\n        if(n==k)return true;\\n        if(k>n)return false;\\n\\n        int[] arr=new int[26];\\n\\n        for(char c:s.toCharArray())arr[c-\\'a\\']++;\\n        \\n        int count=0;\\n        for(int i=0;i<26;i++){\\n            if(arr[i]%2!=0)count++;\\n        }\\n        if(count>k)return false;\\n        return true;\\n    }\\n}\\n```\\nPlease upvote if you understood the solution",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int n=s.length();\\n        if(n==k)return true;\\n        if(k>n)return false;\\n\\n        int[] arr=new int[26];\\n\\n        for(char c:s.toCharArray())arr[c-\\'a\\']++;\\n        \\n        int count=0;\\n        for(int i=0;i<26;i++){\\n            if(arr[i]%2!=0)count++;\\n        }\\n        if(count>k)return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516950,
                "title": "count-frequencies-java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k){\\n        \\n    if(s.length()<k)return false;\\n\\n    int[]freqarr=new int[26];\\n\\n    int even=0;\\n\\n    int odd=0;\\n\\n    for(int i=0;i<s.length();i++){\\n        freqarr[s.charAt(i)-\\'a\\']++;\\n    }\\n\\n    for(int i=0;i<26;i++){\\n        if(freqarr[i]%2==0){\\n            even++;\\n        }\\n        else{\\n            odd++;\\n        }\\n    }\\n\\n    if(odd>k)return false;\\n\\n    return true;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k){\\n        \\n    if(s.length()<k)return false;\\n\\n    int[]freqarr=new int[26];\\n\\n    int even=0;\\n\\n    int odd=0;\\n\\n    for(int i=0;i<s.length();i++){\\n        freqarr[s.charAt(i)-\\'a\\']++;\\n    }\\n\\n    for(int i=0;i<26;i++){\\n        if(freqarr[i]%2==0){\\n            even++;\\n        }\\n        else{\\n            odd++;\\n        }\\n    }\\n\\n    if(odd>k)return false;\\n\\n    return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508841,
                "title": "very-easy-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) \\n    {\\n        int count=0;\\n        if(k>s.length())return false;\\n    if(s.length()==k)return true;\\n    HashMap<Character,Integer> map=new HashMap<>();\\n    for(int i=0; i<s.length(); i++)\\n    {\\n        map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n    }\\n    for(Map.Entry<Character,Integer> entry:map.entrySet())\\n    {\\n        if(entry.getValue()%2!=0)\\n        {\\n         count++;\\n        }\\n    }\\n    if(count>k)return false;\\n\\n\\n    return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) \\n    {\\n        int count=0;\\n        if(k>s.length())return false;\\n    if(s.length()==k)return true;\\n    HashMap<Character,Integer> map=new HashMap<>();\\n    for(int i=0; i<s.length(); i++)\\n    {\\n        map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n    }\\n    for(Map.Entry<Character,Integer> entry:map.entrySet())\\n    {\\n        if(entry.getValue()%2!=0)\\n        {\\n         count++;\\n        }\\n    }\\n    if(count>k)return false;\\n\\n\\n    return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480371,
                "title": "python-greedy-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n\\n        hash = defaultdict(int)\\n\\n        for ch in s:\\n            hash[ch] += 1\\n                    \\n        count = 0\\n        \\n        for num in hash.values():\\n            if num % 2 != 0:\\n                count += 1\\n                \\n        return count <= k\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s) < k:\\n            return False\\n\\n        hash = defaultdict(int)\\n\\n        for ch in s:\\n            hash[ch] += 1\\n                    \\n        count = 0\\n        \\n        for num in hash.values():\\n            if num % 2 != 0:\\n                count += 1\\n                \\n        return count <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477466,
                "title": "construct-k-palindrome-strings",
                "content": "----------------- Easy C++ Solution -------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        if(s.size() == k) return true;\\n        vector<int> count(26);\\n        for(char c : s){\\n            count[c-\\'a\\']++;\\n        }\\n        int odd = 0;\\n        for(int i = 0; i < 26; i++){\\n            if(count[i] % 2 == 1){\\n                odd++;\\n            }\\n        }\\n        return odd <= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size() < k) return false;\\n        if(s.size() == k) return true;\\n        vector<int> count(26);\\n        for(char c : s){\\n            count[c-\\'a\\']++;\\n        }\\n        int odd = 0;\\n        for(int i = 0; i < 26; i++){\\n            if(count[i] % 2 == 1){\\n                odd++;\\n            }\\n        }\\n        return odd <= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444963,
                "title": "java-bitset-solution-with-detailed-comments",
                "content": "# Code\\n```\\n// Class definition for the solution\\nclass Solution {\\n    // Method to check if a given string \\'s\\' can be partitioned into \\'k\\' non-empty palindrome strings\\n    public boolean canConstruct(String s, int k) {\\n        // Create a BitSet of size 26 to represent each lowercase English letter\\n        BitSet chars = new BitSet(26);\\n\\n        // Iterate through the given string \\'s\\'\\n        for (int i = 0; i < s.length(); ++i) {\\n            // Toggle the bit at the index corresponding to the current character,\\n            // effectively counting the occurrences of each character with odd parity\\n            chars.flip(s.charAt(i) - \\'a\\');\\n        }\\n\\n        // If the number of characters with odd occurrences (cardinality of BitSet) is less than or equal to \\'k\\'\\n        // and \\'k\\' is less than or equal to the length of the string \\'s\\', return true\\n        // (meaning the string can be partitioned into \\'k\\' palindrome strings)\\n        return chars.cardinality() <= k && k <= s.length(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Class definition for the solution\\nclass Solution {\\n    // Method to check if a given string \\'s\\' can be partitioned into \\'k\\' non-empty palindrome strings\\n    public boolean canConstruct(String s, int k) {\\n        // Create a BitSet of size 26 to represent each lowercase English letter\\n        BitSet chars = new BitSet(26);\\n\\n        // Iterate through the given string \\'s\\'\\n        for (int i = 0; i < s.length(); ++i) {\\n            // Toggle the bit at the index corresponding to the current character,\\n            // effectively counting the occurrences of each character with odd parity\\n            chars.flip(s.charAt(i) - \\'a\\');\\n        }\\n\\n        // If the number of characters with odd occurrences (cardinality of BitSet) is less than or equal to \\'k\\'\\n        // and \\'k\\' is less than or equal to the length of the string \\'s\\', return true\\n        // (meaning the string can be partitioned into \\'k\\' palindrome strings)\\n        return chars.cardinality() <= k && k <= s.length(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430766,
                "title": "java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (k>s.length()) return false;\\n        boolean isOdd[] = new boolean[26];\\n        for (char c:s.toCharArray()) isOdd[c-\\'a\\']=!isOdd[c-\\'a\\'];\\n        for (boolean b:isOdd) if (b)k--;\\n        return (k>=0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if (k>s.length()) return false;\\n        boolean isOdd[] = new boolean[26];\\n        for (char c:s.toCharArray()) isOdd[c-\\'a\\']=!isOdd[c-\\'a\\'];\\n        for (boolean b:isOdd) if (b)k--;\\n        return (k>=0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425546,
                "title": "easy-c-solution-intuitive-using-hashmaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhave to check for the characters having odd frequency as they have to be present at different strings.\\nif no of characters having odd frequency is less than equal to k then we return true else false.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstoring frequency in unordered_map for each character\\ntraversing map to check for odd frequency character\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(s.length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(s.length)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for(auto x:s)\\n        {\\n            m[x]++;\\n        }\\n\\n        if(k>s.length())\\n        {\\n            return false;\\n        }\\n\\n        int no = 0;\\n        for(auto x:m)\\n        {\\n            if(x.second%2!=0)\\n            {\\n                no++;\\n            }\\n        }\\n\\n        if(no<=k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for(auto x:s)\\n        {\\n            m[x]++;\\n        }\\n\\n        if(k>s.length())\\n        {\\n            return false;\\n        }\\n\\n        int no = 0;\\n        for(auto x:m)\\n        {\\n            if(x.second%2!=0)\\n            {\\n                no++;\\n            }\\n        }\\n\\n        if(no<=k)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410448,
                "title": "c-short-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (k > s.size()) return false;\\n        int freq[26];\\n        memset(freq, 0, sizeof(freq));\\n        for (char c : s) ++ freq[c - \\'a\\'];\\n        for (int i = 0; i < 26; ++ i) {\\n            if (freq[i] & 1) {\\n                -- k;\\n                if (k < 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if (k > s.size()) return false;\\n        int freq[26];\\n        memset(freq, 0, sizeof(freq));\\n        for (char c : s) ++ freq[c - \\'a\\'];\\n        for (int i = 0; i < 26; ++ i) {\\n            if (freq[i] & 1) {\\n                -- k;\\n                if (k < 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398509,
                "title": "c-greedy-counting-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCounting & Greedy Combinatrics. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We will count the number of occurenece of each alphabet in the string and store in count vector.\\n2. Then, we will count the number of maximum total even pairs possible AND the left out odd values.\\n3. This is because we can merge 1 odd value to pair(s) of even value .\\n4. Then we will evaluate the minimum number of palindromic substrings that we will be able to make by the givven formula =>\\n`if(odds<=evens)  \\n  val += odds;`\\n`else \\n  val += evens + (odds - evens);`\\n5. If the val is <= k : true ELSE false\\n6. Taking care of base case :-\\n` if(n==k)    return true;`\\n`if(n<k)     return false;`\\n\\n![download (1).jfif](https://assets.leetcode.com/users/images/56c84a2f-1553-4523-bfd1-adee7f233903_1681070502.749976.jpeg)\\n\\n\\n# Complexity\\n- Time complexity : O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity  : O(26) ~= O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        //base cases\\n        int n = s.size();\\n        if(n==k)    return true;\\n        if(n<k)     return false;\\n\\n        //counting occurences\\n        vector<int> count (26,0);\\n        for(auto i : s) \\n            count[i-\\'a\\']++;\\n\\n        //counting possible_even_pairs AND left out Odds\\n        int odds = 0, evens = 0;\\n        for(auto i : count)     {        \\n            evens += i/2;\\n            odds += i%2;\\n        }\\n\\n        //evaluating val using above explained formula\\n        int val=0;\\n        if(odds<=evens)  \\n            val += odds;\\n        else \\n            val += evens + (odds - evens);\\n\\n        return val <= k ? 1 : 0;\\n    }\\n};\\n```\\n\\n![download (2).jfif](https://assets.leetcode.com/users/images/21ec2357-1a51-48c5-8aee-698351e9c16a_1681070518.8362906.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        //base cases\\n        int n = s.size();\\n        if(n==k)    return true;\\n        if(n<k)     return false;\\n\\n        //counting occurences\\n        vector<int> count (26,0);\\n        for(auto i : s) \\n            count[i-\\'a\\']++;\\n\\n        //counting possible_even_pairs AND left out Odds\\n        int odds = 0, evens = 0;\\n        for(auto i : count)     {        \\n            evens += i/2;\\n            odds += i%2;\\n        }\\n\\n        //evaluating val using above explained formula\\n        int val=0;\\n        if(odds<=evens)  \\n            val += odds;\\n        else \\n            val += evens + (odds - evens);\\n\\n        return val <= k ? 1 : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395252,
                "title": "return-true-for-k-26",
                "content": "# Intuition\\nIf both k and s.length() is greater or equal to 26, we can return solution as true because there can only be 26 bucket in worst case and you will always have enough characters available to expand k. \\n\\n# Complexity\\n- Time complexity:\\nO(1) when k>=26, O(n) otherwise.\\n\\n- Space complexity:\\nO(26)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(k>s.length()){\\n            return false;\\n        }else if(k==s.length()){\\n            return true;\\n        }else if(k>=26){\\n            return true;\\n        }\\n        int map[]=new int[26];\\n        for(int i=0;i<s.length();i++){\\n            map[s.charAt(i)-\\'a\\']++;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<26;i++){\\n            cnt+=map[i]%2;\\n        }\\n        return cnt<=k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(k>s.length()){\\n            return false;\\n        }else if(k==s.length()){\\n            return true;\\n        }else if(k>=26){\\n            return true;\\n        }\\n        int map[]=new int[26];\\n        for(int i=0;i<s.length();i++){\\n            map[s.charAt(i)-\\'a\\']++;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<26;i++){\\n            cnt+=map[i]%2;\\n        }\\n        return cnt<=k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386350,
                "title": "python-even-odd-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        dic = Counter(s)\\n        even, odd = 0,0\\n        for i in dic.keys():\\n            if dic[i]%2!=0:\\n                odd+=1\\n                dic[i]-=1\\n            even+=dic[i]\\n\\n        if odd > k or odd+even<k:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        dic = Counter(s)\\n        even, odd = 0,0\\n        for i in dic.keys():\\n            if dic[i]%2!=0:\\n                odd+=1\\n                dic[i]-=1\\n            even+=dic[i]\\n\\n        if odd > k or odd+even<k:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381403,
                "title": "construct-k-palindrome-strings",
                "content": "# Intuition\\nCondition 1. odd characters <= k\\nCount the occurrences of all characters.\\nIf one character has odd times occurrences,\\nthere must be at least one palindrome,\\nwith odd length and this character in the middle.\\nSo we count the characters that appear odd times,\\nthe number of odd character should not be bigger than k.\\n\\nCondition 2. k <= s.length()\\nAlso, if we have one character in each palindrome,\\nwe will have at most s.length() palindromes,\\nso we need k <= s.length().\\n\\nThe above two condition are necessary and sufficient conditions for this problem.\\nSo we return odd <= k <= n\\n\\n\\nConstruction\\n@spjparmar immediately got a question like why this works always for all strings.\\nHe gave the some following dry runs. :)\\nFor any string with 0 odd character count , we can form k no. of palindrome strings for sure with k<=n\\n(This is why k<=n)\\n\\neg\\naabb, k=1| abba\\naabb, k=2 | aa, bb\\naabb, k=3 | a, a, bb\\naabb, k=4 | a, a, b, b\\n\\nFor any string with odd character count <=k , we can always form k palindrome string for sure with k<=n\\neg2\\naabbc, k=1 | aacbb\\naabbc, k=2 | aca, bb\\naabbc, k=3 | a,a, bcb\\naabbc, k=4 | a, a, c ,bb\\naabbc, k=5 | a, a, c, b, b\\n\\neg3\\naabc, k=1 | N/A\\naabc, k=2 | aba, c\\naabc, k=3 | aa, b, c\\naabc, k=4 | a, a, b, c\\n\\nHope this helps somebody.\\n\\n\\n\\n# Complexity\\n- Time complexity: 0(n)\\n\\n\\n- Space complexity:0(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        bitset<26> odd;\\n        for (char& c : s)\\n            odd.flip(c - \\'a\\');\\n        return odd.count() <= k && k <= s.length();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        bitset<26> odd;\\n        for (char& c : s)\\n            odd.flip(c - \\'a\\');\\n        return odd.count() <= k && k <= s.length();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375694,
                "title": "easy-solution-cpp",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k > s.length()) return false;\\n        if(k == s.length()) return true;\\n        unordered_map<char,int> mp;\\n\\n        for(int i =0; i<s.length(); i++){\\n            mp[s[i]]++;\\n        }\\n        int cnt =0;\\n        for(auto it : mp){\\n            if(it.second % 2 !=0) {cnt++;}\\n        }\\n        if(cnt > k) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(k > s.length()) return false;\\n        if(k == s.length()) return true;\\n        unordered_map<char,int> mp;\\n\\n        for(int i =0; i<s.length(); i++){\\n            mp[s[i]]++;\\n        }\\n        int cnt =0;\\n        for(auto it : mp){\\n            if(it.second % 2 !=0) {cnt++;}\\n        }\\n        if(cnt > k) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347696,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nbool canConstruct(string s, int k) {\\n    int n = s.length();\\n    if (k>n)\\n        return false;\\n    int wasted = 0;\\n    vector<int> freq(26,0);\\n    for (int i{};i<n;i++)\\n        freq[s[i]-\\'a\\']++;\\n    for (int i{};i<26;i++){\\n        if (freq[i]%2!=0)\\n            wasted++;\\n    }\\n    return wasted<=k;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool canConstruct(string s, int k) {\\n    int n = s.length();\\n    if (k>n)\\n        return false;\\n    int wasted = 0;\\n    vector<int> freq(26,0);\\n    for (int i{};i<n;i++)\\n        freq[s[i]-\\'a\\']++;\\n    for (int i{};i<26;i++){\\n        if (freq[i]%2!=0)\\n            wasted++;\\n    }\\n    return wasted<=k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337670,
                "title": "100-python",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        if len(s) < k:\\n            return False\\n        freq = defaultdict(int)\\n        for i in s:\\n            freq[i] += 1\\n        for i in freq.values():\\n            if i % 2:\\n                k -= 1\\n                if k == -1:\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        if len(s) < k:\\n            return False\\n        freq = defaultdict(int)\\n        for i in s:\\n            freq[i] += 1\\n        for i in freq.values():\\n            if i % 2:\\n                k -= 1\\n                if k == -1:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337245,
                "title": "explaination-let-s-take-it-one-by-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIdea is to first try if the simple logic works. Let me put every thought pointwise.\\n\\n1. S will have some odd occurance as well as some even occurances of characters, sounds obivious?.\\n2. First of all, if odd occurances(Let\\'s call O) are more than K i.e O>K, then it\\'s not possible to build just k palindroms using O occurances.  why? Ok, have you seen a palindrom which contains 2 or more odd occurances? There can be atmost one odd occurance and that too in the center.\\n3. It\\'s easy till this point, Now let\\'s take just one character from all the Os and create first O palindroms. So we already have O palndroms out of the K palindroms that we wanted to create.\\n4. Now, we will have to create K-O palindromes out of S-O characters. Remember that all (S-O) remaing characters are even occurances. So another simple condition that comes to mind is (S-O)>=(K-O) or S>K.\\n5. But is it a sufficient condition? let\\'s think in this way. We will build palindromes incremently from 1 till S-O. After step 3 we have (S-O) chars left. Can we create just one palindrom using all the even occurances? Yes, simply put everything there.\\n6. Can we create 2 palindroms? Yes, just take out 1 pair from the first palindrom and split it into two character. Keep 1 charecter in the center of first one and put 1 character in the second palindrom. We have 2 palindroms.\\n7. Can we create 3? Yes, just take out the center one(which we just put)from first palindrom and put it on 3rd palindrom.\\n8. Can we create 4? Yes, just take another pair from the first palindrom. Keep one character at the center of first palindrom and put the remaining character on 4th palindrom. \\n\\nJust keep repeating and you can create all 1 to S-O palindroms. So be it any K<=S, the answer is true.\\n\\nPost it in the comments and we can discuss any point again if needed.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int []count = new int[26];\\n        Arrays.fill(count,0);\\n        for(int i=0; i<s.length();i++)\\n            count[s.charAt(i)-\\'a\\']++;\\n        int odd = 0;\\n        for(int i=0;i<26;i++){\\n            if(count[i]%2!=0){\\n                odd++;\\n            }\\n        }\\n        if(odd>k)\\n            return false;\\n        if(s.length()<k)\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n\\n        int []count = new int[26];\\n        Arrays.fill(count,0);\\n        for(int i=0; i<s.length();i++)\\n            count[s.charAt(i)-\\'a\\']++;\\n        int odd = 0;\\n        for(int i=0;i<26;i++){\\n            if(count[i]%2!=0){\\n                odd++;\\n            }\\n        }\\n        if(odd>k)\\n            return false;\\n        if(s.length()<k)\\n            return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275773,
                "title": "intuitive-and-beginner-o-n-solution-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k)return true;\\n        if(s.size()<k)return false;\\n        unordered_map<char,int> mp;\\n\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int count=0;\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                count++;\\n            }\\n        }\\n    return count<=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()==k)return true;\\n        if(s.size()<k)return false;\\n        unordered_map<char,int> mp;\\n\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        int count=0;\\n        for(auto it:mp){\\n            if(it.second%2!=0){\\n                count++;\\n            }\\n        }\\n    return count<=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274302,
                "title": "c-map-and-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for (auto& c : s) ++m[c];\\n        int oddCount = 0, evenSum = 0;\\n        for (auto& [f,s] : m){\\n            if (s % 2 == 1) ++oddCount;\\n            evenSum += s - (s % 2 == 1);\\n        }\\n        if (oddCount > k) return false;\\n        return (k -= evenSum + oddCount) <= 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        unordered_map<char,int> m;\\n        for (auto& c : s) ++m[c];\\n        int oddCount = 0, evenSum = 0;\\n        for (auto& [f,s] : m){\\n            if (s % 2 == 1) ++oddCount;\\n            evenSum += s - (s % 2 == 1);\\n        }\\n        if (oddCount > k) return false;\\n        return (k -= evenSum + oddCount) <= 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260751,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n\\n\\n- Space complexity: 0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(n<k) return false;\\n        unordered_map<char,int>m1;\\n        for(int i=0;i<n;i++){\\n            m1[s[i]]++;\\n        }\\n        int oddcount=0;\\n        for(auto x : m1){\\n            if(x.second%2!=0) oddcount++;\\n        }\\n\\n        if(oddcount>k) return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n = s.size();\\n        if(n<k) return false;\\n        unordered_map<char,int>m1;\\n        for(int i=0;i<n;i++){\\n            m1[s[i]]++;\\n        }\\n        int oddcount=0;\\n        for(auto x : m1){\\n            if(x.second%2!=0) oddcount++;\\n        }\\n\\n        if(oddcount>k) return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260420,
                "title": "easiest-way-to-construct-k-palindrome-strings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n if(s.length<k){\\n     return false\\n }  \\nlet freq={};\\n\\nfor(let i=0;i<s.length;i++){\\n    let curr=s[i];\\n    if(freq[curr]){\\n        freq[curr]++\\n    }else{\\n        freq[curr]=1\\n    }\\n}\\nlet count=0\\nlet x=Object.keys(freq);\\nfor(let i=0;i<x.length;i++){\\n    let curr=x[i]\\nif(freq[curr]%2!=0){\\n    count++\\n}\\n}\\nif(count>k){\\n    return false\\n}\\nreturn true\\n \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar canConstruct = function(s, k) {\\n if(s.length<k){\\n     return false\\n }  \\nlet freq={};\\n\\nfor(let i=0;i<s.length;i++){\\n    let curr=s[i];\\n    if(freq[curr]){\\n        freq[curr]++\\n    }else{\\n        freq[curr]=1\\n    }\\n}\\nlet count=0\\nlet x=Object.keys(freq);\\nfor(let i=0;i<x.length;i++){\\n    let curr=x[i]\\nif(freq[curr]%2!=0){\\n    count++\\n}\\n}\\nif(count>k){\\n    return false\\n}\\nreturn true\\n \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3251439,
                "title": "c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n=s.size(),arr[26];\\n        for(int i=0;i<26;i++)\\n        {\\n            arr[i]=0;\\n        }\\n        if(n<k)\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[s[i]-\\'a\\']++;\\n        }\\n        int count=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if((arr[i]&1)!=0)\\n            {\\n                count++;\\n            }\\n        }\\n        cout<<count<<\" \";\\n        if(k<count)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        int n=s.size(),arr[26];\\n        for(int i=0;i<26;i++)\\n        {\\n            arr[i]=0;\\n        }\\n        if(n<k)\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[s[i]-\\'a\\']++;\\n        }\\n        int count=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if((arr[i]&1)!=0)\\n            {\\n                count++;\\n            }\\n        }\\n        cout<<count<<\" \";\\n        if(k<count)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3242990,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        s.count >= k && s\\n            .reduce(into: [Character: Int]()) { $0[$1, default: 0] += 1 }\\n            .filter { $0.value % 2 == 1 }\\n            .count <= k\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func canConstruct(_ s: String, _ k: Int) -> Bool {\\n        s.count >= k && s\\n            .reduce(into: [Character: Int]()) { $0[$1, default: 0] += 1 }\\n            .filter { $0.value % 2 == 1 }\\n            .count <= k\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242367,
                "title": "69ms-python",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        if len(s) < k:\\n            return False\\n        freq = defaultdict(int)\\n        r = k\\n        for i in s: \\n            freq[i] += 1\\n        for i in freq.values():\\n            if i % 2:\\n                r -= 1\\n                if r == -1:\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def canConstruct(self, s, k):\\n        if len(s) < k:\\n            return False\\n        freq = defaultdict(int)\\n        r = k\\n        for i in s: \\n            freq[i] += 1\\n        for i in freq.values():\\n            if i % 2:\\n                r -= 1\\n                if r == -1:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240141,
                "title": "greedy-very-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n          if(k > s.length())\\n          return false;\\n          \\n          int evencount=0;\\n          int oddcount = 0;\\n          //we will take the mapping of all the character in the string\\n          unordered_map<char,int>mp;\\n          for(int i=0;i<s.length();i++)\\n          {\\n               mp[s[i]]++;\\n          }    \\n\\n          //counting the even frequncy and odd frequency\\n          for(auto it = mp.begin() ; it!=mp.end() ; it++)\\n          {\\n              if((it->second%2) == 0)\\n              evencount++;\\n              else\\n              oddcount++;\\n          }\\n\\n          if(oddcount > k) return false;\\n          return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) \\n    {\\n          if(k > s.length())\\n          return false;\\n          \\n          int evencount=0;\\n          int oddcount = 0;\\n          //we will take the mapping of all the character in the string\\n          unordered_map<char,int>mp;\\n          for(int i=0;i<s.length();i++)\\n          {\\n               mp[s[i]]++;\\n          }    \\n\\n          //counting the even frequncy and odd frequency\\n          for(auto it = mp.begin() ; it!=mp.end() ; it++)\\n          {\\n              if((it->second%2) == 0)\\n              evencount++;\\n              else\\n              oddcount++;\\n          }\\n\\n          if(oddcount > k) return false;\\n          return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229777,
                "title": "python-easy-solution-using-dict",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s)<k:\\n            return False\\n        \\n        dict=Counter(s)\\n        odd=0\\n        for v in dict:\\n            if dict[v]%2==1:\\n                odd+=1\\n        \\n        return odd<=k\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConstruct(self, s: str, k: int) -> bool:\\n        if len(s)<k:\\n            return False\\n        \\n        dict=Counter(s)\\n        odd=0\\n        for v in dict:\\n            if dict[v]%2==1:\\n                odd+=1\\n        \\n        return odd<=k\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228762,
                "title": "follow-this-one-simple-to-solve-intuition-explained",
                "content": "# Intuition\\n**You just need to keep one rule in mind:-**\\n*If the count of the odd frequencies in the string is greater than k, then it\\'s impossible to form k possible palindromes on that string.*\\n\\n# Approach\\nInsert every char inside hashmap. Now iterate again and count the no.of odd frequencies. Now follow the above rule. \\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        // Handling edge cases\\n        if(s.size()==k) return true;\\n        if(k > s.size()) return false;\\n        // Insert every char inside hashmap\\n        unordered_map<char,int> map;\\n        for(char c : s) map[c]++;\\n        // Now count the chars with odd frequency\\n        int freq=0;\\n        for(auto it : map){\\n            if(it.second%2 != 0) \\n                freq++;\\n        }\\n        // Apply the rule for k possible palindromes\\n        if(freq > k) return false;\\n        return true;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        // Handling edge cases\\n        if(s.size()==k) return true;\\n        if(k > s.size()) return false;\\n        // Insert every char inside hashmap\\n        unordered_map<char,int> map;\\n        for(char c : s) map[c]++;\\n        // Now count the chars with odd frequency\\n        int freq=0;\\n        for(auto it : map){\\n            if(it.second%2 != 0) \\n                freq++;\\n        }\\n        // Apply the rule for k possible palindromes\\n        if(freq > k) return false;\\n        return true;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219092,
                "title": "odd-palindrome-concept-o-n-character-freq-count",
                "content": "-> There is either an odd palindrome or an even palindrome\\n-> In an even palindrome there are no characters with count as odd\\n-> In an odd palindrome, there is only one character with count as odd\\n-> So, just calculate the count for each character in the substring and find the count of the number of odd-count characters \\n-> if the count of odd count characters is greater than the k then we cannot construct k palindromes from these characters\\n\\nT.C -> O(n + c )     S.C-> O(c),  where c is the number of characters and n is the length of the string\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length() < k) return false;\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i = 0;i < s.length();i++)\\n        {\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        int odd = 0;\\n        for(Character key: map.keySet())\\n        {\\n            if(map.get(key) % 2 == 1) odd++;\\n        }\\n        if(odd <= k) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConstruct(String s, int k) {\\n        if(s.length() < k) return false;\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i = 0;i < s.length();i++)\\n        {\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        int odd = 0;\\n        for(Character key: map.keySet())\\n        {\\n            if(map.get(key) % 2 == 1) odd++;\\n        }\\n        if(odd <= k) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213857,
                "title": "c-concise-hashmap-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k)return 0;\\n        if(s.size()==k)return 1;\\n        map<char, int> mp; \\n        for(char x: s)\\n        {\\n            mp[x]++;\\n        }\\n        for(auto &[x,y]: mp)\\n        {\\n            if(y&1) k--;\\n        }\\n        return k>=0?1:0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k)return 0;\\n        if(s.size()==k)return 1;\\n        map<char, int> mp; \\n        for(char x: s)\\n        {\\n            mp[x]++;\\n        }\\n        for(auto &[x,y]: mp)\\n        {\\n            if(y&1) k--;\\n        }\\n        return k>=0?1:0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189311,
                "title": "c-short-and-concise-solution-with-explanation-o-n-time-complexity",
                "content": "# Approach\\n1) If size of the s is less than k it obviously cant be divided into k non empty strings so we return false.\\n2) We then make a map of char,int mp.\\n3) We then count the frequencies of letters in the map\\n4) Now we make a integer variable count and initialize them to 0.\\n5) Now we make a for loop in map and for any alphabet if frequency is odd we add it to count\\n6) If the count is lesser than or equal to k we return true (as we can adjust one alphabet in middle of every palindromic subsets that we make)\\n7) Else we return false.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        map<char,int> mp;\\n        for(auto x: s){\\n            mp[x]++;\\n        }\\n        int count=0;\\n        for(auto x: mp){\\n            if(x.second%2) count+=1;\\n        }\\n        if(count<=k) return true;\\n        else return false;\\n    }\\n};\\n//   PLEASE UPVOTE IF THE ANSWER WAS HELPFUL...THANK YOU\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConstruct(string s, int k) {\\n        if(s.size()<k) return false;\\n        map<char,int> mp;\\n        for(auto x: s){\\n            mp[x]++;\\n        }\\n        int count=0;\\n        for(auto x: mp){\\n            if(x.second%2) count+=1;\\n        }\\n        if(count<=k) return true;\\n        else return false;\\n    }\\n};\\n//   PLEASE UPVOTE IF THE ANSWER WAS HELPFUL...THANK YOU\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188394,
                "title": "javascript-using-intuition-short",
                "content": "Base cases:\\n- If K > the length of the string, then we definitely can\\'t split it up into smaller pieces (\"ABC\" can\\'t be split into 4 palindromes)\\n- If K === the length of the string, then we can make each character its own palindrome\\n- We are restricted by the amount of odd numbered characters there are, if there are 3 Cs for example (\"AABBCCC\"), then we will either need to make \"C\" it\\'s own palindrome or something like \"ACA\", \"BCB\", \"CCC\".\\n- So first, we create a hashmap of all of the letters and their number of occurences. `AABBCCC` would come out to be `{ A: 2, B: 2, C: 3 }`\\n- Therefore, we can count of the number of odds occurrences there are, because we need at least 1 palindrome K for every odd occurence.\\n- In the above example, we have 1 odd number, so we can do K >= 1 (`ABCCCBA` as an example)\\n- In an example like this: `ABBCCC` we have two odd numbers (`A`, and `C`), therefore we need at least 2 palidromic sequences (`A` + `BCCCB` works. Or `BAB` + `C` + `CC` if K were 3)\\n\\nHope this helps.\\n\\n```\\nvar canConstruct = function(s, k) {\\n    if (k > s.length) return false\\n    if (k === s.length) return true\\n    const letterCount = s.split(\\'\\').reduce((acc,el) => {\\n        if (!acc[el]) acc[el] = 0\\n        acc[el] += 1\\n        return acc\\n    }, {})\\n    const numOdds = Object.values(letterCount).reduce((acc, el) => { if (el % 2 !== 0) return acc + 1; return acc}, 0)\\n    if (k < numOdds) return false\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConstruct = function(s, k) {\\n    if (k > s.length) return false\\n    if (k === s.length) return true\\n    const letterCount = s.split(\\'\\').reduce((acc,el) => {\\n        if (!acc[el]) acc[el] = 0\\n        acc[el] += 1\\n        return acc\\n    }, {})\\n    const numOdds = Object.values(letterCount).reduce((acc, el) => { if (el % 2 !== 0) return acc + 1; return acc}, 0)\\n    if (k < numOdds) return false\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1915408,
                "content": [
                    {
                        "username": "aftab0711",
                        "content": "Easy Trick:\\nEdge case: if( length of s<k) return false;\\n1. Count the frequency of every character.\\n2. Count the number of character whose frequency is odd.\\n3. If no. of odd frequency character > k return false, else return true;"
                    },
                    {
                        "username": "arheops",
                        "content": "Not true. Let say you have string AAAA and need make >4."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why the answer of \"leetcode\" if false why not true and the output could be \"l\"+ \"eee\" + \"t\" + \"c\" + \"o\" + \"d\"? the length of output clearly more than k=3 "
                    },
                    {
                        "username": "Lewis0511",
                        "content": "You need to make exactly k palindromes using all the characters. "
                    }
                ]
            },
            {
                "id": 1934761,
                "content": [
                    {
                        "username": "aftab0711",
                        "content": "Easy Trick:\\nEdge case: if( length of s<k) return false;\\n1. Count the frequency of every character.\\n2. Count the number of character whose frequency is odd.\\n3. If no. of odd frequency character > k return false, else return true;"
                    },
                    {
                        "username": "arheops",
                        "content": "Not true. Let say you have string AAAA and need make >4."
                    },
                    {
                        "username": "user5369RY",
                        "content": "why the answer of \"leetcode\" if false why not true and the output could be \"l\"+ \"eee\" + \"t\" + \"c\" + \"o\" + \"d\"? the length of output clearly more than k=3 "
                    },
                    {
                        "username": "Lewis0511",
                        "content": "You need to make exactly k palindromes using all the characters. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Circle and Rectangle Overlapping",
        "question_content": "<p>You are given a circle represented as <code>(radius, xCenter, yCenter)</code> and an axis-aligned rectangle represented as <code>(x1, y1, x2, y2)</code>, where <code>(x1, y1)</code> are the coordinates of the bottom-left corner, and <code>(x2, y2)</code> are the coordinates of the top-right corner of the rectangle.</p>\n\n<p>Return <code>true</code><em> if the circle and rectangle are overlapped otherwise return </em><code>false</code>. In other words, check if there is <strong>any</strong> point <code>(x<sub>i</sub>, y<sub>i</sub>)</code> that belongs to the circle and the rectangle at the same time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/20/sample_4_1728.png\" style=\"width: 258px; height: 167px;\" />\n<pre>\n<strong>Input:</strong> radius = 1, xCenter = 0, yCenter = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Circle and rectangle share the point (1,0).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> radius = 1, xCenter = 1, yCenter = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/20/sample_2_1728.png\" style=\"width: 150px; height: 135px;\" />\n<pre>\n<strong>Input:</strong> radius = 1, xCenter = 0, yCenter = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= radius &lt;= 2000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= xCenter, yCenter &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x1 &lt; x2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= y1 &lt; y2 &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 563463,
                "title": "c-with-simple-explanation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n---\\n\\nMove the center of the circle to the coordinate origin `(0, 0)`, then this problem becomes \"is there a point `(x, y)` (`x1 <= x <= x2`, `y1 <= y <= y2`) satisfying `x^2 + y^2 <= r^2`\".\\n\\nSo just compute minimum values of `x^2` and `y^2`, then compare the sum with `r^2`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/circle-and-rectangle-overlapping/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        x1 -= x_center; x2 -= x_center;\\n        y1 -= y_center; y2 -= y_center;\\n        int minX = x1 * x2 > 0 ? min(x1*x1, x2*x2) : 0, minY = y1 * y2 > 0 ? min(y1*y1, y2*y2) : 0;\\n        return minY + minX <= radius * radius;\\n    }\\n};\\n```\\n\\n---\\n\\nUpdate: 4/18/2020\\n\\n`minX` is the minimum value of `x^2` where `x1 <= x <= x2`.\\n\\nIf `x1` and `x2` have the same sign, `minX = min(x1*x1, x2*x2)`\\n\\nOtherwise, `minX = 0`.",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/circle-and-rectangle-overlapping/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        x1 -= x_center; x2 -= x_center;\\n        y1 -= y_center; y2 -= y_center;\\n        int minX = x1 * x2 > 0 ? min(x1*x1, x2*x2) : 0, minY = y1 * y2 > 0 ? min(y1*y1, y2*y2) : 0;\\n        return minY + minX <= radius * radius;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563341,
                "title": "4-lines-c-o-1-test-shortest-distance-from-center-to-rect-with-pics",
                "content": "Find the shortest distance from the center to the rect and compare it to the radius.\\n![image](https://assets.leetcode.com/users/kutar7580/image_1586018337.png)\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int edgeX = (x_center < x1) ? x1 : (x_center > x2) ? x2 : x_center;\\n        int edgeY = (y_center < y1) ? y1 : (y_center > y2) ? y2 : y_center;\\n        int distX = x_center - edgeX, distY = y_center - edgeY;\\n        return distX * distX + distY * distY <= radius * radius;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int edgeX = (x_center < x1) ? x1 : (x_center > x2) ? x2 : x_center;\\n        int edgeY = (y_center < y1) ? y1 : (y_center > y2) ? y2 : y_center;\\n        int distX = x_center - edgeX, distY = y_center - edgeY;\\n        return distX * distX + distY * distY <= radius * radius;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563317,
                "title": "c-check-rectangle-border",
                "content": "We first check whether the circle is within the rectangle.\\n\\nIf not, we check whether any point on the ractanble border is within the circle.\\n\\n> Update: see optimizations below.\\n\\n```cpp\\nbool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n    auto inside = [&](int x, int y) {\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r; };\\n    if (x1 <= xc && xc <= x2 && y1 <= yc && yc <= y2)\\n        return true;\\n    for (auto x = x1; x <= x2; ++x) {\\n        if (inside(x, y1) || inside(x, y2))\\n            return true;\\n    }\\n    for (auto y = y1; y <= y2; ++y) {\\n        if (inside(x1, y) || inside(x2, y))\\n            return true;                             \\n    }\\n    return false;\\n}\\n```\\n\\n**Optimized Solution**\\nSame as above, but limit the border scan within the circle radius.\\n```cpp\\nbool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n    auto inside = [&](int x, int y) {\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r; };\\n    if (x1 <= xc && xc <= x2 && y1 <= yc && yc <= y2)\\n        return true;\\n    for (auto x = max(x1, xc - r); x <= min(x2, xc + r); ++x) {\\n        if (inside(x, y1) || inside(x, y2))\\n            return true;\\n    }\\n    for (auto y = max(y1, yc - r); y <= min(y2, yc + r); ++y) {\\n        if (inside(x1, y) || inside(x2, y))\\n            return true;                             \\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n    auto inside = [&](int x, int y) {\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r; };\\n    if (x1 <= xc && xc <= x2 && y1 <= yc && yc <= y2)\\n        return true;\\n    for (auto x = x1; x <= x2; ++x) {\\n        if (inside(x, y1) || inside(x, y2))\\n            return true;\\n    }\\n    for (auto y = y1; y <= y2; ++y) {\\n        if (inside(x1, y) || inside(x2, y))\\n            return true;                             \\n    }\\n    return false;\\n}\\n```\n```cpp\\nbool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n    auto inside = [&](int x, int y) {\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r; };\\n    if (x1 <= xc && xc <= x2 && y1 <= yc && yc <= y2)\\n        return true;\\n    for (auto x = max(x1, xc - r); x <= min(x2, xc + r); ++x) {\\n        if (inside(x, y1) || inside(x, y2))\\n            return true;\\n    }\\n    for (auto y = max(y1, yc - r); y <= min(y2, yc + r); ++y) {\\n        if (inside(x1, y) || inside(x2, y))\\n            return true;                             \\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563351,
                "title": "python-o-1-simple-geometry",
                "content": "All relative positions of the intersecting shapes could be decomposed into 3 disjoint groups:\\n1.  a corner of a rectangle is inside the circle\\n2.  one of the edges of the rectangle crosses the circle\\n3.  the circle is completely inside the rectangle\\n\\nIdentifing that a given configuration belongs to one of these cases signifies that the shapes intersect.\\n\\nThough to make our code simpler we will not go for the disjointness of the cases and allow our separate conditions to trigger on some of the same cases, obviously that doesn\\'t sacrifice the corectness of the end result. For example x1<=x_c<=x2 and y1<=y_c<=y2 doesn\\'t only search for the circle inside the rectangle, it could also catch certain cases of the corner inside of the rectangle or an edge crossing the circle, but what is important for us that is does its job of the cathing the former thing. The same applies to the second bullet point.\\n\\nHope that helps!\\nCheers!\\n\\n![image](https://assets.leetcode.com/users/bison_a_besoncon/image_1586079758.png)\\n\\n```\\nclass Solution:\\n    def checkOverlap(self, r, x_c, y_c, x1, y1, x2, y2):\\n        corners = [(x1,y1), (x2,y1), (x2,y2), (x1, y2)]\\n        for (x, y) in corners:\\n            if (x_c - x)**2 + (y_c - y)**2 <= r**2:\\n                return True\\n\\n        for x in [x1, x2]:\\n            if x_c-r <= x <= x_c+r and y1<=y_c<=y2:\\n                return True\\n        for y in [y1, y2]:\\n            if y_c-r <= y <= y_c+r and x1<=x_c<=x2:\\n                return True\\n\\t\\t\\t\\t\\n        if x1<=x_c<=x2 and y1<=y_c<=y2:\\n            return True\\n        return False            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, r, x_c, y_c, x1, y1, x2, y2):\\n        corners = [(x1,y1), (x2,y1), (x2,y2), (x1, y2)]\\n        for (x, y) in corners:\\n            if (x_c - x)**2 + (y_c - y)**2 <= r**2:\\n                return True\\n\\n        for x in [x1, x2]:\\n            if x_c-r <= x <= x_c+r and y1<=y_c<=y2:\\n                return True\\n        for y in [y1, y2]:\\n            if y_c-r <= y <= y_c+r and x1<=x_c<=x2:\\n                return True\\n\\t\\t\\t\\t\\n        if x1<=x_c<=x2 and y1<=y_c<=y2:\\n            return True\\n        return False            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 563391,
                "title": "java-3-lines-super-easy-math-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x, int y, int x1, int y1, int x2, int y2) {\\n        int yy = (y <= y2 && y >= y1) ? 0 : Math.min(Math.abs(y1 - y), Math.abs(y2 - y));\\n        int xx = (x >= x1 && x <= x2) ? 0 : Math.min(Math.abs(x1 - x), Math.abs(x2 - x));\\n        return xx * xx + yy * yy <= radius * radius;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x, int y, int x1, int y1, int x2, int y2) {\\n        int yy = (y <= y2 && y >= y1) ? 0 : Math.min(Math.abs(y1 - y), Math.abs(y2 - y));\\n        int xx = (x >= x1 && x <= x2) ? 0 : Math.min(Math.abs(x1 - x), Math.abs(x2 - x));\\n        return xx * xx + yy * yy <= radius * radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563319,
                "title": "python-o-1-with-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n\\t\\t# Getting the coords of centre of rectangle\\n        c1 = (x2 + x1) / 2\\n        c2 = (y2 + y1) / 2\\n        \\n\\t\\t# Getting distance between centre of circle and rectangle in x, y direction\\n\\t\\t# Abs for suppose centre of circle in 3rd quad and of rectangle in 1st quad\\n        v1 = abs(x_center - c1) \\n        v2 = abs(y_center - c2)\\n        \\n\\t\\t# Getting half of breadth and lenght of rectangle\\n        h1 = (x2 - x1) / 2 \\n        h2 = (y2 - y1) / 2\\n         \\n\\t\\t# Difference in distance between (i) half of side of rectangle (h1,h2) (ii) distance between circle and rectangle\\n\\t\\t# It can be negative For eg. If circle is completely in rectangle. Hence taking max with zero\\n        u1 = max(0, v1 - h1)\\n        u2 = max(0, v2 - h2)\\n        \\n\\t\\t# Now try to think yourself for this last step\\n\\t\\t# Hint is hypotenuse !!\\n        return (u1 * u1 + u2 * u2 <= radius * radius)\\n\\n        # Hope you get it :)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n\\t\\t# Getting the coords of centre of rectangle\\n        c1 = (x2 + x1) / 2\\n        c2 = (y2 + y1) / 2\\n        \\n\\t\\t# Getting distance between centre of circle and rectangle in x, y direction\\n\\t\\t# Abs for suppose centre of circle in 3rd quad and of rectangle in 1st quad\\n        v1 = abs(x_center - c1) \\n        v2 = abs(y_center - c2)\\n        \\n\\t\\t# Getting half of breadth and lenght of rectangle\\n        h1 = (x2 - x1) / 2 \\n        h2 = (y2 - y1) / 2\\n         \\n\\t\\t# Difference in distance between (i) half of side of rectangle (h1,h2) (ii) distance between circle and rectangle\\n\\t\\t# It can be negative For eg. If circle is completely in rectangle. Hence taking max with zero\\n        u1 = max(0, v1 - h1)\\n        u2 = max(0, v2 - h2)\\n        \\n\\t\\t# Now try to think yourself for this last step\\n\\t\\t# Hint is hypotenuse !!\\n        return (u1 * u1 + u2 * u2 <= radius * radius)\\n\\n        # Hope you get it :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563572,
                "title": "java-detailed-explanation-with-graphs",
                "content": "I split it into three different situation:\\n\\n1. The vertex/vertices of the rectangle is inside the circle.\\nIn this situation, given the vertex(x,y) and the circle (radius, x_center, y_center), \\nif `(x - x_center)^2 + (y - y_center)^2 <=radius^2`\\nthen the vertex is inside the circle. Check if four vertices of the rectangle is inside the circle.\\n![image](https://assets.leetcode.com/users/jj-zhang/image_1586021433.png)\\n\\n2. An edge of the rectangle intersects the circle.\\nIn this situation, given the edge (x) and the circle (radius, x_center, y_center),\\nif `radius^2 >= (distance between center point and line) ^ 2`\\nthen the edge intersects the circle.\\n![image](https://assets.leetcode.com/users/jj-zhang/image_1586021470.png)\\n![image](https://assets.leetcode.com/users/jj-zhang/image_1586021485.png)\\nNote that it\\'s necessary to check whether is center point is within the range of the rectangle, or there would be some situation like this.\\n![image](https://assets.leetcode.com/users/jj-zhang/image_1586021525.png)\\n\\n3. The circle is inside the rectangle.\\nIn this situation, we can just check whether **four points**`x_left`,`x_right`,`y_top`, `y_bottom` is inside the rectangle.\\n![image](https://assets.leetcode.com/users/jj-zhang/image_1586021453.png)\\n\\nHere is my Java Code.\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int d_x1 = x_center - x1;\\n        int d_x2 = x_center - x2;\\n        int d_y1 = y_center - y1;\\n        int d_y2 = y_center - y2;\\n        int square = radius * radius;\\n        int x_top = x_center + radius;\\n        int x_bottom = x_center - radius;\\n        int y_top = y_center + radius;\\n        int y_bottom = y_center - radius;\\n        boolean insideX = (x_center >= x1) && (x_center <= x2);\\n        boolean insideY = (y_center >= y1) && (y_center <= y2);\\n        \\n        if ((d_x1 * d_x1 + d_y1 * d_y1 <= square) || (d_x2 * d_x2 + d_y1 * d_y1 <= square) || (d_x1 * d_x1 + d_y2 * d_y2 <= square) || (d_x2 * d_x2 + d_y2 * d_y2 <= square)) {\\n            return true;\\n        }\\n        if (((square - d_x1 * d_x1 >= 0) && insideY) || ((square - d_x2 * d_x2 >= 0) && insideY) || ((square - d_y1 * d_y1 >= 0) && insideX) || ((square - d_y2 * d_y2 >= 0) && insideX)) {\\n            return true;\\n        }\\n        // Circle inside the square.\\n        if ((x_top <= x2) && (x_bottom >= x1) && (y2 >= y_top) && (y1 <= y_bottom)) return true;\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int d_x1 = x_center - x1;\\n        int d_x2 = x_center - x2;\\n        int d_y1 = y_center - y1;\\n        int d_y2 = y_center - y2;\\n        int square = radius * radius;\\n        int x_top = x_center + radius;\\n        int x_bottom = x_center - radius;\\n        int y_top = y_center + radius;\\n        int y_bottom = y_center - radius;\\n        boolean insideX = (x_center >= x1) && (x_center <= x2);\\n        boolean insideY = (y_center >= y1) && (y_center <= y2);\\n        \\n        if ((d_x1 * d_x1 + d_y1 * d_y1 <= square) || (d_x2 * d_x2 + d_y1 * d_y1 <= square) || (d_x1 * d_x1 + d_y2 * d_y2 <= square) || (d_x2 * d_x2 + d_y2 * d_y2 <= square)) {\\n            return true;\\n        }\\n        if (((square - d_x1 * d_x1 >= 0) && insideY) || ((square - d_x2 * d_x2 >= 0) && insideY) || ((square - d_y1 * d_y1 >= 0) && insideX) || ((square - d_y2 * d_y2 >= 0) && insideX)) {\\n            return true;\\n        }\\n        // Circle inside the square.\\n        if ((x_top <= x2) && (x_bottom >= x1) && (y2 >= y_top) && (y1 <= y_bottom)) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563458,
                "title": "c-3-lines-math-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int dx = x_center - max(x1, min(x_center, x2));\\n        int dy = y_center - max(y1, min(y_center, y2));\\n        return (dx * dx + dy * dy) <= (radius * radius);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int dx = x_center - max(x1, min(x_center, x2));\\n        int dy = y_center - max(y1, min(y_center, y2));\\n        return (dx * dx + dy * dy) <= (radius * radius);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565206,
                "title": "python-one-line",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, r: int, rx: int, ry: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return (rx - min(max(x1, rx), x2)) ** 2 + (ry - min(max(y1, ry), y2)) ** 2 <= r ** 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, r: int, rx: int, ry: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return (rx - min(max(x1, rx), x2)) ** 2 + (ry - min(max(y1, ry), y2)) ** 2 <= r ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911047,
                "title": "c-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int sqr(int x) {\\n        return x*x;\\n    }\\n    \\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        int x = max(x1, min(xCenter, x2));\\n        int y = max(y1, min(yCenter, y2));\\n        \\n        if (sqr(x-xCenter) + sqr(y-yCenter) <= sqr(radius)) return true;\\n        return false;\\n    }\\n};\\n```\\n\\n**I have drawn a figure to understand all cases easily. Have a look and upvote if you like it.**\\n\\n![image](https://assets.leetcode.com/users/images/8fe8036b-6ad0-4866-b539-30d9ed5d825a_1649000365.6651344.png)\\n",
                "solutionTags": [
                    "C",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sqr(int x) {\\n        return x*x;\\n    }\\n    \\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        int x = max(x1, min(xCenter, x2));\\n        int y = max(y1, min(yCenter, y2));\\n        \\n        if (sqr(x-xCenter) + sqr(y-yCenter) <= sqr(radius)) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194137,
                "title": "simple-3-line-c-only-integer-calculations-100-100",
                "content": "```x = clamp(x_center, x1, x2)``` and ```y = clamp(y_center, y1, y2)``` get the closest point (x, y) from the circle on the rectangle. Then I calculate lenght of the line between circle\\'s center and our just computed point, and compare it to circle\\'s radius.\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) {\\n        x = std::clamp(x, x1, x2) - x;\\n        y = std::clamp(y, y1, y2) - y;\\n        return x * x + y * y <= r * r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```x = clamp(x_center, x1, x2)```\n```y = clamp(y_center, y1, y2)```\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) {\\n        x = std::clamp(x, x1, x2) - x;\\n        y = std::clamp(y, y1, y2) - y;\\n        return x * x + y * y <= r * r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025150,
                "title": "python-o-1-solution-with-explaination-and-derivation",
                "content": "```\\nclass Solution(object):\\n    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):\\n        \"\"\"\\n        :type radius: int\\n        :type x_center: int\\n        :type y_center: int\\n        :type x1: int\\n        :type y1: int\\n        :type x2: int\\n        :type y2: int\\n        :rtype: bool\\n        \"\"\"\\n        # equations:\\n        # for a point (x, y) to be inside the circle, it has to satisfy the following:\\n        # 1. (x - x_center) ^ 2 + (y - y_center) ^ 2 <= radius ^ 2\\n        # for a point (x, y) to be inside the rectangle, it has to satisfy the following:\\n        # 2. x1 <= x <= x2\\n        # 3. y1 <= y <= y2\\n\\n        # For a O(1) solution, we need to find the point in the rectangle that\\'s closest to the center of the circle, \\n\\t\\t# and verify that the distance from that point to the circle\\'s center is less than the radius. \\n\\t\\t\\n        # In other words, find the x in [x1, x2] such that the value of (x - x_center) ^ 2 is minimized. \\n\\t\\t\\n\\t\\t# It should be apparent to the reader that if x_center is within [x1, x2] the minimal value should be 0, \\n\\t\\t# else we just need to test the two boundary value x1 and x2 and use the smallest.\\n\\t\\t\\n        # repeat the same for y\\n\\t\\t\\n        # Finally we can use above (x,y) to check against equation 1.\\n\\n        min_x_distance = self.find_min(x1, x2, x_center)\\n        min_y_distance = self.find_min(y1, y2, y_center)\\n        return min_y_distance + min_x_distance <= radius * radius\\n    \\n    def find_min(self, lower_bound, upper_bound, point):\\n        if point < lower_bound:\\n            return (lower_bound - point) ** 2\\n        if point > upper_bound:\\n            return (upper_bound - point) ** 2\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):\\n        \"\"\"\\n        :type radius: int\\n        :type x_center: int\\n        :type y_center: int\\n        :type x1: int\\n        :type y1: int\\n        :type x2: int\\n        :type y2: int\\n        :rtype: bool\\n        \"\"\"\\n        # equations:\\n        # for a point (x, y) to be inside the circle, it has to satisfy the following:\\n        # 1. (x - x_center) ^ 2 + (y - y_center) ^ 2 <= radius ^ 2\\n        # for a point (x, y) to be inside the rectangle, it has to satisfy the following:\\n        # 2. x1 <= x <= x2\\n        # 3. y1 <= y <= y2\\n\\n        # For a O(1) solution, we need to find the point in the rectangle that\\'s closest to the center of the circle, \\n\\t\\t# and verify that the distance from that point to the circle\\'s center is less than the radius. \\n\\t\\t\\n        # In other words, find the x in [x1, x2] such that the value of (x - x_center) ^ 2 is minimized. \\n\\t\\t\\n\\t\\t# It should be apparent to the reader that if x_center is within [x1, x2] the minimal value should be 0, \\n\\t\\t# else we just need to test the two boundary value x1 and x2 and use the smallest.\\n\\t\\t\\n        # repeat the same for y\\n\\t\\t\\n        # Finally we can use above (x,y) to check against equation 1.\\n\\n        min_x_distance = self.find_min(x1, x2, x_center)\\n        min_y_distance = self.find_min(y1, y2, y_center)\\n        return min_y_distance + min_x_distance <= radius * radius\\n    \\n    def find_min(self, lower_bound, upper_bound, point):\\n        if point < lower_bound:\\n            return (lower_bound - point) ** 2\\n        if point > upper_bound:\\n            return (upper_bound - point) ** 2\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895200,
                "title": "circle-and-rectangle-overlapping",
                "content": "```\\nwe know the equation of circle (x-c1)^2+(y-c2)^2=r^2\\nx1<=i<=x2\\ny1<=j<=y2\\nif((i-c1)^2+(j-c2)^2<=r*r)\\n   -> means that if (i,j) belongs to circle means that it touches or intersects the circle.\\n```\\n```\\nclass Solution \\n{\\n public:\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n    {\\n        for(int i=x1;i<=x2;i++)\\n        {\\n           for(int j=y1;j<=y2;j++)\\n           {\\n              int c1=i-x;\\n              int c2=j-y;\\n              if(c1*c1+c2*c2<=r*r)\\n                  return 1;\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Geometry"
                ],
                "code": "```\\nwe know the equation of circle (x-c1)^2+(y-c2)^2=r^2\\nx1<=i<=x2\\ny1<=j<=y2\\nif((i-c1)^2+(j-c2)^2<=r*r)\\n   -> means that if (i,j) belongs to circle means that it touches or intersects the circle.\\n```\n```\\nclass Solution \\n{\\n public:\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n    {\\n        for(int i=x1;i<=x2;i++)\\n        {\\n           for(int j=y1;j<=y2;j++)\\n           {\\n              int c1=i-x;\\n              int c2=j-y;\\n              if(c1*c1+c2*c2<=r*r)\\n                  return 1;\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735247,
                "title": "c-easy-to-understand-simple-solution-shifting-center-to-origin",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        x1-=xCenter;\\n        x2-=xCenter;\\n        y1-=yCenter;\\n        y2-=yCenter;\\n        int minX,minY;\\n        if(x1*x2>0)\\n            minX=min(x1*x1,x2*x2);\\n        else\\n            minX=0;\\n        if(y1*y2>0)\\n            minY=min(y1*y1,y2*y2);\\n        else\\n            minY=0;\\n        return minX+minY<=radius*radius;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        x1-=xCenter;\\n        x2-=xCenter;\\n        y1-=yCenter;\\n        y2-=yCenter;\\n        int minX,minY;\\n        if(x1*x2>0)\\n            minX=min(x1*x1,x2*x2);\\n        else\\n            minX=0;\\n        if(y1*y2>0)\\n            minY=min(y1*y1,y2*y2);\\n        else\\n            minY=0;\\n        return minX+minY<=radius*radius;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688824,
                "title": "c-beats-100-speed-and-space",
                "content": "```\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n    int tx = x_center;\\n    int ty = y_center;\\n    \\n    \\n    if(x_center<x1) tx = x1; // left\\n    else if(x_center>x2) tx = x2; //right\\n    else tx = x_center; // between y1 and y2\\n    if(y_center<y1) ty = y1; //bottom\\n    else if(y_center>y2) ty = y2; //top\\n    else ty = y_center; //between x1 and x2\\n    \\n    \\n    int disx = x_center - tx;  \\n    int disy = y_center - ty;\\n    int distance = sqrt((disx * disx) + (disy * disy)); //distance formula\\n    \\n    \\n    return distance <= radius;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n    int tx = x_center;\\n    int ty = y_center;\\n    \\n    \\n    if(x_center<x1) tx = x1; // left\\n    else if(x_center>x2) tx = x2; //right\\n    else tx = x_center; // between y1 and y2\\n    if(y_center<y1) ty = y1; //bottom\\n    else if(y_center>y2) ty = y2; //top\\n    else ty = y_center; //between x1 and x2\\n    \\n    \\n    int disx = x_center - tx;  \\n    int disy = y_center - ty;\\n    int distance = sqrt((disx * disx) + (disy * disy)); //distance formula\\n    \\n    \\n    return distance <= radius;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563452,
                "title": "the-smart-brute-force-solution",
                "content": "I noticed that if the rectangle and circle were to overlap, it could only happen at a limited number of x and y coordinates. So instead of trying to figure out exactly which ones, let\\'s just test every possible combination of those x and y coordinates, and check if there are any that are both in the circle and the rectangle.\\n\\n\\n```\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int[] all_x = {x1, x2, x_center, x_center + radius, x_center-radius}; \\n        int[] all_y = {y1, y2, y_center, y_center + radius, y_center-radius};\\n        \\n        for(int x: all_x){\\n            for(int y: all_y){\\n                if(checkInRectangle(x,y,x1, y1, x2, y2) && checkInCircle(x,y, radius, x_center, y_center)) return true;\\n            }\\n        }\\n        return false;\\n\\t}\\n    private boolean checkInCircle(int px, int py, int radius, int x_center, int y_center) {\\n        return Math.sqrt((px-x_center)*(px-x_center) + (py-y_center)*(py-y_center)) <= radius;\\n    }\\n    \\n    private boolean checkInRectangle(int px, int py, int x1, int y1, int x2, int y2) {\\n        return px >= x1 && px <= x2 && py >= y1 && py <= y2;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int[] all_x = {x1, x2, x_center, x_center + radius, x_center-radius}; \\n        int[] all_y = {y1, y2, y_center, y_center + radius, y_center-radius};\\n        \\n        for(int x: all_x){\\n            for(int y: all_y){\\n                if(checkInRectangle(x,y,x1, y1, x2, y2) && checkInCircle(x,y, radius, x_center, y_center)) return true;\\n            }\\n        }\\n        return false;\\n\\t}\\n    private boolean checkInCircle(int px, int py, int radius, int x_center, int y_center) {\\n        return Math.sqrt((px-x_center)*(px-x_center) + (py-y_center)*(py-y_center)) <= radius;\\n    }\\n    \\n    private boolean checkInRectangle(int px, int py, int x1, int y1, int x2, int y2) {\\n        return px >= x1 && px <= x2 && py >= y1 && py <= y2;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563432,
                "title": "swift-math-geometry-solution",
                "content": "```\\nclass Solution {\\n    func checkOverlap(_ radius: Int, _ x_center: Int, _ y_center: Int, _ left: Int, _ bottom: Int, _ right: Int, _ top: Int) -> Bool {\\n        let recW = Double(right - left)\\n        let recH = Double(top - bottom)\\n        let recx = Double(right + left) / 2\\n        let recy = Double(top + bottom) / 2\\n        \\n        // distance between rectange\\'s center and circle\\'s center\\n        let dx = abs(Double(x_center) - Double(recx))\\n        let dy = abs(Double(y_center) - Double(recy))\\n        \\n        if dx > recW/2 + Double(radius) { return false }\\n        if dy > recH/2 + Double(radius) { return false }\\n        if dx <= recW/2 { return true }\\n        if dy <= recH/2 { return true }\\n                     \\n        let sq = ((dx - recW/2) * (dx - recW/2) + (dy - recH/2) * (dy - recH/2))\\n        return (Double(radius) * Double(radius)) >= sq\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    func checkOverlap(_ radius: Int, _ x_center: Int, _ y_center: Int, _ left: Int, _ bottom: Int, _ right: Int, _ top: Int) -> Bool {\\n        let recW = Double(right - left)\\n        let recH = Double(top - bottom)\\n        let recx = Double(right + left) / 2\\n        let recy = Double(top + bottom) / 2\\n        \\n        // distance between rectange\\'s center and circle\\'s center\\n        let dx = abs(Double(x_center) - Double(recx))\\n        let dy = abs(Double(y_center) - Double(recy))\\n        \\n        if dx > recW/2 + Double(radius) { return false }\\n        if dy > recH/2 + Double(radius) { return false }\\n        if dx <= recW/2 { return true }\\n        if dy <= recH/2 { return true }\\n                     \\n        let sq = ((dx - recW/2) * (dx - recW/2) + (dy - recH/2) * (dy - recH/2))\\n        return (Double(radius) * Double(radius)) >= sq\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882948,
                "title": "solution-for-leetcode-problem-1401-circle-and-rectangle-overlapping",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->The idea behind this approach is to find the closest point on the rectangle to the center of the circle. If the distance between this closest point and the center of the circle is less than or equal to the radius of the circle, then the circle and rectangle overlap.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the closest point on the rectangle to the center of the circle. This can be done by finding the coordinates (closestX, closestY) where closestX is the maximum of x1 and the minimum of xCenter and x2, and closestY is the maximum of y1 and the minimum of yCenter and y2.\\n\\nCalculate the distance between the closest point (closestX, closestY) and the center of the circle (xCenter, yCenter) using the differences in x and y coordinates: distanceX = xCenter - closestX and distanceY = yCenter - closestY.\\n\\nCalculate the squared distance between the closest point and the center of the circle: squaredDistance = distanceX * distanceX + distanceY * distanceY.\\n\\nCompare the squared distance with the squared radius of the circle. If squaredDistance is less than or equal to radius * radius, then there is an overlap; otherwise, there is no overlap.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe calculations involved in finding the closest point, distance, and squared distance are constant-time operations. Therefore, the time complexity of this approach is O(1), or constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe algorithm uses a few integer variables to store intermediate results. These variables do not scale with input size, so the space complexity remains O(1), or constant space.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n                // Calculate the closest point on the rectangle to the center of the circle\\n        int closestX = Math.max(x1, Math.min(xCenter, x2));\\n        int closestY = Math.max(y1, Math.min(yCenter, y2));\\n        \\n        // Calculate the distance between the closest point and the center of the circle\\n        int distanceX = xCenter - closestX;\\n        int distanceY = yCenter - closestY;\\n        \\n        // Calculate the squared distance\\n        int squaredDistance = distanceX * distanceX + distanceY * distanceY;\\n        \\n        // Compare the squared distance with the squared radius\\n        return squaredDistance <= radius * radius;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n                // Calculate the closest point on the rectangle to the center of the circle\\n        int closestX = Math.max(x1, Math.min(xCenter, x2));\\n        int closestY = Math.max(y1, Math.min(yCenter, y2));\\n        \\n        // Calculate the distance between the closest point and the center of the circle\\n        int distanceX = xCenter - closestX;\\n        int distanceY = yCenter - closestY;\\n        \\n        // Calculate the squared distance\\n        int squaredDistance = distanceX * distanceX + distanceY * distanceY;\\n        \\n        // Compare the squared distance with the squared radius\\n        return squaredDistance <= radius * radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194118,
                "title": "binary-search-0ms-different-solution-explained",
                "content": "I know this might look like an overkill but for the fellow coders who couldn\\'t quickly come up with the mathematical solution like me!!\\n\\n[I mean, if you can make the machine do the hard work, why not? Right??]\\n\\n# Intuition\\n\\n1. Find the center of the rectangle.\\n2. This divides the rectangle into 4 smaller non-overlapping rectangles.\\n3. Check if center is inside the circle.\\n4. This can be checked mathematically by substituting the point in the circle equation and if it\\'s less than or equal to the radius, we have the answer.\\n5. Else, find the corner of the rectangle that\\'s closest to the center of the circle.\\n6. Now we have a smaller rectangle, 1/4th the area of the earlier, formed by the center in step 2 and the corner in step 5.\\n7. Loop until rectangle becomes A POINT. :)\\n\\nThis algorithm quickly converges to an answer - hence 0ms.\\n\\nThis can be done in like 14 lines of code.\\nCode is well commented to describe the above idea further.\\n\\n# Complexity\\n- Time complexity:\\n\\nlog_base_4(area_of_rectangle)\\n\\nNot to the base 2 as in binary search - since we chose the closest rectangle to the circle center - from amongst the 4 at a time.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nbool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) const noexcept\\n{\\n    // If returned value is less than or equal to zero\\n    // <x,y> is inside or on the circle.\\n    // Also, larger the returned value further that point is away\\n    // from the center of the circle.\\n    auto in_or_out_circle = [=](int x, int y) noexcept -> int\\n    {\\n        return (x-xCenter)*(x-xCenter) +\\n               (y-yCenter)*(y-yCenter) -\\n               radius*radius;\\n    };\\n\\n    while(x1 != x2 || y1 != y2)\\n    {\\n        // finding the center of the rectangle creating 4 new\\n        // smaller rectangles for us to work with.\\n        auto const center_x = x1 + (x2 - x1)/2;\\n        auto const center_y = y1 + (y2 - y1)/2;\\n\\n        if(in_or_out_circle(center_x, center_y) <= 0) return true;\\n\\n        auto min = std::numeric_limits<int>::max();\\n        for(auto [corner_x, corner_y] : {std::pair{x1,y1},\\n                                         std::pair{x1,y2},\\n                                         std::pair{x2,y1},\\n                                         std::pair{x2,y2}})\\n        {\\n             // find the closest corner to circle-center inorder\\n             // to choose the smaller rectangle of interest\\n            auto const val = in_or_out_circle(corner_x, corner_y);\\n            if(val < min)\\n            {\\n                x1 = corner_x;\\n                y1 = corner_y;\\n                min = val;\\n            }\\n        }\\n        // Prior center becomes the new corner of the\\n        // smaller selected rectangle\\n        x2 = center_x;\\n        y2 = center_y;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nbool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) const noexcept\\n{\\n    // If returned value is less than or equal to zero\\n    // <x,y> is inside or on the circle.\\n    // Also, larger the returned value further that point is away\\n    // from the center of the circle.\\n    auto in_or_out_circle = [=](int x, int y) noexcept -> int\\n    {\\n        return (x-xCenter)*(x-xCenter) +\\n               (y-yCenter)*(y-yCenter) -\\n               radius*radius;\\n    };\\n\\n    while(x1 != x2 || y1 != y2)\\n    {\\n        // finding the center of the rectangle creating 4 new\\n        // smaller rectangles for us to work with.\\n        auto const center_x = x1 + (x2 - x1)/2;\\n        auto const center_y = y1 + (y2 - y1)/2;\\n\\n        if(in_or_out_circle(center_x, center_y) <= 0) return true;\\n\\n        auto min = std::numeric_limits<int>::max();\\n        for(auto [corner_x, corner_y] : {std::pair{x1,y1},\\n                                         std::pair{x1,y2},\\n                                         std::pair{x2,y1},\\n                                         std::pair{x2,y2}})\\n        {\\n             // find the closest corner to circle-center inorder\\n             // to choose the smaller rectangle of interest\\n            auto const val = in_or_out_circle(corner_x, corner_y);\\n            if(val < min)\\n            {\\n                x1 = corner_x;\\n                y1 = corner_y;\\n                min = val;\\n            }\\n        }\\n        // Prior center becomes the new corner of the\\n        // smaller selected rectangle\\n        x2 = center_x;\\n        y2 = center_y;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1142484,
                "title": "simple-4-line-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        //Applying the pythagoras theorem for calculating the distance between the pts to know //which pts lies with circlce\\n        for(int i=x1;i<=x2;i++){\\n            for(int j=y1;j<=y2;j++){\\n                if(sqrt(pow((x_center-i),2)+pow(y_center-j,2))<=radius)\\n                    return true;\\n            }\\n        }\\n        return false;\\n     }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        //Applying the pythagoras theorem for calculating the distance between the pts to know //which pts lies with circlce\\n        for(int i=x1;i<=x2;i++){\\n            for(int j=y1;j<=y2;j++){\\n                if(sqrt(pow((x_center-i),2)+pow(y_center-j,2))<=radius)\\n                    return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 868820,
                "title": "my-java-solution-with-comments",
                "content": "```\\n/*\\n-> (y <= y2 && y >= y1): the two horizontal lines are at different sides of the circle center\\n\\n-> Math.min(Math.abs(y1 - y), Math.abs(y2 - y)): the distance between the horizontal line and the circle center. (There are two such distances. Take the smaller one.)\\n\\n-> (x >= x1 && x <= x2): the two vertical lines are at different sides of the circle center\\n\\n-> Math.min(Math.abs(x1 - x), Math.abs(x2 - x)): the distance between the vertical line and the circle center. (There are two such distances. Take the smaller one.)\\n\\n->The 0 after ?: if the two lines are at different sides, at the return line we will check only the other value (i.e. the value calculated from the other two lines)\\n\\n-> xx * xx + yy * yy <= radius * radius:\\n\\n(a) if xx == 0 and yy==0, that means circle center is in the rectangle\\n(b) if only one of xx and yy is zero, that means we want to check the distance between circle center and the line that is closest to the circle center.\\n(c) if both xx and yy are not zero, that means we want to check the distance between circle center and the rectangle corner that is closest to the circle center.\\n\\n*/\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int y = (y2 >= y_center && y1 <= y_center) ? 0 : Math.min(Math.abs(y2 - y_center), Math.abs(y1-y_center));\\n        int x = (x2 >= x_center && x1 <= x_center) ? 0 : Math.min(Math.abs(x2 - x_center), Math.abs(x1 - x_center));\\n        if (x * x + y*y <= radius * radius)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n/*\\n-> (y <= y2 && y >= y1): the two horizontal lines are at different sides of the circle center\\n\\n-> Math.min(Math.abs(y1 - y), Math.abs(y2 - y)): the distance between the horizontal line and the circle center. (There are two such distances. Take the smaller one.)\\n\\n-> (x >= x1 && x <= x2): the two vertical lines are at different sides of the circle center\\n\\n-> Math.min(Math.abs(x1 - x), Math.abs(x2 - x)): the distance between the vertical line and the circle center. (There are two such distances. Take the smaller one.)\\n\\n->The 0 after ?: if the two lines are at different sides, at the return line we will check only the other value (i.e. the value calculated from the other two lines)\\n\\n-> xx * xx + yy * yy <= radius * radius:\\n\\n(a) if xx == 0 and yy==0, that means circle center is in the rectangle\\n(b) if only one of xx and yy is zero, that means we want to check the distance between circle center and the line that is closest to the circle center.\\n(c) if both xx and yy are not zero, that means we want to check the distance between circle center and the rectangle corner that is closest to the circle center.\\n\\n*/\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int y = (y2 >= y_center && y1 <= y_center) ? 0 : Math.min(Math.abs(y2 - y_center), Math.abs(y1-y_center));\\n        int x = (x2 >= x_center && x1 <= x_center) ? 0 : Math.min(Math.abs(x2 - x_center), Math.abs(x1 - x_center));\\n        if (x * x + y*y <= radius * radius)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 639682,
                "title": "python3-two-solutions-circle-and-rectangle-overlapping",
                "content": "First, check if the nearest point is in the circle. For either dimension, if the center is in between the points, only consider the other dimension.\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        x = 0 if x1 <= x_center <= x2 else min(abs(x1-x_center), abs(x2-x_center))\\n        y = 0 if y1 <= y_center <= y2 else min(abs(y1-y_center), abs(y2-y_center))\\n        return x**2 + y**2 <= radius**2\\n```\\nThe second one is more self explanatory:\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        def pointInCircle(p, center):\\n            nonlocal radius\\n            xr, yr = center\\n            x, y = p\\n            return  abs(x-xr)**2 + abs(y-yr)**2 <= radius**2\\n        \\n        def segmentOverlaps(s1, s2):\\n            return max(s1[0], s2[0]) <= min(s1[1], s2[1])\\n        \\n        if any(pointInCircle(p, (x_center, y_center))\\n               for p in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]):\\n            return True\\n        \\n        if (not segmentOverlaps([x_center - radius, x_center + radius], sorted([x1, x2])) or\\n            not segmentOverlaps([y_center - radius, y_center + radius], sorted([y1, y2]))):\\n            return False\\n        \\n        return x1 <= x_center <= x2 or y1 <= y_center <= y2\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        x = 0 if x1 <= x_center <= x2 else min(abs(x1-x_center), abs(x2-x_center))\\n        y = 0 if y1 <= y_center <= y2 else min(abs(y1-y_center), abs(y2-y_center))\\n        return x**2 + y**2 <= radius**2\\n```\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        def pointInCircle(p, center):\\n            nonlocal radius\\n            xr, yr = center\\n            x, y = p\\n            return  abs(x-xr)**2 + abs(y-yr)**2 <= radius**2\\n        \\n        def segmentOverlaps(s1, s2):\\n            return max(s1[0], s2[0]) <= min(s1[1], s2[1])\\n        \\n        if any(pointInCircle(p, (x_center, y_center))\\n               for p in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]):\\n            return True\\n        \\n        if (not segmentOverlaps([x_center - radius, x_center + radius], sorted([x1, x2])) or\\n            not segmentOverlaps([y_center - radius, y_center + radius], sorted([y1, y2]))):\\n            return False\\n        \\n        return x1 <= x_center <= x2 or y1 <= y_center <= y2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586145,
                "title": "clear-python-solution",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, r: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n      # check if center in rectangle\\n      if x_center in range(x1, x2 + 1) and y_center in range(y1, y2 + 1):\\n        return True\\n      \\n      # check a point from each edge and see if it is within radius of circle\\n      \\'\\'\\'\\n       x1,y2--------------+x2,y2\\n       |                  |\\n       |                  |\\n       |                  |\\n       |                  |\\n       |                  |\\n       |                  |\\n       +------------------+x2,y1\\n     x1,y1\\n\\n      \\'\\'\\'\\n      def within_radius(x,y):\\n        return (x_center - x)*(x_center - x) + (y_center - y)*(y_center - y) <= r*r\\n      \\n      for x in range(x1, x2+1):\\n        if within_radius(x, y1) or within_radius(x, y2):\\n          return True\\n      \\n      for y in range(y1, y2+1):\\n        if within_radius(x1, y) or within_radius(x2, y):\\n          return True\\n      \\n      return False\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, r: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n      # check if center in rectangle\\n      if x_center in range(x1, x2 + 1) and y_center in range(y1, y2 + 1):\\n        return True\\n      \\n      # check a point from each edge and see if it is within radius of circle\\n      \\'\\'\\'\\n       x1,y2--------------+x2,y2\\n       |                  |\\n       |                  |\\n       |                  |\\n       |                  |\\n       |                  |\\n       |                  |\\n       +------------------+x2,y1\\n     x1,y1\\n\\n      \\'\\'\\'\\n      def within_radius(x,y):\\n        return (x_center - x)*(x_center - x) + (y_center - y)*(y_center - y) <= r*r\\n      \\n      for x in range(x1, x2+1):\\n        if within_radius(x, y1) or within_radius(x, y2):\\n          return True\\n      \\n      for y in range(y1, y2+1):\\n        if within_radius(x1, y) or within_radius(x2, y):\\n          return True\\n      \\n      return False\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 580034,
                "title": "python-explanation-with-figures",
                "content": "There are essentially 2 possible cases when the intersection occurs.\\n**Case 1:** The side of the rectangle touches or intersects the circle\\n![image](https://assets.leetcode.com/users/sheel93/image_1586909135.png)\\n\\n**Case 2:** The center of the circle lies inside the rectangle\\n![image](https://assets.leetcode.com/users/sheel93/image_1586909163.png)\\n\\nTo test whether the shapes intersect, we need to find a point on or inside the rectangle that is closest to the center of the circle. If this point lies on or inside the circle, it is guaranteed that both the shapes intersect. Let the closest point be denoted by `(x_nearest, y_nearest)`. Then the  distance between the closest point and the center of the circle can be found using `((x_center - x_nearest)^2 + (y_center - y_nearest)^2)^0.5`. If this distance <= radius of the circle, the two shapes intersect. \\n\\nOn close inspection it can be observed that the point of interest only depends on the locations of `(x1, y1)` and `(x2, y2)` relative to `(x_center, y_center)`.  \\n\\nIn case 1, the x-coordinate of the closest point will either be `x1`, `x2`, or `x_center` and the y-coordinate will be one among `y1`, `y2`, and `y_center`.  \\n\\nIn case 2, since the center of the circle lies inside the rectangle, the closest point will be `(x_center, y_center)`.  \\n\\nThe closest point in both the cases can be calculated using the following expressions:  \\n`x_nearest = max(x1, min(x_center, x2))`\\n`y_nearest = max(y1, min(y_center, y2))`\\n\\n```Python\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool: \\n        # Find the nearest point on the rectangle to the center of the circle\\n        x_nearest = max(x1, min(x_center, x2))\\n        y_nearest = max(y1, min(y_center, y2))\\n        \\n        # Find the distance between the nearest point and the center of the circle\\n        # Distance between 2 points, (x1,y1) & (x2,y2) in 2D Euclidean space = ((x1-x2)**2 + (y1-y2)**2)**0.5\\n        distance_x = x_nearest - x_center\\n        distance_y = y_nearest - y_center\\n        return (distance_x**2 + distance_y**2) <= radius**2\\n    \\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool: \\n        # Find the nearest point on the rectangle to the center of the circle\\n        x_nearest = max(x1, min(x_center, x2))\\n        y_nearest = max(y1, min(y_center, y2))\\n        \\n        # Find the distance between the nearest point and the center of the circle\\n        # Distance between 2 points, (x1,y1) & (x2,y2) in 2D Euclidean space = ((x1-x2)**2 + (y1-y2)**2)**0.5\\n        distance_x = x_nearest - x_center\\n        distance_y = y_nearest - y_center\\n        return (distance_x**2 + distance_y**2) <= radius**2\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 563484,
                "title": "c-check-if-any-point-in-the-rectangle-falls-inside-the-circle",
                "content": "This problem can be easily solved by checking if any of the point inside the area of the rectangle falls inside the area of the circle.\\nUsing the equation of the circle, **if any point (x, y) lies inside the the circle, then it should satisfy the following equation:**\\n\\n***(x\\' - x)^2 + (y\\' - y)^2 <= r^2***\\nwhere, (x\\', y\\') is the center of the circle, and r is the radius of the circle\\n\\nThe function implementation of the above formula would be:\\n\\n```\\nbool computeFormula(int radius, int x_center, int y_center, int x, int y)\\n    {\\n        float r = pow(x-x_center, 2) + pow(y-y_center, 2);\\n        if(r <= pow(radius, 2))\\n            return true;\\n        \\n        return false;\\n    }\\n```\\n\\nIterating through all the points in the area of the rectangle, **if any of the point touches the circumference of the circle or falls inside the circle**, then the rectangle and the circle overlap.\\n\\n```\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        for(int i = x1;i <= x2;i++)\\n        {\\n            for(int j = y1;j <= y2;j++)\\n            {\\n                if(computeFormula(radius, x_center, y_center, i, j))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Geometry"
                ],
                "code": "```\\nbool computeFormula(int radius, int x_center, int y_center, int x, int y)\\n    {\\n        float r = pow(x-x_center, 2) + pow(y-y_center, 2);\\n        if(r <= pow(radius, 2))\\n            return true;\\n        \\n        return false;\\n    }\\n```\n```\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        for(int i = x1;i <= x2;i++)\\n        {\\n            for(int j = y1;j <= y2;j++)\\n            {\\n                if(computeFormula(radius, x_center, y_center, i, j))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3699442,
                "title": "c-distance-between-the-two-centre",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n public:\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n    {\\n        for(int i=x1;i<=x2;i++)\\n        {\\n           for(int j=y1;j<=y2;j++)\\n           {\\n              int c1=i-x;\\n              int c2=j-y;\\n              if(c1*c1+c2*c2<=r*r)\\n                  return 1;\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n public:\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n    {\\n        for(int i=x1;i<=x2;i++)\\n        {\\n           for(int j=y1;j<=y2;j++)\\n           {\\n              int c1=i-x;\\n              int c2=j-y;\\n              if(c1*c1+c2*c2<=r*r)\\n                  return 1;\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677990,
                "title": "java-3-lines",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        int a = x1 > xc ? x1 - xc : xc > x2 ? xc - x2 : 0;\\n        int b = y1 > yc ? y1 - yc : yc > y2 ? yc - y2 : 0;\\n        return a * a + b * b <= r * r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        int a = x1 > xc ? x1 - xc : xc > x2 ? xc - x2 : 0;\\n        int b = y1 > yc ? y1 - yc : yc > y2 ? yc - y2 : 0;\\n        return a * a + b * b <= r * r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632964,
                "title": "c-easy-to-understand-step-by-step",
                "content": "```\\nbool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n    auto inside = [&](int x, int y) {\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r; };\\n    if (x1 <= xc && xc <= x2 && y1 <= yc && yc <= y2)\\n        return true;\\n    for (auto x = max(x1, xc - r); x <= min(x2, xc + r); ++x) {\\n        if (inside(x, y1) || inside(x, y2))\\n            return true;\\n    }\\n    for (auto y = max(y1, yc - r); y <= min(y2, yc + r); ++y) {\\n        if (inside(x1, y) || inside(x2, y))\\n            return true;                             \\n    }\\n    return false;\\n}",
                "solutionTags": [],
                "code": "```\\nbool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n    auto inside = [&](int x, int y) {\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r; };\\n    if (x1 <= xc && xc <= x2 && y1 <= yc && yc <= y2)\\n        return true;\\n    for (auto x = max(x1, xc - r); x <= min(x2, xc + r); ++x) {\\n        if (inside(x, y1) || inside(x, y2))\\n            return true;\\n    }\\n    for (auto y = max(y1, yc - r); y <= min(y2, yc + r); ++y) {\\n        if (inside(x1, y) || inside(x2, y))\\n            return true;                             \\n    }\\n    return false;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2422915,
                "title": "simple-python-3-solution-explained",
                "content": "```\\nclass Solution:\\n\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \"\"\"\\n        Given circle and a rectangle. Return if they intersect.\\n        \"\"\"\\n\\n        def get_closest(x1, x2, x):\\n            return min(max(x1, x), x2)\\n\\n        # Find the closest point of the rectangle.\\n        # It lies on the rectangle border, and because of circle symmetry it is the point closest to the circle center.\\n        x = get_closest(x1, x2, xCenter)\\n        y = get_closest(y1, y2, yCenter)\\n\\n        # Is the point within the radius?\\n        return radius ** 2 >= (x - xCenter) ** 2 + (y - yCenter) ** 2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \"\"\"\\n        Given circle and a rectangle. Return if they intersect.\\n        \"\"\"\\n\\n        def get_closest(x1, x2, x):\\n            return min(max(x1, x), x2)\\n\\n        # Find the closest point of the rectangle.\\n        # It lies on the rectangle border, and because of circle symmetry it is the point closest to the circle center.\\n        x = get_closest(x1, x2, xCenter)\\n        y = get_closest(y1, y2, yCenter)\\n\\n        # Is the point within the radius?\\n        return radius ** 2 >= (x - xCenter) ** 2 + (y - yCenter) ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203911,
                "title": "c-solution-by-geometry",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        \\n        if (xCenter >= x1 && xCenter <= x2){\\n            if (yCenter >= y1 - radius && yCenter <= y2 + radius){\\n                return true;\\n            }\\n        }\\n        if (yCenter >= y1 && yCenter <= y2){\\n            if (xCenter >= x1 - radius && xCenter <= x2 + radius){\\n                return true;\\n            }\\n        }\\n        int rr = radius * radius;\\n        int dx, dy;\\n        dx = xCenter - x1, dy = yCenter - y1;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        dx = xCenter - x1, dy = yCenter - y2;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        dx = xCenter - x2, dy = yCenter - y1;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        dx = xCenter - x2, dy = yCenter - y2;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        \\n        if (xCenter >= x1 && xCenter <= x2){\\n            if (yCenter >= y1 - radius && yCenter <= y2 + radius){\\n                return true;\\n            }\\n        }\\n        if (yCenter >= y1 && yCenter <= y2){\\n            if (xCenter >= x1 - radius && xCenter <= x2 + radius){\\n                return true;\\n            }\\n        }\\n        int rr = radius * radius;\\n        int dx, dy;\\n        dx = xCenter - x1, dy = yCenter - y1;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        dx = xCenter - x1, dy = yCenter - y2;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        dx = xCenter - x2, dy = yCenter - y1;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        dx = xCenter - x2, dy = yCenter - y2;\\n        if (dx * dx + dy * dy <= rr){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189246,
                "title": "python-shortest-distance-to-center-of-circle-o-1-o-1",
                "content": "1.  For a point `(x,  y)`, its distance to the center of the circle is the square root of  `(x - xCenter)**2 + (y - yCenter)**2 ` . \\n\\n2.  For points inside the rectangle, its x cordinate is in the range of `[x1, x2]`, y cordinate of range `[y1, y2]`. \\n3.  Find the point in rectangle with the smallest `abs(x - xCenter)` and `abs(y - yCenter)`. This is the point closest to the center of the circle inside the rectangle.  If **`(x - xCenter)**2 + (y - yCenter)**2  <= Radius**2 `** , point `(x, y)` is inside the circle.\\n\\n\\n\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        def find(a1, a2, aCenter):\\n            if a1 <= aCenter and aCenter <= a2:\\n                return 0 \\n            elif a1 > aCenter:\\n                return  a1 - aCenter\\n            else:\\n                return aCenter - a2\\n\\n        return (find(x1, x2, xCenter))**2 + (find(y1, y2, yCenter))**2 <= radius**2 \\n\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        def find(a1, a2, aCenter):\\n            if a1 <= aCenter and aCenter <= a2:\\n                return 0 \\n            elif a1 > aCenter:\\n                return  a1 - aCenter\\n            else:\\n                return aCenter - a2\\n\\n        return (find(x1, x2, xCenter))**2 + (find(y1, y2, yCenter))**2 <= radius**2 \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2097842,
                "title": "100-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        int x = max(x1, min(x2, xCenter));\\n        int y = max(y1, min(y2, yCenter));\\n        if(radius*radius >= (x-xCenter)*(x-xCenter) + (y-yCenter)*(y-yCenter))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        int x = max(x1, min(x2, xCenter));\\n        int y = max(y1, min(y2, yCenter));\\n        if(radius*radius >= (x-xCenter)*(x-xCenter) + (y-yCenter)*(y-yCenter))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891909,
                "title": "swift-100-faster-code",
                "content": "```\\nfunc <=(lhs: Double, rhs: Int) -> Bool {\\n    return lhs <= Double(rhs)\\n}\\n\\nclass Solution {\\n    func computeDistance(x1: Int, y1: Int, x2: Int, y2: Int) -> Double {\\n        return sqrt(pow(Double((x2 - x1)), 2) + pow(Double((y2 - y1)), 2))\\n    }\\n    \\n    func checkOverlap(_ radius: Int, _ xCenter: Int, _ yCenter: Int, _ x1: Int, _ y1: Int, _ x2: Int, _ y2: Int) -> Bool {\\n        let topLeftDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x1, y2: y2)\\n        let topRightDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x2, y2: y2)\\n        let bottomLeftDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x1, y2: y1)\\n        let bottomRightDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x2, y2: y1)\\n        if xCenter >= x1 - radius && xCenter <= x2 + radius && yCenter >= y1 && yCenter <= y2 ||\\n            xCenter >= x1 && xCenter <= x2 && yCenter >= y1 - radius && yCenter <= y2 + radius ||\\n            topLeftDistance <= radius ||\\n            topRightDistance <= radius ||\\n            bottomLeftDistance <= radius ||\\n            bottomRightDistance <= radius {\\n            return true\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc <=(lhs: Double, rhs: Int) -> Bool {\\n    return lhs <= Double(rhs)\\n}\\n\\nclass Solution {\\n    func computeDistance(x1: Int, y1: Int, x2: Int, y2: Int) -> Double {\\n        return sqrt(pow(Double((x2 - x1)), 2) + pow(Double((y2 - y1)), 2))\\n    }\\n    \\n    func checkOverlap(_ radius: Int, _ xCenter: Int, _ yCenter: Int, _ x1: Int, _ y1: Int, _ x2: Int, _ y2: Int) -> Bool {\\n        let topLeftDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x1, y2: y2)\\n        let topRightDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x2, y2: y2)\\n        let bottomLeftDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x1, y2: y1)\\n        let bottomRightDistance = computeDistance(x1: xCenter, y1: yCenter, x2: x2, y2: y1)\\n        if xCenter >= x1 - radius && xCenter <= x2 + radius && yCenter >= y1 && yCenter <= y2 ||\\n            xCenter >= x1 && xCenter <= x2 && yCenter >= y1 - radius && yCenter <= y2 + radius ||\\n            topLeftDistance <= radius ||\\n            topRightDistance <= radius ||\\n            bottomLeftDistance <= radius ||\\n            bottomRightDistance <= radius {\\n            return true\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515803,
                "title": "c-0ms-100-math-commented",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Circle and Rectangle Overlapping.\\nMemory Usage: 5.9 MB, less than 21.99% of C++ online submissions for Circle and Rectangle Overlapping.\\n```\\nclass Solution {\\npublic:\\n  int r;\\n  bool is_crossed(int A, int B, int C){\\n    A *= A;\\n    return A > r ? false : B*B + A <= r || C*C + A <= r || B*C <= 0;      //is crossed ?   not  : (yes) point into circle or point into circle or points locate into left and right ?\\n  } \\n  \\n  bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n    r = radius*radius;\\n    x1 -= x_center, x2 -= x_center, y1 -= y_center, y2 -= y_center;                              //replace center of coordinates in center of circle\\n    return is_crossed(x1, y1, y2) || is_crossed(x2,y1,y2) || is_crossed(y1,x1,x2) || is_crossed(y2,x1,x2) || (x1*x2 < 0 && y1*y2 < 0);          //if side of rectangle is crossed the circle or rectangle include the circle\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int r;\\n  bool is_crossed(int A, int B, int C){\\n    A *= A;\\n    return A > r ? false : B*B + A <= r || C*C + A <= r || B*C <= 0;      //is crossed ?   not  : (yes) point into circle or point into circle or points locate into left and right ?\\n  } \\n  \\n  bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n    r = radius*radius;\\n    x1 -= x_center, x2 -= x_center, y1 -= y_center, y2 -= y_center;                              //replace center of coordinates in center of circle\\n    return is_crossed(x1, y1, y2) || is_crossed(x2,y1,y2) || is_crossed(y1,x1,x2) || is_crossed(y2,x1,x2) || (x1*x2 < 0 && y1*y2 < 0);          //if side of rectangle is crossed the circle or rectangle include the circle\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166572,
                "title": "simple-java-solution",
                "content": "Here is the simple java solution with 0ms 100% fast\\n\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int xn = Math.max(x1,Math.min(x2,x_center));\\n        int yn = Math.max(y1,Math.min(y2,y_center));\\n        \\n        return Math.sqrt((xn-x_center)*(xn-x_center)+(yn-y_center)*(yn-y_center)) <= radius;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int xn = Math.max(x1,Math.min(x2,x_center));\\n        int yn = Math.max(y1,Math.min(y2,y_center));\\n        \\n        return Math.sqrt((xn-x_center)*(xn-x_center)+(yn-y_center)*(yn-y_center)) <= radius;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1133076,
                "title": "python3-geometry",
                "content": "\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        if x1 <= x_center <= x2 and y1 <= y_center <= y2: return True # circle inside rectangle\\n        \\n        for x, y in (x1, y1), (x1, y2), (x2, y1), (x2, y2): \\n            if (x - x_center)**2 + (y - y_center)**2 <= radius**2: return True \\n        \\n        # check edge \\n        for x in [x1, x2]: \\n            if x_center - radius <= x <= x_center + radius and y1 <= y_center <= y2: return True\\n            \\n        for y in [y1, y2]:\\n            if y_center - radius <= y <= y_center + radius and x1 <= x_center <= x2: return True \\n        \\n        return False \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        if x1 <= x_center <= x2 and y1 <= y_center <= y2: return True # circle inside rectangle\\n        \\n        for x, y in (x1, y1), (x1, y2), (x2, y1), (x2, y2): \\n            if (x - x_center)**2 + (y - y_center)**2 <= radius**2: return True \\n        \\n        # check edge \\n        for x in [x1, x2]: \\n            if x_center - radius <= x <= x_center + radius and y1 <= y_center <= y2: return True\\n            \\n        for y in [y1, y2]:\\n            if y_center - radius <= y <= y_center + radius and x1 <= x_center <= x2: return True \\n        \\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104674,
                "title": "golang-solution-faster-than-100-with-explanation-and-images",
                "content": "**The Main Idea**\\n\\nThe idea of this solution is to find the distance from the middle of the circle to the edge of a rectangle, and if the distance is smaller than or equal to the radius, we know that the rectangle overlaps with the circle.\\n\\nIf you don\\'t understand, look at the following images:\\n\\n![image](https://assets.leetcode.com/users/images/776c78ba-f825-4c67-bafa-8243f5b8f5d0_1615564816.8738723.jpeg)\\n\\n\\n\\n> As you can see, the circle and the rectangle do not overlap, and this can be shown by the distance between the center of the circle and the closest edge of the rectangle. The length is `\\u221A8 = 2.82842712474619`, `2.82842712474619` is greater than the radius of `1`, so we know that the circle and the rectangle don\\'t overlap.\\n\\n![](https://i.imgur.com/W6g3aVq.jpg)\\n\\n> In the image above, we can see that the circle and the edge of the rectangle overlaps. And we can see that the distance between the closest edge of the square and the center of the circle is equal to the radius, so we can see that the rectangle and the rectangle overlap.\\n\\n![](https://i.imgur.com/h8vdUkm.jpg)\\n\\n> In the image above, we can see that the circle and the rectangle overlap. The distance between the center of the circle and the closest point on the rectangle is `\\u221A5 = 2.23606797749979` and `2.23606797749979 < radius` because `radius = 3`. Since the distance is smaller than the `radius`, we can say that the two shapes overlap.\\n\\n**How It Works:**\\n\\nNow that we have covered the main idea of this function, we can get into the details.\\n\\n**The first part is:**\\n\\n```\\nif x_center < x2 && x_center > x1 && y_center < y2 && y_center > y1 {\\n    return true\\n}\\n```\\n\\nThe part above is for if the circle inside the square. Such as like:\\n\\n![](https://i.imgur.com/ChoNOLK.jpg)\\n\\n\\nAs you can see, the circle radius is smaller than the distance of the closest edge and the center of the circle. We know that the circle and the rectangle overlap, but the computer thinks that they don\\'t overlap because the `distance from the center of the circle to the edge of the rectangle > radius`, so we have to make sure that this is counted as an overlap. We check whether this is overlap by checking whether the center of the circle is between the two x\\'s and between the two y\\'s.\\n\\n**The next part:**\\n\\n```\\nif ((y1 <= y_center+radius && y1 >= y_center) ||\\n    (y2 >= y_center-radius && y2 <= y_center)) && x_center >= x1 &&\\n    x_center <= x2 {\\n    \\n    return true\\n}\\n```\\n\\nThis can be used for something like the example below:\\n\\n![](https://i.imgur.com/5T1fXOG.jpg)\\n\\nThe main idea of:\\n\\n`((y1 <= y_center+radius && y1 >= y_center) || (y2 >= y_center-radius && y2 <= y_center)) && x_center >= x1 && x_center <= x2` \\n\\nis: \\n\\n`(y1 <= y_center + radius || y2 >= y_center - radius) && x_center >= x1 && x_center <= x2`\\n\\nThen after that, we can start to understand the additional parts.\\n\\nFirst, `y1 <= y_center + radius` is for if the circle is beneath the rectangle, just like the image below.\\n\\n![](https://i.imgur.com/8YwF90u.jpg)\\n\\n`y1 <= y_center + radius` in this example is `6 <= 5 + 2` which equals `6 <= 7`. So for this example the `y`\\'s\\' overlap.\\n\\n`y2 >= y_center - radius` is for when the circle is on top of the rectangle like in the picture below:\\n\\n![](https://i.imgur.com/NjPtHcc.jpg)\\n\\n`y2 >= y_center - radius` in this example is `4 >= 6 - 2` which is `4 = 4`. As we can see the `y`\\'s\\' overlap. \\n\\nThe next part, `x_center >= x1 && x_center <= x2` is for checking whether the center of the circle is inside the `x`\\'s values of the rectangle, so we can use the example above again. \\n\\nAs we said before the `y` parts of the shapes overlap. And now we can see that `x_center = 8`. `8 > 5`, `x1 = 5`, and `8 < 10`, and `x2 = 8`.\\n\\nWe can see an example where the `y` parts overlap, but the `x`\\'s parts don\\'t.\\n\\n![](https://i.imgur.com/vTe00bX.jpg)\\n\\nThe `y` parts work, `y2 >= y_center - radius`, which equals `4 >= 5 - 2` and when simplifyed `4 >= 3`. But the `x` parts don\\'t work because the equations are `x_center >= x1` and `x_center <= x2`, and when we put in our numbers we get `13 >= 5` but when we put in the numbers into the second equation, `13 > 10` while we want `x_center <= x2`. So we know that the shapes don\\'t overlap.\\n\\nIt also checks whether `y1 >= y_center` and `y2 <= y_center` because we want to make sure that we don\\'t `return true` for extra test cases.\\n\\n**The Next Part:**\\n\\n```\\nif y_center <= y2 && y_center >= y1 && ((x_center-radius <= x2 && \\n    x_center >= x2) || (x_center+radius >= x1 && x_center <= x1)) {\\n    \\n    return true\\n}\\n```\\n\\nWe use this part if the part before fails. This checks whether the circle is on either side of the rectangle.\\n\\nThis checks whether the `y_center` is greater than or equal to `y1` and if it is smaller than or equal to `y2`. Then it checks whether the `x_center - radius` is smaller than or equal to `x2`, or `x_center - radius >= x1`. It also checks whether `x_center >= x2` and `x_center <= x1`, just like the previous part.\\n\\nWe can explain this with the following images:\\n\\n![](https://i.imgur.com/PyTQ1SK.jpg)\\n\\nThis circle is on the right of the rectangle.\\n\\nWe can see that the `y_center = 4` and `4 < 7`, `y2 = 7`, and `4 > 1`, `y1 = 1`. We can see that `((x_center-radius <= x2 && x_center >= x2) || (x_center+radius >= x1 && x_center <= x1))` is true because `x_center-radius <= x2 && x_center >= x2`, since `x_center = 4`, and that `radius = 2`. `4 - 2 <= 3` and `4 > 3` so we return true.\\n\\nThe next image is on the left of the image:\\n\\n![](https://i.imgur.com/6VIXcKh.jpg)\\n\\nThe `y` part is the same as the last image, so we know that the `y` part overlaps. So we can see that the `y` part overlaps. We can use the formula `x_center + radius >= x1 && x_center <= x1`. `x_center = 3` and the `radius  = 2`. So when we input the numbers into the variables, `3 + 2 >= 4` when simplifyed `5 >= 4`, `x1 = 4`. The next equation is `3 <= 4`. \\n\\nAs we can see `x_center+radius >= x1 && x_center <= x1` is for if the circle is on the right of the rectangle. And `x_center-radius <= x2 && x_center >= x2` is for if the circle is on the left of the rectangle.\\n\\n\\n**The last part:**\\n\\n```\\nif powerOfTwo(x_center-x1)+powerOfTwo(y_center-y1) <= \\n    powerOfTwo(radius) {\\n    \\n    return true\\n}\\n```\\n\\nThe idea of `powerOfTwo(x_center-x1)+powerOfTwo(y_center-y1) <= powerOfTwo(radius)` is basicly pythagoras theorem, `a^2 + b^2 = c^2`. `a^2 + b^2 = c^2`, and this is basicly `(x_center - x1)^2 + (y_center - y1)^2 = radius^2`. \\n\\nThe distance formula is `d = sqrt((x1 - x2)^2 + (y1 - y2)^2)`, though for this problem we don\\'t need the `sqrt` so we the equation can be `d = (x1 - x2)^2 + (y1 - y2)^2)`, so we can continue to use `(x_center - x1)^2 + (y_center - y1)^2 = radius^2`. \\n\\nAll of the following are similar except for different points, `x1, x2, y1, y2, x_center, y_center`.\\n\\n```\\npowerOfTwo(x_center-x1)+powerOfTwo(y_center-y2) <= powerOfTwo(radius)\\n\\npowerOfTwo(x_center-x2)+powerOfTwo(y_center-y1) <= powerOfTwo(radius)\\n\\npowerOfTwo(x_center-x2)+powerOfTwo(y_center-y2) <= powerOfTwo(radius)\\n```\\n\\n## The Code:\\n\\n``` go\\nfunc checkOverlap(radius int, x_center int, y_center int, x1 int, y1 int, x2 int, y2 int) bool {\\n\\n    if x_center < x2 && x_center > x1 && y_center < y2 && y_center > y1 {\\n        // Checking whether the circle is in the middle of the square\\n        return true\\n    }\\n\\n    if ((y1 <= y_center+radius && y1 >= y_center) ||\\n    (y2 >= y_center-radius && y2 <= y_center)) &&\\n        x_center >= x1 && x_center <= x2 {\\n        return true\\n    }\\n\\n    if y_center <= y2 && y_center >= y1 && ((x_center-radius <= x2 && \\n    x_center >= x2) || (x_center+radius >= x1 && x_center <= x1)) {\\n        return true\\n    }\\n\\n    if powerOfTwo(x_center-x1)+powerOfTwo(y_center-y1) <= \\n            powerOfTwo(radius) ||\\n        powerOfTwo(x_center-x1)+powerOfTwo(y_center-y2) <= \\n            powerOfTwo(radius) ||\\n        powerOfTwo(x_center-x2)+powerOfTwo(y_center-y1) <= \\n            powerOfTwo(radius) ||\\n        powerOfTwo(x_center-x2)+powerOfTwo(y_center-y2) <= \\n            powerOfTwo(radius) {\\n        return true\\n    }\\n\\n    return false\\n}\\n\\nfunc powerOfTwo(n int) int {\\n    return n * n\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nif x_center < x2 && x_center > x1 && y_center < y2 && y_center > y1 {\\n    return true\\n}\\n```\n```\\nif ((y1 <= y_center+radius && y1 >= y_center) ||\\n    (y2 >= y_center-radius && y2 <= y_center)) && x_center >= x1 &&\\n    x_center <= x2 {\\n    \\n    return true\\n}\\n```\n```\\nif y_center <= y2 && y_center >= y1 && ((x_center-radius <= x2 && \\n    x_center >= x2) || (x_center+radius >= x1 && x_center <= x1)) {\\n    \\n    return true\\n}\\n```\n```\\nif powerOfTwo(x_center-x1)+powerOfTwo(y_center-y1) <= \\n    powerOfTwo(radius) {\\n    \\n    return true\\n}\\n```\n```\\npowerOfTwo(x_center-x1)+powerOfTwo(y_center-y2) <= powerOfTwo(radius)\\n\\npowerOfTwo(x_center-x2)+powerOfTwo(y_center-y1) <= powerOfTwo(radius)\\n\\npowerOfTwo(x_center-x2)+powerOfTwo(y_center-y2) <= powerOfTwo(radius)\\n```\n``` go\\nfunc checkOverlap(radius int, x_center int, y_center int, x1 int, y1 int, x2 int, y2 int) bool {\\n\\n    if x_center < x2 && x_center > x1 && y_center < y2 && y_center > y1 {\\n        // Checking whether the circle is in the middle of the square\\n        return true\\n    }\\n\\n    if ((y1 <= y_center+radius && y1 >= y_center) ||\\n    (y2 >= y_center-radius && y2 <= y_center)) &&\\n        x_center >= x1 && x_center <= x2 {\\n        return true\\n    }\\n\\n    if y_center <= y2 && y_center >= y1 && ((x_center-radius <= x2 && \\n    x_center >= x2) || (x_center+radius >= x1 && x_center <= x1)) {\\n        return true\\n    }\\n\\n    if powerOfTwo(x_center-x1)+powerOfTwo(y_center-y1) <= \\n            powerOfTwo(radius) ||\\n        powerOfTwo(x_center-x1)+powerOfTwo(y_center-y2) <= \\n            powerOfTwo(radius) ||\\n        powerOfTwo(x_center-x2)+powerOfTwo(y_center-y1) <= \\n            powerOfTwo(radius) ||\\n        powerOfTwo(x_center-x2)+powerOfTwo(y_center-y2) <= \\n            powerOfTwo(radius) {\\n        return true\\n    }\\n\\n    return false\\n}\\n\\nfunc powerOfTwo(n int) int {\\n    return n * n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1085109,
                "title": "c-faster-than-100-implemented-complementary-algorithm",
                "content": "Instead of finding if they touch,find if the circle is outside the rectangle.\\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        int a = sqrt(pow(abs(x1 - xc), 2) + pow(abs(y1 - yc), 2));\\n        int b = sqrt(pow(abs(x2 - xc), 2) + pow(abs(y2 - yc), 2));\\n        int c = sqrt(pow(abs(x2 - xc), 2) + pow(abs(y1 - yc), 2));\\n        int d = sqrt(pow(abs(x1 - xc), 2) + pow(abs(y2 - yc), 2));\\n        \\n        if(yc-radius > y2)return false;\\n        if(yc+radius < y1)return false;\\n        if(xc+radius < x1)return false;\\n        if(xc-radius > x2)return false;\\n        \\n        int r= radius;\\n        if(a<r || b<r || c<r || d<r)return true;\\n        \\n        if(xc>x2 && yc<y1)return false;\\n        if(xc>x2 && yc>y2)return false;\\n        if(xc<x1 && yc>y2)return false;\\n        if(xc<x1 && yc<y1)return false;\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        int a = sqrt(pow(abs(x1 - xc), 2) + pow(abs(y1 - yc), 2));\\n        int b = sqrt(pow(abs(x2 - xc), 2) + pow(abs(y2 - yc), 2));\\n        int c = sqrt(pow(abs(x2 - xc), 2) + pow(abs(y1 - yc), 2));\\n        int d = sqrt(pow(abs(x1 - xc), 2) + pow(abs(y2 - yc), 2));\\n        \\n        if(yc-radius > y2)return false;\\n        if(yc+radius < y1)return false;\\n        if(xc+radius < x1)return false;\\n        if(xc-radius > x2)return false;\\n        \\n        int r= radius;\\n        if(a<r || b<r || c<r || d<r)return true;\\n        \\n        if(xc>x2 && yc<y1)return false;\\n        if(xc>x2 && yc>y2)return false;\\n        if(xc<x1 && yc>y2)return false;\\n        if(xc<x1 && yc<y1)return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948424,
                "title": "c-0ms-concise",
                "content": "**Solution Observations**\\nFirst I tried Brute Force solution I got TLE, then I realized that we don\\'t have to check every coordinate one by one, instead we can increase x and y coordinates by radius. \\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        // Check four corners of rectangle\\n        int a = sqrt(pow(abs(x1 - x_center), 2) + pow(abs(y1 - y_center), 2));\\n        int b = sqrt(pow(abs(x2 - x_center), 2) + pow(abs(y2 - y_center), 2));\\n        int c = sqrt(pow(abs(x2 - x_center), 2) + pow(abs(y1 - y_center), 2));\\n        int d = sqrt(pow(abs(x1 - x_center), 2) + pow(abs(y2 - y_center), 2));\\n        if (a <= radius || b <= radius || c <= radius || d <= radius) {\\n            return true;\\n        }\\n        for (int x = x1; x <= x2; x += radius) {\\n            for (int y = y1; y <= y2; y += radius) {\\n                int distToCircleCenter = sqrt(pow(abs(x - x_center), 2) + pow(abs(y - y_center), 2));\\n                if (distToCircleCenter <= radius) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        // Check four corners of rectangle\\n        int a = sqrt(pow(abs(x1 - x_center), 2) + pow(abs(y1 - y_center), 2));\\n        int b = sqrt(pow(abs(x2 - x_center), 2) + pow(abs(y2 - y_center), 2));\\n        int c = sqrt(pow(abs(x2 - x_center), 2) + pow(abs(y1 - y_center), 2));\\n        int d = sqrt(pow(abs(x1 - x_center), 2) + pow(abs(y2 - y_center), 2));\\n        if (a <= radius || b <= radius || c <= radius || d <= radius) {\\n            return true;\\n        }\\n        for (int x = x1; x <= x2; x += radius) {\\n            for (int y = y1; y <= y2; y += radius) {\\n                int distToCircleCenter = sqrt(pow(abs(x - x_center), 2) + pow(abs(y - y_center), 2));\\n                if (distToCircleCenter <= radius) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865672,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n        int i, j;\\n        for(i=y1; i<=y2; i++){\\n            for(j=x1; j<=x2; j++){\\n                if((i-y_center)*(i-y_center)+(j-x_center)*(j-x_center)<=radius*radius)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n        int i, j;\\n        for(i=y1; i<=y2; i++){\\n            for(j=x1; j<=x2; j++){\\n                if((i-y_center)*(i-y_center)+(j-x_center)*(j-x_center)<=radius*radius)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861060,
                "title": "python-math-solution-o-1",
                "content": "For a circle with radius ``r`` and center ``a, b``, for internal points ``x, y`` we have: ``(x-a)^2 +(y-b)^2<=r`` eq.(1)\\nFor ``x, y`` inside the rectangle we have``x1<=x<=x2 and y1<=y<=y2`` thus ``x1-a<=x-a<=x2-a and y1-a<=y-a<=y2-a`` eq. (2)\\nTherefore we only need to find ``min(x-a)^2 + min(y-b)^2 or min[abs(x-a) +abs(y-b)]`` which satisfies eq.(2) and to see if it also satisfies eq.(1) \\nThus define a function to see wether the stright line for ``x and y`` pass through ``0`` to find the minimal value of ``abs(x-a) and abs(y-b)``\\n\\n    def min_abs(self, a: int, b:int):\\n        if a<0 and b>0: return 0\\n        elif a>=0: return a*a\\n        else: return b*b\\n    def checkOverlap(self, r: int, a: int, b: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return self.min_abs(x1-a, x2-a) + self.min_abs(y1-b, y2-b) <= r*r",
                "solutionTags": [],
                "code": "For a circle with radius ``r`` and center ``a, b``, for internal points ``x, y`` we have: ``(x-a)^2 +(y-b)^2<=r`` eq.(1)\\nFor ``x, y`` inside the rectangle we have``x1<=x<=x2 and y1<=y<=y2`` thus ``x1-a<=x-a<=x2-a and y1-a<=y-a<=y2-a`` eq. (2)\\nTherefore we only need to find ``min(x-a)^2 + min(y-b)^2 or min[abs(x-a) +abs(y-b)]`` which satisfies eq.(2) and to see if it also satisfies eq.(1) \\nThus define a function to see wether the stright line for ``x and y`` pass through ``0`` to find the minimal value of ``abs(x-a) and abs(y-b)``\\n\\n    def min_abs(self, a: int, b:int):\\n        if a<0 and b>0: return 0\\n        elif a>=0: return a*a\\n        else: return b*b\\n    def checkOverlap(self, r: int, a: int, b: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return self.min_abs(x1-a, x2-a) + self.min_abs(y1-b, y2-b) <= r*r",
                "codeTag": "Python3"
            },
            {
                "id": 690220,
                "title": "simple-c-code",
                "content": "```\\n#define min(x,y)((x)<(y)?(x):(y))\\n\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n    int x=min(min((y_center-y1),0),(y2-y_center));\\n    int y=min(min((x_center-x1),0),(x2-x_center));\\n    return (x*x)+(y*y)<=(radius*radius);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#define min(x,y)((x)<(y)?(x):(y))\\n\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n    int x=min(min((y_center-y1),0),(y2-y_center));\\n    int y=min(min((x_center-x1),0),(x2-x_center));\\n    return (x*x)+(y*y)<=(radius*radius);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 688643,
                "title": "c-constant-time-space-math",
                "content": "```\\n// this program checks if circle and rectangle over lap ( share at least 1 point in an X Y system)\\n//x_center , y_center - circle cords, x1,y1 - left most lowest most point rectangle points\\n// x2,y2 - right most highest cords of the rectangle\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n// first we check if center of the cirlce is inside the rectangle if so we return true(clearly they share points)\\n    if((x_center>= x1 && x_center<=x2) && (y_center>=y1 && y_center<=y2) ) return true;\\n    // there are cases where the center of the cirlce is not inside the rectangle and \\n\\t//still share points\\n    // we need to check these cases and return the right answer!\\n    \\n    // center of circle is left from rectangle but in rectangle Y axis range of(y1,y2)\\n    else if(x_center<x1 && (y_center>=y1 && y_center<=y2)) { \\n        if((x_center+radius)>=x1) return true;\\n    }\\n    // center of circle is right from rectangle but in rectangle Y axis range of(y1,y2)\\n    else if(x_center >x2 && (y_center>=y1 && y_center<=y2)) { \\n        if((x_center-radius)<=x2) return true;\\n    }\\n    // center of circle is below lowest points in rectangle but in between X1 and X2 AIXS\\n    else if(y_center < y1 && (x_center>=x1 && x_center<=x2)) {\\n        if((y_center+radius) >= y1) return true;\\n    }\\n    // center of circle is above highest points in rectangle but in between X1 and X2 AIXS\\n    else if(y_center > y2 && (x_center >= x1 && x_center<=x2)) {\\n        if((y_center-radius)<=y2) return true;\\n    }\\n    // center of circle is below and right side of the rectangle\\n    // we check if the radius can reach the right most and low most point of the rectangle if so \\n\\t//then they share at least 1 point if its equal to radius and if the radius is even bigger it \\n\\t//may have many points\\n    else if(x_center>x2 && (y_center<y1)) {\\n        double Pythagorean = pow(x_center-x2,2) + pow(y1-y_center,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    // Center of circle is above  the right most and top most cord of the rectangle ( x2,y2) and also right of \\n\\t//the rectangle\\n    // we check if the radius can reach the right most and top most cord of the rectangle(x2,y2) if so\\n\\t//they share at least 1 point if not more(if the radius is even bigger)\\n    else if(x_center>x2 && (y_center>y2)) {\\n        double Pythagorean = pow(x_center-x2,2) + pow(y_center-y2,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    // center of circle is above and also to th eleft of the top most left most cord \\n\\t//in the rectangle we need to check if its radius can reach that point or \\n\\t//if the radius is even bigger in that case it may share more than 1 point with the rectangle\\n    else if(x_center<x1 && (y_center > y2)) {\\n        double Pythagorean = pow(x_center-x1,2) + pow(y_center-y2,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    // center of circle is below and left to the lowest and left most point of the rectangle (x1,y1)\\n    // we need to check if its radius can reach that point or if the radius can reach even more in \\n\\t//that case it  will share more than one point\\n    else if(x_center<x1 && y_center<y1) {\\n        double Pythagorean = pow(x1-x_center,2) + pow(y1-y_center,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    return false;\\n}\\n```\\n![image](https://assets.leetcode.com/users/yarin1/image_1592227941.png)\\n",
                "solutionTags": [],
                "code": "```\\n// this program checks if circle and rectangle over lap ( share at least 1 point in an X Y system)\\n//x_center , y_center - circle cords, x1,y1 - left most lowest most point rectangle points\\n// x2,y2 - right most highest cords of the rectangle\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2){\\n// first we check if center of the cirlce is inside the rectangle if so we return true(clearly they share points)\\n    if((x_center>= x1 && x_center<=x2) && (y_center>=y1 && y_center<=y2) ) return true;\\n    // there are cases where the center of the cirlce is not inside the rectangle and \\n\\t//still share points\\n    // we need to check these cases and return the right answer!\\n    \\n    // center of circle is left from rectangle but in rectangle Y axis range of(y1,y2)\\n    else if(x_center<x1 && (y_center>=y1 && y_center<=y2)) { \\n        if((x_center+radius)>=x1) return true;\\n    }\\n    // center of circle is right from rectangle but in rectangle Y axis range of(y1,y2)\\n    else if(x_center >x2 && (y_center>=y1 && y_center<=y2)) { \\n        if((x_center-radius)<=x2) return true;\\n    }\\n    // center of circle is below lowest points in rectangle but in between X1 and X2 AIXS\\n    else if(y_center < y1 && (x_center>=x1 && x_center<=x2)) {\\n        if((y_center+radius) >= y1) return true;\\n    }\\n    // center of circle is above highest points in rectangle but in between X1 and X2 AIXS\\n    else if(y_center > y2 && (x_center >= x1 && x_center<=x2)) {\\n        if((y_center-radius)<=y2) return true;\\n    }\\n    // center of circle is below and right side of the rectangle\\n    // we check if the radius can reach the right most and low most point of the rectangle if so \\n\\t//then they share at least 1 point if its equal to radius and if the radius is even bigger it \\n\\t//may have many points\\n    else if(x_center>x2 && (y_center<y1)) {\\n        double Pythagorean = pow(x_center-x2,2) + pow(y1-y_center,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    // Center of circle is above  the right most and top most cord of the rectangle ( x2,y2) and also right of \\n\\t//the rectangle\\n    // we check if the radius can reach the right most and top most cord of the rectangle(x2,y2) if so\\n\\t//they share at least 1 point if not more(if the radius is even bigger)\\n    else if(x_center>x2 && (y_center>y2)) {\\n        double Pythagorean = pow(x_center-x2,2) + pow(y_center-y2,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    // center of circle is above and also to th eleft of the top most left most cord \\n\\t//in the rectangle we need to check if its radius can reach that point or \\n\\t//if the radius is even bigger in that case it may share more than 1 point with the rectangle\\n    else if(x_center<x1 && (y_center > y2)) {\\n        double Pythagorean = pow(x_center-x1,2) + pow(y_center-y2,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    // center of circle is below and left to the lowest and left most point of the rectangle (x1,y1)\\n    // we need to check if its radius can reach that point or if the radius can reach even more in \\n\\t//that case it  will share more than one point\\n    else if(x_center<x1 && y_center<y1) {\\n        double Pythagorean = pow(x1-x_center,2) + pow(y1-y_center,2);\\n        Pythagorean = sqrt(Pythagorean);\\n        printf(\"%lf %d\",Pythagorean,radius);\\n        if(Pythagorean<=radius) return true; \\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 679145,
                "title": "java-concise-and-straightforward",
                "content": "false iff:\\n1, circle center prejectino to axis garranttee to far wary from rectrangle; (see example 1);\\nor\\n2, distance btw circle center and either of the 4 corner of rectangle is smaller than radius;\\n\\n```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        if (xc + r < x1 || xc - r > x2 || yc + r < y1 || yc - r > y2) return false;  \\n        if (xc < x1 && yc < y1 && longer(xc, yc, x1, y1, r)) return false;\\n        if (xc < x1 && yc > y2 && longer(xc, yc, x1, y2, r)) return false;\\n        if (xc > x2 && yc < y1 && longer(xc, yc, x2, y1, r)) return false;\\n        if (xc > x2 && yc > y2 && longer(xc, yc, x2, y2, r)) return false;\\n        return true;\\n    }\\n    \\n    private boolean longer(int xc, int yc, int x, int y, int r) {\\n        return (xc - x) * (xc - x) + (yc - y) * (yc - y) > r * r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        if (xc + r < x1 || xc - r > x2 || yc + r < y1 || yc - r > y2) return false;  \\n        if (xc < x1 && yc < y1 && longer(xc, yc, x1, y1, r)) return false;\\n        if (xc < x1 && yc > y2 && longer(xc, yc, x1, y2, r)) return false;\\n        if (xc > x2 && yc < y1 && longer(xc, yc, x2, y1, r)) return false;\\n        if (xc > x2 && yc > y2 && longer(xc, yc, x2, y2, r)) return false;\\n        return true;\\n    }\\n    \\n    private boolean longer(int xc, int yc, int x, int y, int r) {\\n        return (xc - x) * (xc - x) + (yc - y) * (yc - y) > r * r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653132,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int lenX = (x1 > x_center) ? x1 : (x2 < x_center) ? x2 : x_center; \\n        int lenY = (y1 > y_center) ? y1 : (y2 < y_center) ? y2 : y_center; \\n        int diffX = x_center - lenX;\\n        int diffY = y_center - lenY;\\n        return diffX * diffX + diffY * diffY <= radius * radius; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int lenX = (x1 > x_center) ? x1 : (x2 < x_center) ? x2 : x_center; \\n        int lenY = (y1 > y_center) ? y1 : (y2 < y_center) ? y2 : y_center; \\n        int diffX = x_center - lenX;\\n        int diffY = y_center - lenY;\\n        return diffX * diffX + diffY * diffY <= radius * radius; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582138,
                "title": "python-use-a-virtual-square-bounding-the-circle",
                "content": "![image](https://assets.leetcode.com/users/xuawai/image_1587026760.png)\\n\\n1. Assume there is a square of size `(2*radius) * (2*radius)` bounding the circle exactly. Note that `the square area - the circle area = the area of 4 corners in crescent`.\\n2. Check whether the square and the rectangle are overlapped. If not, return False. \\n3. Now the rectangle is overlapped with the square. It does not mean the rectangle is overlapped with the circle, because the rectangle may be overlapped with the 4 corners.\\n4. Check whether the 4 corners and the rectangle are overlapped. If so, return False.\\n5. Now we are sure that the rectangle is overlapped with the square, while not overlapped with the 4 corners. Return True.\\n\\nPython Version:\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:  \\n        # check whether the square and the rectangle are overlapped. If not, return False.  \\n        r_min = min(x_center + radius, x2)\\n        l_max = max(x_center - radius, x1)\\n        t_min = min(y_center + radius, y2)\\n        b_max = max(y_center - radius, y1)\\n        if not (r_min >= l_max and t_min >= b_max):\\n            return False\\n        # Check whether the 4 corners and the rectangle are overlapped.\\n        def d(x, y):\\n            return (x - x_center) ** 2 + (y - y_center) ** 2\\n        r = radius ** 2\\n        # bottom-right corner\\n        if y_center > y2 and x_center < x1 and d(x1, y2) > r:\\n            return False\\n        # top-right corner\\n        if y_center < y1 and x_center < x1 and d(x1, y1) > r:\\n            return False\\n        # top-left corner\\n        if y_center < y1 and x_center > x2 and d(x2, y1) > r:\\n            return False\\n        # bottm-left corner\\n        if y_center > y2 and x_center > x2 and d(x2, y2) > r:\\n            return False\\n        # Now we are sure that the rectangle is overlapped with the square, while not overlapped with the 4 corners.\\n        return True",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/xuawai/image_1587026760.png)\\n\\n1. Assume there is a square of size `(2*radius) * (2*radius)` bounding the circle exactly. Note that `the square area - the circle area = the area of 4 corners in crescent`.\\n2. Check whether the square and the rectangle are overlapped. If not, return False. \\n3. Now the rectangle is overlapped with the square. It does not mean the rectangle is overlapped with the circle, because the rectangle may be overlapped with the 4 corners.\\n4. Check whether the 4 corners and the rectangle are overlapped. If so, return False.\\n5. Now we are sure that the rectangle is overlapped with the square, while not overlapped with the 4 corners. Return True.\\n\\nPython Version:\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:  \\n        # check whether the square and the rectangle are overlapped. If not, return False.  \\n        r_min = min(x_center + radius, x2)\\n        l_max = max(x_center - radius, x1)\\n        t_min = min(y_center + radius, y2)\\n        b_max = max(y_center - radius, y1)\\n        if not (r_min >= l_max and t_min >= b_max):\\n            return False\\n        # Check whether the 4 corners and the rectangle are overlapped.\\n        def d(x, y):\\n            return (x - x_center) ** 2 + (y - y_center) ** 2\\n        r = radius ** 2\\n        # bottom-right corner\\n        if y_center > y2 and x_center < x1 and d(x1, y2) > r:\\n            return False\\n        # top-right corner\\n        if y_center < y1 and x_center < x1 and d(x1, y1) > r:\\n            return False\\n        # top-left corner\\n        if y_center < y1 and x_center > x2 and d(x2, y1) > r:\\n            return False\\n        # bottm-left corner\\n        if y_center > y2 and x_center > x2 and d(x2, y2) > r:\\n            return False\\n        # Now we are sure that the rectangle is overlapped with the square, while not overlapped with the 4 corners.\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 580784,
                "title": "java-100-100-0ms-4-lines",
                "content": "\\tcircle = (x - x_center) * (x - x_center) + (y - y_center) * (y - y_center) <= radius * radius\\n\\tx1 <= x && x <= x2 && y1 <= y && y <= y2\\n    \\n\\txo = x - x_center\\n\\tyo = y - y_center\\n\\tx1 - x_center <= xo <= x2 - x_center \\n\\ty1 - y_center <= yo <= y2 - y_center\\n\\txo^2 + yo^2 <= raidus^2\\n\\t\\n```java\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int xp = 0, yp = 0;\\n        if((x1 - x_center) * (x2 - x_center) > 0) xp = Math.min(Math.abs(x1 - x_center), Math.abs(x2 - x_center));\\n        if((y1 - y_center) * (y2 - y_center) > 0) yp = Math.min(Math.abs(y1 - y_center), Math.abs(y2 - y_center));\\n        return xp * xp + yp * yp <= radius * radius;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int xp = 0, yp = 0;\\n        if((x1 - x_center) * (x2 - x_center) > 0) xp = Math.min(Math.abs(x1 - x_center), Math.abs(x2 - x_center));\\n        if((y1 - y_center) * (y2 - y_center) > 0) yp = Math.min(Math.abs(y1 - y_center), Math.abs(y2 - y_center));\\n        return xp * xp + yp * yp <= radius * radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570622,
                "title": "c-easy-solution",
                "content": "We check if any point (inside/on) the rectangle lies (inside/on) the circle\\nTo check if a point lies (inside/on) the circle   (x-x_center)^2+(y-y_center)^2<=(radius)^2\\n\\ncode:\\n```\\n        for(int i=x1;i<=x2;i++)\\n        {\\n            for(int j=y2;j>=y1;j--)\\n            {\\n                if(pow(i-x_center,2)+pow(j-y_center,2)<=pow(radius,2))\\n                {\\n                    return true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n```",
                "solutionTags": [],
                "code": "```\\n        for(int i=x1;i<=x2;i++)\\n        {\\n            for(int j=y2;j>=y1;j--)\\n            {\\n                if(pow(i-x_center,2)+pow(j-y_center,2)<=pow(radius,2))\\n                {\\n                    return true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 565752,
                "title": "overcomplicated-solution-using-vectors",
                "content": "The implementation is mostly the same as in https://www.***.org/minimum-distance-from-a-point-to-the-line-segment-using-vectors/. The basic idea is that we consider 4 sides of the rectangle and find closest point from center of circle to each side. We get 4 distances to each edge and compare it with radius\\n\\n```\\npublic boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n\\n        if ((x_center <= x2 && x_center >= x1) && (y_center <= y2 && y_center >= y1)) return true;\\n        \\n        double d1 = distance(x_center, y_center, x1, y1, x1,y2);\\n        double d2 = distance(x_center, y_center, x1, y1, x2,y1);\\n        double d3 = distance(x_center, y_center, x2, y1, x2,y2);\\n        double d4 = distance(x_center, y_center, x1, y2, x2,y2);\\n\\n        return le(d1, radius) || le(d2, radius) || le(d3, radius) || le(d4, radius);\\n    }\\n    \\n    boolean le(double d, int r) {\\n        return d <= r || Math.abs(d - r) < 0.0001;\\n    }\\n\\n    private double distance(int x0, int y0, int x1, int y1, int x2, int y2) {\\n        int[] ab = new int[] {x2 - x1, y2 - y1};\\n        int[] ae = new int[] {x0 - x1, y0 - y1};\\n        int[] be = new int[] {x0 - x2, y0 - y2};\\n\\n        if (dot(ab, be) > 0) {\\n            return distance(x0, y0, x2, y2);\\n        }\\n        else if (dot(ab, ae) < 0) {\\n            return distance(x0, y0, x1, y1);\\n        }\\n        else {\\n            double abMod = distance(x1, y1, x2, y2);\\n            return Math.abs(ab[0] * ae[1] - ab[1] * ae[0]) / abMod;\\n        }\\n    }\\n\\n    private double distance(int x1, int y1, int x2, int y2) {\\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\\n    }\\n\\n    private int dot(int[] v1, int[] v2) {\\n        return v1[0] * v2[0] + v1[1] * v2[1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n\\n        if ((x_center <= x2 && x_center >= x1) && (y_center <= y2 && y_center >= y1)) return true;\\n        \\n        double d1 = distance(x_center, y_center, x1, y1, x1,y2);\\n        double d2 = distance(x_center, y_center, x1, y1, x2,y1);\\n        double d3 = distance(x_center, y_center, x2, y1, x2,y2);\\n        double d4 = distance(x_center, y_center, x1, y2, x2,y2);\\n\\n        return le(d1, radius) || le(d2, radius) || le(d3, radius) || le(d4, radius);\\n    }\\n    \\n    boolean le(double d, int r) {\\n        return d <= r || Math.abs(d - r) < 0.0001;\\n    }\\n\\n    private double distance(int x0, int y0, int x1, int y1, int x2, int y2) {\\n        int[] ab = new int[] {x2 - x1, y2 - y1};\\n        int[] ae = new int[] {x0 - x1, y0 - y1};\\n        int[] be = new int[] {x0 - x2, y0 - y2};\\n\\n        if (dot(ab, be) > 0) {\\n            return distance(x0, y0, x2, y2);\\n        }\\n        else if (dot(ab, ae) < 0) {\\n            return distance(x0, y0, x1, y1);\\n        }\\n        else {\\n            double abMod = distance(x1, y1, x2, y2);\\n            return Math.abs(ab[0] * ae[1] - ab[1] * ae[0]) / abMod;\\n        }\\n    }\\n\\n    private double distance(int x1, int y1, int x2, int y2) {\\n        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\\n    }\\n\\n    private int dot(int[] v1, int[] v2) {\\n        return v1[0] * v2[0] + v1[1] * v2[1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564542,
                "title": "java-another-one-closest-point-on-rectangle-to-circle-solution",
                "content": "the best solution Q3 \\n```\\n public class Solution {\\n    private int dist(int a1, int a2, int x) {\\n        if (x < a1) return Math.abs(a1 - x);\\n        if (x > a2) return Math.abs(x - a2);\\n        return 0;\\n    }\\n\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int a = dist(x1, x2, x_center);\\n        int b = dist(y1, y2, y_center);\\n        return a * a + b * b <= radius * radius;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n public class Solution {\\n    private int dist(int a1, int a2, int x) {\\n        if (x < a1) return Math.abs(a1 - x);\\n        if (x > a2) return Math.abs(x - a2);\\n        return 0;\\n    }\\n\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int a = dist(x1, x2, x_center);\\n        int b = dist(y1, y2, y_center);\\n        return a * a + b * b <= radius * radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564063,
                "title": "100-100-mathematical-easy-to-understand-explanation",
                "content": "Thought Process\\n-\\nThe point of the square closest to the circle must be within the circle if any of the square is within the circle. This closest point is on the edge of the square, possible a corner. It\\'s either lined up with the ```(x,y)``` coordinates of the circle\\'s center, or as close as it can get. The distance from this point is then compared to the radius of the circle.\\n\\nAlgorithm\\n-\\n```\\npublic class Solution {\\n    public bool CheckOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        var x_square = ClosestToCenter(x_center, x1, x2);\\n        var y_square = ClosestToCenter(y_center, y1, y2);\\n        return DistanceSquared(x_center - x_square, y_center - y_square) <= radius * radius;\\n    }\\n    \\n    private static int ClosestToCenter(int a_center, int a1, int a2) {\\n        return a_center < a1 ? a1 : a_center > a2 ? a2 : a_center;\\n    }\\n    \\n    private static int DistanceSquared(int x, int y) {\\n        return x*x + y*y;\\n    }\\n}\\n```\\n\\nProof\\n-\\n![image](https://assets.leetcode.com/users/laprade/image_1586046485.png)\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```(x,y)```\n```\\npublic class Solution {\\n    public bool CheckOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        var x_square = ClosestToCenter(x_center, x1, x2);\\n        var y_square = ClosestToCenter(y_center, y1, y2);\\n        return DistanceSquared(x_center - x_square, y_center - y_square) <= radius * radius;\\n    }\\n    \\n    private static int ClosestToCenter(int a_center, int a1, int a2) {\\n        return a_center < a1 ? a1 : a_center > a2 ? a2 : a_center;\\n    }\\n    \\n    private static int DistanceSquared(int x, int y) {\\n        return x*x + y*y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563599,
                "title": "c-solution-for-beginners-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int checkMinDistance(int a1,int a2,int x){\\n        if(x<a1){\\n            return (a1-x);\\n        }\\n        \\n        if(x>a2){\\n            return (a2-x);\\n        }\\n        \\n        return 0;\\n    }\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) {\\n        int a1=checkMinDistance(x1,x2,x);\\n        int a2=checkMinDistance(y1,y2,y);\\n        \\n        return a1*a1+a2*a2<=r*r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int checkMinDistance(int a1,int a2,int x){\\n        if(x<a1){\\n            return (a1-x);\\n        }\\n        \\n        if(x>a2){\\n            return (a2-x);\\n        }\\n        \\n        return 0;\\n    }\\n    bool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) {\\n        int a1=checkMinDistance(x1,x2,x);\\n        int a2=checkMinDistance(y1,y2,y);\\n        \\n        return a1*a1+a2*a2<=r*r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563450,
                "title": "java-o-1-solution-with-line-by-line-explanation",
                "content": "For the rectangle coordinates:\\n```\\nx1 = left vertical\\nx2 = right vertical\\ny1 = bottom horizontal\\ny2 = top horizontal\\n```\\n\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n\\t\\t// Temporary variables to set edges for testing\\n        int testX = x_center;\\n        int testY = y_center;\\n\\t\\t// First, we find the closest edge.\\n\\t\\t// If rectange\\'s left edge is on the right on the circle, then it must be closest vertical edge to the circle\\n        if(x_center < x1) testX = x1;\\n        else if(x_center > x2) testX = x2;\\n\\t\\t\\n\\t\\t// If rectangle\\'s bottom horizontal edge is above the circle, then it must be the closest horizontal edge to the circle \\n        if(y_center < y1) testY = y1;\\n        else if(y_center > y2) testY = y2;\\n        \\n\\t\\t// Get distances from closest edges\\n        double dx = x_center - testX;\\n        double dy = y_center - testY;\\n        \\n\\t\\t// Apply pythagoras to see if the distance is less than the radius\\n        return (dx * dx + dy * dy) <= radius * radius;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nx1 = left vertical\\nx2 = right vertical\\ny1 = bottom horizontal\\ny2 = top horizontal\\n```\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n\\t\\t// Temporary variables to set edges for testing\\n        int testX = x_center;\\n        int testY = y_center;\\n\\t\\t// First, we find the closest edge.\\n\\t\\t// If rectange\\'s left edge is on the right on the circle, then it must be closest vertical edge to the circle\\n        if(x_center < x1) testX = x1;\\n        else if(x_center > x2) testX = x2;\\n\\t\\t\\n\\t\\t// If rectangle\\'s bottom horizontal edge is above the circle, then it must be the closest horizontal edge to the circle \\n        if(y_center < y1) testY = y1;\\n        else if(y_center > y2) testY = y2;\\n        \\n\\t\\t// Get distances from closest edges\\n        double dx = x_center - testX;\\n        double dy = y_center - testY;\\n        \\n\\t\\t// Apply pythagoras to see if the distance is less than the radius\\n        return (dx * dx + dy * dy) <= radius * radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563418,
                "title": "c-the-cycle-of-function-to-solve-it",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        for(int i=x1;i<=x2;i++){\\n            for(int j=y1;j<=y2;j++){\\n                if(pow(i-xc,2)+pow(j-yc,2)<=pow(r,2)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        for(int i=x1;i<=x2;i++){\\n            for(int j=y1;j<=y2;j++){\\n                if(pow(i-xc,2)+pow(j-yc,2)<=pow(r,2)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563398,
                "title": "clean-python-3-straightforward-o-1",
                "content": "- Case 1: The circle is in the retangle\\n- Case 2: The circle is cut by the retangle\\n- Case 3: The circle overlaps a corner of the retangle\\n\\nTime: `O(1)`\\nSpace: `O(1)`\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        def in_circle(x, y):\\n            return (x - x_center) ** 2 + (y - y_center) ** 2 <= radius ** 2\\n\\n        # case 1\\n        if x1 <= x_center <= x2 and y1 <= y_center <= y2: return True\\n\\t\\t\\n        left, right = x_center - radius, x_center + radius\\n        bottom, top = y_center - radius, y_center + radius\\n        x_overlap = left <= x2 and x1 <= right\\n        y_overlap = bottom <= y2 and y1 <= top\\n        if not x_overlap or not y_overlap: return False\\n\\n\\t\\t# case 2\\n        if x1 <= left <= right <= x2 or y1 <= bottom <= top <= y2: return True\\n        if left <= x1 <= x2 <= right or bottom <= y1 <= y2 <= top: return True\\n\\n        # case 3\\n        left_top, left_bottom = (x1, y2), (x1, y1)\\n        right_top, right_bottom = (x2, y2), (x2, y1)\\n        return any(in_circle(x, y) for x, y in (left_top, left_bottom, right_top, right_bottom))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        def in_circle(x, y):\\n            return (x - x_center) ** 2 + (y - y_center) ** 2 <= radius ** 2\\n\\n        # case 1\\n        if x1 <= x_center <= x2 and y1 <= y_center <= y2: return True\\n\\t\\t\\n        left, right = x_center - radius, x_center + radius\\n        bottom, top = y_center - radius, y_center + radius\\n        x_overlap = left <= x2 and x1 <= right\\n        y_overlap = bottom <= y2 and y1 <= top\\n        if not x_overlap or not y_overlap: return False\\n\\n\\t\\t# case 2\\n        if x1 <= left <= right <= x2 or y1 <= bottom <= top <= y2: return True\\n        if left <= x1 <= x2 <= right or bottom <= y1 <= y2 <= top: return True\\n\\n        # case 3\\n        left_top, left_bottom = (x1, y2), (x1, y1)\\n        right_top, right_bottom = (x2, y2), (x2, y1)\\n        return any(in_circle(x, y) for x, y in (left_top, left_bottom, right_top, right_bottom))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563380,
                "title": "o-1-time-and-space-only-integer-math-explanation",
                "content": "```C++\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        // inside vertical bounds of rectangle\\n        if (x1 - r <= xc && xc <= x2 + r && y1 <= yc && yc <= y2) {\\n            return true; \\n        }\\n        // inside horizontal bounds of rectangle\\n        if (x1<= xc && xc <= x2 && y1 - r  <= yc && yc <= y2 + r) \\n            return true; \\n        \\n        vector<int> x = {x1,x2};\\n        vector<int> y = {y1,y2};\\n\\n        // or near one of the 4 points\\n        for (int ix = 0;ix < 2;ix++) {\\n            for (int iy = 0;iy < 2; iy++) {\\n                int dx = xc - x[ix];\\n                int dy = yc - y[iy];\\n                if (dx * dx + dy * dy <= r*r)\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```C++\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        // inside vertical bounds of rectangle\\n        if (x1 - r <= xc && xc <= x2 + r && y1 <= yc && yc <= y2) {\\n            return true; \\n        }\\n        // inside horizontal bounds of rectangle\\n        if (x1<= xc && xc <= x2 && y1 - r  <= yc && yc <= y2 + r) \\n            return true; \\n        \\n        vector<int> x = {x1,x2};\\n        vector<int> y = {y1,y2};\\n\\n        // or near one of the 4 points\\n        for (int ix = 0;ix < 2;ix++) {\\n            for (int iy = 0;iy < 2; iy++) {\\n                int dx = xc - x[ix];\\n                int dy = yc - y[iy];\\n                if (dx * dx + dy * dy <= r*r)\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563325,
                "title": "c-simple-o-1-time-circle-rectangle-intersection-borders-inside-and-tangents-as-sides",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int x_c, int y_c, int x1, int y1, int x2, int y2) {\\n        if(x1 <= x_c && x_c <= x2)\\n        {\\n            if(y1 <= y_c && y_c <= y2)\\n                return 1;\\n        }\\n        \\n        double a = r * r - (x_c - x1)*(x_c - x1) - (y_c - y1) * (y_c - y1);\\n        if(a >= 0.0)\\n        {\\n            return 1;\\n        }\\n        a = r * r - (x_c - x2)*(x_c - x2) - (y_c - y2) * (y_c - y2);\\n        if(a >= 0.0)\\n        {\\n            return 1;\\n        }\\n        a = r * r - (y_c - y1)*(y_c - y1)  - (x_c - x2)*(x_c - x2);\\n        if(a >= 0.0)\\n        {\\n           return 1;\\n        }\\n        a = r * r - (y_c - y2)*(y_c - y2) - (x_c - x1)*(x_c - x1);\\n        if(a >= 0.0)\\n        {\\n            return 1;\\n        }           \\n        \\n        a = r * r - (x_c - x1)*(x_c - x1);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = y_c + a, cy2 = y_c - a;\\n            if((cy >= y1 && cy <= y2) || (cy2 >= y1 && cy2 <= y2))\\n                return 1;\\n        }\\n        a = r * r - (x_c - x2)*(x_c - x2);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = y_c + a, cy2 = y_c - a;\\n            if((cy >= y1 && cy <= y2) || (cy2 >= y1 && cy2 <= y2))\\n                return 1;\\n        }\\n        a = r * r - (y_c - y1)*(y_c - y1);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = x_c + a, cy2 = x_c - a;\\n            if((cy >= x1 && cy <= x2) || (cy2 >= x1 && cy2 <= x2))\\n                return 1;\\n        }\\n        a = r * r - (y_c - y2)*(y_c - y2);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = x_c + a, cy2 = x_c - a;\\n            if((cy >= x1 && cy <= x2) || (cy2 >= x1 && cy2 <= x2))\\n                return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int x_c, int y_c, int x1, int y1, int x2, int y2) {\\n        if(x1 <= x_c && x_c <= x2)\\n        {\\n            if(y1 <= y_c && y_c <= y2)\\n                return 1;\\n        }\\n        \\n        double a = r * r - (x_c - x1)*(x_c - x1) - (y_c - y1) * (y_c - y1);\\n        if(a >= 0.0)\\n        {\\n            return 1;\\n        }\\n        a = r * r - (x_c - x2)*(x_c - x2) - (y_c - y2) * (y_c - y2);\\n        if(a >= 0.0)\\n        {\\n            return 1;\\n        }\\n        a = r * r - (y_c - y1)*(y_c - y1)  - (x_c - x2)*(x_c - x2);\\n        if(a >= 0.0)\\n        {\\n           return 1;\\n        }\\n        a = r * r - (y_c - y2)*(y_c - y2) - (x_c - x1)*(x_c - x1);\\n        if(a >= 0.0)\\n        {\\n            return 1;\\n        }           \\n        \\n        a = r * r - (x_c - x1)*(x_c - x1);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = y_c + a, cy2 = y_c - a;\\n            if((cy >= y1 && cy <= y2) || (cy2 >= y1 && cy2 <= y2))\\n                return 1;\\n        }\\n        a = r * r - (x_c - x2)*(x_c - x2);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = y_c + a, cy2 = y_c - a;\\n            if((cy >= y1 && cy <= y2) || (cy2 >= y1 && cy2 <= y2))\\n                return 1;\\n        }\\n        a = r * r - (y_c - y1)*(y_c - y1);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = x_c + a, cy2 = x_c - a;\\n            if((cy >= x1 && cy <= x2) || (cy2 >= x1 && cy2 <= x2))\\n                return 1;\\n        }\\n        a = r * r - (y_c - y2)*(y_c - y2);\\n        if(a >= 0.0)\\n        {\\n            a = sqrt(a * 1.0);\\n            double cy = x_c + a, cy2 = x_c - a;\\n            if((cy >= x1 && cy <= x2) || (cy2 >= x1 && cy2 <= x2))\\n                return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005966,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n      final miniX = max(x1, min(x2, xCenter));\\n      final miniY = max(y1, min(y2, yCenter));\\n      final distance = sqrt(pow(miniX - xCenter, 2) + pow(miniY - yCenter, 2)).toInt();\\n      return distance <= radius;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n      final miniX = max(x1, min(x2, xCenter));\\n      final miniY = max(y1, min(y2, yCenter));\\n      final distance = sqrt(pow(miniX - xCenter, 2) + pow(miniY - yCenter, 2)).toInt();\\n      return distance <= radius;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999409,
                "title": "100-beast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n                \\n        int closestX = Math.max(x1, Math.min(xCenter, x2));\\n        int closestY = Math.max(y1, Math.min(yCenter, y2));\\n        \\n        \\n        int distanceX = xCenter - closestX;\\n        int distanceY = yCenter - closestY;\\n        \\n        int squaredDistance = distanceX * distanceX + distanceY * distanceY;\\n        \\n        return squaredDistance <= radius * radius;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n                \\n        int closestX = Math.max(x1, Math.min(xCenter, x2));\\n        int closestY = Math.max(y1, Math.min(yCenter, y2));\\n        \\n        \\n        int distanceX = xCenter - closestX;\\n        int distanceY = yCenter - closestY;\\n        \\n        int squaredDistance = distanceX * distanceX + distanceY * distanceY;\\n        \\n        return squaredDistance <= radius * radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979494,
                "title": "my-solution",
                "content": "```\\n/**\\n * if the circle and the rectangle overlaps,\\n * there must exist a point (`x`, `y`) in the rectangle such that\\n * the distance from the point (`x`, `y`) to the center (`xCenter`, `yCenter`) of the circle\\n * is less than or equal to the length of the radius `radius`, that is,\\n * (`x` - `xCenter`) * (`x` - `xCenter`) + (`y` - `yCenter`) * (`y` - `yCenter`) <= `radius` * `radius`\\n * so the target is,\\n * 1. find a `x` in the range [`x1`, `x2`], both inclusive,\\n *    such that (`x` - `xCenter`) * (`x` - `xCenter`) is minimum\\n * 2. find a `y` in the range [`y1`, `y2`], both inclusive,\\n *    such that (`y` - `yCenter`) * (`y` - `yCenter`) is minimum\\n * if (`x` - `xCenter`) * (`x` - `xCenter`) + (`y` - `yCenter`) * (`y` - `yCenter`) <= `radius` * `radius`\\n * return true\\n * otherwise, return false\\n *\\n * the logic of finding the `x` in the range [`x1`, `x2`], both inclusive, such that\\n * (`x` - `xCenter`) * (`x` - `xCenter`) is minimum is as following,\\n * 1. if `xCenter` is in the range [`x1`, `x2`], both inclusive,\\n *    `x` should be equal to `xCenter`, so\\n *    (`x` - `xCenter`) * (`x` - `xCenter`) is zero\\n * 2. if `xCenter` is less than `x1`, `x` should be equal to `x1`, so\\n *    (`x` - `xCenter`) * (`x` - `xCenter`) is equal to (`x1` - `xCenter`) * (`x1` - `xCenter`)\\n * 3. if `xCenter` is greater than `x2`, `x` should be equal to `x2`, so\\n *    (`x` - `xCenter`) * (`x` - `xCenter`) is equal to (`x2` - `xCenter`) * (`x2` - `xCenter`)\\n *\\n * the logic of finding the `y` in the range [`y1`, `y2`], both inclusive, such that\\n * (`y` - `yCenter`) * (`y` - `yCenter`) is minimum is similar with the logic of doing `x`,\\n *\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n public:\\n  bool checkOverlap(const int radius,\\n                    const int xCenter,\\n                    const int yCenter,\\n                    const int x1,\\n                    const int y1,\\n                    const int x2,\\n                    const int y2) {\\n    return min_distance(xCenter, x1, x2) + min_distance(yCenter, y1, y2) <= power2(radius);\\n  }\\n  \\n private:\\n  int min_distance(const int center, const int a1, const int a2) {\\n    if (center < a1) {\\n      return power2(a1 - center);\\n    }\\n    if (center > a2) {\\n      return power2(center - a2);\\n    }\\n    return 0;\\n  }\\n  \\n  int power2(const int a) {\\n    return a * a;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * if the circle and the rectangle overlaps,\\n * there must exist a point (`x`, `y`) in the rectangle such that\\n * the distance from the point (`x`, `y`) to the center (`xCenter`, `yCenter`) of the circle\\n * is less than or equal to the length of the radius `radius`, that is,\\n * (`x` - `xCenter`) * (`x` - `xCenter`) + (`y` - `yCenter`) * (`y` - `yCenter`) <= `radius` * `radius`\\n * so the target is,\\n * 1. find a `x` in the range [`x1`, `x2`], both inclusive,\\n *    such that (`x` - `xCenter`) * (`x` - `xCenter`) is minimum\\n * 2. find a `y` in the range [`y1`, `y2`], both inclusive,\\n *    such that (`y` - `yCenter`) * (`y` - `yCenter`) is minimum\\n * if (`x` - `xCenter`) * (`x` - `xCenter`) + (`y` - `yCenter`) * (`y` - `yCenter`) <= `radius` * `radius`\\n * return true\\n * otherwise, return false\\n *\\n * the logic of finding the `x` in the range [`x1`, `x2`], both inclusive, such that\\n * (`x` - `xCenter`) * (`x` - `xCenter`) is minimum is as following,\\n * 1. if `xCenter` is in the range [`x1`, `x2`], both inclusive,\\n *    `x` should be equal to `xCenter`, so\\n *    (`x` - `xCenter`) * (`x` - `xCenter`) is zero\\n * 2. if `xCenter` is less than `x1`, `x` should be equal to `x1`, so\\n *    (`x` - `xCenter`) * (`x` - `xCenter`) is equal to (`x1` - `xCenter`) * (`x1` - `xCenter`)\\n * 3. if `xCenter` is greater than `x2`, `x` should be equal to `x2`, so\\n *    (`x` - `xCenter`) * (`x` - `xCenter`) is equal to (`x2` - `xCenter`) * (`x2` - `xCenter`)\\n *\\n * the logic of finding the `y` in the range [`y1`, `y2`], both inclusive, such that\\n * (`y` - `yCenter`) * (`y` - `yCenter`) is minimum is similar with the logic of doing `x`,\\n *\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n public:\\n  bool checkOverlap(const int radius,\\n                    const int xCenter,\\n                    const int yCenter,\\n                    const int x1,\\n                    const int y1,\\n                    const int x2,\\n                    const int y2) {\\n    return min_distance(xCenter, x1, x2) + min_distance(yCenter, y1, y2) <= power2(radius);\\n  }\\n  \\n private:\\n  int min_distance(const int center, const int a1, const int a2) {\\n    if (center < a1) {\\n      return power2(a1 - center);\\n    }\\n    if (center > a2) {\\n      return power2(center - a2);\\n    }\\n    return 0;\\n  }\\n  \\n  int power2(const int a) {\\n    return a * a;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973873,
                "title": "java-soln-using-mathematical-equation-and-wavy-curve-method",
                "content": "# Code\\n```\\nclass Solution {\\n    public static class Pair{\\n        double first;\\n        double second;\\n        public Pair(double first,double second){\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n    public Pair getSolution(int a,int b,int c){\\n        int d = b*b - 4 * a * c;\\n        if(d < 0) return new Pair(Integer.MIN_VALUE,Integer.MIN_VALUE);\\n        double s1 = (-b + Math.sqrt(d)) / 2.0 * a;\\n        double s2 = (-b - Math.sqrt(d)) / 2.0 * a;\\n        return new Pair(s1,s2);\\n    }\\n    public boolean checkRange(double s1,double s2,double r1,double r2){\\n       double x = Math.max(r1,r2);\\n       double y = Math.min(r1,r2);\\n       return !(x < s1 || y > s2);\\n    }\\n\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        //We can have equation of circle and substitue the rectangle boundaries to verify\\n        if(xCenter >= x1 && xCenter <= x2 && yCenter >= y1 && yCenter <= y2){\\n            return true;\\n        }\\n        Pair p1 = getSolution(1,-2*yCenter,(x1-xCenter) * (x1-xCenter) - radius*radius + yCenter * yCenter);\\n        Pair p2 = getSolution(1,-2*yCenter,(x2-xCenter) * (x2-xCenter) - radius*radius + yCenter * yCenter);\\n        Pair p3 = getSolution(1,-2*xCenter,(y1-yCenter) * (y1-yCenter) - radius*radius + xCenter * xCenter); \\n        Pair p4 = getSolution(1,-2*xCenter,(y2-yCenter) * (y2-yCenter) - radius*radius + xCenter * xCenter);\\n\\n        return checkRange(Math.min(p1.first,p1.second),Math.max(p1.first,p1.second),y1,y2) || \\n               checkRange(Math.min(p2.first,p2.second),Math.max(p2.first,p2.second),y1,y2) ||\\n               checkRange(Math.min(p3.first,p3.second),Math.max(p3.first,p3.second),x1,x2) ||\\n               checkRange(Math.min(p4.first,p4.second),Math.max(p4.first,p4.second),x1,x2); \\n   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static class Pair{\\n        double first;\\n        double second;\\n        public Pair(double first,double second){\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n    public Pair getSolution(int a,int b,int c){\\n        int d = b*b - 4 * a * c;\\n        if(d < 0) return new Pair(Integer.MIN_VALUE,Integer.MIN_VALUE);\\n        double s1 = (-b + Math.sqrt(d)) / 2.0 * a;\\n        double s2 = (-b - Math.sqrt(d)) / 2.0 * a;\\n        return new Pair(s1,s2);\\n    }\\n    public boolean checkRange(double s1,double s2,double r1,double r2){\\n       double x = Math.max(r1,r2);\\n       double y = Math.min(r1,r2);\\n       return !(x < s1 || y > s2);\\n    }\\n\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        //We can have equation of circle and substitue the rectangle boundaries to verify\\n        if(xCenter >= x1 && xCenter <= x2 && yCenter >= y1 && yCenter <= y2){\\n            return true;\\n        }\\n        Pair p1 = getSolution(1,-2*yCenter,(x1-xCenter) * (x1-xCenter) - radius*radius + yCenter * yCenter);\\n        Pair p2 = getSolution(1,-2*yCenter,(x2-xCenter) * (x2-xCenter) - radius*radius + yCenter * yCenter);\\n        Pair p3 = getSolution(1,-2*xCenter,(y1-yCenter) * (y1-yCenter) - radius*radius + xCenter * xCenter); \\n        Pair p4 = getSolution(1,-2*xCenter,(y2-yCenter) * (y2-yCenter) - radius*radius + xCenter * xCenter);\\n\\n        return checkRange(Math.min(p1.first,p1.second),Math.max(p1.first,p1.second),y1,y2) || \\n               checkRange(Math.min(p2.first,p2.second),Math.max(p2.first,p2.second),y1,y2) ||\\n               checkRange(Math.min(p3.first,p3.second),Math.max(p3.first,p3.second),x1,x2) ||\\n               checkRange(Math.min(p4.first,p4.second),Math.max(p4.first,p4.second),x1,x2); \\n   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951300,
                "title": "java-in-0ms-is-point-in-rounded-rectangle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing principles of *Mathematical Morphology* (geometric properties of point sets) we can convert the problem of seeing whether the circle is inside the rectangle to one of seeing whether a point -- the center of the circle -- is inside a \"rounded\" rectangle -- the starting rectangle, expanded by \"radius\" in all directions, then rounding the resulting corners by \"radius\".  This, in turn, can be converted to the problem of seeing whether the point fits in the original rectangle, or a cross shape formed by expanding the rectangle independently up and down, and right and left, OR in circles of \"radius\" centered at the original rectangle corners.\\n\\nNote in passing that this same logic can be applied not only to a rectangle but to any convex polygon.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses two subfunctions, one that sees whether a point fits in a rectangle and the other that sees whether a point fits in a circle.  These are applied using the logic in Intution in the main function.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe run time depends on the number of vertices which, being fixed, means the time complexity is $$O(1)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSince all variables, arguments, and result are scalars, the space complexity is $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        // Check against rectangle:\\n        if ( isPointInRectangle( xCenter, yCenter, x1, y1, x2, y2 ) )\\n            return true;\\n        // Check against North and South walls and square\\n        if ( isPointInRectangle( xCenter, yCenter, x1, y1 - radius, x2, y2 + radius ) ||\\n        // Check against West and East walls and square\\n             isPointInRectangle( xCenter, yCenter, x1 - radius, y1, x2 + radius, y2 ) )\\n            return true;\\n        // check against corner circles:\\n        int[] xrange = { x1, x2 }, yrange = { y1, y2 };\\n        for ( int x : xrange )\\n            for ( int y : yrange )\\n                if ( isPointInCircle( xCenter, yCenter, x, y, radius ) )\\n                    return true;\\n        return false;\\n\\n    }\\n    private boolean isPointInRectangle( int px, int py, int rxlo, int rylo, int rxhi, int ryhi ) {\\n        return px >= rxlo && px <= rxhi && py >= rylo && py <= ryhi;\\n    }\\n    private boolean isPointInCircle( int px, int py, int ccx, int ccy, int radius ) {\\n        return ( ccx - px ) * (ccx - px ) + (ccy - py ) * ( ccy - py ) <= radius * radius;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        // Check against rectangle:\\n        if ( isPointInRectangle( xCenter, yCenter, x1, y1, x2, y2 ) )\\n            return true;\\n        // Check against North and South walls and square\\n        if ( isPointInRectangle( xCenter, yCenter, x1, y1 - radius, x2, y2 + radius ) ||\\n        // Check against West and East walls and square\\n             isPointInRectangle( xCenter, yCenter, x1 - radius, y1, x2 + radius, y2 ) )\\n            return true;\\n        // check against corner circles:\\n        int[] xrange = { x1, x2 }, yrange = { y1, y2 };\\n        for ( int x : xrange )\\n            for ( int y : yrange )\\n                if ( isPointInCircle( xCenter, yCenter, x, y, radius ) )\\n                    return true;\\n        return false;\\n\\n    }\\n    private boolean isPointInRectangle( int px, int py, int rxlo, int rylo, int rxhi, int ryhi ) {\\n        return px >= rxlo && px <= rxhi && py >= rylo && py <= ryhi;\\n    }\\n    private boolean isPointInCircle( int px, int py, int ccx, int ccy, int radius ) {\\n        return ( ccx - px ) * (ccx - px ) + (ccy - py ) * ( ccy - py ) <= radius * radius;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946374,
                "title": "2-solutions-explained",
                "content": "**9 points that cover all testcases**\\nIn this solutions I tried to identify all core testcases and find a relatively small number of points that can handle them (test driven developement so to speak).\\nThe only operations I wanted to use is a check whether these points belong to a rectangle and a circle. I iteratively added the points, eliminating core testcases and solving them. I started from the cornerpoints then added the centerpoint then added the rest four projections.\\n\\n![image](https://assets.leetcode.com/users/images/a80c56cf-3a71-462c-8f5a-f39b4cab9ed7_1692734806.4796188.png)\\n\\n**Algo:**\\nTake cartesian product of sets `{x,x1,x2}` and `{y,y1,y2}`: \\n`{x,x1,x2} x {y,y1,y2}={(x,y), (x,y1), (x, y2), (x1,y), (x1,y1), (x1, y2), (x2,y), (x2,y1), (x2, y2)}`\\nto obtain the set of 9 2d points.  These points are:\\n* 1 center of the circle;\\n* 4 vertices of the rectangle;\\n* 4 projections of the  vertices of the rectangle to the `xy` axes that pass through the center of the circle.\\n\\nCheck if **any** of the points belongs to the rectangle **and** the circle.\\n\\n![image](https://assets.leetcode.com/users/images/8a412389-8ba6-4efc-a315-a38c7eeae05a_1692729751.8346817.png)\\n\\n```\\nbool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n{\\n\\tauto f = [&](int a, int b){ return (x-a)*(x-a)+(y-b)*(y-b)<=r*r and a>=x1 and a<=x2 and b>=y1 and b<=y2; };   \\n\\treturn f(x,y) or f(x1,y) or f(x2,y) or f(x,y1) or f(x1,y1) or f(x2,y1) or f(x,y2) or f(x1,y2) or f(x2,y2);\\n}\\n```\\nAs you can see on the picture it\\'s always the **\"middlepoint\"** that is really important thus you can check only this point! So the next solution does precisely that.\\n\\n**magic of `min/max`**\\n**Algo:**\\n* from the set `{x,x1,x2}` pick the middle point (Iet\\'s call it `xm`);\\n* from the set `{x,x1,x2}` pick the middle point (Iet\\'s call it `ym`);\\n* check that `(xm, ym)` lies inside the circle. \\n\\nWhy `(xm, ym)` is important? Because this the point of rectangle closest to the center of the circle!\\n\\n![image](https://assets.leetcode.com/users/images/ed511959-a5b6-4fdf-8196-3874b86052cf_1692728689.7014942.png)\\n\\n```\\nbool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n{\\n\\tint xm = min(max(x, x1), x2),\\n\\t\\tym = min(max(y, y1), y2);\\n\\treturn (x-xm)*(x-xm)+(y-ym)*(y-ym)<=r*r;\\n}\\n```\\nWhy `min/max (\\u2227/\\u2228)` are magical ? Because they form an algebra and can sort numbers just by their succesive application. Check this out:\\n[2733. Neither Minimum nor Maximum](https://leetcode.com/problems/neither-minimum-nor-maximum/discuss/3625141/1-liner?currentPage=1&orderBy=most_relevant&query=android)\\n\\nAnother problem about intersections:\\n[836. Rectangle Overlap](https://leetcode.com/problems/rectangle-overlap/discuss/3947417/ok)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n{\\n\\tauto f = [&](int a, int b){ return (x-a)*(x-a)+(y-b)*(y-b)<=r*r and a>=x1 and a<=x2 and b>=y1 and b<=y2; };   \\n\\treturn f(x,y) or f(x1,y) or f(x2,y) or f(x,y1) or f(x1,y1) or f(x2,y1) or f(x,y2) or f(x1,y2) or f(x2,y2);\\n}\\n```\n```\\nbool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) \\n{\\n\\tint xm = min(max(x, x1), x2),\\n\\t\\tym = min(max(y, y1), y2);\\n\\treturn (x-xm)*(x-xm)+(y-ym)*(y-ym)<=r*r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946028,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1,\\n                    int x2, int y2) {\\n    auto clamp = [&](int center, int mini, int maxi) {\\n      return max(mini, min(maxi, center));\\n    };\\n\\n    // The closest point to the circle within the rectangle\\n    int closestX = clamp(x_center, x1, x2);\\n    int closestY = clamp(y_center, y1, y2);\\n\\n    // The distance between the circle\\'s center and this closest point\\n    int distanceX = x_center - closestX;\\n    int distanceY = y_center - closestY;\\n\\n    // If the distance is less than the circle\\'s radius, an intersection occurs\\n    return (distanceX * distanceX) + (distanceY * distanceY) <=\\n           (radius * radius);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1,\\n                    int x2, int y2) {\\n    auto clamp = [&](int center, int mini, int maxi) {\\n      return max(mini, min(maxi, center));\\n    };\\n\\n    // The closest point to the circle within the rectangle\\n    int closestX = clamp(x_center, x1, x2);\\n    int closestY = clamp(y_center, y1, y2);\\n\\n    // The distance between the circle\\'s center and this closest point\\n    int distanceX = x_center - closestX;\\n    int distanceY = y_center - closestY;\\n\\n    // If the distance is less than the circle\\'s radius, an intersection occurs\\n    return (distanceX * distanceX) + (distanceY * distanceY) <=\\n           (radius * radius);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934610,
                "title": "c-simple-clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public:\\n  bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1,\\n                    int x2, int y2) {\\n    if (xCenter + radius < x1 || xCenter - radius > x2) return false;\\n    if (yCenter + radius < y1 || yCenter - radius > y2) return false;\\n    if (xCenter < x1 && yCenter > y2 && out(x1, y2, xCenter, yCenter, radius))\\n      return false;\\n    if (xCenter > x2 && yCenter > y2 && out(x2, y2, xCenter, yCenter, radius))\\n      return false;\\n    if (xCenter < x1 && yCenter < y1 && out(x1, y1, xCenter, yCenter, radius))\\n      return false;\\n    if (xCenter > x2 && yCenter < y1 && out(x2, y1, xCenter, yCenter, radius))\\n      return false;\\n    return true;\\n  }\\n\\n  private:\\n  inline bool out(int x, int y, int xCenter, int yCenter, int radius) {\\n#define SQUARE(x) (x) * (x)\\n    return SQUARE(x - xCenter) + SQUARE(y - yCenter) > SQUARE(radius);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n  bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1,\\n                    int x2, int y2) {\\n    if (xCenter + radius < x1 || xCenter - radius > x2) return false;\\n    if (yCenter + radius < y1 || yCenter - radius > y2) return false;\\n    if (xCenter < x1 && yCenter > y2 && out(x1, y2, xCenter, yCenter, radius))\\n      return false;\\n    if (xCenter > x2 && yCenter > y2 && out(x2, y2, xCenter, yCenter, radius))\\n      return false;\\n    if (xCenter < x1 && yCenter < y1 && out(x1, y1, xCenter, yCenter, radius))\\n      return false;\\n    if (xCenter > x2 && yCenter < y1 && out(x2, y1, xCenter, yCenter, radius))\\n      return false;\\n    return true;\\n  }\\n\\n  private:\\n  inline bool out(int x, int y, int xCenter, int yCenter, int radius) {\\n#define SQUARE(x) (x) * (x)\\n    return SQUARE(x - xCenter) + SQUARE(y - yCenter) > SQUARE(radius);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848126,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xCentre, int yCentre, int x1, int y1, int x2, int y2) {\\n        \\n        int x,y;\\n\\n        if(x1<=xCentre && x2>=xCentre) x = 0;\\n        else x = Math.min(Math.abs(x1-xCentre),Math.abs(x2-xCentre));\\n\\n        if(y1<=yCentre && y2>=yCentre) y = 0;\\n        else y = Math.min(Math.abs(y1-yCentre),Math.abs(y2-yCentre));\\n\\n        if(x*x + y*y <= r*r) return true;\\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xCentre, int yCentre, int x1, int y1, int x2, int y2) {\\n        \\n        int x,y;\\n\\n        if(x1<=xCentre && x2>=xCentre) x = 0;\\n        else x = Math.min(Math.abs(x1-xCentre),Math.abs(x2-xCentre));\\n\\n        if(y1<=yCentre && y2>=yCentre) y = 0;\\n        else y = Math.min(Math.abs(y1-yCentre),Math.abs(y2-yCentre));\\n\\n        if(x*x + y*y <= r*r) return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716856,
                "title": "golang-simple-solution",
                "content": "# Code\\n```\\nfunc checkOverlap(radius int, xCenter int, yCenter int, x1 int, y1 int, x2 int, y2 int) bool {\\n  // We\\'re going to check if any point on the rectangle\\'s side is within the circle\\n  r2 := radius * radius\\n  xMin, yMin := min(x1, x2), min(y1, y2)\\n  xMax, yMax := max(x1, x2), max(y1, y2)\\n\\n  // Check if the circle is inside the rectangle\\n  if xCenter >= xMin && xCenter <= xMax && yCenter >= yMin && yCenter <= yMax {\\n    return true\\n  }\\n\\n  // Check if one of the sides of the rectangle is within the rectangle\\n  for x := xMin; x <= xMax; x++ {\\n    if (x - xCenter) *  (x - xCenter) + (yMin - yCenter) * (yMin - yCenter) <= r2 {\\n      return true\\n    }\\n    if (x - xCenter) *  (x - xCenter) + (yMax - yCenter) * (yMax - yCenter) <= r2 {\\n      return true\\n    }\\n  }\\n  for y := yMin; y <= yMax; y++ {\\n    if (xMin - xCenter) * (xMin - xCenter) + (y - yCenter) * (y - yCenter) <= r2 {\\n      return true\\n    }\\n    if (xMax - xCenter) * (xMax - xCenter) + (y - yCenter) * (y - yCenter) <= r2 {\\n      return true\\n    }\\n  }\\n  return false\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc checkOverlap(radius int, xCenter int, yCenter int, x1 int, y1 int, x2 int, y2 int) bool {\\n  // We\\'re going to check if any point on the rectangle\\'s side is within the circle\\n  r2 := radius * radius\\n  xMin, yMin := min(x1, x2), min(y1, y2)\\n  xMax, yMax := max(x1, x2), max(y1, y2)\\n\\n  // Check if the circle is inside the rectangle\\n  if xCenter >= xMin && xCenter <= xMax && yCenter >= yMin && yCenter <= yMax {\\n    return true\\n  }\\n\\n  // Check if one of the sides of the rectangle is within the rectangle\\n  for x := xMin; x <= xMax; x++ {\\n    if (x - xCenter) *  (x - xCenter) + (yMin - yCenter) * (yMin - yCenter) <= r2 {\\n      return true\\n    }\\n    if (x - xCenter) *  (x - xCenter) + (yMax - yCenter) * (yMax - yCenter) <= r2 {\\n      return true\\n    }\\n  }\\n  for y := yMin; y <= yMax; y++ {\\n    if (xMin - xCenter) * (xMin - xCenter) + (y - yCenter) * (y - yCenter) <= r2 {\\n      return true\\n    }\\n    if (xMax - xCenter) * (xMax - xCenter) + (y - yCenter) * (y - yCenter) <= r2 {\\n      return true\\n    }\\n  }\\n  return false\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3707131,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar checkOverlap = function(radius, xCenter, yCenter, x1, y1, x2, y2) {\\n    const xEdge = Math.max(x1, Math.min(x2, xCenter));\\n    const yEdge = Math.max(y1, Math.min(y2, yCenter));\\n    const xDistance = xCenter - xEdge;\\n    const yDistance = yCenter - yEdge;\\n\\n    return xDistance ** 2 + yDistance ** 2 <= radius ** 2\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkOverlap = function(radius, xCenter, yCenter, x1, y1, x2, y2) {\\n    const xEdge = Math.max(x1, Math.min(x2, xCenter));\\n    const yEdge = Math.max(y1, Math.min(y2, yCenter));\\n    const xDistance = xCenter - xEdge;\\n    const yDistance = yCenter - yEdge;\\n\\n    return xDistance ** 2 + yDistance ** 2 <= radius ** 2\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3439433,
                "title": "o-radius",
                "content": "```ruby\\ndef check_overlap r, x, y, x1, y1, x2, y2\\n    r2, rw, rh = r * r, x1..x2, y1..y2\\n    for h in 0..r\\n        w = Integer.sqrt r2 - h * h\\n        cw = x - w..x + w\\n        a, b = *(rw.begin < cw.begin ? [rw, cw] : [cw, rw])\\n        if b.begin <= a.end && (rh === y + h || rh === y - h)\\n            return true\\n        end\\n    end\\n    false\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef check_overlap r, x, y, x1, y1, x2, y2\\n    r2, rw, rh = r * r, x1..x2, y1..y2\\n    for h in 0..r\\n        w = Integer.sqrt r2 - h * h\\n        cw = x - w..x + w\\n        a, b = *(rw.begin < cw.begin ? [rw, cw] : [cw, rw])\\n        if b.begin <= a.end && (rh === y + h || rh === y - h)\\n            return true\\n        end\\n    end\\n    false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3370592,
                "title": "python-easy-geometry",
                "content": "First we have to find the nearest point on the rectangle to the center of the circle. Calculate the distance between the center of the circle with the nearest x and y coordinates. We can check the intersection by using pythagorean theorem. A point lies inside the circle if distance < radius. A point lies on the circle if d = radius. \\nSo we return check if distance <= radius. \\n\\n# Code\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        nearest_x = max(x1, min(x2, xCenter))\\n        nearest_y = max(y1, min(y2, yCenter))\\n        dist_x = nearest_x - xCenter\\n        dist_y = nearest_y - yCenter\\n\\n        return dist_x ** 2 + dist_y ** 2 <= radius ** 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        nearest_x = max(x1, min(x2, xCenter))\\n        nearest_y = max(y1, min(y2, yCenter))\\n        dist_x = nearest_x - xCenter\\n        dist_y = nearest_y - yCenter\\n\\n        return dist_x ** 2 + dist_y ** 2 <= radius ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353919,
                "title": "antarnab-java-2lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x, int y, int x1, int y1, int x2, int y2) {\\n        int yy = (y <= y2 && y >= y1) ? 0 : Math.min(Math.abs(y1 - y), Math.abs(y2 - y));\\n        int xx = (x >= x1 && x <= x2) ? 0 : Math.min(Math.abs(x1 - x), Math.abs(x2 - x));\\n        return xx * xx + yy * yy <= radius * radius;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x, int y, int x1, int y1, int x2, int y2) {\\n        int yy = (y <= y2 && y >= y1) ? 0 : Math.min(Math.abs(y1 - y), Math.abs(y2 - y));\\n        int xx = (x >= x1 && x <= x2) ? 0 : Math.min(Math.abs(x1 - x), Math.abs(x2 - x));\\n        return xx * xx + yy * yy <= radius * radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323768,
                "title": "java-using-basic-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x, int y, int x1, int y1, int x2, int y2) {\\n        int yy = (y <= y2 && y >= y1) ? 0 : Math.min(Math.abs(y1 - y), Math.abs(y2 - y));\\n        int xx = (x >= x1 && x <= x2) ? 0 : Math.min(Math.abs(x1 - x), Math.abs(x2 - x));\\n        return xx * xx + yy * yy <= radius * radius;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x, int y, int x1, int y1, int x2, int y2) {\\n        int yy = (y <= y2 && y >= y1) ? 0 : Math.min(Math.abs(y1 - y), Math.abs(y2 - y));\\n        int xx = (x >= x1 && x <= x2) ? 0 : Math.min(Math.abs(x1 - x), Math.abs(x2 - x));\\n        return xx * xx + yy * yy <= radius * radius;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109398,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn check_overlap(radius: i32, x_center: i32, y_center: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n        let x = if x_center < x1 {\\n            x1\\n        } else if x_center > x2 {\\n            x2\\n        } else {\\n            x_center\\n        };\\n        let y = if y_center < y1 {\\n            y1\\n        } else if y_center > y2 {\\n            y2\\n        } else {\\n            y_center\\n        };\\n        let dx = x_center - x;\\n        let dy = y_center - y;\\n        dx * dx + dy * dy <= radius * radius\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn check_overlap(radius: i32, x_center: i32, y_center: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n        let x = if x_center < x1 {\\n            x1\\n        } else if x_center > x2 {\\n            x2\\n        } else {\\n            x_center\\n        };\\n        let y = if y_center < y1 {\\n            y1\\n        } else if y_center > y2 {\\n            y2\\n        } else {\\n            y_center\\n        };\\n        let dx = x_center - x;\\n        let dy = y_center - y;\\n        dx * dx + dy * dy <= radius * radius\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3103448,
                "title": "c-0ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought on how to solve this problem is to find the closest edge of the rectangle to the circle\\'s center, and then check if the distance between them is less than or equal to the radius. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, I will first check if the circle\\'s center is inside the rectangle. If so, then it is definitely overlapping. If not, I will find the closest edge of the rectangle to the circle\\'s center and check the distance between them. If the distance is less than or equal to the radius, then the circle and the rectangle overlap, otherwise they don\\'t overlap. \\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        if (xCenter >= x1 && xCenter <= x2 && yCenter >= y1 && yCenter <= y2) {\\n            return true;\\n        }\\n        if (xCenter < x1) {\\n            if (yCenter < y1) {\\n                return (xCenter - x1) * (xCenter - x1) + (yCenter - y1) * (yCenter - y1) <= radius * radius;\\n            } else if (yCenter > y2) {\\n                return (xCenter - x1) * (xCenter - x1) + (yCenter - y2) * (yCenter - y2) <= radius * radius;\\n            } else {\\n                return x1 - xCenter <= radius;\\n            }\\n        } else if (xCenter > x2) {\\n            if (yCenter < y1) {\\n                return (xCenter - x2) * (xCenter - x2) + (yCenter - y1) * (yCenter - y1) <= radius * radius;\\n            } else if (yCenter > y2) {\\n                return (xCenter - x2) * (xCenter - x2) + (yCenter - y2) * (yCenter - y2) <= radius * radius;\\n            } else {\\n                return xCenter - x2 <= radius;\\n            }\\n        } else {\\n            if (yCenter < y1) {\\n                return y1 - yCenter <= radius;\\n            } else if (yCenter > y2) {\\n                return yCenter - y2 <= radius;\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        if (xCenter >= x1 && xCenter <= x2 && yCenter >= y1 && yCenter <= y2) {\\n            return true;\\n        }\\n        if (xCenter < x1) {\\n            if (yCenter < y1) {\\n                return (xCenter - x1) * (xCenter - x1) + (yCenter - y1) * (yCenter - y1) <= radius * radius;\\n            } else if (yCenter > y2) {\\n                return (xCenter - x1) * (xCenter - x1) + (yCenter - y2) * (yCenter - y2) <= radius * radius;\\n            } else {\\n                return x1 - xCenter <= radius;\\n            }\\n        } else if (xCenter > x2) {\\n            if (yCenter < y1) {\\n                return (xCenter - x2) * (xCenter - x2) + (yCenter - y1) * (yCenter - y1) <= radius * radius;\\n            } else if (yCenter > y2) {\\n                return (xCenter - x2) * (xCenter - x2) + (yCenter - y2) * (yCenter - y2) <= radius * radius;\\n            } else {\\n                return xCenter - x2 <= radius;\\n            }\\n        } else {\\n            if (yCenter < y1) {\\n                return y1 - yCenter <= radius;\\n            } else if (yCenter > y2) {\\n                return yCenter - y2 <= radius;\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061816,
                "title": "python-4-line-o-1-solution",
                "content": "```\\ndef checkOverlap(self, d: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:   \\n\\tcorners = [(x1, y1), (x2, y1), (x1, y2), (x2, y2)]\\n\\tif any((xc-x)**2+(yc-y)**2<=d**2 for x, y in corners):\\n\\t\\treturn True\\n\\treturn (x1<=xc<=x2 and y1-d<=yc<=y2+d) or (x1-d<=xc<=x2+d and y1<=yc<=y2)\\n```",
                "solutionTags": [],
                "code": "```\\ndef checkOverlap(self, d: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:   \\n\\tcorners = [(x1, y1), (x2, y1), (x1, y2), (x2, y2)]\\n\\tif any((xc-x)**2+(yc-y)**2<=d**2 for x, y in corners):\\n\\t\\treturn True\\n\\treturn (x1<=xc<=x2 and y1-d<=yc<=y2+d) or (x1-d<=xc<=x2+d and y1<=yc<=y2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2941751,
                "title": "python-beats-80-circle-and-square-intersect",
                "content": "```\\nimport itertools\\nclass Solution:\\n    def in_rect(corners: tuple[int, int, int, int], point: tuple[int, int]) -> bool:\\n        x1, y1, x2, y2 = corners\\n        x, y = point\\n        # Has to be included in both dimensions\\n        return x1 <= x and x <= x2 and y1 <= y and y <= y2\\n    def in_semi(semi: tuple[tuple[int, int], tuple[int, int]], r2: int, point: tuple[int, int]) -> bool:\\n        (right, cx), (up, cy) = semi\\n        x, y = point\\n        if right and x < cx or not right and x > cx:\\n            # Has to be to the right side of the quarter circle/s quarter-cutting radius vectors\\n            return False\\n        if up and y < cy or not up and y > cy:\\n            # Has to be to the right side of the quarter circle/s quarter-cutting radius vectors\\n            return False\\n        # Has to be close enough\\n        return (cx - x)**2 + (cy - y)**2 <= r2\\n    def checkOverlap(self, r: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        # They overlap if the circle\\'s center is in the rounded rectangle around the rectangle or if the\\n        # rectangle\\'s center is in some sort of other relation with the circle... let\\'s do the firs one\\n        horiz_cross = (x1 - r, y1, x2 + r, y2)\\n        vert_cross = (x1, y1 - r, x2, y2 + r)\\n        rects = [horiz_cross, vert_cross]\\n        semis = list(itertools.product(enumerate([x1, x2]), enumerate([y1, y2])))\\n        center = (xCenter, yCenter)\\n        r2 = r**2\\n        return (\\n            any([Solution.in_rect(rect, center) for rect in rects]) or\\n            any([Solution.in_semi(semi, r2, center) for semi in semis])\\n        )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport itertools\\nclass Solution:\\n    def in_rect(corners: tuple[int, int, int, int], point: tuple[int, int]) -> bool:\\n        x1, y1, x2, y2 = corners\\n        x, y = point\\n        # Has to be included in both dimensions\\n        return x1 <= x and x <= x2 and y1 <= y and y <= y2\\n    def in_semi(semi: tuple[tuple[int, int], tuple[int, int]], r2: int, point: tuple[int, int]) -> bool:\\n        (right, cx), (up, cy) = semi\\n        x, y = point\\n        if right and x < cx or not right and x > cx:\\n            # Has to be to the right side of the quarter circle/s quarter-cutting radius vectors\\n            return False\\n        if up and y < cy or not up and y > cy:\\n            # Has to be to the right side of the quarter circle/s quarter-cutting radius vectors\\n            return False\\n        # Has to be close enough\\n        return (cx - x)**2 + (cy - y)**2 <= r2\\n    def checkOverlap(self, r: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        # They overlap if the circle\\'s center is in the rounded rectangle around the rectangle or if the\\n        # rectangle\\'s center is in some sort of other relation with the circle... let\\'s do the firs one\\n        horiz_cross = (x1 - r, y1, x2 + r, y2)\\n        vert_cross = (x1, y1 - r, x2, y2 + r)\\n        rects = [horiz_cross, vert_cross]\\n        semis = list(itertools.product(enumerate([x1, x2]), enumerate([y1, y2])))\\n        center = (xCenter, yCenter)\\n        r2 = r**2\\n        return (\\n            any([Solution.in_rect(rect, center) for rect in rects]) or\\n            any([Solution.in_semi(semi, r2, center) for semi in semis])\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878843,
                "title": "simple-maths-solution",
                "content": "# Intuition\\nSample point from rectangle and check if in circle.\\n\\n# Approach\\nFind a point $(x, y)$ such that $x_1 <= x <= y_2$ and $y_1 <= y <= y_2$ (i.e. in rectangle) which is closest to the circle origin.\\nObviously, if $x_c$ lies within the range $[x_1, x_2]$ then $x = x_c$. If $x_c < x_1$, take $x=x_1$, conversely if $x_c > x_2$ take $x=x_2$. Do same for $y$.\\nFinally test if the point lies within the circle with $(x-x_c)^2+(y-y_c)^2<=r^2$.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkOverlap(self, r: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        x = xc if x1 <= xc <= x2 else x1 if xc < x1 else x2\\n        y = yc if y1 <= yc <= y2 else y1 if yc < y1 else y2\\n        return (x - xc) ** 2 + (y - yc) ** 2 <= r ** 2\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, r: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        x = xc if x1 <= xc <= x2 else x1 if xc < x1 else x2\\n        y = yc if y1 <= yc <= y2 else y1 if yc < y1 else y2\\n        return (x - xc) ** 2 + (y - yc) ** 2 <= r ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873776,
                "title": "cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        int a,b,ans;\\n        a= max(x1,min(xCenter,x2));\\n        b=max(y1,min(yCenter,y2));\\n        int x_o = xCenter-a;\\n        int y_o = yCenter-b; \\n        if((x_o*x_o+y_o*y_o)<=(radius)*radius)\\n        ans = true;\\n        else\\n        ans = false;\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        int a,b,ans;\\n        a= max(x1,min(xCenter,x2));\\n        b=max(y1,min(yCenter,y2));\\n        int x_o = xCenter-a;\\n        int y_o = yCenter-b; \\n        if((x_o*x_o+y_o*y_o)<=(radius)*radius)\\n        ans = true;\\n        else\\n        ans = false;\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748618,
                "title": "rust-find-closest-point-in-rectangle-to-circle-center",
                "content": "Then check whether the closest point is inside the circle.\\n```rust\\nimpl Solution {\\n    pub fn check_overlap(radius: i32, x_center: i32, y_center: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n        let x = x_center.max(x1).min(x2);\\n        let y = y_center.max(y1).min(y2);\\n        (x - x_center).pow(2) + (y - y_center).pow(2) <= radius.pow(2)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn check_overlap(radius: i32, x_center: i32, y_center: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n        let x = x_center.max(x1).min(x2);\\n        let y = y_center.max(y1).min(y2);\\n        (x - x_center).pow(2) + (y - y_center).pow(2) <= radius.pow(2)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2727816,
                "title": "python-solution-3-cases",
                "content": "```\\nclass Solution:\\n    # 3 cases:\\n    # 1. Rectangle has >= 1 corners inside the circle\\n    # 2. Rectangle has >= 1 edge inside the circle\\n    # 3. Rectangle has 4 edges enclosing the circle\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        corners = [[x1, y1], [x1, y2], [x2, y2], [x2, y1]]\\n        # Case 1\\n        for x, y in corners:\\n            if (x-xCenter)*(x-xCenter) + (y-yCenter)*(y-yCenter) <= radius*radius:\\n                return True\\n        # Case 2\\n        if (xCenter - radius <= x1 <= xCenter + radius) and y1 <= yCenter <= y2:\\n            return True\\n        if (xCenter - radius <= x2 <= xCenter + radius) and y1 <= yCenter <= y2:\\n            return True\\n        if (yCenter - radius <= y1 <= yCenter + radius) and x1 <= xCenter <= x2:\\n            return True\\n        if (yCenter - radius <= y2 <= yCenter + radius) and x1 <= xCenter <= x2:\\n            return True\\n        # Case 3\\n        if x1 <= xCenter <= x2 and y1 <= yCenter <= y2:\\n            return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # 3 cases:\\n    # 1. Rectangle has >= 1 corners inside the circle\\n    # 2. Rectangle has >= 1 edge inside the circle\\n    # 3. Rectangle has 4 edges enclosing the circle\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        corners = [[x1, y1], [x1, y2], [x2, y2], [x2, y1]]\\n        # Case 1\\n        for x, y in corners:\\n            if (x-xCenter)*(x-xCenter) + (y-yCenter)*(y-yCenter) <= radius*radius:\\n                return True\\n        # Case 2\\n        if (xCenter - radius <= x1 <= xCenter + radius) and y1 <= yCenter <= y2:\\n            return True\\n        if (xCenter - radius <= x2 <= xCenter + radius) and y1 <= yCenter <= y2:\\n            return True\\n        if (yCenter - radius <= y1 <= yCenter + radius) and x1 <= xCenter <= x2:\\n            return True\\n        if (yCenter - radius <= y2 <= yCenter + radius) and x1 <= xCenter <= x2:\\n            return True\\n        # Case 3\\n        if x1 <= xCenter <= x2 and y1 <= yCenter <= y2:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658600,
                "title": "my-kotlin-solution-with-time-o-1-and-space-o-1",
                "content": "Below is my solution in kotlin, it should be quite straight-forward.\\n\\n```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(1) and Space O(1);\\n     */\\n    fun checkOverlap(radius: Int, xCenter: Int, yCenter: Int, x1: Int, y1: Int, x2: Int, y2: Int): Boolean {\\n        val rangeOfX = x1..x2\\n        val xClosestToCenter = rangeOfX.findClosest(xCenter)\\n\\n        val rangeOfY = y1..y2\\n        val yClosestToCenter = rangeOfY.findClosest(yCenter)\\n\\n        return square(xClosestToCenter - xCenter) + square(yClosestToCenter - yCenter) <= square(radius)\\n    }\\n\\n    private fun IntRange.findClosest(target: Int): Int {\\n        return when {\\n            target < first -> first\\n            target > last -> last\\n            else -> target\\n        }\\n    }\\n\\n    private fun square(i: Int) = i * i\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(1) and Space O(1);\\n     */\\n    fun checkOverlap(radius: Int, xCenter: Int, yCenter: Int, x1: Int, y1: Int, x2: Int, y2: Int): Boolean {\\n        val rangeOfX = x1..x2\\n        val xClosestToCenter = rangeOfX.findClosest(xCenter)\\n\\n        val rangeOfY = y1..y2\\n        val yClosestToCenter = rangeOfY.findClosest(yCenter)\\n\\n        return square(xClosestToCenter - xCenter) + square(yClosestToCenter - yCenter) <= square(radius)\\n    }\\n\\n    private fun IntRange.findClosest(target: Int): Int {\\n        return when {\\n            target < first -> first\\n            target > last -> last\\n            else -> target\\n        }\\n    }\\n\\n    private fun square(i: Int) = i * i\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540813,
                "title": "java-runtime-0-ms-faster-than-100",
                "content": "```java\\nclass Solution {\\n    public boolean checkOverlap(\\n            int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        // Find the closest point to the circle within the rectangle\\n        int closestX = clamp(xCenter, x1, x2);\\n        int closestY = clamp(yCenter, y1, y2);\\n        // Calculate the distance between the circle\\'s center and this closest point\\n        int distanceX = xCenter - closestX;\\n        int distanceY = yCenter - closestY;\\n        // If the distance is less than the circle\\'s radius, an intersection occurs\\n        int distanceSquared = distanceX * distanceX + distanceY * distanceY;\\n        return distanceSquared <= radius * radius;\\n    }\\n\\n    private int clamp(int val, int min, int max) {\\n        return Math.max(min, Math.min(max, val));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Geometry"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean checkOverlap(\\n            int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        // Find the closest point to the circle within the rectangle\\n        int closestX = clamp(xCenter, x1, x2);\\n        int closestY = clamp(yCenter, y1, y2);\\n        // Calculate the distance between the circle\\'s center and this closest point\\n        int distanceX = xCenter - closestX;\\n        int distanceY = yCenter - closestY;\\n        // If the distance is less than the circle\\'s radius, an intersection occurs\\n        int distanceSquared = distanceX * distanceX + distanceY * distanceY;\\n        return distanceSquared <= radius * radius;\\n    }\\n\\n    private int clamp(int val, int min, int max) {\\n        return Math.max(min, Math.min(max, val));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462741,
                "title": "c-solution-using-if-else-control-statements",
                "content": "```\\n\\n\\nbool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2){\\n    int xParam = xCenter;\\n    int yParam = yCenter;\\n    \\n    if(xCenter<=x1){\\n        xParam = x1;\\n    }\\n    else if(xCenter>=x2){\\n        xParam = x2;\\n    }\\n    else{\\n        xParam = xCenter;\\n    }\\n    if(yCenter<=y1){\\n        yParam = y1;\\n    }\\n    else if(yCenter>=y2){\\n        yParam = y2;\\n    }\\n    else{\\n        yParam = yCenter;\\n    }\\n    \\n    int xDistance = xCenter-xParam;\\n    int yDistance = yCenter-yParam;\\n    \\n    int total = sqrt((xDistance*xDistance) + (yDistance*yDistance));\\n    \\n    return total<=radius;\\n    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nbool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2){\\n    int xParam = xCenter;\\n    int yParam = yCenter;\\n    \\n    if(xCenter<=x1){\\n        xParam = x1;\\n    }\\n    else if(xCenter>=x2){\\n        xParam = x2;\\n    }\\n    else{\\n        xParam = xCenter;\\n    }\\n    if(yCenter<=y1){\\n        yParam = y1;\\n    }\\n    else if(yCenter>=y2){\\n        yParam = y2;\\n    }\\n    else{\\n        yParam = yCenter;\\n    }\\n    \\n    int xDistance = xCenter-xParam;\\n    int yDistance = yCenter-yParam;\\n    \\n    int total = sqrt((xDistance*xDistance) + (yDistance*yDistance));\\n    \\n    return total<=radius;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2335399,
                "title": "intuitive-math-do-as-hints-say",
                "content": "```\\nclass Solution {\\n    \\n    int shortest_coor(int radius, int xCenter, int x1, int x2) {\\n        \\n        if (x1 <= xCenter and xCenter <= x2)\\n            return 0;\\n        \\n        int px = 0;\\n        if (xCenter + radius <= x1) {\\n            px = abs(x1 - xCenter);\\n        } else if (xCenter - radius >= x2) {\\n            px = abs(x2 - xCenter);\\n        } else {\\n            px = min(abs(x1 - xCenter), abs(x2 - xCenter));\\n        }\\n        \\n        return px;\\n    }\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        \\n        int px = shortest_coor(radius, xCenter, x1, x2);\\n        int py = shortest_coor(radius, yCenter, y1, y2);\\n        \\n        int dis = pow(px, 2) + pow(py, 2);\\n        int r_square = pow(radius, 2);\\n        return dis <= r_square;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int shortest_coor(int radius, int xCenter, int x1, int x2) {\\n        \\n        if (x1 <= xCenter and xCenter <= x2)\\n            return 0;\\n        \\n        int px = 0;\\n        if (xCenter + radius <= x1) {\\n            px = abs(x1 - xCenter);\\n        } else if (xCenter - radius >= x2) {\\n            px = abs(x2 - xCenter);\\n        } else {\\n            px = min(abs(x1 - xCenter), abs(x2 - xCenter));\\n        }\\n        \\n        return px;\\n    }\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        \\n        int px = shortest_coor(radius, xCenter, x1, x2);\\n        int py = shortest_coor(radius, yCenter, y1, y2);\\n        \\n        int dis = pow(px, 2) + pow(py, 2);\\n        int r_square = pow(radius, 2);\\n        return dis <= r_square;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207660,
                "title": "most-optimal-solution",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return (xCenter - min(max(x1, xCenter), x2)) ** 2 + (yCenter - min(max(y1, yCenter), y2)) ** 2 <= radius ** 2\\n```",
                "solutionTags": [
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return (xCenter - min(max(x1, xCenter), x2)) ** 2 + (yCenter - min(max(y1, yCenter), y2)) ** 2 <= radius ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146664,
                "title": "clean-javascript-solution-easy-to-understand",
                "content": "***Before Optimization***\\n\\n```\\nfunction compare(v, min, max) {\\n\\tif (v < min) return min\\n\\tif (max < v) return max\\n\\treturn v\\n}\\n\\nfunction checkOverlap(r, c1, c2, x1, y1, x2, y2) {\\n    const [b1, b2] = [compare(c1, x1, x2), compare(c2, y1, y2)]\\n    return (c1 - b1) ** 2 + (c2 - b2) ** 2 <= r ** 2\\n}\\n```\\n\\n***After Optimization***\\n\\n```\\nfunction checkOverlap(r, c1, c2, x1, y1, x2, y2) {\\n    const [d1, d2] = [c1 -  Math.max(x1, Math.min(x2, c1)), c2 - Math.max(y1, Math.min(y2, c2))]\\n    return (d1 ** 2) + (d2 ** 2) <= r ** 2\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction compare(v, min, max) {\\n\\tif (v < min) return min\\n\\tif (max < v) return max\\n\\treturn v\\n}\\n\\nfunction checkOverlap(r, c1, c2, x1, y1, x2, y2) {\\n    const [b1, b2] = [compare(c1, x1, x2), compare(c2, y1, y2)]\\n    return (c1 - b1) ** 2 + (c2 - b2) ** 2 <= r ** 2\\n}\\n```\n```\\nfunction checkOverlap(r, c1, c2, x1, y1, x2, y2) {\\n    const [d1, d2] = [c1 -  Math.max(x1, Math.min(x2, c1)), c2 - Math.max(y1, Math.min(y2, c2))]\\n    return (d1 ** 2) + (d2 ** 2) <= r ** 2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2137686,
                "title": "brute-force-c-by-comparing-distance-runtime-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n \\n    // According to constraint or question x1 < x2 and y1 < y2\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        \\n        // for xc there are 3 cases:\\n        // 1. xc < (x1 < x2) : x-coordinate of Center less than both x1, x2\\n        // 2. (x1) < xc < (x2) : x-coordinate of Center lies between both x1, x2\\n        // 3. (x1 < x2) < xc : x-coordinate of Center greater than both x1, x2\\n        \\n        // for x\\n        int closest_x = xc; \\n        if (xc < x1)\\n            closest_x = x1;\\n        else \\n        {\\n            if (xc > x2)  \\n                closest_x = x2;\\n            else \\n                closest_x = xc;\\n        }\\n        \\n        // for y\\n        int closest_y = yc; \\n        if (yc < y1)\\n            closest_y = y1;\\n        else \\n        {\\n            if (yc > y2)  \\n                closest_y = y2;\\n            else \\n                closest_y = yc;\\n        }\\n    \\n        int dx = closest_x - xc;\\n        int dy = closest_y - yc;\\n        // compare distance\\n        return dx*dx + dy*dy <= r*r;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n \\n    // According to constraint or question x1 < x2 and y1 < y2\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        \\n        // for xc there are 3 cases:\\n        // 1. xc < (x1 < x2) : x-coordinate of Center less than both x1, x2\\n        // 2. (x1) < xc < (x2) : x-coordinate of Center lies between both x1, x2\\n        // 3. (x1 < x2) < xc : x-coordinate of Center greater than both x1, x2\\n        \\n        // for x\\n        int closest_x = xc; \\n        if (xc < x1)\\n            closest_x = x1;\\n        else \\n        {\\n            if (xc > x2)  \\n                closest_x = x2;\\n            else \\n                closest_x = xc;\\n        }\\n        \\n        // for y\\n        int closest_y = yc; \\n        if (yc < y1)\\n            closest_y = y1;\\n        else \\n        {\\n            if (yc > y2)  \\n                closest_y = y2;\\n            else \\n                closest_y = yc;\\n        }\\n    \\n        int dx = closest_x - xc;\\n        int dy = closest_y - yc;\\n        // compare distance\\n        return dx*dx + dy*dy <= r*r;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127404,
                "title": "c-maths-based-solution-with-explanation-o-1-time-o-1-time",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        //nearest_x = x1 when xCenter<x1<x2 (OR) x2 when x1<x2<xCenter (OR) xCenter when x1<xCenter<x2\\n        int nearest_x = (xCenter < x1) ? x1 : (xCenter > x2) ? x2 : xCenter;\\n        //same logic for nearest_y as in nearest_x\\n        int nearest_y = (yCenter < y1) ? y1 : (yCenter > y2) ? y2 : yCenter;\\n        int dist_x = xCenter - nearest_x, dist_y = yCenter - nearest_y;\\n        return dist_x * dist_x + dist_y * dist_y <= radius * radius;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        //nearest_x = x1 when xCenter<x1<x2 (OR) x2 when x1<x2<xCenter (OR) xCenter when x1<xCenter<x2\\n        int nearest_x = (xCenter < x1) ? x1 : (xCenter > x2) ? x2 : xCenter;\\n        //same logic for nearest_y as in nearest_x\\n        int nearest_y = (yCenter < y1) ? y1 : (yCenter > y2) ? y2 : yCenter;\\n        int dist_x = xCenter - nearest_x, dist_y = yCenter - nearest_y;\\n        return dist_x * dist_x + dist_y * dist_y <= radius * radius;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077638,
                "title": "java-100-faster-one-liner",
                "content": "```\\nclass Solution\\n{\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2)\\n    {\\n        return Math.pow(Math.max(x1,Math.min(x2,xCenter))-xCenter,2)\\n            + Math.pow(Math.max(y1,Math.min(y2,yCenter))-yCenter,2) <= radius*radius;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2)\\n    {\\n        return Math.pow(Math.max(x1,Math.min(x2,xCenter))-xCenter,2)\\n            + Math.pow(Math.max(y1,Math.min(y2,yCenter))-yCenter,2) <= radius*radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039160,
                "title": "python-following-the-hints",
                "content": "\\t\\t# offset x\\'s and y\\'s so that the center of the circle is (0,0)\\n        x1 -= xCenter\\n        x2 -= xCenter\\n        y1 -= yCenter\\n        y2 -= yCenter\\n        \\n        # find the point (xMin, yMin) that is closest to the origin:\\n        if x1 <= 0 and x2 >=0:\\n            xMin = 0\\n        elif x1 >= 0:\\n            xMin = min(x1, x2)     # = x1\\n        else:\\n            xMin = max(x1, x2)     # = x2\\n        \\n        if y1 <= 0 and y2 >= 0:\\n            yMin = 0        \\n        elif y1 >= 0:\\n            yMin = min(y1, y2)         # = y1\\n        else:\\n            yMin = max(y1, y2)      # = y2\\n            \\n        # return whether or not that point is inside a circle\\n        # of radius R:\\n        return(xMin**2 + yMin**2 <= radius**2)",
                "solutionTags": [],
                "code": "\\t\\t# offset x\\'s and y\\'s so that the center of the circle is (0,0)\\n        x1 -= xCenter\\n        x2 -= xCenter\\n        y1 -= yCenter\\n        y2 -= yCenter\\n        \\n        # find the point (xMin, yMin) that is closest to the origin:\\n        if x1 <= 0 and x2 >=0:\\n            xMin = 0\\n        elif x1 >= 0:\\n            xMin = min(x1, x2)     # = x1\\n        else:\\n            xMin = max(x1, x2)     # = x2\\n        \\n        if y1 <= 0 and y2 >= 0:\\n            yMin = 0        \\n        elif y1 >= 0:\\n            yMin = min(y1, y2)         # = y1\\n        else:\\n            yMin = max(y1, y2)      # = y2\\n            \\n        # return whether or not that point is inside a circle\\n        # of radius R:\\n        return(xMin**2 + yMin**2 <= radius**2)",
                "codeTag": "Unknown"
            },
            {
                "id": 1827454,
                "title": "c-100-faster-code",
                "content": "class Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        \\n        if(xCenter >= x1 && xCenter <= x2 || yCenter >= y1 && yCenter <= y2){\\n            if(xCenter < x1-radius || xCenter > x2+radius || yCenter < y1-radius || yCenter > y2+radius ) return false;\\n            else return true;\\n        } else{\\n            int xx1 = xCenter>x1?x2:xCenter;\\n            int xx2 = xCenter>x1?xCenter:x1;\\n            \\n            int yy1 = yCenter>y1?y2:yCenter;\\n            int yy2 = yCenter>y1?yCenter:y1;\\n            \\n            if(sqrt((xx2-xx1)*(xx2-xx1) + (yy2-yy1)*(yy2-yy1)) > radius) return false;\\n            else return true;\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        \\n        if(xCenter >= x1 && xCenter <= x2 || yCenter >= y1 && yCenter <= y2){\\n            if(xCenter < x1-radius || xCenter > x2+radius || yCenter < y1-radius || yCenter > y2+radius ) return false;\\n            else return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1806644,
                "title": "katttttttttttt",
                "content": ".......//////////////////",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1781256,
                "title": "javascript-solution-math-geometry",
                "content": "In order to derive the closest x and y points of the square from the circle, we use what is called a `clamp` function. Afterwards, we calculate the Euclidan Distance. We can slightly optimize the calculation by using the Pythagorean Theorem.\\n\\n```\\nvar checkOverlap = function(radius, xCenter, yCenter, x1, y1, x2, y2) {\\n    const closestX = clamp(xCenter, x1, x2);\\n    const closestY = clamp(yCenter, y1, y2);\\n    \\n    const dist = (xCenter - closestX)**2 + (yCenter - closestY)**2;\\n    \\n    return dist <= radius * radius ? true : false;\\n    \\n    \\n    function clamp(val, min, max) {\\n        if (val < min) return min;\\n        if (max < val) return max;\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar checkOverlap = function(radius, xCenter, yCenter, x1, y1, x2, y2) {\\n    const closestX = clamp(xCenter, x1, x2);\\n    const closestY = clamp(yCenter, y1, y2);\\n    \\n    const dist = (xCenter - closestX)**2 + (yCenter - closestY)**2;\\n    \\n    return dist <= radius * radius ? true : false;\\n    \\n    \\n    function clamp(val, min, max) {\\n        if (val < min) return min;\\n        if (max < val) return max;\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1682986,
                "title": "golang-o-1-time-mem-easy-to-understand",
                "content": "```\\nfunc checkOverlap(radius int, xCenter int, yCenter int, x1 int, y1 int, x2 int, y2 int) bool {\\n    if xCenter <= x1 {\\n        if yCenter <= y1 {\\n            return sqr(xCenter - x1) + sqr(yCenter - y1) <= sqr(radius)\\n        }\\n        \\n        if yCenter >= y2 {\\n            return sqr(xCenter - x1) + sqr(yCenter - y2) <= sqr(radius)\\n        }\\n        \\n        return x1 - xCenter <= radius\\n    }    \\n    \\n    if xCenter >= x2 {\\n        if yCenter <= y1 {\\n            return sqr(xCenter - x2) + sqr(yCenter - y1) <= sqr(radius)\\n        }\\n        \\n        if yCenter >= y2 {\\n            return sqr(xCenter - x2) + sqr(yCenter - y2) <= sqr(radius)\\n        }\\n        \\n        return xCenter - x2 <= radius\\n    }\\n    \\n    if yCenter <= y1 {\\n        return y1 - yCenter <= radius\\n    } \\n    \\n    if yCenter >= y2 {\\n        return yCenter - y2 <= radius\\n    }\\n    \\n    return true \\n}\\n\\nfunc sqr(a int) int {\\n    return a * a\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc checkOverlap(radius int, xCenter int, yCenter int, x1 int, y1 int, x2 int, y2 int) bool {\\n    if xCenter <= x1 {\\n        if yCenter <= y1 {\\n            return sqr(xCenter - x1) + sqr(yCenter - y1) <= sqr(radius)\\n        }\\n        \\n        if yCenter >= y2 {\\n            return sqr(xCenter - x1) + sqr(yCenter - y2) <= sqr(radius)\\n        }\\n        \\n        return x1 - xCenter <= radius\\n    }    \\n    \\n    if xCenter >= x2 {\\n        if yCenter <= y1 {\\n            return sqr(xCenter - x2) + sqr(yCenter - y1) <= sqr(radius)\\n        }\\n        \\n        if yCenter >= y2 {\\n            return sqr(xCenter - x2) + sqr(yCenter - y2) <= sqr(radius)\\n        }\\n        \\n        return xCenter - x2 <= radius\\n    }\\n    \\n    if yCenter <= y1 {\\n        return y1 - yCenter <= radius\\n    } \\n    \\n    if yCenter >= y2 {\\n        return yCenter - y2 <= radius\\n    }\\n    \\n    return true \\n}\\n\\nfunc sqr(a int) int {\\n    return a * a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640836,
                "title": "python-math-solution",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        if x_center + radius < x1 or x_center - radius > x2 or y_center + radius < y1 or y_center - radius > y2:\\n            return False\\n        \\n        distance = ((x1 + x2) / 2 - x_center)**2 + ((y1 + y2) / 2 - y_center)**2\\n        d1 = radius**2\\n        d2 = ((x1 - x2)**2 + (y1 - y2)**2) / 4\\n        \\n        return sqrt(distance) <= sqrt(d1) + sqrt(d2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        if x_center + radius < x1 or x_center - radius > x2 or y_center + radius < y1 or y_center - radius > y2:\\n            return False\\n        \\n        distance = ((x1 + x2) / 2 - x_center)**2 + ((y1 + y2) / 2 - y_center)**2\\n        d1 = radius**2\\n        d2 = ((x1 - x2)**2 + (y1 - y2)**2) / 4\\n        \\n        return sqrt(distance) <= sqrt(d1) + sqrt(d2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489055,
                "title": "partitioning-all-areas-in-9-cases",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, r: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        if xc >= x1 and xc <= x2 and yc >= y1 and yc <= y2:\\n            return True\\n        \\n        elif xc > x2:\\n            if yc > y2:\\n                return r**2 >= (xc-x2)**2 + (yc-y2)**2\\n            elif yc >= y1 and yc < y2:\\n                return r >= xc-x2\\n            else: # yc < y1\\n                return r**2 >= (xc-x2)**2 + (yc-y1)**2\\n        elif xc <= x1:\\n            if yc > y2:\\n                return r**2 >= (xc-x1)**2 + (yc-y2)**2\\n            elif yc >= y1 and yc < y2:\\n                return r >= x1-xc\\n            else: # yc < y1\\n                return r**2 >= (xc-x1)**2 + (yc-y1)**2\\n        elif xc > x1 and xc < x2 and yc > y2:\\n            \\n            return r >= yc -y2\\n        else: \\n            return r >= y1-yc\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, r: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        if xc >= x1 and xc <= x2 and yc >= y1 and yc <= y2:\\n            return True\\n        \\n        elif xc > x2:\\n            if yc > y2:\\n                return r**2 >= (xc-x2)**2 + (yc-y2)**2\\n            elif yc >= y1 and yc < y2:\\n                return r >= xc-x2\\n            else: # yc < y1\\n                return r**2 >= (xc-x2)**2 + (yc-y1)**2\\n        elif xc <= x1:\\n            if yc > y2:\\n                return r**2 >= (xc-x1)**2 + (yc-y2)**2\\n            elif yc >= y1 and yc < y2:\\n                return r >= x1-xc\\n            else: # yc < y1\\n                return r**2 >= (xc-x1)**2 + (yc-y1)**2\\n        elif xc > x1 and xc < x2 and yc > y2:\\n            \\n            return r >= yc -y2\\n        else: \\n            return r >= y1-yc\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421857,
                "title": "c-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/79b43106-9254-4dc7-85b0-4e11db56e8f7_1629744775.83113.png)\\n<b>Idea</b> \\nThe center of our circle lies in rectange `r1` or rectange `r2` or any of the 4 circles. The radius of each of the 4 circles is `r` ( the radius of the circle given in question ). The bottom left corner of the red rectange is `(x1,y1)` and top right corner of red rectangle is `(x2,y2)`.\\n\\n```\\nclass Solution {\\npublic:\\nbool ok(int r,int x,int y,int x1,int y1){\\n    return (r*r>=(x-x1)*(x-x1)+(y-y1)*(y-y1));\\n}\\n\\nbool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) { \\n    int newX1=x1-r,newY1=y1-r,newX2=x2+r,newY2=y2+r;\\n    bool inR1 = (x>=x1 && x<=x2 && y>=newY1 && y<=newY2);\\n    bool inR2 = (x>=newX1 && x<=newX2 && y>=y1 && y<=y2); \\n    bool inCircle = ok(r,x,y,x1,y1) || ok(r,x,y,x1,y2) || ok(r,x,y,x2,y1) || ok(r,x,y,x2,y2);\\n    return inR1 || inR2 || inCircle;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nbool ok(int r,int x,int y,int x1,int y1){\\n    return (r*r>=(x-x1)*(x-x1)+(y-y1)*(y-y1));\\n}\\n\\nbool checkOverlap(int r, int x, int y, int x1, int y1, int x2, int y2) { \\n    int newX1=x1-r,newY1=y1-r,newX2=x2+r,newY2=y2+r;\\n    bool inR1 = (x>=x1 && x<=x2 && y>=newY1 && y<=newY2);\\n    bool inR2 = (x>=newX1 && x<=newX2 && y>=y1 && y<=y2); \\n    bool inCircle = ok(r,x,y,x1,y1) || ok(r,x,y,x1,y2) || ok(r,x,y,x2,y1) || ok(r,x,y,x2,y2);\\n    return inR1 || inR2 || inCircle;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178944,
                "title": "ugly-rust-solution-100-100",
                "content": "```\\nimpl Solution {\\n    pub fn check_overlap(radius: i32, x_center: i32, y_center: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n        f(radius, x1 - x_center, y1 - y_center, x2 - x_center, y2 - y_center)\\n    }\\n}\\n\\nfn f(r: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n    in_circ(r, x1, y1) || in_circ(r, x1, y2) ||\\n      in_circ(r, x2, y1) || in_circ(r, x2, y2) || \\n    (x1 <= 0 && x2 >= 0 && y1 <= 0 && y2 >= 0) ||\\n    (x1.abs() <= r && y1 <= 0 && y2 >= 0) ||\\n    (x2.abs() <= r && y1 <= 0 && y2 >= 0) ||\\n    (y1.abs() <= r && x1 <= 0 && x2 >= 0) ||\\n    (y2.abs() <= r && x1 <= 0 && x2 >= 0)\\n}\\n\\nfn in_circ(r: i32, x: i32, y: i32) -> bool {\\n    x*x + y*y <= r*r\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn check_overlap(radius: i32, x_center: i32, y_center: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n        f(radius, x1 - x_center, y1 - y_center, x2 - x_center, y2 - y_center)\\n    }\\n}\\n\\nfn f(r: i32, x1: i32, y1: i32, x2: i32, y2: i32) -> bool {\\n    in_circ(r, x1, y1) || in_circ(r, x1, y2) ||\\n      in_circ(r, x2, y1) || in_circ(r, x2, y2) || \\n    (x1 <= 0 && x2 >= 0 && y1 <= 0 && y2 >= 0) ||\\n    (x1.abs() <= r && y1 <= 0 && y2 >= 0) ||\\n    (x2.abs() <= r && y1 <= 0 && y2 >= 0) ||\\n    (y1.abs() <= r && x1 <= 0 && x2 >= 0) ||\\n    (y2.abs() <= r && x1 <= 0 && x2 >= 0)\\n}\\n\\nfn in_circ(r: i32, x: i32, y: i32) -> bool {\\n    x*x + y*y <= r*r\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1123495,
                "title": "python-solution-faster-than-100-intersect-circle-with-four-lines",
                "content": "Two cases when the circle touches the rectangle\\n* Circle is completely interior to the rectangle\\n* Or the rectangle has one side which interesect it\\n\\nFirst, recenter all coordinates with respect to circle center.\\n\\nThen if x1x2 <= 0 and y1y2 <= 0, the rectangle goes over the origin (which covers all cases when circle is interior).\\n\\nOtherwise for each edge check the closest point (will either be the projection of the center onto the edge, or the two end points).\\n\\nFinally, check for closest distance of remaining four points.\\n\\nKeep all arithmetic integral for speed.\\n\\n```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        x1, x2 = x1-x_center, x2-x_center\\n        y1, y2 = y1-y_center, y2-y_center\\n\\n\\t\\tif (x1*x2 <= 0 and y1*y2 <= 0):\\n            return True\\n        \\n        line_list = [\\n            [y1, x2, y1, x1],\\n            [y2, x2, y2, x1],\\n            [x1, y1, x1, y2],\\n            [x2, y1, x2, y2],\\n        ]\\n        \\n        def proj(l):\\n            x1, y1, x2, y2 = l\\n            if y1 * y2 < 0:\\n                return (x1, 0)\\n            if abs(y1) < abs(y2):\\n                return (x1, y1)\\n            return (x1, y2)\\n        \\n        check_points = [proj(l) for l in line_list]\\n       \\n        r2 = radius**2\\n        for p in check_points:\\n            print(p[0]**2 + p[1]**2)\\n            if p[0]**2 + p[1]**2 <= r2:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        x1, x2 = x1-x_center, x2-x_center\\n        y1, y2 = y1-y_center, y2-y_center\\n\\n\\t\\tif (x1*x2 <= 0 and y1*y2 <= 0):\\n            return True\\n        \\n        line_list = [\\n            [y1, x2, y1, x1],\\n            [y2, x2, y2, x1],\\n            [x1, y1, x1, y2],\\n            [x2, y1, x2, y2],\\n        ]\\n        \\n        def proj(l):\\n            x1, y1, x2, y2 = l\\n            if y1 * y2 < 0:\\n                return (x1, 0)\\n            if abs(y1) < abs(y2):\\n                return (x1, y1)\\n            return (x1, y2)\\n        \\n        check_points = [proj(l) for l in line_list]\\n       \\n        r2 = radius**2\\n        for p in check_points:\\n            print(p[0]**2 + p[1]**2)\\n            if p[0]**2 + p[1]**2 <= r2:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121889,
                "title": "js-solution",
                "content": "```\\n/**\\n * @param {number} radius\\n * @param {number} x_center\\n * @param {number} y_center\\n * @param {number} x1\\n * @param {number} y1\\n * @param {number} x2\\n * @param {number} y2\\n * @return {boolean}\\n */\\nvar checkOverlap = function(radius, xCenter, yCenter, x1, y1, x2, y2) {\\n    function getDistanceToHorizontal(xA, xB, y) {\\n        let distance3 = Infinity\\n        if (xA < xCenter && xCenter < xB) {\\n            distance3 = (yCenter - y) ** 2\\n            return distance3\\n        }\\n        \\n        const distance1 = (xCenter - xA) ** 2 + (yCenter - y) ** 2\\n        const distance2 = (xCenter - xB) ** 2 + (yCenter - y) ** 2\\n        \\n        let result = Math.min(distance1, distance2)\\n        return result\\n    }\\n    \\n    function getDistanceToVertical(yA, yB, x) {\\n        let distance3 = Infinity\\n        if (yA < yCenter && yCenter < yB) {\\n            distance3 = (xCenter - x) ** 2\\n            return distance3\\n        }\\n    \\n        const distance1 = (yCenter - yA) ** 2 + (xCenter - x) ** 2\\n        const distance2 = (yCenter - yB) ** 2 + (xCenter - x) ** 2\\n        \\n        let result = Math.min(distance1, distance2)\\n        return result\\n    }\\n    \\n    \\n    // check whether circle\\'s center is inside rectangle\\n    if ((x1 < xCenter && xCenter < x2) && (y1 < yCenter && yCenter < y2)) {\\n        return true\\n    }\\n    \\n    \\n    // check whether circle\\'s radius can reach rectangle\\n    const distanceValve = radius ** 2\\n    if (getDistanceToHorizontal(x1, x2, y1) <= distanceValve)   return true\\n    if (getDistanceToHorizontal(x1, x2, y2) <= distanceValve)   return true\\n    if (getDistanceToVertical(y1, y2, x1) <= distanceValve) return true\\n    if (getDistanceToVertical(y1, y2, x2) <= distanceValve) return true\\n    \\n    \\n    return false\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} radius\\n * @param {number} x_center\\n * @param {number} y_center\\n * @param {number} x1\\n * @param {number} y1\\n * @param {number} x2\\n * @param {number} y2\\n * @return {boolean}\\n */\\nvar checkOverlap = function(radius, xCenter, yCenter, x1, y1, x2, y2) {\\n    function getDistanceToHorizontal(xA, xB, y) {\\n        let distance3 = Infinity\\n        if (xA < xCenter && xCenter < xB) {\\n            distance3 = (yCenter - y) ** 2\\n            return distance3\\n        }\\n        \\n        const distance1 = (xCenter - xA) ** 2 + (yCenter - y) ** 2\\n        const distance2 = (xCenter - xB) ** 2 + (yCenter - y) ** 2\\n        \\n        let result = Math.min(distance1, distance2)\\n        return result\\n    }\\n    \\n    function getDistanceToVertical(yA, yB, x) {\\n        let distance3 = Infinity\\n        if (yA < yCenter && yCenter < yB) {\\n            distance3 = (xCenter - x) ** 2\\n            return distance3\\n        }\\n    \\n        const distance1 = (yCenter - yA) ** 2 + (xCenter - x) ** 2\\n        const distance2 = (yCenter - yB) ** 2 + (xCenter - x) ** 2\\n        \\n        let result = Math.min(distance1, distance2)\\n        return result\\n    }\\n    \\n    \\n    // check whether circle\\'s center is inside rectangle\\n    if ((x1 < xCenter && xCenter < x2) && (y1 < yCenter && yCenter < y2)) {\\n        return true\\n    }\\n    \\n    \\n    // check whether circle\\'s radius can reach rectangle\\n    const distanceValve = radius ** 2\\n    if (getDistanceToHorizontal(x1, x2, y1) <= distanceValve)   return true\\n    if (getDistanceToHorizontal(x1, x2, y2) <= distanceValve)   return true\\n    if (getDistanceToVertical(y1, y2, x1) <= distanceValve) return true\\n    if (getDistanceToVertical(y1, y2, x2) <= distanceValve) return true\\n    \\n    \\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1083255,
                "title": "python3-faster-than-97-8-of-submissions",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        import math\\n        x_center_sq = x1 + (x2-x1)/2\\n        y_center_sq = y1 + (y2-y1)/2\\n        x3 = x2\\n        y3 = y1\\n        x4 = x1\\n        y4 = y2\\n        if y2-y1 <= 2*radius:\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == 0:\\n                if x1 -x_center <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > 0 and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < math.pi/2:\\n                if math.sqrt((x1-x_center)**2+(y1-y_center)**2) <= radius or (y1 - y_center <= radius and x1 - x_center <= radius):\\n                    return 1\\n                elif x_center_sq - x_center < radius:\\n                    if y1 - y_center <= radius:\\n                        return 1\\n                elif y_center_sq - y_center < radius:\\n                    if x1 - x_center <= radius:\\n                        return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == math.pi/2:\\n                if y1 - y_center <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > math.pi/2 and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < math.pi:\\n                if math.sqrt((x3-x_center)**2+(y3-y_center)**2) <= radius:\\n                    return 1\\n                elif x_center - x_center_sq < radius:\\n                    if y1 - y_center <= radius:\\n                        return 1\\n                elif y_center_sq - y_center < radius:\\n                    if x_center - x2 <= radius:\\n                        return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == math.pi:\\n                if x_center - x2 <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > -math.pi and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < -0.5*math.pi:\\n                if math.sqrt((x2-x_center)**2+(y2-y_center)**2) <= radius or (y_center - y4 <= radius and x_center - x2 <= radius):\\n                    return 1\\n                elif x_center - x_center_sq < radius:\\n                    if y_center - y2 <= radius:\\n                        return 1\\n                elif y_center - y2 < radius:\\n                    if x_center - x2 <= radius:\\n                        return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == -0.5*math.pi:\\n                if y_center -y2 <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > -0.5*math.pi and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < 0:\\n                if math.sqrt((x4-x_center)**2+(y4-y_center)**2) <= radius or (y_center - y4 <= radius and x4-x_center <= radius):\\n                    return 1\\n                elif x_center_sq - x_center < radius:\\n                    if y_center - y2 <= radius:\\n                        return 1\\n                elif y_center - y_center_sq < radius:\\n                    if x1 - x_center <= radius:\\n                        return 1\\n        else:\\n            x_right = x_center + radius\\n            y_top = y_center + radius\\n            if x_right >= x1 and x_right <= x2 + 2*radius and y_top >= y1 and y_top <= y2 +2*radius:\\n                return 1\\n        return 0\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        import math\\n        x_center_sq = x1 + (x2-x1)/2\\n        y_center_sq = y1 + (y2-y1)/2\\n        x3 = x2\\n        y3 = y1\\n        x4 = x1\\n        y4 = y2\\n        if y2-y1 <= 2*radius:\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == 0:\\n                if x1 -x_center <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > 0 and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < math.pi/2:\\n                if math.sqrt((x1-x_center)**2+(y1-y_center)**2) <= radius or (y1 - y_center <= radius and x1 - x_center <= radius):\\n                    return 1\\n                elif x_center_sq - x_center < radius:\\n                    if y1 - y_center <= radius:\\n                        return 1\\n                elif y_center_sq - y_center < radius:\\n                    if x1 - x_center <= radius:\\n                        return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == math.pi/2:\\n                if y1 - y_center <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > math.pi/2 and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < math.pi:\\n                if math.sqrt((x3-x_center)**2+(y3-y_center)**2) <= radius:\\n                    return 1\\n                elif x_center - x_center_sq < radius:\\n                    if y1 - y_center <= radius:\\n                        return 1\\n                elif y_center_sq - y_center < radius:\\n                    if x_center - x2 <= radius:\\n                        return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == math.pi:\\n                if x_center - x2 <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > -math.pi and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < -0.5*math.pi:\\n                if math.sqrt((x2-x_center)**2+(y2-y_center)**2) <= radius or (y_center - y4 <= radius and x_center - x2 <= radius):\\n                    return 1\\n                elif x_center - x_center_sq < radius:\\n                    if y_center - y2 <= radius:\\n                        return 1\\n                elif y_center - y2 < radius:\\n                    if x_center - x2 <= radius:\\n                        return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) == -0.5*math.pi:\\n                if y_center -y2 <= radius:\\n                    return 1\\n            if math.atan2(y_center_sq-y_center,x_center_sq-x_center) > -0.5*math.pi and math.atan2(y_center_sq-y_center,x_center_sq-x_center) < 0:\\n                if math.sqrt((x4-x_center)**2+(y4-y_center)**2) <= radius or (y_center - y4 <= radius and x4-x_center <= radius):\\n                    return 1\\n                elif x_center_sq - x_center < radius:\\n                    if y_center - y2 <= radius:\\n                        return 1\\n                elif y_center - y_center_sq < radius:\\n                    if x1 - x_center <= radius:\\n                        return 1\\n        else:\\n            x_right = x_center + radius\\n            y_top = y_center + radius\\n            if x_right >= x1 and x_right <= x2 + 2*radius and y_top >= y1 and y_top <= y2 +2*radius:\\n                return 1\\n        return 0\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1065275,
                "title": "solutions-written-in-javascript",
                "content": "There aren\\'t many JavaScript posts for this question so here are two solutions re-written in JavaScript found here on the discuss forums: \\n[Solution 1](https://leetcode.com/problems/circle-and-rectangle-overlapping/discuss/563341/4-lines-C%2B%2B-O(1)%3A-Test-shortest-distance-from-center-to-rect-(with-pics))\\n[Solution 2](https://leetcode.com/problems/circle-and-rectangle-overlapping/discuss/563441/JAVA-compare-distance-between-radius-and-closest-point-on-rectangle-to-circle)\\n\\nSolution 1:\\n```\\nvar checkOverlap = function(radius, x_center, y_center, x1, y1, x2, y2) {\\n    let edgeX = 0;\\n    let edgeY = 0;\\n    let distX = 0;\\n    let distY = 0;\\n    if(x_center < x1) {\\n        edgeX = x1;\\n    }\\n    else if(x_center > x2) {\\n        edgeX = x2;\\n    }\\n    else {\\n        edgeX = x_center;\\n    }\\n    if(y_center < y1) {\\n        edgeY = y1;\\n    }\\n    else if(y_center > y2) {\\n        edgeY = y2;\\n    }\\n    else {\\n        edgeY = y_center;\\n    }\\n    distX = x_center - edgeX;\\n    distY = y_center - edgeY;\\n    return (distX ** 2) + (distY ** 2) <= radius ** 2;\\n};\\n```\\n\\nSolution 2:\\n```\\nvar checkOverlap = function(radius, x_center, y_center, x1, y1, x2, y2) {\\n    let closestX = Math.max(x1, Math.min(x2, x_center));\\n    let closestY = Math.max(y1, Math.min(y2, y_center));\\n    \\n    let distX = x_center - closestX;\\n    let distY = y_center - closestY;\\n    \\n    return (distX ** 2) + (distY ** 2) <= radius ** 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkOverlap = function(radius, x_center, y_center, x1, y1, x2, y2) {\\n    let edgeX = 0;\\n    let edgeY = 0;\\n    let distX = 0;\\n    let distY = 0;\\n    if(x_center < x1) {\\n        edgeX = x1;\\n    }\\n    else if(x_center > x2) {\\n        edgeX = x2;\\n    }\\n    else {\\n        edgeX = x_center;\\n    }\\n    if(y_center < y1) {\\n        edgeY = y1;\\n    }\\n    else if(y_center > y2) {\\n        edgeY = y2;\\n    }\\n    else {\\n        edgeY = y_center;\\n    }\\n    distX = x_center - edgeX;\\n    distY = y_center - edgeY;\\n    return (distX ** 2) + (distY ** 2) <= radius ** 2;\\n};\\n```\n```\\nvar checkOverlap = function(radius, x_center, y_center, x1, y1, x2, y2) {\\n    let closestX = Math.max(x1, Math.min(x2, x_center));\\n    let closestY = Math.max(y1, Math.min(y2, y_center));\\n    \\n    let distX = x_center - closestX;\\n    let distY = y_center - closestY;\\n    \\n    return (distX ** 2) + (distY ** 2) <= radius ** 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1048109,
                "title": "java-solution-0ms-math",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        if(x1<=xc && xc<=x2 && y1<=yc && yc<=y2) return true;\\n        int cx=Math.max(x1,Math.min(x2,xc)),cy=Math.max(y1,Math.min(y2,yc));\\n        int tx=xc-cx, ty=yc-cy;\\n        return ((tx*tx)+(ty*ty))<=(radius*radius);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        if(x1<=xc && xc<=x2 && y1<=yc && yc<=y2) return true;\\n        int cx=Math.max(x1,Math.min(x2,xc)),cy=Math.max(y1,Math.min(y2,yc));\\n        int tx=xc-cx, ty=yc-cy;\\n        return ((tx*tx)+(ty*ty))<=(radius*radius);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006679,
                "title": "p23-5",
                "content": "Find point on rect closest to centre of cirl\\nThen if dis(point,centreOfCircl)-radius >0, then No intersec\\n\\nAnother solution of shifting origin\\nMove the center of the circle to the coordinate origin (0, 0), then this problem becomes \"is there a point (x, y) (x1 <= x <= x2, y1 <= y <= y2) satisfying x^2 + y^2 <= r^2\".\\n\\nSo just compute minimum values of x^2 and y^2, then compare the sum with r^2.",
                "solutionTags": [],
                "code": "Find point on rect closest to centre of cirl\\nThen if dis(point,centreOfCircl)-radius >0, then No intersec\\n\\nAnother solution of shifting origin\\nMove the center of the circle to the coordinate origin (0, 0), then this problem becomes \"is there a point (x, y) (x1 <= x <= x2, y1 <= y <= y2) satisfying x^2 + y^2 <= r^2\".\\n\\nSo just compute minimum values of x^2 and y^2, then compare the sum with r^2.",
                "codeTag": "Unknown"
            },
            {
                "id": 1006667,
                "title": "p23-5",
                "content": "Find point on rect closest to centre of cirl\\nThen if dis(point,centreOfCircl)-radius >0, then No intersec",
                "solutionTags": [],
                "code": "Find point on rect closest to centre of cirl\\nThen if dis(point,centreOfCircl)-radius >0, then No intersec",
                "codeTag": "Unknown"
            },
            {
                "id": 998708,
                "title": "java-geometry",
                "content": "Split into 3 cases when returning true\\n1. center of rectangle in circle\\n2. center of circle in rectangle\\n3. circle at least cut with one edge\\n```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        double midx = (x1 + x2) / 2.0, midy = (y1 + y2) / 2.0;\\n        // center of rectangle in circle\\n        if ((midx - x_center) * (midx - x_center) + (midy - y_center) * (midy - y_center) <= radius * radius) return true;\\n        // center of circle in rectangle\\n        if (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2) return true;\\n        // at least cut with one edge\\n        if (cut(x_center, x1, y1, y2, radius, y_center) || cut(x_center, x2, y1, y2, radius, y_center) || cut(y_center, y1, x1, x2, radius, x_center) || cut(y_center, y2, x1, x2, radius, x_center)) return true;\\n        return false;\\n    }\\n    private boolean cut(int xR, int xE, int lower, int upper, int radius, int center) {\\n        if (Math.abs(xR - xE) > radius) return false; \\n        int diff = Math.abs(xR - xE);\\n        double line = Math.sqrt(radius * radius - diff * diff);\\n        double start = center - line, end = center + line;\\n        return !(lower > end || start > upper);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        double midx = (x1 + x2) / 2.0, midy = (y1 + y2) / 2.0;\\n        // center of rectangle in circle\\n        if ((midx - x_center) * (midx - x_center) + (midy - y_center) * (midy - y_center) <= radius * radius) return true;\\n        // center of circle in rectangle\\n        if (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2) return true;\\n        // at least cut with one edge\\n        if (cut(x_center, x1, y1, y2, radius, y_center) || cut(x_center, x2, y1, y2, radius, y_center) || cut(y_center, y1, x1, x2, radius, x_center) || cut(y_center, y2, x1, x2, radius, x_center)) return true;\\n        return false;\\n    }\\n    private boolean cut(int xR, int xE, int lower, int upper, int radius, int center) {\\n        if (Math.abs(xR - xE) > radius) return false; \\n        int diff = Math.abs(xR - xE);\\n        double line = Math.sqrt(radius * radius - diff * diff);\\n        double start = center - line, end = center + line;\\n        return !(lower > end || start > upper);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995484,
                "title": "intuition-with-live-demo-using-javascript-animation",
                "content": "Link to github: https://github.com/shreyanshsaha/leetcode-circle-and-rectangle-overlapping\\nLink to Demo: https://shreyanshsaha.github.io/leetcode-circle-and-rectangle-overlapping/\\n\\nI was confused with the intuition of the given solutions by other people so i decided to visualize it. Hope it helps!",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 957749,
                "title": "java-0ms",
                "content": "public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int minsqr = 0;\\n        \\n        minsqr += x_center < x1 ? (x1 - x_center) * (x1 - x_center) : 0;\\n        minsqr += x_center > x2 ? (x_center - x2) * (x_center - x2) : 0;\\n        minsqr += y_center < y1 ? (y1 - y_center) * (y1 - y_center) : 0;\\n        minsqr += y_center > y2 ? (y_center - y2) * (y_center - y2) : 0;\\n        \\n        return minsqr <= radius * radius;\\n    }",
                "solutionTags": [],
                "code": "public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int minsqr = 0;\\n        \\n        minsqr += x_center < x1 ? (x1 - x_center) * (x1 - x_center) : 0;\\n        minsqr += x_center > x2 ? (x_center - x2) * (x_center - x2) : 0;\\n        minsqr += y_center < y1 ? (y1 - y_center) * (y1 - y_center) : 0;\\n        minsqr += y_center > y2 ? (y_center - y2) * (y_center - y2) : 0;\\n        \\n        return minsqr <= radius * radius;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 901818,
                "title": "c-check-three-cases-o-1",
                "content": "Case 1: Circle\\'s center is inside the rectangle.\\nCase 2: Circle\\'s center is outside the rectangle but at the same level: horizontally or vertically.\\nCase 3: Circle\\'s center is outside, we check distance to corners.\\n\\n```\\npublic class Solution\\n{\\n  public bool CheckOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2)\\n  {\\n    // circle center is inside\\n    if (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2)\\n      return true;\\n\\n    // vertically aligned\\n    if (x_center >= x1 && x_center <= x2)\\n    {\\n      var f1 = Math.Abs(y_center - y1) - radius;\\n      var f2 = Math.Abs(y_center - y2) - radius;\\n\\n      if (f1 <= 0 || f2 <= 0)\\n        return true;\\n    }\\n\\n    // horizontally aligned\\n    if (y_center >= y1 && y_center <= y2)\\n    {\\n      var f1 = Math.Abs(x_center - x1) - radius;\\n      var f2 = Math.Abs(x_center - x2) - radius;\\n\\n      if (f1 <= 0 || f2 <= 0)\\n        return true;\\n    }\\n\\n    // get distances to corners\\n    var d1 = GetDistance((x_center, y_center), (x1, y1));\\n    var d2 = GetDistance((x_center, y_center), (x2, y2));\\n    var d3 = GetDistance((x_center, y_center), (x2, y1));\\n    var d4 = GetDistance((x_center, y_center), (x1, y2));\\n\\n    if (d1 <= radius || d2 <= radius || d3 <= radius || d4 <= radius)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  private double GetDistance((int x, int y) p1, (int x, int y) p2)\\n  {\\n    return Math.Sqrt(Math.Pow(p2.x - p1.x, 2) + Math.Pow(p2.y - p1.y, 2));\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n  public bool CheckOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2)\\n  {\\n    // circle center is inside\\n    if (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2)\\n      return true;\\n\\n    // vertically aligned\\n    if (x_center >= x1 && x_center <= x2)\\n    {\\n      var f1 = Math.Abs(y_center - y1) - radius;\\n      var f2 = Math.Abs(y_center - y2) - radius;\\n\\n      if (f1 <= 0 || f2 <= 0)\\n        return true;\\n    }\\n\\n    // horizontally aligned\\n    if (y_center >= y1 && y_center <= y2)\\n    {\\n      var f1 = Math.Abs(x_center - x1) - radius;\\n      var f2 = Math.Abs(x_center - x2) - radius;\\n\\n      if (f1 <= 0 || f2 <= 0)\\n        return true;\\n    }\\n\\n    // get distances to corners\\n    var d1 = GetDistance((x_center, y_center), (x1, y1));\\n    var d2 = GetDistance((x_center, y_center), (x2, y2));\\n    var d3 = GetDistance((x_center, y_center), (x2, y1));\\n    var d4 = GetDistance((x_center, y_center), (x1, y2));\\n\\n    if (d1 <= radius || d2 <= radius || d3 <= radius || d4 <= radius)\\n      return true;\\n\\n    return false;\\n  }\\n\\n  private double GetDistance((int x, int y) p1, (int x, int y) p2)\\n  {\\n    return Math.Sqrt(Math.Pow(p2.x - p1.x, 2) + Math.Pow(p2.y - p1.y, 2));\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858820,
                "title": "c-brute-forse",
                "content": "```\\nclass Solution {\\n public:\\n  bool checkOverlap(int radius,\\n                    int x_center,\\n                    int y_center,\\n                    int x1,\\n                    int y1,\\n                    int x2,\\n                    int y2) {\\n    for (int i = x1; i <= x2; ++i) {\\n      for (int j = y2; j >= y1; --j) {\\n        if (pow(abs(i - x_center), 2) + pow(abs(j - y_center), 2) <=\\n            radius * radius) {\\n          return true;\\n        }\\n      }\\n    }\\n\\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  bool checkOverlap(int radius,\\n                    int x_center,\\n                    int y_center,\\n                    int x1,\\n                    int y1,\\n                    int x2,\\n                    int y2) {\\n    for (int i = x1; i <= x2; ++i) {\\n      for (int j = y2; j >= y1; --j) {\\n        if (pow(abs(i - x_center), 2) + pow(abs(j - y_center), 2) <=\\n            radius * radius) {\\n          return true;\\n        }\\n      }\\n    }\\n\\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858633,
                "title": "easy-to-understand-java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int cx = getClosest(x_center, x1, x2);\\n        int cy = getClosest(y_center, y1, y2);\\n        double distance = calculateDistance(cx, cy, x_center, y_center);\\n        return distance <= (double) radius;\\n    }\\n    \\n    private int getClosest(int center, int first, int second) {\\n        if (center <= first && center < second) {\\n            return first;\\n        } else if (center > first && center <= second) {\\n            return center;\\n        } else {\\n            return second;\\n        }\\n    }\\n    \\n    private double calculateDistance(int x1, int y1, int x2, int y2) {\\n        long yDelta = Math.max(y1, y2) - Math.min(y1, y2);\\n        long xDelta = Math.max(x1, x2) - Math.min(x1, x2);\\n        return Math.sqrt(yDelta * yDelta + xDelta * xDelta);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int cx = getClosest(x_center, x1, x2);\\n        int cy = getClosest(y_center, y1, y2);\\n        double distance = calculateDistance(cx, cy, x_center, y_center);\\n        return distance <= (double) radius;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 855876,
                "title": "cpp14-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x = max(x1 , min(x2 , x_center));\\n        int y = max(y1 , min(y2 , y_center));\\n        int distance = (x-x_center)*(x-x_center) + (y-y_center)*(y-y_center); \\n        if(distance <= (radius * radius)) return true;\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x = max(x1 , min(x2 , x_center));\\n        int y = max(y1 , min(y2 , y_center));\\n        int distance = (x-x_center)*(x-x_center) + (y-y_center)*(y-y_center); \\n        if(distance <= (radius * radius)) return true;\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810073,
                "title": "java-solution-beats-100",
                "content": "Straightforward idea that divides the problem into different schenarios.\\nThere will be overlap if and only if the minimum distance between the circle center and any point of the rectanglular is less than or equal to the circle radius.\\n\\n```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        if (xc >= x1 && xc <= x2 && yc >= y1 && yc <= y2) return true;\\n        else if (xc < x1){\\n            if (yc >= y1 && yc <= y2) return x1 - xc <= r;\\n            else if (yc < y1) return (x1-xc)*(x1-xc) + (y1-yc)*(y1-yc) <= r*r;\\n            else return (x1-xc)*(x1-xc) + (y2-yc)*(y2-yc) <= r*r;\\n        }\\n        else if (xc > x2) {\\n            if (yc >= y1 && yc <= y2) return xc - x2 <= r;\\n            else if (yc < y1) return (x2-xc)*(x2-xc) + (y1-yc)*(y1-yc) <= r*r;\\n            else return (x2-xc)*(x2-xc) + (y2-yc)*(y2-yc) <= r*r;\\n        }\\n        else if (yc < y1){\\n            return y1 - yc <= r;\\n        }\\n        else {\\n            return yc - y2 <= r;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        if (xc >= x1 && xc <= x2 && yc >= y1 && yc <= y2) return true;\\n        else if (xc < x1){\\n            if (yc >= y1 && yc <= y2) return x1 - xc <= r;\\n            else if (yc < y1) return (x1-xc)*(x1-xc) + (y1-yc)*(y1-yc) <= r*r;\\n            else return (x1-xc)*(x1-xc) + (y2-yc)*(y2-yc) <= r*r;\\n        }\\n        else if (xc > x2) {\\n            if (yc >= y1 && yc <= y2) return xc - x2 <= r;\\n            else if (yc < y1) return (x2-xc)*(x2-xc) + (y1-yc)*(y1-yc) <= r*r;\\n            else return (x2-xc)*(x2-xc) + (y2-yc)*(y2-yc) <= r*r;\\n        }\\n        else if (yc < y1){\\n            return y1 - yc <= r;\\n        }\\n        else {\\n            return yc - y2 <= r;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781564,
                "title": "0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x= x_center;\\n        int y= y_center;\\n        if(x_center<x1)x=x1;\\n        else if(x_center>x2) x=x2;\\n         if(y_center<y1) y=y1;\\n        else if(y_center>y2) y=y2;\\n        int x_dist= x-x_center;\\n        int y_dist=y-y_center;\\n        return x_dist*x_dist + y_dist*y_dist <= radius*radius;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x= x_center;\\n        int y= y_center;\\n        if(x_center<x1)x=x1;\\n        else if(x_center>x2) x=x2;\\n         if(y_center<y1) y=y1;\\n        else if(y_center>y2) y=y2;\\n        int x_dist= x-x_center;\\n        int y_dist=y-y_center;\\n        return x_dist*x_dist + y_dist*y_dist <= radius*radius;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 766749,
                "title": "python-solution-simple-fast-easy-to-understand",
                "content": "```\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        Xn = max(x1, min(x_center, x2)) \\n        Yn = max(y1, min(y_center, y2)) \\n        Dx = Xn - x_center \\n        Dy = Yn - y_center \\n        return (Dx**2 + Dy**2) <= radius**2\\n```",
                "solutionTags": [],
                "code": "```\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        Xn = max(x1, min(x_center, x2)) \\n        Yn = max(y1, min(y_center, y2)) \\n        Dx = Xn - x_center \\n        Dy = Yn - y_center \\n        return (Dx**2 + Dy**2) <= radius**2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 742414,
                "title": "best-java-solution-so-far-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        // If center of circle is within the rectangle, return true.\\n        if (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2) return true;\\n        // If center is aligned horizontally with the rect, check if distance from closest edge is less than radius.\\n        if (y_center >= y1 && y_center <= y2) {\\n            int nearestEdgeDistance = Math.min(Math.abs(x_center - x1), Math.abs(x_center - x2));\\n            if (nearestEdgeDistance <= radius) return true;\\n            else return false;\\n        }\\n        // If center is aligned vertically with the rect, check if distance from closest edge is less than radius.\\n        if (x_center >= x1 && x_center <= x2) {\\n            int nearestEdgeDistance = Math.min(Math.abs(y_center - y1), Math.abs(y_center - y2));\\n            if (nearestEdgeDistance <= radius) return true;\\n            else return false;\\n        }\\n        // Find out distance with the closest corner. Return true if less than radius.\\n        double nearestCornerDistance = Math.sqrt(Math.pow(Math.min(Math.abs(x_center - x1), Math.abs(x_center - x2)), 2) + Math.pow(Math.min(Math.abs(y_center - y1), Math.abs(y_center - y2)), 2));\\n        if (nearestCornerDistance <= radius) return true;\\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        // If center of circle is within the rectangle, return true.\\n        if (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2) return true;\\n        // If center is aligned horizontally with the rect, check if distance from closest edge is less than radius.\\n        if (y_center >= y1 && y_center <= y2) {\\n            int nearestEdgeDistance = Math.min(Math.abs(x_center - x1), Math.abs(x_center - x2));\\n            if (nearestEdgeDistance <= radius) return true;\\n            else return false;\\n        }\\n        // If center is aligned vertically with the rect, check if distance from closest edge is less than radius.\\n        if (x_center >= x1 && x_center <= x2) {\\n            int nearestEdgeDistance = Math.min(Math.abs(y_center - y1), Math.abs(y_center - y2));\\n            if (nearestEdgeDistance <= radius) return true;\\n            else return false;\\n        }\\n        // Find out distance with the closest corner. Return true if less than radius.\\n        double nearestCornerDistance = Math.sqrt(Math.pow(Math.min(Math.abs(x_center - x1), Math.abs(x_center - x2)), 2) + Math.pow(Math.min(Math.abs(y_center - y1), Math.abs(y_center - y2)), 2));\\n        if (nearestCornerDistance <= radius) return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734550,
                "title": "2-line-java-find-the-shortest-distance",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int dx = x_center >= x1 && x_center <= x2? x_center : x_center < x1? x1 : x2, dy = y_center >= y1 && y_center <= y2? y_center : y_center < y1? y1 : y2;\\n        return Math.sqrt((Math.pow((dx - x_center), 2) + Math.pow((dy - y_center), 2))) <= radius;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int dx = x_center >= x1 && x_center <= x2? x_center : x_center < x1? x1 : x2, dy = y_center >= y1 && y_center <= y2? y_center : y_center < y1? y1 : y2;\\n        return Math.sqrt((Math.pow((dx - x_center), 2) + Math.pow((dy - y_center), 2))) <= radius;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719015,
                "title": "cpp-solution-beats-100-time-and-91-space",
                "content": "pretty straight forward -  the idea is to find a point in the rectangle that is closest to the circle center. After the alogrithm aquired a candidate, the algorithm determines whether that point is inside the circle or not (inside is equivalent to distance is smaller than radius).\\nI computed the distances without taking the square root as it is a more complex and resource-consuming operation.\\n\\n```\\nclass Solution {\\nprivate:\\n    static inline int dist(int a1, int a2) {\\n        return (a1 - a2) * (a1 - a2);\\n    }\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x_closest, y_closest;\\n        if (x_center > x1 && x_center < x2)\\n            x_closest = x_center;\\n        else\\n            x_closest = abs(x1 - x_center) < abs(x2 - x_center) ? x1 : x2;\\n        \\n        if (y_center > y1 && y_center < y2)\\n            y_closest = y_center;\\n        else\\n            y_closest = abs(y1 - y_center) < abs(y2 - y_center) ? y1 : y2;\\n        \\n        return dist(x_closest, x_center) + dist(y_closest, y_center) <= radius * radius;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    static inline int dist(int a1, int a2) {\\n        return (a1 - a2) * (a1 - a2);\\n    }\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x_closest, y_closest;\\n        if (x_center > x1 && x_center < x2)\\n            x_closest = x_center;\\n        else\\n            x_closest = abs(x1 - x_center) < abs(x2 - x_center) ? x1 : x2;\\n        \\n        if (y_center > y1 && y_center < y2)\\n            y_closest = y_center;\\n        else\\n            y_closest = abs(y1 - y_center) < abs(y2 - y_center) ? y1 : y2;\\n        \\n        return dist(x_closest, x_center) + dist(y_closest, y_center) <= radius * radius;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706055,
                "title": "c-100-time-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x3 = x2;\\n        int y3 = y1;\\n        int x4 = x1;\\n        int y4 = y2;\\n        \\n        if(x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2)\\n            return true;\\n        \\n        int d1 = pow(x1 - x_center, 2) + pow(y1 - y_center, 2);\\n        int d2 = pow(x2 - x_center, 2) + pow(y2 - y_center, 2);\\n        int d3 = pow(x3 - x_center, 2) + pow(y3 - y_center, 2);\\n        int d4 = pow(x4 - x_center, 2) + pow(y4 - y_center, 2);\\n        \\n        int r = pow(radius, 2);\\n        \\n        if(d1 <= r || d2 <= r || d3 <= r || d4 <= r)\\n            return true;\\n        \\n        int xx = x_center + radius;\\n        int yy = y_center;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        xx = x_center - radius;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        xx = x_center;\\n        yy = y_center + radius;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        xx = x_center;\\n        yy = y_center - radius;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        int xplus = x_center + radius;\\n        int xminus = x_center - radius;\\n        \\n        if(xplus >= x2 && xminus <= x1 && y_center <= y2 && y_center >= y1)\\n            return true;\\n        \\n        int yplus = y_center + radius;\\n        int yminus = y_center - radius;\\n        \\n        if(yplus >= y2 && yminus <= y1 && x_center <= x2 && x_center >= x1)\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int x3 = x2;\\n        int y3 = y1;\\n        int x4 = x1;\\n        int y4 = y2;\\n        \\n        if(x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2)\\n            return true;\\n        \\n        int d1 = pow(x1 - x_center, 2) + pow(y1 - y_center, 2);\\n        int d2 = pow(x2 - x_center, 2) + pow(y2 - y_center, 2);\\n        int d3 = pow(x3 - x_center, 2) + pow(y3 - y_center, 2);\\n        int d4 = pow(x4 - x_center, 2) + pow(y4 - y_center, 2);\\n        \\n        int r = pow(radius, 2);\\n        \\n        if(d1 <= r || d2 <= r || d3 <= r || d4 <= r)\\n            return true;\\n        \\n        int xx = x_center + radius;\\n        int yy = y_center;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        xx = x_center - radius;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        xx = x_center;\\n        yy = y_center + radius;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        xx = x_center;\\n        yy = y_center - radius;\\n        \\n        if(xx >= x1 && xx <= x2 && yy <= y2 && yy >= y1)\\n            return true;\\n        \\n        int xplus = x_center + radius;\\n        int xminus = x_center - radius;\\n        \\n        if(xplus >= x2 && xminus <= x1 && y_center <= y2 && y_center >= y1)\\n            return true;\\n        \\n        int yplus = y_center + radius;\\n        int yminus = y_center - radius;\\n        \\n        if(yplus >= y2 && yminus <= y1 && x_center <= x2 && x_center >= x1)\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 660318,
                "title": "when-in-doubt-use-library",
                "content": "https://github.com/jaehyunp/stanfordacm/blob/master/code/Geometry.cc\\n```\\n// C++ routines for computational geometry.\\n\\n#include <iostream>\\n#include <vector>\\n#include <cmath>\\n#include <cassert>\\n\\nusing namespace std;\\n\\ndouble INF = 1e100;\\ndouble EPS = 1e-12;\\n\\nstruct PT { \\n  double x, y; \\n  PT() {}\\n  PT(double x, double y) : x(x), y(y) {}\\n  PT(const PT &p) : x(p.x), y(p.y)    {}\\n  PT operator + (const PT &p)  const { return PT(x+p.x, y+p.y); }\\n  PT operator - (const PT &p)  const { return PT(x-p.x, y-p.y); }\\n  PT operator * (double c)     const { return PT(x*c,   y*c  ); }\\n  PT operator / (double c)     const { return PT(x/c,   y/c  ); }\\n};\\n\\ndouble dot(PT p, PT q)     { return p.x*q.x+p.y*q.y; }\\ndouble dist2(PT p, PT q)   { return dot(p-q,p-q); }\\ndouble cross(PT p, PT q)   { return p.x*q.y-p.y*q.x; }\\nostream &operator<<(ostream &os, const PT &p) {\\n  return os << \"(\" << p.x << \",\" << p.y << \")\"; \\n}\\n\\n// rotate a point CCW or CW around the origin\\nPT RotateCCW90(PT p)   { return PT(-p.y,p.x); }\\nPT RotateCW90(PT p)    { return PT(p.y,-p.x); }\\nPT RotateCCW(PT p, double t) { \\n  return PT(p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t)); \\n}\\n\\n// project point c onto line through a and b\\n// assuming a != b\\nPT ProjectPointLine(PT a, PT b, PT c) {\\n  return a + (b-a)*dot(c-a, b-a)/dot(b-a, b-a);\\n}\\n\\n// project point c onto line segment through a and b\\nPT ProjectPointSegment(PT a, PT b, PT c) {\\n  double r = dot(b-a,b-a);\\n  if (fabs(r) < EPS) return a;\\n  r = dot(c-a, b-a)/r;\\n  if (r < 0) return a;\\n  if (r > 1) return b;\\n  return a + (b-a)*r;\\n}\\n\\n// compute distance from c to segment between a and b\\ndouble DistancePointSegment(PT a, PT b, PT c) {\\n  return sqrt(dist2(c, ProjectPointSegment(a, b, c)));\\n}\\n\\n// compute distance between point (x,y,z) and plane ax+by+cz=d\\ndouble DistancePointPlane(double x, double y, double z,\\n                          double a, double b, double c, double d)\\n{\\n  return fabs(a*x+b*y+c*z-d)/sqrt(a*a+b*b+c*c);\\n}\\n\\n// determine if lines from a to b and c to d are parallel or collinear\\nbool LinesParallel(PT a, PT b, PT c, PT d) { \\n  return fabs(cross(b-a, c-d)) < EPS; \\n}\\n\\nbool LinesCollinear(PT a, PT b, PT c, PT d) { \\n  return LinesParallel(a, b, c, d)\\n      && fabs(cross(a-b, a-c)) < EPS\\n      && fabs(cross(c-d, c-a)) < EPS; \\n}\\n\\n// determine if line segment from a to b intersects with \\n// line segment from c to d\\nbool SegmentsIntersect(PT a, PT b, PT c, PT d) {\\n  if (LinesCollinear(a, b, c, d)) {\\n    if (dist2(a, c) < EPS || dist2(a, d) < EPS ||\\n      dist2(b, c) < EPS || dist2(b, d) < EPS) return true;\\n    if (dot(c-a, c-b) > 0 && dot(d-a, d-b) > 0 && dot(c-b, d-b) > 0)\\n      return false;\\n    return true;\\n  }\\n  if (cross(d-a, b-a) * cross(c-a, b-a) > 0) return false;\\n  if (cross(a-c, d-c) * cross(b-c, d-c) > 0) return false;\\n  return true;\\n}\\n\\n// compute intersection of line passing through a and b\\n// with line passing through c and d, assuming that unique\\n// intersection exists; for segment intersection, check if\\n// segments intersect first\\nPT ComputeLineIntersection(PT a, PT b, PT c, PT d) {\\n  b=b-a; d=c-d; c=c-a;\\n  assert(dot(b, b) > EPS && dot(d, d) > EPS);\\n  return a + b*cross(c, d)/cross(b, d);\\n}\\n\\n// compute center of circle given three points\\nPT ComputeCircleCenter(PT a, PT b, PT c) {\\n  b=(a+b)/2;\\n  c=(a+c)/2;\\n  return ComputeLineIntersection(b, b+RotateCW90(a-b), c, c+RotateCW90(a-c));\\n}\\n\\n// determine if point is in a possibly non-convex polygon (by William\\n// Randolph Franklin); returns 1 for strictly interior points, 0 for\\n// strictly exterior points, and 0 or 1 for the remaining points.\\n// Note that it is possible to convert this into an *exact* test using\\n// integer arithmetic by taking care of the division appropriately\\n// (making sure to deal with signs properly) and then by writing exact\\n// tests for checking point on polygon boundary\\nbool PointInPolygon(const vector<PT> &p, PT q) {\\n  bool c = 0;\\n  for (int i = 0; i < p.size(); i++){\\n    int j = (i+1)%p.size();\\n    if ((p[i].y <= q.y && q.y < p[j].y || \\n      p[j].y <= q.y && q.y < p[i].y) &&\\n      q.x < p[i].x + (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y))\\n      c = !c;\\n  }\\n  return c;\\n}\\n\\n// determine if point is on the boundary of a polygon\\nbool PointOnPolygon(const vector<PT> &p, PT q) {\\n  for (int i = 0; i < p.size(); i++)\\n    if (dist2(ProjectPointSegment(p[i], p[(i+1)%p.size()], q), q) < EPS)\\n      return true;\\n    return false;\\n}\\n\\n// compute intersection of line through points a and b with\\n// circle centered at c with radius r > 0\\nvector<PT> CircleLineIntersection(PT a, PT b, PT c, double r) {\\n  vector<PT> ret;\\n  b = b-a;\\n  a = a-c;\\n  double A = dot(b, b);\\n  double B = dot(a, b);\\n  double C = dot(a, a) - r*r;\\n  double D = B*B - A*C;\\n  if (D < -EPS) return ret;\\n  ret.push_back(c+a+b*(-B+sqrt(D+EPS))/A);\\n  if (D > EPS)\\n    ret.push_back(c+a+b*(-B-sqrt(D))/A);\\n  return ret;\\n}\\n\\n// compute intersection of circle centered at a with radius r\\n// with circle centered at b with radius R\\nvector<PT> CircleCircleIntersection(PT a, PT b, double r, double R) {\\n  vector<PT> ret;\\n  double d = sqrt(dist2(a, b));\\n  if (d > r+R || d+min(r, R) < max(r, R)) return ret;\\n  double x = (d*d-R*R+r*r)/(2*d);\\n  double y = sqrt(r*r-x*x);\\n  PT v = (b-a)/d;\\n  ret.push_back(a+v*x + RotateCCW90(v)*y);\\n  if (y > 0)\\n    ret.push_back(a+v*x - RotateCCW90(v)*y);\\n  return ret;\\n}\\n\\n// This code computes the area or centroid of a (possibly nonconvex)\\n// polygon, assuming that the coordinates are listed in a clockwise or\\n// counterclockwise fashion.  Note that the centroid is often known as\\n// the \"center of gravity\" or \"center of mass\".\\ndouble ComputeSignedArea(const vector<PT> &p) {\\n  double area = 0;\\n  for(int i = 0; i < p.size(); i++) {\\n    int j = (i+1) % p.size();\\n    area += p[i].x*p[j].y - p[j].x*p[i].y;\\n  }\\n  return area / 2.0;\\n}\\n\\ndouble ComputeArea(const vector<PT> &p) {\\n  return fabs(ComputeSignedArea(p));\\n}\\n\\nPT ComputeCentroid(const vector<PT> &p) {\\n  PT c(0,0);\\n  double scale = 6.0 * ComputeSignedArea(p);\\n  for (int i = 0; i < p.size(); i++){\\n    int j = (i+1) % p.size();\\n    c = c + (p[i]+p[j])*(p[i].x*p[j].y - p[j].x*p[i].y);\\n  }\\n  return c / scale;\\n}\\n\\n// tests whether or not a given polygon (in CW or CCW order) is simple\\nbool IsSimple(const vector<PT> &p) {\\n  for (int i = 0; i < p.size(); i++) {\\n    for (int k = i+1; k < p.size(); k++) {\\n      int j = (i+1) % p.size();\\n      int l = (k+1) % p.size();\\n      if (i == l || j == k) continue;\\n      if (SegmentsIntersect(p[i], p[j], p[k], p[l])) \\n        return false;\\n    }\\n  }\\n  return true;\\n}\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        vector<PT> rect;\\n        rect.push_back(PT(x1,y1));\\n        rect.push_back(PT(x1,y2));\\n        rect.push_back(PT(x2,y2));\\n        rect.push_back(PT(x2,y1));\\n        PT center=PT(x_center,y_center);\\n       return  DistancePointSegment(rect[0],rect[1],center) <= radius\\n           ||  DistancePointSegment(rect[1],rect[2],center) <= radius \\n           ||  DistancePointSegment(rect[2],rect[3],center) <= radius\\n           ||  DistancePointSegment(rect[3],rect[0],center) <= radius\\n           ||  PointInPolygon(rect,center);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// C++ routines for computational geometry.\\n\\n#include <iostream>\\n#include <vector>\\n#include <cmath>\\n#include <cassert>\\n\\nusing namespace std;\\n\\ndouble INF = 1e100;\\ndouble EPS = 1e-12;\\n\\nstruct PT { \\n  double x, y; \\n  PT() {}\\n  PT(double x, double y) : x(x), y(y) {}\\n  PT(const PT &p) : x(p.x), y(p.y)    {}\\n  PT operator + (const PT &p)  const { return PT(x+p.x, y+p.y); }\\n  PT operator - (const PT &p)  const { return PT(x-p.x, y-p.y); }\\n  PT operator * (double c)     const { return PT(x*c,   y*c  ); }\\n  PT operator / (double c)     const { return PT(x/c,   y/c  ); }\\n};\\n\\ndouble dot(PT p, PT q)     { return p.x*q.x+p.y*q.y; }\\ndouble dist2(PT p, PT q)   { return dot(p-q,p-q); }\\ndouble cross(PT p, PT q)   { return p.x*q.y-p.y*q.x; }\\nostream &operator<<(ostream &os, const PT &p) {\\n  return os << \"(\" << p.x << \",\" << p.y << \")\"; \\n}\\n\\n// rotate a point CCW or CW around the origin\\nPT RotateCCW90(PT p)   { return PT(-p.y,p.x); }\\nPT RotateCW90(PT p)    { return PT(p.y,-p.x); }\\nPT RotateCCW(PT p, double t) { \\n  return PT(p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t)); \\n}\\n\\n// project point c onto line through a and b\\n// assuming a != b\\nPT ProjectPointLine(PT a, PT b, PT c) {\\n  return a + (b-a)*dot(c-a, b-a)/dot(b-a, b-a);\\n}\\n\\n// project point c onto line segment through a and b\\nPT ProjectPointSegment(PT a, PT b, PT c) {\\n  double r = dot(b-a,b-a);\\n  if (fabs(r) < EPS) return a;\\n  r = dot(c-a, b-a)/r;\\n  if (r < 0) return a;\\n  if (r > 1) return b;\\n  return a + (b-a)*r;\\n}\\n\\n// compute distance from c to segment between a and b\\ndouble DistancePointSegment(PT a, PT b, PT c) {\\n  return sqrt(dist2(c, ProjectPointSegment(a, b, c)));\\n}\\n\\n// compute distance between point (x,y,z) and plane ax+by+cz=d\\ndouble DistancePointPlane(double x, double y, double z,\\n                          double a, double b, double c, double d)\\n{\\n  return fabs(a*x+b*y+c*z-d)/sqrt(a*a+b*b+c*c);\\n}\\n\\n// determine if lines from a to b and c to d are parallel or collinear\\nbool LinesParallel(PT a, PT b, PT c, PT d) { \\n  return fabs(cross(b-a, c-d)) < EPS; \\n}\\n\\nbool LinesCollinear(PT a, PT b, PT c, PT d) { \\n  return LinesParallel(a, b, c, d)\\n      && fabs(cross(a-b, a-c)) < EPS\\n      && fabs(cross(c-d, c-a)) < EPS; \\n}\\n\\n// determine if line segment from a to b intersects with \\n// line segment from c to d\\nbool SegmentsIntersect(PT a, PT b, PT c, PT d) {\\n  if (LinesCollinear(a, b, c, d)) {\\n    if (dist2(a, c) < EPS || dist2(a, d) < EPS ||\\n      dist2(b, c) < EPS || dist2(b, d) < EPS) return true;\\n    if (dot(c-a, c-b) > 0 && dot(d-a, d-b) > 0 && dot(c-b, d-b) > 0)\\n      return false;\\n    return true;\\n  }\\n  if (cross(d-a, b-a) * cross(c-a, b-a) > 0) return false;\\n  if (cross(a-c, d-c) * cross(b-c, d-c) > 0) return false;\\n  return true;\\n}\\n\\n// compute intersection of line passing through a and b\\n// with line passing through c and d, assuming that unique\\n// intersection exists; for segment intersection, check if\\n// segments intersect first\\nPT ComputeLineIntersection(PT a, PT b, PT c, PT d) {\\n  b=b-a; d=c-d; c=c-a;\\n  assert(dot(b, b) > EPS && dot(d, d) > EPS);\\n  return a + b*cross(c, d)/cross(b, d);\\n}\\n\\n// compute center of circle given three points\\nPT ComputeCircleCenter(PT a, PT b, PT c) {\\n  b=(a+b)/2;\\n  c=(a+c)/2;\\n  return ComputeLineIntersection(b, b+RotateCW90(a-b), c, c+RotateCW90(a-c));\\n}\\n\\n// determine if point is in a possibly non-convex polygon (by William\\n// Randolph Franklin); returns 1 for strictly interior points, 0 for\\n// strictly exterior points, and 0 or 1 for the remaining points.\\n// Note that it is possible to convert this into an *exact* test using\\n// integer arithmetic by taking care of the division appropriately\\n// (making sure to deal with signs properly) and then by writing exact\\n// tests for checking point on polygon boundary\\nbool PointInPolygon(const vector<PT> &p, PT q) {\\n  bool c = 0;\\n  for (int i = 0; i < p.size(); i++){\\n    int j = (i+1)%p.size();\\n    if ((p[i].y <= q.y && q.y < p[j].y || \\n      p[j].y <= q.y && q.y < p[i].y) &&\\n      q.x < p[i].x + (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y))\\n      c = !c;\\n  }\\n  return c;\\n}\\n\\n// determine if point is on the boundary of a polygon\\nbool PointOnPolygon(const vector<PT> &p, PT q) {\\n  for (int i = 0; i < p.size(); i++)\\n    if (dist2(ProjectPointSegment(p[i], p[(i+1)%p.size()], q), q) < EPS)\\n      return true;\\n    return false;\\n}\\n\\n// compute intersection of line through points a and b with\\n// circle centered at c with radius r > 0\\nvector<PT> CircleLineIntersection(PT a, PT b, PT c, double r) {\\n  vector<PT> ret;\\n  b = b-a;\\n  a = a-c;\\n  double A = dot(b, b);\\n  double B = dot(a, b);\\n  double C = dot(a, a) - r*r;\\n  double D = B*B - A*C;\\n  if (D < -EPS) return ret;\\n  ret.push_back(c+a+b*(-B+sqrt(D+EPS))/A);\\n  if (D > EPS)\\n    ret.push_back(c+a+b*(-B-sqrt(D))/A);\\n  return ret;\\n}\\n\\n// compute intersection of circle centered at a with radius r\\n// with circle centered at b with radius R\\nvector<PT> CircleCircleIntersection(PT a, PT b, double r, double R) {\\n  vector<PT> ret;\\n  double d = sqrt(dist2(a, b));\\n  if (d > r+R || d+min(r, R) < max(r, R)) return ret;\\n  double x = (d*d-R*R+r*r)/(2*d);\\n  double y = sqrt(r*r-x*x);\\n  PT v = (b-a)/d;\\n  ret.push_back(a+v*x + RotateCCW90(v)*y);\\n  if (y > 0)\\n    ret.push_back(a+v*x - RotateCCW90(v)*y);\\n  return ret;\\n}\\n\\n// This code computes the area or centroid of a (possibly nonconvex)\\n// polygon, assuming that the coordinates are listed in a clockwise or\\n// counterclockwise fashion.  Note that the centroid is often known as\\n// the \"center of gravity\" or \"center of mass\".\\ndouble ComputeSignedArea(const vector<PT> &p) {\\n  double area = 0;\\n  for(int i = 0; i < p.size(); i++) {\\n    int j = (i+1) % p.size();\\n    area += p[i].x*p[j].y - p[j].x*p[i].y;\\n  }\\n  return area / 2.0;\\n}\\n\\ndouble ComputeArea(const vector<PT> &p) {\\n  return fabs(ComputeSignedArea(p));\\n}\\n\\nPT ComputeCentroid(const vector<PT> &p) {\\n  PT c(0,0);\\n  double scale = 6.0 * ComputeSignedArea(p);\\n  for (int i = 0; i < p.size(); i++){\\n    int j = (i+1) % p.size();\\n    c = c + (p[i]+p[j])*(p[i].x*p[j].y - p[j].x*p[i].y);\\n  }\\n  return c / scale;\\n}\\n\\n// tests whether or not a given polygon (in CW or CCW order) is simple\\nbool IsSimple(const vector<PT> &p) {\\n  for (int i = 0; i < p.size(); i++) {\\n    for (int k = i+1; k < p.size(); k++) {\\n      int j = (i+1) % p.size();\\n      int l = (k+1) % p.size();\\n      if (i == l || j == k) continue;\\n      if (SegmentsIntersect(p[i], p[j], p[k], p[l])) \\n        return false;\\n    }\\n  }\\n  return true;\\n}\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        vector<PT> rect;\\n        rect.push_back(PT(x1,y1));\\n        rect.push_back(PT(x1,y2));\\n        rect.push_back(PT(x2,y2));\\n        rect.push_back(PT(x2,y1));\\n        PT center=PT(x_center,y_center);\\n       return  DistancePointSegment(rect[0],rect[1],center) <= radius\\n           ||  DistancePointSegment(rect[1],rect[2],center) <= radius \\n           ||  DistancePointSegment(rect[2],rect[3],center) <= radius\\n           ||  DistancePointSegment(rect[3],rect[0],center) <= radius\\n           ||  PointInPolygon(rect,center);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 624143,
                "title": "go-straight-forward-beat-100",
                "content": "```\\nfunc checkOverlap(r, x, y, x1, y1, x2, y2 int) bool {\\n    if x >= x1 && x <= x2  && y >= y1 && y <= y2 {\\n        return true\\n    } else if x >= x1 && x <= x2 && (y < y1 || y > y2) {\\n        if (y1 - y > 0 && y1 - y <= r) || (y - y2 > 0 && y - y2 <= r) {\\n            return true\\n        }\\n    } else if (x < x1 || x > x2) && y >= y1 && y <= y2 {\\n        if (x1 - x > 0 && x1 - x <= r) || (x - x2 > 0 && x - x2 <= r) {\\n            return true\\n        }\\n    } else if ((x - x1) * (x - x1) + (y - y1) * (y - y1) <= r * r) ||\\n              ((x - x2) * (x - x2) + (y - y1) * (y - y1) <= r * r) ||\\n              ((x - x1) * (x - x1) + (y - y2) * (y - y2) <= r * r) ||\\n              ((x - x2) * (x - x2) + (y - y2) * (y - y2) <= r * r) {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc checkOverlap(r, x, y, x1, y1, x2, y2 int) bool {\\n    if x >= x1 && x <= x2  && y >= y1 && y <= y2 {\\n        return true\\n    } else if x >= x1 && x <= x2 && (y < y1 || y > y2) {\\n        if (y1 - y > 0 && y1 - y <= r) || (y - y2 > 0 && y - y2 <= r) {\\n            return true\\n        }\\n    } else if (x < x1 || x > x2) && y >= y1 && y <= y2 {\\n        if (x1 - x > 0 && x1 - x <= r) || (x - x2 > 0 && x - x2 <= r) {\\n            return true\\n        }\\n    } else if ((x - x1) * (x - x1) + (y - y1) * (y - y1) <= r * r) ||\\n              ((x - x2) * (x - x2) + (y - y1) * (y - y1) <= r * r) ||\\n              ((x - x1) * (x - x1) + (y - y2) * (y - y2) <= r * r) ||\\n              ((x - x2) * (x - x2) + (y - y2) * (y - y2) <= r * r) {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 617386,
                "title": "c-readable-commented-solution-still-100-faster",
                "content": "```\\n\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        //is the circle center within the left and right sides of the rectangle, and if not is it closer to the left edge or right edge of the rectangle?\\n        int rectSideX = 0;\\n        if(x1 > x_center) {\\n            //circle is to the left of the rectangle\\n            rectSideX = x1;\\n        } else if(x2 < x_center) {\\n            //circle is to the right of the rectangle\\n            rectSideX = x2;\\n        } else {\\n            //circle center is within the left and right bounds of the rect\\n            //(but not necessarily top and bottom)\\n            rectSideX = x_center;\\n        }\\n        \\n        int rectSideY = 0;\\n        if(y1 > y_center) {\\n            //circle is below the rectangle\\n            rectSideY = y1;\\n        } else if(y2 < y_center) {\\n            //circle is above the rectangle\\n            rectSideY = y2;\\n        } else {\\n            //circle center is within the top and bottom bounds of the rectangle\\n            rectSideY = y_center;\\n        }\\n        \\n        int dx = x_center - rectSideX;\\n        int dy = y_center - rectSideY;\\n        double distance = sqrt(dx * dx + dy * dy);\\n        \\n        return distance <= radius;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        //is the circle center within the left and right sides of the rectangle, and if not is it closer to the left edge or right edge of the rectangle?\\n        int rectSideX = 0;\\n        if(x1 > x_center) {\\n            //circle is to the left of the rectangle\\n            rectSideX = x1;\\n        } else if(x2 < x_center) {\\n            //circle is to the right of the rectangle\\n            rectSideX = x2;\\n        } else {\\n            //circle center is within the left and right bounds of the rect\\n            //(but not necessarily top and bottom)\\n            rectSideX = x_center;\\n        }\\n        \\n        int rectSideY = 0;\\n        if(y1 > y_center) {\\n            //circle is below the rectangle\\n            rectSideY = y1;\\n        } else if(y2 < y_center) {\\n            //circle is above the rectangle\\n            rectSideY = y2;\\n        } else {\\n            //circle center is within the top and bottom bounds of the rectangle\\n            rectSideY = y_center;\\n        }\\n        \\n        int dx = x_center - rectSideX;\\n        int dy = y_center - rectSideY;\\n        double distance = sqrt(dx * dx + dy * dy);\\n        \\n        return distance <= radius;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 610977,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int lenX = (x1 > x_center) ? x1 : (x2 < x_center) ? x2 : x_center; \\n        int lenY = (y1 > y_center) ? y1 : (y2 < y_center) ? y2 : y_center; \\n        int diffX = x_center - lenX;\\n        int diffY = y_center - lenY;\\n        return diffX * diffX + diffY * diffY <= radius * radius; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int lenX = (x1 > x_center) ? x1 : (x2 < x_center) ? x2 : x_center; \\n        int lenY = (y1 > y_center) ? y1 : (y2 < y_center) ? y2 : y_center; \\n        int diffX = x_center - lenX;\\n        int diffY = y_center - lenY;\\n        return diffX * diffX + diffY * diffY <= radius * radius; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607169,
                "title": "1401-circle-and-rectangle-overlapping-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Find the Closest Distance Between the Circle and the Rec**\\n| O(T): O() | O(S): O() | Rt: 24ms | \\n```python\\n    def checkOverlap(self, radius: int, x: int, y: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        closest_x = 0 if x1<=x<=x2 else min(abs(x-x1), abs(x2-x))\\n        closest_y = 0 if y1<=y<=y2 else min(abs(y-y1), abs(y2-y))\\n        return closest_x ** 2 + closest_y ** 2 <= radius ** 2\\n```\\nReferrence: https://leetcode.com/problems/circle-and-rectangle-overlapping/discuss/563391/Java-3-lines-super-easy-math-solution",
                "solutionTags": [],
                "code": "```python\\n    def checkOverlap(self, radius: int, x: int, y: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        closest_x = 0 if x1<=x<=x2 else min(abs(x-x1), abs(x2-x))\\n        closest_y = 0 if y1<=y<=y2 else min(abs(y-y1), abs(y2-y))\\n        return closest_x ** 2 + closest_y ** 2 <= radius ** 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 598164,
                "title": "python-scipy-optimization-solution-slow-but-something-different",
                "content": "We want to find the smallest distance from the centre of the circle, subject to being inside the rectangle. This is a constrained optimisation problem with smooth objective function, so we can just use scipy L-BFGS-B algrithm to get us the answer.\\n\\nThe answer to the question is then `True` if and only if the solution found by optimisation is smaller or equal than the radius squared.\\n\\n```python\\nimport numpy as np\\nfrom scipy.optimize import minimize\\n\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n\\n        l2norm = lambda x: (x[0] - x_center)**2 + (x[1] - y_center)**2  # objective function\\n        jacobian = lambda x: np.array([2*(x[0] - x_center), 2*(x[1] - y_center)])  # gradient\\n        min_r = minimize(\\n            l2norm, \\n            x0=[(x1 + x2) / 2., (y1 + y2) / 2.],\\n            jac=jacobian,\\n            method=\"L-BFGS-B\", \\n            bounds=[[x1, x2], [y1, y2]]\\n        ).fun\\n        \\n        return round(min_r, 10) <= radius**2\\n```",
                "solutionTags": [],
                "code": "```python\\nimport numpy as np\\nfrom scipy.optimize import minimize\\n\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n\\n        l2norm = lambda x: (x[0] - x_center)**2 + (x[1] - y_center)**2  # objective function\\n        jacobian = lambda x: np.array([2*(x[0] - x_center), 2*(x[1] - y_center)])  # gradient\\n        min_r = minimize(\\n            l2norm, \\n            x0=[(x1 + x2) / 2., (y1 + y2) / 2.],\\n            jac=jacobian,\\n            method=\"L-BFGS-B\", \\n            bounds=[[x1, x2], [y1, y2]]\\n        ).fun\\n        \\n        return round(min_r, 10) <= radius**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590737,
                "title": "simple-and-efficient-python-solution",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        rwidth, rheight = x2 - x1, y2 - y1\\n        rcx, rcy = x1 + rwidth / 2, y1 + rheight / 2\\n        \\n        if x1 <= x_center <= x2:\\n            return abs(y_center - rcy) <= radius + rheight / 2\\n        \\n        if y1 <= y_center <= y2:\\n            return abs(x_center - rcx) <= radius + rwidth / 2\\n        \\n        return any([(x - x_center) ** 2 + (y - y_center) ** 2 <= radius ** 2 for x in [x1, x2] for y in [y1, y2]])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        rwidth, rheight = x2 - x1, y2 - y1\\n        rcx, rcy = x1 + rwidth / 2, y1 + rheight / 2\\n        \\n        if x1 <= x_center <= x2:\\n            return abs(y_center - rcy) <= radius + rheight / 2\\n        \\n        if y1 <= y_center <= y2:\\n            return abs(x_center - rcx) <= radius + rwidth / 2\\n        \\n        return any([(x - x_center) ** 2 + (y - y_center) ** 2 <= radius ** 2 for x in [x1, x2] for y in [y1, y2]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590210,
                "title": "guys-doubt-if-the-test-cases-are-weak",
                "content": "\\'\\'\\'\\'\\nbool checkOverlap(int r, int x0, int y0, int x1, int y1, int x2, int y2) \\n    {\\n        int i=0,j=0;\\n        \\n        for(i=x1;i<=x2;i++)\\n        {\\n            for(j=y1;j<=y2;j++)\\n            {\\n                int d = (i-x0)*(i-x0) + (j-y0)*(j-y0) ;\\n                if(d<=r*r)\\n                    return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n\\t\\n\\tGuys, I have a doubt, ive done a Brute force by taking all the integer points in the rectangle, finding the distance from the circles centre and returning true if that distance is less than the circles radius,\\n\\tThis solution passed all the 90 test cases,\\n\\t\\n\\tbut what iff the circle and the rectangle intersect at a non integer coordinate?",
                "solutionTags": [],
                "code": "\\'\\'\\'\\'\\nbool checkOverlap(int r, int x0, int y0, int x1, int y1, int x2, int y2) \\n    {\\n        int i=0,j=0;\\n        \\n        for(i=x1;i<=x2;i++)\\n        {\\n            for(j=y1;j<=y2;j++)\\n            {\\n                int d = (i-x0)*(i-x0) + (j-y0)*(j-y0) ;\\n                if(d<=r*r)\\n                    return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n\\t\\n\\tGuys, I have a doubt, ive done a Brute force by taking all the integer points in the rectangle, finding the distance from the circles centre and returning true if that distance is less than the circles radius,\\n\\tThis solution passed all the 90 test cases,\\n\\t\\n\\tbut what iff the circle and the rectangle intersect at a non integer coordinate?",
                "codeTag": "Unknown"
            },
            {
                "id": 588315,
                "title": "java-solution-beats-both-t-and-s",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        double r2 = Math.pow(radius, 2);\\n        if (y_center >= y2) {\\n            return (x_center <= x2 && x_center >= x1 && y_center - y2 <= radius) ||\\n                    distance(x1, x_center, y2, y_center) <= r2 || distance(x2, x_center, y2, y_center) <= r2;\\n        } else if (y_center <= y1) {\\n            return (x_center <= x2 && x_center >= x1 && y1 - y_center <= radius) ||\\n                    distance(x1, x_center, y1, y_center) <= r2 || distance(x2, x_center, y1, y_center) <= r2;\\n        } else if (x_center <= x1) return x1-x_center <= radius;\\n        else if (x_center >= x2) return x_center-x2 <= radius;\\n        return true;\\n\\n\\n    }\\n\\n    public double distance(int x1, int x2, int y1, int y2) {\\n        return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        double r2 = Math.pow(radius, 2);\\n        if (y_center >= y2) {\\n            return (x_center <= x2 && x_center >= x1 && y_center - y2 <= radius) ||\\n                    distance(x1, x_center, y2, y_center) <= r2 || distance(x2, x_center, y2, y_center) <= r2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 581907,
                "title": "java-0ms-3-line-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int xres=Math.min(Math.max(x1,x2),Math.max(Math.min(x1,x2),x_center));\\n        int yres=Math.min(Math.max(y1,y2),Math.max(Math.min(y1,y2),y_center));\\n        return (x_center-xres)*(x_center-xres)+(y_center-yres)*(y_center-yres)-radius*radius<=0;\\n    }\\n}\\n```\\nExplaination: As the rectangle is axis aligned we can compare x, y coordinates to find the nearest point in rectangle to the circle. For eg:\\nfor x co ordinate- compare the least of the 2 rect abscissa with the abscissa of center to get the max of the two. Compare this with the max of the 2 rect abscissa to get the minimum. We do this to check the position and estimating nearest co-ordinate to the circle.\\n\\nNow we must check whether the distance between the calculated point and the center of radius less than or equal to the radius. if it is less than radius the circle and the rect overlap else they dont.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        int xres=Math.min(Math.max(x1,x2),Math.max(Math.min(x1,x2),x_center));\\n        int yres=Math.min(Math.max(y1,y2),Math.max(Math.min(y1,y2),y_center));\\n        return (x_center-xres)*(x_center-xres)+(y_center-yres)*(y_center-yres)-radius*radius<=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575165,
                "title": "golang",
                "content": "```\\nimport (\\n    \"math\"\\n)\\ntype point struct {\\n    x int\\n    y int\\n}\\nfunc checkOverlap(r int, x_c int, y_c int, x1 int, y1 int, x2 int, y2 int) bool {\\n    corners := []point{point{x1, y1}, point{x2, y1}, point{x1, y2}, point{x2, y2}}\\n    for _, corner := range corners {\\n        if math.Pow(float64(corner.x - x_c), 2) + math.Pow(float64(corner.y - y_c), 2) <= math.Pow(float64(r), 2) {\\n            return true\\n        }\\n    }\\n    \\n    xs := []int{x1, x2}\\n    for _, x := range xs {\\n        if x_c - r <= x && x <= x_c + r && y1 <= y_c && y_c <= y2 {\\n            return true\\n        }\\n    }\\n    ys := []int{y1, y2}\\n    for _, y := range ys {\\n        if y_c - r <= y && y <= y_c + r && x1 <= x_c && x_c <= x2 {\\n            return true\\n        }\\n    }\\n    if x1 <= x_c && x_c <= x2 && y1 <= y_c && y_c <= y2 {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport (\\n    \"math\"\\n)\\ntype point struct {\\n    x int\\n    y int\\n}\\nfunc checkOverlap(r int, x_c int, y_c int, x1 int, y1 int, x2 int, y2 int) bool {\\n    corners := []point{point{x1, y1}, point{x2, y1}, point{x1, y2}, point{x2, y2}}\\n    for _, corner := range corners {\\n        if math.Pow(float64(corner.x - x_c), 2) + math.Pow(float64(corner.y - y_c), 2) <= math.Pow(float64(r), 2) {\\n            return true\\n        }\\n    }\\n    \\n    xs := []int{x1, x2}\\n    for _, x := range xs {\\n        if x_c - r <= x && x <= x_c + r && y1 <= y_c && y_c <= y2 {\\n            return true\\n        }\\n    }\\n    ys := []int{y1, y2}\\n    for _, y := range ys {\\n        if y_c - r <= y && y <= y_c + r && x1 <= x_c && x_c <= x2 {\\n            return true\\n        }\\n    }\\n    if x1 <= x_c && x_c <= x2 && y1 <= y_c && y_c <= y2 {\\n        return true\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 571184,
                "title": "c-simple-solution-100-faster",
                "content": "This is basically a simple trick where we try to find the distance the between the center of circle and that of nearest side of rectangle.\\nAfter that we find if the answer from above is greater than the radius or not.\\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int lenX = (x1 > x_center) ? x1 : (x2 < x_center) ? x2 : x_center; \\n        int lenY = (y1 > y_center) ? y1 : (y2 < y_center) ? y2 : y_center; \\n        int diffX = x_center - lenX;\\n        int diffY = y_center - lenY;\\n        return diffX * diffX + diffY * diffY <= radius * radius; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        int lenX = (x1 > x_center) ? x1 : (x2 < x_center) ? x2 : x_center; \\n        int lenY = (y1 > y_center) ? y1 : (y2 < y_center) ? y2 : y_center; \\n        int diffX = x_center - lenX;\\n        int diffY = y_center - lenY;\\n        return diffX * diffX + diffY * diffY <= radius * radius; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570329,
                "title": "cpp-0ms-100-faster",
                "content": "```\\nstatic auto fast=[]{ios_base::sync_with_stdio(false);cin.tie(nullptr);return 0;}();\\n#define mod 1000000007\\nclass Solution \\n{\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) \\n    {\\n        //there are three cases in which a circle and a rectangle can overlap:\\n        //case 1: they overlap partially, hence circumference of circle and an edge of rectangle will intersect\\n        \\n        //left edge of rectangle\\n        int x=x1,y=y1;\\n        while(y<=y2)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true; \\n           y++; \\n        }\\n        \\n        //bottom edge of rectangle\\n        x=x1; y=y1;\\n        while(x<=x2)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true; \\n              x++;\\n        }\\n        \\n        //top edge of rectangle\\n        x=x2; y=y2;\\n        while(x>=x1)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true;\\n           x--; \\n        }\\n        \\n        //right edge of rectangle\\n        x=x2; y=y2;\\n        while(y>=y1)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true;\\n           y--; \\n        }\\n        \\n        //case 2 : circle lies in the rectangle\\n        if(x_center>=x1&&x_center<=x2&&y_center>=y1&&y_center<=y2)\\n           return true;\\n        \\n        //case 3 : rectangle lies in the circle\\n        x=x1; y=y1;\\n        int dist=dist=pow(x-x_center,2)+pow(y-y_center,2);\\n        if(dist<=pow(radius,2))\\n           return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic auto fast=[]{ios_base::sync_with_stdio(false);cin.tie(nullptr);return 0;}();\\n#define mod 1000000007\\nclass Solution \\n{\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) \\n    {\\n        //there are three cases in which a circle and a rectangle can overlap:\\n        //case 1: they overlap partially, hence circumference of circle and an edge of rectangle will intersect\\n        \\n        //left edge of rectangle\\n        int x=x1,y=y1;\\n        while(y<=y2)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true; \\n           y++; \\n        }\\n        \\n        //bottom edge of rectangle\\n        x=x1; y=y1;\\n        while(x<=x2)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true; \\n              x++;\\n        }\\n        \\n        //top edge of rectangle\\n        x=x2; y=y2;\\n        while(x>=x1)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true;\\n           x--; \\n        }\\n        \\n        //right edge of rectangle\\n        x=x2; y=y2;\\n        while(y>=y1)\\n        {\\n           int dist=pow(x-x_center,2)+pow(y-y_center,2);\\n           if(dist<=pow(radius,2))\\n              return true;\\n           y--; \\n        }\\n        \\n        //case 2 : circle lies in the rectangle\\n        if(x_center>=x1&&x_center<=x2&&y_center>=y1&&y_center<=y2)\\n           return true;\\n        \\n        //case 3 : rectangle lies in the circle\\n        x=x1; y=y1;\\n        int dist=dist=pow(x-x_center,2)+pow(y-y_center,2);\\n        if(dist<=pow(radius,2))\\n           return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 569395,
                "title": "c-100-faster-100-less-memory-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        if(x_center+radius<x1||x_center-radius>x2||y_center+radius<y1||y_center-radius>y2){\\n            cout<<\"1\";\\n            return false;\\n        }\\n        if(x_center<x1){\\n            if(y_center<y1){\\n                if(pow((x1-x_center),2)+pow((y1-y_center),2)>radius*radius){\\n                    cout<<\"2\";\\n                    return false;\\n                }\\n            }\\n            if(y_center>y2){\\n                if(pow((x1-x_center),2)+pow((y_center-y2),2)>radius*radius){\\n                    cout<<\"3\";\\n                    return false;\\n                }\\n            }\\n        }\\n        if(x_center>x2){\\n            if(y_center<y1){\\n                if(pow((x_center-x2),2)+pow((y1-y_center),2)>radius*radius){\\n                    cout<<\"4\";\\n                    return false;\\n                }\\n            }\\n            if(y_center>y2){\\n                if(pow((x_center-x2),2)+pow((y_center-y2),2)>radius*radius){\\n                    cout<<\"5\";\\n                    return false;\\n                }\\n            }\\n        }\\n            \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        if(x_center+radius<x1||x_center-radius>x2||y_center+radius<y1||y_center-radius>y2){\\n            cout<<\"1\";\\n            return false;\\n        }\\n        if(x_center<x1){\\n            if(y_center<y1){\\n                if(pow((x1-x_center),2)+pow((y1-y_center),2)>radius*radius){\\n                    cout<<\"2\";\\n                    return false;\\n                }\\n            }\\n            if(y_center>y2){\\n                if(pow((x1-x_center),2)+pow((y_center-y2),2)>radius*radius){\\n                    cout<<\"3\";\\n                    return false;\\n                }\\n            }\\n        }\\n        if(x_center>x2){\\n            if(y_center<y1){\\n                if(pow((x_center-x2),2)+pow((y1-y_center),2)>radius*radius){\\n                    cout<<\"4\";\\n                    return false;\\n                }\\n            }\\n            if(y_center>y2){\\n                if(pow((x_center-x2),2)+pow((y_center-y2),2)>radius*radius){\\n                    cout<<\"5\";\\n                    return false;\\n                }\\n            }\\n        }\\n            \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 565428,
                "title": "python-100-fast-and-100-less-memory",
                "content": "```python\\nclass Solution:\\n    def checkOverlap(self, rad: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        if xc + rad < x1: return False\\n        elif xc - rad > x2: return False\\n        elif yc + rad < y1: return False\\n        elif yc - rad > y2: return False\\n        xcc = (x1 + x2) // 2\\n        ycc = (y1 + y2) // 2\\n        return abs(xcc - xc) ** 2 + abs(ycc - yc) ** 2 <= (rad + (x2 - x1)) ** 2\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def checkOverlap(self, rad: int, xc: int, yc: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        if xc + rad < x1: return False\\n        elif xc - rad > x2: return False\\n        elif yc + rad < y1: return False\\n        elif yc - rad > y2: return False\\n        xcc = (x1 + x2) // 2\\n        ycc = (y1 + y2) // 2\\n        return abs(xcc - xc) ** 2 + abs(ycc - yc) ** 2 <= (rad + (x2 - x1)) ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565179,
                "title": "beats-100-c",
                "content": "```\\nclass Solution {\\n    double dist(int x1, int y1, int x2, int y2) {\\n        return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\\n    }\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        double xsq = (x1+x2)/2;\\n        double ysq = (y1+y2)/2;\\n        \\n        double dist_sq = dist(x_center, y_center, xsq, ysq) - radius;\\n        double diag_half = (sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)))/2;\\n        \\n        if (dist_sq < 0)\\n            return true;\\n        \\n        return !(dist_sq > diag_half);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double dist(int x1, int y1, int x2, int y2) {\\n        return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\\n    }\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        \\n        double xsq = (x1+x2)/2;\\n        double ysq = (y1+y2)/2;\\n        \\n        double dist_sq = dist(x_center, y_center, xsq, ysq) - radius;\\n        double diag_half = (sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)))/2;\\n        \\n        if (dist_sq < 0)\\n            return true;\\n        \\n        return !(dist_sq > diag_half);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564570,
                "title": "python-3-check-8-direction",
                "content": "\\tclass Solution:\\n\\t\\tdef checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n\\t\\t\\tif x_center + radius < x1:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x_center - radius > x2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif y_center + radius < y1:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif y_center - radius > y2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x2 < x_center and y1 > y_center and (x2 - x_center) ** 2 + (y1 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x2 < x_center and y2 < y_center and (x2 - x_center) ** 2 + (y2 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x1 > x_center and y1 > y_center and (x1 - x_center) ** 2 + (y1 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x1 > x_center and y2 < y_center and (x1 - x_center) ** 2 + (y2 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n\\t\\t\\tif x_center + radius < x1:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x_center - radius > x2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif y_center + radius < y1:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif y_center - radius > y2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x2 < x_center and y1 > y_center and (x2 - x_center) ** 2 + (y1 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x2 < x_center and y2 < y_center and (x2 - x_center) ** 2 + (y2 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x1 > x_center and y1 > y_center and (x1 - x_center) ** 2 + (y1 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\telif x1 > x_center and y2 < y_center and (x1 - x_center) ** 2 + (y2 - y_center) ** 2 > radius ** 2:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 564224,
                "title": "simple-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private bool CircleSegmentIntersection(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2)\\n        {\\n            checked\\n            {\\n\\n                if (x1 == x2)\\n                {\\n                    //y - aligned\\n\\n                    if (x1 > xCenter + radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    if (x1 < xCenter - radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    double r = radius;\\n                    var xDiff = (double) x1 - xCenter;\\n                    var sqYdiff = r * r - xDiff * xDiff;\\n\\n                    var sqr = Math.Sqrt(sqYdiff);\\n\\n                    var first = sqr + yCenter;\\n                    var second = -sqr + yCenter;\\n\\n                    if (first >= y1 && first <= y2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    if (second >= y1 && second <= y2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    return false;\\n                }\\n                else\\n                {\\n                    //x - aligned\\n\\n                    if (y1 > yCenter + radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    if (y1 < yCenter - radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    double r = radius;\\n                    var yDiff = (double) y1 - yCenter;\\n                    var sqXDiff = r * r - yDiff * yDiff;\\n\\n                    var sqr = Math.Sqrt(sqXDiff);\\n\\n                    var first = sqr + xCenter;\\n                    var second = -sqr + xCenter;\\n\\n                    if (first >= x1 && first <= x2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    if (second >= x1 && second <= x2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        public bool CheckOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2)\\n        {\\n            checked\\n            {\\n                //circle inside rect\\n                if (xCenter + radius <= x2 && xCenter - radius >= x1 && yCenter + radius <= y2 &&\\n                    yCenter - radius >= y1)\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x1, y1, x2, y1))\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x1, y1, x1, y2))\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x1, y2, x2, y2))\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x2, y1, x2, y2))\\n                {\\n                    return true;\\n                }\\n\\n                //rect inside circle\\n                double midX = (double) x1 + (double) (x2 - x1) / 2;\\n                double midY = (double) y1 + (double) (y2 - y1) / 2;\\n\\n                if (midX >= xCenter - radius && midX <= xCenter + radius && midY >= yCenter - radius &&\\n                    midY <= yCenter + radius)\\n                {\\n                    return true;\\n                }\\n\\n                return false;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private bool CircleSegmentIntersection(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2)\\n        {\\n            checked\\n            {\\n\\n                if (x1 == x2)\\n                {\\n                    //y - aligned\\n\\n                    if (x1 > xCenter + radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    if (x1 < xCenter - radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    double r = radius;\\n                    var xDiff = (double) x1 - xCenter;\\n                    var sqYdiff = r * r - xDiff * xDiff;\\n\\n                    var sqr = Math.Sqrt(sqYdiff);\\n\\n                    var first = sqr + yCenter;\\n                    var second = -sqr + yCenter;\\n\\n                    if (first >= y1 && first <= y2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    if (second >= y1 && second <= y2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    return false;\\n                }\\n                else\\n                {\\n                    //x - aligned\\n\\n                    if (y1 > yCenter + radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    if (y1 < yCenter - radius)\\n                    {\\n                        return false;\\n                    }\\n\\n                    double r = radius;\\n                    var yDiff = (double) y1 - yCenter;\\n                    var sqXDiff = r * r - yDiff * yDiff;\\n\\n                    var sqr = Math.Sqrt(sqXDiff);\\n\\n                    var first = sqr + xCenter;\\n                    var second = -sqr + xCenter;\\n\\n                    if (first >= x1 && first <= x2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    if (second >= x1 && second <= x2)\\n                    {\\n                        return true;\\n                    }\\n\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        public bool CheckOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2)\\n        {\\n            checked\\n            {\\n                //circle inside rect\\n                if (xCenter + radius <= x2 && xCenter - radius >= x1 && yCenter + radius <= y2 &&\\n                    yCenter - radius >= y1)\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x1, y1, x2, y1))\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x1, y1, x1, y2))\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x1, y2, x2, y2))\\n                {\\n                    return true;\\n                }\\n\\n                if (CircleSegmentIntersection(radius, xCenter, yCenter, x2, y1, x2, y2))\\n                {\\n                    return true;\\n                }\\n\\n                //rect inside circle\\n                double midX = (double) x1 + (double) (x2 - x1) / 2;\\n                double midY = (double) y1 + (double) (y2 - y1) / 2;\\n\\n                if (midX >= xCenter - radius && midX <= xCenter + radius && midY >= yCenter - radius &&\\n                    midY <= yCenter + radius)\\n                {\\n                    return true;\\n                }\\n\\n                return false;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564163,
                "title": "python-simple-math",
                "content": "```\\n# Fix the rectangle and track the center of the circle\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return (x1 <= x_center <= x2 and y1 - radius <= y_center <= y2 + radius) or (y1 <= y_center <= y2 and x1 - radius <= x_center <= x2 + radius) or ((x_center - x1)**2 + (y_center - y1)**2 <= radius ** 2) or ((x_center - x2)**2 + (y_center - y1)**2 <= radius ** 2) or ((x_center - x1)**2 + (y_center - y2)**2 <= radius ** 2) or ((x_center - x2)**2 + (y_center - y2)**2 <= radius ** 2)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Fix the rectangle and track the center of the circle\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        return (x1 <= x_center <= x2 and y1 - radius <= y_center <= y2 + radius) or (y1 <= y_center <= y2 and x1 - radius <= x_center <= x2 + radius) or ((x_center - x1)**2 + (y_center - y1)**2 <= radius ** 2) or ((x_center - x2)**2 + (y_center - y1)**2 <= radius ** 2) or ((x_center - x1)**2 + (y_center - y2)**2 <= radius ** 2) or ((x_center - x2)**2 + (y_center - y2)**2 <= radius ** 2)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 564155,
                "title": "c-easy-to-understand",
                "content": "```\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        for(int i=x1;i<=x2;i++)\\n        {\\n            for(int j=y1;j<=y2;j++)\\n            {\\n                if(((i-x_center)*(i-x_center))+((j-y_center)*(j-y_center))<=radius*radius)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        for(int i=x1;i<=x2;i++)\\n        {\\n            for(int j=y1;j<=y2;j++)\\n            {\\n                if(((i-x_center)*(i-x_center))+((j-y_center)*(j-y_center))<=radius*radius)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564131,
                "title": "a-c-python-3-solution-math-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        import math\\n        print(\"radius = \", radius)\\n\\n        if (x1 <= x_center <= x2 and y1 <= y_center <= y2):\\n            return True\\n\\n        x_dis = 0 - x_center\\n        y_dis = 0 - y_center\\n\\n        print(\"x_dis = \", x_dis, \" y_dis = \", y_dis)\\n\\n        x_center += x_dis\\n        y_center += y_dis\\n\\n        x1 += x_dis\\n        x2 += x_dis\\n\\n        y1 += y_dis\\n        y2 += y_dis\\n\\n        print(\"x1 = \", x1, \" y1 = \", y1)\\n        print(\"x2 = \", x2, \" y2 = \", y2)\\n\\n        x_mid = (x1+x2) / 2\\n        y_mid = (y1+y2) / 2\\n        print(\"x_mid = \", x_mid, \" y_mid = \", y_mid)\\n\\n        dis = (x_mid - x_center) ** 2 + (y_mid - y_center) ** 2\\n\\n        print(\"dis = \", dis)\\n\\n        x_touch, y_touch = 0, 0\\n\\n        c1_x, c1_y = x1, y1\\n        c2_x, c2_y = x1, y2\\n        c3_x, c3_y = x2, y1\\n        c4_x, c4_y = x2, y2\\n\\n        c5_x, c5_y = x1, (y1+y2)/2\\n        c6_x, c6_y = x2, (y1+y2)/2\\n\\n        print(\"c5_x = \", c5_x, \" c5_y = \", c5_y)\\n        print(\"c6_x = \", c6_x, \" c6_y = \", c6_y)\\n\\n        c7_x, c7_y = 0, y1\\n        c8_x, c8_y = 0, y2\\n\\n        dis_1 = math.sqrt(c1_x**2 + c1_y**2)\\n        print(\"dis_1 = \", dis_1)\\n        if (dis_1 <= radius):\\n            return True\\n\\n        dis_2 = math.sqrt(c2_x**2 + c2_y**2)\\n        print(\"dis_2 = \", dis_2)\\n        if (dis_2 <= radius):\\n            return True\\n\\n        dis_3 = math.sqrt(c3_x**2 + c3_y**2)\\n        print(\"dis_3 = \", dis_3)\\n        if (dis_3 <= radius):\\n            return True\\n\\n        dis_4 = math.sqrt(c4_x**2 + c4_y**2)\\n        print(\"dis_4 = \", dis_4)\\n        if (dis_4 <= radius):\\n            return True\\n\\n        dis_5 = math.sqrt(c5_x**2 + c5_y**2)\\n        print(\"dis_5 = \", dis_5)\\n        if (dis_5 <= radius):\\n            return True\\n\\n        dis_6 = math.sqrt(c6_x**2 + c6_y**2)\\n        print(\"dis_6 = \", dis_6)\\n        if (dis_6 <= radius):\\n            return True\\n\\n        if (x1*x2 < 0):\\n            dis_7 = math.sqrt(c7_x**2 + c7_y**2)\\n            print(\"dis_7 = \", dis_7)\\n            if (dis_7 <= radius):\\n                return True\\n\\n        if (x1*x2 < 0 and (y1 < 0 or y2 < 0)):\\n            dis_8 = math.sqrt(c8_x**2 + c8_y**2)\\n            print(\"dis_8 = \", dis_8)\\n            if (dis_8 <= radius):\\n                return True\\n\\n        if (y1*y2 < 0):\\n            c9_x, c9_y = x1, 0\\n            dis_9 = math.sqrt(c9_x**2 + c9_y**2)\\n            print(\"dis_9 = \", dis_9)\\n            if (dis_9 <= radius):\\n                return True\\n\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        import math\\n        print(\"radius = \", radius)\\n\\n        if (x1 <= x_center <= x2 and y1 <= y_center <= y2):\\n            return True\\n\\n        x_dis = 0 - x_center\\n        y_dis = 0 - y_center\\n\\n        print(\"x_dis = \", x_dis, \" y_dis = \", y_dis)\\n\\n        x_center += x_dis\\n        y_center += y_dis\\n\\n        x1 += x_dis\\n        x2 += x_dis\\n\\n        y1 += y_dis\\n        y2 += y_dis\\n\\n        print(\"x1 = \", x1, \" y1 = \", y1)\\n        print(\"x2 = \", x2, \" y2 = \", y2)\\n\\n        x_mid = (x1+x2) / 2\\n        y_mid = (y1+y2) / 2\\n        print(\"x_mid = \", x_mid, \" y_mid = \", y_mid)\\n\\n        dis = (x_mid - x_center) ** 2 + (y_mid - y_center) ** 2\\n\\n        print(\"dis = \", dis)\\n\\n        x_touch, y_touch = 0, 0\\n\\n        c1_x, c1_y = x1, y1\\n        c2_x, c2_y = x1, y2\\n        c3_x, c3_y = x2, y1\\n        c4_x, c4_y = x2, y2\\n\\n        c5_x, c5_y = x1, (y1+y2)/2\\n        c6_x, c6_y = x2, (y1+y2)/2\\n\\n        print(\"c5_x = \", c5_x, \" c5_y = \", c5_y)\\n        print(\"c6_x = \", c6_x, \" c6_y = \", c6_y)\\n\\n        c7_x, c7_y = 0, y1\\n        c8_x, c8_y = 0, y2\\n\\n        dis_1 = math.sqrt(c1_x**2 + c1_y**2)\\n        print(\"dis_1 = \", dis_1)\\n        if (dis_1 <= radius):\\n            return True\\n\\n        dis_2 = math.sqrt(c2_x**2 + c2_y**2)\\n        print(\"dis_2 = \", dis_2)\\n        if (dis_2 <= radius):\\n            return True\\n\\n        dis_3 = math.sqrt(c3_x**2 + c3_y**2)\\n        print(\"dis_3 = \", dis_3)\\n        if (dis_3 <= radius):\\n            return True\\n\\n        dis_4 = math.sqrt(c4_x**2 + c4_y**2)\\n        print(\"dis_4 = \", dis_4)\\n        if (dis_4 <= radius):\\n            return True\\n\\n        dis_5 = math.sqrt(c5_x**2 + c5_y**2)\\n        print(\"dis_5 = \", dis_5)\\n        if (dis_5 <= radius):\\n            return True\\n\\n        dis_6 = math.sqrt(c6_x**2 + c6_y**2)\\n        print(\"dis_6 = \", dis_6)\\n        if (dis_6 <= radius):\\n            return True\\n\\n        if (x1*x2 < 0):\\n            dis_7 = math.sqrt(c7_x**2 + c7_y**2)\\n            print(\"dis_7 = \", dis_7)\\n            if (dis_7 <= radius):\\n                return True\\n\\n        if (x1*x2 < 0 and (y1 < 0 or y2 < 0)):\\n            dis_8 = math.sqrt(c8_x**2 + c8_y**2)\\n            print(\"dis_8 = \", dis_8)\\n            if (dis_8 <= radius):\\n                return True\\n\\n        if (y1*y2 < 0):\\n            c9_x, c9_y = x1, 0\\n            dis_9 = math.sqrt(c9_x**2 + c9_y**2)\\n            print(\"dis_9 = \", dis_9)\\n            if (dis_9 <= radius):\\n                return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564085,
                "title": "python-binary-search",
                "content": "O(NlgN)\\nAlthough math is awesome but it could be more computer science related\\n```\\n    def checkOverlap(self, r: int, x0: int, y0: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        def withinCircle(x,y):\\n            a=(x-x0)**2+(y-y0)**2\\n            b=r**2\\n            return a<=b or abs(a-b)<0.0001\\n        lx,rx=x1,x2\\n        while lx<=rx:\\n            mx=lx+(rx-lx)/2\\n            for y in range(y1,y2+1):\\n                if withinCircle(mx,y):return True\\n            if math.isclose(lx,rx):break\\n            if mx>x0:\\n                rx=mx\\n            else:\\n                lx=mx\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n    def checkOverlap(self, r: int, x0: int, y0: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        def withinCircle(x,y):\\n            a=(x-x0)**2+(y-y0)**2\\n            b=r**2\\n            return a<=b or abs(a-b)<0.0001\\n        lx,rx=x1,x2\\n        while lx<=rx:\\n            mx=lx+(rx-lx)/2\\n            for y in range(y1,y2+1):\\n                if withinCircle(mx,y):return True\\n            if math.isclose(lx,rx):break\\n            if mx>x0:\\n                rx=mx\\n            else:\\n                lx=mx\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 564029,
                "title": "closest-point-is-the-median",
                "content": "We only need to consider the closest point on the rectangle to the CENTER of the circle, ignoring the shape of the circle. There are 9 cases for the relative location between the center of the circle and the rectangle: the center of the circle can be on the (upper-left, upper, upper-right, right, lower-right, lower, lower-left, left) or inside of the rectangle (we here consider \"on a corner or edge\" as inside). Under whichever case, the aforementioned closest point is:\\n\\t(median(x_center, x1, x2), median(y_center, y1, y2))\\nThen we can check if this point is inside the circle.\\n```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        int x = xc < x1 ? x1 : xc < x2 ? xc : x2, y = yc < y1 ? y1 : yc < y2 ? yc : y2;\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int r, int xc, int yc, int x1, int y1, int x2, int y2) {\\n        int x = xc < x1 ? x1 : xc < x2 ? xc : x2, y = yc < y1 ? y1 : yc < y2 ? yc : y2;\\n        return (x - xc) * (x - xc) + (y - yc) * (y - yc) <= r * r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563979,
                "title": "python-check-closest-point-on-the-rectangle",
                "content": "\"\"\"\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n\\t\\t\\t#let\\'s make rec center as origin and convert circle center\\n        \\n\\t\\t\\tx_center = abs(x_center - (x1+x2)/2)\\n\\t\\t\\ty_center = abs(y_center - (y1+y2)/2)\\n        \\n\\t\\t\\t#half size\\n\\t\\t\\thalf_rx = abs(x1-x2) / 2\\n\\t\\t\\thalf_ry = abs(y1-y2) / 2\\n        \\n\\t\\t\\t#two center distance\\n        \\n\\t\\t\\td = (x_center**2 + y_center**2) ** 1/2\\n        \\n\\t\\t\\tx_p = abs(x1-x2)/2 if x_center >= half_rx else x_center\\n\\t\\t\\ty_p = abs(y1-y2)/2 if y_center >= half_ry else y_center\\n        \\n\\t\\t\\treturn (x_p-x_center)**2+(y_p-y_center)**2 <= radius ** 2\\n\\t\\n\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n\\t\\t\\t#let\\'s make rec center as origin and convert circle center\\n        \\n\\t\\t\\tx_center = abs(x_center - (x1+x2)/2)\\n\\t\\t\\ty_center = abs(y_center - (y1+y2)/2)\\n        \\n\\t\\t\\t#half size\\n\\t\\t\\thalf_rx = abs(x1-x2) / 2\\n\\t\\t\\thalf_ry = abs(y1-y2) / 2\\n        \\n\\t\\t\\t#two center distance\\n        \\n\\t\\t\\td = (x_center**2 + y_center**2) ** 1/2\\n        \\n\\t\\t\\tx_p = abs(x1-x2)/2 if x_center >= half_rx else x_center\\n\\t\\t\\ty_p = abs(y1-y2)/2 if y_center >= half_ry else y_center\\n        \\n\\t\\t\\treturn (x_p-x_center)**2+(y_p-y_center)**2 <= radius ** 2\\n\\t\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 563776,
                "title": "c-visualizing-the-line-between-centroids-100-speed-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center,    int x1, int y1, int x2, int y2) {\\n        if ((x_center == x1 && y_center == y1) || (x_center == x2 && y_center == y2) || (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2)) return true;\\n        \\n        double sqctrx = (x2+x1)/2;   //get square\\'s center coordinate\\n        double sqctry = (y2+y1)/2;\\n        double d = sqrt(pow((sqctrx-x_center),2)+pow((sqctry-y_center),2));        //direct distance between circle center and square center\\n        double sqrd = sqrt(pow((x2-x1),2)+pow((y2-y1),2))/2;    //worst case distance from square center to edge is to a corner\\n        return sqrd+radius >= d;                                //if square\\'s edge distance and the circle\\'s edge distance are greater than the euclidean distance between the centroids, overlap exists\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkOverlap(int radius, int x_center, int y_center,    int x1, int y1, int x2, int y2) {\\n        if ((x_center == x1 && y_center == y1) || (x_center == x2 && y_center == y2) || (x_center >= x1 && x_center <= x2 && y_center >= y1 && y_center <= y2)) return true;\\n        \\n        double sqctrx = (x2+x1)/2;   //get square\\'s center coordinate\\n        double sqctry = (y2+y1)/2;\\n        double d = sqrt(pow((sqctrx-x_center),2)+pow((sqctry-y_center),2));        //direct distance between circle center and square center\\n        double sqrd = sqrt(pow((x2-x1),2)+pow((y2-y1),2))/2;    //worst case distance from square center to edge is to a corner\\n        return sqrd+radius >= d;                                //if square\\'s edge distance and the circle\\'s edge distance are greater than the euclidean distance between the centroids, overlap exists\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563725,
                "title": "easy-java-0ms-100-faster-with-explanation",
                "content": "```\\n//basic equation of circle is sq(x-h) + sq(y-k) = r2 where (h,k) is the center coordinates\\n//basically we can have 3 situation \\n//1)if any of the point of square lie inside the circle you can check all 4 points with equation sq(x-h) + sq(y-k) <= r2 if this is true then one point lie inside the circle.\\n//As per the circle definition if any point(x,y) if it lie inside circle then equation sq(x-h) + sq(y-k) <= r2\\n//Else if outside then sq(x-h) + sq(y-k) > r2\\n//2)check if any line of rectangle cuts the circle by simple pythagoras therom r2-d2>=0\\n//3)check if the circle is inside rectangle\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n\\t    int x_h1 = x1-x_center;\\n\\t    int y_h1 = y1-y_center;\\n\\t    int x_h2 = x2-x_center;\\n\\t    int y_h2 = y2-y_center;\\n\\t    int r2 = radius*radius;\\n\\t    \\n\\t    boolean insideRangeOfRectangleX= (x_center>=x1)&&(x_center<=x2);\\n\\t    boolean insideRangeOfRectangleY =(y_center>=y1) &&(y_center<=y2);\\n\\t    \\n\\t    //case1 check all four points lie inside circle\\n\\t    if(x_h1*x_h1+y_h1*y_h1<=r2 || x_h2*x_h2+y_h2*y_h2<=r2 || x_h1*x_h1+y_h2*y_h2<=r2 || x_h2*x_h2+y_h1*y_h1<=r2)\\n\\t    \\treturn true;\\n\\t    \\n\\t    if((r2-x_h1*x_h1>=0 &&insideRangeOfRectangleY) || (r2-x_h2*x_h2>=0 &&insideRangeOfRectangleY) || (r2-y_h1*y_h1>=0 &&insideRangeOfRectangleX)||(r2-y_h2*y_h2>=0 &&insideRangeOfRectangleX))\\n\\t       return true;\\n   \\n\\t    if((x_center + radius<=x2)&&(x_center -radius >=x1)&&(y_center+radius<=y2) &&(y_center-radius>=y1))\\n\\t    \\treturn true;\\n\\t    return false;\\n    \\n    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//basic equation of circle is sq(x-h) + sq(y-k) = r2 where (h,k) is the center coordinates\\n//basically we can have 3 situation \\n//1)if any of the point of square lie inside the circle you can check all 4 points with equation sq(x-h) + sq(y-k) <= r2 if this is true then one point lie inside the circle.\\n//As per the circle definition if any point(x,y) if it lie inside circle then equation sq(x-h) + sq(y-k) <= r2\\n//Else if outside then sq(x-h) + sq(y-k) > r2\\n//2)check if any line of rectangle cuts the circle by simple pythagoras therom r2-d2>=0\\n//3)check if the circle is inside rectangle\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n\\t    int x_h1 = x1-x_center;\\n\\t    int y_h1 = y1-y_center;\\n\\t    int x_h2 = x2-x_center;\\n\\t    int y_h2 = y2-y_center;\\n\\t    int r2 = radius*radius;\\n\\t    \\n\\t    boolean insideRangeOfRectangleX= (x_center>=x1)&&(x_center<=x2);\\n\\t    boolean insideRangeOfRectangleY =(y_center>=y1) &&(y_center<=y2);\\n\\t    \\n\\t    //case1 check all four points lie inside circle\\n\\t    if(x_h1*x_h1+y_h1*y_h1<=r2 || x_h2*x_h2+y_h2*y_h2<=r2 || x_h1*x_h1+y_h2*y_h2<=r2 || x_h2*x_h2+y_h1*y_h1<=r2)\\n\\t    \\treturn true;\\n\\t    \\n\\t    if((r2-x_h1*x_h1>=0 &&insideRangeOfRectangleY) || (r2-x_h2*x_h2>=0 &&insideRangeOfRectangleY) || (r2-y_h1*y_h1>=0 &&insideRangeOfRectangleX)||(r2-y_h2*y_h2>=0 &&insideRangeOfRectangleX))\\n\\t       return true;\\n   \\n\\t    if((x_center + radius<=x2)&&(x_center -radius >=x1)&&(y_center+radius<=y2) &&(y_center-radius>=y1))\\n\\t    \\treturn true;\\n\\t    return false;\\n    \\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563724,
                "title": "naive-ideas-analyzing-3-cases-python",
                "content": "```python\\nclass Solution(object):\\n    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):\\n        \\n        \"\"\"\\n        any of the following conditions \\n        1) the distance between the circle-center and one vertex of rect is smaller than the radius of sphere\\n        2) the circle center is inside the rect \\n        3) if 1) and 2) both Flase: compare circle-center and 4 edges of the rect. For each edge:\\n        3.1) any of the two endpoints of the edge is within the circle;\\n        3.2) both endpoints are outside the circle, but the distance from circle center point to the edge is less than or equal to radius.\\n       \\n        \"\"\"\\n        \\n\\t\\t# case 1) \\n\\t\\t\\n        d11 = self.distance(x_center, y_center, x1, y1)\\n        d12 = self.distance(x_center, y_center, x2, y2)\\n        d13 = self.distance(x_center, y_center, x1, y2)\\n        d14 = self.distance(x_center, y_center, x2, y1)\\n        \\n        b1 = any(d <= radius * radius for d in (d11, d12, d13, d14))\\n        \\n\\t\\t# case 2) \\n\\t\\t\\n        b2 = x1 <= x_center <= x2 and y1 <= y_center <= y2\\n        \\n        if b1 or b2:\\n            return True\\n    \\n\\t    # case 3) \\n\\t\\t\\n        b31 = self.check_edges(x_center, y_center, radius, x1, y1, x1, y2)\\n        b32 = self.check_edges(x_center, y_center, radius, x1, y2, x2, y2)\\n        b33 = self.check_edges(x_center, y_center, radius, x2, y2, x2, y1)\\n        b34 = self.check_edges(x_center, y_center, radius, x1, y1, x2, y1)\\n        \\n        return b31 or b32 or b33 or b34\\n        \\n    \\n    def distance(self, x1, y1, x2, y2):\\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2\\n    \\n    def check_edges(self, x_center, y_center, radius, x1, y1, x2, y2):\\n        if self.distance(x1, y1, x_center, y_center) <= radius ** 2:\\n            return True\\n        if self.distance(x2, y2, x_center, y_center) <= radius ** 2:\\n            return True\\n        \\n        if x1 == x2:\\n            if abs(x_center - x1) > radius:\\n                return False\\n            return y1 <= y_center <= y2 or y2 <= y_center <= y1\\n        \\n        if y1 == y2:\\n            if abs(y_center - y1) > radius:\\n                return False\\n            return x1 <= x_center <= x2 or x2 <= x_center <= x1\\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):\\n        \\n        \"\"\"\\n        any of the following conditions \\n        1) the distance between the circle-center and one vertex of rect is smaller than the radius of sphere\\n        2) the circle center is inside the rect \\n        3) if 1) and 2) both Flase: compare circle-center and 4 edges of the rect. For each edge:\\n        3.1) any of the two endpoints of the edge is within the circle;\\n        3.2) both endpoints are outside the circle, but the distance from circle center point to the edge is less than or equal to radius.\\n       \\n        \"\"\"\\n        \\n\\t\\t# case 1) \\n\\t\\t\\n        d11 = self.distance(x_center, y_center, x1, y1)\\n        d12 = self.distance(x_center, y_center, x2, y2)\\n        d13 = self.distance(x_center, y_center, x1, y2)\\n        d14 = self.distance(x_center, y_center, x2, y1)\\n        \\n        b1 = any(d <= radius * radius for d in (d11, d12, d13, d14))\\n        \\n\\t\\t# case 2) \\n\\t\\t\\n        b2 = x1 <= x_center <= x2 and y1 <= y_center <= y2\\n        \\n        if b1 or b2:\\n            return True\\n    \\n\\t    # case 3) \\n\\t\\t\\n        b31 = self.check_edges(x_center, y_center, radius, x1, y1, x1, y2)\\n        b32 = self.check_edges(x_center, y_center, radius, x1, y2, x2, y2)\\n        b33 = self.check_edges(x_center, y_center, radius, x2, y2, x2, y1)\\n        b34 = self.check_edges(x_center, y_center, radius, x1, y1, x2, y1)\\n        \\n        return b31 or b32 or b33 or b34\\n        \\n    \\n    def distance(self, x1, y1, x2, y2):\\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2\\n    \\n    def check_edges(self, x_center, y_center, radius, x1, y1, x2, y2):\\n        if self.distance(x1, y1, x_center, y_center) <= radius ** 2:\\n            return True\\n        if self.distance(x2, y2, x_center, y_center) <= radius ** 2:\\n            return True\\n        \\n        if x1 == x2:\\n            if abs(x_center - x1) > radius:\\n                return False\\n            return y1 <= y_center <= y2 or y2 <= y_center <= y1\\n        \\n        if y1 == y2:\\n            if abs(y_center - y1) > radius:\\n                return False\\n            return x1 <= x_center <= x2 or x2 <= x_center <= x1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 563709,
                "title": "java-with-explanation",
                "content": "At first we check whether the circle is inside the rectangle.\\nIf not, we calculate min distance between rectangle and circle projectons on x / y.\\nIf circle center is between y1 and y2 than horizontal line which goes through circle center crosses rectangle -> closest path is on horizontal line. And it should be LTE radius. The same logic for x.\\nIf no, min distance does not lie neither on horizontal nor on vertical lines so we check using Pythagorean theorem\\n\\n```\\npublic boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        if (x1 <= x_center && x_center <= x2 && y1 <= y_center && y_center <= y2) {\\n            return true;\\n        }\\n\\n        int minDistX = Math.min(Math.abs(x1 - x_center), Math.abs(x2 - x_center));\\n        int minDistY = Math.min(Math.abs(y1 - y_center), Math.abs(y2 - y_center));\\n\\n        if (y1 <= y_center && y_center <= y2) {\\n            return minDistX <= radius;\\n        } else if (x1 <= x_center && x_center <= x2) {\\n            return minDistY <= radius;\\n        } else {\\n            return minDistX * minDistX + minDistY * minDistY <= radius * radius;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        if (x1 <= x_center && x_center <= x2 && y1 <= y_center && y_center <= y2) {\\n            return true;\\n        }\\n\\n        int minDistX = Math.min(Math.abs(x1 - x_center), Math.abs(x2 - x_center));\\n        int minDistY = Math.min(Math.abs(y1 - y_center), Math.abs(y2 - y_center));\\n\\n        if (y1 <= y_center && y_center <= y2) {\\n            return minDistX <= radius;\\n        } else if (x1 <= x_center && x_center <= x2) {\\n            return minDistY <= radius;\\n        } else {\\n            return minDistX * minDistX + minDistY * minDistY <= radius * radius;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563644,
                "title": "java-o-m-n",
                "content": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        for (int i = x1; i <= x2; i++) {\\n            for (int j = y1; j <= y2; j++) {\\n                int x = i - x_center;\\n                int y = j - y_center;\\n                if (x * x + y * y <= radius * radius) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        for (int i = x1; i <= x2; i++) {\\n            for (int j = y1; j <= y2; j++) {\\n                int x = i - x_center;\\n                int y = j - y_center;\\n                if (x * x + y * y <= radius * radius) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 563634,
                "title": "please-help-85-86-testcases-passed-java",
                "content": "Simply checking if the rec. is left of or right or it is upside or downside, if any condition satisfies return false.\\nNot getting whats wrong in my approach\\nOne testcase is not getting passed. Please help\\nclass Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        return !(x1>x_center+radius ||\\n                x2<x_center-radius ||\\n                y1>y_center+radius ||\\n                y2<y_center-radius);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {\\n        return !(x1>x_center+radius ||\\n                x2<x_center-radius ||\\n                y1>y_center+radius ||\\n                y2<y_center-radius);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 563578,
                "title": "python-lots-of-checking",
                "content": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        def check_point_is_in_circle(i, j):\\n            diff_x = i - x_center\\n            diff_y = j - y_center\\n            \\n            return math.sqrt(diff_x ** 2 + diff_y ** 2) <= radius\\n            \\n        top_left_x, top_left_y = x1, y2\\n        bot_left_x, bot_left_y = x1, y1\\n        top_right_x, top_right_y = x2, y2\\n        bot_right_x, bot_right_y = x2, y1\\n        \\n        mid_x, mid_y = x1 + (x2 - x1) / 2, y1 + (y2 - y1) / 2\\n\\n        if check_point_is_in_circle(mid_x, mid_y):\\n            return True\\n        \\n        if check_point_is_in_circle(top_left_x, top_left_y) or check_point_is_in_circle(bot_left_x, bot_left_y) or check_point_is_in_circle(top_right_x, top_right_y) or check_point_is_in_circle(bot_right_x, bot_right_y):\\n            return True\\n\\n        # if circle is inside square\\n        if x1 <= x_center <= x2 and y1 <= y_center <= y2:\\n            return True\\n        \\n        # if circle petrudes square on one of the edges\\n        circle_north_x, circle_north_y = x_center, y_center + radius\\n        circle_west_x, circle_west_y = x_center - radius, y_center\\n        circle_south_x, circle_south_y = x_center, y_center - radius\\n        circle_east_x, circle_east_y = x_center + radius, y_center\\n        \\n        if x1 <= circle_east_x <= x2 and y1 <= circle_east_y <= y2:\\n            return True\\n\\n        if x1 <= circle_west_x <= x2 and y1 <= circle_east_y <= y2:\\n            return True\\n        \\n        if y1 <= circle_north_y <= y2 and x1 <= circle_north_x <= x2:\\n            return True\\n\\n        if y1 <= circle_south_y <= y2 and x1 <= circle_south_x <= x2:\\n            return True\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkOverlap(self, radius: int, x_center: int, y_center: int, x1: int, y1: int, x2: int, y2: int) -> bool:\\n        \\n        def check_point_is_in_circle(i, j):\\n            diff_x = i - x_center\\n            diff_y = j - y_center\\n            \\n            return math.sqrt(diff_x ** 2 + diff_y ** 2) <= radius\\n            \\n        top_left_x, top_left_y = x1, y2\\n        bot_left_x, bot_left_y = x1, y1\\n        top_right_x, top_right_y = x2, y2\\n        bot_right_x, bot_right_y = x2, y1\\n        \\n        mid_x, mid_y = x1 + (x2 - x1) / 2, y1 + (y2 - y1) / 2\\n\\n        if check_point_is_in_circle(mid_x, mid_y):\\n            return True\\n        \\n        if check_point_is_in_circle(top_left_x, top_left_y) or check_point_is_in_circle(bot_left_x, bot_left_y) or check_point_is_in_circle(top_right_x, top_right_y) or check_point_is_in_circle(bot_right_x, bot_right_y):\\n            return True\\n\\n        # if circle is inside square\\n        if x1 <= x_center <= x2 and y1 <= y_center <= y2:\\n            return True\\n        \\n        # if circle petrudes square on one of the edges\\n        circle_north_x, circle_north_y = x_center, y_center + radius\\n        circle_west_x, circle_west_y = x_center - radius, y_center\\n        circle_south_x, circle_south_y = x_center, y_center - radius\\n        circle_east_x, circle_east_y = x_center + radius, y_center\\n        \\n        if x1 <= circle_east_x <= x2 and y1 <= circle_east_y <= y2:\\n            return True\\n\\n        if x1 <= circle_west_x <= x2 and y1 <= circle_east_y <= y2:\\n            return True\\n        \\n        if y1 <= circle_north_y <= y2 and x1 <= circle_north_x <= x2:\\n            return True\\n\\n        if y1 <= circle_south_y <= y2 and x1 <= circle_south_x <= x2:\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574793,
                "content": [
                    {
                        "username": "cemozturan",
                        "content": "const closestX = (x_center, x1, x2) => {\\n  if (x_center < x1) return x1 - x_center\\n  if (x_center > x2) return x_center - x2\\n  return 0\\n}\\n\\nconst closestY = (y_center, y1, y2) => {\\n  if (y_center < y1) return y1 - y_center\\n  if (y_center > y2) return y_center - y2\\n  return 0\\n}\\n\\nvar checkOverlap = function(radius, x_center, y_center, x1, y1, x2, y2) {\\n  const xDistance = closestX(x_center, x1, x2)\\n  const yDistance = closestY(y_center, y1, y2)\\n  return (xDistance * xDistance + yDistance * yDistance <= radius * radius)\\n};"
                    },
                    {
                        "username": "longluo",
                        "content": "**3** Lines Code\\n\\n```java\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        double v_x = Math.abs(xCenter - (double) (x1 + x2) / 2) - (double) (x2 - x1) / 2;\\n        double v_y = Math.abs(yCenter - (double) (y1 + y2) / 2) - (double) (y2 - y1) / 2;\\n\\n        return Math.max(0, v_x) * Math.max(0, v_x) + Math.max(0, v_y) * Math.max(0, v_y) <= radius * radius; \\n    }\\n```\\n"
                    },
                    {
                        "username": "MaciejFicek",
                        "content": "That exercise should be removed from Leetcode or changed.\\nThere are test cases where disc and rectangle have only ONE common point.\\n\\nHow normal human does that exercise:\\n- first check if center of circle is inside rectangle - if yes, then we are finished\\n- if not, then if the objects overlap, the border of rectangle overlaps with circle. Therefore You go through whole border of rectangle and check FINITELY MANY points. You can\\'t check them all. And, You can\\'t win test with starting data (1, 0 , 0, 1, -1 ,3 ,1). This is the case when only one points is common.\\n\\nDon\\'t waste tiem on that exercise, check normal exercises."
                    }
                ]
            },
            {
                "id": 1943152,
                "content": [
                    {
                        "username": "cemozturan",
                        "content": "const closestX = (x_center, x1, x2) => {\\n  if (x_center < x1) return x1 - x_center\\n  if (x_center > x2) return x_center - x2\\n  return 0\\n}\\n\\nconst closestY = (y_center, y1, y2) => {\\n  if (y_center < y1) return y1 - y_center\\n  if (y_center > y2) return y_center - y2\\n  return 0\\n}\\n\\nvar checkOverlap = function(radius, x_center, y_center, x1, y1, x2, y2) {\\n  const xDistance = closestX(x_center, x1, x2)\\n  const yDistance = closestY(y_center, y1, y2)\\n  return (xDistance * xDistance + yDistance * yDistance <= radius * radius)\\n};"
                    },
                    {
                        "username": "longluo",
                        "content": "**3** Lines Code\\n\\n```java\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        double v_x = Math.abs(xCenter - (double) (x1 + x2) / 2) - (double) (x2 - x1) / 2;\\n        double v_y = Math.abs(yCenter - (double) (y1 + y2) / 2) - (double) (y2 - y1) / 2;\\n\\n        return Math.max(0, v_x) * Math.max(0, v_x) + Math.max(0, v_y) * Math.max(0, v_y) <= radius * radius; \\n    }\\n```\\n"
                    },
                    {
                        "username": "MaciejFicek",
                        "content": "That exercise should be removed from Leetcode or changed.\\nThere are test cases where disc and rectangle have only ONE common point.\\n\\nHow normal human does that exercise:\\n- first check if center of circle is inside rectangle - if yes, then we are finished\\n- if not, then if the objects overlap, the border of rectangle overlaps with circle. Therefore You go through whole border of rectangle and check FINITELY MANY points. You can\\'t check them all. And, You can\\'t win test with starting data (1, 0 , 0, 1, -1 ,3 ,1). This is the case when only one points is common.\\n\\nDon\\'t waste tiem on that exercise, check normal exercises."
                    }
                ]
            },
            {
                "id": 1574360,
                "content": [
                    {
                        "username": "cemozturan",
                        "content": "const closestX = (x_center, x1, x2) => {\\n  if (x_center < x1) return x1 - x_center\\n  if (x_center > x2) return x_center - x2\\n  return 0\\n}\\n\\nconst closestY = (y_center, y1, y2) => {\\n  if (y_center < y1) return y1 - y_center\\n  if (y_center > y2) return y_center - y2\\n  return 0\\n}\\n\\nvar checkOverlap = function(radius, x_center, y_center, x1, y1, x2, y2) {\\n  const xDistance = closestX(x_center, x1, x2)\\n  const yDistance = closestY(y_center, y1, y2)\\n  return (xDistance * xDistance + yDistance * yDistance <= radius * radius)\\n};"
                    },
                    {
                        "username": "longluo",
                        "content": "**3** Lines Code\\n\\n```java\\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\\n        double v_x = Math.abs(xCenter - (double) (x1 + x2) / 2) - (double) (x2 - x1) / 2;\\n        double v_y = Math.abs(yCenter - (double) (y1 + y2) / 2) - (double) (y2 - y1) / 2;\\n\\n        return Math.max(0, v_x) * Math.max(0, v_x) + Math.max(0, v_y) * Math.max(0, v_y) <= radius * radius; \\n    }\\n```\\n"
                    },
                    {
                        "username": "MaciejFicek",
                        "content": "That exercise should be removed from Leetcode or changed.\\nThere are test cases where disc and rectangle have only ONE common point.\\n\\nHow normal human does that exercise:\\n- first check if center of circle is inside rectangle - if yes, then we are finished\\n- if not, then if the objects overlap, the border of rectangle overlaps with circle. Therefore You go through whole border of rectangle and check FINITELY MANY points. You can\\'t check them all. And, You can\\'t win test with starting data (1, 0 , 0, 1, -1 ,3 ,1). This is the case when only one points is common.\\n\\nDon\\'t waste tiem on that exercise, check normal exercises."
                    }
                ]
            }
        ]
    }
]