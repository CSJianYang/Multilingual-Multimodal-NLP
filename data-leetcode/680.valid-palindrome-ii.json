[
    {
        "title": "Bitwise AND of Numbers Range",
        "question_content": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\n&nbsp;\nExample 1:\n\nInput: left = 5, right = 7\nOutput: 4\n\nExample 2:\n\nInput: left = 0, right = 0\nOutput: 0\n\nExample 3:\n\nInput: left = 1, right = 2147483647\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\t0 <= left <= right <= 231 - 1",
        "solutions": [
            {
                "id": 56729,
                "title": "bit-operation-solution-java",
                "content": "The idea is very simple: \\n\\n1. last bit of (odd number & even number) is 0.   \\n2. when m != n, There is at least an odd number and an even number, so the last bit position result is 0.   \\n3. Move m and n rigth a position.\\n\\nKeep doing step 1,2,3 until m equal to n, use a factor to record the iteration time.\\n\\n    public class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            if(m == 0){\\n                return 0;\\n            }\\n            int moveFactor = 1;\\n            while(m != n){\\n                m >>= 1;\\n                n >>= 1;\\n                moveFactor <<= 1;\\n            }\\n            return m * moveFactor;\\n        }\\n    }\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            if(m == 0){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 593317,
                "title": "simple-3-line-java-solution-faster-than-100",
                "content": "The trick here is that :\\n**Bitwise-AND of any two numbers will always produce a number less than or equal to the smaller number.**\\n\\nConsider the following example:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t12 ---- 1100\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t11 ---- 1011\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t10 ---- 1010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t9  ---- 1001\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t8  ---- 1000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t7  ---- 0111\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t6  ---- 0110\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t5  ---- 0101\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nDesired Range: [5,12]\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\nStarting from 12, the loop will first do \\n12 & 11 = 8\\n\\nNext iteration, the loop will do \\n8 & 7 = 0\\n\\nwhy did we skip anding of 10,9? Because even if we did so, the result would eventually be anded with 8 whose value would be lesser than equal to 8. \\n\\nHence, you start from the range end and keep working your way down the range till you reach the start. \\n\\n```\\n while(n>m)\\n           n = n & n-1;\\n return m&n;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n while(n>m)\\n           n = n & n-1;\\n return m&n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56746,
                "title": "one-line-c-solution",
                "content": "   Consider the bits from low to high. if n > m, the lowest bit will be 0, and then we could transfer the problem to sub-problem:  rangeBitwiseAnd(m>>1, n>>1).  \\n\\n    int rangeBitwiseAnd(int m, int n) {\\n        return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;\\n    }",
                "solutionTags": [],
                "code": "   Consider the bits from low to high. if n > m, the lowest bit will be 0, and then we could transfer the problem to sub-problem:  rangeBitwiseAnd(m>>1, n>>1).  \\n\\n    int rangeBitwiseAnd(int m, int n) {\\n        return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56719,
                "title": "java-python-easy-solution-with-explanation",
                "content": "First let's think what does bitwise AND do to two numbers, for example ( 0b means base 2)\\n\\n    4 & 7 = 0b100 & 0b111 = 0b100\\n    5 & 7 = 0b101 & 0b111 = 0b101\\n    5 & 6 = 0b101 & 0b110 = 0b100\\n\\nThe operator & is keeping those bits which is set in both number.\\n\\nFor several numbers, the operator & is keeping those bits which is 1 in every number.\\n\\nIn other word, a bit is 0 in any number will result in 0 in the answer's corresponding bit.\\n\\nNow consider a range \\n\\n    [m = 0bxyz0acd, n=0bxyz1rst]\\n\\nhere xyzpacdrst all are digits in base 2.\\n\\nWe can find two numbers that are special in the range [m, n]\\n\\n    (1) m' = 0bxyz0111\\n    (2) n' = 0bxyz1000\\n\\nThe bitwise AND of all the numbers in range [m, n] is just the bitwise AND of the two special number\\n\\n    rangeBitwiseAnd(m, n) = m' & n' = 0bxyz0000\\n\\nThis tells us, the bitwise and of the range is keeping the common bits of m and n from left to right until the first bit that they are different, padding zeros for the rest. \\n\\n**Java**\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int i = 0;\\n        for (; m != n; ++i) {\\n            m >>= 1;\\n            n >>= 1;\\n        }\\n        return n << i;\\n    }\\n\\n    // 8266 / 8266 test cases passed.\\n    // Status: Accepted\\n    // Runtime: 8 ms\\n\\n**Python**\\n\\n    def rangeBitwiseAnd(self, m, n):\\n        i = 0\\n        while m != n:\\n            m >>= 1\\n            n >>= 1\\n            i += 1\\n        return n << i\\n\\n    # 8266 / 8266 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 208 ms",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "First let's think what does bitwise AND do to two numbers, for example ( 0b means base 2)\\n\\n    4 & 7 = 0b100 & 0b111 = 0b100\\n    5 & 7 = 0b101 & 0b111 = 0b101\\n    5 & 6 = 0b101 & 0b110 = 0b100\\n\\nThe operator & is keeping those bits which is set in both number.\\n\\nFor several numbers, the operator & is keeping those bits which is 1 in every number.\\n\\nIn other word, a bit is 0 in any number will result in 0 in the answer's corresponding bit.\\n\\nNow consider a range \\n\\n    [m = 0bxyz0acd, n=0bxyz1rst]\\n\\nhere xyzpacdrst all are digits in base 2.\\n\\nWe can find two numbers that are special in the range [m, n]\\n\\n    (1) m' = 0bxyz0111\\n    (2) n' = 0bxyz1000\\n\\nThe bitwise AND of all the numbers in range [m, n] is just the bitwise AND of the two special number\\n\\n    rangeBitwiseAnd(m, n) = m' & n' = 0bxyz0000\\n\\nThis tells us, the bitwise and of the range is keeping the common bits of m and n from left to right until the first bit that they are different, padding zeros for the rest. \\n\\n**Java**\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int i = 0;\\n        for (; m != n; ++i) {\\n            m >>= 1;\\n            n >>= 1;\\n        }\\n        return n << i;\\n    }\\n\\n    // 8266 / 8266 test cases passed.\\n    // Status: Accepted\\n    // Runtime: 8 ms\\n\\n**Python**\\n\\n    def rangeBitwiseAnd(self, m, n):\\n        i = 0\\n        while m != n:\\n            m >>= 1\\n            n >>= 1\\n            i += 1\\n        return n << i\\n\\n    # 8266 / 8266 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 208 ms",
                "codeTag": "Python3"
            },
            {
                "id": 56721,
                "title": "2-line-solution-the-fastest-with-detailed-explanation",
                "content": "public int rangeBitwiseAnd(int m, int n) {\\n            while(m<n) n = n & (n-1);\\n            return n;\\n        }\\n\\nThe key point:  reduce n by removing the rightest '1' bit until n<=m;\\n\\n\\n**(1)if n>m**,suppose m = yyyzzz, n = xxx100, because m is less than n, m can be equal to three cases:\\n\\n    (a) xxx011 (if yyy==xxx)\\n    (b) less than xxx011 (if yyy==xxx)\\n    (c) yyyzzz (if yyy<xxx)\\n   \\n   for case (a), and (b), xxx011 will always be ANDed to the result, which results in xxx011 & xxx100 = uuu000(uuu == yyy&xxx == xxx);\\n\\n   for case (c), xxx000/xxx011 will always be ANDed to the result, which results in yyyzzz & xxx000 & xxx011 & xxx100 = uuu000 (uuu <= yyy & xxx)\\n \\n   => for any case, you will notice that: rangBitWiseAnd(vvvzzz,xxx100) == **uuu000** == rangBitWiseAnd(vvvzzz,xxx000), (not matter what the value of\"uuu\" will be, the last three digits will be all zero)\\n\\n   => This is why the rightest '1' bit can be removed by : n = n & (n-1);\\n  \\n    \\n**(2)when n==m,** obviously n is the result.\\n\\n **(3)when n < m**, suppose we reduce n from rangBitWiseAnd(yyyzzz,xxx100) to rangBitWiseAnd(yyyzzz,xxx000);\\n\\n  i)  xxx100 >yyyzzz => xxx >= yyy;\\n\\n  ii) xxx000 < yyyzzz => xxx <= yyy;\\n\\n=> xxx == yyy;\\n\\n=> rangBitWiseAnd(yyyzzz,xxx000) == rangeBitWiseAnd(xxxzzz,xxx000); \\n\\n=>result is xxx000, which is also n;",
                "solutionTags": [],
                "code": "public int rangeBitwiseAnd(int m, int n) {\\n            while(m<n) n = n & (n-1);\\n            return n;\\n        }\\n\\nThe key point:  reduce n by removing the rightest '1' bit until n<=m;\\n\\n\\n**(1)if n>m**,suppose m = yyyzzz, n = xxx100, because m is less than n, m can be equal to three cases:\\n\\n    (a) xxx011 (if yyy==xxx)\\n    (b) less than xxx011 (if yyy==xxx)\\n    (c) yyyzzz (if yyy<xxx)\\n   \\n   for case (a), and (b), xxx011 will always be ANDed to the result, which results in xxx011 & xxx100 = uuu000(uuu == yyy&xxx == xxx);\\n\\n   for case (c), xxx000/xxx011 will always be ANDed to the result, which results in yyyzzz & xxx000 & xxx011 & xxx100 = uuu000 (uuu <= yyy & xxx)\\n \\n   => for any case, you will notice that: rangBitWiseAnd(vvvzzz,xxx100) == **uuu000** == rangBitWiseAnd(vvvzzz,xxx000), (not matter what the value of\"uuu\" will be, the last three digits will be all zero)\\n\\n   => This is why the rightest '1' bit can be removed by : n = n & (n-1);\\n  \\n    \\n**(2)when n==m,** obviously n is the result.\\n\\n **(3)when n < m**, suppose we reduce n from rangBitWiseAnd(yyyzzz,xxx100) to rangBitWiseAnd(yyyzzz,xxx000);\\n\\n  i)  xxx100 >yyyzzz => xxx >= yyy;\\n\\n  ii) xxx000 < yyyzzz => xxx <= yyy;\\n\\n=> xxx == yyy;\\n\\n=> rangBitWiseAnd(yyyzzz,xxx000) == rangeBitWiseAnd(xxxzzz,xxx000); \\n\\n=>result is xxx000, which is also n;",
                "codeTag": "Unknown"
            },
            {
                "id": 592288,
                "title": "100-memory-c-solution-with-explanation",
                "content": "We are given range of numbers m to n. We are asked to find the bitwise and in the given range [m,n].\\nA simple solution would be to go from m to n and do a bitwise and given as following:\\t\\n\\t\\n\\tint and=0;\\n\\tfor (m;m<=n;m++)\\n\\t     {\\n\\t\\t and&=m;\\n\\t\\t }\\n\\t\\t \\nBut the solution is not effective and efficient for large range of numbers. \\nSo we use bit manipulations for solving this problem.\\nConsider the case where range is given as [5,7].\\nThe representation is given as following:\\n5 - 0101 \\n6 - 0110\\n7 - 0111\\nsince we are dealing with and(&) operator any presence of 0 with a 1 gives 0. We loop through the binary representation and in the lsbs of elements m and n if there is a 0 and a 1 then the resultant value is 0, so we shift the elements right till there are equal and count the increments made i.e for each of the shift till both the numbers become equal. When both elements m and n are equal we get the value in the lsb as 1. From the above binary representation of the numbers and range we make the following observations:\\n    1. The third bit from lsb is common for all the three numbers in the range.\\n    2. There are zeros in the first and second positions from the lsb so the resultant value will be 0 in that postion.\\n  Count is a variable wich keeps a track of number of zeros from the lsb to the case of m==n.\\n  \\n  The code is as following \\n```\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n         int count=0;\\n       // simple solution is to do bitwise and and return the sum. \\n      //     for(int i=m;i<=n;i++)\\n      //               sum&=i;        \\n\\t\\t //      return sum;\\n        while(m!=n)  // see till both numbers are equal\\n        {   // right shift both numbers by 1\\n            m>>=1; \\n            n>>=1;\\n            count++;  // increment the count.\\n        }\\n\\t\\t//count gives the number of zero places from the lsb so left shift m by count.\\n        return m<<count;\\n    }\\n\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t",
                "solutionTags": [],
                "code": "We are given range of numbers m to n. We are asked to find the bitwise and in the given range [m,n].\\nA simple solution would be to go from m to n and do a bitwise and given as following:\\t\\n\\t\\n\\tint and=0;\\n\\tfor (m;m<=n;m++)\\n\\t     {\\n\\t\\t and&=m;\\n\\t\\t }\\n\\t\\t \\nBut the solution is not effective and efficient for large range of numbers. \\nSo we use bit manipulations for solving this problem.\\nConsider the case where range is given as [5,7].\\nThe representation is given as following:\\n5 - 0101 \\n6 - 0110\\n7 - 0111\\nsince we are dealing with and(&) operator any presence of 0 with a 1 gives 0. We loop through the binary representation and in the lsbs of elements m and n if there is a 0 and a 1 then the resultant value is 0, so we shift the elements right till there are equal and count the increments made i.e for each of the shift till both the numbers become equal. When both elements m and n are equal we get the value in the lsb as 1. From the above binary representation of the numbers and range we make the following observations:\\n    1. The third bit from lsb is common for all the three numbers in the range.\\n    2. There are zeros in the first and second positions from the lsb so the resultant value will be 0 in that postion.\\n  Count is a variable wich keeps a track of number of zeros from the lsb to the case of m==n.\\n  \\n  The code is as following \\n```\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n         int count=0;\\n       // simple solution is to do bitwise and and return the sum. \\n      //     for(int i=m;i<=n;i++)\\n      //               sum&=i;        \\n\\t\\t //      return sum;\\n        while(m!=n)  // see till both numbers are equal\\n        {   // right shift both numbers by 1\\n            m>>=1; \\n            n>>=1;\\n            count++;  // increment the count.\\n        }\\n\\t\\t//count gives the number of zero places from the lsb so left shift m by count.\\n        return m<<count;\\n    }\\n\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 56753,
                "title": "accepted-c-solution-with-simple-explanation",
                "content": "    int rangeBitwiseAnd(int m, int n) {\\n    \\tint c=0;\\n    \\twhile(m!=n){\\n    \\t\\tm>>=1;\\n    \\t\\tn>>=1;\\n    \\t\\t++c;\\n    \\t}\\n    \\treturn n<<c;\\n    }\\n\\n----------\\n\\nthe result of a range bitwise is the common 'left header' of m and n.",
                "solutionTags": [],
                "code": "    int rangeBitwiseAnd(int m, int n) {\\n    \\tint c=0;\\n    \\twhile(m!=n){\\n    \\t\\tm>>=1;\\n    \\t\\tn>>=1;\\n    \\t\\t++c;\\n    \\t}\\n    \\treturn n<<c;\\n    }\\n\\n----------\\n\\nthe result of a range bitwise is the common 'left header' of m and n.",
                "codeTag": "Unknown"
            },
            {
                "id": 56845,
                "title": "my-simple-java-solution-3-lines",
                "content": "The idea is to use a mask to find the leftmost common digits of m and n. \\nExample: m=1110001, n=1110111, and you just need to find 1110000 and it will be the answer.\\n\\n    public class Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int r=Integer.MAX_VALUE;\\n        while((m&r)!=(n&r))  r=r<<1;\\n        return n&r;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int r=Integer.MAX_VALUE;\\n        while((m&r)!=(n&r))  r=r<<1;\\n        return n&r;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1513866,
                "title": "c-super-simple-intuitive-explained-solution-different-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        // edge case - zero AND anything will always stay zero\\n        if ((m == 0) || (n == 0)) return 0;\\n        \\n        // if there is a different amount of digits in binary - always will be zero\\n        if ((int)log2(m) != (int)log2(n)) return 0;\\n        \\n        // None of the above - not too many numbers left to calculate one by one...\\n        int res = m;\\n        for (long i = m; i <= n; i++)\\n            res &= i;\\n                \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        // edge case - zero AND anything will always stay zero\\n        if ((m == 0) || (n == 0)) return 0;\\n        \\n        // if there is a different amount of digits in binary - always will be zero\\n        if ((int)log2(m) != (int)log2(n)) return 0;\\n        \\n        // None of the above - not too many numbers left to calculate one by one...\\n        int res = m;\\n        for (long i = m; i <= n; i++)\\n            res &= i;\\n                \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56849,
                "title": "simple-and-easy-to-understand-java-solution",
                "content": "    public class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            int diffBits = 0;\\n            while (m != n) {\\n                m >>= 1;\\n                n >>= 1;\\n                diffBits++;\\n            }\\n            return n<<diffBits;\\n        }\\n    }\\n\\nIt's a problem that can be reduced to find the same prefix of the numbers in this range.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            int diffBits = 0;\\n            while (m != n) {\\n                m >>= 1;\\n                n >>= 1;\\n                diffBits++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 593403,
                "title": "bit-masks-no-loops",
                "content": "The approach outlined here constructs a mask of all bits that the numbers between `m` and `n` would zero when AND\\'ed together. It then ANDs this with `m & n` to get the result. This requires no loops and a small number of operations.\\n\\n## Brute force\\n\\nThe brute force solution is to iterate through all the numbers and perform the bitwise AND on the result.\\n\\n```python\\nresult = m\\n# n + 1 as the problem statement is inclusive of n\\nfor x in range(m + 1, n + 1):\\n    result &= x\\nreturn x\\n```\\n\\n## Creating a mask\\n\\nInstead of doing this, we can take the AND with `n` directly as a first step:\\n\\n```python\\nresult = m & n\\n```\\n\\nBut what about all the numbers in between `m` and `n`?\\n\\nRecall that the ith bit will change every 2^i increments. For example, the `i = 0` bit changes for every 2^0 = 1 you add:\\n\\n```\\n00\\n# Added 2^0, flip the i = 0 bit\\n01\\n# Added 2^0, flip the i = 0 bit again\\n11\\n# Added 2^0, flip the i = 0 bit again\\n10\\n```\\n\\nThe `i = 1` bit changes every 2^1 = 2 you add:\\n\\n```\\n000\\n001\\n# Added 2^1, flip the i = 1 bit\\n010\\n011\\n# Added 2^1, flip the i = 1 bit again\\n100\\n101\\n# Added 2^1, flip the i = 1 bit again\\n110\\n111\\n```\\n\\n**If there is a number `m + 2^i` in between `m` and `n`, the ith bit will be flipped**. This is the key of this solution.\\n\\nBecause we perform a bitwise AND with _every_ number in between `m` and `n`, _any_ flip of the ith bit means the ith bit in the final result will also be zero: it will either be zero in `m` to start with, or it will be one to start with and it will flip _at least once_ from 1 to 0 after we\\'ve added 2^i. The bitwise AND will pick up the flip to zero and it will \\'stick\\' in the result.\\n\\nPutting all this together, the most significant bit of the _difference_ between `m` and `n` gives us the highest bit at which all bits will become zero.\\n\\nAs an example, take `m = 5` and `n = 7`. This gives:\\n\\n```\\nm = 101\\nn = 111\\ndifference = 010\\n```\\n\\nThe difference is 2. This means the `i = 0` bit will flip, because `difference >= 2**0`, and the `i = 1` bit will also flip, because `difference >= 2**1`. The `i = 2` bit will not flip because `difference < 2**2`.\\n\\nWe can find the index of the most significant by taking the base-2 logarithm.\\n\\n```python\\nimport math\\n\\ndifference = n - m\\nmsb = math.floor(math.log2(difference))\\n```\\n\\nThen we just need to create a mask out of this so that we can zero all bits at and below this index in the result.\\n\\nOne technique is to shift the most-significant bit up one place and then subtract one, leaving all ones. For example when the the difference is 2:\\n\\n```\\ndifference = 2\\n# msb is 010\\nmsb = 1 << 2\\n# Shift up by one to get 100, then subtract one to get 011\\nbits_to_remove = (msb << 1) - 1\\n```\\n\\nWe now have a mask of all bits which the numbers between `m` and `n` will flip.\\n\\nAll that\\'s left to do is zero these bits in the result. To do this, we can just invert the mask and AND it with the `m & n` we had previously.\\n\\n```\\n# bits_to_remove was 011, so the inverse is 100\\nresult &= ~bits_to_remove\\n```\\n\\n## Final solution\\n\\nAfter taking care of the trivial case `m` = `n`, compute the difference and the mask, and then AND together `m`, `n`, and the mask.\\n\\n```\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:\\n    if m == n:\\n\\t    return m\\n\\tdifference = n - m\\n\\tmsb = 1 << math.floor(math.log2(difference))\\n\\tbits_to_remove = (msb << 1) - 1\\n\\treturn m & n & ~bits_to_remove\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```python\\nresult = m\\n# n + 1 as the problem statement is inclusive of n\\nfor x in range(m + 1, n + 1):\\n    result &= x\\nreturn x\\n```\n```python\\nresult = m & n\\n```\n```\\n00\\n# Added 2^0, flip the i = 0 bit\\n01\\n# Added 2^0, flip the i = 0 bit again\\n11\\n# Added 2^0, flip the i = 0 bit again\\n10\\n```\n```\\n000\\n001\\n# Added 2^1, flip the i = 1 bit\\n010\\n011\\n# Added 2^1, flip the i = 1 bit again\\n100\\n101\\n# Added 2^1, flip the i = 1 bit again\\n110\\n111\\n```\n```\\nm = 101\\nn = 111\\ndifference = 010\\n```\n```python\\nimport math\\n\\ndifference = n - m\\nmsb = math.floor(math.log2(difference))\\n```\n```\\ndifference = 2\\n# msb is 010\\nmsb = 1 << 2\\n# Shift up by one to get 100, then subtract one to get 011\\nbits_to_remove = (msb << 1) - 1\\n```\n```\\n# bits_to_remove was 011, so the inverse is 100\\nresult &= ~bits_to_remove\\n```\n```\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:\\n    if m == n:\\n\\t    return m\\n\\tdifference = n - m\\n\\tmsb = 1 << math.floor(math.log2(difference))\\n\\tbits_to_remove = (msb << 1) - 1\\n\\treturn m & n & ~bits_to_remove\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 56803,
                "title": "share-my-simple-java-solution",
                "content": "The little trick is to return the left common parts of two numbers.  When not equal, move right for 1 bit, util equal, return the common parts.\\n \\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n            int count = 0;\\n    \\t\\twhile(m != n){\\n    \\t\\t\\tm >>= 1;\\n    \\t\\t\\tn >>= 1;\\n    \\t\\t\\tcount++;\\n    \\t\\t}\\n    \\t\\treturn m<<=count;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The little trick is to return the left common parts of two numbers.  When not equal, move right for 1 bit, util equal, return the common parts.\\n \\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n            int count = 0;\\n    \\t\\twhile(m != n){\\n    \\t\\t\\tm >>= 1;\\n    \\t\\t\\tn >>= 1;\\n    \\t\\t\\tcount++;\\n    \\t\\t}\\n    \\t\\treturn m<<=count;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 56827,
                "title": "fast-three-line-c-solution-and-explanation-with-no-loops-or-recursion-and-one-extra-variable",
                "content": "Whenever a bit changes when counting from `m` to `n`, that bit will be 0 in the AND of the range. So we consider the XOR `x` of `m` and `n`. The leftmost 1 bit in `x` is the last bit that changes at some point when counting from `m` to `n`. This bit and the bits to the right of it are all 0 in the AND of the range. We can easily fill all the bits to the right of that bit with 1s using the OR operations below to create a mask. This technique \"smears\" the 1 bits in `x` to the right. Then it's just a matter of returning the rest of `m` excluding those bits (the bits in `m` that did not change when counting up to `n`), which is precisely the AND of the range from `m` to `n`.\\n\\n    class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            unsigned int x = m ^ n;\\n            x |= x >> 1, x |= x >> 2, x |= x >> 4, x |= x >> 8, x |= x >> 16;\\n            return m & ~x;  \\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            unsigned int x = m ^ n;\\n            x |= x >> 1, x |= x >> 2, x |= x >> 4, x |= x >> 8, x |= x >> 16;\\n            return m & ~x;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1514018,
                "title": "python-o-log-n-short-solution-explained",
                "content": "The key observation here is that if binary length of numbers is different, then the answer is equal to zero. If lengths are equal, we remove the first symbol (which is \\u201C1\\u201D) and do recursion. Basically, for two binary numbers `a1...an` and `b1...bn` the answer will be the common prefix and the rest are zeros.\\n\\n#### Complexity\\nIt is `O(log n)` both for time and space.\\n\\n#### Code\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m, n):\\n        if n == m or m == 0:\\n            return m\\n        elif len(bin(m)) != len(bin(n)):\\n            return 0\\n        else:\\n            pref = 1<<(len(bin(m))-3)\\n            return pref ^ self.rangeBitwiseAnd(m - pref, n - pref)\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m, n):\\n        if n == m or m == 0:\\n            return m\\n        elif len(bin(m)) != len(bin(n)):\\n            return 0\\n        else:\\n            pref = 1<<(len(bin(m))-3)\\n            return pref ^ self.rangeBitwiseAnd(m - pref, n - pref)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593298,
                "title": "python-o-log-n-find-common-prefix",
                "content": "Suppose `S` is the bit string of `n` and `T` is the bit string of `m`. Then the answer\\'s bit string is the `common_prefix(S, T)` padding the rest bits with `0`. \\n\\nProof:\\nWe can set both `S` and `T` with a fixed length of `32` by padding multiple leading `0`.\\nLet `P` to be the common prefix. Then the range of number is `[P + [0] + S1, P + [1] + S2]` as the first bit follows `P` are different with `S` and `T`.\\nLet `k = len(S1)` and this range must include `P + [0] + [1] * k` and `P + [1] + [0] * k`. And these two values make bitwise AND produce a `P + [0] * (k+1)`. And this make the entire Bitwise AND to be `P + [0] * (k+1)`.\\n\\n```\\ndef rangeBitwiseAnd(m, n):\\n    k = 0\\n    while n != m:\\n        n >>= 1\\n        m >>= 1\\n        k += 1\\n    return n << k\\n```\\nOne line recursive way\\n```\\ndef rangeBitwiseAnd(m, n):\\n    return rangeBitwiseAnd(m >> 1, n >> 1) << 1 if m != n else m\\n```",
                "solutionTags": [],
                "code": "```\\ndef rangeBitwiseAnd(m, n):\\n    k = 0\\n    while n != m:\\n        n >>= 1\\n        m >>= 1\\n        k += 1\\n    return n << k\\n```\n```\\ndef rangeBitwiseAnd(m, n):\\n    return rangeBitwiseAnd(m >> 1, n >> 1) << 1 if m != n else m\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 56793,
                "title": "8line-c-simple-clear-solution",
                "content": "        class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int i = 0;\\n            while(m!=n){\\n                m=m>>1;\\n                n=n>>1;\\n                ++i;        \\n            }\\n            return m<<i;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int i = 0;\\n            while(m!=n){\\n                m=m>>1;\\n                n=n>>1;\\n                ++i;        \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 56735,
                "title": "java-8-ms-one-liner-o-log-32-no-loop-no-explicit-log",
                "content": "    public int rangeBitwiseAnd(int m, int n) {\\n        return m == n ? m : m & ~((Integer.highestOneBit(m ^ n) << 1) - 1);\\n    }\\n\\nThe idea here is pretty simple: when we go from `m` to `n` some higher part may remain the same. The lower part changes. If we take the highest bit that is different, then it must be true that it is `1` in `n` and `0` in `m`, simply because `n` is larger than `m`. That means that at some point it went from `0` to `1`, and at that very point the lower digits must have all turned to zeroes, just like it happens in decimal when we go up to 1000 from 999. That means that all lower bits will be zero in the result. The differing bit will also be zero for obvious reasons. The higher part (if any) will remain as it is because it didn\\'t change at all.\\n\\nTherefore, we take that differing bit (`Integer.highestOneBit(m ^ n)`) and then create a mask that fills the whole thing with `1` to the right, including that bit. We achieve that by shifting that bit left (we can do it because we know that `n < Integer.MAX_VALUE`), then we subtract `1` so that bit goes to zero and everything to the right turns into ones. Then we bit-reverse the mask and apply it either to `m` or to `n`, doesn\\'t matter because the higher part is identical.\\n\\nUnfortunately, that doesn\\'t quite work when `m == n` because then `m ^ n` will be zero and we\\'ll end up zeroing the whole thing.\\n\\nBut it doesn\\'t end here. As noted by @gorokhovsky in a comment below, we don\\'t even have to shift the mask at all, but then we\\'ll *have* to apply it to `m`. We can do this because we know that the highest differing bit is zero in `m`, so it doesn\\'t really matter whether it\\'s zero or one in the mask. This leads to the following solution:\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        return m == n ? m : m & ~(Integer.highestOneBit(m ^ n) - 1);\\n    }\\n\\nNow, if you have a good understanding of two\\'s complement, you should instantly recognize that `~(something - 1)` is just `something` negated, which leads us to @gorokhovsky\\'s solution, refactored into one-liner:\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        return m == n ? m : m & -Integer.highestOneBit(m ^ n);\\n    }\\n\\n\\nIn case anyone feels like using `Integer.highestOneBit` is cheating, here is it\\'s code, from the standard Java library:\\n\\n        i |= (i >>  1);\\n        i |= (i >>  2);\\n        i |= (i >>  4);\\n        i |= (i >>  8);\\n        i |= (i >> 16);\\n        return i - (i >>> 1);\\n\\nDoesn\\'t look *that* complicated, does it? (If you think it does, look at `Integer.reverse` or something.)\\n\\nWhat happens here is that we first OR bit pair-wise. If any bit was `1` to begin with or had `1` to the left, it will now be `1`. Then we do the same thing with resulting pairs. Now every bit will be `1` if at least one of the following is true:\\n\\n- it was `1` to begin with;\\n- its left neighbor was `1` (so it became `1` on the previous step);\\n- its next left neighbor was `1` (because now we OR exactly with this next neighbor);\\n- its next-next left neighbor was `1` (because now we OR exactly with this next neighbor and that neighbor was ORed with its neighbor on the previous step).\\n\\nSo each *ith* bit will be `1` if at least of the bits `i + 1`, `i + 2`, `i + 3` was `1`. Note that the code uses signed shifting, but it doesn\\'t really matter because if `i` is negative we\\'ll fill everything with `1` anyway.\\n\\nBy repeating this process we finally have a mask that fills everything with `1` from the highest bit and to the right. By shifting it and subtracting we get the highest bit. Speaking of which, looks like we can use this code directly to solve our problem, although it won\\'t be a one-liner any more:\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        if (m == n) {\\n            return m;\\n        }\\n        int i = m ^ n;\\n        i |= (i >>> 1);\\n        i |= (i >>> 2);\\n        i |= (i >>> 4);\\n        i |= (i >>> 8);\\n        i |= (i >>> 16);\\n        return m & ~i;\\n    }\\n\\nOne advantage in writing the code like this is that the complexity becomes clearer. Note that we have 5 shifts here. 5 is because we use 32-bit integers. If we had `long` instead of `int`, we\\'d need 6 shifts. 32 and 64 are 5th and 6th powers of 2. Therefore, the complexity is `O(log p)`, where `p` is the number of binary digits, which is 32 in our case, but if we used arbitrary length numbers, then it\\'d be something like `O(log(log(max(m, n))))` or `O(log(log(m+n)))` for simplicity because it\\'s of the same order anyway.",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "    public int rangeBitwiseAnd(int m, int n) {\\n        return m == n ? m : m & ~((Integer.highestOneBit(m ^ n) << 1) - 1);\\n    }\\n\\nThe idea here is pretty simple: when we go from `m` to `n` some higher part may remain the same. The lower part changes. If we take the highest bit that is different, then it must be true that it is `1` in `n` and `0` in `m`, simply because `n` is larger than `m`. That means that at some point it went from `0` to `1`, and at that very point the lower digits must have all turned to zeroes, just like it happens in decimal when we go up to 1000 from 999. That means that all lower bits will be zero in the result. The differing bit will also be zero for obvious reasons. The higher part (if any) will remain as it is because it didn\\'t change at all.\\n\\nTherefore, we take that differing bit (`Integer.highestOneBit(m ^ n)`) and then create a mask that fills the whole thing with `1` to the right, including that bit. We achieve that by shifting that bit left (we can do it because we know that `n < Integer.MAX_VALUE`), then we subtract `1` so that bit goes to zero and everything to the right turns into ones. Then we bit-reverse the mask and apply it either to `m` or to `n`, doesn\\'t matter because the higher part is identical.\\n\\nUnfortunately, that doesn\\'t quite work when `m == n` because then `m ^ n` will be zero and we\\'ll end up zeroing the whole thing.\\n\\nBut it doesn\\'t end here. As noted by @gorokhovsky in a comment below, we don\\'t even have to shift the mask at all, but then we\\'ll *have* to apply it to `m`. We can do this because we know that the highest differing bit is zero in `m`, so it doesn\\'t really matter whether it\\'s zero or one in the mask. This leads to the following solution:\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        return m == n ? m : m & ~(Integer.highestOneBit(m ^ n) - 1);\\n    }\\n\\nNow, if you have a good understanding of two\\'s complement, you should instantly recognize that `~(something - 1)` is just `something` negated, which leads us to @gorokhovsky\\'s solution, refactored into one-liner:\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        return m == n ? m : m & -Integer.highestOneBit(m ^ n);\\n    }\\n\\n\\nIn case anyone feels like using `Integer.highestOneBit` is cheating, here is it\\'s code, from the standard Java library:\\n\\n        i |= (i >>  1);\\n        i |= (i >>  2);\\n        i |= (i >>  4);\\n        i |= (i >>  8);\\n        i |= (i >> 16);\\n        return i - (i >>> 1);\\n\\nDoesn\\'t look *that* complicated, does it? (If you think it does, look at `Integer.reverse` or something.)\\n\\nWhat happens here is that we first OR bit pair-wise. If any bit was `1` to begin with or had `1` to the left, it will now be `1`. Then we do the same thing with resulting pairs. Now every bit will be `1` if at least one of the following is true:\\n\\n- it was `1` to begin with;\\n- its left neighbor was `1` (so it became `1` on the previous step);\\n- its next left neighbor was `1` (because now we OR exactly with this next neighbor);\\n- its next-next left neighbor was `1` (because now we OR exactly with this next neighbor and that neighbor was ORed with its neighbor on the previous step).\\n\\nSo each *ith* bit will be `1` if at least of the bits `i + 1`, `i + 2`, `i + 3` was `1`. Note that the code uses signed shifting, but it doesn\\'t really matter because if `i` is negative we\\'ll fill everything with `1` anyway.\\n\\nBy repeating this process we finally have a mask that fills everything with `1` from the highest bit and to the right. By shifting it and subtracting we get the highest bit. Speaking of which, looks like we can use this code directly to solve our problem, although it won\\'t be a one-liner any more:\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        if (m == n) {\\n            return m;\\n        }\\n        int i = m ^ n;\\n        i |= (i >>> 1);\\n        i |= (i >>> 2);\\n        i |= (i >>> 4);\\n        i |= (i >>> 8);\\n        i |= (i >>> 16);\\n        return m & ~i;\\n    }\\n\\nOne advantage in writing the code like this is that the complexity becomes clearer. Note that we have 5 shifts here. 5 is because we use 32-bit integers. If we had `long` instead of `int`, we\\'d need 6 shifts. 32 and 64 are 5th and 6th powers of 2. Therefore, the complexity is `O(log p)`, where `p` is the number of binary digits, which is 32 in our case, but if we used arbitrary length numbers, then it\\'d be something like `O(log(log(max(m, n))))` or `O(log(log(m+n)))` for simplicity because it\\'s of the same order anyway.",
                "codeTag": "Unknown"
            },
            {
                "id": 1514377,
                "title": "java-easy-solution",
                "content": "**Idea**\\nJust update the right value and because we know that during \\'&\\' operations the value either remain the same or get decreases so we can skip many iterations!\\n\\n````\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        \\n        for(int i=right-1;i>=left;i--) {\\n            \\n            right=right&i;\\n            i=right;\\n        }\\n        return right;\\n    }\\n}\\n````\\nI really hope you get it!",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        \\n        for(int i=right-1;i>=left;i--) {\\n            \\n            right=right&i;\\n            i=right;\\n        }\\n        return right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220550,
                "title": "201-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach to solve this problem is to perform a bitwise AND operation on all numbers between the left and right limits. However, performing this operation on every number will be a costly operation.\\n\\nIf we consider the bitwise representation of the numbers in the given range, we observe that the result of the bitwise AND operation on these numbers gives us the common bits present in the left and right limits.\\n\\nThus, the task of finding the bitwise AND operation of all numbers between left and right limits reduces to finding the common bits between the left and right limits.\\n\\nTo find these common bits, we find the leftmost common bits between the left and right limits. We can start from the leftmost bit and move rightwards and check the bits of the left and right limits. If there is a mismatch between the bits, then all the bits to the right of the current bit will be set in the result of the bitwise AND operation. If there is no mismatch between the bits, then the current bit will be set in the result of the bitwise AND operation.\\n\\nAlgorithm:\\n\\n1. Initialize a variable \\'shift\\' to 0.\\n2. While the left and right limits are not equal,\\na. Right shift the left limit by 1 bit.\\nb. Right shift the right limit by 1 bit.\\nc. Increment the \\'shift\\' variable by 1.\\n3. Left shift the left limit by \\'shift\\' bits and return the result.\\n\\n# Complexity\\n- Time complexity:\\nO(1), as we are performing a constant number of operations.\\n\\n- Space complexity:\\nO(1), as we are not using any extra data structures.\\n\\n# Code\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        \\n        # Initialize a variable \\'shift\\' to 0.\\n        shift = 0\\n        \\n        # While the left and right limits are not equal,\\n        while left < right:\\n            \\n            # Right shift the left limit by 1 bit.\\n            left >>= 1\\n            \\n            # Right shift the right limit by 1 bit.\\n            right >>= 1\\n            \\n            # Increment the \\'shift\\' variable by 1.\\n            shift += 1\\n        \\n        # Left shift the left limit by \\'shift\\' bits and return the result.\\n        return left << shift\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        \\n        # Initialize a variable \\'shift\\' to 0.\\n        shift = 0\\n        \\n        # While the left and right limits are not equal,\\n        while left < right:\\n            \\n            # Right shift the left limit by 1 bit.\\n            left >>= 1\\n            \\n            # Right shift the right limit by 1 bit.\\n            right >>= 1\\n            \\n            # Increment the \\'shift\\' variable by 1.\\n            shift += 1\\n        \\n        # Left shift the left limit by \\'shift\\' bits and return the result.\\n        return left << shift\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083395,
                "title": "simple-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is very simple, we just need to take number started with left range and do the AND operation with consecutive numbers untill the number reaches its value equal to right range value.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNeed to avoid some of the cases.\\n1. If any one of the left or right range value is zero then we return 0 since Anynum&0 = 0.\\n2. If binary representation of left and right numbers are of different digits then also we should result 0.\\nExample: suppose we have got left as 1 and right as 64. So the binary values are left = 1, right = 1000000.\\nSo if we start with left AND with left + 1, i.e. 1 & 2 result becomes 0. So from next operation onwards it is always zero.\\n\\nOnce we validate these..then the solution is simple. Take the value and performe AND operation with next number.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        // if both the numbers left and right is same, return anyone\\n        if(left==0 || right ==0) return 0;\\n\\n        // if there binary numbers for left and right are of different digits\\n        if((int)log2(left)!=(int)log2(right)) return 0; \\n        //initialize output with left range\\n        int res = left;\\n\\n        while(left<right){\\n            res &= ++left;\\n        }\\n        return res;\\n    }\\n};\\n# IF THIS CODE  IS HELPFUL,  THEN  PLEASE UPVOTE!!!\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        // if both the numbers left and right is same, return anyone\\n        if(left==0 || right ==0) return 0;\\n\\n        // if there binary numbers for left and right are of different digits\\n        if((int)log2(left)!=(int)log2(right)) return 0; \\n        //initialize output with left range\\n        int res = left;\\n\\n        while(left<right){\\n            res &= ++left;\\n        }\\n        return res;\\n    }\\n};\\n# IF THIS CODE  IS HELPFUL,  THEN  PLEASE UPVOTE!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285877,
                "title": "c-solution-using-brian-kernighan-s-algo",
                "content": "So given the range [left, right] , we need to find bitwise AND of all the numbers. \\nLet\\'s say the bitwise representation of left = 101001 , right =  111001 ; Notice that the numbers between left and right ;  will ideally have some bit flips wrt left order to reach the right number . (Increment of left by 1 for every number) ; Since any one of the 0 in the bitwise representation will ultimately lead to 0 in the AND representation, so flips will lead to 0. This gives you a hint that, the part which is prefix and common to both left and right, will remain same for the entire range and the remaining part that flips , will lead to zero.\\n\\nNow the problem is to find the Prefix part which is common. \\nsay left = 1010100 and right = 1011001 , The prefix part which is common is 101, and the numbers between this range will be 101XXXX which will ultimately AND to form 1010000.\\n\\nHow Brian Kernighan\\'s algo works :  x&(x-1) will drop the lowest set bit to 0. The beauty of this Algo is, that it works in O(set bits) time. So we dont have to iterate through all the bits.\\n\\nNow we start from the larger value, and we keep dropping the least set bit until it becomes equal to n, which is the common prefix part;\\nfor ex - left = 1010001001 right = 1010101000 ; in first iteration, right becomes - 1010100000 ; Now right>left; So Again we do x &=(x-1) and drop the last set bit to form - 1010000000 , now right <left; This means that we cant drop any further bits . ( also handles 0 case);\\n\\nCode :\\n```\\nint rangeBitwiseAnd(int left, int right) {\\n        //Basically we want to find the common prefix, so what we will do is, we drop the least set bit in the higher value, and compare if it is equal to the left, if so, this is the common part \\n        int x = right;\\n        while(x>left){\\n            x = x&(x-1);\\n        }\\n        return x;\\n    }\\n\\t\\n```\\n\\nExtremely sorry if I wasn\\'t able to explain it properly, this is my first time trying to post here.  You can ping me and I\\'ll try to explain as best as possible.",
                "solutionTags": [],
                "code": "```\\nint rangeBitwiseAnd(int left, int right) {\\n        //Basically we want to find the common prefix, so what we will do is, we drop the least set bit in the higher value, and compare if it is equal to the left, if so, this is the common part \\n        int x = right;\\n        while(x>left){\\n            x = x&(x-1);\\n        }\\n        return x;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56855,
                "title": "bit-wise-solution-c-40ms",
                "content": "    int mask = ~0;\\n\\twhile (mask != 0)\\n\\t{\\n\\t\\tif ((m & mask) == (n & mask))\\n\\t\\t{\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tmask <<= 1;\\n\\t}\\n\\treturn m & mask;",
                "solutionTags": [],
                "code": "    int mask = ~0;\\n\\twhile (mask != 0)\\n\\t{\\n\\t\\tif ((m & mask) == (n & mask))\\n\\t\\t{\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tmask <<= 1;\\n\\t}\\n\\treturn m & mask;",
                "codeTag": "Unknown"
            },
            {
                "id": 56779,
                "title": "java-7-ms-solution",
                "content": "    public class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            int i = 0;\\n            for(; i<32; i ++)\\n                if(m>>i == n >>i)\\n                    break;\\n            return m>>i << i;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            int i = 0;\\n            for(; i<32; i ++)\\n                if(m>>i == n >>i)\\n                    break;\\n            return m>>i << i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 56856,
                "title": "python-different-solutions",
                "content": "        \\n    def rangeBitwiseAnd1(self, m, n):\\n        d = n-m\\n        p = 0\\n        while d:\\n            p += 1\\n            d /= 2\\n        return ((m&n)>>p)<<p\\n        \\n    def rangeBitwiseAnd2(self, m, n):\\n        if m == n:\\n            return m\\n        return self.rangeBitwiseAnd(m>>1, n>>1) << 1\\n        \\n    def rangeBitwiseAnd3(self, m, n):\\n        p = 0\\n        while m != n:\\n            m >>= 1\\n            n >>= 1\\n            p += 1\\n        return m << p\\n        \\n    def rangeBitwiseAnd(self, m, n):\\n        p = 0\\n        q = m^n\\n        while q:\\n            p += 1\\n            q >>= 1\\n        return ((m&n)>>p)<<p",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "        \\n    def rangeBitwiseAnd1(self, m, n):\\n        d = n-m\\n        p = 0\\n        while d:\\n            p += 1\\n            d /= 2\\n        return ((m&n)>>p)<<p\\n        \\n    def rangeBitwiseAnd2(self, m, n):\\n        if m == n:\\n            return m\\n        return self.rangeBitwiseAnd(m>>1, n>>1) << 1\\n        \\n    def rangeBitwiseAnd3(self, m, n):\\n        p = 0\\n        while m != n:\\n            m >>= 1\\n            n >>= 1\\n            p += 1\\n        return m << p\\n        \\n    def rangeBitwiseAnd(self, m, n):\\n        p = 0\\n        q = m^n\\n        while q:\\n            p += 1\\n            q >>= 1\\n        return ((m&n)>>p)<<p",
                "codeTag": "Python3"
            },
            {
                "id": 1513529,
                "title": "c-simple-short-o-31-solution",
                "content": "**Let\\'s Start:-**\\n1. We know, for every bit position, numbers are lying in a certain range and they form the arithmetic progression\\n2. Example:- bit position 0:- (1-1,3-3,5-5,7-7...and so on).\\n3. Example bit position1 :- (2-3,6-7,10-11,14-15... and so on).\\n4. Example bit position 2:- (4-7,12-15,20-23,28-31 and so on).\\n5. Example bit position 3:- (8-15,24-31,40-47,56-63 and so on).\\n....so on.\\nHence, we will work on every bit position and since we need to focus on bitwise AND, so numbers in the range [left,right], if they all have 1 at current bit position, **we\\'ll include (1<<i) into our answer.**\\n\\n**Wait:-**  How we\\'ll check ?\\n**Idea?:-**  We\\'ll find our interval which is closest to [left and right] and check [left,right] completely lies inside our interval [l1,r1] then, we\\'re done...we\\'ll include (1<<i) into our answer since we know [l1,r1] will contain all 1s at current bit position.\\n\\n**How to find [l1,r1]:-** For every bit position...left bound of interval follows the Arithmetic Progression...Hence you can easily find the interval closest to [left, right]. **I expect, you can do further mathematical calculations since you passed class 10th right (XD) ?**\\n\\n**If you find the Post Helpful, Do give me upvotes!**\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int rangeBitwiseAnd(int left, int right) {\\n        ll ans = 0;\\n        for(ll i=0;i<=30;i++){\\n            ll a = (1LL<<i);\\n            ll l = left - a,p = l/(a*2);\\n            ll l1 = p*a*2 + a,r1 = l1 + a - 1;\\n            if(left>=l1 and right<=r1)\\n                ans+=a;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int rangeBitwiseAnd(int left, int right) {\\n        ll ans = 0;\\n        for(ll i=0;i<=30;i++){\\n            ll a = (1LL<<i);\\n            ll l = left - a,p = l/(a*2);\\n            ll l1 = p*a*2 + a,r1 = l1 + a - 1;\\n            if(left>=l1 and right<=r1)\\n                ans+=a;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 469130,
                "title": "python-iterative-sol-based-on-bit-manipulation",
                "content": "Python iterative sol. based on bit-manipulation\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        \\n        shift = 0\\n        \\n        # find the common MSB bits.\\n        while m != n:\\n            \\n            m = m >> 1\\n            n = n >> 1\\n        \\n            shift += 1\\n        \\n        \\n        return m << shift\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        \\n        shift = 0\\n        \\n        # find the common MSB bits.\\n        while m != n:\\n            \\n            m = m >> 1\\n            n = n >> 1\\n        \\n            shift += 1\\n        \\n        \\n        return m << shift\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185693,
                "title": "c-short-simple-solution-o-1-time-o-1-space-with-explanation-and-bonus-binary-search",
                "content": "The problem, while not obvious at first, can be solved by finding longest bit string, starting at the most significant bit, where _m_ and _n_ match.\\n\\nAn example will make things a bit clearer. Take the given example of [5, 7] and for simplicity, considering them as 4 bit numbers. The following table can be formed.\\n\\n|value|**8**|**4**|**2**|**1**|\\n|:-:|:-:|:-:|:-:|:-:|\\n|5|0|1|0|1|\\n|6|0|1|1|0|\\n|7|0|1|1|1|\\n|result|0|1|0|0|\\n\\nYou can see that only the 8, and 4, columns are the same. It also shows that 7 is in fact the upper bound when using 5. While 5 could be reduced to 4 and still return the same result. The result of course being 0100b or 4.\\n\\n|value|**8**|**4**|**2**|**1**|\\n|:-:|:-:|:-:|:-:|:-:|\\n|5|0|1|0|1|\\n|6|0|1|1|0|\\n|7|0|1|1|1|\\n|8|1|0|0|0|\\n|result|0|0|0|0|\\n\\nUsing this table, we can see that a short and simple solution that increasingly masks out more least significant bits will produce the expected result.\\n\\n```cpp\\n  int rangeBitwiseAnd(int m, int n) {\\n    int mask = 0xFFFFFFFF;\\n    for (; (m & mask) != (n & mask); mask <<= 1)\\n      ;\\n    return m & mask;\\n  }\\n```\\n\\nJust for fun, and to illustrate what we\\'re looking for, I did a binary search solution. It theory it would be faster if you had to run billions of comparisons.\\n```cpp\\n  int rangeBitwiseAnd(int m, int n) {\\n    static constexpr const uint masks[] = {\\n      0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFFFC, 0xFFFFFFF8, 0xFFFFFFF0, 0xFFFFFFE0, 0xFFFFFFC0, 0xFFFFFF80,\\n      0xFFFFFF00, 0xFFFFFE00, 0xFFFFFC00, 0xFFFFF800, 0xFFFFF000, 0xFFFFE000, 0xFFFFC000, 0xFFFF8000,\\n      0xFFFF0000, 0xFFFE0000, 0xFFFC0000, 0xFFF80000, 0xFFF00000, 0xFFE00000, 0xFFC00000, 0xFF800000,\\n      0xFF000000, 0xFE000000, 0xFC000000, 0xF8000000, 0xF0000000, 0xE0000000, 0xC0000000, 0x80000000\\n      };\\n\\n    auto lo = std::begin(masks);\\n    auto hi = std::end(masks);\\n    \\n    while (lo != hi) {\\n      auto mid = lo + (hi - lo) / 2;\\n      if ((m & *mid) != (n & *mid)) {\\n        lo = mid + 1;\\n      } else {\\n        hi = mid;\\n      }\\n    }\\n    \\n    return m & *lo;\\n  }\\n```\\t\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\n  int rangeBitwiseAnd(int m, int n) {\\n    int mask = 0xFFFFFFFF;\\n    for (; (m & mask) != (n & mask); mask <<= 1)\\n      ;\\n    return m & mask;\\n  }\\n```\n```cpp\\n  int rangeBitwiseAnd(int m, int n) {\\n    static constexpr const uint masks[] = {\\n      0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFFFC, 0xFFFFFFF8, 0xFFFFFFF0, 0xFFFFFFE0, 0xFFFFFFC0, 0xFFFFFF80,\\n      0xFFFFFF00, 0xFFFFFE00, 0xFFFFFC00, 0xFFFFF800, 0xFFFFF000, 0xFFFFE000, 0xFFFFC000, 0xFFFF8000,\\n      0xFFFF0000, 0xFFFE0000, 0xFFFC0000, 0xFFF80000, 0xFFF00000, 0xFFE00000, 0xFFC00000, 0xFF800000,\\n      0xFF000000, 0xFE000000, 0xFC000000, 0xF8000000, 0xF0000000, 0xE0000000, 0xC0000000, 0x80000000\\n      };\\n\\n    auto lo = std::begin(masks);\\n    auto hi = std::end(masks);\\n    \\n    while (lo != hi) {\\n      auto mid = lo + (hi - lo) / 2;\\n      if ((m & *mid) != (n & *mid)) {\\n        lo = mid + 1;\\n      } else {\\n        hi = mid;\\n      }\\n    }\\n    \\n    return m & *lo;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513945,
                "title": "c-naive-vs-log-iterative-vs-log-recursive-bitwise-solutions-explained-100-time-80-space",
                "content": "The main intuition is that we can just keep looping from `l` to `r`, as long as our accumulator is not `0`.\\n\\nIf for example we just start with `1` (`1` in binary too) and we move to `2` (`10` in binary), we can quickly see that `&`ing them would result in `0`, since they have no matching bits:\\n\\n```cpp\\n01 // 1\\n10 // 2\\n```\\nOr again, we can move from `5` to `8` this way:\\n\\n```cpp\\n0101 // 5\\n0110 // 6\\n0111 // 7\\n1000 // 8\\n```\\nAnd again we quickly get to a situation giving us a flat `0`, since no single bit is present in all the numbers.\\n\\nImplementing this logic is then trivial and does not even time out for larger numbers (when it would take more to move to the next significant bit):\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r) {\\n        int res = l;\\n        while (res && l < r) res &= ++l;\\n        return res;\\n    }\\n};\\n```\\nCan we do better? Well, yes, if we notice that we are basically proceeding shaving the least significant bit as long as `l` and `r` are different; consider for example having to work with `25` (11001` in binary) and `29` (`11101` in binary):\\n\\n```cpp\\n11001 // 25\\n11101 // 29\\n```\\nWe can successfully proceed so that we will shave the least signficant bit of both numbers as long as they are different: `25`, for example, would lose its leftmost bit as soon as we parse `26` and the central bit in `29` will never make the cut, considering smaller numbers before.\\n\\nOnce we are done shaving bits off, once we reach a situation so that `l == r`, we can just return that number, shifted left by the amount of steps we did before, to remove the diverging bits.\\n\\nIn our example above, we will end up with a value of `3` (`11` in binary) and then, shifted left by the number of steps we did to reach this position, we will get back `24` (`11000` in binary), which is the correct answer.\\n\\nFor extra optimisation, we can actually stop as soon as we shaved off the last bit of `l` (ie: `l == 0`), since there would be no point on going on in that case and shave more bits out of `r`: we just know that there are no matching bits in that range. \\n\\nThe code for the logarithmic approach (unsurprisingly blazingly faster than the linear approach above):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r) {\\n        int count = 0;\\n        while (l && l != r) l >>= 1, r >>= 1, count++;\\n        return l << count;\\n    }\\n};\\n```\\n\\nSame, but recursive because it\\'s cooler:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r) {\\n        return (l && l != r) ? (rangeBitwiseAnd(l >> 1, r >> 1) << 1) : l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n01 // 1\\n10 // 2\\n```\n```cpp\\n0101 // 5\\n0110 // 6\\n0111 // 7\\n1000 // 8\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r) {\\n        int res = l;\\n        while (res && l < r) res &= ++l;\\n        return res;\\n    }\\n};\\n```\n```cpp\\n11001 // 25\\n11101 // 29\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r) {\\n        int count = 0;\\n        while (l && l != r) l >>= 1, r >>= 1, count++;\\n        return l << count;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r) {\\n        return (l && l != r) ? (rangeBitwiseAnd(l >> 1, r >> 1) << 1) : l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513722,
                "title": "for-mere-mortals-like-myself",
                "content": "write bitwise representation for all numbers possible with n bits, for ex with just 3 bits we can have:\\n\\n100\\n101\\n110\\n111\\nif we AND these with any numbers which need more than 3 bits to represent(8 to 15), the answer will be 0\\n\\nNow, we have broken the problem into a smaller set. We just need to individually check the 2 numbers only if they can be represented by same number of bits. We run a simple loop for that. \\n\\n```\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        int bitsLeft = 0;\\n        int bitsRight = 0;\\n        int l = left;\\n        int r = right;\\n        if (left == right) \\n            return left;\\n        while(left > 1) {\\n            left = left/2;\\n            bitsLeft++;\\n        } \\n        while(right > 1) {\\n            right = right/2;\\n            bitsRight++;\\n        }\\n        \\n        long result = l;\\n        if (bitsRight == bitsLeft &&  bitsRight != 0) {\\n            for(long i = l+1; i<= r; i++) \\n                result = result & i;\\n            return (int)result;\\n        }\\n        else \\n            return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        int bitsLeft = 0;\\n        int bitsRight = 0;\\n        int l = left;\\n        int r = right;\\n        if (left == right) \\n            return left;\\n        while(left > 1) {\\n            left = left/2;\\n            bitsLeft++;\\n        } \\n        while(right > 1) {\\n            right = right/2;\\n            bitsRight++;\\n        }\\n        \\n        long result = l;\\n        if (bitsRight == bitsLeft &&  bitsRight != 0) {\\n            for(long i = l+1; i<= r; i++) \\n                result = result & i;\\n            return (int)result;\\n        }\\n        else \\n            return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56863,
                "title": "a-math-solution",
                "content": "    public class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            if (m == n){\\n                return m;\\n            }\\n            //The highest bit of 1 in diff is the highest changed bit.\\n            int diff = m ^ n;\\n            //Index is the index of the highest changed bit. Starting at 1.\\n            int index = (int)(Math.log(diff) / Math.log(2)) + 1;\\n            //Eliminate the changed part.\\n            m = m >> index;\\n            return m << index;\\n        }\\n    }\\n\\n\\nI think this is fast since it doesn't involve loops.",
                "solutionTags": [],
                "code": "class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            if (m == n){\\n                return m;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1513133,
                "title": "c-while-loop-to-repeated-clear-out-last-digit-until-common-prefix-is-found",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int shift_count = 0;\\n        while (left != right) {\\n            // since left is not the same as right, the least significant digits must vary thus cleared.\\n            shift_count++;\\n            left /= 2;\\n            right /= 2;\\n        }\\n        return left << shift_count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int shift_count = 0;\\n        while (left != right) {\\n            // since left is not the same as right, the least significant digits must vary thus cleared.\\n            shift_count++;\\n            left /= 2;\\n            right /= 2;\\n        }\\n        return left << shift_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860667,
                "title": "ac-detailed-solution-with-bit-manipulation",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    /*\\n    We need both 1s to contribute to ans {0,0}, {0,1}, {1,0} don\\'t contribute to ans as their \"bitwise AND\" = 0\\n    We iterate binary representation of both left and right, when both numbers become equal we stop.\\n    \\n    Now we know the count of places that are different in left and right extremes, But there are (right-left-1) elements in the range, \\n    The final answer: left<<toShift. \\n    Reason? the result of a range bitwise is the common \\'left header\\' of m and n. So left shift the left number by count of bits that were different\\n    \\n        Example: [5, 7]\\n        5 - 0101\\n        7 - 0111\\n        Iteration-1:\\n        (5!=7) => left = 010, right = 011, ans = 1\\n        Iteration-2:\\n        (2!=3) => left = 01, right = 01, ans = 2\\n        Iteration-3:\\n        (1==1) break;\\n    */\\n    \\n    int rangeBitwiseAnd(int left, int right)\\n    {\\n        int toShift = 0;\\n\\t\\twhile(left != right)  // see till both numbers are equal\\n\\t\\t{\\n            // right shift both numbers by 1, basically move over to the left bit\\n\\t\\t    left = left>>1; \\n\\t\\t    right= right>>1;\\n\\t\\t    toShift++;  // increment the count.\\n\\t\\t}\\n\\t\\t//  gives the number of zero places from the lsb so left shift m by count.\\n\\t\\treturn left<<toShift;    \\n    }\\n};\\n```\\n___\\n**Edit**: Added recursive version\\nBY: @[applewolf](https://leetcode.com/problems/bitwise-and-of-numbers-range/discuss/56746/One-line-C%2B%2B-solution)\\n```\\nint rangeBitwiseAnd(int m, int n) {\\n    return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;\\n}\\n```\\n___",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    /*\\n    We need both 1s to contribute to ans {0,0}, {0,1}, {1,0} don\\'t contribute to ans as their \"bitwise AND\" = 0\\n    We iterate binary representation of both left and right, when both numbers become equal we stop.\\n    \\n    Now we know the count of places that are different in left and right extremes, But there are (right-left-1) elements in the range, \\n    The final answer: left<<toShift. \\n    Reason? the result of a range bitwise is the common \\'left header\\' of m and n. So left shift the left number by count of bits that were different\\n    \\n        Example: [5, 7]\\n        5 - 0101\\n        7 - 0111\\n        Iteration-1:\\n        (5!=7) => left = 010, right = 011, ans = 1\\n        Iteration-2:\\n        (2!=3) => left = 01, right = 01, ans = 2\\n        Iteration-3:\\n        (1==1) break;\\n    */\\n    \\n    int rangeBitwiseAnd(int left, int right)\\n    {\\n        int toShift = 0;\\n\\t\\twhile(left != right)  // see till both numbers are equal\\n\\t\\t{\\n            // right shift both numbers by 1, basically move over to the left bit\\n\\t\\t    left = left>>1; \\n\\t\\t    right= right>>1;\\n\\t\\t    toShift++;  // increment the count.\\n\\t\\t}\\n\\t\\t//  gives the number of zero places from the lsb so left shift m by count.\\n\\t\\treturn left<<toShift;    \\n    }\\n};\\n```\n```\\nint rangeBitwiseAnd(int m, int n) {\\n    return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784272,
                "title": "c-solution-with-explanations",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        if ((m == 0) || (n == 0)) // edge case 1 - zero AND anything will always stay zero\\n            return 0;\\n        \\n        if (m == n) // edge case 2 - only one number in range\\n            return m;\\n        \\n        if (n-m == 1) // edge case 3 - only two numbers in range\\n            return m&n;\\n        \\n        if ((int)log2(m) != (int)log2(n)) // if there is a different amount of digits in binary - always will be zero\\n            return 0;\\n        \\n        else // None of the above - not too many numbers left to calculate one by one...\\n        {\\n            int res = m;\\n            for (int i=m+1; i<=n;i++)\\n                res &= i;\\n                \\n            return res;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        if ((m == 0) || (n == 0)) // edge case 1 - zero AND anything will always stay zero\\n            return 0;\\n        \\n        if (m == n) // edge case 2 - only one number in range\\n            return m;\\n        \\n        if (n-m == 1) // edge case 3 - only two numbers in range\\n            return m&n;\\n        \\n        if ((int)log2(m) != (int)log2(n)) // if there is a different amount of digits in binary - always will be zero\\n            return 0;\\n        \\n        else // None of the above - not too many numbers left to calculate one by one...\\n        {\\n            int res = m;\\n            for (int i=m+1; i<=n;i++)\\n                res &= i;\\n                \\n            return res;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593239,
                "title": "easy-python-with-explanation-100-memory",
                "content": "The idea is very simple.\\nIf m and n are on different sides of nearest power of 2 then the result will be zero.\\nIf they are on the same side then we need to calculate.\\nExample:\\nm = 3 n = 5\\n3 and 5 are on different sides of nearest power of 2 wich is 4. This means stepping over 4 will eats everything and become zero. Try it on paper - you will get it.\\n```\\nimport math\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        if m == 0:\\n            return 0\\n        top = int(math.log(n,2))\\n        bottom = int(math.log(m,2))\\n        if top != bottom:\\n            return 0\\n\\n        res = m\\n        for i in range(m + 1, n + 1):\\n            res = res & i\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        if m == 0:\\n            return 0\\n        top = int(math.log(n,2))\\n        bottom = int(math.log(m,2))\\n        if top != bottom:\\n            return 0\\n\\n        res = m\\n        for i in range(m + 1, n + 1):\\n            res = res & i\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56785,
                "title": "one-line-java-solution-kerninghan-algorithm-turn-off-right-most-bit",
                "content": "    public int rangeBitwiseAnd(int m, int n) {\\n        while (n > m) n &= (n-1);\\n        return n;\\n    }\\n\\n`n & (n-1)` turns off the right most bit.",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int rangeBitwiseAnd(int m, int n) {\\n        while (n > m) n &= (n-1);\\n        return n;\\n    }\\n\\n`n & (n-1)` turns off the right most bit.",
                "codeTag": "Unknown"
            },
            {
                "id": 2743659,
                "title": "using-java-faster-than-97-52",
                "content": "public class Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int res = 0;\\n        while( m != n){\\n            m >>= 1;\\n            n >>= 1;\\n            res++;\\n        }\\n\\n        return m << res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int res = 0;\\n        while( m != n){\\n            m >>= 1;\\n            n >>= 1;\\n            res++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2661382,
                "title": "c-detailed-explanation-bit-manipulation-observation",
                "content": "```\\n/*\\n\\nTime Complexity  : O(log(right))\\nSpace Complexity : O(1)\\n\\nAlgorithm :->\\n\\n(1) First check whether there exists a transition (0-->1 / 1-->0) at a \\nparticular bit position for any two consecutive elements in the given \\nrange.\\n\\n(2) If transition exists , then the final bit will be set to zero(0) for that bit \\nindex , else set to one(1).\\n\\n(3) Another major observation would be , if there is a transition at bit \\nposition \\'i\\' , then definitely there is a transition at bit position \\'i-1\\' , \\'i-2\\' , \\n\\'i-3\\' , ...... , \\'0\\'.\\n\\n(4) So we will traverse from the right side until and unless the left and \\nright values are equal to each other.\\n\\n10100 --> 1010 --> 101 left==right\\n10101 --> 1010 --> 101\\n10110 --> 1011 --> 101\\n10111 --> 1011 --> 101 right==left\\n\\n(5) Finally , bitwise and for these range of numbers , [left...right] will be \\n(remaining_left) after the right shift operations.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        int count = 0;\\n        \\n        while(left != right){\\n            \\n            left>>=1;\\n            right>>=1;\\n            count++;\\n            \\n        }\\n        \\n        return (left<<count);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n\\nTime Complexity  : O(log(right))\\nSpace Complexity : O(1)\\n\\nAlgorithm :->\\n\\n(1) First check whether there exists a transition (0-->1 / 1-->0) at a \\nparticular bit position for any two consecutive elements in the given \\nrange.\\n\\n(2) If transition exists , then the final bit will be set to zero(0) for that bit \\nindex , else set to one(1).\\n\\n(3) Another major observation would be , if there is a transition at bit \\nposition \\'i\\' , then definitely there is a transition at bit position \\'i-1\\' , \\'i-2\\' , \\n\\'i-3\\' , ...... , \\'0\\'.\\n\\n(4) So we will traverse from the right side until and unless the left and \\nright values are equal to each other.\\n\\n10100 --> 1010 --> 101 left==right\\n10101 --> 1010 --> 101\\n10110 --> 1011 --> 101\\n10111 --> 1011 --> 101 right==left\\n\\n(5) Finally , bitwise and for these range of numbers , [left...right] will be \\n(remaining_left) after the right shift operations.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        int count = 0;\\n        \\n        while(left != right){\\n            \\n            left>>=1;\\n            right>>=1;\\n            count++;\\n            \\n        }\\n        \\n        return (left<<count);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571613,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        while(left < right)\\n            right &= right-1;\\n        return right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        while(left < right)\\n            right &= right-1;\\n        return right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894629,
                "title": "c-o-1-solution-bitwise-operations",
                "content": "This solution takes advantage of one key property of the two numbers -- the difference between them. While the code below isn\\'t necessarily the most cleanest way to solve this problem, I believe that it provides a good intuition has to why the solution works.\\n\\nNow, we have two cases -- the number of bits used to represent each number is the same (`log2(n) == log2(m)`) or the number of bits used to represent the two numbers are different (`log2(n) != log2(m)`). We can tackle the latter case first, because it is easier to understand, and then move on to the former.\\n\\nTo establish a base case, clearly, if the numbers are the same (i.e. `diff == 0`), then the bitwise AND of all the numbers in the range is simply the same as the numbers, or number, themselves. Now let us move on to our other cases.\\n\\nIf the numbers `m` and `n` differ by a number, say, `x`, then the only bits that will change within their implementation are the bits that are used to represent their difference.\\n\\n* If the number of bits used to represent each number differs, then, we can show that the bitwise and of the two numbers will always be zero. The reason is because if we ignore all leading zeros and just look at the numbers themselves, in order to count from `m`, the smaller number, to `n`, the larger number, at some point, we must flip all the bits while counting up between the numbers, progressively adding on more and more bits to express the numbers until we reach `n`. Therefore, at some point while counting, which just represents the numbers in our range, each bit will be unset at some point. Therefore, since we are doing AND and all these bits are unset, this means that the result will be zero.\\n* Otherwise, if the bits used to represent the numbers are the same, this means that we need to consider the difference between the numbers and use this to construct our final solution. The number of bits used to represent the difference are *guaranteed* to change throughout the course of the reaching from `m` to `n`, since on each addition, at least on of these bits will flip. Therefore, we just need to create a mask that clears all these bits that can change, but keeps the other \"common\" bits the same.\\n\\nNow how does this manifest in the code? Well, start out by seeing that `curr = m & n`, or just the bitwise AND of our range bounds, and \\n`diff = n - m`. Obviously, if the difference is zero, then the numbers are the same, so we just return `m & n = m = n`. Otherwise, let\\'s try and construct a mask that captures the process we explained above. We can see that we are setting all the bits in our mask while `diff > 1`, and then doing one operation bitset after that. The operation after that is really part of the same process, but as removed from the loop to avoid infinite looping in certain cases. Now, after doing this process, what are we left with. We are left with a bitmask that is set to `1` for all bits that are used to represent our `diff`. \\n\\nTherefore, looking back at our two original cases, we can see that if `m` and `n` require a different number of bits to be expressed, then the bits in either number *that are not* used in the expression of the other (e.g. if you have the numbers `27 = 11011` and `15 = 1111`, bit 5 will already be zero, since the bits used to express the range are different). After this, the bits that are in the range of our difference (e.g. in this case, `27 - 15 = 12`, which uses the first four bits, so these four bits would be part of our `difference` bits) become set to zero, which is what our mask does in the last line. Any other common bits remain set.\\n\\nIf the number of bits used to express the numbers are the same, then `m` and `n` are in fact the same, then we repeat a similar process as above, just noting that there could be a set of common bits in the beginning which are the same throughout, since they aren\\'t in the range that our `difference` bits can count through. As a result, since the `difference` bits won\\'t reach this range, these bits will not be flipped at any point in our range, and will therefore show up in our final answer as captured by `m & n`. As an example, consider the case of `7 = 111` and `5 = 101`. In this case, the are expressed with 3 bits each. Since our difference is `2`, which is expressed in two bits, the bits which are guaranteed to change value when moving in this range are bits `0` and `1`. Therefore, any bits after this (i.e. the third bit and onwards) will remain the same in the ANDing of these two numbers, since the difference bits cannot count through this range and alter those higher-order bits.\\n\\nTo accomplish this, we are simplying doing `curr & (~mask)`, which clears all of our `difference` bits, and then leaves only the common ones that remain in the end as our final answer.\\n\\n```\\nint rangeBitwiseAnd(int m, int n) {\\n        int curr = m & n;\\n        int diff = n - m;\\n        if (!diff) {\\n            return curr;\\n        }\\n        int mask = 1;\\n        while (diff > 1) {\\n            diff >>= 1;\\n            mask |= 1;\\n            mask <<= 1; \\n        }\\n        mask |= 1;\\n        return curr & (~mask);\\n    }",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "This solution takes advantage of one key property of the two numbers -- the difference between them. While the code below isn\\'t necessarily the most cleanest way to solve this problem, I believe that it provides a good intuition has to why the solution works.\\n\\nNow, we have two cases -- the number of bits used to represent each number is the same (`log2(n) == log2(m)`) or the number of bits used to represent the two numbers are different (`log2(n) != log2(m)`). We can tackle the latter case first, because it is easier to understand, and then move on to the former.\\n\\nTo establish a base case, clearly, if the numbers are the same (i.e. `diff == 0`), then the bitwise AND of all the numbers in the range is simply the same as the numbers, or number, themselves. Now let us move on to our other cases.\\n\\nIf the numbers `m` and `n` differ by a number, say, `x`, then the only bits that will change within their implementation are the bits that are used to represent their difference.\\n\\n* If the number of bits used to represent each number differs, then, we can show that the bitwise and of the two numbers will always be zero. The reason is because if we ignore all leading zeros and just look at the numbers themselves, in order to count from `m`, the smaller number, to `n`, the larger number, at some point, we must flip all the bits while counting up between the numbers, progressively adding on more and more bits to express the numbers until we reach `n`. Therefore, at some point while counting, which just represents the numbers in our range, each bit will be unset at some point. Therefore, since we are doing AND and all these bits are unset, this means that the result will be zero.\\n* Otherwise, if the bits used to represent the numbers are the same, this means that we need to consider the difference between the numbers and use this to construct our final solution. The number of bits used to represent the difference are *guaranteed* to change throughout the course of the reaching from `m` to `n`, since on each addition, at least on of these bits will flip. Therefore, we just need to create a mask that clears all these bits that can change, but keeps the other \"common\" bits the same.\\n\\nNow how does this manifest in the code? Well, start out by seeing that `curr = m & n`, or just the bitwise AND of our range bounds, and \\n`diff = n - m`. Obviously, if the difference is zero, then the numbers are the same, so we just return `m & n = m = n`. Otherwise, let\\'s try and construct a mask that captures the process we explained above. We can see that we are setting all the bits in our mask while `diff > 1`, and then doing one operation bitset after that. The operation after that is really part of the same process, but as removed from the loop to avoid infinite looping in certain cases. Now, after doing this process, what are we left with. We are left with a bitmask that is set to `1` for all bits that are used to represent our `diff`. \\n\\nTherefore, looking back at our two original cases, we can see that if `m` and `n` require a different number of bits to be expressed, then the bits in either number *that are not* used in the expression of the other (e.g. if you have the numbers `27 = 11011` and `15 = 1111`, bit 5 will already be zero, since the bits used to express the range are different). After this, the bits that are in the range of our difference (e.g. in this case, `27 - 15 = 12`, which uses the first four bits, so these four bits would be part of our `difference` bits) become set to zero, which is what our mask does in the last line. Any other common bits remain set.\\n\\nIf the number of bits used to express the numbers are the same, then `m` and `n` are in fact the same, then we repeat a similar process as above, just noting that there could be a set of common bits in the beginning which are the same throughout, since they aren\\'t in the range that our `difference` bits can count through. As a result, since the `difference` bits won\\'t reach this range, these bits will not be flipped at any point in our range, and will therefore show up in our final answer as captured by `m & n`. As an example, consider the case of `7 = 111` and `5 = 101`. In this case, the are expressed with 3 bits each. Since our difference is `2`, which is expressed in two bits, the bits which are guaranteed to change value when moving in this range are bits `0` and `1`. Therefore, any bits after this (i.e. the third bit and onwards) will remain the same in the ANDing of these two numbers, since the difference bits cannot count through this range and alter those higher-order bits.\\n\\nTo accomplish this, we are simplying doing `curr & (~mask)`, which clears all of our `difference` bits, and then leaves only the common ones that remain in the end as our final answer.\\n\\n```\\nint rangeBitwiseAnd(int m, int n) {\\n        int curr = m & n;\\n        int diff = n - m;\\n        if (!diff) {\\n            return curr;\\n        }\\n        int mask = 1;\\n        while (diff > 1) {\\n            diff >>= 1;\\n            mask |= 1;\\n            mask <<= 1; \\n        }\\n        mask |= 1;\\n        return curr & (~mask);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 595748,
                "title": "c-o-1-time-and-memory-8ms-time-100-memory-5-line-easy-understand",
                "content": "We know that, if any number between m and n have a 0 at rth index.\\nThen the `AND` of all numbers between m and n will have 0 at rth index. \\n\\nThe solution is based on the difference between the 2 numbers `m` and `n`.\\n\\nConsider the binary represenations of numbers. If count from LSB to MSB and start our indexing with 0.\\n\\n0 => 00**0**0 \\n1 => 00**0**1 \\n2 => 00**1**0 \\n3 => 00**1**1 \\n4 => 01**0**0 \\n5 => 01**0**1 \\n6 => 01**1**0 \\n7 => 01**1**1 \\n8 => 10**0**0 \\n9 => 10**0**1 \\n\\nWe can clearly see that,\\n0th bit flips after every 1 number.\\n1th bit flips after every 2 number.\\n2nd bit flips after every 4 number.\\nSimilarly, kth bit flips after every 2^k number.\\n\\nSo, if the difference between the numbers m and n is greater than 2^k then all bits till kth bit are 0 as they must be 0 in atleast 1 number in range[m,n].\\n\\nOther bits after kth bit can flip atmost 1 time in the range [m,n]. So we have to take the AND of number `m` and `n` and that will give all the bits after kth bit.\\n\\n```\\nint rangeBitwiseAnd(int m, int n) {\\n\\tif(!(n-m))\\n\\t\\treturn n;\\n\\n\\tint l = (int) log2(n-m);\\n\\n\\tl++;\\n\\tm &= n;\\n\\tm >>= l;\\n\\tm <<= l;\\n\\n\\treturn m;\\n```\\n\\nSo, Worst case Time complexity is O(1) .\\nAnd, Worst case Space complexity is O(1).",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint rangeBitwiseAnd(int m, int n) {\\n\\tif(!(n-m))\\n\\t\\treturn n;\\n\\n\\tint l = (int) log2(n-m);\\n\\n\\tl++;\\n\\tm &= n;\\n\\tm >>= l;\\n\\tm <<= l;\\n\\n\\treturn m;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594464,
                "title": "detailed-python-solution-using-binary-string",
                "content": "**Idea**\\nBitwise AND has two properties:  \\n1. ANDing same bits always results in the original bit. 1 & 1 = 1, 0 & 0 = 0.\\n2. ANDing different bits always results in zero. 1 & 0 = 0, 0 & 1 = 0.\\n\\nTherefore, given two numbers `m,n` and their binary representation `mbin, nbin`, WLOG assumme `mbin < nbin` and `len(mbin) == len(nbin)`\\n- Th result of `mbin & nbin` has the same longest common prefix `common` as `mbin` and `nbin` (property 1).  \\n- If we AND every binary number ranging from `mbin` to `nbin`, every number in [mbin, nbin] has `common` prefix, hence the result will definitely have the `common` prefix. \\n- However, the result\\'s remaining bits are zero. Why? Every bit at remaining positions, regardless of their initial value, have a chance of becoming zero as we increment from `mbin` to `nbin`. According to property 2, every remaining position is ANDed with `0` at least once, so corresponding position in result will be `0`\\n\\nFor example, given `m=49`, `n=51`, we have :\\n`mbin = 110001`, and \\n`nbin = 110011`\\n`mbin & nbin = 110001`\\nThe longest common prefix is `1100` from `m` and `n`. Therefore, `mbin & mbin+1`, `mbin+1 & nbin` also has `1100` as its prefix.\\n`result = mbin & mbin+1 & ... & nbin`\\n`= 110001 & 110010 & 110011` \\n`= 110000`\\n`1100` is still the prefix, but remaining bits are `00` since `01 & 10 & 11 = 00`\\n\\nWhat if `len(mbin) != len(nbin)`? If we right align `mbin` and `nbin`, we will see they have no common prefix, in other words `len(common) == 0`, so the result will definitely be zero. \\n\\nFor example, `m=12, n=44` have no common prefix:\\n`mbin=001100`\\n`nbin=101100`\\n\\n**Code**  \\n```py\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        mbin, nbin = bin(m)[2:], bin(n)[2:] # take out the \"0b\" format\\n        ml, nl = len(mbin), len(nbin)\\n\\t\\t# pre-pad the shorter one of mbin, nbin with zeros to make them equal in length\\n\\t\\t# optim: directly return 0 if detect ml != nl, beats 98% Python solutions\\n        if ml < nl:\\n            mbin = \\'0\\' * (nl-ml) + mbin\\n        elif nl < ml:\\n            nbin = \\'0\\' * (ml-nl) + nbin\\n\\t\\t# at this point, mbin and nbin are aligned at least significant bit, len(mbin) = len(nbin)\\n        \\n\\t\\t# find out the length of longest common prefix\\n        common_prefix_length = 0\\n        for mbit, nbit in zip(mbin, nbin):\\n            if mbit == nbit:\\n                common_prefix_length += 1\\n            else: # detect the first different bit, the end of common prefix \\n                break\\n\\n\\t\\t# the result has the common prefix mbin[:common], and 0 as remaining bits. Total length should be max(ml,nl)\\n        res = mbin[:common_prefix_length] + \\'0\\'*(max(ml,nl)-common_prefix_length)\\n        return int(res, 2)\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```py\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        mbin, nbin = bin(m)[2:], bin(n)[2:] # take out the \"0b\" format\\n        ml, nl = len(mbin), len(nbin)\\n\\t\\t# pre-pad the shorter one of mbin, nbin with zeros to make them equal in length\\n\\t\\t# optim: directly return 0 if detect ml != nl, beats 98% Python solutions\\n        if ml < nl:\\n            mbin = \\'0\\' * (nl-ml) + mbin\\n        elif nl < ml:\\n            nbin = \\'0\\' * (ml-nl) + nbin\\n\\t\\t# at this point, mbin and nbin are aligned at least significant bit, len(mbin) = len(nbin)\\n        \\n\\t\\t# find out the length of longest common prefix\\n        common_prefix_length = 0\\n        for mbit, nbit in zip(mbin, nbin):\\n            if mbit == nbit:\\n                common_prefix_length += 1\\n            else: # detect the first different bit, the end of common prefix \\n                break\\n\\n\\t\\t# the result has the common prefix mbin[:common], and 0 as remaining bits. Total length should be max(ml,nl)\\n        res = mbin[:common_prefix_length] + \\'0\\'*(max(ml,nl)-common_prefix_length)\\n        return int(res, 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594192,
                "title": "javascript-bit-manipulation-w-comments-explanation",
                "content": "**solution:**\\n```\\nfunction rangeBitwiseAnd(m, n) {\\n    // number of shifts we had to make\\n    let i = 0;\\n\\t\\n    // go until m and n are equal\\n    while (m !== n) {\\n        // right shift both m and n\\n        m >>= 1;\\n        n >>= 1;\\n        // that\\'s 1 more shift\\n        i++;\\n    }\\n\\t\\n    // pad 0\\'s on right of m by right shifting by i\\n    return (m <<= i);\\n}\\n```\\n**explanation:**\\nthe idea here is to keep right shifting m and n until they are equal.\\nwe do this, because, until they are equal, the bits that are lost in the right shift will ultimately end up yielding a 0 bit on the ANDs anyways.\\n\\nExample: \\n```\\nlet m = 27, n = 31\\n```\\n\\n* 27 = 11011\\n* 31 = 11111\\n\\n**1st shift**\\n1101\\n1111\\nshifts = 1\\n\\n**2nd shift**\\n110\\n111\\nshifts = 2\\n\\n**3rd shift**\\n11\\n11\\nshifts = 3\\n\\nThey are now equal, and that required 3 shifts.\\n\\nWe take that `11`, and after left shifting 3 times, it becomes 11000 which is `24`.\\n\\nThe reason this is the answer, is because if we were to loop from m and n, ANDing everything, everything to the right of that 1 would become a zero anyways, due to differing bits, since they weren\\'t equal until this point anyways.\\n",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunction rangeBitwiseAnd(m, n) {\\n    // number of shifts we had to make\\n    let i = 0;\\n\\t\\n    // go until m and n are equal\\n    while (m !== n) {\\n        // right shift both m and n\\n        m >>= 1;\\n        n >>= 1;\\n        // that\\'s 1 more shift\\n        i++;\\n    }\\n\\t\\n    // pad 0\\'s on right of m by right shifting by i\\n    return (m <<= i);\\n}\\n```\n```\\nlet m = 27, n = 31\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 593348,
                "title": "summary-of-5-solutions",
                "content": "## core idea\\n\\nm := leading_common_bits + 0 + remaining_bits_of_m\\nn  := leading_common_bits + 1 + remaining_bits_of_n\\n( leading_common_bits can be 0 )\\nthen the result should be:\\nleading_common_bits + 0 + remaining_bits_all_0\\n\\nSo the crux is to find the highest bit that is different between m and n.\\n\\nWe use `1-bit` to denote a bit that is set to 1 in the following.\\n\\n\\n## solution 1\\uFF1Areduce and conquer\\nO(logN)\\n1. if n > m\\uFF0Cthen there are at least 2 consecutive numbers, their lowest bits are 0 and 1 respectively, so the lowest bit of the bitwise AND result must be 0. \\n2.   n >>= 1, m >>= 1 \\u2192  back to step 1\\n```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:        \\n        pos = 0        \\n        while n > m:\\n            n, m, pos = n >> 1, m >> 1, pos + 1            \\n        return m << pos\\n```\\n\\n## solution 2\\uFF1Afind the highest 1-bit of m^n\\n\\n### solution 2.1\\nO(logN)\\n```python\\npos = 0\\nwhile diff:\\n    pos, diff = pos + 1, diff >> 1\\n```\\n\\n### solution 2.2 pythonic\\n```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:        \\n        diff = n ^ m\\n        pos = diff.bit_length()                 \\n        return ( m >> pos ) << pos\\n```\\n\\n### solution 2.3 a bit faster than logN\\nThe highest `1-bit` of m^n \\u2208 `1-bit`s of n. \\nSo we don\\'t need to check all the bits (as in solution 1 or solution 2.1). \\nInstead, we can skip the `0-bit`s of n by iteratively setting the lowest `1-bit` of n to 0 until n <= m.\\nIf we assume the probability of a bit to be 1 is 0.5, then theoretically, solution 2.3 costs half the time of solution 2.1 in average.\\n\\n```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        while n > m:\\n            n &= (n-1)     # setting the lowest `1-bit` of n to 0 \\n        return n\\n```\\n\\n\\n## solution 3\\uFF1A O(loglogN)\\nStill we are trying to find the highest `1-bit` of m^n, but in logarithmic of the number of bits of N, thus `O(loglogN)`.\\n\\n```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        diff = m ^ n\\n        for i in 1,2,4,8,16:\\n            diff |= diff >> i\\n        return m & (~diff)\\n```\\n\\nexplanation:\\n```python\\ni |= (i >>  1);   # the following 1 bit of 1-bit is set to 1\\ni |= (i >>  2);   # the following 3 bit of 1-bit is set to 1\\ni |= (i >>  4);  # the following 7 bit of 1-bit is set to 1\\ni |= (i >>  8);   # the following 15 bit of 1-bit is set to 1\\ni |= (i >> 16);   # the following 31 bit of 1-bit is set to 1\\n```\\nThus in the end, all the following bits of the highest `1-bit` is set to 1",
                "solutionTags": [],
                "code": "```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:        \\n        pos = 0        \\n        while n > m:\\n            n, m, pos = n >> 1, m >> 1, pos + 1            \\n        return m << pos\\n```\n```python\\npos = 0\\nwhile diff:\\n    pos, diff = pos + 1, diff >> 1\\n```\n```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:        \\n        diff = n ^ m\\n        pos = diff.bit_length()                 \\n        return ( m >> pos ) << pos\\n```\n```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        while n > m:\\n            n &= (n-1)     # setting the lowest `1-bit` of n to 0 \\n        return n\\n```\n```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        diff = m ^ n\\n        for i in 1,2,4,8,16:\\n            diff |= diff >> i\\n        return m & (~diff)\\n```\n```python\\ni |= (i >>  1);   # the following 1 bit of 1-bit is set to 1\\ni |= (i >>  2);   # the following 3 bit of 1-bit is set to 1\\ni |= (i >>  4);  # the following 7 bit of 1-bit is set to 1\\ni |= (i >>  8);   # the following 15 bit of 1-bit is set to 1\\ni |= (i >> 16);   # the following 31 bit of 1-bit is set to 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 333497,
                "title": "c-o-1-solution-clever-clever-trix-koderz-kamp",
                "content": "\\nOne think to consider... to get from any lesset bit to any higher bit via all the numbers in-between, you must visit all lower bits than the higher bit.\\n\\nExample:\\n0010 to 0 1000\\n\\nYou would have to visit the following:\\n\\n0010\\n0011\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nSo, we have to toggle all bits after the 1st 1.\\n\\nAnd these all together and you get ZERO...\\n\\nNow try this:\\n10000 to 0 10100\\n\\nYou would have to visit the following:\\n\\n10000\\n10001\\n10010\\n10011\\n10100\\n\\nAnd these all together and you get 10000\\n\\nAnd so a pattern emerges. Every bit which is not equal, means we must flop all lower bits to get to said digit.\\n\\nSo, we can just keep shifting both numbers right until they are equal. Count this number of shifts, and then shift back by that amount. Everything in the lower \"nibble\" of this potato chip would be too fattening, and so we would need to cut it out like bad origami. \\n\\nAnd so our code becomes this:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        \\n        if ((m & n) == 0) { return 0; }\\n        \\n        int aLow = m;\\n        int aHigh = n;\\n        int aShiftCount = 0;\\n        \\n        while (aLow != aHigh) {\\n            aLow = aLow >> 1;\\n            aHigh = aHigh >> 1;\\n            aShiftCount += 1;\\n        }\\n        \\n        return (aHigh << aShiftCount);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        \\n        if ((m & n) == 0) { return 0; }\\n        \\n        int aLow = m;\\n        int aHigh = n;\\n        int aShiftCount = 0;\\n        \\n        while (aLow != aHigh) {\\n            aLow = aLow >> 1;\\n            aHigh = aHigh >> 1;\\n            aShiftCount += 1;\\n        }\\n        \\n        return (aHigh << aShiftCount);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56799,
                "title": "the-most-terrific-and-simplest-solution-accepted-as-best-submission-in-c-well-explained",
                "content": "Since we are doing bitwise then let's think as it is. AND all numbers from m to n inclusive then all the right different bits will be erased until all bits are identical in the left part; why? the consecutive attribute of the problem -> from m to n inclusive means gradual increments from m to n  <font color=\"#ff0000\">each step with another 1 addition causing more bits zero</font>\\n\\nBang! End of Story!\\n\\n- space cost O(1).\\n- time cost O(1) - > the digits' number is limited under 32 considering the range.\\n\\n\\n----------\\n\\n    int rangeBitwiseAnd(int m, int n)\\n    {\\n        int count = 0;\\n        while(m != n)\\n        {\\n            m >>= 1;\\n            n >>= 1;\\n            count++;\\n        }\\n        return m << count;\\n    }",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "Since we are doing bitwise then let's think as it is. AND all numbers from m to n inclusive then all the right different bits will be erased until all bits are identical in the left part; why? the consecutive attribute of the problem -> from m to n inclusive means gradual increments from m to n  <font color=\"#ff0000\">each step with another 1 addition causing more bits zero</font>\\n\\nBang! End of Story!\\n\\n- space cost O(1).\\n- time cost O(1) - > the digits' number is limited under 32 considering the range.\\n\\n\\n----------\\n\\n    int rangeBitwiseAnd(int m, int n)\\n    {\\n        int count = 0;\\n        while(m != n)\\n        {\\n            m >>= 1;\\n            n >>= 1;\\n            count++;\\n        }\\n        return m << count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56894,
                "title": "water-problem",
                "content": "if m-n+1>=2, then the last bit must be 0;\\n\\nthen we just operater m>>=1, n>>=1, and repeat until m==n (m-n+1==1), in this situation, the last digits would the same as m or n.\\n\\n    class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int ans = 0;\\n            int i = 0;\\n            while (m != n) {\\n                n >>= 1;\\n                m >>= 1;\\n                ++i;\\n            }\\n            ans += (m<<i);\\n            return ans;\\n        }\\n    };\\n\\nUPD :\\nthanks @[zhanqing][1]\\n , the code can be further cleaned as :\\n\\n    class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int i = 0;\\n            while (m != n) {\\n                n >>= 1;\\n                m >>= 1;\\n                ++i;\\n            }\\n            return (m << i);\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/user/zhanqing",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int ans = 0;\\n            int i = 0;\\n            while (m != n) {\\n                n >>= 1;\\n                m >>= 1;\\n                ++i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3637655,
                "title": "c-easiest-solution-bit-manipulation",
                "content": "\\n# Approach\\nFind the common bits from the MSB side of both numbers. Rest bits will end up having 0 as the ANDed value.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int ans = 0;\\n\\n        for(int i=31;i>=0;i--){\\n            if((m & (1 << i)) != (n & (1 << i))){\\n                break;\\n            }\\n            else{\\n                ans |= ((m & (1 << i)));\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n***PLEASE UPVOTE IF THIS WAS HELPFUL***",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int ans = 0;\\n\\n        for(int i=31;i>=0;i--){\\n            if((m & (1 << i)) != (n & (1 << i))){\\n                break;\\n            }\\n            else{\\n                ans |= ((m & (1 << i)));\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514159,
                "title": "c-brute-force-thinking",
                "content": "```\\nObserve  any range which are like left < 2^i , right >= 2^i ,for all i\\nyou will always get 0 for these type of ranges. for example 3 < (2^2), 5>=(2^2)\\ntheir binary 3 - 011, 4 - 100 ,5 - 101 ,beacuse at every position of digit u can always\\nhave one are more 0\\'s.\\n\\nso for the rest case which will be small we can loop them.\\n\\nit\\'s not quite good solution but it\\'s also one way to do the things! :)\\n```\\n                               \\n```\\nint rangeBitwiseAnd(int left, int right) {\\n        int c1 = 0,c2 =0;\\n        for(int i=0;i<32;i++)\\n        {\\n            if(left>>i & 1) c1 = i;\\n            if(right>>i & 1) c2 = i;\\n        }\\n        \\n        if(c1 == c2)\\n        {\\n            int ans = left;\\n            for(long i=left;i<=right;i++)\\n                ans &= i;\\n            return ans;\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nObserve  any range which are like left < 2^i , right >= 2^i ,for all i\\nyou will always get 0 for these type of ranges. for example 3 < (2^2), 5>=(2^2)\\ntheir binary 3 - 011, 4 - 100 ,5 - 101 ,beacuse at every position of digit u can always\\nhave one are more 0\\'s.\\n\\nso for the rest case which will be small we can loop them.\\n\\nit\\'s not quite good solution but it\\'s also one way to do the things! :)\\n```\n```\\nint rangeBitwiseAnd(int left, int right) {\\n        int c1 = 0,c2 =0;\\n        for(int i=0;i<32;i++)\\n        {\\n            if(left>>i & 1) c1 = i;\\n            if(right>>i & 1) c2 = i;\\n        }\\n        \\n        if(c1 == c2)\\n        {\\n            int ans = left;\\n            for(long i=left;i<=right;i++)\\n                ans &= i;\\n            return ans;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513209,
                "title": "go-solution-so-easy-even-a-caveman-can-do-it-o-1",
                "content": "In all honesty, it can be tricky to come up with this. Even I had a hard time thinking about it. What helps is using a large number of examples to help you realize that we can get common prefixes for numbers.\\n\\nTime: O(logn) - see comments below for explanation.\\nSpace: O(1)\\n\\n```go\\nfunc rangeBitwiseAnd(left int, right int) int {\\n    // Shift both numbers to the right until you find something in common in the prefix of both numbers\\n    count := 0\\n    for left != right {\\n        left >>= 1\\n        right >>= 1\\n        count += 1\\n    }\\n    \\n    return left << count // Shift back to get the prefix in the original bit positions it appeared in\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc rangeBitwiseAnd(left int, right int) int {\\n    // Shift both numbers to the right until you find something in common in the prefix of both numbers\\n    count := 0\\n    for left != right {\\n        left >>= 1\\n        right >>= 1\\n        count += 1\\n    }\\n    \\n    return left << count // Shift back to get the prefix in the original bit positions it appeared in\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1231665,
                "title": "short-easy-and-fastest-c-solution-with-explanation-bit-manipulation",
                "content": "The idea to iterate over all the elements from left to right is not a good one, instead I suggest something better than this. \\nIf we can get the \"Common Bit Prefix\" of left and right, that itself is our answer.\\nFor Example, let us consider: left = 357 and right = 366\\nUsing Binary representation, (only 9 bits represented and other 21 bits are all 0\\'s )\\nleft     = 101100101\\nright   = 101101110\\nThe common prefix is \" 10110 \" so the answer will be 256+0+64+32+0 = 352 .\\nThe above idea holds true because there always exists a number between left and right, such that after the first prefix mismatching bit in left and right, all the other combinations of 0\\'s and 1\\'s after the mismatching bit are covered by the numbers between left and right and the Bitwise AND of the range results in low ( 0 ) if any of the numbers between left and right is low ( 0 ) for that particular bit.\\n```\\nclass Solution { \\npublic:                                    \\n    int rangeBitwiseAnd(int left, int right) { \\n        //Finding the Common Prefix of left and right is the answer\\n        int ans=0;\\n        for(int bit=30;bit>=0;bit--){\\n            // To check for a specific bit number\\n            if((left&(1<<bit))!=(right&(1<<bit)))\\n                break; //Not Common: so no need to check further\\n            else\\n                ans|=(left&(1<<bit)); //Common: add the value of specific bit and continue \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution { \\npublic:                                    \\n    int rangeBitwiseAnd(int left, int right) { \\n        //Finding the Common Prefix of left and right is the answer\\n        int ans=0;\\n        for(int bit=30;bit>=0;bit--){\\n            // To check for a specific bit number\\n            if((left&(1<<bit))!=(right&(1<<bit)))\\n                break; //Not Common: so no need to check further\\n            else\\n                ans|=(left&(1<<bit)); //Common: add the value of specific bit and continue \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 595968,
                "title": "java-beginner-s-solution",
                "content": "My logic works on the principle that if any 2^x`[x is an int]` is present in the range, excluding m, then the value will be 0.\\nAs in, between 5 and 10, there is 8 `[2^3]` which corresponds to `1000` in binary. when this happens, the bitwise AND with its previous number will always yield 0.\\n\\nNow to find that number, take m and find it\\'s` result = log base 2(m)`. Check if `2^(result+1) <= n`. \\n\\nOtherwise do normal bitwise operation.\\n\\n    private static long getLogBase2(int a) {\\n        return (long)(Math.log(a)/Math.log(2));\\n    }    \\n    public int rangeBitwiseAnd(int m, int n) {\\n        if (m == 0) return 0;\\n        long nextVal = getLogBase2(m);\\n        if (Math.pow(2, nextVal + 1) <= n) return 0;\\n        \\n        long value = m;\\n        for (long i=value+1; i<=n; i++) {\\n            value = value & i;\\n            if (value == 0) return (int)value;\\n        }\\n        \\n        return (int)value;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "My logic works on the principle that if any 2^x`[x is an int]` is present in the range, excluding m, then the value will be 0.\\nAs in, between 5 and 10, there is 8 `[2^3]` which corresponds to `1000` in binary. when this happens, the bitwise AND with its previous number will always yield 0.\\n\\nNow to find that number, take m and find it\\'s` result = log base 2(m)`. Check if `2^(result+1) <= n`. \\n\\nOtherwise do normal bitwise operation.\\n\\n    private static long getLogBase2(int a) {\\n        return (long)(Math.log(a)/Math.log(2));\\n    }    \\n    public int rangeBitwiseAnd(int m, int n) {\\n        if (m == 0) return 0;\\n        long nextVal = getLogBase2(m);\\n        if (Math.pow(2, nextVal + 1) <= n) return 0;\\n        \\n        long value = m;\\n        for (long i=value+1; i<=n; i++) {\\n            value = value & i;\\n            if (value == 0) return (int)value;\\n        }\\n        \\n        return (int)value;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56810,
                "title": "my-c-solution-2-with-explanation",
                "content": "The intuition is from here.\\n\\nhttps://leetcode.com/discuss/75805/share-my-o-1-time-solution-with-explanation-and-proof   \\n\\n     class Solution {\\n        public:\\n            int rangeBitwiseAnd(int m, int n) {\\n                // When we excute m & m+1 & m+2 & ... & n-1 & n, only the common bits of all these number will surrive\\n                // n     : 0110101101 10000000\\n                // n-1   : 0110101101 01111111\\n                //  ....\\n                // m+3   : 0110101101 0000011\\n                // m+2   : 0110101101 0000010\\n                // m+1   : 0110101101 0000001\\n                // m     : 0110101101 0000000\\n                // We can see that , only the leftmost common bits of m and n will meet that requirement\\n                // so the job here is to find the leftmost common bits of m and n\\n                // There is another way.\\n                // n - m will eliminate all the left common bit of m and n. \\n                // n -m : 0000000000 10000000 \\n                // we can use log(n-m, 2)+1 to get how many number of bits beside the leftmost common bits of m and n\\n                // after we get the number cnt, we set the rightmost cnt bits to 0\\n                // mask : 1111111111 00000000\\n                // by dong mask & m & n, we will get the leftmost common bits of m and n\\n                int cnt = log(n-m)/log(2)+1;\\n                int mask = 0x7fffffff ^ ((1<<cnt) -1);\\n                return mask & m & n;\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            int rangeBitwiseAnd(int m, int n) {\\n                // When we excute m & m+1 & m+2 & ... & n-1 & n, only the common bits of all these number will surrive\\n                // n     : 0110101101 10000000\\n                // n-1   : 0110101101 01111111\\n                //  ....\\n                // m+3   : 0110101101 0000011\\n                // m+2   : 0110101101 0000010\\n                // m+1   : 0110101101 0000001\\n                // m     : 0110101101 0000000\\n                // We can see that , only the leftmost common bits of m and n will meet that requirement\\n                // so the job here is to find the leftmost common bits of m and n\\n                // There is another way.\\n                // n - m will eliminate all the left common bit of m and n. \\n                // n -m : 0000000000 10000000 \\n                // we can use log(n-m, 2)+1 to get how many number of bits beside the leftmost common bits of m and n\\n                // after we get the number cnt, we set the rightmost cnt bits to 0\\n                // mask : 1111111111 00000000\\n                // by dong mask & m & n, we will get the leftmost common bits of m and n\\n                int cnt = log(n-m)/log(2)+1;\\n                int mask = 0x7fffffff ^ ((1<<cnt) -1);\\n                return mask & m & n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3764763,
                "title": "c-bit-manipulation-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int left , int right){\\n        if(left == 0)return 0;\\n        int bit1 = log2(left);\\n        int bit2 = log2(right);\\n        if(bit1 < bit2)return 0;\\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \\n    }\\n    int rangeBitwiseAnd(int left, int right) {\\n         return solve(left , right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int left , int right){\\n        if(left == 0)return 0;\\n        int bit1 = log2(left);\\n        int bit2 = log2(right);\\n        if(bit1 < bit2)return 0;\\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \\n    }\\n    int rangeBitwiseAnd(int left, int right) {\\n         return solve(left , right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665661,
                "title": "201-bitwise-and-of-numbers-range-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        int result = right;\\n\\n        while(right>left){\\n            result = right & (right - 1);\\n            right = result;\\n        }\\n        return result;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        int result = right;\\n\\n        while(right>left){\\n            result = right & (right - 1);\\n            right = result;\\n        }\\n        return result;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731500,
                "title": "98-faster-3-lines-solution-very-easy-easy-to-understand",
                "content": "** The bitwise AND in number ranges\\n  \\n\\n```\\n\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right)\\n    {\\n       int i=0;\\n        \\n        while(left!=right)\\n        {\\n           i++;\\n            left>>=1;\\n            right>>=1;\\n            \\n        }\\n        \\n        return left<<i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right)\\n    {\\n       int i=0;\\n        \\n        while(left!=right)\\n        {\\n           i++;\\n            left>>=1;\\n            right>>=1;\\n            \\n        }\\n        \\n        return left<<i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469070,
                "title": "bit-manipulation-c-easy-understanding",
                "content": "The main observation here is we just need to check next 2^power number greater than L \\nnow let next power of 2 greater than L is X\\nnow two cases arises here \\n\\n1->if(X<=R) then answer will be 0\\nlet me explain it\\nlet takes L=5 and R=10\\nnext 2 power of L is 8 \\nnow in binary representation\\n\\n5->0101\\n6->0110\\n7->0111\\n8->1000 here in 8 starting three bits are 000 which will make our ans Zero because in & operation 0 have highest priority\\n\\nwe dont need to chack number greater than 8 because it will give zero\\n\\ncase 2->In this case we can iterate from L to R and get the ans\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(long long int left,long long int right) {\\n      long long int next=1;\\n        \\n        while(next<=left)\\n            next*=2;\\n        \\n        if(next<=right)\\n            return 0;\\n        \\n        long long  ans=left;\\n        \\n        for(long long int i=left+1;i<=right&&i<=next;i++)\\n            ans&=i;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(long long int left,long long int right) {\\n      long long int next=1;\\n        \\n        while(next<=left)\\n            next*=2;\\n        \\n        if(next<=right)\\n            return 0;\\n        \\n        long long  ans=left;\\n        \\n        for(long long int i=left+1;i<=right&&i<=next;i++)\\n            ans&=i;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790745,
                "title": "cpp-easy-explanation",
                "content": "things to keep in mind\\n1.any of the bit that will flip in a column of bitwise representation will have all preceeding flips tured 0 as a new flip will occur at nearest power of 2\\n\\n2. all the columns before the column of left most common bit would be considered 0 as they would already have tested all the combination resulting in 0 in some column that will render whole column 0\\n\\n3. so the fixed bits which are same till the left most common bit will be same in the resulting and operator result\\n```\\nclass Solution {\\npublic:\\n      //the and that will be carried across\\n      // all the numbers will preserve the left most \\n      // common part of the bits of the number while the\\n      // other bits on the right will null out due to \\n      // flipping of digits \\n    int rangeBitwiseAnd(int left, int right) {\\n     int count=0;\\n        while(left!=right){\\n            left=left>>1;\\n            right=right>>1;\\n            count++;\\n        }\\n         left=left<<count;\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      //the and that will be carried across\\n      // all the numbers will preserve the left most \\n      // common part of the bits of the number while the\\n      // other bits on the right will null out due to \\n      // flipping of digits \\n    int rangeBitwiseAnd(int left, int right) {\\n     int count=0;\\n        while(left!=right){\\n            left=left>>1;\\n            right=right>>1;\\n            count++;\\n        }\\n         left=left<<count;\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747449,
                "title": "java-easy-and-clean-code-with-comments-100-00-faster",
                "content": "Runtime: 4 ms, faster than 100.00% of Java online submissions for Bitwise AND of Numbers Range.\\n\\n```\\n/*\\nExample : left = 36, right = 40\\n\\nDecimal number  :  Binary Form \\n    36          :    100100\\n    37          :    100101\\n    38          :    100110\\n    39          :    100111\\n    40          :    101000\\n    \\nFor 36 and 40, only their first two bits(from MSB) are same, rest are different, so their AND will be 0. \\nSo we don\\'t have to check for the numbers in between. \\n\\nWorking : left = 36(100100)  |   right = 40(101000)  |   count = 0\\n          left = 18(10010)   |   right = 20(10100)   |   count = 1\\n          left = 9(1001)     |   right = 10(1010)    |   count = 2\\n          left = 4(100)      |   right = 5(101)      |   count = 3\\n          left = 2(10)       |   right = 2(10)       |   count = 4\\n          \\n     Now they have become equal, so left shift the number(left or right) by count times.\\n     -> left <<= count; \\n     -> 2(10) <= 4; \\n     -> 32(100000)\\n     \\n*/\\n\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        //How many bits are different in left and right from LSB to MSB. \\n\\t\\t//As they are flipped so their AND will be 0.\\n        int count = 0;\\n        \\n        //To preserve the bits that are same in left and right from MSB to LSB.\\n        while (left != right) {\\n            //Right shift left and right.\\n            left >>= 1;\\n            right >>= 1;\\n            //Increase the count.\\n            count++;\\n        }\\n        \\n        //After the above loop, left will be equal to right. \\n\\t\\t//Now left shift count times to add 0 on it\\'s right side.\\n        return left <<= count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\nExample : left = 36, right = 40\\n\\nDecimal number  :  Binary Form \\n    36          :    100100\\n    37          :    100101\\n    38          :    100110\\n    39          :    100111\\n    40          :    101000\\n    \\nFor 36 and 40, only their first two bits(from MSB) are same, rest are different, so their AND will be 0. \\nSo we don\\'t have to check for the numbers in between. \\n\\nWorking : left = 36(100100)  |   right = 40(101000)  |   count = 0\\n          left = 18(10010)   |   right = 20(10100)   |   count = 1\\n          left = 9(1001)     |   right = 10(1010)    |   count = 2\\n          left = 4(100)      |   right = 5(101)      |   count = 3\\n          left = 2(10)       |   right = 2(10)       |   count = 4\\n          \\n     Now they have become equal, so left shift the number(left or right) by count times.\\n     -> left <<= count; \\n     -> 2(10) <= 4; \\n     -> 32(100000)\\n     \\n*/\\n\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        //How many bits are different in left and right from LSB to MSB. \\n\\t\\t//As they are flipped so their AND will be 0.\\n        int count = 0;\\n        \\n        //To preserve the bits that are same in left and right from MSB to LSB.\\n        while (left != right) {\\n            //Right shift left and right.\\n            left >>= 1;\\n            right >>= 1;\\n            //Increase the count.\\n            count++;\\n        }\\n        \\n        //After the above loop, left will be equal to right. \\n\\t\\t//Now left shift count times to add 0 on it\\'s right side.\\n        return left <<= count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677958,
                "title": "1-liner-recursive-solution-in-c-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n    return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n    return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200277,
                "title": "c-dead-easy-100-faster",
                "content": "Just check how many bits from start of both numbers are equal \\n   coz when u do & operation all the non common ones(from the point where left and right differed) will change and will result in 0 while performing & operation.\\n   so what i mean is \\n    5 - 1(equal) | 01(non equal)                    \\n\\t7 - 1(equal) | 11(non equal) ans:-4 \\n\\t12 - 11(equal) | 00(non equal)\\n\\t15 - 11(equal) | 11(non equal) ans :- 12\\n\\tfirst non equal bits are at index 1 and index 2 for both examples respectively\\n\\t\\nEven then if u dont get it just think ... u will\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int count=0;\\n        while(left!=right){\\n            left=left>>1;\\n            right=right>>1;\\n            count++;\\n        }\\n        return left<<count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int count=0;\\n        while(left!=right){\\n            left=left>>1;\\n            right=right>>1;\\n            count++;\\n        }\\n        return left<<count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123441,
                "title": "easy-observation-based-algorithm-with-code-c",
                "content": "**Approach :**\\n1. By observation, we can see that all the numbers between left and right, will have some commons bits, at the beginning.\\n\\nExample - \\n```\\nInput: left = 5, right = 7\\nOutput: 4\\n\\nlocation =     432 10\\n5 =            001 01\\n6 =            001 10\\n7 =            001 11\\n```\\nWhat we can see is that all the numbers in the range have a common prefix bit (here, 001).\\nFor the bits, following the prefix (common) bits, we encounter a **0** in any of the numbers, in the range (left, right).\\n\\nHere in above example - \\n1. We have common bits for all the positions starting from location no. 31 to 2 (as total size = 32 bits)\\n2. For bit locations following the common part, we encounter 0, in atleast any of the numbers.\\n Here,  we get 0 at location 1, from binary of 5. similarly we get 0 at location 0, from 6.\\n3. So, when we take AND of all these our answer will contain only the prefix common part, following by all 0s. \\n (as, contribution of 0 in AND will lead to 0, at that bit, in the answer.).\\n \\n The code is short, and will explain the above steps, in a more detailed manner.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) \\n    {\\n        int ans = 0; // answer containing all 32 bits as 0.\\n        \\n        for(int i=31;i>=0;i--) // iterating over all the 32 bits\\n        {\\n            if( (left & (1<<i) ) != (right & (1<<i) ) ) \\n                break;  //finding if bits are common or not.\\n            \\n            else\\n            ans |= (left & (1<<i));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nPlease upvote, if its helpful.\\nFind more Leetcode solutions [HERE](https://github.com/noob-hu-yaar/Leetcode/tree/master/nandincpp)\\n****\\n\\n",
                "solutionTags": [],
                "code": "```\\nInput: left = 5, right = 7\\nOutput: 4\\n\\nlocation =     432 10\\n5 =            001 01\\n6 =            001 10\\n7 =            001 11\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) \\n    {\\n        int ans = 0; // answer containing all 32 bits as 0.\\n        \\n        for(int i=31;i>=0;i--) // iterating over all the 32 bits\\n        {\\n            if( (left & (1<<i) ) != (right & (1<<i) ) ) \\n                break;  //finding if bits are common or not.\\n            \\n            else\\n            ans |= (left & (1<<i));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988867,
                "title": "100-fast-detailed-explanation-c-solution",
                "content": "let us take two numbers suppose 3 and 5,\\n3 & 4 & 5 ==> \\n          0 1 1 \\n\\t\\t     1 0 0 \\n\\t\\t     1 0 1\\nwe can notice that their is no prefix common in all,\\n\\nNow let us take 13,14\\n\\n13 & 14 ==> \\n1 1 0 1 \\n  1 1 1 0\\n              \\ncommon prefix in both is : 1 1 .... After the starting 1 1 every bit after it is confirmed to be flipped off so we will append 0 after that. Hence, 1 1 0 0.\\nAlgo:\\ni.e, 1. Find the common prefix in both the number. (DO BY JUST DOING RIGHT SHIFT UNTIL BOTH NUMBERS ARE EQUAL)\\n2 . Count the numbers of shift\\n3. Just make left shift to the count of the right shift to generate the desired result.\\neg:\\n1st right shift\\n1 1 0 1 -------------------> 1 1 0\\n1 1 1 0 -------------------> 1 1 1    \\n\\n2nd right shift\\n1 1 0 ---------------------> 1 1\\n1 1 1 ---------------------> 1 1   (BOTH THE NUMBERS ARE EQUAL,STOP!!!)\\n\\n\\nNOW JUST MAKE TWO LEFT SHIFT(Number Of Right Shift)  TO GET THE DESIRED RESULT \\n1 1 -----------------------> 1 1 0 0 (Ans)\\n\\nBelow is the implementation of the above algorithm which is self explanatory.\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n       \\n        int shift=0;\\n        \\n        if(m == n) return m;\\n        \\n        while(m != n)\\n        {  m >>= 1;\\n           n >>= 1;\\n           ++shift;\\n        }\\n        \\n      \\n       return m << shift; \\n          \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n       \\n        int shift=0;\\n        \\n        if(m == n) return m;\\n        \\n        while(m != n)\\n        {  m >>= 1;\\n           n >>= 1;\\n           ++shift;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 857269,
                "title": "c-bit-manipulation-o-1",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int count=0;\\n        while (m!=n)\\n        {\\n            m>>=1;\\n            n>>=1;\\n            count++;\\n        }\\n        return m<<=count;\\n    } \\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int count=0;\\n        while (m!=n)\\n        {\\n            m>>=1;\\n            n>>=1;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 709339,
                "title": "python-longest-common-prefix-o-1-solution",
                "content": "1. If we know the longest common prefix (LCP) of `m` and `n` represented in binary, that\\'s our answer.\\n\\n2. Let\\'s run through a few examples.\\n\\n```\\nm = 5, n = 7\\n\\n    1   0   1\\n(&) 1   1   0\\n(&) 1   1   1\\n______________\\n    1   0   0\\n\\t\\n\\t\\nLCP(5, 7) = 1 X X --> the X is to pad the RHS with 0\\'s.\\nHence, bitwise AND of [5, 7] = \\'0b100\\' = 4\\n\\n```\\n<br>\\n\\n```\\nm = 8, n = 11\\n\\n    1   0   0   0\\n(&) 1   0   0   1\\n(&) 1   0   1   0\\n(&) 1   0   1   1\\n__________________\\n    1   0   0   0\\n\\t\\n\\t\\nLCP(8, 11) = 1 0 X X --> the X is to pad the RHS with 0\\'s\\nHence, bitwise AND of [8, 11] = \\'0b1000\\' = 8\\n\\n```\\n\\n<br>\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        \\n        # TRACK THE NUMBER OF RIGHT SHIFTS WE DID\\n        rightShifts = 0\\n        \\n        # WE KEEP RIGHT-SHFITING UNTIL M == N\\n        while m != n:\\n            m >>= 1\\n            n >>= 1\\n            rightShifts += 1\\n            \\n        # ONCE M == N, WE\\'VE THE LONGEST COMMON PREFIX = M = N, RETURN IT\\n        return m * (2 ** rightShifts)\\n```",
                "solutionTags": [],
                "code": "```\\nm = 5, n = 7\\n\\n    1   0   1\\n(&) 1   1   0\\n(&) 1   1   1\\n______________\\n    1   0   0\\n\\t\\n\\t\\nLCP(5, 7) = 1 X X --> the X is to pad the RHS with 0\\'s.\\nHence, bitwise AND of [5, 7] = \\'0b100\\' = 4\\n\\n```\n```\\nm = 8, n = 11\\n\\n    1   0   0   0\\n(&) 1   0   0   1\\n(&) 1   0   1   0\\n(&) 1   0   1   1\\n__________________\\n    1   0   0   0\\n\\t\\n\\t\\nLCP(8, 11) = 1 0 X X --> the X is to pad the RHS with 0\\'s\\nHence, bitwise AND of [8, 11] = \\'0b1000\\' = 8\\n\\n```\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        \\n        # TRACK THE NUMBER OF RIGHT SHIFTS WE DID\\n        rightShifts = 0\\n        \\n        # WE KEEP RIGHT-SHFITING UNTIL M == N\\n        while m != n:\\n            m >>= 1\\n            n >>= 1\\n            rightShifts += 1\\n            \\n        # ONCE M == N, WE\\'VE THE LONGEST COMMON PREFIX = M = N, RETURN IT\\n        return m * (2 ** rightShifts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594259,
                "title": "100-memory-python-3-one-line-short-with-math",
                "content": "\\'\\'\\'\\n\\n\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        return 0 if  n >= m*2 else functools.reduce(lambda x, y: x & y, range(m, n+1))\\n\\n\\'\\'\\'\\nIn math it is easy to see when the last number >= first number *2, the return must be 0\\nIn other case, I use & to loop. (using of & seems illegal after I saw other\\'s beautiful solutions.\\nAnyway, just another perspective for everyone.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\'\\'\\'\\n\\n\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        return 0 if  n >= m*2 else functools.reduce(lambda x, y: x & y, range(m, n+1))\\n\\n\\'\\'\\'\\nIn math it is easy to see when the last number >= first number *2, the return must be 0\\nIn other case, I use & to loop. (using of & seems illegal after I saw other\\'s beautiful solutions.\\nAnyway, just another perspective for everyone.",
                "codeTag": "Python3"
            },
            {
                "id": 593850,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nObserve the bitwise pattern which occurs in sequential numbers between each range of powers of 2.  More formally, if the range `M..N` is contained within the range of powers of 2 from 2<sup>i</sup> non-inclusive  to 2<sup>i - 1</sup> inclusive, then we can set the bit in the answer for 2<sup>i - 1</sup>.  We search for the range of powers of 2 in descending order since each number in the range `M..N` could potentially be in multiple ranges of powers of 2.  For example, consider `M = 6` and `N = 7`, the range `6..7` has the 2<sup>2</sup> and 2<sup>1</sup> bits set in common, thus to check each subsequent range of powers of 2, simply subtract `M` and `N` by the lower bound of current range of powers of 2 (see example below).\\n\\n![image](https://assets.leetcode.com/users/claytonjwong/image_1587655962.png)\\n\\n\\n*Example:* `M = 6` and `N = 7`\\n\\n`M` and `N` fall within the range of powers of 2 between 2<sup>3</sup> and 2<sup>2</sup>, ie. `8 > 7` and `6 >= 4`.  This occurs when `i = 3` and `i - 1 = 2`.  So we set the bit in the answer for 2<sup>2</sup> = 4, then subtract `M` and `N` by `4`, thus, `M = 2` and `N = 3`.  Now `M` and `N` fall within the range of powers of 2 between 2<sup>2</sup> and 2<sup>1</sup>, ie. `4 > 3` and `2 >= 2`.  This occurs when `i = 2` and `i - 1 = 1`.  So we set the bit in the answer for 2<sup>1</sup> = 2.  Thus the answer is `4 + 2 = 6`.\\n\\n---\\n\\n*Javascript*\\n```\\nlet rangeBitwiseAnd = (M, N, ans = 0) => {\\n    for (let i = 31; i > 0; --i)\\n        if (2**i > N && M >= 2**(i - 1))\\n            ans |= 2**(i - 1),\\n              M -= 2**(i - 1),\\n              N -= 2**(i - 1);\\n    return ans;\\n};\\n```\\n\\n---\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int M, int N, int ans = 0) {\\n        for (unsigned int i = 1 << 31; i > 0; i >>= 1)\\n            if (i > N && M >= i >> 1)\\n                ans |= i >> 1,\\n                  N -= i >> 1,\\n                  M -= i >> 1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet rangeBitwiseAnd = (M, N, ans = 0) => {\\n    for (let i = 31; i > 0; --i)\\n        if (2**i > N && M >= 2**(i - 1))\\n            ans |= 2**(i - 1),\\n              M -= 2**(i - 1),\\n              N -= 2**(i - 1);\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int M, int N, int ans = 0) {\\n        for (unsigned int i = 1 << 31; i > 0; i >>= 1)\\n            if (i > N && M >= i >> 1)\\n                ans |= i >> 1,\\n                  N -= i >> 1,\\n                  M -= i >> 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593777,
                "title": "pretty-much-explained-cpp-with-pseudo-code",
                "content": "**ATLAST we see: for [a,b] a&b<=min(a,b)**\\nAt the first glance, looping from m to n seems straightforward but obviously time limit exceeds.\\nIterating from m to n seems unavailable, but we can consider looping from bit to bit.\\n(works good for nos of 2^31 range)(save sis from runtime error)\\nLet\\'s first write down some binary numbers:\\n1    000001\\n2    000010\\n3    000011\\n4    000100\\n5    000101\\n6    000110\\n7    000111\\n8    001000\\nAs we can see,every consecutive numbers lowest bit(LSB) is either 1 or 0.So,doing \\'&\\' operation over consecutive nos results 0 or 1 in LSB positon.\\nSo,if there are nos between given range[m,n],LSB will be 0 after & operation.\\nSo,for every bit from LSB to MSB,we shift both and compare them,if(n>m) then some nos are between them,so lowest bit now in answer will be 0.\\nAgain we go on shifting until we reach equality.\\nAfter equality, answer bits will be same as any one of them(since 0&0 =0,1&1 =1).\\nWe can see it from below example..\\n\\nm =  01000\\nn =   01011\\n\\n(1)   01011 > 01000  ->  lowest bit = 0\\n(2)   0101 > 0100      ->  2nd lowest bit  = 0\\n(3)   010 = 010          ->  3rd lowest bit = current lowest bit  0\\n(4)   01 = 01              ->  4th lowest bit = current lowest bit   1\\n(5)   0 = 0                  ->  5th lowest bit = current lowest bit   0\\n\\nFinal result:   01000\\n**We can see that step (3)-(5) is unnecessary, when m=n, the other bits are just the same as current m (or n), then we can easily get the final result.**\\n\\nFinally, incurred from this is\\nfor range [a,b];\\na&b<=min(a,b);\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        while(m!=n){\\n            count++;\\n            m = m>>1;\\n            n = n>>1;\\n        }\\n        return m<<count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        while(m!=n){\\n            count++;\\n            m = m>>1;\\n            n = n>>1;\\n        }\\n        return m<<count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56808,
                "title": "share-my-c-solution-with-explanation-easy-to-understand",
                "content": "    //For two consecutive numbers A and B,they must have different Least Significant Bit(LSB),\\n    //beause B = A + 1,if the LSB is 0 in A,then LSB must be 1 in B,and vice versa.\\n    //If m != n,there must be 0 in LSB in the range [m, n].So we just right shift one bit to \\n    //check the  next bit( i.e. update the LSB).If m == n, we need left shift some bits to get \\n    //the right answer.\\n    \\n    class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int i = 0;\\n            \\n            while (m != n)\\n            {\\n                m = m >> 1;\\n                n = n >> 1;\\n                i++;\\n            }\\n            \\n            return m << i;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int i = 0;\\n            \\n            while (m != n)\\n            {\\n                m = m >> 1;\\n                n = n >> 1;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 56837,
                "title": "40ms-solution-by-c",
                "content": "    int rangeBitwiseAnd(int m, int n) {\\n        int i;\\n        for(i=0;m!=n;m>>=1,n>>=1)i++;\\n        return m<<i;\\n    }",
                "solutionTags": [],
                "code": "    int rangeBitwiseAnd(int m, int n) {\\n        int i;\\n        for(i=0;m!=n;m>>=1,n>>=1)i++;\\n        return m<<i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56875,
                "title": "my-o-1-solution-using-bitwise-xor-and",
                "content": "    //34ms    \\n    int rangeBitwiseAnd(int m, int n) {\\n                int xmask = m ^ n;\\n                int mlen = 0;\\n                int mask;\\n                \\n                if ((xmask >> (mlen + 16)) > 0) mlen += 16;\\n                if ((xmask >> (mlen + 8)) > 0) mlen += 8;\\n                if ((xmask >> (mlen + 4)) > 0) mlen += 4;\\n                if ((xmask >> (mlen + 2)) > 0) mlen += 2;\\n                if ((xmask >> (mlen + 1)) > 0) mlen ++;\\n                \\n                mask = ~0 << mlen;\\n                \\n                return m & mask;\\n        }",
                "solutionTags": [],
                "code": "    //34ms    \\n    int rangeBitwiseAnd(int m, int n) {\\n                int xmask = m ^ n;\\n                int mlen = 0;\\n                int mask;\\n                \\n                if ((xmask >> (mlen + 16)) > 0) mlen += 16;\\n                if ((xmask >> (mlen + 8)) > 0) mlen += 8;\\n                if ((xmask >> (mlen + 4)) > 0) mlen += 4;\\n                if ((xmask >> (mlen + 2)) > 0) mlen += 2;\\n                if ((xmask >> (mlen + 1)) > 0) mlen ++;\\n                \\n                mask = ~0 << mlen;\\n                \\n                return m & mask;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 56898,
                "title": "my-c-solution-iterate-32-bits",
                "content": "The code just iterates every bits for the two numbers. Then determine to break, count, or just contiune.\\n\\n    int rangeBitwiseAnd(int m, int n) {\\n        int result = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = 1 << i;\\n            if ((n & bit) > 0) {\\n                if ((m & bit) == 0) { break; }\\n                result |= bit;\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "The code just iterates every bits for the two numbers. Then determine to break, count, or just contiune.\\n\\n    int rangeBitwiseAnd(int m, int n) {\\n        int result = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = 1 << i;\\n            if ((n & bit) > 0) {\\n                if ((m & bit) == 0) { break; }\\n                result |= bit;\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3602246,
                "title": "c-bit-manipulation-solution-w-intution-simple-logic-tc-o-n",
                "content": "# Intuition\\nThe intuition behind this problem is the to find the bits that don\\'t change at all in the given interval.\\nLet\\'s take two numbers: `82` and `94`\\n```\\n     6 5 4 3 2 1 0\\n82 - 1 0 1 0 0 1 0\\n\\n83 - 1 0 1 0 0 1 1\\n84 - 1 0 1 0 1 0 0\\n85 - 1 0 1 0 1 0 1\\n86 - 1 0 1 0 1 1 0\\n87 - 1 0 1 0 1 1 1\\n88 - 1 0 1 1 0 0 0\\n89 - 1 0 1 1 0 0 1\\n90 - 1 0 1 1 0 1 0\\n91 - 1 0 1 1 0 1 1\\n92 - 1 0 1 1 1 0 0\\n93 - 1 0 1 1 1 0 1\\n\\n94 - 1 0 1 1 1 1 0\\n```\\nHere, the bits are changing till the $$3^{rd}$$ bit. If you see, the each bit from `0` to `3` will at least turn 0 once in the interval.\\nThis tells us that we need to take the longest common series of bits starting from the `MSB` (Most Significant Bit), $$6^{th}$$ bit in this case.\\n\\n# Approach\\n1. Move bits from left and right to another variable.\\n2. If left\\'s LSB and right\\'s LSB are equal then shift the bit value into the variable.\\n3. If they are not equal then make the variable 0 again.\\n4. Repeat this until both left and right become 0 or in this case since the number is 31 bit only, we do it 31 time. (makes it easier to reverse bits in next step).\\n5. Now we have our answer but it\\'s in reverse form so start moving the bits into a different variable for 31 time.\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if (left == right)\\n            return left;\\n        int temp{0};\\n        for(int i=0; i<31; i++, left>>=1, right>>=1, temp<<=1) {\\n            if ((left&1) == (right&1))\\n                temp |= (left&1);\\n            else\\n                temp = 0;\\n        }\\n        int res{0};\\n        for(int i=0; i<31; i++) {\\n            res |= (temp&1);\\n            temp >>= 1;\\n            res <<= 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(2*31) \\\\approx O(1)$$\\nTraversed 31 bits to get the common sequence of bits and again to reverse them.\\n- Space complexity: $$O(1)$$\\nNo extra space used.\\n\\n\\n> ### Note\\n> - Upvote if you liked my solution\\n> - Drop a comment if you have any doubt",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n     6 5 4 3 2 1 0\\n82 - 1 0 1 0 0 1 0\\n\\n83 - 1 0 1 0 0 1 1\\n84 - 1 0 1 0 1 0 0\\n85 - 1 0 1 0 1 0 1\\n86 - 1 0 1 0 1 1 0\\n87 - 1 0 1 0 1 1 1\\n88 - 1 0 1 1 0 0 0\\n89 - 1 0 1 1 0 0 1\\n90 - 1 0 1 1 0 1 0\\n91 - 1 0 1 1 0 1 1\\n92 - 1 0 1 1 1 0 0\\n93 - 1 0 1 1 1 0 1\\n\\n94 - 1 0 1 1 1 1 0\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if (left == right)\\n            return left;\\n        int temp{0};\\n        for(int i=0; i<31; i++, left>>=1, right>>=1, temp<<=1) {\\n            if ((left&1) == (right&1))\\n                temp |= (left&1);\\n            else\\n                temp = 0;\\n        }\\n        int res{0};\\n        for(int i=0; i<31; i++) {\\n            res |= (temp&1);\\n            temp >>= 1;\\n            res <<= 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670409,
                "title": "c-3-lines-simple-code-without-iteration-or-recursion",
                "content": "Some Explanation Here:\\n1. If we have more than 1 numbers in the range, then 0-bit must be 0 since two adjacent numbers have different bits at 0-bit.\\n2. If we have more than 2 numbers in the range, then 1-bit must be 0 in the same way.\\n3. If we have more than 4 numbers in the range, then 2-bit must be 0 ...\\n\\nHence we can simply ignore the lower bits according to how many numbers we have in the range, which is done by ```~(((uint32_t)1<<offset)-1)```.\\n\\nAs for the higher bits, let us take certain nth-bit for example. Because we have limited range of numbers, there are only three situations:\\n1. They are all zeros.\\n2. They are all ones.\\n3. They are 0..000111...1 or 1...111000...0.\\n\\nIn any of three ways, we only need to check the greatest and smallest boundary of the range, i.e. left and right: ```right & left```.\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if (right == left) return right;\\n        int offset = log2(right - left) + 1;\\n        return ~(((uint32_t)1<<offset)-1) & right & left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```~(((uint32_t)1<<offset)-1)```\n```right & left```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if (right == left) return right;\\n        int offset = log2(right - left) + 1;\\n        return ~(((uint32_t)1<<offset)-1) & right & left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336688,
                "title": "c-short-simple-to-the-point-code",
                "content": "```\\nint rangeBitwiseAnd(int left, int right) {\\n        int count=0;\\n        while(left!=right){\\n            left>>=1; right>>=1;\\n            count++;\\n        }\\n        return left<<count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint rangeBitwiseAnd(int left, int right) {\\n        int count=0;\\n        while(left!=right){\\n            left>>=1; right>>=1;\\n            count++;\\n        }\\n        return left<<count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1871634,
                "title": "python-easy-to-understand-solution",
                "content": "All we need to do is return the longest common prefix between the two binary digits.\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        left, right = bin(left)[2:], bin(right)[2:]\\n        if len(left) != len(right): return 0\\n        \\n        num = 0\\n        for i in range(len(left)):\\n            if left[i] == right[i] == \\'1\\':\\n                num += pow(2, len(left)-i-1)\\n            elif left[i] != right[i]:\\n                break\\n        \\n        return num",
                "solutionTags": [],
                "code": "All we need to do is return the longest common prefix between the two binary digits.\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        left, right = bin(left)[2:], bin(right)[2:]\\n        if len(left) != len(right): return 0\\n        \\n        num = 0\\n        for i in range(len(left)):\\n            if left[i] == right[i] == \\'1\\':\\n                num += pow(2, len(left)-i-1)\\n            elif left[i] != right[i]:\\n                break\\n        \\n        return num",
                "codeTag": "Java"
            },
            {
                "id": 1524535,
                "title": "easy-to-understand-python-solution",
                "content": "if binary length of left is shorter than the binary length of right, let\\'s say left: 3 `0b11` and right 7 `0b111`, there must be a `0b100` in the range which would lead the result to 0.\\n\\nIf two integers have the same length, there must be part of suffix with a different leading bit `0` and `1` for two integers, this applied to the former conclusion and the suffix could be all zero.\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        if len(bin(left)) != len(bin(right)):\\n            return 0\\n        shift = 0\\n        while left != right:\\n            left = left >> 1\\n            right = right >> 1\\n            shift += 1\\n        return left << shift\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        if len(bin(left)) != len(bin(right)):\\n            return 0\\n        shift = 0\\n        while left != right:\\n            left = left >> 1\\n            right = right >> 1\\n            shift += 1\\n        return left << shift\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513901,
                "title": "c-significant-no-in-range-mask",
                "content": "**Idea behind solution  :generate the no in range with maximum continuous zeros in right\\nonce that no is generated do AND with left to get result\\nex: \\nleft===============    10100111\\nright==============    10111110\\nrequired no.=========    10110000\\nresult=left & required no=   10100000**\\n```\\nclass Solution {\\npublic:\\n    int getMsb(int left)\\n    {\\n        int msb=0;\\n        while(left>>=1)\\n            msb++;\\n        return msb;\\n    }\\n    int rangeBitwiseAnd(int left, int right)\\n    { \\n        unsigned int temp=0,msb=getMsb(left)+2;//+1 extra  to balance first --msb\\n        while(temp<left)\\n        {\\n            temp|=(1<<--msb);\\n            if(temp>right)\\n                temp^=(1<<msb);//undo last or\\n        }\\n        return left&temp;\\n    }\\n};\\n```\\n**much easier approach\\n1.)generate mask with zeros till leftmost bit position where left and right differs(and all remaining bits set)\\n2.)do AND with left to get result\\n3.left==============    10100111\\nright==============    10111110\\nmask========   (1 till 31)11100000\\nresult=left & mask= =====10100000**\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) \\n    {\\n        if(left==right) return left;\\n        int msb=log2(left^right);\\n        int mask=(1U<<msb+1)-1;\\n        return left&~mask;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMsb(int left)\\n    {\\n        int msb=0;\\n        while(left>>=1)\\n            msb++;\\n        return msb;\\n    }\\n    int rangeBitwiseAnd(int left, int right)\\n    { \\n        unsigned int temp=0,msb=getMsb(left)+2;//+1 extra  to balance first --msb\\n        while(temp<left)\\n        {\\n            temp|=(1<<--msb);\\n            if(temp>right)\\n                temp^=(1<<msb);//undo last or\\n        }\\n        return left&temp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) \\n    {\\n        if(left==right) return left;\\n        int msb=log2(left^right);\\n        int mask=(1U<<msb+1)-1;\\n        return left&~mask;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031250,
                "title": "c-3-lines-solution-no-recursion-easy-to-understand-find-the-common-binary-prefix",
                "content": "The bitwise `AND` of numbers between `m` and `n` will not **affect** the common binary prefix(CBP) of them(because they are sharing the same CBP), so the idea is to find the CBP of `m` and `n`.\\n```\\n                        5   b\\'01 01\\n                        7   b\\'01 11\\nCommon binary prefix    4   b\\'01(00)\\n```\\nWe use an unsigned-int mask filled with `1` (`0xffffffff`) to  `AND` with `m` and `n` to find the common binary prefix.\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        uint32_t mask = 0xffffffff;\\n        while ((m & mask) != (n & mask)) mask <<= 1;\\n        return m & mask;\\n    }\\n};\\n```\\nThere is a more interesting code to find the CBP:\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        uint32_t x = m ^ n;\\n        x |= x >> 1, x |= x >> 2, x |= x >> 4, x |= x >> 8, x |= x >> 16;\\n        return m & ~x;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n                        5   b\\'01 01\\n                        7   b\\'01 11\\nCommon binary prefix    4   b\\'01(00)\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        uint32_t mask = 0xffffffff;\\n        while ((m & mask) != (n & mask)) mask <<= 1;\\n        return m & mask;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        uint32_t x = m ^ n;\\n        x |= x >> 1, x |= x >> 2, x |= x >> 4, x |= x >> 8, x |= x >> 16;\\n        return m & ~x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999501,
                "title": "c-o-1-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    int rangeBitwiseAnd(int m, int n) {\\n        // if m==0, then answer is 0\\n        if(m==0) return 0;\\n        // if number is same, then answer is that number\\n        int diff = n-m;\\n        if(!diff) return m;\\n        // if number of bits required to represent the numbers are different, then answer is zero, because in order to go from e.g 5 bits to 6 bits, we have to flip all the 5 bits to zero.\\n        if(int(log2(n)) != int(log2(m))) {    return 0;}\\n        // if number of bits are same, then difference between the numbers in binary form are the bits that we have to change\\n        //like if m=35 and n = 57, then diff = 22 ~ 10110 so only 5 last 5 bits will be changed, but first take AND of m and n, then change last 5 bits. \\n        int k = log2(diff);\\n        cout<<k;\\n        m = m&n;\\n        for(int i= k; i>=0;i--){\\n            // here we are setting the ith bit to zero\\n            m = m & (~(1<<i));\\n        }\\n        return m;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int rangeBitwiseAnd(int m, int n) {\\n        // if m==0, then answer is 0\\n        if(m==0) return 0;\\n        // if number is same, then answer is that number\\n        int diff = n-m;\\n        if(!diff) return m;\\n        // if number of bits required to represent the numbers are different, then answer is zero, because in order to go from e.g 5 bits to 6 bits, we have to flip all the 5 bits to zero.\\n        if(int(log2(n)) != int(log2(m))) {    return 0;}",
                "codeTag": "Java"
            },
            {
                "id": 819089,
                "title": "easy-java-solution-with-video-explanation",
                "content": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int shift = 0;\\n        while (m != n) {\\n            m >>= 1;\\n            n >>= 1;\\n            shift++;\\n        }\\n        n <<= shift;\\n        return n;\\n    }\\n}\\n```\\n\\nMy video explanation: \\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/j3XRFREnPWI\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int shift = 0;\\n        while (m != n) {\\n            m >>= 1;\\n            n >>= 1;\\n            shift++;\\n        }\\n        n <<= shift;\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741067,
                "title": "java-clean-code-with-explanation",
                "content": "When the bit is different, then for bitwise AND we get 0. Continue this until two numbers match.\\nNow, the final result could be obtained when we shift the first number (which is less than the other) to that many bits to the left. Because the rest of the bits are zero.\\n**For example** - 1001 - 1011\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tIteration 1 -> \\n\\t\\t\\t\\t\\t\\t\\t\\t0100, 0101\\n\\t\\t\\t\\t\\t\\t\\t\\t-> 0010, 0010\\n\\t\\t\\tTotal dropped -> 2\\n\\t\\t\\tResult -> \\n\\t\\t\\t\\t\\t\\t\\t\\t0010 << 2 -> 1000 (8)\\n\\t\\t\\tThis is the bitwise AND of 9 to 11.\\n\\n```java\\npublic int rangeBitwiseAnd(int m, int n) {\\n\\tif (m == n) return m;\\n\\tif (m == 0 || n == 0) return 0;\\n\\n\\tint droppedBitCount = 0;\\n\\t\\n\\twhile (m != n) {\\n\\t\\tm = m >> 1;\\n\\t\\tn = n >> 1;\\n\\t\\tdroppedBitCount++;\\n\\t}\\n\\treturn m << droppedBitCount;\\n}",
                "solutionTags": [],
                "code": "When the bit is different, then for bitwise AND we get 0. Continue this until two numbers match.\\nNow, the final result could be obtained when we shift the first number (which is less than the other) to that many bits to the left. Because the rest of the bits are zero.\\n**For example** - 1001 - 1011\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tIteration 1 -> \\n\\t\\t\\t\\t\\t\\t\\t\\t0100, 0101\\n\\t\\t\\t\\t\\t\\t\\t\\t-> 0010, 0010\\n\\t\\t\\tTotal dropped -> 2\\n\\t\\t\\tResult -> \\n\\t\\t\\t\\t\\t\\t\\t\\t0010 << 2 -> 1000 (8)\\n\\t\\t\\tThis is the bitwise AND of 9 to 11.\\n\\n```java\\npublic int rangeBitwiseAnd(int m, int n) {\\n\\tif (m == n) return m;\\n\\tif (m == 0 || n == 0) return 0;\\n\\n\\tint droppedBitCount = 0;\\n\\t\\n\\twhile (m != n) {\\n\\t\\tm = m >> 1;\\n\\t\\tn = n >> 1;\\n\\t\\tdroppedBitCount++;\\n\\t}\\n\\treturn m << droppedBitCount;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 692428,
                "title": "cpp-easy-solution-faster-than-100",
                "content": "The question is essentially asking the common prefix. So as long as there is a difference between bits you can ignore it. keep right shifting the lower and upper limit and when they are equal we know they are equal to common prefix. Finally, just shift it left by the number of positions where the bits were not common since it will be succeded by the zeros.\\n```\\nclass Solution {\\npublic:\\n   \\n    int rangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        while(m!=n){\\n            m = m>>1;\\n            n = n>>1;\\n            count++;\\n        }\\n        return m<<count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int rangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        while(m!=n){\\n            m = m>>1;\\n            n = n>>1;\\n            count++;\\n        }\\n        return m<<count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653015,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int i = 0;\\n        while (m!=n){\\n            m = m >> 1;\\n            n = n >> 1;\\n            i++;\\n        }\\n        return m << i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int i = 0;\\n        while (m!=n){\\n            m = m >> 1;\\n            n = n >> 1;\\n            i++;\\n        }\\n        return m << i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594153,
                "title": "different-solution-using-logarithm",
                "content": "My intuition took me to somewhere else rather than other solutions.\\n\\n**Intuition:**\\n* If numbers (m and n) are in different power of twos, then it means that the result is 0 every time.\\n* Else if numbers are in the same power of two then it means that the first bit is countable and we will check rest bits with recursion. \\n\\n**Let me explain with examples:**\\n\\n```\\n13 - 001101\\n14 - 001110\\n15 - 001111\\n16 - 010000 <- it will change all bits to 0. (Look at example 1)\\n17 - 010001\\n18 - 010010\\n19 - 010011\\n20 - 010100 <- 3rd and 5th bits are 1 (Look at example 2)\\n21 - 010101\\n22 - 010111 <- 3rd and 5th bits are 1\\n23 - 011000\\n```\\n\\n1. Example 1) `(m, n) = (14, 19)`. In this case, as I mentioned before, 16 (010000) will change all bits to 0 and that is why the result is 0. Surely this approach works for all such where m and n are in different power of twos. \\n\\n1. Example 2) `(m, n) = (20, 22)`. As the power of 2s are the same we should add the power of two of current number to result and traverse all rest of bits. \\n\\n**Java:**\\n```java\\npublic int rangeBitwiseAnd(int m, int n) {        \\n\\tint pm = log2(m);\\n\\tint pn = log2(n);\\n\\n\\tif (m == 0 || n == 0 || pm != pn) {                         // if logarithms of numbers are different\\n\\t\\treturn 0;\\n\\t} \\n\\n\\tint newm = 1 << pm;                                         // adding number to result \\n\\treturn newm + rangeBitwiseAnd(m & (newm-1), n & (newm-1));  // unsetting first bits of both m and n \\n}\\n\\nprivate int log2(int a) {\\n\\treturn (int) (Math.log(a) / Math.log(2));\\n}\\n```\\n\\n**Python:**\\n```python\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        if m == 0 or n == 0:\\n            return 0\\n     \\n        pm = int(math.log2(m))\\n        pn = int(math.log2(n))\\n\\n        if pm != pn:\\n            return 0\\n\\n        newm = 1 << pm\\n        return newm + self.rangeBitwiseAnd(m & (newm-1), n & (newm-1))\\n```\\n\\n**Golang:**\\n```golang\\nfunc rangeBitwiseAnd(m int, n int) int {\\n\\tif m == 0 || n == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tpm := int(math.Log2(float64(m)))\\n\\tpn := int(math.Log2(float64(n)))\\n\\n\\tif pm != pn {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tnewm := 1 << pm\\n\\treturn newm + rangeBitwiseAnd(m&(newm-1), n&(newm-1))\\n}\\n```\\n\\n**Complexity:**\\nIn the worst case it will traverse all bits one by one and number of iteration in the algorithm is bounded by the number of bits in an integer number, which is constant - O(1)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Go"
                ],
                "code": "```\\n13 - 001101\\n14 - 001110\\n15 - 001111\\n16 - 010000 <- it will change all bits to 0. (Look at example 1)\\n17 - 010001\\n18 - 010010\\n19 - 010011\\n20 - 010100 <- 3rd and 5th bits are 1 (Look at example 2)\\n21 - 010101\\n22 - 010111 <- 3rd and 5th bits are 1\\n23 - 011000\\n```\n```java\\npublic int rangeBitwiseAnd(int m, int n) {        \\n\\tint pm = log2(m);\\n\\tint pn = log2(n);\\n\\n\\tif (m == 0 || n == 0 || pm != pn) {                         // if logarithms of numbers are different\\n\\t\\treturn 0;\\n\\t} \\n\\n\\tint newm = 1 << pm;                                         // adding number to result \\n\\treturn newm + rangeBitwiseAnd(m & (newm-1), n & (newm-1));  // unsetting first bits of both m and n \\n}\\n\\nprivate int log2(int a) {\\n\\treturn (int) (Math.log(a) / Math.log(2));\\n}\\n```\n```python\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        if m == 0 or n == 0:\\n            return 0\\n     \\n        pm = int(math.log2(m))\\n        pn = int(math.log2(n))\\n\\n        if pm != pn:\\n            return 0\\n\\n        newm = 1 << pm\\n        return newm + self.rangeBitwiseAnd(m & (newm-1), n & (newm-1))\\n```\n```golang\\nfunc rangeBitwiseAnd(m int, n int) int {\\n\\tif m == 0 || n == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tpm := int(math.Log2(float64(m)))\\n\\tpn := int(math.Log2(float64(n)))\\n\\n\\tif pm != pn {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tnewm := 1 << pm\\n\\treturn newm + rangeBitwiseAnd(m&(newm-1), n&(newm-1))\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 593999,
                "title": "javascript-solution",
                "content": "```\\nvar rangeBitwiseAnd = function(m, n) {\\n    let count = 0;\\n    \\n    while (m != n) {\\n        count++;\\n        m >>= 1;\\n        n >>= 1;\\n    }\\n    \\n    return m << count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rangeBitwiseAnd = function(m, n) {\\n    let count = 0;\\n    \\n    while (m != n) {\\n        count++;\\n        m >>= 1;\\n        n >>= 1;\\n    }\\n    \\n    return m << count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 593340,
                "title": "one-liner-python-with-dirty-math-no-import-math",
                "content": "```\\nreturn m & (-1 << (0 if m == n else len(bin(m ^ n))-2))\\n```\\nor\\n```\\nreturn m & (-1 << (len(bin(m ^ n))-2 - int(m == n)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nreturn m & (-1 << (0 if m == n else len(bin(m ^ n))-2))\\n```\n```\\nreturn m & (-1 << (len(bin(m ^ n))-2 - int(m == n)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 593281,
                "title": "java-alternative-easy-solution-4-5ms",
                "content": "The idea is to go through the all bits and check if it present in both numbers and if this bit is not larger then the difference `n-m`. \\n\\nSo in first `while` we discard all bits that are less than `n-m`, because if it is so - it means that on the way from `m` to `n` that bit will change at least once.\\n\\nIn the next `while` we append all bits that are present in both numbers and larger than difference, so it means they won\\'t change on that way. \\n\\nWe can stop when our bit is larger than `m`, because all the next bits won\\'t be present in `m`.\\n\\n```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int d = n - m;\\n        int res = 0;\\n        long p = 1;\\n        while (p <= m && p <= d) { p = p << 1; }\\n        while (p <= m) {\\n            if ((p&n) != 0 && (p&m) != 0) res |= p;\\n            p = p << 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int d = n - m;\\n        int res = 0;\\n        long p = 1;\\n        while (p <= m && p <= d) { p = p << 1; }\\n        while (p <= m) {\\n            if ((p&n) != 0 && (p&m) != 0) res |= p;\\n            p = p << 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593205,
                "title": "easy-python-3-lsb-solution",
                "content": "Easy python- find LSB and keep flipping as long as we\\'re within the range. \\nThis all hinges on the fact that the 2\\'s complement of n is -n. So the loop runs until we exceed the range from m-n (inclusive) and we keep getting the least significant bit and subtracting that from n. When we\\'re no longer within the range, we return the value of n we\\'ve arrived at. \\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        if m==n:\\n            return m\\n        \\n        while (m<n):\\n            n -= (n & -n)\\n        \\n        return n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        if m==n:\\n            return m\\n        \\n        while (m<n):\\n            n -= (n & -n)\\n        \\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433266,
                "title": "c-concise-solution-with-explanation",
                "content": "The bit positions that will be set to `1` in our result are those which are `1` in every number in our given range.\\n\\nWe check each bit position as long as the value of that bit is greater than or equal to the difference between our upper and lower bound. Any lesser bits are guaranteed to flip at least once in the given range, so we don\\'t bother checking those.\\n\\nFor each bit position, simply check that the bit is set in both given bounds, since that will also ensure that every number within the range has that bit set. Add this bit to our result and continue.\\n\\n```cpp\\nint rangeBitwiseAnd(int m, int n, int res = 0) {\\n\\tfor (int p = 1 << 30; p >= max(1, n - m); p >>= 1)\\n\\t\\tif ((m & p) && (n & p))\\n\\t\\t\\tres += p;\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nint rangeBitwiseAnd(int m, int n, int res = 0) {\\n\\tfor (int p = 1 << 30; p >= max(1, n - m); p >>= 1)\\n\\t\\tif ((m & p) && (n & p))\\n\\t\\t\\tres += p;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 406460,
                "title": "bit-manipulation-solution-in-java",
                "content": "This solution makes use of the intuition of what is occuring when we AND numbers between m and n. Example given below:\\n\\nm = 5 = 0x**01**01\\nn = 7 =  0x**01**11\\n\\nNotice when we increment 5 to 7, the **01** portion never changes.\\n\\nAnother example:\\n\\nm = 73 = 0x**010**01001\\nn = 82 = 0x**010**10010\\n\\nThe **010** portion never changes.\\n\\nAs we can see, this is the portion that we care about, all other bits are subject to change as m approaches n and thus evaluate to 0 as we AND among the numbers in the range. The bolded field are the bits that will remain intact.\\n\\nWith the given intuition, we just need to grab the bolded bits and return that as the answer. The solution given below:\\n```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int p = m ^ n;\\n        p |= p >> 1;\\n        p |= p >> 2;\\n        p |= p >> 4;\\n        p |= p >> 8;\\n        p |= p >> 16;\\n        return ~p & n;\\n    }\\n}\\n```\\n\\n`int p = m ^ n` gives us the difference between m and n. The higher-order bits that were equal in m and n will evaluate to zero. However, the bits in the lower-order bits are potentially combination of 1\\'s and 0\\'s (minus the bit adjacent to the right-most higher-order bit) illustrated below:\\n\\n0x**010**01001 ^ 0x**010**10010 = 0x**000**11011\\n\\nWe simply set all lower-level bits to 1 which is what the five lines of bit-shifts are doing. Inverse the final value to get our desired bitmask and AND it by n which gives you the answer.\\n\\np = 0x**000**11011 -> 0x**000**11111 -> 0x**111**00000\\n\\nn = 0x**010**10010\\n\\nAnswer = 0x**111**00000 & 0x**010**10010 = 0x**010**00000 = 64",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int p = m ^ n;\\n        p |= p >> 1;\\n        p |= p >> 2;\\n        p |= p >> 4;\\n        p |= p >> 8;\\n        p |= p >> 16;\\n        return ~p & n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260812,
                "title": "java-simple-explanation-100",
                "content": "Inspired from - [this Stack Overflow ans](https://stackoverflow.com/questions/31949524/bitwise-and-for-range-of-numbers).\\n2 things to consider\\n1. if the 2 numbers are equal, then their Binary representations are equal. so return the number.\\n2. We need to keep chopping off the LSB, ie. so we keep right shifting until `m` becomes equal to `n`.\\n\\nWhen it does become equal, we left shift either m or n, step times to the left, and return the resultant value.\\n\\n```\\npublic int rangeBitwiseAnd(int m, int n) {\\n        \\n        //********************\\n        int ans = 0;\\n        int step = 0;\\n        while (m != n) {\\n            //we need to keep chopping off the lsb\\n            m = m >>> 1;\\n            n = n >>> 1;\\n            step++;\\n        }\\n        ans = m << step;\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int rangeBitwiseAnd(int m, int n) {\\n        \\n        //********************\\n        int ans = 0;\\n        int step = 0;\\n        while (m != n) {\\n            //we need to keep chopping off the lsb\\n            m = m >>> 1;\\n            n = n >>> 1;\\n            step++;\\n        }\\n        ans = m << step;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 224460,
                "title": "simple-c-98-solution-with-clear-explanation-in-24ms",
                "content": "Actually, if the numbers of the range of m and n are different in lowbits, after AND operation, the lowbits will be zero 0 and only these highbits can be saved , which is the final result. \\nFor example,  5 ->101,  6->110, 7->111, we can infer that the low two bits are different ,so after AND, they will be zero. The highest bit will be saved,the final result is 4->100. So only select the high bits can we get the final result, in which we can right shift operation all the numbers untill they equal to each other. for instance, 5,6,7 >> operate twice which can get the same result 4. But actually,  we just need operate the m and n, because the low bits of the numbers of boundary is more likely different.  \\n```\\nint rangeBitwiseAnd(int m, int n) \\n    {\\n        int i=0;\\n        while(m!=n)\\n        {\\n            m>>=1;\\n            n>>=1;\\n            i++;\\n        }\\n        return m<<i;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint rangeBitwiseAnd(int m, int n) \\n    {\\n        int i=0;\\n        while(m!=n)\\n        {\\n            m>>=1;\\n            n>>=1;\\n            i++;\\n        }\\n        return m<<i;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 211810,
                "title": "c-o-32-shift",
                "content": "```\\nint rangeBitwiseAnd(int m, int n) {\\n    int count = 0;\\n    while(m != n){\\n        m >>= 1;\\n        n >>= 1;\\n        count += 1;\\n    }\\n    return m <<= count;\\n}\\n```\\nobservation 1:\\nm = aaaaaa1xx...xx \\nn  = aaaaaa0xx...xx\\nm, n must have the form that\\n\"the next digit\" of common prefix digits is 1 for m and 0 for n\\n\\nobservation 2:\\nn = aaaaaa0xx...xx <= aaaaaa0111...111 <= aaaaaa1000...000 <= aaaaaa1xx...xx = m\\n\\nobservation 3:\\naaaaaa0111...111 & aaaaaa1000...000 = aaaaaa0000...000\\n\\nobservation 4:\\nfor any k in [m, n], k has common prefix aaaaaa\\n\\nTherefore,  the anser is the longest common prefix in binary digits",
                "solutionTags": [],
                "code": "```\\nint rangeBitwiseAnd(int m, int n) {\\n    int count = 0;\\n    while(m != n){\\n        m >>= 1;\\n        n >>= 1;\\n        count += 1;\\n    }\\n    return m <<= count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56720,
                "title": "simple-c-solution-counting-different-lower-bits",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int len = 0;\\n        while (m != n) { m >>= 1; n >>= 1; ++len; }\\n        return m << len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int len = 0;\\n        while (m != n) { m >>= 1; n >>= 1; ++len; }\\n        return m << len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56756,
                "title": "simple-c-1-liner-solution-with-detailed-explanation",
                "content": "There are four steps to the solution:\\n\\n**Step 1 :** Compute Range of Numbers\\nGiven by, **( n - m )**\\n\\n**Step 2 :** Compute Number of Bits that will toggle in this range\\nGiven by, **ceil ( log ( n - m ) / log ( 2 ) )**\\n```\\nThe idea is that:\\nBit 0 (LSB) will toggle every time we move from m to n\\nBit 1 will toggle alternately\\nBit 2 will toggle every one in four times\\nand so on...\\n\\nSo taking logarithm base 2 of the above range,\\nwe can compute the number of bits that will toggle from going from right to left, \\nand hence will definitely be zero in the result.\\n```\\n\\n**Step 3 :** Take a INT_MAX integer and left shift it to the count above\\nGiven by, **INT_MAX << ( ceil ( log ( n - m ) / log ( 2 ) ) )**\\n```\\nThe idea is that:\\nResult will definitely have the number of bits calculated above as 0\\nSince these bits toggle; and\\nAND operator requires all bits under consideration to be 1 to output 1\\n```\\n**Step 4 :** Just AND the above output with m and n\\nGiven by, **( INT_MAX << ( ceil ( log ( n - m ) / log ( 2 ) ) ) ) & m & n**\\n```\\nThe idea is that:\\nWe need to retain only those bits now that are set in both m and n\\nAND it to the result from previous step\\n```\\n**So, our final code is:**\\n```\\nreturn ((INT_MAX<<((int)ceil(log(n-m)/log(2))))&m&n);\\n```",
                "solutionTags": [],
                "code": "```\\nThe idea is that:\\nBit 0 (LSB) will toggle every time we move from m to n\\nBit 1 will toggle alternately\\nBit 2 will toggle every one in four times\\nand so on...\\n\\nSo taking logarithm base 2 of the above range,\\nwe can compute the number of bits that will toggle from going from right to left, \\nand hence will definitely be zero in the result.\\n```\n```\\nThe idea is that:\\nResult will definitely have the number of bits calculated above as 0\\nSince these bits toggle; and\\nAND operator requires all bits under consideration to be 1 to output 1\\n```\n```\\nThe idea is that:\\nWe need to retain only those bits now that are set in both m and n\\nAND it to the result from previous step\\n```\n```\\nreturn ((INT_MAX<<((int)ceil(log(n-m)/log(2))))&m&n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56768,
                "title": "two-line-c-simple-solution",
                "content": "```\\nint rangeBitwiseAnd(int m, int n) {\\n    while (n > m) n &= (n-1);\\n    return n;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint rangeBitwiseAnd(int m, int n) {\\n    while (n > m) n &= (n-1);\\n    return n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56791,
                "title": "my-simple-c-code",
                "content": "    int rangeBitwiseAnd(int m, int n) \\n    {\\n        for(int k=0; m>0&&n>0; k++)\\n        {\\n            if(m==n)\\n            {\\n                while(k>0)\\n                {\\n                    m=m<<1;\\n                    k--;\\n                }\\n                return m;\\n            }\\n            m=m>>1;\\n            n=n>>1;\\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "    int rangeBitwiseAnd(int m, int n) \\n    {\\n        for(int k=0; m>0&&n>0; k++)\\n        {\\n            if(m==n)\\n            {\\n                while(k>0)\\n                {\\n                    m=m<<1;\\n                    k--;\\n                }\\n                return m;\\n            }\\n            m=m>>1;\\n            n=n>>1;\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56801,
                "title": "check-all-the-common-bits-from-most-significant-bit",
                "content": "    public int rangeBitwiseAnd(int m, int n) {\\n        int result = 0;\\n        \\n        for(int i = 30; i >= 0; i--){\\n            int mask = 1 << i;\\n            \\n            if((n & mask) == (m & mask)){\\n                result |= (mask & m);\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    public int rangeBitwiseAnd(int m, int n) {\\n        int result = 0;\\n        \\n        for(int i = 30; i >= 0; i--){\\n            int mask = 1 << i;\\n            \\n            if((n & mask) == (m & mask)){\\n                result |= (mask & m);\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56806,
                "title": "three-different-solutions-in-c-very-terse-and-clean",
                "content": "    int rangeBitwiseAnd(int m, int n)\\n    {\\n        int count = 0;\\n        while(m != n) //until the left identical bits, all the right will be cancelled by increments from m to n;;\\n        {\\n            m >>= 1;\\n            n >>= 1;\\n            count++;\\n        }\\n        return m << count;\\n    }\\n    \\n    \\n----------\\n    \\n    \\n    //AC - get the left common part;\\n    int rangeBitwiseAnd1(int m, int n)\\n    {\\n        int r = INT_MAX;\\n        while((m&r) != (n&r)) r <<= 1;\\n        return n&r;\\n    }\\n    \\n----------\\n    \\n    \\n    int rangeBitwiseAnd(int m, int n)\\n    {\\n        while(m < n) n &= n-1; //remove the right bit-1 until equal to or less than m;\\n        return n;\\n    }",
                "solutionTags": [],
                "code": "    int rangeBitwiseAnd(int m, int n)\\n    {\\n        int count = 0;\\n        while(m != n) //until the left identical bits, all the right will be cancelled by increments from m to n;;\\n        {\\n            m >>= 1;\\n            n >>= 1;\\n            count++;\\n        }\\n        return m << count;\\n    }\\n    \\n    \\n----------\\n    \\n    \\n    //AC - get the left common part;\\n    int rangeBitwiseAnd1(int m, int n)\\n    {\\n        int r = INT_MAX;\\n        while((m&r) != (n&r)) r <<= 1;\\n        return n&r;\\n    }\\n    \\n----------\\n    \\n    \\n    int rangeBitwiseAnd(int m, int n)\\n    {\\n        while(m < n) n &= n-1; //remove the right bit-1 until equal to or less than m;\\n        return n;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56809,
                "title": "two-lines-solution-just-a-math-problem-python-c-java",
                "content": " C++:\\n\\n    #include <cmath>\\n    class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int t = (int) ceil(log(n-m+1)/log(2));\\n            return m&n>>t<<t;\\n        }\\n    };\\nPython\\n\\n    from math import *\\n    class Solution(object):\\n        def rangeBitwiseAnd(self, m, n):\\n            t =  int(ceil(log(n-m+1)/log(2)))\\n            return m&n >> t << t\\n            \\nJava:\\n\\n    public class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            int t = (int) Math.ceil(Math.log(n-m+1)/Math.log(2));\\n            return m&n >> t << t;\\n        }\\n    }\\n\\nExplanation:\\n\\n> 0b11111110000   \\n> 0b11111110001  \\n> 0b11111110010  \\n> 0b11111110011   \\n> 0b11111110100  \\n> 0b11111110101    \\n> 0b11111110110  \\n> 0b11111110111   \\n> 0b11111111000  \\n> 0b11111111001   \\n> 0b11111111010   \\n> 0b11111111011   \\n> 0b11111111100   \\n> 0b11111111101   \\n> 0b11111111110    \\n> 0b11111111111  \\n\\nWe can see every 1+1/2+1/4+1/8+1/16+1/... adjacent numbers, there must be a digit change in binary form. And if it is a \"16 + 1\" change, the smaller ones(i.e. \"8+1\", \"4+1\", \"2+1\", \"1+1\") must change (more than once) as well. And once changed, it must be from 0 to 1, or 1 to 0. Either will get 0.\\n\\nIf it is a 16+1 change, (or rather there are 16+1 numbers between m and n --- n-m+1=16+1=17) then last 5 ( ceil(log17/log2) = 5 ) must be zero after all the \"&\" operations. That's why doing \">>t<<t\", to make last five digits to be zero.\\n\\nThe special case is we are not sure about the 6th digit has changed or not, but we can know it by using m&n.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int t = (int) ceil(log(n-m+1)/log(2));\\n            return m&n>>t<<t;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 56826,
                "title": "share-my-o-1-time-solution-with-explanation-and-proof",
                "content": "With a little bit observation, we can come to a quick conclusion\\n \\n 0. when n - m == 0: the result is **n & m** \\n 1. when n - m == 1: the result is **n & m masked last 1 bit as 0**,\\n 2. when n - m == 2: the result is **n & m masked last 2 bit as 0**,\\n 3. when n - m == 4: the result is **n & m masked last 3 bit as 0**,\\n 4. when n - m == 2^i: the result is **n & m masked last i bit as 0**\\n\\nWe can proof with Induction: \\n\\nAssume when n - m = 2^i, where i > 1, we have the result of continuous AND operation from [n,m] is  **n & m masked last i bit as 0**. We denotes **R_i as number R with last i bits masked as 0**. Thus result of AND through [n, m] is **(n & m)_i**\\n\\nWe can easily proof when i == 0 and i == 1, the assumption holds.\\n\\nWhen **n'** - m == 2^(i+1). We can rewrites it as (2n-m) - m == 2^(i+1). So, AND through [m, 2n-m] equals AND through [m, n] and then through [n+1, 2n-m]. We denotes the result is **R\\u2018**\\n\\n**R'** = (m & n)_i & [ (n+1) & (2n-m)]_i \\n\\nit won't bother if we AND anther n in [n+1, 2n-m], thus\\n\\n**R'** = (m & n )_i  &  [ ( **n** ) & (2n-m) ]_i \\n\\n== (m)_i   &   (n)_i   &  (n)_i   &   (2n-m)_i \\n\\n== (m)_i  &  (n)_i & (2n-m)_i  //  since  (n)_i  & (n)_i =  (n)_i\\n\\n== (m)_i  &  (m+2^i)_i & [m+2^(i+1)]_i  // since n = m + 2^i\\n\\nDenotes the i-th bit of m as m(i), we can easily proof that when {m(i+1), m(i)} are {0,0}, {0,1}, {1,0} or {1,1},  the (i+1)-th bit of previous equation will always be 0. Moreover, we already masked last i bits, so ,the last (i+1) bits of the previous equation is 0.\\n\\n\\n\\n    class Solution(object):\\n    def rangeBitwiseAnd(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        import math\\n        if m == n: return m&n\\n        i = int(math.log(n-m, 2))\\n        return (0x7fffffff ^ (1<<i+1) -1 ) & m & n",
                "solutionTags": [],
                "code": "With a little bit observation, we can come to a quick conclusion\\n \\n 0. when n - m == 0: the result is **n & m** \\n 1. when n - m == 1: the result is **n & m masked last 1 bit as 0**,\\n 2. when n - m == 2: the result is **n & m masked last 2 bit as 0**,\\n 3. when n - m == 4: the result is **n & m masked last 3 bit as 0**,\\n 4. when n - m == 2^i: the result is **n & m masked last i bit as 0**\\n\\nWe can proof with Induction: \\n\\nAssume when n - m = 2^i, where i > 1, we have the result of continuous AND operation from [n,m] is  **n & m masked last i bit as 0**. We denotes **R_i as number R with last i bits masked as 0**. Thus result of AND through [n, m] is **(n & m)_i**\\n\\nWe can easily proof when i == 0 and i == 1, the assumption holds.\\n\\nWhen **n'** - m == 2^(i+1). We can rewrites it as (2n-m) - m == 2^(i+1). So, AND through [m, 2n-m] equals AND through [m, n] and then through [n+1, 2n-m]. We denotes the result is **R\\u2018**\\n\\n**R'** = (m & n)_i & [ (n+1) & (2n-m)]_i \\n\\nit won't bother if we AND anther n in [n+1, 2n-m], thus\\n\\n**R'** = (m & n )_i  &  [ ( **n** ) & (2n-m) ]_i \\n\\n== (m)_i   &   (n)_i   &  (n)_i   &   (2n-m)_i \\n\\n== (m)_i  &  (n)_i & (2n-m)_i  //  since  (n)_i  & (n)_i =  (n)_i\\n\\n== (m)_i  &  (m+2^i)_i & [m+2^(i+1)]_i  // since n = m + 2^i\\n\\nDenotes the i-th bit of m as m(i), we can easily proof that when {m(i+1), m(i)} are {0,0}, {0,1}, {1,0} or {1,1},  the (i+1)-th bit of previous equation will always be 0. Moreover, we already masked last i bits, so ,the last (i+1) bits of the previous equation is 0.\\n\\n\\n\\n    class Solution(object):\\n    def rangeBitwiseAnd(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        import math\\n        if m == n: return m&n\\n        i = int(math.log(n-m, 2))\\n        return (0x7fffffff ^ (1<<i+1) -1 ) & m & n",
                "codeTag": "Java"
            },
            {
                "id": 56843,
                "title": "simple-and-fast-java-solution-with-explanation",
                "content": "For this problem, the naive approach is to iterate from n to m and & all the values. However, this approach is time consuming because it waste time to & values which will eventually be 0.  The insight  of this problem is that we can be sure the value & from n to m will be 0 if the index of the highest 1 in n's binary representation is different from the index of the highest 1 in m's binary representation. For example if we have n=001 and m=110, we will have two value in between which could be 001 and 100 and these two & will be 0 which makes the whole value 0.  Here goes my code in java, hope it will explain itself:\\n\\n    public class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            int p1=0, p2=0;\\n            int val1=m, val2=n;\\n            while(val1>1 || val2>1)\\n            {\\n                if(val1>1) \\n                {\\n                    val1=val1/2;\\n                    p1++;\\n                }\\n                if(val2>1)\\n                {\\n                    val2=val2/2;\\n                    p2++;\\n                }\\n            }\\n            if(p1!=p2) return 0;\\n            \\n            int result=~0;\\n            for(int i=m;i<n;i++)\\n                result=result&i;\\n            result=result&n;\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            int p1=0, p2=0;\\n            int val1=m, val2=n;\\n            while(val1>1 || val2>1)\\n            {\\n                if(val1>1) \\n                {\\n                    val1=val1/2;\\n                    p1++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 56848,
                "title": "share-a-simple-four-line-python-solution-using-bit-operation",
                "content": "It seems that no one has post this solution which is pretty simple.\\n\\nIf we go through all the numbers from m to n, only those digits which are constantly 1 can remain to be 1 at last. So we simply operate m xor n to calculate the number of zeros at the end of result. \\n\\nThe final result should be  n>>zeors concatenates to zeros. Here is the code.\\n\\n    class Solution:\\n    # @param {integer} m\\n    # @param {integer} n\\n    # @return {integer}\\n    def rangeBitwiseAnd(self, m, n):\\n        if m == n:\\n            return m\\n        zeros = len(bin(m^n)) - 2\\n        return (n >> zeros) * (2**zeros)",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 56860,
                "title": "a-3-line-non-recursive-c-solution-with-clear-explanation",
                "content": "    // The idea is not to loop all numbers in-between or recursive\\n    // Thinking in this way:\\n    //   1. Binary counter has only 1 or 0 at each bit,\\n    //       so once it was changed once, the result on this bit must be 0,\\n    //       therefore we are looking for the bits which were changed in-between the 2 numbers.\\n    //   2. To find out the changed bits, we need only a ^ operation between m and n, for\\n    //         it's reflecting the 2 numbers difference as well as the bits part changed.\\n    //         Below sample shows the m^n result and we are interested in the leftest position of 1\\n    //       A sample: m: 00000001,10101010,00101011,11010111\\n    //                 n: 00000001,10101010,00110001,01111001\\n    //                m^n:00000000,00000000,00011010,10101110\\n    //   3. Next step is to find out the leftest position of 1 in m^n, and this is going to be done by a \\n    //        for loop and a counter. Counter will be used clear 0 in m\\n    //   4. Right shift m the counter times then shift left back same counter times,\\n    //         as is to clear all changed parts to 0.\\n    public int RangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        for(int changed = m^n; changed > 0; changed /= 2, count++); //Counting length\\n        return m >> count << count; //Clear 0s at changed bits\\n    }",
                "solutionTags": [],
                "code": "    // The idea is not to loop all numbers in-between or recursive\\n    // Thinking in this way:\\n    //   1. Binary counter has only 1 or 0 at each bit,\\n    //       so once it was changed once, the result on this bit must be 0,\\n    //       therefore we are looking for the bits which were changed in-between the 2 numbers.\\n    //   2. To find out the changed bits, we need only a ^ operation between m and n, for\\n    //         it's reflecting the 2 numbers difference as well as the bits part changed.\\n    //         Below sample shows the m^n result and we are interested in the leftest position of 1\\n    //       A sample: m: 00000001,10101010,00101011,11010111\\n    //                 n: 00000001,10101010,00110001,01111001\\n    //                m^n:00000000,00000000,00011010,10101110\\n    //   3. Next step is to find out the leftest position of 1 in m^n, and this is going to be done by a \\n    //        for loop and a counter. Counter will be used clear 0 in m\\n    //   4. Right shift m the counter times then shift left back same counter times,\\n    //         as is to clear all changed parts to 0.\\n    public int RangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        for(int changed = m^n; changed > 0; changed /= 2, count++); //Counting length\\n        return m >> count << count; //Clear 0s at changed bits\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56867,
                "title": "c-accepted-easy-to-understand-recursive",
                "content": "\\nThis answer is from @applewolf 's one line solution:\\nhttps://leetcode.com/discuss/34918/one-line-c-solution\\n\\nif number m < n, then at the last bit, there must exist both 1 and 0, so the AND result at the last bit would be 0.\\n\\nFor example,\\n4: 0100\\nAND\\n5: 0101\\n\\nSo the problem became:\\n4 >> 1: 0010 \\nAND\\n5 >> 1: 0010\\n\\nThen back 1 bit\\n0010 << 1 = 0100\\n\\n\\n    public static int RangeBitwiseAnd(int m, int n)\\n    {\\n        if (m < n)\\n        {\\n            return (RangeBitwiseAnd(m >> 1, n >> 1) << 1);\\n        }\\n        else\\n        {\\n            // m = n\\n            return m;\\n        }\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "\\nThis answer is from @applewolf 's one line solution:\\nhttps://leetcode.com/discuss/34918/one-line-c-solution\\n\\nif number m < n, then at the last bit, there must exist both 1 and 0, so the AND result at the last bit would be 0.\\n\\nFor example,\\n4: 0100\\nAND\\n5: 0101\\n\\nSo the problem became:\\n4 >> 1: 0010 \\nAND\\n5 >> 1: 0010\\n\\nThen back 1 bit\\n0010 << 1 = 0100\\n\\n\\n    public static int RangeBitwiseAnd(int m, int n)\\n    {\\n        if (m < n)\\n        {\\n            return (RangeBitwiseAnd(m >> 1, n >> 1) << 1);\\n        }\\n        else\\n        {\\n            // m = n\\n            return m;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56877,
                "title": "100-ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int i = n^m;\\n            int p = -1;\\n            while(i!=0){\\n                i>>=1;\\n                p<<=1;\\n            }\\n            return m&p;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int i = n^m;\\n            int p = -1;\\n            while(i!=0){\\n                i>>=1;\\n                p<<=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 56889,
                "title": "c-cpp-soln-no-loops-recursion",
                "content": "   \\n\\n    int Log2(int n) {\\n            return log(n)/log(2);\\n     }\\n    \\n    int rangeBitwiseAnd(int m, int n) {\\n        int diff;\\n        // special case    \\n        if (m == n) \\n            return m;\\n        \\n        else {\\n            diff = Log2(n-m) + 1;\\n    \\t    m >>= diff;\\n    \\t    n >>= diff;\\n            return (m & n) << diff;\\n    \\t\\n        }\\n    \\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "   \\n\\n    int Log2(int n) {\\n            return log(n)/log(2);\\n     }\\n    \\n    int rangeBitwiseAnd(int m, int n) {\\n        int diff;\\n        // special case    \\n        if (m == n) \\n            return m;\\n        \\n        else {\\n            diff = Log2(n-m) + 1;\\n    \\t    m >>= diff;\\n    \\t    n >>= diff;\\n            return (m & n) << diff;\\n    \\t\\n        }\\n    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56892,
                "title": "java-solution-using-math-log",
                "content": "    /*\\n        From right to left, the ith bit (start from 0) will flip every pow(2,i) numbers.\\n        We can know that some bits of result will always be 0 resulting from such bit flip.\\n        The number of that kind of bits is log2(n-m)+1. (Exception is n-m=0).\\n        And these bits are adjacent, starting from right.\\n        Let L = log2(n-m)+1. (n-m!=0)\\n        We can create a mask that all bits are '1'. And set L bits counting from right to left to '0'.\\n        Use this mask to do AND operation with (m & n).\\n        \\n        For example m=6(0000 0110) n=12(0000 1100).\\n        L = 3\\n        mask = (1111 1000)\\n        result = m & n & mask = 0\\n    */\\n    public int rangeBitwiseAnd(int m, int n) {\\n        if(m==n)\\n            return m;\\n        int dif = n-m;\\n        int log = (int) (Math.log(dif)/Math.log(2));//log = log2(dif)\\n        int base = 0xffffffff;\\n        int mask = base<<(log+1);\\n        return m & n & mask;\\n    }",
                "solutionTags": [],
                "code": "    /*\\n        From right to left, the ith bit (start from 0) will flip every pow(2,i) numbers.\\n        We can know that some bits of result will always be 0 resulting from such bit flip.\\n        The number of that kind of bits is log2(n-m)+1. (Exception is n-m=0).\\n        And these bits are adjacent, starting from right.\\n        Let L = log2(n-m)+1. (n-m!=0)\\n        We can create a mask that all bits are '1'. And set L bits counting from right to left to '0'.\\n        Use this mask to do AND operation with (m & n).\\n        \\n        For example m=6(0000 0110) n=12(0000 1100).\\n        L = 3\\n        mask = (1111 1000)\\n        result = m & n & mask = 0\\n    */\\n    public int rangeBitwiseAnd(int m, int n) {\\n        if(m==n)\\n            return m;\\n        int dif = n-m;\\n        int log = (int) (Math.log(dif)/Math.log(2));//log = log2(dif)\\n        int base = 0xffffffff;\\n        int mask = base<<(log+1);\\n        return m & n & mask;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3689623,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        return (right>left)? (rangeBitwiseAnd(left/2,right/2)<<1):left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        return (right>left)? (rangeBitwiseAnd(left/2,right/2)<<1):left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195650,
                "title": "c-solution-with-explaination",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    /* \\n    Check last bit every time \\n    When (left != right), there is at least an 1 and 0 \\n    Right shift left and right\\n    Keep doing those steps until (left = right), use a factor to record the iteration time.\\n    Find the bigest same part\\n    Left shift to get the result\\n    */\\n    public int RangeBitwiseAnd(int left, int right) \\n    {\\n        var count = 0;\\n\\n        while(left != right)\\n        {\\n            count++;\\n            left = left >> 1;\\n            right = right >> 1;\\n        }\\n\\n        return left << count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    /* \\n    Check last bit every time \\n    When (left != right), there is at least an 1 and 0 \\n    Right shift left and right\\n    Keep doing those steps until (left = right), use a factor to record the iteration time.\\n    Find the bigest same part\\n    Left shift to get the result\\n    */\\n    public int RangeBitwiseAnd(int left, int right) \\n    {\\n        var count = 0;\\n\\n        while(left != right)\\n        {\\n            count++;\\n            left = left >> 1;\\n            right = right >> 1;\\n        }\\n\\n        return left << count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177705,
                "title": "aisa-soln-nahi-dekha-hoga",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if(left==0 || right==0) return 0;\\n        if(left==right) return left;\\n        int x = log10(left)/log10(2);\\n        int y = log10(right)/log10(2);\\n        if(y-x>=1) return 0;\\n        long long ans = left;\\n        for(long long i=left+1;i<=right;i++) ans&=i; \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if(left==0 || right==0) return 0;\\n        if(left==right) return left;\\n        int x = log10(left)/log10(2);\\n        int y = log10(right)/log10(2);\\n        if(y-x>=1) return 0;\\n        long long ans = left;\\n        for(long long i=left+1;i<=right;i++) ans&=i; \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164488,
                "title": "short-simple-javascript-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst shift the left & right AND\\'s while they are not equal. Once they are equal then add zero at the end the number of times we shifted, the resultent is our answer.\\n# Code\\n```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nvar rangeBitwiseAnd = function(left, right) {\\n    var i = 0\\n    while(left != right){\\n        i++\\n        left >>= 1\\n        right >>= 1\\n\\n    }\\n    return left << i\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nvar rangeBitwiseAnd = function(left, right) {\\n    var i = 0\\n    while(left != right){\\n        i++\\n        left >>= 1\\n        right >>= 1\\n\\n    }\\n    return left << i\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3110066,
                "title": "201-simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if(left==right)\\n        return left;\\n        for(long long int i=left;i<=right;i++)\\n        {\\n            left&=i;\\n            if(left==0)\\n            return left;    \\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if(left==right)\\n        return left;\\n        for(long long int i=left;i<=right;i++)\\n        {\\n            left&=i;\\n            if(left==0)\\n            return left;    \\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811354,
                "title": "c-bit-manipulation-self-explanatory-clean-short",
                "content": "![image](https://assets.leetcode.com/users/images/ffad2c35-4435-40c8-9dd4-36d08ccb5c81_1668353836.3737333.png)\\n\\n**n==right-left\\nT->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint rangeBitwiseAnd(int left, int right) {\\n\\t\\t\\t\\tlong long ans=left;\\n\\t\\t\\t\\tfor(long long i=left;i<=right;i++){\\n\\t\\t\\t\\t\\tans&=i;\\n\\t\\t\\t\\t\\tif(!ans) return 0;\\n\\t\\t\\t\\t}    \\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint rangeBitwiseAnd(int left, int right) {\\n\\t\\t\\t\\tlong long ans=left;\\n\\t\\t\\t\\tfor(long long i=left;i<=right;i++){\\n\\t\\t\\t\\t\\tans&=i;\\n\\t\\t\\t\\t\\tif(!ans) return 0;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2686827,
                "title": "python-bits-manipulation-solution-with-detailed-intuition",
                "content": "```\\n\\'\\'\\'\\n# Intuition:\\nTraverse from LSB to MSB and keep right-shifting left and right until both of them become equal. \\nIf at any bit position left side bits of left and right are equal ie. left == right, \\nthen all numbers in [left, right] will also be equal.\\n\\ne.g.\\nbit index =  3 2 1 0\\nleft =  12 = 1 1 0 0\\n        13 = 1 1 0 1\\n        14 = 1 1 1 0\\nright = 15 = 1 1 1 1\\n\\nAfter right-shifting left and right 2 times(ie. count = 2), left == right = 12 = 13 = 14 = 15 = 0 0 1 1\\nSo \\'&\\' of all number in [left, right] is (left << count)\\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        count = 0\\n        \\n        while left != right:\\n            left = left >> 1\\n            right = right >> 1\\n            count += 1\\n        \\n        return left << count\\n                \\n        \\n# Time: O(1)\\n# Space: O(1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\'\\'\\'\\n# Intuition:\\nTraverse from LSB to MSB and keep right-shifting left and right until both of them become equal. \\nIf at any bit position left side bits of left and right are equal ie. left == right, \\nthen all numbers in [left, right] will also be equal.\\n\\ne.g.\\nbit index =  3 2 1 0\\nleft =  12 = 1 1 0 0\\n        13 = 1 1 0 1\\n        14 = 1 1 1 0\\nright = 15 = 1 1 1 1\\n\\nAfter right-shifting left and right 2 times(ie. count = 2), left == right = 12 = 13 = 14 = 15 = 0 0 1 1\\nSo \\'&\\' of all number in [left, right] is (left << count)\\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        count = 0\\n        \\n        while left != right:\\n            left = left >> 1\\n            right = right >> 1\\n            count += 1\\n        \\n        return left << count\\n                \\n        \\n# Time: O(1)\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686824,
                "title": "python-bits-manipulation-solution-with-detailed-intuition",
                "content": "```\\n\\'\\'\\'\\n# Intuition:\\nTraverse from LSB to MSB and keep right-shifting left and right until both of them become equal. \\nIf at any bit position left side bits of left and right are equal ie. left == right, \\nthen all numbers in [left, right] will also be equal.\\n\\ne.g.\\nbit index =  3 2 1 0\\nleft =  12 = 1 1 0 0\\n        13 = 1 1 0 1\\n        14 = 1 1 1 0\\nright = 15 = 1 1 1 1\\n\\nAfter right-shifting left and right 2 times(ie. count = 2), left == right = 12 = 13 = 14 = 15 = 0 0 1 1\\nSo \\'&\\' of all number in [left, right] is (left << count)\\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        count = 0\\n        \\n        while left != right:\\n            left = left >> 1\\n            right = right >> 1\\n            count += 1\\n        \\n        return left << count\\n                \\n        \\n# Time: O(1)\\n# Space: O(1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\'\\'\\'\\n# Intuition:\\nTraverse from LSB to MSB and keep right-shifting left and right until both of them become equal. \\nIf at any bit position left side bits of left and right are equal ie. left == right, \\nthen all numbers in [left, right] will also be equal.\\n\\ne.g.\\nbit index =  3 2 1 0\\nleft =  12 = 1 1 0 0\\n        13 = 1 1 0 1\\n        14 = 1 1 1 0\\nright = 15 = 1 1 1 1\\n\\nAfter right-shifting left and right 2 times(ie. count = 2), left == right = 12 = 13 = 14 = 15 = 0 0 1 1\\nSo \\'&\\' of all number in [left, right] is (left << count)\\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        count = 0\\n        \\n        while left != right:\\n            left = left >> 1\\n            right = right >> 1\\n            count += 1\\n        \\n        return left << count\\n                \\n        \\n# Time: O(1)\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549796,
                "title": "c-two-simple-approach-brute-force-and-bit-manipulation",
                "content": "**Brute Force Approach:**\\nThe naive approach would be to traverse all the numbers from left to right, compute the AND, and subsequently store it as we proceed. \\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        long ans=left;\\n        for(long i=left; i<=right; i++) {\\n            ans &= i;\\n            if(ans==0) return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n`Time Complexity: O(n)`\\n\\n</br>\\n\\n**Bit Manipulation (Considering LSB):**\\nApproach...\\n* For every pair of continuous numbers, the last bit is different from the previous one(one is always 0 and the other is always 1 because continuous numbers form an even-odd pair or vice-versa). Hence, until both numbers are not equal, the resultant bitwise AND of the rightmost bit is always zero.\\n* So we check if the bits of *left* are equal to that of *right* or not.\\n* If they are not equal, we right shift our numbers, which basically removes the rightmost bit from the numbers.\\n* We keep a count of the number of shifts, say *count*.\\n* If the numbers are equal, we leftshift the remaining number count times. \\n* This gives us the required answer.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int count=0;\\n        while(left!=right) {\\n            left >>= 1;\\n            right >>= 1;\\n            count++;\\n        }\\n        return left<<count;\\n    }\\n};\\n```\\n\\n`Time Complexity: O(log(n))`\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        long ans=left;\\n        for(long i=left; i<=right; i++) {\\n            ans &= i;\\n            if(ans==0) return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int count=0;\\n        while(left!=right) {\\n            left >>= 1;\\n            right >>= 1;\\n            count++;\\n        }\\n        return left<<count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528555,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Bit Manipulation***\\n\\n* ***Time Complexity :- O(Constant)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        // count the no. of right shift required to make left and right equal\\n        \\n        int right_shift_count = 0;\\n        \\n        // do right shifting of both the left and right until both becomes equal\\n        \\n        while(left != right)\\n        {\\n            left = left >> 1;\\n            \\n            right = right >> 1;\\n            \\n            right_shift_count++;\\n        }\\n        \\n        // now do the left shift of left by right_shift_count\\n        \\n        int ans = left << right_shift_count;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        // count the no. of right shift required to make left and right equal\\n        \\n        int right_shift_count = 0;\\n        \\n        // do right shifting of both the left and right until both becomes equal\\n        \\n        while(left != right)\\n        {\\n            left = left >> 1;\\n            \\n            right = right >> 1;\\n            \\n            right_shift_count++;\\n        }\\n        \\n        // now do the left shift of left by right_shift_count\\n        \\n        int ans = left << right_shift_count;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332948,
                "title": "c-using-bit-manipulation-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int t=0;\\n        while(left!=right){\\n            left= left>>1;\\n            right= right>>1;\\n            t++;\\n        }\\n        int ans= left;\\n        while(t--){\\n            ans= ans<<1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int t=0;\\n        while(left!=right){\\n            left= left>>1;\\n            right= right>>1;\\n            t++;\\n        }\\n        int ans= left;\\n        while(t--){\\n            ans= ans<<1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163983,
                "title": "c-solution-93-71-time-74-32-space-left-and-right-shift",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right);\\n};\\n/**************************************************************************/\\nint Solution::rangeBitwiseAnd(int left, int right) {\\n    int i{};\\n    while (left != right) {\\n        ++i;\\n        left>>=1; \\n        right>>=1;\\n    }\\n    return left<<i;\\n}\\n/**************************************************************************/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right);\\n};\\n/**************************************************************************/\\nint Solution::rangeBitwiseAnd(int left, int right) {\\n    int i{};\\n    while (left != right) {\\n        ++i;\\n        left>>=1; \\n        right>>=1;\\n    }\\n    return left<<i;\\n}\\n/**************************************************************************/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154765,
                "title": "c-solution-with-explanation",
                "content": "We can observe that whenever a bit is flipped going from left to right, the output for that bit will be 0 (as 1&0 and 0&1 both equals 0.) and also see that whichever column has a flipped bit, all the columns right to that will also have a flipped bit. \\nexample: left = 20; right = 24;\\nleft = 20 =>    10100\\nright = 23 =>  10111\\nrightmost 2 columns will give 00(as both have flipped bits) while the other three columns will remain as it is.\\nso we can maintain a counter for the no. of flipped bits and right shift until m == n. when m==n we will left shift by count to add 0s at the end which came from the flipped bits.\\nso for this the output will be 10100.\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int count = 0;\\n        while(left != right) {\\n            left>>=1;\\n            right>>=1;\\n            count++;\\n        }\\n        return left<<=count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int count = 0;\\n        while(left != right) {\\n            left>>=1;\\n            right>>=1;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1884657,
                "title": "c-o-32-bit-operation-simple-solution-with-explanation",
                "content": "# Solution 1 (R)\\n\\nWe can find the most shared bits from left side to right side for `left` and `right` by `right &= (right-1)` until `right` \\u2264 `left` .\\n\\nFor example: `right` = `11100011`, `left` = `11000010`, then shared bits would be `11000000`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        while (right > left) {\\n            right &= (right-1);\\n        }\\n        return right;\\n    }\\n};\\n```\\n\\n**Time:** `O(32)`   \\n**Space:** `O(1)`",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        while (right > left) {\\n            right &= (right-1);\\n        }\\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850975,
                "title": "intuitive-simple-and-clean-well-explained-with-proof",
                "content": "Claim :  if run loop on bits from right to left if we came accross any bits which are unequal \\nwe will break from there and calculate the answer while looping why it is so ? \\n\\nleft :    00000010000000\\nright :  00000010101010\\n\\nBecause there exists an number which is in the form of the power of 2 which will make always make 0\\nrest of the bits.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        \\n        int ans = 0;\\n        for(int i=30;i>=0;i--){\\n            if((m & (1 << i)) != (n & (1 << i))) break;\\n            ans = ans | (m & (1 << i));\\n        }\\n        return ans;   \\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        \\n        int ans = 0;\\n        for(int i=30;i>=0;i--){\\n            if((m & (1 << i)) != (n & (1 << i))) break;\\n            ans = ans | (m & (1 << i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1741397,
                "title": "c",
                "content": "If a bit at ```i```-th (```0 <= i <= 31```) position is ```0``` in either ```left``` or ```right``` then the bit in the result at this position will also be ```0```, since we need at least one ```0``` to set all bits to ```0```. If not, i.e., both have their bits set at this ```i```, then check if the gap between these two numbers is less than or equal to ```2^i - 1```. On observation, one can see that the max-run of ```1```s (or ```0```s) is equal to ```2^i``` for the ```i```-th bit. Thus, if gap between inputs is greater than this range, then this range has at least one ```0``` for this ```i```.\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r)\\n    {\\n        if (l == r) return l;\\n        if (!l || !r) return 0;\\n        int n = 0;\\n        for (int i = 0; i < 31; ++i) {\\n            if (((l & (1 << i)) == 0) || ((r & (1 << i)) == 0)) continue;\\n            if ((r - l <= (1 << i) - 1)) {\\n                n |= (1 << i);\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```i```\n```0 <= i <= 31```\n```0```\n```left```\n```right```\n```0```\n```0```\n```0```\n```i```\n```2^i - 1```\n```1```\n```0```\n```2^i```\n```i```\n```0```\n```i```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r)\\n    {\\n        if (l == r) return l;\\n        if (!l || !r) return 0;\\n        int n = 0;\\n        for (int i = 0; i < 31; ++i) {\\n            if (((l & (1 << i)) == 0) || ((r & (1 << i)) == 0)) continue;\\n            if ((r - l <= (1 << i) - 1)) {\\n                n |= (1 << i);\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726706,
                "title": "c-all-possible-solutions",
                "content": "Approach 1: Brute force\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        int result = left;\\n        \\n        for(int i = left + 1; i <= right; i++)\\n            result = result & i;\\n        \\n        return result;\\n    }\\n};\\n```\\n\\nApproach 2: Use the property of BITWISE AND\\nMore explanation [here](https://leetcode.com/problems/bitwise-and-of-numbers-range/discuss/593317/Simple-3-line-Java-solution-faster-than-100#:~:text=Consider%20the%20following%20example%3A)\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        // Idea is bitwise and of 2 numbers will be less than or equal to that number\\n        // When u are given numbers in range there is no need to do repetitve AND\\n        // if u get a less answer that is good as ultimately u will reach there anyhow.\\n        // so, if u are reaching end directly why take longer steps to reach there.\\n        \\n        int result = right;\\n        \\n        while(right > left) {\\n            result = right & (right - 1);\\n            right = result;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        int result = left;\\n        \\n        for(int i = left + 1; i <= right; i++)\\n            result = result & i;\\n        \\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        // Idea is bitwise and of 2 numbers will be less than or equal to that number\\n        // When u are given numbers in range there is no need to do repetitve AND\\n        // if u get a less answer that is good as ultimately u will reach there anyhow.\\n        // so, if u are reaching end directly why take longer steps to reach there.\\n        \\n        int result = right;\\n        \\n        while(right > left) {\\n            result = right & (right - 1);\\n            right = result;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602277,
                "title": "simple-c-solution-0ms-100",
                "content": "```\\nint rangeBitwiseAnd(int left, int right){\\n    int reset = 0;\\n    while(left != right)\\n    {\\n        left >>= 1;\\n        right >>= 1;\\n        reset += 1;\\n    }\\n    return left << reset;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint rangeBitwiseAnd(int left, int right){\\n    int reset = 0;\\n    while(left != right)\\n    {\\n        left >>= 1;\\n        right >>= 1;\\n        reset += 1;\\n    }\\n    return left << reset;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1595589,
                "title": "java-solution-kernighans-algo",
                "content": "class Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        \\n\\n     while(right>left){         \\n         right=right&(right-1);         \\n     }\\n    return right;\\n}}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        \\n\\n     while(right>left){         \\n         right=right&(right-1);         \\n     }",
                "codeTag": "Java"
            },
            {
                "id": 1514638,
                "title": "one-line-solution-for-any-language-o-log-n",
                "content": "The key is to realise that if the left and right are equal, then that is your answer. If they are unequal, then you *know* that:\\n\\n(a) the last digit of your answer must be 0 \\n    (because your range contains at least one odd and one even number)\\nand\\n\\n(b) the remaining digits can be solved by recursively calling yourself, with the last digit removed from both the left and the right.\\n\\nThis is classic recursion which is easiest to understand like this:\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        if right==left:\\n            return left\\n        if right>left:\\n            return 2*Solution.rangeBitwiseAnd(self,left>>1,right>>1)\\n```\\n\\nThe one-line version? Just use a ternary expression in your language of choice. 8-)\\n\\nPython\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n\\t\\treturn left if right==left else Solution.rangeBitwiseAnd(self,left>>1,right>>1)*2\\n```\\n\\t\\t\\t\\nJavascript and other curly-bracket languages with a \"?\", \":\" ternary operator can use this one-liner:\\n\\n\\t\\treturn (right===left) ? left : Solution.rangeBitwiseAnd(self,left>>1,right>>1)*2\\n\\nI think this is easier than the other so-called \"medium\" cases that took me hours and hours!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        if right==left:\\n            return left\\n        if right>left:\\n            return 2*Solution.rangeBitwiseAnd(self,left>>1,right>>1)\\n```\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n\\t\\treturn left if right==left else Solution.rangeBitwiseAnd(self,left>>1,right>>1)*2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514567,
                "title": "javascript-loop-less-o-1-explained",
                "content": "For a range of binary numbers, observe the following:\\n\\n- Bitwise AND means that the `n`th bit of the result is `1` only if there are no `0`s at the `n`th bit of any numbers in the range.\\n- If the `n`th bit changes in the range, then either of them must be `0`, so the `n`th bit of the output will be `0`.\\n- If the `n`th bit changes in the range, the `n-1`th bit must also change (it must carry to the `n`th bit, resetting to `0` in  the process).\\n\\nConsidering these, we can figure out that we have to find the the last bit from the left that doesn\\'t change; all bits to the right of that bit will be zeros.\\n\\nTo find changes, we can use XOR, that will make the `n`th bit a `1` if it is different in the start and the end number of the range. Although this doesn\\'t detect bits that change multiple times in the range, we are only looking for the first change, which has to be a single change (otherwise it would carry, causing the next bit to change once). Then, find the bit before the first `1` (i.e. the first change) by using `Math.clz32()` (`c`ount `l`eading `z`eroes `32` bit).\\n\\nOnce we have that, we can just make a bitmask by starting with an all-ones pattern (i.e. `0xffffffff`, NOT `0` or `~0`), then shifting it to the left as many times as many bits we have to the right of the last `0` (equal) bit. That can be found by subtracting the count of leading zeroes from the number of bits, `32` in this case.\\n\\nFinally, AND the mask with either number in the range (the relevant part is where they\\'re all the same, so it doesn\\'t matter which one).\\n\\nCode:\\n```\\nvar rangeBitwiseAnd = function(left, right) {\\n  return left & (~0 << (32 - Math.clz32(left ^ right)))\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rangeBitwiseAnd = function(left, right) {\\n  return left & (~0 << (32 - Math.clz32(left ^ right)))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514420,
                "title": "python-solution-explained",
                "content": "It\\'s clear that a naive loop or map ANDing all the numbers in the range is inefficient and unnecessary.\\n\\nFor AND to return 1 for a particular bit in a range of numbers that bit has to be set for every number in said range. Which leads to the observation that only bits that are 1 in both left and right can possibly be 1 in our answer.\\n\\nso possible_bits = left & right gets us part way to the solution.\\n\\nNow we only have to consider bits that flip as you increment left to get to right.\\n\\nThe least significant bit can only ever be 1 in a \"range\" of 1 number. It will flip if you increment just once. Similarly the 2nd bit can only be 1 in a range of 2 numbers, ending ...bbb10 and ...bbb11. Another increment and we end ...bb100 flipping the 2nd bit...and so on.\\n\\nSo we can create a mask as the logical NOT of 1 less than the next power of 2 of the length of the range, and use it to mask out the least significant bits in our possible_bits. e.g if our range is 5, the mask is bbbb11111000. \\n\\n```\\n   def nextPowerOf2(n):\\n        n -= 1\\n        n |= n >> 1\\n        n |= n >> 2\\n        n |= n >> 4\\n        n |= n >> 8\\n        n |= n >> 16\\n        n += 1\\n        return n\\n    mask = ~(nextPowerOf2(right - left + 1) - 1)\\n    possible_bits = left & right\\n    return possible_bits & mask\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n   def nextPowerOf2(n):\\n        n -= 1\\n        n |= n >> 1\\n        n |= n >> 2\\n        n |= n >> 4\\n        n |= n >> 8\\n        n |= n >> 16\\n        n += 1\\n        return n\\n    mask = ~(nextPowerOf2(right - left + 1) - 1)\\n    possible_bits = left & right\\n    return possible_bits & mask\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1514194,
                "title": "c-simple-solution-one-line-0ms-faster-than-100-with-explanation",
                "content": "when we list the range from left to right, we can find that when a binary number is carried, the number after this number will be 0.\\nlike 0011 to 0100, the number behind 01 become 00 -> 0100.\\n```\\n0001\\n0010\\n0011\\n0100\\n0101\\n0110\\n0111\\n1000\\n```\\nif we know the leftmost carried number, the number behind the leftmost carried number will be 0 too.\\nAnd we know that the number before the leftmost carried number will not change.\\nSo the answer has to be:\\n1. the number behind the leftmost carried number will be 0.\\n2. the number before the leftmost carried number will not change.\\n\\n\\nThen how to find out the leftmost carried number?\\nwe know that the carried number between the left and right is differnt.\\nfor example [5,7]\\n![image](https://assets.leetcode.com/users/images/d50b3000-04e5-43b3-91ef-3f70568bc353_1633869900.7822227.png)\\nthen we just need to use right(111) to & 100 (the number behind the leftmost carried number is 0)\\n111 & 100 = 100\\n\\nAnother Example: 38(100110) -> 45(101101)\\n![image](https://assets.leetcode.com/users/images/1a79db5c-e2a4-48a0-85f9-14b2fc98c5d6_1633870763.4848013.png)\\nthen 32(100000) is the answer we want.\\nHow can we find the leftmost carried number, and turn the number behind the leftmost carried number into 0?\\nwe know that the number before the leftmost carried number will not change. \\nWhy don\\'t we turn every rightmost 1 into 0 and check if the rest of the numbers are the same?\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        for(; left < right; right -= right & -right);\\n\\t\\treturn right;\\n    }\\n};\\n```\\nwe can use expression (x & -x) to find out the rightmost 1.\\n\\nCan we find out leftmost carried numebr without using loop?\\nyes we can. we know that carried number is different in binary numbers.\\nWe can use left ^ right to get every different number, and the leftmost 1 is the leftmost carried number.\\nthen 1 << (int)log2(left ^ right) is the leftmost carried number we want.\\n\\nhow can we use this number to turn the number behind into 0, and keep the other number the same?\\nwe can use -1 ^ ((1 << (int)log2(left ^ right)) - 1)) to do that.\\nfor example [38, 45]\\nleft ^ right = 11 (001011)\\n1 << (int)log2(left ^ right) = 8 (001000)\\n-1 ^ ((1 << (int)log2(left ^ right)) - 1)) = (111000)\\n1 & no matter 1 or 0 is to be the same.\\nso we use 1 to keep the number before the leftmost carried number the same.\\nright 45(101101) & (111000) = 101000\\nwe also need to change the leftmost number into 0.\\nso we use left 38(100110) & 101000 = 100000\\nthen we get the answer.\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        return left & right & (left == right? -1 : -1 ^ ((1 << (int)log2(left ^ right)) - 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n0001\\n0010\\n0011\\n0100\\n0101\\n0110\\n0111\\n1000\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        for(; left < right; right -= right & -right);\\n\\t\\treturn right;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        return left & right & (left == right? -1 : -1 ^ ((1 << (int)log2(left ^ right)) - 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513163,
                "title": "c-match-prefix",
                "content": "**Intuition**\\nSummarizing the problem, we\\'d like to calculate the below:\\n`rangeAnd(left, right) = left & left + 1 & ... & right - 1 & right`\\nin a smarter fashion. \\n\\nThe main trick to this problem is the observation that only the common most signficant bits between the left and right ranges are preserved when performing an `AND` operation between all values in the range `[left, right]`. \\n\\nTo see why this is the case, we can supposing that the numbers do indeed differ at some intermediate bit, with `left < right`. This will result in something like:\\n```\\nleft:  0 0 ... 1 x0 x1 ... xp-1 xp 0 y y ... y y\\nright: 0 0 ... 1 x0 x1 ... xp-1 xp 1 y y ... y y\\n```\\n\\nwhere the `1 x0 x1 ... xp-1 xp` headers align in `left` and `right`. Notice that because we include all numbers within `[left, right]`, we know that the number `mid` exists in the range, which will effectively clear out the rightmost range:\\n```\\nleft:  0 0 ... 1 x0 x1 ... xp-1 xp 0 y y ... y y\\nright: 0 0 ... 1 x0 x1 ... xp-1 xp 1 y y ... y y\\nmid:   0 0 ... 1 x0 x1 ... xp-1 xp 1 0 0 ... 0 0\\n```\\n\\nFurthermore, the `0` and `1` mismatch between `left` and `right` implies that this position will be cleared after performing all `AND` operations, due to the contribution of `left`. Therefore, the expected `AND` of all numbers in `[left, right]` and be summarized by:\\n```\\nrangeAnd(left, right) = left & mid & right = longest matching prefix of left and right\\n```\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    /***\\n     * Return the bitwise and of all numbers from left to right inclusive\\n     * Key: Suppose left is something like:\\n     * 00001xxxxx\\n     * and right is something larger, so it\\'s:\\n     * yxxxxxxxxx\\n     * \\n     * Off the rip we know the largest bit of left to largest bit of right should be zeroed out\\n     * Ex:\\n     * left = 7 = 0111\\n     * right= 9 = 1001\\n     * Because 8 = 1000 falls in between all three bits will end up being cleared...\\n     * Optimal: just get the longest prefix chain of 1s that are common between left and right\\n     ***/\\n    int rangeBitwiseAnd(int left, int right) {\\n        if(left > right) {\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        for(\\n            int bit = 0, lMSB = getMsb(left), rMSB = getMsb(right);\\n            (bit = (lMSB & left)) == (rMSB & right) && lMSB != 0;  // prefix matches and haven\\'t exhausted both\\n            res |= bit, lMSB >>= 1, rMSB >>= 1                     // extend result, extract next msb\\n        );\\n        \\n        return res;\\n    }\\n    \\n    /***\\n     * Given a 32-bit integer x get its most significant bit only\\n     * Ex: x = 0000 0000 0000 0000 0000 1xxx xxxx xxxx\\n             =>0000 0000 0000 0000 0000 1000 0000 0000\\n     ***/\\n    int getMsb(int x) {\\n        if(x == 0) {\\n            return 0;\\n        }\\n        \\n        int res = 0x01; // figure out where to put the singleton 1\\n        if(x & 0xFFFF0000) { // check top 16 bits of 32-bit number; if any bit is set within this range, adjust\\n            x >>= 16;\\n            res <<= 16;\\n        }\\n        \\n        if(x & 0x0000FF00) { // check top 8 bits of 16-bit number\\n            x >>= 8;\\n            res <<= 8;\\n        }\\n        \\n        if(x & 0x000000F0) { // check top 4 bits of 8 bit number\\n            x >>= 4;\\n            res <<= 4;\\n        }\\n        \\n        if(x & 0x0000000c) { // check top 2 bits of 4 bit number \\n            x >>= 2;\\n            res <<= 2;\\n        }\\n        \\n        if(x & 0x00000002) {\\n            x >>= 1;\\n            res <<= 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nleft:  0 0 ... 1 x0 x1 ... xp-1 xp 0 y y ... y y\\nright: 0 0 ... 1 x0 x1 ... xp-1 xp 1 y y ... y y\\n```\n```\\nleft:  0 0 ... 1 x0 x1 ... xp-1 xp 0 y y ... y y\\nright: 0 0 ... 1 x0 x1 ... xp-1 xp 1 y y ... y y\\nmid:   0 0 ... 1 x0 x1 ... xp-1 xp 1 0 0 ... 0 0\\n```\n```\\nrangeAnd(left, right) = left & mid & right = longest matching prefix of left and right\\n```\n```\\nclass Solution {\\npublic:\\n    /***\\n     * Return the bitwise and of all numbers from left to right inclusive\\n     * Key: Suppose left is something like:\\n     * 00001xxxxx\\n     * and right is something larger, so it\\'s:\\n     * yxxxxxxxxx\\n     * \\n     * Off the rip we know the largest bit of left to largest bit of right should be zeroed out\\n     * Ex:\\n     * left = 7 = 0111\\n     * right= 9 = 1001\\n     * Because 8 = 1000 falls in between all three bits will end up being cleared...\\n     * Optimal: just get the longest prefix chain of 1s that are common between left and right\\n     ***/\\n    int rangeBitwiseAnd(int left, int right) {\\n        if(left > right) {\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        for(\\n            int bit = 0, lMSB = getMsb(left), rMSB = getMsb(right);\\n            (bit = (lMSB & left)) == (rMSB & right) && lMSB != 0;  // prefix matches and haven\\'t exhausted both\\n            res |= bit, lMSB >>= 1, rMSB >>= 1                     // extend result, extract next msb\\n        );\\n        \\n        return res;\\n    }\\n    \\n    /***\\n     * Given a 32-bit integer x get its most significant bit only\\n     * Ex: x = 0000 0000 0000 0000 0000 1xxx xxxx xxxx\\n             =>0000 0000 0000 0000 0000 1000 0000 0000\\n     ***/\\n    int getMsb(int x) {\\n        if(x == 0) {\\n            return 0;\\n        }\\n        \\n        int res = 0x01; // figure out where to put the singleton 1\\n        if(x & 0xFFFF0000) { // check top 16 bits of 32-bit number; if any bit is set within this range, adjust\\n            x >>= 16;\\n            res <<= 16;\\n        }\\n        \\n        if(x & 0x0000FF00) { // check top 8 bits of 16-bit number\\n            x >>= 8;\\n            res <<= 8;\\n        }\\n        \\n        if(x & 0x000000F0) { // check top 4 bits of 8 bit number\\n            x >>= 4;\\n            res <<= 4;\\n        }\\n        \\n        if(x & 0x0000000c) { // check top 2 bits of 4 bit number \\n            x >>= 2;\\n            res <<= 2;\\n        }\\n        \\n        if(x & 0x00000002) {\\n            x >>= 1;\\n            res <<= 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498764,
                "title": "python-if-the-range-contains-any-number-which-is-a-power-of-2-then-the-answer-will-always-be-0",
                "content": "```\\n# if there is a power of 2 in the range then the answer will always be zero due to the fact that ((2^n&((2^n)-1)) = 0)\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        # this is to check if there is a power of 2 in the range\\n        if left*2 <= right:\\n            return 0\\n        result = left\\n        for i in range(left+1,right+1):\\n            result = result&i\\n        return result;\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# if there is a power of 2 in the range then the answer will always be zero due to the fact that ((2^n&((2^n)-1)) = 0)\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        # this is to check if there is a power of 2 in the range\\n        if left*2 <= right:\\n            return 0\\n        result = left\\n        for i in range(left+1,right+1):\\n            result = result&i\\n        return result;\\n",
                "codeTag": "Java"
            },
            {
                "id": 1391827,
                "title": "bitwise-and-of-numbers-range-c-solution-constant-space-and-constant-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n     \\n        int count = 0;\\n        while(left != right){\\n            left >>= 1;\\n            right >>= 1;\\n            count++;\\n        }\\n        \\n        int ans = left<<count;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n     \\n        int count = 0;\\n        while(left != right){\\n            left >>= 1;\\n            right >>= 1;\\n            count++;\\n        }\\n        \\n        int ans = left<<count;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241050,
                "title": "python-faster-than-98",
                "content": "\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        shift = 0\\n        #find the common left header (or, same prefix) of left and right\\n        while left != right:\\n            left >>= 1 #shift to right by 1 bit\\n            right >>= 1\\n            shift += 1\\n        #then shift back to left to form the final result\\n        #(the remaining bits are not the same, so definitely result in 0 after AND)\\n        return left << shift",
                "solutionTags": [],
                "code": "\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        shift = 0\\n        #find the common left header (or, same prefix) of left and right\\n        while left != right:\\n            left >>= 1 #shift to right by 1 bit\\n            right >>= 1\\n            shift += 1\\n        #then shift back to left to form the final result\\n        #(the remaining bits are not the same, so definitely result in 0 after AND)\\n        return left << shift",
                "codeTag": "Python3"
            },
            {
                "id": 1227393,
                "title": "c-if-condition-and-one-for-loop-simple-observation",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n    long long int res=left; \\n    if(left==right)\\n        return left;\\n        \\n    if(  int( log2(right) ) !=  int( log2(left) ) )\\n            return 0;\\n        \\n    for(long long int i=left+1;i<=right;i++)\\n         res=res&i;\\n        \\n     return res;\\n    }\\n};\\n```\\n\\nSimple Observation is\\n if(  int( log2(right) ) !=  int( log2(left) ) )\\n            return 0;\\n\\n4    100\\n5    101\\n6    110\\n7    111\\n---------\\n8   1000\\n\\nso from number 4 to 7  (all having their integral log base 2 value same))\\nso any range between [ 4 , 7 ] will never be zero over AND Operation. and we can find answer by iterating from left to right.\\n\\nBut as soon as you add 8 in the range AND of all elements is zero.\\nie. say left= 5 and right=8 \\nlog2(left) =2 and log2(right)=3   not equal.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n    long long int res=left; \\n    if(left==right)\\n        return left;\\n        \\n    if(  int( log2(right) ) !=  int( log2(left) ) )\\n            return 0;\\n        \\n    for(long long int i=left+1;i<=right;i++)\\n         res=res&i;\\n        \\n     return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905732,
                "title": "python-3-faster-than-94-less-space-than-100",
                "content": "Explanation:\\n1. If bit m[i] == 0 or n[i] == 0 -> res[i] == 0\\n2. Therefor we need to deal only with cases of m[i] == n[i] == 1, and check whether in range m-n bit i == 0.\\n3. bit i will change from 1 to 0 if n - m is more or equal to pow(2, i)\\n4. (if bit i changed from 1 to 0 with n -m < pow(2, i) - that means n[i] == 0 and its covered in #1)\\n5. the result is  m & n (#1) & mask_that_holds_0_for_bits_that_change\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        diff = n - m\\n        mask = 9223372036854775807  # sys.maxsize\\n        for i in range(0, 32):\\n            curr = 1 << i           # pow(2, i)\\n            if diff >= curr:        # somewhere in range m - n bit i will be 0, if m[i] == 1\\n                mask = mask ^ curr  #  set bit i to 0\\n            else:\\n                break\\n            \\n        return m & mask & n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        diff = n - m\\n        mask = 9223372036854775807  # sys.maxsize\\n        for i in range(0, 32):\\n            curr = 1 << i           # pow(2, i)\\n            if diff >= curr:        # somewhere in range m - n bit i will be 0, if m[i] == 1\\n                mask = mask ^ curr  #  set bit i to 0\\n            else:\\n                break\\n            \\n        return m & mask & n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873267,
                "title": "java-vary-easy-understanding-solution",
                "content": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        // m <= n so,\\n        // m = xxxx0____\\n        // n = xxxx1____ because \\n        // xxxx01.111 >= m and\\n        // xxxx10.000 <= n \\n        // xxxx01.111, and xxxx10.000 are between m and n, and their AND result is 0\\n        // so we only need to find the first bit where m and differs. \\n        int ans = 0;\\n        for (int i = 30; i >= 0; i--) {\\n            if ( (m >> i & 1) != (n >> i & 1) ) {\\n                break;\\n            } else {\\n                if( (m >> i & 1) == 1 ){\\n                    ans += 1 << i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        // m <= n so,\\n        // m = xxxx0____\\n        // n = xxxx1____ because \\n        // xxxx01.111 >= m and\\n        // xxxx10.000 <= n \\n        // xxxx01.111, and xxxx10.000 are between m and n, and their AND result is 0\\n        // so we only need to find the first bit where m and differs. \\n        int ans = 0;\\n        for (int i = 30; i >= 0; i--) {\\n            if ( (m >> i & 1) != (n >> i & 1) ) {\\n                break;\\n            } else {\\n                if( (m >> i & 1) == 1 ){\\n                    ans += 1 << i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729023,
                "title": "simple-c-explaination",
                "content": "Consider the binary represenations of numbers. If count from LSB to MSB and start our indexing with 0.\\n\\n0 => 0000\\n1 => 0001\\n2 => 0010\\n3 => 0011\\n4 => 0100\\n5 => 0101\\n6 => 0110\\n7 => 0111\\n8 => 1000\\n9 => 1001\\n\\nWe can clearly see that,\\n0th bit flips after every 1 number.\\n1th bit flips after every 2 number.\\n2nd bit flips after every 4 number.\\nSimilarly, kth bit flips after every 2^k number. We find that for kth bit to be 1 ,m/powerof2 should be equal to n/powerof2 and both should be odd ( I found it from above pattern).\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int power,sum=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            power=1<<i;\\n            if((m/power)==0)\\n                break;\\n            if((m/power)%2==1 && (m/power)==(n/power))\\n                sum+=power;\\n        }\\n        return sum;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int power,sum=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            power=1<<i;\\n            if((m/power)==0)\\n                break;\\n            if((m/power)%2==1 && (m/power)==(n/power))\\n                sum+=power;\\n        }\\n        return sum;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 717678,
                "title": "c-easy-solution-with-photo-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/13d7af5d-5937-47fb-b144-97bd2d0a34e6_1593773814.6153946.png)\\n\\n```\\nint rangeBitwiseAnd(int m, int n) {\\n        int placeCounter = 0;\\n        while (m != n) {\\n            m = m >> 1;\\n            n = n >> 1;\\n            ++placeCounter;\\n        }\\n        return m << placeCounter;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint rangeBitwiseAnd(int m, int n) {\\n        int placeCounter = 0;\\n        while (m != n) {\\n            m = m >> 1;\\n            n = n >> 1;\\n            ++placeCounter;\\n        }\\n        return m << placeCounter;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696270,
                "title": "alternative-python-solution-with-explanation",
                "content": "The way I approach this is to first find the AND of the binary representations of m & n.\\n\\nLet i be the most significant bit of the result that is a 1.\\n\\nSuppose we AND this result with every number between m & n.\\n\\nNotice that none of the resulting bits can change from 0 to 1.\\n\\nHowever, a bit might change from 1 to 0.\\n\\nFor instance, suppose the bit representing 4 is originally a 1 in the result.\\n\\nThat means it\\'s a 1 in both m and n.\\n\\nIt can become a 0 only if one of the numbers between m and n have a 0 for this bit.\\n\\nThis can only happen if m and n have a difference of at least 4.\\n\\nSo after computing AND of m & n, we simply need to determine which resulting bit we should change from 1 to 0 based on the difference n-m.\\n```\\nclass Solution(object):\\n    def rangeBitwiseAnd(self, m, n):\\n        result = m&n\\n        diff = n-m\\n        bit = 1\\n        while bit <= diff:\\n            result &= ~bit\\n            bit *= 2\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rangeBitwiseAnd(self, m, n):\\n        result = m&n\\n        diff = n-m\\n        bit = 1\\n        while bit <= diff:\\n            result &= ~bit\\n            bit *= 2\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638403,
                "title": "c-bit-operations-with-explanaion",
                "content": "/* The idea is very simple:\\n\\nlast bit of (odd number & even number) is 0.\\nwhen m != n, There is at least an odd number and an even number, so the last bit position result is 0.\\nMove m and n rigth a position.\\nKeep doing step 1,2,3 until m equal to n, use a factor to record the iteration time.\\n*/\\n\\npublic class Solution {\\n    public int RangeBitwiseAnd(int m, int n) {\\n        int shift = 0;\\n        while( m < n){\\n            m >>= 1;\\n            n >>= 1;\\n            shift++;\\n        }\\n        return m << shift;\\n            \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int RangeBitwiseAnd(int m, int n) {\\n        int shift = 0;\\n        while( m < n){\\n            m >>= 1;\\n            n >>= 1;\\n            shift++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 630905,
                "title": "easy-to-understand-solution-pigeonhole-principle-intuition",
                "content": "Notice that the k\\'th bit flips every 2^k numbers\\nConsider k=2\\nwe have 0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000\\nThe 2nd bit was unset 0-3, set from 4-7, unset 8-11, and will be set again 12-15, changing every 4 numbers\\nSo if the difference between m and n is greater than 4, we know that there must be at least one number such that the 2nd bit is unset\\nOtherwise, we must check both the k\\'th bit in m and the k\\'th bit in n to see if it was unset in either one\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        bitset<31>res(INT_MAX),x(m),y(n);\\n        for(int i=0;i<32;++i){\\n            if(n-m>(1<<i) || x[i]==0 || y[i]==0)res[i]=0;\\n        }   \\n        return (int)(res.to_ulong());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        bitset<31>res(INT_MAX),x(m),y(n);\\n        for(int i=0;i<32;++i){\\n            if(n-m>(1<<i) || x[i]==0 || y[i]==0)res[i]=0;\\n        }   \\n        return (int)(res.to_ulong());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615660,
                "title": "another-way-of-looking-at-solution-3",
                "content": "You might find it easier to understand the third solution by switching the while condition as follows:\\n\\n```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        while ((m & n) != n) {\\n            n &= n - 1;\\n        }\\n        return n;\\n    }\\n}\\n```\\n\\nThe idea is that we keep turning off the least significant bit set to 1 in `n` until `m & n` is equal to `n`.\\n\\n* When `m & n` is equal to `n`, we will have found the longest common prefix between `m` and `n`, and it will be `n`.\\n* If there is no such common prefix, `n` will eventually be 0, causing the loop to termiate and the function to return `0`.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        while ((m & n) != n) {\\n            n &= n - 1;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595031,
                "title": "c-solution-with-explaination",
                "content": "The bruteforce solution to this problem would be to initialize x=1 and & x from m to n.\\nWhile this is efficient we can do better using some bit logic.\\nLets take two nubers\\n**m = 1000010010110\\nn = 1000101011011**\\nso this is the range givven to us.\\nWe kniw that even one 0 is present it can  make the whole result 0.\\nAs this is a range given here in m and n whatever it is the first 4 digits from the left will be the same \\nwhatsoever ans the rest will be 0s as there will be atleast 1 0.\\nSo we can leverage this fact and decrease our original complexity to logarithmic.\\nwe rightshift m and n unti they are equal and right shift if by the sam amount as the above logic mentioned\\nall the other eements will be 0.\\n```\\n    int rangeBitwiseAnd(int m, int n) {\\n        int i=0;\\n        while(m!=n)\\n        {\\n            m>>=1;\\n            n>>=1;\\n            i++;\\n        }\\n        return m<<i;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int rangeBitwiseAnd(int m, int n) {\\n        int i=0;\\n        while(m!=n)\\n        {\\n            m>>=1;\\n            n>>=1;\\n            i++;\\n        }\\n        return m<<i;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594704,
                "title": "2-java-solution-from-brute-force-to-constant-time-with-explaination",
                "content": "# Approach 1->\\nbasic approach is to loop from m to n and keep on doing bitwise &. But it takes o(n) time.\\n```\\npublic int rangeBitwiseAnd(int left, int right) {\\n    if(left==right) {\\n        return left;\\n    }\\n    int res = left;\\n    for (int i = left + 1; i < right; i++) {\\n        if (res == 0) {\\n            return 0;\\n        }\\n        res = res & i;\\n    }\\n    return res & right;\\n}\\n```\\n# Approach 2-> using some bits observation. \\n1.We can do it faster just by observing some property of bit.\\n3.\\tright shift by 1 will remove last digit from binary representation of number\\n4.\\tleft shift by 1 will add 0 after last digit in binary representation of number\\n5.\\t**Example 1**-> Suppose m=16 and n=19 ->\\nM=10000\\nN =10011\\nNumbers are \\u2013 \\n10000\\n10001\\n10010\\n10011 \\nResult =        10000\\nIt is clear that if we go from left to right (i.e. from MSB to LSB) for m and n only. The common digits will be in the result and remaining digit will be zero in result.\\n10000 and 10011 has 100 common and after that we have two digits left so we append two 0 at end. So result will be 10000.\\n**Example 2**->\\nm = 00110\\nn = 11111\\nhere there is no common digit from left to right. hence answer will be 0\\n**Example 3**->\\nm = 110001\\nn = 111011\\nhere common digit is 11. hence answer will be 110000\\n6.\\tSo, now problem is to find common digits from left to right. We can do it by performing right shift of m and n till m and n are same. And keep counter to count number of shift done.\\nSo, we get 100 whose decimal value is 4 and now if we do left shift of this 4 by count number of times. We get the result. As left shift will append zero to result count number of times.\\n\\nMaximum time below while loop will run is 32. which is fixed irrepective how range will grow.\\nhence time complexity is constant.\\n```\\npublic int rangeBitwiseAnd(int m, int n) {\\n        int c=0;\\n        while(m!=n){\\n            m=m>>1;\\n            n=n>>1;\\n            c++;\\n        }\\n        return m<<c;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int rangeBitwiseAnd(int left, int right) {\\n    if(left==right) {\\n        return left;\\n    }\\n    int res = left;\\n    for (int i = left + 1; i < right; i++) {\\n        if (res == 0) {\\n            return 0;\\n        }\\n        res = res & i;\\n    }\\n    return res & right;\\n}\\n```\n```\\npublic int rangeBitwiseAnd(int m, int n) {\\n        int c=0;\\n        while(m!=n){\\n            m=m>>1;\\n            n=n>>1;\\n            c++;\\n        }\\n        return m<<c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594522,
                "title": "solution-in-java-beats-100",
                "content": "Goal is to get the MSB of both m and n, we keep shifting m and n to the **RIGHT** until they are same and keep a track how many times we shifted the integers. Then shift either m or n to the **LEFT** by counter times.\\n\\nm = 18 (10010) base 2\\nn = 20  (10100) base 2\\n\\nBackground Info: \\n**1**0010 AND **1**0100 = **1**0000\\n\\nThe answer of the AND operation also seems to be our MSB. \\n\\n**Control Flow of the Logic:** \\n\\nm >> 1 = 01001\\nn  >> 1 = 01010\\ncount++\\n\\nm >> 1 = 00100\\nn  >> 1 = 00101\\ncount++\\n\\nm >> 1 = 00100\\nn  >> 1 = 00010\\ncount++\\n\\nanswer = m << count = 10010 << 3 = 10000\\n\\n```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        while (m != n) {\\n            m = m >> 1;\\n            n = n >> 1;\\n            count++;\\n        }\\n        return m << count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        while (m != n) {\\n            m = m >> 1;\\n            n = n >> 1;\\n            count++;\\n        }\\n        return m << count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594336,
                "title": "easy-bitwise-operation-o-1-explained",
                "content": "##### So the idea is that when any bit flips for a given position in [M,N] then entire column & val =0\\n##### We simply do the right shifting till we get a common leftmost bit. And then copy the remaining bits by zero.\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        \\n        int count=0;\\n        \\n        while(m!=n){\\n            m>>=1;\\n            n>>=1;\\n            count++;\\n        }\\n        return m<<=count;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        \\n        int count=0;\\n        \\n        while(m!=n){\\n            m>>=1;\\n            n>>=1;\\n            count++;\\n        }\\n        return m<<=count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593872,
                "title": "find-longest-common-prefix-with-straightforward-bit-operation-simulation",
                "content": "# [subject] find longest common prefix with straightforward bit operation simulation\\n\\nThe hardest part of this problem is to find the regular pattern.\\nLet\\'s begin with two cases:\\n\\nCase 1:(We assume the least significant bit(LSB) is in right end, most significant bit(MSB) is in left end)\\nFor example, for number 5 to 7\\nTheir binary form are:\\n**1**01\\n**1**10\\n**1**11\\nExpected result: \\n100\\nThat is: 4 in decimal format.\\nNote, the longest common prefix is:  the first bit in the left\\n\\nCase 2:\\nFor example, for number 26 to 30\\nTheir binary form are:\\n**11**010\\n**11**011\\n**11**100\\u3000\\u3000\\n**11**101\\u3000\\u3000\\n**11**110\\nExpected result: \\n11000\\nThat is : 24 in decimal format.\\nNote, the longest common prefix is:  the first two bits in the left\\n\\nObservation:\\nBecause we are trying to find bitwise AND, so if any bit there are at least one 0 and one 1, it always 0. In this case, it is 100, and 11000, respectively.\\nSo we are go to cut all these bit that they are different. In this case we cut the right 2 and 3 bit, respetively.\\n\\nI think after understand this, the code is trivial:\\nTalk is cheap, let\\u2019s code:\\n\\n ```\\nclass Solution {// Best: Bit operation simulation\\npublic://Time/Space complexity: O(logn); O(1)\\n    int rangeBitwiseAnd(int m, int n) {\\n        while (m < n)\\n            n &= (n-1); //Note1\\n        // while(m < n) n -= n & (-n); // also okay\\n        return n; // once here,  m == n must be true, so we can return either m or n\\n    }\\n};\\n/*\\nNote1: \\nEverty time, we only check bigest two numbers: n, n-1\\nIt can disclose higher and higher significant 0\\n*/\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n      int i = 0; // i means how many bits are 0 on the right\\n      while(m != n){\\n        m >>= 1;\\n        n >>= 1;\\n        i++;  \\n      }  \\n      return m << i;  \\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic: //Time/Space complexity: O(logn); O(logn)\\n    int rangeBitwiseAnd(int m, int n) {\\n        return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;        \\n    }\\n};\\n```\\n\\nP.S.\\nCase 3:\\nFor example, for number 10 to 11\\nTheir binary form are:\\n**101**0\\n**101**1\\nExpected result: \\n**101**0\\nThat is: 10 in decimal format.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {// Best: Bit operation simulation\\npublic://Time/Space complexity: O(logn); O(1)\\n    int rangeBitwiseAnd(int m, int n) {\\n        while (m < n)\\n            n &= (n-1); //Note1\\n        // while(m < n) n -= n & (-n); // also okay\\n        return n; // once here,  m == n must be true, so we can return either m or n\\n    }\\n};\\n/*\\nNote1: \\nEverty time, we only check bigest two numbers: n, n-1\\nIt can disclose higher and higher significant 0\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n      int i = 0; // i means how many bits are 0 on the right\\n      while(m != n){\\n        m >>= 1;\\n        n >>= 1;\\n        i++;  \\n      }  \\n      return m << i;  \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic: //Time/Space complexity: O(logn); O(logn)\\n    int rangeBitwiseAnd(int m, int n) {\\n        return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593812,
                "title": "c-brute-force",
                "content": "```\\nint rangeBitwiseAnd(int m, int n) {\\n\\tif (m == n)\\n\\t\\treturn m;\\n\\n\\tlong ret = m;\\n\\tfor (long i = m + 1; i <= n; i++) {\\n\\t\\tret &= i;\\n\\t\\tif (ret == 0)\\n\\t\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint rangeBitwiseAnd(int m, int n) {\\n\\tif (m == n)\\n\\t\\treturn m;\\n\\n\\tlong ret = m;\\n\\tfor (long i = m + 1; i <= n; i++) {\\n\\t\\tret &= i;\\n\\t\\tif (ret == 0)\\n\\t\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1814370,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1567464,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1953918,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1569253,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1905888,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1785705,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 2053637,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1951412,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1777966,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1723778,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1814370,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1567464,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1953918,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1569253,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1905888,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1785705,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 2053637,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1951412,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1777966,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1723778,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            }
        ]
    },
    {
        "title": "Valid Palindrome II",
        "question_content": "<p>Given a string <code>s</code>, return <code>true</code> <em>if the </em><code>s</code><em> can be palindrome after deleting <strong>at most one</strong> character from it</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aba&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abca&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> You could delete the character &#39;c&#39;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abc&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 107718,
                "title": "easy-to-understand-python-solution",
                "content": "We can use the standard two-pointer approach that starts at the left and right of the string and move inwards. Whenever there is a mismatch, we can either exclude the character at the left or the right pointer. We then take the two remaining substrings and compare against its reversed and see if either one is a palindrome.\\n\\n**\\uD83D\\uDCAF Check out https://www.techinterviewhandbook.org for more tips and tricks by me to ace your coding interview \\uD83D\\uDCAF**\\n\\n```\\nclass Solution(object):\\n    def validPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(n)\\n        left, right = 0, len(s) - 1\\n        while left < right:\\n            if s[left] != s[right]:\\n                one, two = s[left:right], s[left + 1:right + 1]\\n                return one == one[::-1] or two == two[::-1]\\n            left, right = left + 1, right - 1\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def validPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(n)\\n        left, right = 0, len(s) - 1\\n        while left < right:\\n            if s[left] != s[right]:\\n                one, two = s[left:right], s[left + 1:right + 1]\\n                return one == one[::-1] or two == two[::-1]\\n            left, right = left + 1, right - 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209252,
                "title": "java-python-two-pointers-with-thinking-process",
                "content": ">Assuming `i = 0, j = s.length() - 1;`, `s` is a valid palindrome (as defined in the problem) if \\n- there is **only one** pair of i, j such that `s.charAt(i) != s.charAt(j)`\\nafter the different pair hit, we try removing i or j, the characters in middle should be a palindrome.\\n- there is **no** pair of i, j such that `s.charAt(i) != s.charAt(j)`\\n****\\n**Java**\\n```\\n    public boolean validPalindrome(String s) {\\n        int i = 0, j = s.length() - 1;\\n        \\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);\\n            }\\n            i++;\\n            j--;\\n        }\\n\\n        return true;\\n    }\\n    \\n    /* Check is s[i...j] is palindrome. */\\n    private boolean isPalindrome(String s, int i, int j) {\\n        \\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return true;\\n    }\\n```\\n**Python**\\n```\\n    def validPalindrome(self, s):\\n        i, j = 0, len(s) - 1\\n        \\n        while i < j:\\n            if s[i] == s[j]:\\n                i += 1\\n                j -= 1\\n            else:\\n                return self.validPalindromeUtil(s, i + 1, j) or self.validPalindromeUtil(s, i, j - 1)\\n        return True\\n    \\n    def validPalindromeUtil(self, s, i, j):\\n        while i < j:\\n            if s[i] == s[j]:\\n                i += 1\\n                j -= 1\\n            else:\\n                return False\\n        \\n        return True\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    public boolean validPalindrome(String s) {\\n        int i = 0, j = s.length() - 1;\\n        \\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);\\n            }\\n            i++;\\n            j--;\\n        }\\n\\n        return true;\\n    }\\n    \\n    /* Check is s[i...j] is palindrome. */\\n    private boolean isPalindrome(String s, int i, int j) {\\n        \\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return true;\\n    }\\n```\n```\\n    def validPalindrome(self, s):\\n        i, j = 0, len(s) - 1\\n        \\n        while i < j:\\n            if s[i] == s[j]:\\n                i += 1\\n                j -= 1\\n            else:\\n                return self.validPalindromeUtil(s, i + 1, j) or self.validPalindromeUtil(s, i, j - 1)\\n        return True\\n    \\n    def validPalindromeUtil(self, s, i, j):\\n        while i < j:\\n            if s[i] == s[j]:\\n                i += 1\\n                j -= 1\\n            else:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 107716,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\npublic boolean validPalindrome(String s) {\\n    int l = -1, r = s.length();\\n    while (++l < --r) \\n        if (s.charAt(l) != s.charAt(r)) return isPalindromic(s, l, r+1) || isPalindromic(s, l-1, r);\\n    return true;\\n}\\n\\npublic boolean isPalindromic(String s, int l, int r) {\\n    while (++l < --r) \\n        if (s.charAt(l) != s.charAt(r)) return false;\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean validPalindrome(String s) {\\n    int l = -1, r = s.length();\\n    while (++l < --r) \\n        if (s.charAt(l) != s.charAt(r)) return isPalindromic(s, l, r+1) || isPalindromic(s, l-1, r);\\n    return true;\\n}\\n\\npublic boolean isPalindromic(String s, int l, int r) {\\n    while (++l < --r) \\n        if (s.charAt(l) != s.charAt(r)) return false;\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107720,
                "title": "c-java-python-easy-and-concise",
                "content": "Check from left and right at the same time until the first different pair.\\nNow we have something like ```a****b```, where a and b are different.\\nWe need to delete either ```a``` or ```b``` to make it a palindrome.\\n\\nC++\\n```\\n    bool validPalindrome(string s) {\\n        for (int i = 0, j = s.size() - 1; i < j; i++, j--)\\n            if (s[i] != s[j]) {\\n                int i1 = i, j1 = j - 1, i2 = i + 1, j2 = j;\\n                while (i1 < j1 && s[i1] == s[j1]) {i1++; j1--;};\\n                while (i2 < j2 && s[i2] == s[j2]) {i2++; j2--;};\\n                return i1 >= j1 || i2 >= j2;\\n            }\\n        return true;\\n    }\\n```\\n\\nJava\\n```\\n    public boolean validPalindrome(String s) {\\n        for (int i = 0, j = s.length() - 1; i < j; i++, j--)\\n            if (s.charAt(i) != s.charAt(j)) {\\n                int i1 = i, j1 = j - 1, i2 = i + 1, j2 = j;\\n                while (i1 < j1 && s.charAt(i1) == s.charAt(j1)) {i1++; j1--;};\\n                while (i2 < j2 && s.charAt(i2) == s.charAt(j2)) {i2++; j2--;};\\n                return i1 >= j1 || i2 >= j2;\\n            }\\n        return true;\\n    }\\n```\\nPython\\n`````\\ndef validPalindrome(self, s):\\n        i = 0\\n        while i < len(s) / 2 and s[i] == s[-(i + 1)]: i += 1\\n        s = s[i:len(s) - i]\\n        return s[1:] == s[1:][::-1] or s[:-1] == s[:-1][::-1]",
                "solutionTags": [],
                "code": "```a****b```\n```a```\n```b```\n```\\n    bool validPalindrome(string s) {\\n        for (int i = 0, j = s.size() - 1; i < j; i++, j--)\\n            if (s[i] != s[j]) {\\n                int i1 = i, j1 = j - 1, i2 = i + 1, j2 = j;\\n                while (i1 < j1 && s[i1] == s[j1]) {i1++; j1--;};\\n                while (i2 < j2 && s[i2] == s[j2]) {i2++; j2--;};\\n                return i1 >= j1 || i2 >= j2;\\n            }\\n        return true;\\n    }\\n```\n```\\n    public boolean validPalindrome(String s) {\\n        for (int i = 0, j = s.length() - 1; i < j; i++, j--)\\n            if (s.charAt(i) != s.charAt(j)) {\\n                int i1 = i, j1 = j - 1, i2 = i + 1, j2 = j;\\n                while (i1 < j1 && s.charAt(i1) == s.charAt(j1)) {i1++; j1--;};\\n                while (i2 < j2 && s.charAt(i2) == s.charAt(j2)) {i2++; j2--;};\\n                return i1 >= j1 || i2 >= j2;\\n            }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107751,
                "title": "c-clean-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int lo = 0, hi = s.size() - 1;\\n        return validPalindrome(s, lo, hi, 0);\\n    }\\n    \\n    bool validPalindrome(string& s, int lo, int hi, int count) {\\n        if (count > 1) return false;\\n        while (lo < hi) {\\n            if (s[lo] == s[hi]) {\\n                lo++; hi--;\\n            } else {\\n                return validPalindrome(s, lo + 1, hi, count + 1) || \\n                        validPalindrome(s, lo, hi - 1, count + 1);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int lo = 0, hi = s.size() - 1;\\n        return validPalindrome(s, lo, hi, 0);\\n    }\\n    \\n    bool validPalindrome(string& s, int lo, int hi, int count) {\\n        if (count > 1) return false;\\n        while (lo < hi) {\\n            if (s[lo] == s[hi]) {\\n                lo++; hi--;\\n            } else {\\n                return validPalindrome(s, lo + 1, hi, count + 1) || \\n                        validPalindrome(s, lo, hi - 1, count + 1);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632647,
                "title": "python-readable-and-intuitive-solution-generalizable-to-n-deletes",
                "content": "Simply checking if character at left matches corresponding right until it doesn\\'t. At that point we have a choice of either deleting the left or right character. If either returns Palindrome, we return true. To generalize this to more than one deletes, we can simply replace the flag \"deleted\" to be a counter initialized to how many characters we are allowed to delete and stop allowing for recursive calls when it reaches 0.\\n\\n```\\ndef validPalindrome(self, s: str) -> bool:\\n    def verify(s, left, right, deleted):\\n        while left < right:\\n            if s[left] != s[right]:\\n                if deleted:\\n                    return False\\n                else:\\n                    return verify(s, left+1, right, True) or verify(s, left, right-1, True)\\n            else:\\n                left += 1\\n                right -= 1\\n        return True\\n    return verify(s, 0, len(s)-1, False)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\ndef validPalindrome(self, s: str) -> bool:\\n    def verify(s, left, right, deleted):\\n        while left < right:\\n            if s[left] != s[right]:\\n                if deleted:\\n                    return False\\n                else:\\n                    return verify(s, left+1, right, True) or verify(s, left, right-1, True)\\n            else:\\n                left += 1\\n                right -= 1\\n        return True\\n    return verify(s, 0, len(s)-1, False)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 107717,
                "title": "c-java-clean-code-2-liner-generic-for-you-may-delete-at-most-n-character",
                "content": "**Recursion Compact**\\n```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        return valid(s, 0, s.length() - 1, 1);\\n    }\\n\\nprivate:\\n    bool valid(string& s, int i, int j, int d) { // d: num of chars you can delete at most\\n        return i >= j || (s[i] == s[j] ? valid(s, i + 1, j - 1, d) : d > 0 && (valid(s, i + 1, j, d - 1) || valid(s, i, j - 1, d - 1)));\\n    }\\n};\\n```\\n**Recursion Cozy**\\n```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        return valid(s, 0, s.length() - 1, 1);\\n    }\\n\\nprivate:\\n    bool valid(string& s, int i, int j, int d) { // d: num of chars you can delete at most\\n        if (i >= j) return true;\\n        if (s[i] == s[j])\\n            return valid(s, i + 1, j - 1, d);\\n        else\\n            return d > 0 && (valid(s, i + 1, j, d - 1) || valid(s, i, j - 1, d - 1));\\n    }\\n};\\n```\\n\\n**Iterative - Java**\\n```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        char[] ca = s.toCharArray();\\n        for (int i = 0, j = ca.length - 1; i < j; i++, j--)\\n            if (ca[i] != ca[j]) return isp(ca, i + 1, j) || isp(ca, i, j - 1);\\n        return true;\\n    }\\n\\n    private boolean isp(char[] ca, int l, int r) {\\n        for (int i = l, j = r; i < j; i++, j--)\\n            if (ca[i] != ca[j]) return false;\\n        return true;\\n    }\\n}\\n```\\n**Iterative - C++**\\n```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        for (int i = 0, j = s.size() - 1; i < j; i++, j--)\\n            if (s[i] != s[j]) return isp(s, i + 1, j) || isp(s, i, j - 1);\\n        return true;\\n    }\\n\\nprivate:\\n    bool isp(string s, int l, int r) {\\n        for (int i = l, j = r; i < j; i++, j--)\\n            if (s[i] != s[j]) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        return valid(s, 0, s.length() - 1, 1);\\n    }\\n\\nprivate:\\n    bool valid(string& s, int i, int j, int d) { // d: num of chars you can delete at most\\n        return i >= j || (s[i] == s[j] ? valid(s, i + 1, j - 1, d) : d > 0 && (valid(s, i + 1, j, d - 1) || valid(s, i, j - 1, d - 1)));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        return valid(s, 0, s.length() - 1, 1);\\n    }\\n\\nprivate:\\n    bool valid(string& s, int i, int j, int d) { // d: num of chars you can delete at most\\n        if (i >= j) return true;\\n        if (s[i] == s[j])\\n            return valid(s, i + 1, j - 1, d);\\n        else\\n            return d > 0 && (valid(s, i + 1, j, d - 1) || valid(s, i, j - 1, d - 1));\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        char[] ca = s.toCharArray();\\n        for (int i = 0, j = ca.length - 1; i < j; i++, j--)\\n            if (ca[i] != ca[j]) return isp(ca, i + 1, j) || isp(ca, i, j - 1);\\n        return true;\\n    }\\n\\n    private boolean isp(char[] ca, int l, int r) {\\n        for (int i = l, j = r; i < j; i++, j--)\\n            if (ca[i] != ca[j]) return false;\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        for (int i = 0, j = s.size() - 1; i < j; i++, j--)\\n            if (s[i] != s[j]) return isp(s, i + 1, j) || isp(s, i, j - 1);\\n        return true;\\n    }\\n\\nprivate:\\n    bool isp(string s, int l, int r) {\\n        for (int i = l, j = r; i < j; i++, j--)\\n            if (s[i] != s[j]) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324407,
                "title": "c-solution-two-pointer-approach",
                "content": "**Two Pointer Approach**\\n\\ni is at 0th index;\\nj is at last index \\n\\nwhile checking for i and j pointers if they are equal than just move the pointers. \\nif they aren\\'t equal there could be two cases  i != j\\nif  we delete ith index character check for the i+1 to j are they a palindrome?  if yes than the whole string is palindrome.\\ncase 2: skip jth index character and see if i to j-1 are a palindrome or not \\n\\n\\tTime complexity - O(N) \\n\\tSpace complexity - O(1)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool ispalindrome(string s, int i, int j){\\n        while(i < j){\\n            if(s.at(i) == s.at(j)){\\n                i++;\\n                j--;\\n            }else return false;\\n        }\\n        return true;\\n    }\\n    bool validPalindrome(string s) {\\n        int i  = 0;\\n        int j = s.size()-1;\\n        while(i < j){\\n            if(s.at(i) == s.at(j)){\\n                i++;\\n                j--;\\n            }else{\\n                return ispalindrome(s, i+1, j) || ispalindrome(s, i, j-1);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Please upvote if you like the solution and comment if have doubts**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ispalindrome(string s, int i, int j){\\n        while(i < j){\\n            if(s.at(i) == s.at(j)){\\n                i++;\\n                j--;\\n            }else return false;\\n        }\\n        return true;\\n    }\\n    bool validPalindrome(string s) {\\n        int i  = 0;\\n        int j = s.size()-1;\\n        while(i < j){\\n            if(s.at(i) == s.at(j)){\\n                i++;\\n                j--;\\n            }else{\\n                return ispalindrome(s, i+1, j) || ispalindrome(s, i, j-1);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904942,
                "title": "java-c-awesome-visuall-explanation",
                "content": "How\\'s going Ladies - n - Gentlemen today we are going to solve another coolest problem i.e. **Valid Palindrome II**\\n\\nSo, first of all let\\'s talk about what the palindrome is. According to google,\\n![image](https://assets.leetcode.com/users/images/7cca3579-f336-4e20-81ef-c76928492648_1648863006.3678515.png)\\n\\n**Now let\\'s just talk about Problem Statement:-**\\n```\\nGiven a string s, return true if the s can be palindrome after deleting at most one character from it.\\n```\\n\\nLet\\'s consider on example in order to understand it :-\\n**Input**: s = \"abcdecba\"\\n**Output**: true\\n\\nSo, what I can do is create two pointer\\'s & start comparing them from. \\n* One will start from 0th Index & another will start from last index.\\n* We\\'ll check, if they are equal then continue checking\\n* But if they are undequal we can have 2 cases :-\\n* * Case 1 : Skip e to check whether it\\'s forming an palindrome\\n* * Case 2 : Skip d to check whether it\\'s forming an plaindrome\\n* But still if after deleting one character we are not gettong palindrome **return false**\\n* Otherwise **return true**\\n\\n![image](https://assets.leetcode.com/users/images/620dc518-3c9f-4d32-8cac-71eb6ee91216_1648864228.2340546.gif)\\n\\n*I hope ladies - n - gentlemen, approach is absolute clear.* **Let\\'s code it up**\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        \\n        while(i <= j){\\n            if(s.charAt(i) == s.charAt(j)){\\n                i++;\\n                j--;\\n            }\\n            else return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);\\n        }\\n        return true;\\n    }\\n    public boolean isPalindrome(String s, int i, int j){\\n        while(i <= j){\\n            if(s.charAt(i) == s.charAt(j)){\\n                i++;\\n                j--;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        \\n        while(i <= j){\\n            if(s[i] == s[j]){\\n                i++;\\n                j--;\\n            }\\n            else return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);\\n        }\\n        return true;\\n    }\\n    bool isPalindrome(string s, int i, int j){\\n        while(i <= j){\\n            if(s[i] == s[j]){\\n                i++;\\n                j--;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(1)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nGiven a string s, return true if the s can be palindrome after deleting at most one character from it.\\n```\n```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        \\n        while(i <= j){\\n            if(s.charAt(i) == s.charAt(j)){\\n                i++;\\n                j--;\\n            }\\n            else return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);\\n        }\\n        return true;\\n    }\\n    public boolean isPalindrome(String s, int i, int j){\\n        while(i <= j){\\n            if(s.charAt(i) == s.charAt(j)){\\n                i++;\\n                j--;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        \\n        while(i <= j){\\n            if(s[i] == s[j]){\\n                i++;\\n                j--;\\n            }\\n            else return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);\\n        }\\n        return true;\\n    }\\n    bool isPalindrome(string s, int i, int j){\\n        while(i <= j){\\n            if(s[i] == s[j]){\\n                i++;\\n                j--;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409641,
                "title": "python-3-two-pointer-approach-self-understandable",
                "content": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n            p1=0\\n            p2=len(s)-1\\n            while p1<=p2:\\n                if s[p1]!=s[p2]:\\n                    string1=s[:p1]+s[p1+1:]\\n                    string2=s[:p2]+s[p2+1:]\\n                    return string1==string1[::-1] or string2==string2[::-1]\\n                p1+=1\\n                p2-=1\\n            return True\\n```\\n\\n***Do Upvote If you found my solution helpful :)***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n            p1=0\\n            p2=len(s)-1\\n            while p1<=p2:\\n                if s[p1]!=s[p2]:\\n                    string1=s[:p1]+s[p1+1:]\\n                    string2=s[:p2]+s[p2+1:]\\n                    return string1==string1[::-1] or string2==string2[::-1]\\n                p1+=1\\n                p2-=1\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107714,
                "title": "java-solution-ispalindrome",
                "content": "Follow normal way (two pointers) to check if ```s``` is palindrome. When two chars are not equal, try to skip (pseudo ```delete```) either left one or right one and continue checking.\\n```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int i = 0, j = s.length() - 1;\\n        while (i < j && s.charAt(i) == s.charAt(j)) {\\n            i++; j--;\\n        }\\n\\n        if (i >= j) return true;\\n\\n        if (isPalin(s, i + 1, j) || isPalin(s, i, j - 1)) return true;\\n        return false;\\n    }\\n\\n    private boolean isPalin(String s, int i, int j) {\\n        while (i < j) {\\n            if (s.charAt(i) == s.charAt(j)) {\\n                i++; j--;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```s```\n```delete```\n```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int i = 0, j = s.length() - 1;\\n        while (i < j && s.charAt(i) == s.charAt(j)) {\\n            i++; j--;\\n        }\\n\\n        if (i >= j) return true;\\n\\n        if (isPalin(s, i + 1, j) || isPalin(s, i, j - 1)) return true;\\n        return false;\\n    }\\n\\n    private boolean isPalin(String s, int i, int j) {\\n        while (i < j) {\\n            if (s.charAt(i) == s.charAt(j)) {\\n                i++; j--;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391809,
                "title": "java-solutions-to-valid-palindrome-i-ii-with-explanation-subpalindrome-iteration-recursion",
                "content": "Reference: [125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/) & [680. Valid Palindrome II](https://leetcode.com/problems/valid-palindrome-ii/) <span class=\"gray\">EPI 6.5</span>\\nDifficulty: <span class=\"green\">Easy</span>\\n\\n## Problem\\n\\n> Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\\n\\n**Note:** For the purpose of this problem, we define empty string as valid palindrome.\\n\\n**Example:** \\n\\n```java\\nInput: \"aba\"\\nOutput: True\\n\\nInput: \"race a car\"\\nOutput: false\\n```\\n\\n**Follow up:** Do not use extra space. Also, check out Valid Palindrome II section.\\n\\n\\n## Analysis\\n\\n### Brute-Force\\n\\nThe basic idea is based on the following code:\\n\\n```java\\npublic boolean isPalindrome(String s) {\\n  int n = s.length();\\n  for (int i = 0; i < n / 2; ++i) { // n / 2 is right-leaning\\n    int j = n - i - 1;\\n    if (s.charAt(i) != s.charAt(j)) return false;\\n  }\\n  return true;\\n}\\n```\\n\\nSince the input has some non-alphanumeric characters, we have to do some preprocessing.\\n\\n- Remove invalid characters (`Character.isLetterOrDigit(ch)`).\\n- Convert all letters to lower cases (use `s.toLowerCase()`).\\n- Reversing is optional (it also incurs extra space usage).\\n\\n**Note:**\\n\\n- Since the StringBuilder is resizable, the condition in while-loop is `idx < sb.length()` instead of `idx < n`.\\n- Remember to update the length `n` after preprocessing.\\n\\n\\n```java\\npublic boolean isPalindrome(String s) {\\n  StringBuilder sb = new StringBuilder(s.toLowerCase()); // for later comparisons\\n  int idx = 0;  \\n  // remove non-letter character\\n  while (idx < sb.length()) {\\n    char ch = sb.charAt(idx);\\n    if (Character.isLetterOrDigit(ch)) { // letter or digit\\n      idx += 1;\\n    } else { // not letter\\n      sb.deleteCharAt(idx);\\n    }\\n  }\\n  int n = sb.length(); // update length\\n  // check\\n  for (int i = 0; i < n / 2; ++i) { // right-leaning\\n    int j = n - i - 1;\\n    if (sb.charAt(i) != sb.charAt(j)) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(N)`\\n\\n\\n\\n### Two Pointers\\n\\nWe use two indices (pointers) to traverse the string, one forwards, the other backwards, skipping nonalphanumeric characters, performing case-insensitive comparison on the alphanumeric characters. We return false as soon as there is a mismatch. If the indices cross, we have a verified palindrome string.\\n\\n**Note:** Remember to update `lo` and `hi` at the end of each iteration.\\n\\n```java\\npublic boolean isPalindrome(String s) {\\n  int lo = 0, hi = s.length() - 1;\\n  while (lo < hi) { // if lo >= hi, stops!\\n    // i stops at a letter, or lo == hi\\n    while (lo < hi && !isValid(s.charAt(lo))) lo += 1;\\n    // j stops at a letter, or lo == hi\\n    while (lo < hi && !isValid(s.charAt(hi))) hi -= 1;\\n    // check\\n    if (lo < hi) { // ensure in-bound & letter comparison (because they don\\'t meet yet)\\n      if (isCharDiff(s.charAt(lo), s.charAt(hi))) return false;\\n    }\\n    lo += 1; hi -= 1; // update, remember to move (otherwise it caseus infinite loop)\\n  }\\n  return true;\\n}\\n\\nprivate boolean isValid(char ch) {\\n  return Character.isLetterOrDigit(ch);\\n}\\n\\nprivate boolean isCharDiff(char ch1, char ch2) {\\n  return Character.toLowerCase(ch1) != Character.toLowerCase(ch2);\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`\\n\\n\\n\\n\\n## Valid Palindrome II\\n\\n> Given a non-empty string `s`, you may delete **at most one character**. Judge whether you can make it a palindrome. In other words, we allow one mismatch.\\n\\n**Note:** The string will only contain lowercase characters a-z. The maximum length of the string is 50000.\\n\\n**Example:** \\n\\n```java\\nInput: \"aba\"\\nOutput: True\\n\\nInput: \"abca\"\\nOutput: True (delete \"c\")\\n\\nInput: \"abbbca\"\\nOutput: True (delete \"c\")\\n```\\n\\n\\n### Brute-Force\\n\\nDelete each character and then test palindromicity.\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(1)`\\n\\n\\n### SubPalindrome (Iteration)\\n\\nWhen detecting the first mismatch we should consider two cases:\\n\\n- **Case 1:** Delete the character on the left, and move on.\\n- **Case 2:** Delete the character on the right, and move on.\\n\\nThen we get rid of the characters we have checked before, and only focus on those **substrings** in two cases. If the first case fails, we will try the second case. If it also fails, return `false`.\\n\\nNotice that when a mismatch is detected in for-loop, every future work would be done within the current iteration.\\n\\n```java\\nExample: [a b b b c a]\\ni = left, j = right\\n[a b b b c a]\\n i         j\\n[a b b b c a]\\n   i     j     <-- mismatch\\n\\nCase 1:\\n[a b b b c a]\\n     i   j     <-- now we focus on a substring [b b c] --> fail in case 1\\n\\nCase 2:\\n[a b b b c a]\\n   i   j       <-- now we focus on a substring [b b b] --> succeed in case 2\\n```\\n\\nShow me the code:\\n\\n```java\\n// \"abbbca\"\\npublic boolean validPalindrome(String s) {\\n  int n = s.length();\\n  for (int i = 0; i < n / 2; ++i) {\\n    int left = i, right = n - i - 1;\\n    if (s.charAt(left) != s.charAt(right)) { // give a last chance\\n      // delete char at left\\n      if (validSubPalindrome(s, left + 1, right)) return true;\\n      // delete char at right\\n      return validSubPalindrome(s, left, right - 1);\\n    }\\n  }\\n  return true;\\n}\\n\\nprivate boolean validSubPalindrome(String s, int lo, int hi) {\\n  int n = hi - lo + 1;\\n  for (int i = 0; i < n / 2; ++i) {\\n    int left = lo + i, right = hi - i;\\n    if (s.charAt(left) != s.charAt(right)) return false;\\n  }\\n  return true;\\n}\\n```\\n\\n**Time:** `O(N)` since there are at most `~ 2N` operations.\\n**Space:** `O(1)`\\n\\n\\n\\n### SubPalindrome (Recursion)\\n\\nBased on the idea above, we can write a recursive version.\\n\\n**Note:** You have to pass down a `used` variable to indicate if the remedy has been used.\\n\\n```java\\npublic boolean validPalindrome(String s) {\\n  return validSubPalindrome(s, 0, s.length() - 1, false);\\n}\\n\\nprivate boolean validSubPalindrome(String s, int lo, int hi, boolean used) {\\n  if (lo >= hi) { // base case\\n    return true;\\n  }\\n  \\n  if (s.charAt(lo) != s.charAt(hi)) { // equal\\n    if (used == false) {\\n      if (validSubPalindrome(s, lo + 1, hi, true)) return true; // test left deletion\\n      return validSubPalindrome(s, lo, hi - 1, true); // test right deletion\\n    } else {\\n      return false;\\n    }\\n  }\\n  \\n  return validSubPalindrome(s, lo + 1, hi - 1, used);\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(N)`",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java\\nInput: \"aba\"\\nOutput: True\\n\\nInput: \"race a car\"\\nOutput: false\\n```\n```java\\npublic boolean isPalindrome(String s) {\\n  int n = s.length();\\n  for (int i = 0; i < n / 2; ++i) { // n / 2 is right-leaning\\n    int j = n - i - 1;\\n    if (s.charAt(i) != s.charAt(j)) return false;\\n  }\\n  return true;\\n}\\n```\n```java\\npublic boolean isPalindrome(String s) {\\n  StringBuilder sb = new StringBuilder(s.toLowerCase()); // for later comparisons\\n  int idx = 0;  \\n  // remove non-letter character\\n  while (idx < sb.length()) {\\n    char ch = sb.charAt(idx);\\n    if (Character.isLetterOrDigit(ch)) { // letter or digit\\n      idx += 1;\\n    } else { // not letter\\n      sb.deleteCharAt(idx);\\n    }\\n  }\\n  int n = sb.length(); // update length\\n  // check\\n  for (int i = 0; i < n / 2; ++i) { // right-leaning\\n    int j = n - i - 1;\\n    if (sb.charAt(i) != sb.charAt(j)) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```\n```java\\npublic boolean isPalindrome(String s) {\\n  int lo = 0, hi = s.length() - 1;\\n  while (lo < hi) { // if lo >= hi, stops!\\n    // i stops at a letter, or lo == hi\\n    while (lo < hi && !isValid(s.charAt(lo))) lo += 1;\\n    // j stops at a letter, or lo == hi\\n    while (lo < hi && !isValid(s.charAt(hi))) hi -= 1;\\n    // check\\n    if (lo < hi) { // ensure in-bound & letter comparison (because they don\\'t meet yet)\\n      if (isCharDiff(s.charAt(lo), s.charAt(hi))) return false;\\n    }\\n    lo += 1; hi -= 1; // update, remember to move (otherwise it caseus infinite loop)\\n  }\\n  return true;\\n}\\n\\nprivate boolean isValid(char ch) {\\n  return Character.isLetterOrDigit(ch);\\n}\\n\\nprivate boolean isCharDiff(char ch1, char ch2) {\\n  return Character.toLowerCase(ch1) != Character.toLowerCase(ch2);\\n}\\n```\n```java\\nInput: \"aba\"\\nOutput: True\\n\\nInput: \"abca\"\\nOutput: True (delete \"c\")\\n\\nInput: \"abbbca\"\\nOutput: True (delete \"c\")\\n```\n```java\\nExample: [a b b b c a]\\ni = left, j = right\\n[a b b b c a]\\n i         j\\n[a b b b c a]\\n   i     j     <-- mismatch\\n\\nCase 1:\\n[a b b b c a]\\n     i   j     <-- now we focus on a substring [b b c] --> fail in case 1\\n\\nCase 2:\\n[a b b b c a]\\n   i   j       <-- now we focus on a substring [b b b] --> succeed in case 2\\n```\n```java\\n// \"abbbca\"\\npublic boolean validPalindrome(String s) {\\n  int n = s.length();\\n  for (int i = 0; i < n / 2; ++i) {\\n    int left = i, right = n - i - 1;\\n    if (s.charAt(left) != s.charAt(right)) { // give a last chance\\n      // delete char at left\\n      if (validSubPalindrome(s, left + 1, right)) return true;\\n      // delete char at right\\n      return validSubPalindrome(s, left, right - 1);\\n    }\\n  }\\n  return true;\\n}\\n\\nprivate boolean validSubPalindrome(String s, int lo, int hi) {\\n  int n = hi - lo + 1;\\n  for (int i = 0; i < n / 2; ++i) {\\n    int left = lo + i, right = hi - i;\\n    if (s.charAt(left) != s.charAt(right)) return false;\\n  }\\n  return true;\\n}\\n```\n```java\\npublic boolean validPalindrome(String s) {\\n  return validSubPalindrome(s, 0, s.length() - 1, false);\\n}\\n\\nprivate boolean validSubPalindrome(String s, int lo, int hi, boolean used) {\\n  if (lo >= hi) { // base case\\n    return true;\\n  }\\n  \\n  if (s.charAt(lo) != s.charAt(hi)) { // equal\\n    if (used == false) {\\n      if (validSubPalindrome(s, lo + 1, hi, true)) return true; // test left deletion\\n      return validSubPalindrome(s, lo, hi - 1, true); // test right deletion\\n    } else {\\n      return false;\\n    }\\n  }\\n  \\n  return validSubPalindrome(s, lo + 1, hi - 1, used);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 404606,
                "title": "c-easy-to-understand",
                "content": "```C++\\nbool validPalindrome(string s) {\\n\\tint left = 0, right = s.length() - 1;\\n\\twhile (left < right) {\\n\\t\\tif (s[left] != s[right]) {\\n\\t\\t\\treturn isPalin(s, left + 1, right) || isPalin(s, left, right - 1);\\n\\t\\t}\\n\\t\\tleft++;\\n\\t\\tright--;\\n\\t}\\n\\treturn true;\\n}\\n\\nbool isPalin(string s, int left, int right) {\\n\\twhile (left < right) {\\n\\t\\tif (s[left] != s[right]) return false;\\n\\t\\tleft++;\\n\\t\\tright--;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nbool validPalindrome(string s) {\\n\\tint left = 0, right = s.length() - 1;\\n\\twhile (left < right) {\\n\\t\\tif (s[left] != s[right]) {\\n\\t\\t\\treturn isPalin(s, left + 1, right) || isPalin(s, left, right - 1);\\n\\t\\t}\\n\\t\\tleft++;\\n\\t\\tright--;\\n\\t}\\n\\treturn true;\\n}\\n\\nbool isPalin(string s, int left, int right) {\\n\\twhile (left < right) {\\n\\t\\tif (s[left] != s[right]) return false;\\n\\t\\tleft++;\\n\\t\\tright--;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1904881,
                "title": "c-algorithm-easy-to-understand",
                "content": "# 680. Valid Palindrome II\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. 2 Pointer Approach\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\nJust **similar to yesterday question** here i am **just using a cnt variable which will keep track of unmatched characters.**\\n\\n\\n**ALGORITHM**\\n* **Maintain 2 Pointers** : **Start and End** **pointing to the first** and **last index of the string.**\\n* Now **traverse a while loop until start < end.**\\n\\t* If **char pointed by both pointer is same than,**\\n\\t\\t* **Increment start and Decrement end.**\\n\\t* If **character didn\\'t match** **increment  start** and **end ramins same** and **increase the cnt1, as we are skipping the character from starting.**\\n\\t* **cnt will keep the track of no of instances that didn\\'t match.**\\n* Reinitialise the start and end pointers.\\n* Now **again use a while loop and this time if character not matched decrement end end & start reamains same and incerease cnt2, as we are skipping character from end**\\n* If **cnt or cnt1 is greater than 1 i will break the loop for optimization so that no that no need to compare all string content.**\\n* also **we can skipped only 1 character** therfore **break only when cnt > 1.**\\n* if **cnt1 and cnt2 remains 0** that **means string is already a palindrome**.\\n* if **cnt1 and cnt2 is 1** this **means one character is obstructing the string to be palindrome**, therefore **we will delete that char by skipping it as done in code.**\\n* **skipping start once** and **skipping end once.**\\n* If **cnt1 == cnt2** **remains 0 or 1** then **return true.** \\n* **As deleting of one character will result in a palindrome.**\\n``` ```\\n\\n\\n\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int start = 0;\\n        int end = s.size() - 1;\\n        int cnt = 0;\\n        \\n        while(start < end){\\n            if(s[start] == s[end])\\n            {\\n\\t\\t\\t\\t// if char matches increment start and decrement end\\n                start++;\\n                end--;\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// keeping cnt of character that didn\\'t match\\n                cnt++;\\n               start++;     //skip 1 from starting\\n            }\\n\\t\\t\\t// for optimising code if cnt is greater than 1 \\n            // we will just break the loop as only one char can skipped/deleted.\\n            if(cnt > 1)\\n                break;\\n        }\\n        \\n\\t\\t// reinitialize pointer \\n        start = 0;\\n        end = s.size() - 1;\\n        int cnt1 = 0;\\n        \\n        while(start < end){\\n            if(s[start] == s[end])\\n            {\\n\\t\\t\\t\\t// if char matches increment start and decrement end\\n                start++;\\n                end--;  \\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// keeping cnt of character that didn\\'t match\\n                cnt1++;\\n                end--;  //skip 1 from ending\\n            }\\n\\t\\t\\t// for optimising code if cnt is greater than 1 \\n            // we will just break the loop as only one char can skipped/deleted.\\n            if(cnt1 > 1)\\n                break;\\n               \\n        }\\n        \\n        if(cnt == 1 || cnt1 == 1)   //del atmost one char\\n            return true;\\n        if(cnt == 0 || cnt1 == 0)    //palindrome\\n            return true;\\n        \\n        return false;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. 2 Pointer Approach\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n```\\n\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int start = 0;\\n        int end = s.size() - 1;\\n        int cnt = 0;\\n        \\n        while(start < end){\\n            if(s[start] == s[end])\\n            {\\n\\t\\t\\t\\t// if char matches increment start and decrement end\\n                start++;\\n                end--;\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// keeping cnt of character that didn\\'t match\\n                cnt++;\\n               start++;     //skip 1 from starting\\n            }\\n\\t\\t\\t// for optimising code if cnt is greater than 1 \\n            // we will just break the loop as only one char can skipped/deleted.\\n            if(cnt > 1)\\n                break;\\n        }\\n        \\n\\t\\t// reinitialize pointer \\n        start = 0;\\n        end = s.size() - 1;\\n        int cnt1 = 0;\\n        \\n        while(start < end){\\n            if(s[start] == s[end])\\n            {\\n\\t\\t\\t\\t// if char matches increment start and decrement end\\n                start++;\\n                end--;  \\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// keeping cnt of character that didn\\'t match\\n                cnt1++;\\n                end--;  //skip 1 from ending\\n            }\\n\\t\\t\\t// for optimising code if cnt is greater than 1 \\n            // we will just break the loop as only one char can skipped/deleted.\\n            if(cnt1 > 1)\\n                break;\\n               \\n        }\\n        \\n        if(cnt == 1 || cnt1 == 1)   //del atmost one char\\n            return true;\\n        if(cnt == 0 || cnt1 == 0)    //palindrome\\n            return true;\\n        \\n        return false;\\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245374,
                "title": "c-java-easy-single-method-two-pointers-efficient-explained",
                "content": "<u><strong>ALGORITHM:</strong></u>\\n* Here, we will use **two pointer approach** by taking **firstIndex** and **lastIndex**. \\n* Iterate through the string by **incrementing the leftIndex** and **decrementing the rightIndex.**\\n\\t* If the **two characters on leftIndex and rightIndex are not equal**, then **delete the character(done using isCharacterDeleted = true)**. \\n* Now, iterate through rest of the remaining characters\\n\\t* if **two characters are found which are not equal again**, then **return false** \\n* **return true** after whole iteration of the string.\\n\\n\\n<iframe src=\"https://leetcode.com/playground/8aCzgCWC/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\n<u><strong>COMPLEXITY:</strong></u>\\n* <strong>Time: O(n),</strong> where n is the length of the string\\n* <strong>Space: O(1),</strong> constant time\\n\\n# **Please UPVOTE if you find this solution helpful :)**\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "<u><strong>ALGORITHM:</strong></u>\\n* Here, we will use **two pointer approach** by taking **firstIndex** and **lastIndex**. \\n* Iterate through the string by **incrementing the leftIndex** and **decrementing the rightIndex.**\\n\\t* If the **two characters on leftIndex and rightIndex are not equal**, then **delete the character(done using isCharacterDeleted = true)**. \\n* Now, iterate through rest of the remaining characters\\n\\t* if **two characters are found which are not equal again**, then **return false** \\n* **return true** after whole iteration of the string.\\n\\n\\n<iframe src=\"https://leetcode.com/playground/8aCzgCWC/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\n<u><strong>COMPLEXITY:</strong></u>\\n* <strong>Time: O(n),</strong> where n is the length of the string\\n* <strong>Space: O(1),</strong> constant time\\n\\n# **Please UPVOTE if you find this solution helpful :)**\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 798322,
                "title": "easy-js-solution",
                "content": "```\\n/*\\nSolution:\\n\\n1. Use two pointers, one initialised to 0 and the other initialised to end of string. Check if characters at each index\\nare the same. If they are the same, shrink both pointers. Else, we have two possibilities: one that neglects character\\nat left pointer and the other that neglects character at right pointer. Hence, we check if s[low+1...right] is a palindrome\\nor s[low...right-1] is a palindrome. If one of them is a palindrome, we know that we can form a palindrome with one deletion and return true. Else, we require more than one deletion, and hence we return false.\\n*/\\nvar validPalindrome = function(s) {\\n    let low = 0, high = s.length-1;\\n    while (low < high) {\\n        if (s[low] !== s[high]) {\\n            return isPalindrome(s, low+1, high) || isPalindrome(s, low, high-1);\\n        }\\n        low++, high--;\\n    }\\n    return true;\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n\\nfunction isPalindrome(str, low, high) {\\n    while (low < high) {\\n        if (str[low] !== str[high]) return false;\\n        low++, high--;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nSolution:\\n\\n1. Use two pointers, one initialised to 0 and the other initialised to end of string. Check if characters at each index\\nare the same. If they are the same, shrink both pointers. Else, we have two possibilities: one that neglects character\\nat left pointer and the other that neglects character at right pointer. Hence, we check if s[low+1...right] is a palindrome\\nor s[low...right-1] is a palindrome. If one of them is a palindrome, we know that we can form a palindrome with one deletion and return true. Else, we require more than one deletion, and hence we return false.\\n*/\\nvar validPalindrome = function(s) {\\n    let low = 0, high = s.length-1;\\n    while (low < high) {\\n        if (s[low] !== s[high]) {\\n            return isPalindrome(s, low+1, high) || isPalindrome(s, low, high-1);\\n        }\\n        low++, high--;\\n    }\\n    return true;\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n\\nfunction isPalindrome(str, low, high) {\\n    while (low < high) {\\n        if (str[low] !== str[high]) return false;\\n        low++, high--;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 119188,
                "title": "c-easy-to-understand-clear-explaination",
                "content": "This problem is quite huge if you try to solve using Brute force.\\n\\n**`BRUTE FORCE`**\\nThe most naive approach would be:\\n1) Remove every element once and apply isPalindrome() every time.\\n2) If any time you find that its palindrome then return true\\n3) If you reach end of sting then return false\\n\\nThe worst part for this type of solution is that the string length can be 50000 (see question).\\nSo remove each element means it will run O(50000) and each isPalindrome is O(N) making it O(50000N)\\n\\n**`OPTIMIZED`**\\nJust maintain 2 pointers i.e for start and end of string\\nKeep checking if they are same\\n1) If they are **Same** -  then just check inside and keep going till you reach the center`(left==right)`(if odd string) or `left>right` (if even string)\\n2) If they are **NOT same** : You now have 2 options\\n\\t2.1) `Remove Left Element` and Check for the Rest of String **OR**\\n\\t2.2) `Remove Right Element` and Check for the Rest of the string. \\n\\tIf either of them dont give palindrome then its not a palindorme.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int m = s.size();\\n        if(m<=2) return true;\\n        \\n        // Keep two pointers Left and Right\\n        int L,R;    \\n        L = 0;\\n        R = m-1;\\n        \\n        while(L<=R)\\n        {\\n            //Both first and last element match\\n            if(s[L]==s[R])\\n            {\\n                ++L;--R;\\n            }\\n            \\n            // One of the element is not matching\\n            else \\n            {\\n                //Removing Left\\n                int LL = L+1, LR = R;\\n                while(LL<=LR && s[LL]==s[LR]) {++LL;--LR;}\\n                if(LL>=LR) return true;\\n                \\n                //Removing Right\\n                int RL = L, RR = R-1;\\n                while(RL<=RR && s[RL]==s[RR]) {++RL;--RR;}\\n                if(RL>=RR) return true;\\n\\n                return false;\\n\\n            }\\n \\n        }\\n        \\n        return true; //It was already a Palindrome\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int m = s.size();\\n        if(m<=2) return true;\\n        \\n        // Keep two pointers Left and Right\\n        int L,R;    \\n        L = 0;\\n        R = m-1;\\n        \\n        while(L<=R)\\n        {\\n            //Both first and last element match\\n            if(s[L]==s[R])\\n            {\\n                ++L;--R;\\n            }\\n            \\n            // One of the element is not matching\\n            else \\n            {\\n                //Removing Left\\n                int LL = L+1, LR = R;\\n                while(LL<=LR && s[LL]==s[LR]) {++LL;--LR;}\\n                if(LL>=LR) return true;\\n                \\n                //Removing Right\\n                int RL = L, RR = R-1;\\n                while(RL<=RR && s[RL]==s[RR]) {++RL;--RR;}\\n                if(RL>=RR) return true;\\n\\n                return false;\\n\\n            }\\n \\n        }\\n        \\n        return true; //It was already a Palindrome\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107743,
                "title": "simple-javascript-o-n-solution",
                "content": "```\\nconst validPalindrome = (s) => {\\n    for (let i = 0, stop = s.length / 2; i < stop; i++) {\\n        let j = s.length - i - 1\\n        if (s[i] !== s[j]) {\\n            return isPalindrome(cut(s, i)) || isPalindrome(cut(s, j))\\n        }\\n    }\\n    return true\\n};\\n\\nconst cut = (s, i) => s.substr(0, i) + s.substr(i + 1);\\n\\nconst isPalindrome = (s) => s === s.split('').reverse().join('');\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst validPalindrome = (s) => {\\n    for (let i = 0, stop = s.length / 2; i < stop; i++) {\\n        let j = s.length - i - 1\\n        if (s[i] !== s[j]) {\\n            return isPalindrome(cut(s, i)) || isPalindrome(cut(s, j))\\n        }\\n    }\\n    return true\\n};\\n\\nconst cut = (s, i) => s.substr(0, i) + s.substr(i + 1);\\n\\nconst isPalindrome = (s) => s === s.split('').reverse().join('');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1905341,
                "title": "python-6-lines-simple-o-n-solution-explained",
                "content": "**Please UPVOTE if you LIKE!** \\uD83D\\uDE01\\n\\n\\n```\\nclass Solution(object):\\n    def validPalindrome(self, s):\\n        h, t = 0, len(s) - 1  # head and tail\\n        while h < t:\\n            if s[h] != s[t]:  # delete s[h] or s[t] and validate palindrome finally\\n                 return s[h:t] == s[h:t][::-1] or s[h + 1:t + 1] == s[h + 1:t + 1][::-1]\\n            h, t = h + 1, t - 1\\n        return True\\n```\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def validPalindrome(self, s):\\n        h, t = 0, len(s) - 1  # head and tail\\n        while h < t:\\n            if s[h] != s[t]:  # delete s[h] or s[t] and validate palindrome finally\\n                 return s[h:t] == s[h:t][::-1] or s[h + 1:t + 1] == s[h + 1:t + 1][::-1]\\n            h, t = h + 1, t - 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725877,
                "title": "python-94-65-faster-simplest-solution-with-explanation-beg-to-adv-two-pointer",
                "content": "```python\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        left = 0 # pointer one\\n        right = len(s) - 1 # pointer two\\n        \\n        while left < right: # index should be less then right one, not even equal, as  we dont need to compare same index\\n            if s[left] == s[right]: # if both the ends value are equal.\\n                left += 1 # if yes increase them both\\n                right -= 1\\n            else: # if not, we will check if it is after removing either right of left value\\n                return s[left:right] == s[left:right][::-1] or s[left+1:right+1] == s[left+1:right+1][::-1] # return true if either situation is True.\\n        \\n        return True # True as both ends values are same.\\n```\\n\\nLemme explain this line too, to make it easy for you:-\\n```\\nreturn s[left:right] == s[left:right][::-1] or s[left+1:right+1] == s[left+1:right+1][::-1]\\n```\\nThe first part is \\n> s[left:right] == s[left:right][::-1]\\n> In this we are taking whole list, starting from start to the end. Though list slicing doesn`t consider last element, so automatically right value will be removed, then we`ll compare it with reverse of it.\\n\\nThe second part is \\n>s[left+1:right+1] == s[left+1:right+1][::-1]\\n>In this we are removing left most element.\\n\\n\\nFound helpful, Do upvote !!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        left = 0 # pointer one\\n        right = len(s) - 1 # pointer two\\n        \\n        while left < right: # index should be less then right one, not even equal, as  we dont need to compare same index\\n            if s[left] == s[right]: # if both the ends value are equal.\\n                left += 1 # if yes increase them both\\n                right -= 1\\n            else: # if not, we will check if it is after removing either right of left value\\n                return s[left:right] == s[left:right][::-1] or s[left+1:right+1] == s[left+1:right+1][::-1] # return true if either situation is True.\\n        \\n        return True # True as both ends values are same.\\n```\n```\\nreturn s[left:right] == s[left:right][::-1] or s[left+1:right+1] == s[left+1:right+1][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407697,
                "title": "simple-javascript-solution",
                "content": "```js\\nvar validPalindrome = function(s, corrections = 1) {\\n  let lo = 0;\\n  let hi = s.length - 1;\\n  \\n  while (lo < hi) {\\n    if (s[lo] === s[hi]) {\\n      lo++;\\n      hi--;\\n      continue;\\n    }\\n    \\n    if (corrections === 0) {\\n      return false;\\n    }\\n    \\n    return validPalindrome(s.slice(lo, hi), 0) \\n      || validPalindrome(s.slice(lo + 1, hi + 1), 0);\\n  }\\n  \\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar validPalindrome = function(s, corrections = 1) {\\n  let lo = 0;\\n  let hi = s.length - 1;\\n  \\n  while (lo < hi) {\\n    if (s[lo] === s[hi]) {\\n      lo++;\\n      hi--;\\n      continue;\\n    }\\n    \\n    if (corrections === 0) {\\n      return false;\\n    }\\n    \\n    return validPalindrome(s.slice(lo, hi), 0) \\n      || validPalindrome(s.slice(lo + 1, hi + 1), 0);\\n  }\\n  \\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 493705,
                "title": "java-iterative-solution-in-o-n-time-easy-to-read",
                "content": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int left = 0;\\n        int right = s.length() - 1;\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right))\\n                return checkPalindrome(left + 1, right, s) || checkPalindrome(left, right - 1, s);\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n    private boolean checkPalindrome(int left, int right, String s) {\\n        while (left < right) {\\n            if (s.charAt(left++) != s.charAt(right--))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int left = 0;\\n        int right = s.length() - 1;\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right))\\n                return checkPalindrome(left + 1, right, s) || checkPalindrome(left, right - 1, s);\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n    private boolean checkPalindrome(int left, int right, String s) {\\n        while (left < right) {\\n            if (s.charAt(left++) != s.charAt(right--))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077560,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string &s, int i, int j)\\n    {\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool validPalindrome(string s) {\\n        int i=0, j=s.size()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            break;\\n            i++;\\n            j--;\\n        }\\n        if(check(s, i+1, j) || check(s, i, j-1))\\n        return true;\\n        return false;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string &s, int i, int j)\\n    {\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool validPalindrome(string s) {\\n        int i=0, j=s.size()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            break;\\n            i++;\\n            j--;\\n        }\\n        if(check(s, i+1, j) || check(s, i, j-1))\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904913,
                "title": "python-clean-solution-python-art",
                "content": "```python\\n        for i in range(len(s) // 2):\\n            if s[i] != s[~i]:\\n                l = s[i:~i]\\n                r = s[i+1:len(s)-i]\\n                return l == l[::-1] or r == r[::-1]\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n        for i in range(len(s) // 2):\\n            if s[i] != s[~i]:\\n                l = s[i:~i]\\n                r = s[i+1:len(s)-i]\\n                return l == l[::-1] or r == r[::-1]\\n        return True\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 356505,
                "title": "c-concise-solution",
                "content": "```cpp\\nbool validPalindrome(string s) {\\n\\treturn validPal(s, 0, s.size() - 1);\\n}\\n\\nbool validPal(string &s, int i, int j, bool usedSkip = false) {\\n\\tfor(; i < j; i++, j--)\\n\\t\\tif(s[i] != s[j]) \\n\\t\\t\\treturn usedSkip ? false : validPal(s, i + 1, j, true) || validPal(s, i, j - 1, true);\\n\\treturn true;        \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nbool validPalindrome(string s) {\\n\\treturn validPal(s, 0, s.size() - 1);\\n}\\n\\nbool validPal(string &s, int i, int j, bool usedSkip = false) {\\n\\tfor(; i < j; i++, j--)\\n\\t\\tif(s[i] != s[j]) \\n\\t\\t\\treturn usedSkip ? false : validPal(s, i + 1, j, true) || validPal(s, i, j - 1, true);\\n\\treturn true;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1628724,
                "title": "java-simple-clean-faster-than-100-pure-logic-efficient-solution",
                "content": "# **Please UPVOTE if you find this solution helpful :)**\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n<u><strong>COMPLEXITY:</strong></u>\\n* <strong>Time: O(n),</strong> where n is the length of the string\\n* <strong>Space: O(1),</strong> in-place\\n\\n<u><strong>BASIC IDEA:</strong></u>\\n* Here, we will use two pointer approach by taking firstIndex and lastIndex. \\n* We will iterate through the string by **incrementing the leftIndex** and **decerementing the rightIndex.**\\n* If the **two characters** on leftIndex and rightIndex **are not same**, then we will **delete the character(done using isCharacterDeleted = true)**. \\n* Now, again we will start iterating through rest of the remaining characters.\\n* Now, **if 2 characters** are found which **are not equal again**, then **return false** else return true after whole iteration of the string.\\n\\n<iframe src=\"https://leetcode.com/playground/8aCzgCWC/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please UPVOTE if you find this solution helpful :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "# **Please UPVOTE if you find this solution helpful :)**\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n<u><strong>COMPLEXITY:</strong></u>\\n* <strong>Time: O(n),</strong> where n is the length of the string\\n* <strong>Space: O(1),</strong> in-place\\n\\n<u><strong>BASIC IDEA:</strong></u>\\n* Here, we will use two pointer approach by taking firstIndex and lastIndex. \\n* We will iterate through the string by **incrementing the leftIndex** and **decerementing the rightIndex.**\\n* If the **two characters** on leftIndex and rightIndex **are not same**, then we will **delete the character(done using isCharacterDeleted = true)**. \\n* Now, again we will start iterating through rest of the remaining characters.\\n* Now, **if 2 characters** are found which **are not equal again**, then **return false** else return true after whole iteration of the string.\\n\\n<iframe src=\"https://leetcode.com/playground/8aCzgCWC/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please UPVOTE if you find this solution helpful :)**",
                "codeTag": "Unknown"
            },
            {
                "id": 1315402,
                "title": "c-time-o-log-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int i=0;\\n        int n=s.length();\\n        int j=n-1;\\n        int count=0,count1=0;\\n            while(i<=j){\\n                if(s[i]==s[j]){\\n                    i++;\\n                    j--;\\n                }\\n                else{\\n                    i++;\\n                    count++;\\n                }\\n            }\\n         i=0;\\n         j=n-1;\\n            while(i<=j){\\n                if(s[i]==s[j]){\\n                    i++;\\n                    j--;\\n                }\\n                else{\\n                    j--;\\n                    count1++;\\n                }\\n            } \\n        if(count==0 || count1==0){\\n            return true;\\n        }\\n        if(count==1 || count1==1){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\nif you like the solution upvote it and encourage me.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int i=0;\\n        int n=s.length();\\n        int j=n-1;\\n        int count=0,count1=0;\\n            while(i<=j){\\n                if(s[i]==s[j]){\\n                    i++;\\n                    j--;\\n                }\\n                else{\\n                    i++;\\n                    count++;\\n                }\\n            }\\n         i=0;\\n         j=n-1;\\n            while(i<=j){\\n                if(s[i]==s[j]){\\n                    i++;\\n                    j--;\\n                }\\n                else{\\n                    j--;\\n                    count1++;\\n                }\\n            } \\n        if(count==0 || count1==0){\\n            return true;\\n        }\\n        if(count==1 || count1==1){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452155,
                "title": "python-visual-explanation-picture-is-worth-a-thousand-words",
                "content": "Using two pointers you can check if characters are sames and when they mismatch you have two cases.\\n\\nIf you skip the left character once rest of the pending string is palindrome.\\nIf you skip the right character another pending part is palindrome.\\n\\n\\nHere is the visual\\n\\n![image](https://assets.leetcode.com/users/images/d99f4973-3e18-4159-a093-d04161c125f4_1631104708.117352.jpeg)\\n\\n\\nCode\\n\\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        def is_palindrome(s):\\n            return s == s[::-1]\\n        \\n        l, r = 0, len(s)-1\\n        \\n        while l < r:\\n            if s[l] == s[r]:\\n                l, r = l+1, r-1\\n            else:\\n                return is_palindrome(s[l:r]) or is_palindrome(s[l+1:r+1])\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        def is_palindrome(s):\\n            return s == s[::-1]\\n        \\n        l, r = 0, len(s)-1\\n        \\n        while l < r:\\n            if s[l] == s[r]:\\n                l, r = l+1, r-1\\n            else:\\n                return is_palindrome(s[l:r]) or is_palindrome(s[l+1:r+1])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245885,
                "title": "o-n-o-1-elegant-javascript-solution",
                "content": "```\\nconst validPalindrome = (str, skipped = false) => {\\n  for (let i = 0, j = str.length - 1; i < j; i++, j--) {\\n    if (str[i] !== str[j]) {\\n      if (skipped) return false;\\n      return (\\n        validPalindrome(str.substring(i, j), true) ||\\n        validPalindrome(str.substring(i + 1, j + 1), true)\\n      );\\n    }\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst validPalindrome = (str, skipped = false) => {\\n  for (let i = 0, j = str.length - 1; i < j; i++, j--) {\\n    if (str[i] !== str[j]) {\\n      if (skipped) return false;\\n      return (\\n        validPalindrome(str.substring(i, j), true) ||\\n        validPalindrome(str.substring(i + 1, j + 1), true)\\n      );\\n    }\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1515549,
                "title": "easy-java-solution-with-two-pointers-approach",
                "content": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int left = 0 ; \\n        int right = s.length() - 1;\\n        \\n        while(left<right){\\n            if(s.charAt(left) == s.charAt(right)){\\n                left++;\\n                right--;\\n            } else{\\n                return isPalindrome(s,left+1,right) || isPalindrome(s,left,right-1);\\n            }\\n        }\\n        \\n        return true ;\\n    }\\n    \\n    public boolean isPalindrome(String s , int left , int right){\\n        while(left<right){\\n        if(s.charAt(left) == s.charAt(right)){\\n                left++;\\n                right--;\\n          } else{\\n            return false ;\\n            }\\n       }\\n        \\n        return true ;\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int left = 0 ; \\n        int right = s.length() - 1;\\n        \\n        while(left<right){\\n            if(s.charAt(left) == s.charAt(right)){\\n                left++;\\n                right--;\\n            } else{\\n                return isPalindrome(s,left+1,right) || isPalindrome(s,left,right-1);\\n            }\\n        }\\n        \\n        return true ;\\n    }\\n    \\n    public boolean isPalindrome(String s , int left , int right){\\n        while(left<right){\\n        if(s.charAt(left) == s.charAt(right)){\\n                left++;\\n                right--;\\n          } else{\\n            return false ;\\n            }\\n       }\\n        \\n        return true ;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507206,
                "title": "go-12ms-100-clear-solution",
                "content": "```go\\nfunc validPalindrome(s string) bool {\\n    valid, l, r := isPalindrome(s, 0, len(s)-1)\\n    if valid {\\n        return true\\n    }\\n    if valid, _, _ := isPalindrome(s, l+1, r); valid {\\n        return true\\n    }\\n    if valid, _, _ := isPalindrome(s, l, r-1); valid {\\n        return true\\n    }\\n    return false\\n}\\n\\nfunc isPalindrome(s string, l, r int) (bool, int, int) {\\n    for l < r {\\n        if s[l] != s[r] {\\n            return false, l, r\\n        }\\n        l++\\n        r--\\n    }\\n    return true, 0, 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc validPalindrome(s string) bool {\\n    valid, l, r := isPalindrome(s, 0, len(s)-1)\\n    if valid {\\n        return true\\n    }\\n    if valid, _, _ := isPalindrome(s, l+1, r); valid {\\n        return true\\n    }\\n    if valid, _, _ := isPalindrome(s, l, r-1); valid {\\n        return true\\n    }\\n    return false\\n}\\n\\nfunc isPalindrome(s string, l, r int) (bool, int, int) {\\n    for l < r {\\n        if s[l] != s[r] {\\n            return false, l, r\\n        }\\n        l++\\n        r--\\n    }\\n    return true, 0, 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1726612,
                "title": "using-2-pointer-solution-in-c-time-complexity-o-n",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we can delete almost 1 character to make a valid palindrome.\\n- We took 2 pointers and iterates them from start and end.\\n- At any point, if we find the characters are not the same then we\\u2019ll pass the array with 2 pointers skipping one character.**`isPalindrome(s, i+1, j) || isPalindrome(s, i, j-1)`**\\n- This function will check it the rest array is palindrome or not.\\n- If any of these return true then return true.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int n = s.size();\\n        int i=0, j=n-1, count1=0, count2=0;\\n        while(i<j){\\n            if(s[i] != s[j])\\n                return isPalindrome(s, i+1, j) || isPalindrome(s, i, j-1);\\n            i++; j--;\\n        }\\n        return true;\\n    }\\n    bool isPalindrome(string s, int i, int j){\\n        while(i<j){\\n            if(s[i] != s[j]) \\n                return false;\\n            i++; j--;\\n        }\\n        return true;\\n    }\\n    \\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int n = s.size();\\n        int i=0, j=n-1, count1=0, count2=0;\\n        while(i<j){\\n            if(s[i] != s[j])\\n                return isPalindrome(s, i+1, j) || isPalindrome(s, i, j-1);\\n            i++; j--;\\n        }\\n        return true;\\n    }\\n    bool isPalindrome(string s, int i, int j){\\n        while(i<j){\\n            if(s[i] != s[j]) \\n                return false;\\n            i++; j--;\\n        }\\n        return true;\\n    }\\n    \\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 579880,
                "title": "c-solution",
                "content": "When s[i] != s[j], there are two options to delete one character. \\n* case 1: After deleting s[i], substring from s[i+1] to s[j] should be a palindrome.\\n* case 2: After deleting s[j], substring from s[i] to s[j-1] should be a palindrome.\\n\\n![image](https://assets.leetcode.com/users/danhuang/image_1586901272.png)\\n\\n\\n```\\npublic class Solution {\\n    public bool ValidPalindrome(string s) {\\n        \\n        if(s == \"\")\\n            return true;\\n        \\n        int i = 0, j = s.Length - 1;\\n        \\n        while(i < j)\\n        {\\n            if(s[i] != s[j])\\n                return IsPalindrome(s, i + 1, j) || IsPalindrome(s, i, j - 1);\\n            \\n            i++;\\n            j--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private bool IsPalindrome(string s, int i, int j)\\n    {\\n        while(i < j)\\n        {\\n            if(s[i] != s[j])\\n                return false;\\n            \\n            i++;\\n            j--;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool ValidPalindrome(string s) {\\n        \\n        if(s == \"\")\\n            return true;\\n        \\n        int i = 0, j = s.Length - 1;\\n        \\n        while(i < j)\\n        {\\n            if(s[i] != s[j])\\n                return IsPalindrome(s, i + 1, j) || IsPalindrome(s, i, j - 1);\\n            \\n            i++;\\n            j--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private bool IsPalindrome(string s, int i, int j)\\n    {\\n        while(i < j)\\n        {\\n            if(s[i] != s[j])\\n                return false;\\n            \\n            i++;\\n            j--;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1267611,
                "title": "c-solution-two-pointers-o-n-time",
                "content": "```\\n\\nclass Solution {\\n    \\n    bool valid(string s, int i, int j)\\n    {\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    bool validPalindrome(string s) {\\n        \\n        int i=0;\\n        int j=s.size()-1;\\n        \\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return valid(s, i, j-1) || valid(s, i+1, j);\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\n    bool valid(string s, int i, int j)\\n    {\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    bool validPalindrome(string s) {\\n        \\n        int i=0;\\n        int j=s.size()-1;\\n        \\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return valid(s, i, j-1) || valid(s, i+1, j);\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107763,
                "title": "o-n-easy-understand-solution",
                "content": "```\\npublic boolean validPalindrome(String s) {\\n        if(s == null || s.length() == 0) return true;\\n        int left = 0; int right = s.length() - 1;\\n        int count1 = 0;\\n        while(left < right){\\n            if(s.charAt(left) != s.charAt(right)){\\n                count1++;\\n                left ++;\\n            }else{\\n                left ++;\\n                right --;\\n            }\\n        }\\n        left = 0; right = s.length() - 1; int count2 = 0;\\n        while(left < right){\\n            if(s.charAt(left) != s.charAt(right)){\\n                count2++;\\n                right --;\\n            }else{\\n                left ++;\\n                right --;\\n            }\\n        }\\n        return count1 <= 1 || count2 <= 1; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean validPalindrome(String s) {\\n        if(s == null || s.length() == 0) return true;\\n        int left = 0; int right = s.length() - 1;\\n        int count1 = 0;\\n        while(left < right){\\n            if(s.charAt(left) != s.charAt(right)){\\n                count1++;\\n                left ++;\\n            }else{\\n                left ++;\\n                right --;\\n            }\\n        }\\n        left = 0; right = s.length() - 1; int count2 = 0;\\n        while(left < right){\\n            if(s.charAt(left) != s.charAt(right)){\\n                count2++;\\n                right --;\\n            }else{\\n                left ++;\\n                right --;\\n            }\\n        }\\n        return count1 <= 1 || count2 <= 1; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107731,
                "title": "simple-python-solution",
                "content": "Whenever there is a mismatch when checking for palindrome, we try deleting either one of the two characters involved in the mismatch and see if isPalindrome succeeds. To make sure, we don\\u2019t delete more than 1 character, we also maintain the delCount.\\n\\n```\\n    def isPalindrome(self, s, start, end, delCount):\\n        if delCount > 1:\\n            return False\\n        while start < end:\\n            if s[start] != s[end]:\\n                break\\n            start += 1\\n            end -= 1\\n        if (start == end) or (start == end+1):\\n            return True\\n        return any([self.isPalindrome(s, start+1, end, delCount+1), self.isPalindrome(s, start, end-1, delCount+1)])\\n\\n    def validPalindrome(self, s):\\n        return self.isPalindrome(s, 0, len(s)-1, 0)\\n```",
                "solutionTags": [],
                "code": "```\\n    def isPalindrome(self, s, start, end, delCount):\\n        if delCount > 1:\\n            return False\\n        while start < end:\\n            if s[start] != s[end]:\\n                break\\n            start += 1\\n            end -= 1\\n        if (start == end) or (start == end+1):\\n            return True\\n        return any([self.isPalindrome(s, start+1, end, delCount+1), self.isPalindrome(s, start, end-1, delCount+1)])\\n\\n    def validPalindrome(self, s):\\n        return self.isPalindrome(s, 0, len(s)-1, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1905437,
                "title": "c-two-pointer-2-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int st = 0;\\n        int lt = s.size()-1;\\n        int count = 0;\\n        \\n        while(st<=lt){\\n            if(s[st]==s[lt]){\\n                st++;\\n                lt--;\\n            }\\n            else {\\n                st++;\\n                count++;\\n            }\\n        }\\n    int count1 = 0;\\n        st=0;\\n        lt = s.size()-1;\\n                while(st<=lt){\\n            if(s[st]==s[lt]){\\n                st++;\\n                lt--;\\n            }\\n            else {\\n                lt--;\\n                count1++;\\n            }\\n        }\\n        if(count1<=1||count<=1){\\n            return true;\\n        }\\n        else return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int st = 0;\\n        int lt = s.size()-1;\\n        int count = 0;\\n        \\n        while(st<=lt){\\n            if(s[st]==s[lt]){\\n                st++;\\n                lt--;\\n            }\\n            else {\\n                st++;\\n                count++;\\n            }\\n        }\\n    int count1 = 0;\\n        st=0;\\n        lt = s.size()-1;\\n                while(st<=lt){\\n            if(s[st]==s[lt]){\\n                st++;\\n                lt--;\\n            }\\n            else {\\n                lt--;\\n                count1++;\\n            }\\n        }\\n        if(count1<=1||count<=1){\\n            return true;\\n        }\\n        else return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904932,
                "title": "c-clean-easy-two-pointers",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool helper(string s,int i,int j ){\\n\\t\\t\\twhile(i<j){\\n\\t\\t\\t\\tif(s[i]!=s[j]){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tbool validPalindrome(string s) {\\n\\t\\t\\tint i=0,j=s.size()-1;\\n\\t\\t\\twhile(i<j){\\n\\t\\t\\t\\tif(s[i]!=s[j]){ //mismatched pair\\n\\t\\t\\t\\t\\treturn (helper(s,i,j-1)||helper(s,i+1,j));\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};\\n\\n**feel free to ask your doubts :)\\nand pls upvote if it was helpful :)**",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool helper(string s,int i,int j ){\\n\\t\\t\\twhile(i<j){\\n\\t\\t\\t\\tif(s[i]!=s[j]){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 679091,
                "title": "python-3-simple-solution-explained",
                "content": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        \"\"\"\\n        Given an input string s, this program determines whether s is a\\n        valid palindrome or becomes one with the removal of a single\\n        character.\\n\\n        :param s: input string\\n        :type s: str\\n        :return: True if s is palindrome unmodified or with the removal\\n                 of a single character, else False\\n        :rtype: bool\\n        \"\"\"\\n        \"\"\"\\n        If s is a palindrome unmodified, return True right away.\\n        \"\"\"\\n        if s == s[::-1]:\\n            return True\\n\\n        \"\"\"\\n        The string s may be a palindrome with the removal of a character.\\n        The while loop finds two possible locations of the offending\\n        character, s[left] (leftmost) and s[right] (rightmost).\\n        \"\"\"\\n        left = 0\\n        right = len( s ) - 1\\n        while s[left] == s[right]:\\n            left += 1\\n            right -= 1\\n\\n        \"\"\"\\n        Check whether substring created by removing either the leftmost\\n        character or rightmost character from the while loop is a valid\\n        palindrome.\\n        \"\"\"\\n        new_s = s[left+1:right+1]\\n        if new_s == new_s[::-1]:\\n            return True\\n        new_s = s[left:right]\\n        if new_s == new_s[::-1]:\\n            return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        \"\"\"\\n        Given an input string s, this program determines whether s is a\\n        valid palindrome or becomes one with the removal of a single\\n        character.\\n\\n        :param s: input string\\n        :type s: str\\n        :return: True if s is palindrome unmodified or with the removal\\n                 of a single character, else False\\n        :rtype: bool\\n        \"\"\"\\n        \"\"\"\\n        If s is a palindrome unmodified, return True right away.\\n        \"\"\"\\n        if s == s[::-1]:\\n            return True\\n\\n        \"\"\"\\n        The string s may be a palindrome with the removal of a character.\\n        The while loop finds two possible locations of the offending\\n        character, s[left] (leftmost) and s[right] (rightmost).\\n        \"\"\"\\n        left = 0\\n        right = len( s ) - 1\\n        while s[left] == s[right]:\\n            left += 1\\n            right -= 1\\n\\n        \"\"\"\\n        Check whether substring created by removing either the leftmost\\n        character or rightmost character from the while loop is a valid\\n        palindrome.\\n        \"\"\"\\n        new_s = s[left+1:right+1]\\n        if new_s == new_s[::-1]:\\n            return True\\n        new_s = s[left:right]\\n        if new_s == new_s[::-1]:\\n            return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623463,
                "title": "python-recursive-solution-works-for-n-deletes",
                "content": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        def is_valid(i, j, s, d=1):\\n            while i < j:\\n                if s[i] != s[j]:\\n                    return is_valid(i+1, j, s, d-1) or is_valid(i, j-1, s, d-1) if d else False\\n                i, j = i+1, j-1\\n            return True\\n        return is_valid(0, len(s)-1, s)\\n```\\nTime Complexity: O(N)\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        def is_valid(i, j, s, d=1):\\n            while i < j:\\n                if s[i] != s[j]:\\n                    return is_valid(i+1, j, s, d-1) or is_valid(i, j-1, s, d-1) if d else False\\n                i, j = i+1, j-1\\n            return True\\n        return is_valid(0, len(s)-1, s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097873,
                "title": "simple-c-solution-two-pointer",
                "content": "**Solution -->**\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s,int i,int j){\\n        while(i<=j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool validPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        \\n        while(i<=j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                return (isPalindrome(s,i+1,j) || isPalindrome(s,i,j-1));\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n##### If you have any doubt, feel free to write it down in the comments.\\n##### Thankyou",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s,int i,int j){\\n        while(i<=j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool validPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        \\n        while(i<=j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                return (isPalindrome(s,i+1,j) || isPalindrome(s,i,j-1));\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906431,
                "title": "simple-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int low=0,high=s.length()-1;\\n        // to check if a string is palindrome or not\\n        // if loop runs successfully then it palindrome string\\n        while(high>low){\\n            if(s[low]==s[high]){\\n                low++;\\n                high--;\\n            }\\n            else\\n                break;\\n        }\\n        if(low>=high)\\n            return true;\\n        \\n        // if string is not palindrome then we have to look \\n        // to skip left char where loop break and check again for palindrome\\n        int low1=low+1,high1=high;\\n        while(low1<high1){\\n            if(s[low1]==s[high1]){\\n                low1++;\\n                high1--;\\n            }\\n            else\\n                break;\\n        }\\n        if(low1>=high1)\\n            return true;\\n        \\n        // now we will skip the right most where 1st loop breaks\\n        \\n        int low2=low,high2=high-1;\\n        while(low2<high2){\\n            if(s[low2]==s[high2]){\\n                low2++;\\n                high2--;\\n            }\\n            else\\n                break;\\n        }\\n        if(low2>=high2)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int low=0,high=s.length()-1;\\n        // to check if a string is palindrome or not\\n        // if loop runs successfully then it palindrome string\\n        while(high>low){\\n            if(s[low]==s[high]){\\n                low++;\\n                high--;\\n            }\\n            else\\n                break;\\n        }\\n        if(low>=high)\\n            return true;\\n        \\n        // if string is not palindrome then we have to look \\n        // to skip left char where loop break and check again for palindrome\\n        int low1=low+1,high1=high;\\n        while(low1<high1){\\n            if(s[low1]==s[high1]){\\n                low1++;\\n                high1--;\\n            }\\n            else\\n                break;\\n        }\\n        if(low1>=high1)\\n            return true;\\n        \\n        // now we will skip the right most where 1st loop breaks\\n        \\n        int low2=low,high2=high-1;\\n        while(low2<high2){\\n            if(s[low2]==s[high2]){\\n                low2++;\\n                high2--;\\n            }\\n            else\\n                break;\\n        }\\n        if(low2>=high2)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905659,
                "title": "o-n-explanation",
                "content": "Hello Leetcoders, hope you are well.\\n\\nLet\\'s proceed to this valid palindrome II problem.\\n\\n**What Problem statement is saying**\\n```\\nYou have a String s, return true if it is palindrome else false.\\nOperation : you can delete one character from the String to make it palindrome\\n```\\n\\nNow I think you know what is a palindrome String \\nAn string which you can read same from left to right & right to left\\n\\ne.g : racecar\\n\\n**Base code for palindrome**\\n```\\n\\n// T(n) - O(n) \\n// S(n) - O(n)\\n\\n\\npublic boolean isPalindrome(String s) {\\n\\tint left = 0, right = s.length() - 1;\\n\\t\\n\\twhile(left < right) {\\n\\t\\tif(s.charAt(left) != s.charAt(right)) return false;\\n\\t\\t\\n\\t\\tleft++;\\n\\t\\tright--;\\n\\t}\\n\\t\\n\\treturn true;\\n}\\t\\n```\\n\\nNow if you think problem said that we can delete one character from the string(if needed) to make this string palindrome\\n\\n**how can we do that?**\\n\\nlet me explain it to you by using one example \\n\\ne.g acdda\\n\\nhere you can see first and last character is same so we skip to the next iteration. Now at 2nd place we have **c** from start and **d** from end. here mis-matched the characters. what we can do here? a simple deletion of the character.\\n\\nThe question is which one we have to delete, The start one or end one. what we can do is delete start and check is it palindrome and delete end and check is it palindrome. do OR operation to get the desired output\\n\\nHow you can delete? just call another fuunction by skiping the desired index of the character \\n\\nin our exmaple we call another function which return boolean value\\nretrun callFunction(\"dd\") || callFunction(\"cd\");\\n\\ncallFunction(\"dd\") -> skipped start position i.e **\\'c\\'**\\ncallFunction(\"cd\") -> Skipped last position i.e. **\\'d\\'**\\n\\n\\nCode \\n```\\npublic boolean validPalindrome(String s) {\\n        int left = 0;\\n        int right = s.length() - 1;\\n        \\n        while(left < right) {\\n            if(s.charAt(left) != s.charAt(right)) {\\n                return (checkPalindrome(s, left, right-1) || checkPalindrome(s, left+1, right));\\n            }\\n             left++;\\n            right--;\\n        }\\n        \\n        return true;\\n    }\\n    private boolean isPalindrome(String s, int l, int r) {\\n        \\n        while(l < r) {\\n            if(s.charAt(l) != s.charAt(r)) return false;\\n            \\n            l++;\\n            r--;\\n            \\n        }\\n        \\n        return true;\\n    }\\n\\n```\\n\\nTime complexity - O(n) : Cause we are traversing every element once\\nSpace complexity - O(1)\\n\\n\\nNote : in case of any doubt please feel free to comment below, Thank You.",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nYou have a String s, return true if it is palindrome else false.\\nOperation : you can delete one character from the String to make it palindrome\\n```\n```\\n\\n// T(n) - O(n) \\n// S(n) - O(n)\\n\\n\\npublic boolean isPalindrome(String s) {\\n\\tint left = 0, right = s.length() - 1;\\n\\t\\n\\twhile(left < right) {\\n\\t\\tif(s.charAt(left) != s.charAt(right)) return false;\\n\\t\\t\\n\\t\\tleft++;\\n\\t\\tright--;\\n\\t}\\n\\t\\n\\treturn true;\\n}\\t\\n```\n```\\npublic boolean validPalindrome(String s) {\\n        int left = 0;\\n        int right = s.length() - 1;\\n        \\n        while(left < right) {\\n            if(s.charAt(left) != s.charAt(right)) {\\n                return (checkPalindrome(s, left, right-1) || checkPalindrome(s, left+1, right));\\n            }\\n             left++;\\n            right--;\\n        }\\n        \\n        return true;\\n    }\\n    private boolean isPalindrome(String s, int l, int r) {\\n        \\n        while(l < r) {\\n            if(s.charAt(l) != s.charAt(r)) return false;\\n            \\n            l++;\\n            r--;\\n            \\n        }\\n        \\n        return true;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1641476,
                "title": "easy-simple-python-code-beats-99",
                "content": "![image](https://assets.leetcode.com/users/images/018bf77e-2d55-4add-975d-283b65a0788d_1640182611.1584713.png)\\n\\n\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n\\t\\n\\t\\t#Deal with edge cases: empty string and single char string\\n\\t\\t\\n\\t\\tif len(s) == 0: return False         \\t\\t\\n\\t\\tif len(s) == 1: return True \\n    \\n        #Palindrome without deletion\\n        if s == s[::-1]: return True\\n        \\n        #If not a valid Palindrome at the moment iterate over and check sub strings.\\n\\t\\t\\n\\t\\tbegin = 0\\n        end = len(s)-1        \\n        \\n        while begin<end:\\n            if s[begin] == s[end]:\\n                begin = begin + 1\\n                end = end - 1\\n                \\n            else: \\n\\t\\t\\t\\t# define two substring, with left removal and right removal. Then check if one of them is a valid palindrom.\\n\\t\\t\\t\\t# if so return True. Else, it has more than 2 violations.![image](https://assets.leetcode.com/users/images/008a5c22-7f8c-466f-b5bd-d8dee87f184f_1640182578.8853605.png)\\n\\n                left_remove = s[begin+1:end+1]\\n                right_remove= s[begin:end]\\n                if left_remove==left_remove[::-1] or right_remove == right_remove[::-1]:\\n                    return True\\n                else:\\n                    return False\\n                \\n        return True\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/018bf77e-2d55-4add-975d-283b65a0788d_1640182611.1584713.png)\\n\\n\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n\\t\\n\\t\\t#Deal with edge cases: empty string and single char string\\n\\t\\t\\n\\t\\tif len(s) == 0: return False         \\t\\t\\n\\t\\tif len(s) == 1: return True \\n    \\n        #Palindrome without deletion\\n        if s == s[::-1]: return True\\n        \\n        #If not a valid Palindrome at the moment iterate over and check sub strings.\\n\\t\\t\\n\\t\\tbegin = 0\\n        end = len(s)-1        \\n        \\n        while begin<end:\\n            if s[begin] == s[end]:\\n                begin = begin + 1\\n                end = end - 1\\n                \\n            else: \\n\\t\\t\\t\\t# define two substring, with left removal and right removal. Then check if one of them is a valid palindrom.\\n\\t\\t\\t\\t# if so return True. Else, it has more than 2 violations.![image](https://assets.leetcode.com/users/images/008a5c22-7f8c-466f-b5bd-d8dee87f184f_1640182578.8853605.png)\\n\\n                left_remove = s[begin+1:end+1]\\n                right_remove= s[begin:end]\\n                if left_remove==left_remove[::-1] or right_remove == right_remove[::-1]:\\n                    return True\\n                else:\\n                    return False\\n                \\n        return True\\n",
                "codeTag": "Java"
            },
            {
                "id": 1474792,
                "title": "python-3-recursion",
                "content": "### Idea\\nUse two pointers, left and right\\nIf s[left] and s[right] does not match, you have two options.\\n1. Ignore left characer and move on\\n2. Ignore right character and move on\\n\\nIf either one recursive calls return True, you have a valid palindrome. Remember for both cases you have to mark the `changed` variable to `True` so that you don\\'t accept another mismatch. \\n\\n\\n```python\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        \\n        def isPalindrome(left, right, changed):            \\n            while left < right:\\n                if s[left] != s[right]:\\n                    if not changed:\\n                        return isPalindrome(left + 1, right, True) or isPalindrome(left, right - 1, True)\\n                    else:\\n                        return False\\n                else:\\n                    left += 1\\n                    right -= 1\\n            return True\\n\\n        return isPalindrome(0, len(s) - 1, False)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        \\n        def isPalindrome(left, right, changed):            \\n            while left < right:\\n                if s[left] != s[right]:\\n                    if not changed:\\n                        return isPalindrome(left + 1, right, True) or isPalindrome(left, right - 1, True)\\n                    else:\\n                        return False\\n                else:\\n                    left += 1\\n                    right -= 1\\n            return True\\n\\n        return isPalindrome(0, len(s) - 1, False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127533,
                "title": "4ms-java-solution-faster-than-100",
                "content": "```java\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        return validPalindrome(s, 0, s.length() - 1, false);\\n    }\\n    \\n    private boolean validPalindrome(String s, int left, int right, boolean hasDeleted) {\\n        while (left < right) {\\n            char sleft = s.charAt(left);\\n            char sright = s.charAt(right);\\n            if (sleft != sright) {\\n                if (hasDeleted) return false;\\n                return validPalindrome(s, left+1, right, true) \\n                    || validPalindrome(s, left, right -1, true);\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        return validPalindrome(s, 0, s.length() - 1, false);\\n    }\\n    \\n    private boolean validPalindrome(String s, int left, int right, boolean hasDeleted) {\\n        while (left < right) {\\n            char sleft = s.charAt(left);\\n            char sright = s.charAt(right);\\n            if (sleft != sright) {\\n                if (hasDeleted) return false;\\n                return validPalindrome(s, left+1, right, true) \\n                    || validPalindrome(s, left, right -1, true);\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077075,
                "title": "javascript-valid-palindrome-ii",
                "content": "\\n\\n# JavaScript \\uD83D\\uDFE8\\n\\nRuntime: ```O(n)```\\nSpace Complexity: ```O(1)```\\n```\\n/**\\n * @param {string} s\\n * @param {number} p1\\n * @param {number} p2\\n * @return {boolean}\\n */\\nconst isTruePalindrome = function(s, p1, p2) {\\n  while (p1 < p2) {\\n    if (s[p1] !== s[p2]) return false;\\n    p1++;\\n    p2--;\\n  }\\n  \\n  return true;\\n}\\n\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nconst validPalindrome = function(s) {\\n  let p1 = 0;\\n  let p2 = s.length - 1;\\n  \\n  while (p1 < p2) {\\n    if (s[p1] !== s[p2]) return isTruePalindrome(s, p1 + 1, p2) || isTruePalindrome(s, p1, p2 - 1);\\n    p1++;\\n    p2--;\\n  }\\n  \\n  return true;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```O(n)```\n```O(1)```\n```\\n/**\\n * @param {string} s\\n * @param {number} p1\\n * @param {number} p2\\n * @return {boolean}\\n */\\nconst isTruePalindrome = function(s, p1, p2) {\\n  while (p1 < p2) {\\n    if (s[p1] !== s[p2]) return false;\\n    p1++;\\n    p2--;\\n  }\\n  \\n  return true;\\n}\\n\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nconst validPalindrome = function(s) {\\n  let p1 = 0;\\n  let p2 = s.length - 1;\\n  \\n  while (p1 < p2) {\\n    if (s[p1] !== s[p2]) return isTruePalindrome(s, p1 + 1, p2) || isTruePalindrome(s, p1, p2 - 1);\\n    p1++;\\n    p2--;\\n  }\\n  \\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 771315,
                "title": "c-2-pointers-solutions-explained-90-time-100-space",
                "content": "This was a nice path to further and further improvements.\\n\\nFirst we set up 2 pointers, `i` and `j`, like [in the base problem](https://leetcode.com/discuss/topic/770505), so check there for some discussion about why we start from beginning and end, instead of starting from the center (spoiler: just easier to visualise/conceive, plus no need for extra logic depending on whether or not the string has an odd length).\\n\\nAnd like the previous problem we progress, BUT when we find a mismatch, the things turn funny and I opted to return the result of the function called on the rest of the string skipping the next position of `i` or the next position of `j` - notice I also added a boolean flag `del` to mark whether or not we did our trial with a deletion: it defaults to `false`, and then of course it get turned to `true` in the recursive calls with the rest of the string.\\n\\nIf we exit our loop safely, then we just return `true` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s, bool del = false) {\\n        int i = -1, j = s.size();\\n        while (i++ < j--) {\\n            if (s[i] != s[j]) {\\n                return !del && (validPalindrome(s.substr(i, j - i), true) || validPalindrome(s.substr(i + 1, j - i), true));\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nAfter the improvements, removing the `.substr` part did not gain much, but turning `s` into `&s` (ie: passing it by reference) did wonders for the performances, particularly space related (of course!).\\n\\nThe improved code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s, bool del = false, int i = -1, int j = -1) {\\n        if (j == - 1) j = s.size();\\n        while (i++ < j--) {\\n            if (s[i] != s[j]) {\\n                return !del && (validPalindrome(s, true, i - 1, j) || validPalindrome(s, true, i, j + 1));\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nA nice exercise now would be to turn it into a recursive function, but I am too bored by this problem for now to do it :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s, bool del = false) {\\n        int i = -1, j = s.size();\\n        while (i++ < j--) {\\n            if (s[i] != s[j]) {\\n                return !del && (validPalindrome(s.substr(i, j - i), true) || validPalindrome(s.substr(i + 1, j - i), true));\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s, bool del = false, int i = -1, int j = -1) {\\n        if (j == - 1) j = s.size();\\n        while (i++ < j--) {\\n            if (s[i] != s[j]) {\\n                return !del && (validPalindrome(s, true, i - 1, j) || validPalindrome(s, true, i, j + 1));\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723091,
                "title": "python-short-easy-to-understand-recursive-solution",
                "content": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        l, r = 0, len(s)-1\\n        count = 0\\n                    \\n        def isPalindrome(l, r, count):\\n            if count > 1:\\n                return False\\n            while l < r:\\n                if s[l] == s[r]:\\n                    l+=1\\n                    r-=1\\n                if s[l] != s[r]:\\n                    if s[l+1] != s[r] and s[l] != s[r-1]:\\n                        return False\\n                    return isPalindrome(l+1, r, count+1) or isPalindrome(l, r-1, count+1)\\n\\t\\t\\t\\t\\t\\n            return True\\n        \\n        return isPalindrome(l, r, count)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        l, r = 0, len(s)-1\\n        count = 0\\n                    \\n        def isPalindrome(l, r, count):\\n            if count > 1:\\n                return False\\n            while l < r:\\n                if s[l] == s[r]:\\n                    l+=1\\n                    r-=1\\n                if s[l] != s[r]:\\n                    if s[l+1] != s[r] and s[l] != s[r-1]:\\n                        return False\\n                    return isPalindrome(l+1, r, count+1) or isPalindrome(l, r-1, count+1)\\n\\t\\t\\t\\t\\t\\n            return True\\n        \\n        return isPalindrome(l, r, count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113922,
                "title": "easy-to-understand-approach-two-pointers-c-beats-99-11",
                "content": "# My Submition\\n![important.png](https://assets.leetcode.com/users/images/f74c7568-6383-4805-8474-571cbae5a5d0_1675001959.0578392.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo my first thought is why don\\'t we use a **Hash Table** to store the values and we can check if there are more than two characters which aren\\'t duplicated then we will return **false** otherwise we will return **true**. \\nThat\\'s not going to work because these characters might be in the beginning or the end and that will make the string not palindrome. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo my approach in this problem is that i will use two pointers so that we can check if the string is palindrome after execluding one of the **chars**. \\n\\nIf the `s[left] == s[right]` then we will increase the left pointer and decrease the right pointer, otherwise we will execlude one of the chars at the two pointers.\\n\\nAfter execluding the character from the **left pointer** then we have to check if all the remaining **chars** are palindrom or not, as well as we will do the same after execluding the right pointer.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool ValidPalindrome(string s) {\\n        int left = 0, right = s.Length - 1;\\n\\n        while (left < right){\\n            if (s[left] == s[right]){\\n                left++;\\n                right--;\\n            }else \\n                return IsPalindrome(s, left + 1, right) || IsPalindrome(s, left, right - 1);     \\n        }\\n\\n        return true;\\n    }\\n    private bool IsPalindrome(string s, int left, int right){\\n        while (left < right){\\n            if (s[left] != s[right])\\n                return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ValidPalindrome(string s) {\\n        int left = 0, right = s.Length - 1;\\n\\n        while (left < right){\\n            if (s[left] == s[right]){\\n                left++;\\n                right--;\\n            }else \\n                return IsPalindrome(s, left + 1, right) || IsPalindrome(s, left, right - 1);     \\n        }\\n\\n        return true;\\n    }\\n    private bool IsPalindrome(string s, int left, int right){\\n        while (left < right){\\n            if (s[left] != s[right])\\n                return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906338,
                "title": "python-easy-solution-faster-than-99-57",
                "content": "# Please upvote if it helps.\\n\\n```\\ndef validPalindrome(self, s: str) -> bool:\\n        if s == s[::-1]:\\n            return True\\n        \\n        l, r =0, len(s)-1\\n        while l<=r:\\n            if s[l]!=s[r]:\\n                temp2 = s[:r] + s[r+1:]\\n                temp = s[:l] + s[l+1:]\\n                \\n                return temp == temp[::-1] or temp2 == temp2[::-1]\\n            \\n            l +=1\\n            r -=1\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2dc22546-86d2-42aa-8c44-4ef3a0d816d5_1648897747.248173.png)\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\ndef validPalindrome(self, s: str) -> bool:\\n        if s == s[::-1]:\\n            return True\\n        \\n        l, r =0, len(s)-1\\n        while l<=r:\\n            if s[l]!=s[r]:\\n                temp2 = s[:r] + s[r+1:]\\n                temp = s[:l] + s[l+1:]\\n                \\n                return temp == temp[::-1] or temp2 == temp2[::-1]\\n            \\n            l +=1\\n            r -=1\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1570599,
                "title": "c-solution-60-ms-23-8-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool pCheck(string s, int start, int end) {\\n        while(start <= end) {\\n            if(s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n    \\n    bool validPalindrome(string s) {\\n        int left = 0;\\n        int right = s.size() - 1;\\n        while (left <= right) {\\n            if(s[left] != s[right]) {\\n                //two conditions \\n                if(pCheck(s, left + 1, right) || pCheck(s, left, right - 1)) {\\n                    return true;\\n                } else {\\n                    return false;\\n                }\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool pCheck(string s, int start, int end) {\\n        while(start <= end) {\\n            if(s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n    \\n    bool validPalindrome(string s) {\\n        int left = 0;\\n        int right = s.size() - 1;\\n        while (left <= right) {\\n            if(s[left] != s[right]) {\\n                //two conditions \\n                if(pCheck(s, left + 1, right) || pCheck(s, left, right - 1)) {\\n                    return true;\\n                } else {\\n                    return false;\\n                }\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1267681,
                "title": "python-3-easy-to-understand-solution",
                "content": "the logic is, there will be at most one mismatch of characters, so you have to check ignoring that one character, the rest of the string is a palindrome or not.\\nnow we all know that, aPa is a palindrome if P is another string which itself is a palindrome.\\nnow you might be given that abPa or aPba. \\nso you just need to check ignoring the b, the rest is a palindrome or not.\\nif you\\'re given abPa, you have already checked the outer parts, now see if P is a palindrom or not, if yes then you can ignore b and make it a full palindrome.\\n\\nif P is not a palindrome, it means there may need to perform some deletion inside P as well, which will make the total deletion more than 1 because we have already kept a character to delete.\\n\\nThe same thing also applies for aPba.\\n```\\ndef validPalindrome(self, s: str) -> bool:\\n\\tstart, end = 0, len(s)-1\\n\\n\\tdef check_palindrome(start, end):\\n\\t\\twhile start<end:\\n\\t\\t\\tif s[start]==s[end]:\\n\\t\\t\\t\\tstart+=1\\n\\t\\t\\t\\tend-=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False  \\n\\t\\treturn True\\n\\n\\twhile start<end:\\n\\t\\tif s[start]==s[end]:\\n\\t\\t\\tstart+=1\\n\\t\\t\\tend-=1\\n\\t\\telse:\\n\\t\\t\\tif check_palindrome(start+1, end) or check_palindrome(start, end-1):\\n\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef validPalindrome(self, s: str) -> bool:\\n\\tstart, end = 0, len(s)-1\\n\\n\\tdef check_palindrome(start, end):\\n\\t\\twhile start<end:\\n\\t\\t\\tif s[start]==s[end]:\\n\\t\\t\\t\\tstart+=1\\n\\t\\t\\t\\tend-=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False  \\n\\t\\treturn True\\n\\n\\twhile start<end:\\n\\t\\tif s[start]==s[end]:\\n\\t\\t\\tstart+=1\\n\\t\\t\\tend-=1\\n\\t\\telse:\\n\\t\\t\\tif check_palindrome(start+1, end) or check_palindrome(start, end-1):\\n\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1123449,
                "title": "java-iterative-solution",
                "content": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<=j){\\n            char ch1=s.charAt(i);\\n            char ch2=s.charAt(j);\\n            if(ch1!=ch2){\\n                boolean res1=ispalindrome(s,i+1,j);\\n                boolean res2=ispalindrome(s,i,j-1);\\n                if(res1==true || res2==true){\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean ispalindrome(String s,int i,int j){\\n     \\n        while(i<j){\\n         char ch1=s.charAt(i);\\n         char ch2=s.charAt(j);\\n            if(ch1!=ch2) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```\\nTime:O(N) and Space:O(1)\\n\\nPlease **UPVOTE** if found it Helpful :)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<=j){\\n            char ch1=s.charAt(i);\\n            char ch2=s.charAt(j);\\n            if(ch1!=ch2){\\n                boolean res1=ispalindrome(s,i+1,j);\\n                boolean res2=ispalindrome(s,i,j-1);\\n                if(res1==true || res2==true){\\n                    return true;\\n                }else{\\n                    return false;\\n                }\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean ispalindrome(String s,int i,int j){\\n     \\n        while(i<j){\\n         char ch1=s.charAt(i);\\n         char ch2=s.charAt(j);\\n            if(ch1!=ch2) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374343,
                "title": "simple-python-solution",
                "content": "Just compare head and tail, from two sides to middle.\\nSkip the character if not equals to see if the rest is valid.\\n```\\ndef validPalindrome(self, s: str) -> bool:\\n\\tL = len(s)\\n\\tfor i in range(L//2+1):\\n\\t\\tif (s[i] != s[-i-1]):\\n\\t\\t\\treturn s[i+1:L-i] == s[i+1:L-i][::-1] or s[i:L-i-1] == s[i:L-i-1][::-1]\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef validPalindrome(self, s: str) -> bool:\\n\\tL = len(s)\\n\\tfor i in range(L//2+1):\\n\\t\\tif (s[i] != s[-i-1]):\\n\\t\\t\\treturn s[i+1:L-i] == s[i+1:L-i][::-1] or s[i:L-i-1] == s[i:L-i-1][::-1]\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 117555,
                "title": "python-solution-with-detailed-solution",
                "content": "**Solution with detailed explanation**  \n\n**Valid Palindrome II** https://leetcode.com/problems/valid-palindrome-ii/description/\n\n**Algorithm**\n1. Initialize i and j to 0 and len(s)-1.\n2. Now while i < j, test if s\\[i] is equal to s\\[j]. When s\\[i] == s\\[j], then advance i and reduce j. If we find no mismatch and i >= j, then return True.\n3.  Otherwise, on the first mismatch, say at i1, j1, test if s\\[i1+1:j1+1] or s\\[i1:j1] are palindromes.\n4.  Linear time and no extra space is required.\n\n```\nclass Solution:\n    def test(self, s, i, j):\n        while i<j:\n            if s[i] != s[j]:\n                return False\n            i, j = i+1, j-1\n        return True\n    \n    def validPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        i, j = 0, len(s)-1\n        while i < j:\n            if s[i] != s[j]:\n                return self.test(s,i+1,j) or self.test(s, i, j-1)\n            i,j = i+1, j-1\n        return True\n```\n\n",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def test(self, s, i, j):\n        while i<j:\n            if s[i] != s[j]:\n                return False\n            i, j = i+1, j-1\n        return True\n    \n    def validPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        i, j = 0, len(s)-1\n        while i < j:\n            if s[i] != s[j]:\n                return self.test(s,i+1,j) or self.test(s, i, j-1)\n            i,j = i+1, j-1\n        return True\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414664,
                "title": "c-recursive-solution-intuitive-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(string &s, int cnt, int i, int j){\\n        if(i>=j) return true;\\n        \\n        //if both matches, continue;\\n        if(s[i] == s[j]) return solve(s, cnt, i+1, j-1);\\n        //if its the first time they didn\\'t match, delete any one of them and see if it comes palindrome\\n        if(cnt == 0){\\n            return (solve(s, cnt+1, i+1, j) || solve(s, cnt+1, i, j-1));\\n        }\\n        //else return false;\\n        return false;\\n    }\\n    bool validPalindrome(string s) {\\n        return solve(s, 0, 0, s.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(string &s, int cnt, int i, int j){\\n        if(i>=j) return true;\\n        \\n        //if both matches, continue;\\n        if(s[i] == s[j]) return solve(s, cnt, i+1, j-1);\\n        //if its the first time they didn\\'t match, delete any one of them and see if it comes palindrome\\n        if(cnt == 0){\\n            return (solve(s, cnt+1, i+1, j) || solve(s, cnt+1, i, j-1));\\n        }\\n        //else return false;\\n        return false;\\n    }\\n    bool validPalindrome(string s) {\\n        return solve(s, 0, 0, s.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2405788,
                "title": "easily-understandable-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return (checkPalindrome(s, i, j - 1) || checkPalindrome(s, i + 1, j));\\n            } \\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    public boolean checkPalindrome(String s, int i, int j) {\\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return (checkPalindrome(s, i, j - 1) || checkPalindrome(s, i + 1, j));\\n            } \\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    public boolean checkPalindrome(String s, int i, int j) {\\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905505,
                "title": "valid-palindrome-ii-using-recursion-java",
                "content": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        return isPalindrome(s, 0, s.length()-1, 1);\\n    }\\n   public boolean isPalindrome(String str, int start, int end, int chance) {\\n        if(start >= end) return true;\\n        if(str.charAt(start) == str.charAt(end))\\n            return isPalindrome(str, start+1, end-1, chance);\\n        \\n        if(chance == 0) return false;\\n        \\n    return isPalindrome(str, start+1, end, chance-1)  || isPalindrome(str, start, end - 1,chance-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        return isPalindrome(s, 0, s.length()-1, 1);\\n    }\\n   public boolean isPalindrome(String str, int start, int end, int chance) {\\n        if(start >= end) return true;\\n        if(str.charAt(start) == str.charAt(end))\\n            return isPalindrome(str, start+1, end-1, chance);\\n        \\n        if(chance == 0) return false;\\n        \\n    return isPalindrome(str, start+1, end, chance-1)  || isPalindrome(str, start, end - 1,chance-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829341,
                "title": "java-90-o-n-solution-2-pointer",
                "content": "//Time: O(N)\\n//Space: O(1)\\n\\nclass Solution {\\n    \\n    public boolean validPalindrome(String s) {\\n        \\n        int i=0,j=s.length()-1;\\n        \\n        while(i<j)\\n        {\\n           if(s.charAt(i)!=s.charAt(j))         //Check if characters in the middle between (i+1 & j) OR (i & j-1) are palindromes\\n               return isPalindrome(s,i+1,j)||isPalindrome(s,i,j-1);\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isPalindrome(String s, int i, int j)\\n    {\\n        while(i<j)\\n        {\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n            \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    \\n    public boolean validPalindrome(String s) {\\n        \\n        int i=0,j=s.length()-1;\\n        \\n        while(i<j)\\n        {\\n           if(s.charAt(i)!=s.charAt(j))         //Check if characters in the middle between (i+1 & j) OR (i & j-1) are palindromes\\n               return isPalindrome(s,i+1,j)||isPalindrome(s,i,j-1);\\n            i++;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1733177,
                "title": "two-pointer-approach",
                "content": "```\\nclass Solution {\\n    \\n    public static boolean isPalindrome(String s, int i, int j){\\n        while(i < j){\\n            if(s.charAt(i) == s.charAt(j)){\\n                i++;\\n                j--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean validPalindrome(String s) {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        \\n        while(i < j){\\n            if(s.charAt(i) == s.charAt(j)){\\n                i++;\\n                j--;\\n            } else {\\n                //skip left OR skip right -> delete atmost one character\\n                return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static boolean isPalindrome(String s, int i, int j){\\n        while(i < j){\\n            if(s.charAt(i) == s.charAt(j)){\\n                i++;\\n                j--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean validPalindrome(String s) {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        \\n        while(i < j){\\n            if(s.charAt(i) == s.charAt(j)){\\n                i++;\\n                j--;\\n            } else {\\n                //skip left OR skip right -> delete atmost one character\\n                return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504710,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Intuition**\\nThis is a variation of the classic [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/) problem. We approach this problem the same way with a slight twist:\\n* We use 2 pointers at 2 ends of the string and move them inwards in tandem\\n* If at any point there is a mismatch, check if we have done a character removal in one of the previous iterations. If we **have not**, check if we can form a palindrome by either dropping the character at the left pointer or the character at the right pointer\\n\\n**Code**\\n```\\ndef isPalindrome(left, right, s, count):\\n\\twhile left < right:\\n\\t\\tif s[left] != s[right]:\\n\\t\\t\\tif count == 1:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\treturn isPalindrome(left + 1, right, s, count + 1) or isPalindrome(left, right - 1, s, count + 1)\\n\\t\\tleft += 1\\n\\t\\tright -= 1\\n\\treturn True\\n\\nreturn isPalindrome(0, len(s) - 1, s, 0)\\n```\\n\\nTime: O(Length of the string) | Space: O(1). We only recurse at most once, which means our recursion stack does not grow with the input",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isPalindrome(left, right, s, count):\\n\\twhile left < right:\\n\\t\\tif s[left] != s[right]:\\n\\t\\t\\tif count == 1:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\treturn isPalindrome(left + 1, right, s, count + 1) or isPalindrome(left, right - 1, s, count + 1)\\n\\t\\tleft += 1\\n\\t\\tright -= 1\\n\\treturn True\\n\\nreturn isPalindrome(0, len(s) - 1, s, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1310424,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        i,j = 0, len(s)-1\\n        \\n        while i < j:\\n            if s[i] != s[j]:\\n                return s[i+1:j+1] == s[i+1:j+1][::-1] or s[i:j] == s[i:j][::-1]\\n            i += 1\\n            j -= 1\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        i,j = 0, len(s)-1\\n        \\n        while i < j:\\n            if s[i] != s[j]:\\n                return s[i+1:j+1] == s[i+1:j+1][::-1] or s[i:j] == s[i:j][::-1]\\n            i += 1\\n            j -= 1\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975432,
                "title": "c-solution-68ms-solution",
                "content": "### T = O(n) & S = O(1)\\n```\\nclass Solution {\\npublic:\\n    bool palindrome(string A, int s, int e) {\\n        while(s<=e) {\\n            if(A[s] != A[e]) {\\n                return false;\\n            }\\n            s++;\\n            e--;\\n        }\\n        return true;\\n    }\\n    \\n    bool validPalindrome(string A) {\\n        int n = A.size();\\n        int s = 0;\\n        int e = n-1;\\n        \\n        while(s<=e) {\\n            if(A[s] != A[e]) {\\n                //delete s, check palindrome from s+1 to e\\n                // delete e, check palindrome from s to e-1\\n                // following above two cases\\n                if(palindrome(A, s+1, e) || palindrome(A, s, e-1)) return true;\\n                \\n                return false; // if no any case is not true\\n            }\\n            \\n            s++;\\n            e--;\\n        }\\n        \\n        // If already a palindrome\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool palindrome(string A, int s, int e) {\\n        while(s<=e) {\\n            if(A[s] != A[e]) {\\n                return false;\\n            }\\n            s++;\\n            e--;\\n        }\\n        return true;\\n    }\\n    \\n    bool validPalindrome(string A) {\\n        int n = A.size();\\n        int s = 0;\\n        int e = n-1;\\n        \\n        while(s<=e) {\\n            if(A[s] != A[e]) {\\n                //delete s, check palindrome from s+1 to e\\n                // delete e, check palindrome from s to e-1\\n                // following above two cases\\n                if(palindrome(A, s+1, e) || palindrome(A, s, e-1)) return true;\\n                \\n                return false; // if no any case is not true\\n            }\\n            \\n            s++;\\n            e--;\\n        }\\n        \\n        // If already a palindrome\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822606,
                "title": "swift-recursive-solution",
                "content": "Under time pressure, recursive solutions often feel like the most intuitive approaches to take. I initially attempted to solve this in simple while-loop by skipping either left or right pointer by one extra step (on error)  if the next character matches the character at the other end of the string. But obviously that was incorrect assumption (e.g. \"mlcuppuculm\") and I had to resort to using recursion.\\n```\\nclass Solution {\\n    func validPalindrome(_ s: String) -> Bool {\\n        if s.count <= 0 { return false }\\n        return checkPalindromiality(0, s.utf8CString.count - 2, s.utf8CString, false)\\n    }\\n\\n    func checkPalindromiality(_ left: Int, _ right: Int, _ s: ContiguousArray<CChar>, _ isReplacementUsed: Bool) -> Bool {\\n        if s[left] != s[right] {\\n            if isReplacementUsed { return false }\\n            // Try removing from left and right and see which one is better; notice we have \"used one replacement\"\\n            return checkPalindromiality(left + 1, right, s, true) || checkPalindromiality(left, right - 1, s, true)\\n        }\\n        if left >= right { return true }\\n        return checkPalindromiality(left + 1, right - 1, s, isReplacementUsed)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func validPalindrome(_ s: String) -> Bool {\\n        if s.count <= 0 { return false }\\n        return checkPalindromiality(0, s.utf8CString.count - 2, s.utf8CString, false)\\n    }\\n\\n    func checkPalindromiality(_ left: Int, _ right: Int, _ s: ContiguousArray<CChar>, _ isReplacementUsed: Bool) -> Bool {\\n        if s[left] != s[right] {\\n            if isReplacementUsed { return false }\\n            // Try removing from left and right and see which one is better; notice we have \"used one replacement\"\\n            return checkPalindromiality(left + 1, right, s, true) || checkPalindromiality(left, right - 1, s, true)\\n        }\\n        if left >= right { return true }\\n        return checkPalindromiality(left + 1, right - 1, s, isReplacementUsed)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731090,
                "title": "java-easy-to-understand-with-comments-including-follow-up-for-delete-upto-k-characters",
                "content": "```\\npublic boolean validPalindrome(String s) {\\n        int l = 0;\\n        int r = s.length() - 1;\\n\\n        // replace k with number of characters we are allowed to remove, here k = 1\\n        return checkPalindrome(l, r, s, 1);\\n    }\\n\\n    /**\\n     * \\n     * @param start Start Index\\n     * @param end End index\\n     * @param s String\\n     * @param k number of characters allowed to remove\\n     * @return\\n     */\\n    public boolean checkPalindrome(int start, int end, String s, int k){\\n        while(start <= end){\\n            if(s.charAt(start) != s.charAt(end)){\\n                // Base case : In case no characters are allowed to be removed\\n                if(k == 0) return false;\\n                \\n                // if we encounter a character mismatch, check for both the cases\\n                // case (i) increment start pointer\\n                // case (ii) decrement end pointer\\n                // and decrement k by 1;\\n                return (checkPalindrome(start + 1, end, s, k - 1)\\n                        || checkPalindrome(start, end - 1, s, k - 1));\\n            }\\n            \\n            start++;\\n            end--;\\n        }\\n\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean validPalindrome(String s) {\\n        int l = 0;\\n        int r = s.length() - 1;\\n\\n        // replace k with number of characters we are allowed to remove, here k = 1\\n        return checkPalindrome(l, r, s, 1);\\n    }\\n\\n    /**\\n     * \\n     * @param start Start Index\\n     * @param end End index\\n     * @param s String\\n     * @param k number of characters allowed to remove\\n     * @return\\n     */\\n    public boolean checkPalindrome(int start, int end, String s, int k){\\n        while(start <= end){\\n            if(s.charAt(start) != s.charAt(end)){\\n                // Base case : In case no characters are allowed to be removed\\n                if(k == 0) return false;\\n                \\n                // if we encounter a character mismatch, check for both the cases\\n                // case (i) increment start pointer\\n                // case (ii) decrement end pointer\\n                // and decrement k by 1;\\n                return (checkPalindrome(start + 1, end, s, k - 1)\\n                        || checkPalindrome(start, end - 1, s, k - 1));\\n            }\\n            \\n            start++;\\n            end--;\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 692686,
                "title": "javascript-while-loop-simple-o-n-o-1",
                "content": "\\n```\\nvar validPalindrome = function(s) {\\n    let i = 0;\\n    let j = s.length -1;\\n    \\n    let isPalindrome = function(s, i, j) {\\n        while (i < j) {\\n            if (s.charAt(i++) !== s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n        \\n    while (i < j) {\\n        if (s.charAt(i) !== s.charAt(j)) {\\n            return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1)\\n        }\\n        i++\\n        j--\\n    }\\n    \\n    return true;\\n};\\n```\\n\\nhttps://youtu.be/L_74qbyPHXE",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar validPalindrome = function(s) {\\n    let i = 0;\\n    let j = s.length -1;\\n    \\n    let isPalindrome = function(s, i, j) {\\n        while (i < j) {\\n            if (s.charAt(i++) !== s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n        \\n    while (i < j) {\\n        if (s.charAt(i) !== s.charAt(j)) {\\n            return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1)\\n        }\\n        i++\\n        j--\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 637636,
                "title": "python-two-pointer-easy-to-understand-solution-o-n",
                "content": "``` \\ndef validPalindrome(self, s: str) -> bool:\\n            if s==s[::-1]:\\n                return True\\n            else:\\n                i=0\\n                j=len(s)-1\\n                while(i<j):\\n                    if s[i]==s[j]:\\n                        i=i+1\\n                        j=j-1\\n                        continue\\n                    else:\\n                        p=s[0:j]+s[j+1:]\\n                        q=s[0:i]+s[i+1:]\\n                        break\\n                if p==p[::-1] or q==q[::-1]:\\n                    return True\\n                else:\\n                    return False",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` \\ndef validPalindrome(self, s: str) -> bool:\\n            if s==s[::-1]:\\n                return True\\n            else:\\n                i=0\\n                j=len(s)-1\\n                while(i<j):\\n                    if s[i]==s[j]:\\n                        i=i+1\\n                        j=j-1\\n                        continue\\n                    else:\\n                        p=s[0:j]+s[j+1:]\\n                        q=s[0:i]+s[i+1:]\\n                        break\\n                if p==p[::-1] or q==q[::-1]:\\n                    return True\\n                else:\\n                    return False",
                "codeTag": "Python3"
            },
            {
                "id": 632680,
                "title": "beats-100-simple-single-recursive-method-java",
                "content": "Here, canDelete is used to determine if one deletion is done or not. Initially it is true, which means we can still delete one character, after that if we delete one character, it would be false for next calls. \\nRecursive will be only used if case if left and right characters dont match. \\n\\n```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        return validPalindromeUtil(s,0,s.length()-1,true);\\n    }\\n    \\n    boolean validPalindromeUtil(String s,int l,int r,boolean canDelete){\\n      \\n        while(l < r) {\\n        if(s.charAt(l) == s.charAt(r)){\\n            l++;r--;\\n        }\\n        else if(canDelete){\\n            return validPalindromeUtil(s,l+1,r,false) || validPalindromeUtil(s,l,r-1,false);\\n        }\\n        else\\n            return false;\\n     }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        return validPalindromeUtil(s,0,s.length()-1,true);\\n    }\\n    \\n    boolean validPalindromeUtil(String s,int l,int r,boolean canDelete){\\n      \\n        while(l < r) {\\n        if(s.charAt(l) == s.charAt(r)){\\n            l++;r--;\\n        }\\n        else if(canDelete){\\n            return validPalindromeUtil(s,l+1,r,false) || validPalindromeUtil(s,l,r-1,false);\\n        }\\n        else\\n            return false;\\n     }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570499,
                "title": "easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        \\n        int start=0;\\n        int end=s.length()-1;\\n        \\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            {\\n                return checkPalindrome(start,end-1,s) || checkPalindrome(start+1,end,s);\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean checkPalindrome(int start, int end,String s)\\n    {\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        \\n        int start=0;\\n        int end=s.length()-1;\\n        \\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            {\\n                return checkPalindrome(start,end-1,s) || checkPalindrome(start+1,end,s);\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean checkPalindrome(int start, int end,String s)\\n    {\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 553236,
                "title": "java-very-short-solution-4-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        return isValid(s, 0, s.length()-1, true);\\n    }\\n    \\n    private boolean isValid(String s, int l, int r, boolean allowMistake) {\\n        for (; l < r; l++, r--) {\\n            if (s.charAt(l) != s.charAt(r)) {\\n                return allowMistake ? (isValid(s, l+1, r, false) || isValid(s, l, r-1, false)) : false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        return isValid(s, 0, s.length()-1, true);\\n    }\\n    \\n    private boolean isValid(String s, int l, int r, boolean allowMistake) {\\n        for (; l < r; l++, r--) {\\n            if (s.charAt(l) != s.charAt(r)) {\\n                return allowMistake ? (isValid(s, l+1, r, false) || isValid(s, l, r-1, false)) : false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423191,
                "title": "javascript-solution-without-helper-function-less-memory-than-100-faster-than-70",
                "content": "```\\nfunction validPalindrome(s,left = 0, right = s.length - 1, removedChars = 0) {\\n\\n    if (removedChars > 1){\\n        return false;\\n    }\\n\\n    while(left < right){\\n\\n        if (s[left] !== s[right]){\\n            return validPalindrome(s, left+1, right, removedChars+1) || validPalindrome(s, left, right-1, removedChars+1);\\n        }\\n\\n        left++;\\n        right--;\\n    }\\n\\n    return true;\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nfunction validPalindrome(s,left = 0, right = s.length - 1, removedChars = 0) {\\n\\n    if (removedChars > 1){\\n        return false;\\n    }\\n\\n    while(left < right){\\n\\n        if (s[left] !== s[right]){\\n            return validPalindrome(s, left+1, right, removedChars+1) || validPalindrome(s, left, right-1, removedChars+1);\\n        }\\n\\n        left++;\\n        right--;\\n    }\\n\\n    return true;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 265730,
                "title": "javascript-easy-and-fast",
                "content": "```js\\nfunction validPalindrome(str) {\\n  let start = 0;\\n  let end = str.length - 1;\\n\\n  while(start < end) {\\n    if(str[start] !== str[end]) {\\n\\t  //check both ways, slice here is not so intuitive\\n      return isValidYet(str.slice(start, end))\\n        || isValidYet(str.slice(start + 1, end + 1));\\n    }\\n\\n    start++;\\n    end--;\\n  }\\n\\n  return true;\\n}\\n\\n// just checking is regular palindrome\\nfunction isValidYet(s) {\\n  for(let i = 0; i < s.length / 2; i++) {\\n    if(s[i] !== s[s.length - 1 - i]) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction validPalindrome(str) {\\n  let start = 0;\\n  let end = str.length - 1;\\n\\n  while(start < end) {\\n    if(str[start] !== str[end]) {\\n\\t  //check both ways, slice here is not so intuitive\\n      return isValidYet(str.slice(start, end))\\n        || isValidYet(str.slice(start + 1, end + 1));\\n    }\\n\\n    start++;\\n    end--;\\n  }\\n\\n  return true;\\n}\\n\\n// just checking is regular palindrome\\nfunction isValidYet(s) {\\n  for(let i = 0; i < s.length / 2; i++) {\\n    if(s[i] !== s[s.length - 1 - i]) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 251519,
                "title": "c-97",
                "content": "```\\npublic class Solution {\\n    private bool flag = false;\\n    public bool ValidPalindrome(string s) {\\n        int i = 0, j = s.Length - 1;\\n        \\n        while(i < j){\\n            if(s[i] == s[j]){\\n                i++;j--;\\n            }else{\\n                if(flag) return false;\\n                \\n                flag = true;\\n                \\n                return ValidPalindrome(s.Substring(i, j - i)) || ValidPalindrome(s.Substring(i + 1, j - i));\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private bool flag = false;\\n    public bool ValidPalindrome(string s) {\\n        int i = 0, j = s.Length - 1;\\n        \\n        while(i < j){\\n            if(s[i] == s[j]){\\n                i++;j--;\\n            }else{\\n                if(flag) return false;\\n                \\n                flag = true;\\n                \\n                return ValidPalindrome(s.Substring(i, j - i)) || ValidPalindrome(s.Substring(i + 1, j - i));\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153478,
                "title": "swift-4-1-2",
                "content": "```\\nclass Solution {\\n    func validPalindrome(_ s: String) -> Bool {\\n        if s.isEmpty {\\n            return true\\n        }\\n        \\n        var start = s.startIndex\\n        var end = s.index(before: s.endIndex)\\n        while start < end {\\n            if s[start] != s[end] {\\n                if isValid(String(s[start...s.index(before: end)])) || isValid(String(s[s.index(after: start)...end])) {\\n                    return true\\n                }\\n                return false\\n            }\\n            start = s.index(after: start)\\n            end = s.index(before: end)\\n        }\\n        return true\\n    }\\n    \\n    func isValid(_ s: String) -> Bool {\\n        var start = s.startIndex\\n        var end = s.index(before: s.endIndex)\\n        while start < end {\\n            if s[start] != s[end] {\\n                return false\\n            }\\n            start = s.index(after: start)\\n            end = s.index(before: end)\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func validPalindrome(_ s: String) -> Bool {\\n        if s.isEmpty {\\n            return true\\n        }\\n        \\n        var start = s.startIndex\\n        var end = s.index(before: s.endIndex)\\n        while start < end {\\n            if s[start] != s[end] {\\n                if isValid(String(s[start...s.index(before: end)])) || isValid(String(s[s.index(after: start)...end])) {\\n                    return true\\n                }\\n                return false\\n            }\\n            start = s.index(after: start)\\n            end = s.index(before: end)\\n        }\\n        return true\\n    }\\n    \\n    func isValid(_ s: String) -> Bool {\\n        var start = s.startIndex\\n        var end = s.index(before: s.endIndex)\\n        while start < end {\\n            if s[start] != s[end] {\\n                return false\\n            }\\n            start = s.index(after: start)\\n            end = s.index(before: end)\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334947,
                "title": "c-beats-98-90-two-pointers-very-simple-solution-o-n",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool isPalindrom(char* left, char* right) {\\n    while (left < right) {\\n        if (*left++ != *right--) return false;\\n    }\\n\\n    return true;\\n}\\n\\nbool validPalindrome(char* s) {\\n    char* left = s;\\n    char* right = s + strlen(s) - 1;\\n\\n    while (left < right) {\\n        if (*left == *right) {\\n            left++;\\n            right--;\\n        } else {\\n            return isPalindrom(left + 1, right) || isPalindrom(left, right - 1);\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nbool isPalindrom(char* left, char* right) {\\n    while (left < right) {\\n        if (*left++ != *right--) return false;\\n    }\\n\\n    return true;\\n}\\n\\nbool validPalindrome(char* s) {\\n    char* left = s;\\n    char* right = s + strlen(s) - 1;\\n\\n    while (left < right) {\\n        if (*left == *right) {\\n            left++;\\n            right--;\\n        } else {\\n            return isPalindrom(left + 1, right) || isPalindrom(left, right - 1);\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2469594,
                "title": "c-fast-solution-680-valid-palindrome-ii",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    bool validPalindrome(string s) \\n    {\\n        \\n        int i=0;\\n        int j=s.length()-1;\\n        \\n        int count=0;\\n        \\n        while(i<=j)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                i++;\\n                count++;\\n            }\\n        }\\n        \\n        if(count<=1)\\n        {\\n            return true;\\n        }\\n        \\n        count=0;\\n        i=0;\\n        j=s.length()-1;\\n        \\n        while(i<=j)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                j--;\\n                count++;\\n            }\\n        }\\n        \\n        if(count<=1)\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool validPalindrome(string s) \\n    {\\n        \\n        int i=0;\\n        int j=s.length()-1;\\n        \\n        int count=0;\\n        \\n        while(i<=j)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                i++;\\n                j--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2202705,
                "title": "javascript-two-pointers",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nconst validPalindrome = (s) => {\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left<right){\\n        if(s.charAt(left)==s.charAt(right)){\\n            left++;\\n            right--;\\n        }\\n        if(s.charAt(left)!=s.charAt(right)){\\n            return checkPalindrome(s,left+1,right) || checkPalindrome(s,left,right-1);\\n        }\\n    }\\n    return true;\\n};\\n\\nconst checkPalindrome = (s,i,j) => {\\n    let left = i;\\n    let right = j;\\n    while(left<right){\\n        if(s.charAt(left)==s.charAt(right)){\\n            left++;\\n            right--;\\n        }\\n        if(s.charAt(left)!=s.charAt(right)){\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nconst validPalindrome = (s) => {\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left<right){\\n        if(s.charAt(left)==s.charAt(right)){\\n            left++;\\n            right--;\\n        }\\n        if(s.charAt(left)!=s.charAt(right)){\\n            return checkPalindrome(s,left+1,right) || checkPalindrome(s,left,right-1);\\n        }\\n    }\\n    return true;\\n};\\n\\nconst checkPalindrome = (s,i,j) => {\\n    let left = i;\\n    let right = j;\\n    while(left<right){\\n        if(s.charAt(left)==s.charAt(right)){\\n            left++;\\n            right--;\\n        }\\n        if(s.charAt(left)!=s.charAt(right)){\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907535,
                "title": "valid-palindrome-2-python-beats-81-12-two-pointers",
                "content": "Recursive Solution:- \\n\\n```\\nclass Solution:\\n    def palindrome(s,l,r):\\n            while(l<r):\\n                if s[l]!=s[r]:\\n                    return False\\n                l+=1\\n                r-=1\\n            return True    \\n                \\n    def validPalindrome(self, s: str) -> bool:\\n        \\n        if s==s[::-1]:\\n            return True\\n        l = 0\\n        r = len(s)-1\\n        \\n        while(l<r):\\n            if s[l]==s[r]:\\n                l+=1\\n                r-=1\\n                \\n            elif s[l]!=s[r]:\\n                return Solution.palindrome(s,l+1,r) or Solution.palindrome(s,l,r-1)\\n```\\t\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def palindrome(s,l,r):\\n            while(l<r):\\n                if s[l]!=s[r]:\\n                    return False\\n                l+=1\\n                r-=1\\n            return True    \\n                \\n    def validPalindrome(self, s: str) -> bool:\\n        \\n        if s==s[::-1]:\\n            return True\\n        l = 0\\n        r = len(s)-1\\n        \\n        while(l<r):\\n            if s[l]==s[r]:\\n                l+=1\\n                r-=1\\n                \\n            elif s[l]!=s[r]:\\n                return Solution.palindrome(s,l+1,r) or Solution.palindrome(s,l,r-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906369,
                "title": "c-two-pointer-explanation",
                "content": "# Explanation \\nWe can ues two pointer to check Palindrom s. But in our problem we can allow one error.\\nThat\\'s mean when string s is not palindrom but it is when delete one element, then we \\nshould return true.\\n\\nWhen we use two pointer method to check palindrom, and meet first L,R s.t. \\ns[L] != s[R], then we have to way to do. \\ncase 1: delete s[L] and keep going to check palindrom. \\ncase 2: delete s[R] and then keep going to check palindrom. \\n\\nIf case 1 or case 2 can be passed , then our function should return true.\\n\\n# Source Code\\n```C++\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int L=0,R = s.length()-1;\\n        while(L<R) {\\n            if(s[R]!=s[L]) {\\n                int L1=L+1, R1=R;\\n                int L2=L,R2=R-1;\\n                bool case1=true, case2=true;\\n                while(L1<R1){\\n                    if(s[R1]!=s[L1]) {\\n                        case1=false;\\n                        break;\\n                    }\\n                    R1--;L1++;\\n                }\\n                while(L2<R2){\\n                    if(s[R2]!=s[L2]) {\\n                        case2=false;\\n                        break;\\n                    }\\n                    R2--;L2++;\\n                }\\n                return case1||case2;\\n            }            \\n            R--;L++;\\n        }       \\n        return true;\\n    }};\\n```\\n\\nIf you want to simplify the code, it would be \\n```C++\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int L=0,R = s.length()-1;\\n        while(L<R) {\\n            if(s[R--]!=s[L++]) {                \\n                //case 1\\n                int L1=L, R1=R+1;\\n                while(L1<=R1) if(s[R1--]!=s[L1++]) break;\\n                bool case1 = s[R1+1]==s[L1-1];\\n                //case 2\\n                int L2=L-1,R2=R;\\n                while(L2<=R2) if(s[R2--]!=s[L2++]) break;\\n                bool case2 = s[R2+1]==s[L2-1];\\n\\t\\t\\t\\t\\n                return case1||case2;\\n            }            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int L=0,R = s.length()-1;\\n        while(L<R) {\\n            if(s[R]!=s[L]) {\\n                int L1=L+1, R1=R;\\n                int L2=L,R2=R-1;\\n                bool case1=true, case2=true;\\n                while(L1<R1){\\n                    if(s[R1]!=s[L1]) {\\n                        case1=false;\\n                        break;\\n                    }\\n                    R1--;L1++;\\n                }\\n                while(L2<R2){\\n                    if(s[R2]!=s[L2]) {\\n                        case2=false;\\n                        break;\\n                    }\\n                    R2--;L2++;\\n                }\\n                return case1||case2;\\n            }            \\n            R--;L++;\\n        }       \\n        return true;\\n    }};\\n```\n```C++\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int L=0,R = s.length()-1;\\n        while(L<R) {\\n            if(s[R--]!=s[L++]) {                \\n                //case 1\\n                int L1=L, R1=R+1;\\n                while(L1<=R1) if(s[R1--]!=s[L1++]) break;\\n                bool case1 = s[R1+1]==s[L1-1];\\n                //case 2\\n                int L2=L-1,R2=R;\\n                while(L2<=R2) if(s[R2--]!=s[L2++]) break;\\n                bool case2 = s[R2+1]==s[L2-1];\\n\\t\\t\\t\\t\\n                return case1||case2;\\n            }            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905793,
                "title": "python-easy-solution-beats-100",
                "content": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        if s == s[::-1]:\\n            return True\\n        p = len(s) - 1\\n        for i in range(len(s) // 2):\\n            if s[i] != s[p]:\\n                temp1 = s[:i] + s[i+1:]\\n                temp2 = s[:p] + s[p+1:]\\n                if temp1 == temp1[::-1] or temp2 == temp2[::-1]:\\n                    return True\\n                break\\n            p -= 1\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        if s == s[::-1]:\\n            return True\\n        p = len(s) - 1\\n        for i in range(len(s) // 2):\\n            if s[i] != s[p]:\\n                temp1 = s[:i] + s[i+1:]\\n                temp2 = s[:p] + s[p+1:]\\n                if temp1 == temp1[::-1] or temp2 == temp2[::-1]:\\n                    return True\\n                break\\n            p -= 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905017,
                "title": "using-two-pointers-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool flag = 0;\\n    bool validPalindrome(string s) {\\n        return helper(s, 0, s.size() - 1);\\n    }\\n    \\n    bool helper(string &s, int l, int r) {\\n        if(l >= r)\\n            return true;\\n        \\n        // same\\n        if(s[l] == s[r])\\n            return helper(s, l+1, r-1);\\n        // Not same for 2nd time\\n        if(flag)\\n            return false;\\n        // not same for first time\\n        flag = 1;\\n        return helper(s, l+1, r) || helper(s, l, r-1);\\n    }\\n    \\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool flag = 0;\\n    bool validPalindrome(string s) {\\n        return helper(s, 0, s.size() - 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1636529,
                "title": "java-dfs-5-lines-should-be-medium",
                "content": "I remember trying to bruteforce this question 2 months ago when I first started leetcoding and no matter what I did, it always TLE, so I just ignored it until finally today, I\\'ve learned all the commonly used data structure, and decided to give it another shot. \\n\\nGreedily advacing one of the invalid indexes does not work for test case 461 / 467 `\"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga\"`, so I resorted to DFS at most 2 layers instead and it passed with 90% speed.\\n\\nHonestly tho, if bruteforce solution isn\\'t getting accepted, it should be medium. I\\'ve done 700 questions in the past two months and feel there are some easy hards / medium that are easier than this question.\\n```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        return check(s.toCharArray(), 0, s.length() - 1, 0);\\n    }\\n\\n    private boolean check(char[] arr, int lo, int hi, int count){\\n        while(lo < hi){\\n            if (arr[lo] == arr[hi]) {lo++; hi--; continue;}\\n            if (++count == 2) return false;\\n            if (check(arr, lo + 1, hi, count) || check(arr, lo, hi - 1, count)) return true;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        return check(s.toCharArray(), 0, s.length() - 1, 0);\\n    }\\n\\n    private boolean check(char[] arr, int lo, int hi, int count){\\n        while(lo < hi){\\n            if (arr[lo] == arr[hi]) {lo++; hi--; continue;}\\n            if (++count == 2) return false;\\n            if (check(arr, lo + 1, hi, count) || check(arr, lo, hi - 1, count)) return true;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596099,
                "title": "using-two-is-valid-palindrome-to-solve-this-i-got-this-in-a-fb-phone-interview",
                "content": "```\\nclass Solution(object):\\n    def validPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def validPalindromeRemove(s, r, l,i):\\n            if l==i:\\n                l+=1\\n            elif r == i:\\n                r-=1\\n            while l<r:\\n                if s[l]!=s[r]:\\n                    return False\\n                l+=1\\n                r-=1\\n            return True\\n        \\n        l = 0 \\n        r = len(s)-1\\n        while l<r:\\n            if s[l] != s[r]:\\n                return validPalindromeRemove(s, r, l, r) or validPalindromeRemove(s, r, l, l)\\n            l+=1\\n            r-=1\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def validPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def validPalindromeRemove(s, r, l,i):\\n            if l==i:\\n                l+=1\\n            elif r == i:\\n                r-=1\\n            while l<r:\\n                if s[l]!=s[r]:\\n                    return False\\n                l+=1\\n                r-=1\\n            return True\\n        \\n        l = 0 \\n        r = len(s)-1\\n        while l<r:\\n            if s[l] != s[r]:\\n                return validPalindromeRemove(s, r, l, r) or validPalindromeRemove(s, r, l, l)\\n            l+=1\\n            r-=1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251708,
                "title": "c-easy-to-understand",
                "content": "In regular palindrome check, you can use a two pointer approach, i.e. p1 goes from begining to end and p2 vice versa and each time you check: ``` s[p1] == s[p2] ```\\nIts a similar idea here, except when you reach the first occurance of different character, you have to decide which character you should remove? You have to consider both cases, if any of them works, then it is a correct answer.\\n\\n```\\n    // Scan the array, look for the first occurance\\n    // of where the characters are not equal, like this: \"z****k\"\\n    // then here we have two choices, either to remove \\'z\\', so to evaluate the \"****k\" string\\n    // or remove \\'k\\' and evaluate the \"z****\" string\\n    \\n    bool isPalindrome(string s, int p1, int p2) {\\n        while(p1 < p2) {\\n            if(s[p1] == s[p2]) {\\n                ++p1;\\n                --p2;\\n            } else\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n\\t// Time: O(N), Space: O(1)\\n    bool validPalindrome(string s) {\\n\\n        int p1 = 0;\\n        int p2 = s.size() - 1;\\n\\n        while(p1 < p2) {\\n            if(s[p1] != s[p2]) {\\n                \\n                // Either remove the character in p1 (so move p1 to p1 + 1)\\n                // or remvoe the character in p2 (so move p2 to p2 - 1)\\n\\t\\t\\t\\t// if any of these two cases forms a palindrom, it is still a correct answer\\n                bool case1 = isPalindrome(s, p1 + 1, p2);\\n                bool case2 = isPalindrome(s, p1, p2 - 1);\\n                return case1 || case2;\\n\\n            } else {\\n                ++p1;\\n                --p2;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` s[p1] == s[p2] ```\n```\\n    // Scan the array, look for the first occurance\\n    // of where the characters are not equal, like this: \"z****k\"\\n    // then here we have two choices, either to remove \\'z\\', so to evaluate the \"****k\" string\\n    // or remove \\'k\\' and evaluate the \"z****\" string\\n    \\n    bool isPalindrome(string s, int p1, int p2) {\\n        while(p1 < p2) {\\n            if(s[p1] == s[p2]) {\\n                ++p1;\\n                --p2;\\n            } else\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n\\t// Time: O(N), Space: O(1)\\n    bool validPalindrome(string s) {\\n\\n        int p1 = 0;\\n        int p2 = s.size() - 1;\\n\\n        while(p1 < p2) {\\n            if(s[p1] != s[p2]) {\\n                \\n                // Either remove the character in p1 (so move p1 to p1 + 1)\\n                // or remvoe the character in p2 (so move p2 to p2 - 1)\\n\\t\\t\\t\\t// if any of these two cases forms a palindrom, it is still a correct answer\\n                bool case1 = isPalindrome(s, p1 + 1, p2);\\n                bool case2 = isPalindrome(s, p1, p2 - 1);\\n                return case1 || case2;\\n\\n            } else {\\n                ++p1;\\n                --p2;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110833,
                "title": "a-different-approach-recursion-without-extra-function",
                "content": "```\\nclass Solution:\\n    def validPalindrome(self, s: str,outlier_removed=False) -> bool:\\n        l,r=0,len(s)-1\\n        while l<r:\\n            if s[l] != s[r]:\\n                if outlier_removed: return False\\n                return self.validPalindrome(s[l:r],True) or self.validPalindrome(s[l+1:r+1],True)\\n            l+=1\\n            r-=1\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str,outlier_removed=False) -> bool:\\n        l,r=0,len(s)-1\\n        while l<r:\\n            if s[l] != s[r]:\\n                if outlier_removed: return False\\n                return self.validPalindrome(s[l:r],True) or self.validPalindrome(s[l+1:r+1],True)\\n            l+=1\\n            r-=1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1093408,
                "title": "for-anyone-stuck-at-test-case-458-o-n-time-o-1-space",
                "content": "After one read of this problem the first impression was to do simple pallindrome check with an exception that we are allowed at 1 mismatch.\\n\\nSo the intital thought process was (which was incorrect):\\n\\n1) Intitalize start=0 and end=size-1.\\n2) If the elements at start and end are equal then increment start and decrement end.\\n3) Otherwise maintain a flag to keep a check on threshold (i.e 1 mismatch). If threshold not exceeded: \\n\\t3.1)  Check if (s[ start+1] and s[end]) are same if yes then  continue the loop  from[start+1,end].\\n\\t3.2) Otherwise if (s[start] and s[end-1]) are same then continue the loop from [start,end-1].\\n\\t3.3) Otherwise return false.\\n4) If we have exceeded threshold we return false.\\n\\nThis was the first code i came up with:\\n\\n```\\nbool validPalindrome(string s) {\\n        \\n        int size=s.size();\\n        int start=0,end=size-1;\\n\\t\\tbool thresh=false; // showing that threshold not reached\\n        \\n        while(start<end){\\n            if(s[start]==s[end]){\\n                start++;\\n                end--;\\n            }\\n            \\n            else if(!thresh){ // if we have first mismatch\\n\\t\\t\\t\\n                if(s[start+1]==s[end]){\\n                    start++; // continue the while loop from [start+1,end]\\n                    thresh=true; // one mismatch seen\\n                }\\n                \\n                else if(s[end-1]==s[start]){\\n                    end--; // continue the while loop from [start,end-1]\\n                    thresh=true; // one mismatch seen\\n                }\\n                \\n                else{  // neither of the two [start+1,end] or [start,end-1] are same\\n                    return false;\\n                }\\n            }\\n            \\n            else{  // 2nd mismatch\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\n```\\n\\t\\nThis passed 458 of the 460 test cases, but the test case which failed kind of annoyed me because:\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/d477eef6-d3de-45c4-acdd-5f935bf5f005_1614877680.708844.png)\\n\\na 100 sized string.....  How on earth could I debug for this case.\\n\\nSo after a long brainstorm, a friend of mine suggested a case where my code will fail: **s=\"adccdca\".**\\n\\nwhy?\\t\\t\\nwhen at start=1 (1st d from left) and end=5(1st c from right) we were checking if s[start+1]==s[end] ? yes so continue from [2,5] which is \"ccdc\" string and this is not a pallindrome (as threshold is exhausted).\\nInstead from [1,4] which is \"dccd\" is a pallindrome.\\n\\t\\t\\n**Conclusion** - At the mismatch we need to check string from both [start+1,end] and [start,end-1] and if any one them is pallindrome we return true. \\n\\t\\t\\nSo finally the correct version:\\n\\n```\\n    bool validPalindrome(string s) {\\n        \\n        int size=s.size();\\n        int start=0,end=size-1,count=0;\\n        \\n        while(start<end){\\n\\t\\t\\n            if(s[start]==s[end]){\\n                start++;\\n                end--;\\n            }\\n            \\n            else{\\n\\n                int first_start=start+1,first_end=end; // if start is deleted\\n                int second_start=start,second_end=end-1; // if end is deleted\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check pallindrome from start+1 to end\\n                while(first_start<first_end && s[first_start]==s[first_end]){ \\n                    first_start++;\\n                    first_end--;\\n                }\\n\\t\\t\\t\\n\\t\\t\\t\\t// check pallindrome from start to end-1\\n                while(second_start<second_end && s[second_start]==s[second_end]){ /\\n                    second_start++;\\n                    second_end--;\\n                }\\n\\n                return ((first_start>=first_end) || (second_start>=second_end));  // if anyone of the two scans are complete \\n            }\\n        }\\n        // the whole string is pallindrome\\n        return true;\\n    }\\n\\n```\\n\\t\\nPs - In my opinion an easy question though but the test cases are poor (an easier TC could have been provided to show the failiure of trivial solution). \\n\\nHope this helps!!!\\n\\n\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n",
                "solutionTags": [],
                "code": "```\\nbool validPalindrome(string s) {\\n        \\n        int size=s.size();\\n        int start=0,end=size-1;\\n\\t\\tbool thresh=false; // showing that threshold not reached\\n        \\n        while(start<end){\\n            if(s[start]==s[end]){\\n                start++;\\n                end--;\\n            }\\n            \\n            else if(!thresh){ // if we have first mismatch\\n\\t\\t\\t\\n                if(s[start+1]==s[end]){\\n                    start++; // continue the while loop from [start+1,end]\\n                    thresh=true; // one mismatch seen\\n                }\\n                \\n                else if(s[end-1]==s[start]){\\n                    end--; // continue the while loop from [start,end-1]\\n                    thresh=true; // one mismatch seen\\n                }\\n                \\n                else{  // neither of the two [start+1,end] or [start,end-1] are same\\n                    return false;\\n                }\\n            }\\n            \\n            else{  // 2nd mismatch\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\n```\n```\\n    bool validPalindrome(string s) {\\n        \\n        int size=s.size();\\n        int start=0,end=size-1,count=0;\\n        \\n        while(start<end){\\n\\t\\t\\n            if(s[start]==s[end]){\\n                start++;\\n                end--;\\n            }\\n            \\n            else{\\n\\n                int first_start=start+1,first_end=end; // if start is deleted\\n                int second_start=start,second_end=end-1; // if end is deleted\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// check pallindrome from start+1 to end\\n                while(first_start<first_end && s[first_start]==s[first_end]){ \\n                    first_start++;\\n                    first_end--;\\n                }\\n\\t\\t\\t\\n\\t\\t\\t\\t// check pallindrome from start to end-1\\n                while(second_start<second_end && s[second_start]==s[second_end]){ /\\n                    second_start++;\\n                    second_end--;\\n                }\\n\\n                return ((first_start>=first_end) || (second_start>=second_end));  // if anyone of the two scans are complete \\n            }\\n        }\\n        // the whole string is pallindrome\\n        return true;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 809638,
                "title": "c-simple-o-n-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/valid-palindrome-ii/submissions/\\n*/\\n\\nclass Solution {\\n\\npublic:\\n    // Checks if string is a palindrome\\n    bool isPalin(string &s, int start, int end) {\\n        while(start < end) {\\n            if(s[start] != s[end])\\n                return false;\\n            ++start, --end;\\n        }\\n        return true;\\n    }\\n    \\n    // TC: O(N)\\n    // SC: O(1)\\n    bool validPalindrome(string s) {\\n        for(int i = 0, j = s.size()-1; i < j;  ++i, --j) {\\n            // mismatch found, only if it is the first time delete\\n            // a char and move on, else not possible\\n            if(s[i] != s[j]) {\\n                // s[0:i-1] and s[j+1, n-1] matched,\\n                // now we check if atleast s[i:j-1] or s[i+1:j] is a palindrome\\n                return (isPalin(s, i, j-1) || isPalin(s, i+1, j));\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/valid-palindrome-ii/submissions/\\n*/\\n\\nclass Solution {\\n\\npublic:\\n    // Checks if string is a palindrome\\n    bool isPalin(string &s, int start, int end) {\\n        while(start < end) {\\n            if(s[start] != s[end])\\n                return false;\\n            ++start, --end;\\n        }\\n        return true;\\n    }\\n    \\n    // TC: O(N)\\n    // SC: O(1)\\n    bool validPalindrome(string s) {\\n        for(int i = 0, j = s.size()-1; i < j;  ++i, --j) {\\n            // mismatch found, only if it is the first time delete\\n            // a char and move on, else not possible\\n            if(s[i] != s[j]) {\\n                // s[0:i-1] and s[j+1, n-1] matched,\\n                // now we check if atleast s[i:j-1] or s[i+1:j] is a palindrome\\n                return (isPalin(s, i, j-1) || isPalin(s, i+1, j));\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776647,
                "title": "c-solution",
                "content": "```\\n\\nbool isPalindrome(char *s,int i,int j)\\n{\\n    while(i<j)\\n    {\\n        if(s[i]!=s[j])\\n            return 0;\\n        i++;j--;\\n    }\\n    return 1;\\n}\\nbool validPalindrome(char * s){\\n    int i=0,j=strlen(s)-1;\\n    while(i<j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return isPalindrome(s,i+1,j)||isPalindrome(s,i,j-1);\\n        }\\n        i++;j--;\\n    }\\n    return 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nbool isPalindrome(char *s,int i,int j)\\n{\\n    while(i<j)\\n    {\\n        if(s[i]!=s[j])\\n            return 0;\\n        i++;j--;\\n    }\\n    return 1;\\n}\\nbool validPalindrome(char * s){\\n    int i=0,j=strlen(s)-1;\\n    while(i<j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return isPalindrome(s,i+1,j)||isPalindrome(s,i,j-1);\\n        }\\n        i++;j--;\\n    }\\n    return 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 773121,
                "title": "java-if-you-can-delete-at-most-k",
                "content": "~~~java\\n\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        if (s == null || s.isEmpty()) {\\n            return true;\\n        }\\n        \\n        return helper(s, 0, s.length() - 1, 1);\\n    }\\n    \\n    private boolean helper(String s, int i, int j, int k) {\\n        if (j <= i) {\\n            return true;\\n        }\\n        \\n        while (i < j) {\\n            if (s.charAt(i) == s.charAt(j)) {\\n                i++;\\n                j--;\\n            } else {\\n                if (k == 0) {\\n                    return false;\\n                }\\n                return helper(s, i + 1, j, k - 1) || helper(s, i, j - 1, k - 1);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean validPalindrome(String s) {\\n        if (s == null || s.isEmpty()) {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 767532,
                "title": "rust-cheapest-best",
                "content": "```\\nimpl Solution {\\n    pub fn valid_palindrome(s: String) -> bool {\\n        let chars = s.chars().collect::<Vec<char>>();\\n        let (mut left, mut right) = (0, s.len() - 1);\\n        while left < right {\\n            if chars[left] != chars[right] {\\n                let (l, r) = (&chars[left..right], &chars[left + 1..right + 1]);\\n                return (0..l.len()).all(|i| l[i] == l[l.len() - 1 - i])\\n                    || (0..r.len()).all(|i| r[i] == r[r.len() - 1 - i]);\\n            }\\n            left += 1;\\n            right -= 1;\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn valid_palindrome(s: String) -> bool {\\n        let chars = s.chars().collect::<Vec<char>>();\\n        let (mut left, mut right) = (0, s.len() - 1);\\n        while left < right {\\n            if chars[left] != chars[right] {\\n                let (l, r) = (&chars[left..right], &chars[left + 1..right + 1]);\\n                return (0..l.len()).all(|i| l[i] == l[l.len() - 1 - i])\\n                    || (0..r.len()).all(|i| r[i] == r[r.len() - 1 - i]);\\n            }\\n            left += 1;\\n            right -= 1;\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374439,
                "title": "java-recursive-2-pointers-6-ms-clean",
                "content": "We are checking for palindrome with 2 pointers, starting from ends going toward center. We keep advancing pointers until they became equal - this means string is a palindrome.\\n\\nIf chars under pointers are not equal - we can do one deletion. To tack deletion event we use boolean flag. In case of pointers this means - skip the char. Because we don\\'t know which character to delete we make a fork here - we try both left and right deletion simultaneously. Also we flip the flag, so next time we\\'ll met different charcters - we break from the method.\\n\\nBecause it\\'s possible to get a palindrome from both left and right deletion we join result of both recursions via OR.\\n\\n```\\n  public boolean validPalindrome(String s) {\\n    return helper(s, 0, s.length() - 1, true);\\n  }\\n\\n  private boolean helper(String s, int l, int r, boolean okRemove) {\\n\\t//base case - pointer met, our string is a palindrome\\n    if (l >= r)\\n      return true;\\n\\t//check if chars are same - palindrome is possible, advancing to the center\\n    if (s.charAt(l) == s.charAt(r))\\n      return helper(s, l + 1, r - 1, okRemove);\\n    else\\n\\t  //if chars are different - skip one or another, set remove flag to false\\n      return okRemove && (helper(s, l + 1, r, false) || helper(s, l, r - 1, false));\\n  }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```\\n  public boolean validPalindrome(String s) {\\n    return helper(s, 0, s.length() - 1, true);\\n  }\\n\\n  private boolean helper(String s, int l, int r, boolean okRemove) {\\n\\t//base case - pointer met, our string is a palindrome\\n    if (l >= r)\\n      return true;\\n\\t//check if chars are same - palindrome is possible, advancing to the center\\n    if (s.charAt(l) == s.charAt(r))\\n      return helper(s, l + 1, r - 1, okRemove);\\n    else\\n\\t  //if chars are different - skip one or another, set remove flag to false\\n      return okRemove && (helper(s, l + 1, r, false) || helper(s, l, r - 1, false));\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237511,
                "title": "python-solution",
                "content": "Idea: Initialize two pointers `i = 0`, `j = len(s)-1`. `while i < j`, we check if `s[i] == s[j]`. If `Ture`, we move `i` and `j` one step towards the middle: `i += 1, j -= 1`; Else `s` cannot be a palindrome, but it is possible that it is a palindrome after deleting either `s[i]`, or `s[j]`. Thus we need to check if either `s[i+1:j+1]` or `s[i:j]` is a palindrome. If either is `True`, we return `True`; Else we return `False`. We finished the while loop, it means that `s` itself is a palindrome, and we return `True`.\\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def validPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def check_palindrome(i, j):\\n            if i >= j:\\n                return True\\n            while i < j:\\n                if s[i] == s[j]:\\n                    i += 1\\n                    j -= 1\\n                else:\\n                    return False\\n            return True\\n        \\n        i = 0\\n        j = len(s)-1\\n        while i < j:\\n            if s[i] == s[j]:\\n                i += 1\\n                j -= 1\\n            else:\\n                if check_palindrome(i+1, j) or check_palindrome(i, j-1):\\n                    return True\\n                else:\\n                    return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def validPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def check_palindrome(i, j):\\n            if i >= j:\\n                return True\\n            while i < j:\\n                if s[i] == s[j]:\\n                    i += 1\\n                    j -= 1\\n                else:\\n                    return False\\n            return True\\n        \\n        i = 0\\n        j = len(s)-1\\n        while i < j:\\n            if s[i] == s[j]:\\n                i += 1\\n                j -= 1\\n            else:\\n                if check_palindrome(i+1, j) or check_palindrome(i, j-1):\\n                    return True\\n                else:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194511,
                "title": "python-2-pointer-recursive-o-n-time-o-1-space",
                "content": "Also generalized for arbitrary number of allowed deletions\\n\\n```\\nclass Solution(object):\\n    def validPalindrome(self, s, allowed_deletions=1):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n\\n        i = 0\\n        j = len(s) - 1\\n\\n        while i < j:\\n            if s[i] != s[j]:\\n                if not allowed_deletions:\\n                    return False\\n                \\n                return (\\n                    self.validPalindrome(s[i+1:j+1], allowed_deletions-1)\\n                    or\\n                    self.validPalindrome(s[i:j], allowed_deletions-1)\\n                )\\n\\n            i += 1\\n            j -= 1\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def validPalindrome(self, s, allowed_deletions=1):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n\\n        i = 0\\n        j = len(s) - 1\\n\\n        while i < j:\\n            if s[i] != s[j]:\\n                if not allowed_deletions:\\n                    return False\\n                \\n                return (\\n                    self.validPalindrome(s[i+1:j+1], allowed_deletions-1)\\n                    or\\n                    self.validPalindrome(s[i:j], allowed_deletions-1)\\n                )\\n\\n            i += 1\\n            j -= 1\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189969,
                "title": "understanding-python-solution",
                "content": "```\ndef validPalindrome(self, s):\n        i=0\n        j=len(s)-1\n        while i<j and s[i]==s[j]:\n            i+=1\n            j-=1\n        \n        r=s[:i]+s[i+1:]\n        r1=s[:j]+s[j+1:]\n        return r==r[::-1] or r1==r1[::-1]\n```",
                "solutionTags": [],
                "code": "```\ndef validPalindrome(self, s):\n        i=0\n        j=len(s)-1\n        while i<j and s[i]==s[j]:\n            i+=1\n            j-=1\n        \n        r=s[:i]+s[i+1:]\n        r1=s[:j]+s[j+1:]\n        return r==r[::-1] or r1==r1[::-1]\n```",
                "codeTag": "Python3"
            },
            {
                "id": 147892,
                "title": "c-easy-to-understand-intuitive-solution-with-explanation-accepted",
                "content": "**Basic Idea:**\\n*  If s[i] == s[j] **->** i++; j--. \\n* Otherwise, the palindrome must be either \\n\\t* s[i+1], s[i+2], ..., s[j] or \\n\\t* s[i], s[i+1], ..., s[j-1] \\n```\\npublic class Solution {\\n    public bool ValidPalindrome(string s) {\\n        int left = 0;\\n        int right = s.Length - 1;\\n        while (left < right) {\\n            if (s[left] != s[right])\\n                return ValidPalindrome(s, left + 1, right) || ValidPalindrome(s, left, right - 1);\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n    private static bool ValidPalindrome(string s, int left, int right) {\\n        while (left < right) {\\n            if (s[left++] != s[right--])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool ValidPalindrome(string s) {\\n        int left = 0;\\n        int right = s.Length - 1;\\n        while (left < right) {\\n            if (s[left] != s[right])\\n                return ValidPalindrome(s, left + 1, right) || ValidPalindrome(s, left, right - 1);\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n    private static bool ValidPalindrome(string s, int left, int right) {\\n        while (left < right) {\\n            if (s[left++] != s[right--])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359275,
                "title": "recursive-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\nbool isPalindrome(string s, int i, int j) {\\n    while (i < j) {\\n        if (s[i] != s[j]) {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n//    time complexity: O(n)\\n//    space complexity: O(1)\\n}\\n\\nbool validPalindrome(string s) {\\n//    Given a string s, return true if the s can be palindrome after deleting at most one character from it.\\n\\n\\n    int i = 0;\\n    int j = s.length() - 1;\\n    while (i < j) {\\n        if (s[i] != s[j]) {\\n            return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n//    time complexity: O(n)\\n//    space complexity: O(1)\\n\\n\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isPalindrome(string s, int i, int j) {\\n    while (i < j) {\\n        if (s[i] != s[j]) {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n//    time complexity: O(n)\\n//    space complexity: O(1)\\n}\\n\\nbool validPalindrome(string s) {\\n//    Given a string s, return true if the s can be palindrome after deleting at most one character from it.\\n\\n\\n    int i = 0;\\n    int j = s.length() - 1;\\n    while (i < j) {\\n        if (s[i] != s[j]) {\\n            return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n//    time complexity: O(n)\\n//    space complexity: O(1)\\n\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318883,
                "title": "680-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAlgorithm for the validPalindrome method:\\n\\nInitialize left pointer to 0 and right pointer to len(s) - 1.\\nWhile left pointer is less than right pointer:\\na. If the characters at the left and right pointers are not equal:\\ni. Check if deleting the character at the left pointer makes the rest of the string a palindrome by calling the isPalindrome method with left pointer incremented by 1 and right pointer.\\n- If it returns True, return True from the method.\\nii. Check if deleting the character at the right pointer makes the rest of the string a palindrome by calling the isPalindrome method with left pointer and right pointer decremented by 1.\\n- If it returns True, return True from the method.\\niii. Otherwise, both substrings are not palindromes, return False.\\nb. Otherwise, characters at the left and right pointers are equal, increment left pointer and decrement right pointer.\\nIf the method hasn\\'t returned True yet, it means the string is a palindrome, return True.\\nAlgorithm for the isPalindrome method:\\n\\nWhile left pointer is less than right pointer:\\na. If the characters at the left and right pointers are not equal, return False.\\nb. Otherwise, increment left pointer and decrement right pointer.\\nIf the method hasn\\'t returned False yet, it means the string is a palindrome, return True.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        left, right = 0, len(s) - 1\\n        while left < right:\\n            if s[left] != s[right]:\\n                # Check if deleting the left character makes the rest of the string a palindrome\\n                if self.isPalindrome(s, left + 1, right):\\n                    return True\\n                # Check if deleting the right character makes the rest of the string a palindrome\\n                elif self.isPalindrome(s, left, right - 1):\\n                    return True\\n                else:\\n                    # Both substrings are not palindromes\\n                    return False\\n            left += 1\\n            right -= 1\\n        return True\\n    \\n    def isPalindrome(self, s: str, left: int, right: int) -> bool:\\n        while left < right:\\n            if s[left] != s[right]:\\n                return False\\n            left += 1\\n            right -= 1\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        left, right = 0, len(s) - 1\\n        while left < right:\\n            if s[left] != s[right]:\\n                # Check if deleting the left character makes the rest of the string a palindrome\\n                if self.isPalindrome(s, left + 1, right):\\n                    return True\\n                # Check if deleting the right character makes the rest of the string a palindrome\\n                elif self.isPalindrome(s, left, right - 1):\\n                    return True\\n                else:\\n                    # Both substrings are not palindromes\\n                    return False\\n            left += 1\\n            right -= 1\\n        return True\\n    \\n    def isPalindrome(self, s: str, left: int, right: int) -> bool:\\n        while left < right:\\n            if s[left] != s[right]:\\n                return False\\n            left += 1\\n            right -= 1\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906727,
                "title": "python3-simple-with-explanation-beats-99-69-two-pointers",
                "content": "# Approach\\n- Begin by eliminating cases that are already palindromes.\\n- Create two pointers `l` and `r` referencing the first and last indices of the string.\\n- Loop through the string, moving `l` and `r` towards the center with each matching character.\\n- When the two characters don\\'t match, create two temporary strings: `tmp1` with the character at index `l` removed, and `tmp2` with the character at index `r` removed.\\n- Return `True` if `tmp1` or `tmp2` is a palindrome, otherwise return `False`.\\n\\n# Complexity\\n\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n\\nRuntime: 70 ms (Beats 99.69%)\\nMemory: 14.5 MB (Beats 89.91%)\\n# Code\\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        if s == s[::-1]: return True\\n\\n        l = 0\\n        r = len(s) - 1\\n\\n        while l < r:\\n            if s[l] == s[r]:\\n                l += 1\\n                r -= 1\\n            else:\\n                tmp1 = s[:l] + s[l+1:]\\n                tmp2 = s[:r] + s[r+1:]\\n                if tmp1 == tmp1[::-1] or tmp2 == tmp2[::-1]:\\n                    return True\\n                else:\\n                    return False\\n        \\n        return True\\n\\n```\\n\\n## Please upvote if you find this helpful! :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        if s == s[::-1]: return True\\n\\n        l = 0\\n        r = len(s) - 1\\n\\n        while l < r:\\n            if s[l] == s[r]:\\n                l += 1\\n                r -= 1\\n            else:\\n                tmp1 = s[:l] + s[l+1:]\\n                tmp2 = s[:r] + s[r+1:]\\n                if tmp1 == tmp1[::-1] or tmp2 == tmp2[::-1]:\\n                    return True\\n                else:\\n                    return False\\n        \\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848351,
                "title": "python-99-07-faster-two-pointers-o-n-solution",
                "content": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        i,j=0,len(s)-1\\n        while i<j:\\n            if s[i]!=s[j]:\\n                left_remove=s[i+1:j+1]\\n                right_remove=s[i:j]\\n                return left_remove==left_remove[-1::-1] or right_remove==right_remove[-1::-1]\\n            else:\\n                i+=1\\n                j-=1\\n        return True\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        i,j=0,len(s)-1\\n        while i<j:\\n            if s[i]!=s[j]:\\n                left_remove=s[i+1:j+1]\\n                right_remove=s[i:j]\\n                return left_remove==left_remove[-1::-1] or right_remove==right_remove[-1::-1]\\n            else:\\n                i+=1\\n                j-=1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824893,
                "title": "java-two-pointers-recursion",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        return isPalindrome(s, 0, s.length() - 1, false);\\n    }\\n\\n    public boolean isPalindrome(String s, int i, int j, boolean isDeleted) {\\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                if (isDeleted) return false;\\n                return isPalindrome(s, i + 1, j, true) || isPalindrome(s, i, j - 1, true);\\n            }\\n\\n            i++; j--;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        return isPalindrome(s, 0, s.length() - 1, false);\\n    }\\n\\n    public boolean isPalindrome(String s, int i, int j, boolean isDeleted) {\\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                if (isDeleted) return false;\\n                return isPalindrome(s, i + 1, j, true) || isPalindrome(s, i, j - 1, true);\\n            }\\n\\n            i++; j--;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787023,
                "title": "c-easy-solution-0ms-solution-fast-method",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s, int i, int j){\\n        while(i<=j){\\n            if(s[i]!=s[j])return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool validPalindrome(string s) {\\n       int count =1;\\n       int i=0;\\n       int j=s.size()-1;\\n       while(i<j){\\n           if(s[i]==s[j]){\\n               i++; \\n               j--;\\n           }\\n             else{\\n                 return (isPalindrome(s,i+1,j)|| isPalindrome(s,i,j-1));\\n             }\\n       }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s, int i, int j){\\n        while(i<=j){\\n            if(s[i]!=s[j])return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool validPalindrome(string s) {\\n       int count =1;\\n       int i=0;\\n       int j=s.size()-1;\\n       while(i<j){\\n           if(s[i]==s[j]){\\n               i++; \\n               j--;\\n           }\\n             else{\\n                 return (isPalindrome(s,i+1,j)|| isPalindrome(s,i,j-1));\\n             }\\n       }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643597,
                "title": "easy-understanding",
                "content": "class Solution {\\npublic:\\nbool isvalidPalidrome(string s,int i,int j){\\n while(i<j){\\n     if(s[i]==s[j]){\\n         i++;\\n         j--;\\n     }\\n     else{\\n         return false;\\n     }\\n }\\n     return true;\\n}\\n    bool validPalindrome(string s) {\\n    string m=s;\\n        reverse(m.begin(),m.end());\\n        if(m==s){\\n            return true;\\n        }\\n    int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                return ( isvalidPalidrome(s,i+1,j)||( isvalidPalidrome(s,i,j-1)));\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nbool isvalidPalidrome(string s,int i,int j){\\n while(i<j){\\n     if(s[i]==s[j]){\\n         i++;\\n         j--;\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 2640130,
                "title": "100-faster-c-solution-two-pointer",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool valid(string &s, int low, int high, int cnt){\\n        if(high-low==0) {\\n            return true;\\n        }\\n        while(low<high){\\n            if(s[low] == s[high]) {\\n                low++;\\n                high--;\\n            }\\n            else if(cnt == 0){\\n                return valid(s,low+1,high,cnt+1) or valid(s,low,high-1,cnt+1);\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool validPalindrome(string s) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int low = 0, high = s.length()-1 ,cnt = 0;\\n        return valid(s,low,high,cnt);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(string &s, int low, int high, int cnt){\\n        if(high-low==0) {\\n            return true;\\n        }\\n        while(low<high){\\n            if(s[low] == s[high]) {\\n                low++;\\n                high--;\\n            }\\n            else if(cnt == 0){\\n                return valid(s,low+1,high,cnt+1) or valid(s,low,high-1,cnt+1);\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool validPalindrome(string s) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int low = 0, high = s.length()-1 ,cnt = 0;\\n        return valid(s,low,high,cnt);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2510844,
                "title": "97-faster-python-solution",
                "content": "**class Solution:\\n    def validPalindrome(self, s: str) -> bool:**\\n\\t\\n        if s == s[::-1]:\\n            return True\\n        p1, p2 = 0, len(s)-1\\n        while p1 <= p2:\\n            if s[p1] == s[p2]:\\n                p1 += 1\\n                p2 -= 1\\n            else:\\n                return s[p1+1:p2+1] == s[p1+1:p2+1][::-1] or s[p1:p2] == s[p1:p2][::-1]\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "**class Solution:\\n    def validPalindrome(self, s: str) -> bool:**\\n\\t\\n        if s == s[::-1]:\\n            return True\\n        p1, p2 = 0, len(s)-1\\n        while p1 <= p2:\\n            if s[p1] == s[p2]:\\n                p1 += 1\\n                p2 -= 1\\n            else:\\n                return s[p1+1:p2+1] == s[p1+1:p2+1][::-1] or s[p1:p2] == s[p1:p2][::-1]\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2469175,
                "title": "the-shortest-most-optimal-solution-python-no-string-reverse-bullshit",
                "content": "Idk why there are so many solutions which reverse string and then compare. That is not optimal.\\n```\\ndef isPal(l, r, delFlag):\\n            while l<r and s[l] == s[r]: l+=1; r-=1\\n            if l>=r: return True\\n            return isPal(l+1, r, False) or isPal(l, r-1, False) if delFlag else False\\n```\\n\\nYou can further optimise it by caching intermediate results like so:\\n```\\n@functools.lru_cache\\ndef isPal(l, r, delFlag):\\n            while l<r and s[l] == s[r]: l+=1; r-=1\\n            if l>=r: return True\\n            return isPal(l+1, r, False) or isPal(l, r-1, False) if delFlag else False\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isPal(l, r, delFlag):\\n            while l<r and s[l] == s[r]: l+=1; r-=1\\n            if l>=r: return True\\n            return isPal(l+1, r, False) or isPal(l, r-1, False) if delFlag else False\\n```\n```\\n@functools.lru_cache\\ndef isPal(l, r, delFlag):\\n            while l<r and s[l] == s[r]: l+=1; r-=1\\n            if l>=r: return True\\n            return isPal(l+1, r, False) or isPal(l, r-1, False) if delFlag else False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2415990,
                "title": "java-100-faster-easy-to-understand",
                "content": "Upvote if this solution helped :) For all my optimized solutions, visit my [GitHub Repo](https://github.com/abhideepghosh/Leetcode-Solutions).\\n```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int i=0,j=s.length()-1;\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j))\\n                return isPalindrome(s,i+1,j) || isPalindrome(s,i,j-1);   \\n            j--;i++;\\n        }\\n        return true;\\n    }\\n    public static boolean isPalindrome(String ss,int i, int j){\\n        while(i<j){\\n            if(ss.charAt(i)!= ss.charAt(j)) return false;\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int i=0,j=s.length()-1;\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j))\\n                return isPalindrome(s,i+1,j) || isPalindrome(s,i,j-1);   \\n            j--;i++;\\n        }\\n        return true;\\n    }\\n    public static boolean isPalindrome(String ss,int i, int j){\\n        while(i<j){\\n            if(ss.charAt(i)!= ss.charAt(j)) return false;\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318426,
                "title": "python-two-pointers-approach-explained",
                "content": "\\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        # whenever we find a mismatched pair, there could two possibilities\\n        # i) we could decrement r by 1 and continue the search\\n        # ii) we could increment l by 1 and continue the search\\n\\t\\t# And that\\'s we\\'re gonna do.\\n\\t\\n        l, r = 0, len(s)-1\\n\\n        while l < r:\\n            if s[l] != s[r]:\\n                # try both ways\\n                l2, r2 = l+1, r\\n                l3, r3 = l, r-1\\n\\n                first, second = True, True\\n                # l+1, r\\n                while l2 < r2:\\n                    if s[l2] != s[r2]:\\n                        first = False\\n                        break\\n                    l2 +=1\\n                    r2 -=1\\n                # l, r-1\\n                while l3 < r3:\\n                    if s[l3] != s[r3]:\\n                        second = False\\n                        break\\n                    l3 +=1\\n                    r3 -=1\\n                \\n                if first or second: # if any of them returns True\\n                    return True\\n                else:\\n                    return False\\n\\n            l+=1\\n            r-=1\\n\\n        return True\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        # whenever we find a mismatched pair, there could two possibilities\\n        # i) we could decrement r by 1 and continue the search\\n        # ii) we could increment l by 1 and continue the search\\n\\t\\t# And that\\'s we\\'re gonna do.\\n\\t\\n        l, r = 0, len(s)-1\\n\\n        while l < r:\\n            if s[l] != s[r]:\\n                # try both ways\\n                l2, r2 = l+1, r\\n                l3, r3 = l, r-1\\n\\n                first, second = True, True\\n                # l+1, r\\n                while l2 < r2:\\n                    if s[l2] != s[r2]:\\n                        first = False\\n                        break\\n                    l2 +=1\\n                    r2 -=1\\n                # l, r-1\\n                while l3 < r3:\\n                    if s[l3] != s[r3]:\\n                        second = False\\n                        break\\n                    l3 +=1\\n                    r3 -=1\\n                \\n                if first or second: # if any of them returns True\\n                    return True\\n                else:\\n                    return False\\n\\n            l+=1\\n            r-=1\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218316,
                "title": "680-valid-palindrome-ii-best-approach-java-solution",
                "content": "Simple Solution : Just Check by deleting one element from both sides and count the element skipped if it is equal to 0 or 1 then return true else false.\\n\\nCODE ------>\\n\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int start = 0, end = s.length()-1;\\n        int count1 = 0, count2 = 0;\\n        \\n        while (start<end){\\n            if (s.charAt(start)==s.charAt(end)){\\n                start++;\\n                end--;\\n            }else{\\n                start++;\\n                count1++;\\n            }\\n        }\\n        \\n        start = 0; \\n        end = s.length()-1;\\n        \\n        while (start<end){\\n            if (s.charAt(start)==s.charAt(end)){\\n                start++;\\n                end--;\\n            }else{\\n                end--;\\n                count2++;\\n            }\\n        }\\n        \\n        if (count1==1 || count2==1 || count1==0 || count2==0) return true;\\n        \\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public boolean validPalindrome(String s) {\\n        int start = 0, end = s.length()-1;\\n        int count1 = 0, count2 = 0;\\n        \\n        while (start<end){\\n            if (s.charAt(start)==s.charAt(end)){\\n                start++;\\n                end--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2041007,
                "title": "c-two-pointer-easy",
                "content": "class Solution {\\npublic:\\n\\n    bool palin(string s,int i,int j){\\n        while(j>i){\\n            if(s[i]!=s[j]) return false; \\n                i++;\\n                j--;\\n        }\\n        return true;\\n    }\\n    bool validPalindrome(string s){\\n        int i=0,j=s.size()-1;\\n        while(j>i){\\n            if(s[i]!=s[j]) return palin(s,i+1,j) || palin(s,i,j-1);\\n            i++;j--;\\n        }\\n        return true;\\n                \\n    }\\n};\\n\\n#### **UPVOTE IF YOU LIKE THE SOLUTION :)**",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool palin(string s,int i,int j){\\n        while(j>i){\\n            if(s[i]!=s[j]) return false; \\n                i++;\\n                j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1908154,
                "title": "java-2-pointers-explained",
                "content": "**Idea:**\\n* Use 2 pointers, 1 at the beginning of s and 1 at the end\\n* Move them inwards as long as they point to same chars and don\\'t cross each other\\n* If the pointers aren\\'t same then check if:\\n\\t* s[i, j) is a palindrome. If yes, then s[j] can be deleted to get a palindrome\\n\\t* s[i+1, j+1) is a palindrome. If yes, then s[i] can be deleted to get a palindrome \\n>**T/S:** O(n)/O(1), where n = size(s)  \\n```\\npublic boolean validPalindrome(String s) {\\n\\tfor (int i = 0, j = s.length() - 1; i < j; i++, j--)\\n\\t\\tif (s.charAt(i) != s.charAt(j))\\n\\t\\t\\treturn isPalindrome(s.substring(i, j)) || isPalindrome(s.substring(i + 1, j + 1));\\n\\treturn true;\\n}\\n\\nprivate boolean isPalindrome(String s) {\\n\\tfor (int i = 0, j = s.length() - 1; i < j; i++, j--)\\n\\t\\tif (s.charAt(i) != s.charAt(j))\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean validPalindrome(String s) {\\n\\tfor (int i = 0, j = s.length() - 1; i < j; i++, j--)\\n\\t\\tif (s.charAt(i) != s.charAt(j))\\n\\t\\t\\treturn isPalindrome(s.substring(i, j)) || isPalindrome(s.substring(i + 1, j + 1));\\n\\treturn true;\\n}\\n\\nprivate boolean isPalindrome(String s) {\\n\\tfor (int i = 0, j = s.length() - 1; i < j; i++, j--)\\n\\t\\tif (s.charAt(i) != s.charAt(j))\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906221,
                "title": "python-5-solutions",
                "content": "\\u274C **Solution 1:** (BruteForce) | Delete each character and check\\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        isPal = lambda s: s == s[::-1]\\n        if isPal(s): return True\\n        for i in range(len(s)):\\n            if isPal(s[:i] + s[i+1:]): return True\\n        return False\\n```\\n***\\n```Time Complexity: O(N*N)  |  TLE```\\n***\\n\\n\\u2714 **Solution 2:** Two pointers iterative\\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        def isPal(s):\\n            lo, hi = 0, len(s) - 1\\n            while lo < hi:\\n                if s[lo] != s[hi]: return False\\n                lo += 1\\n                hi -= 1\\n            return True\\n        \\n        lo, hi = 0, len(s) - 1\\n        while lo < hi:\\n            if s[lo] != s[hi]:\\n                return isPal(s[lo+1:hi+1]) or isPal(s[lo:hi])\\n            lo += 1\\n            hi -= 1\\n        return True\\n```\\n**OR** this to reduce lines\\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        lo, hi, isPal = 0, len(s) - 1, lambda s: s == s[::-1]\\n        while lo < hi:\\n            if s[lo] != s[hi]:\\n                return isPal(s[lo+1:hi+1]) or isPal(s[lo:hi])\\n            lo += 1\\n            hi -= 1\\n        return True\\n```\\n***\\n```Time Complexity: O(N)```\\n***\\n\\n\\u2714 **Solution 3:** Two pointers Recursive\\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        def validPal(lo, hi, flag):\\n            if lo >= hi: return True\\n            if s[lo] == s[hi]: return validPal(lo+1,hi-1, flag)\\n            if flag: return validPal(lo+1,hi, False) or validPal(lo, hi-1, False)\\n            return False\\n        return validPal(0, len(s)-1, True)\\n```\\n***\\n```Time Complexity: O(N)```\\n***\\n\\u2714 **Solution 4:** Recursive Array splicing\\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        def validPal(s, flag):\\n            if len(s) < 2: return True\\n            if s[0] == s[-1]: return validPal(s[1:-1], flag)\\n            if flag: return validPal(s[1:], False) or validPal(s[:-1], False)\\n            return False\\n        return validPal(s, True)\\n```\\n***\\n```Time Complexity: O(N)```\\n***\\n**Solution 5:**  4 Liner | Just for fun\\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        isPal, n = lambda s: s == s[::-1], len(s)\\n        for i in range(n // 2):\\n            if s[i] != s[n-i-1]: return isPal(s[i+1:n-i]) or isPal(s[i:n-i-1])\\n        return True\\n```\\n***\\n```Time Complexity: O(N)```\\n***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        isPal = lambda s: s == s[::-1]\\n        if isPal(s): return True\\n        for i in range(len(s)):\\n            if isPal(s[:i] + s[i+1:]): return True\\n        return False\\n```\n```Time Complexity: O(N*N)  |  TLE```\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        def isPal(s):\\n            lo, hi = 0, len(s) - 1\\n            while lo < hi:\\n                if s[lo] != s[hi]: return False\\n                lo += 1\\n                hi -= 1\\n            return True\\n        \\n        lo, hi = 0, len(s) - 1\\n        while lo < hi:\\n            if s[lo] != s[hi]:\\n                return isPal(s[lo+1:hi+1]) or isPal(s[lo:hi])\\n            lo += 1\\n            hi -= 1\\n        return True\\n```\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        lo, hi, isPal = 0, len(s) - 1, lambda s: s == s[::-1]\\n        while lo < hi:\\n            if s[lo] != s[hi]:\\n                return isPal(s[lo+1:hi+1]) or isPal(s[lo:hi])\\n            lo += 1\\n            hi -= 1\\n        return True\\n```\n```Time Complexity: O(N)```\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        def validPal(lo, hi, flag):\\n            if lo >= hi: return True\\n            if s[lo] == s[hi]: return validPal(lo+1,hi-1, flag)\\n            if flag: return validPal(lo+1,hi, False) or validPal(lo, hi-1, False)\\n            return False\\n        return validPal(0, len(s)-1, True)\\n```\n```Time Complexity: O(N)```\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        def validPal(s, flag):\\n            if len(s) < 2: return True\\n            if s[0] == s[-1]: return validPal(s[1:-1], flag)\\n            if flag: return validPal(s[1:], False) or validPal(s[:-1], False)\\n            return False\\n        return validPal(s, True)\\n```\n```Time Complexity: O(N)```\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        isPal, n = lambda s: s == s[::-1], len(s)\\n        for i in range(n // 2):\\n            if s[i] != s[n-i-1]: return isPal(s[i+1:n-i]) or isPal(s[i:n-i-1])\\n        return True\\n```\n```Time Complexity: O(N)```",
                "codeTag": "Java"
            },
            {
                "id": 1905967,
                "title": "680-c-o-n-solution-2-approaches-2-pointer-approach",
                "content": "**Approach-1 : Use 2 pointers and loop**\\n**TC: O(N), SC: O(1)**\\n```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int start=0, end=s.size()-1, cnt=0;\\n        \\n        while(start<end) {\\n            if(s[start] == s[end]) {\\n                start++;\\n                end--;\\n            }\\n            \\n            //if characters mismatch we move end pointer and start is at its own place\\n            else {\\n\\n                cnt++;\\n                end--;\\n            }\\n            \\n            //if count >1 use break for saving time\\n            if(cnt>1)\\n                break;  \\n        }\\n        \\n        start=0;\\n        end=s.size()-1;\\n        int cnt1=0;\\n        \\n        while(start<end) {\\n            if(s[start] == s[end]) {\\n                start++;\\n                end--;\\n            }\\n            \\n\\t\\t\\t//if characters mismatch we move start pointer and end is at its own place\\n            else {\\n                cnt1++;\\n                start++;\\n            }\\n            \\n            if(cnt1>1)\\n                break;  \\n        }\\n        if(cnt<=1 || cnt1<=1) return true;\\n        return false;\\n    }\\n};\\n```\\n\\n**Approach-2: Use 2 pointers and function call**\\n**TC: O(N), SC: O(1)**\\n```\\nclass Solution {\\npublic:\\n    \\n    bool checkPalindrome(string s, int i, int j)\\n    {\\n        while(i<j)\\n        {\\n            if(s[i] != s[j]) //we can also use s.at(i) != s.at(j)\\n                return false;\\n            \\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool validPalindrome(string s) {\\n        int start=0, end=s.size()-1;\\n        \\n        while(start<end) \\n        {\\n            if(s[start] != s[end]) \\n            {\\n\\t\\t\\t\\t//check for next left of end pointer and next right of start pointer\\n                return (checkPalindrome(s, start, end-1) || checkPalindrome(s, start+1, end));\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int start=0, end=s.size()-1, cnt=0;\\n        \\n        while(start<end) {\\n            if(s[start] == s[end]) {\\n                start++;\\n                end--;\\n            }\\n            \\n            //if characters mismatch we move end pointer and start is at its own place\\n            else {\\n\\n                cnt++;\\n                end--;\\n            }\\n            \\n            //if count >1 use break for saving time\\n            if(cnt>1)\\n                break;  \\n        }\\n        \\n        start=0;\\n        end=s.size()-1;\\n        int cnt1=0;\\n        \\n        while(start<end) {\\n            if(s[start] == s[end]) {\\n                start++;\\n                end--;\\n            }\\n            \\n\\t\\t\\t//if characters mismatch we move start pointer and end is at its own place\\n            else {\\n                cnt1++;\\n                start++;\\n            }\\n            \\n            if(cnt1>1)\\n                break;  \\n        }\\n        if(cnt<=1 || cnt1<=1) return true;\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool checkPalindrome(string s, int i, int j)\\n    {\\n        while(i<j)\\n        {\\n            if(s[i] != s[j]) //we can also use s.at(i) != s.at(j)\\n                return false;\\n            \\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool validPalindrome(string s) {\\n        int start=0, end=s.size()-1;\\n        \\n        while(start<end) \\n        {\\n            if(s[start] != s[end]) \\n            {\\n\\t\\t\\t\\t//check for next left of end pointer and next right of start pointer\\n                return (checkPalindrome(s, start, end-1) || checkPalindrome(s, start+1, end));\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905689,
                "title": "clear-easy-simple-recursion",
                "content": "```\\nvar validPalindrome = function(s) {\\n    let helper = (left,right,check) => {\\n    if (left >= right) return true;\\n\\n    if (s[left] != s[right]) {\\n      if (check) return helper(left+1,right,false) || helper(left,right-1,false);\\n        return false;\\n    }\\n    return helper(left+1,right-1,check)\\n  }\\n\\n  return helper(0,s.length-1,true)  \\n};\\n```\\n**PLEASE UPVOTE !**",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```\\nvar validPalindrome = function(s) {\\n    let helper = (left,right,check) => {\\n    if (left >= right) return true;\\n\\n    if (s[left] != s[right]) {\\n      if (check) return helper(left+1,right,false) || helper(left,right-1,false);\\n        return false;\\n    }\\n    return helper(left+1,right-1,check)\\n  }\\n\\n  return helper(0,s.length-1,true)  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1905572,
                "title": "o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPalindrome(string s, int l, int r){ \\n      while(l<r){\\n          if(s[l]==s[r]){\\n              l++;\\n              r--;\\n          }\\n          else return false;\\n       }\\n       return true;\\n    } \\n    \\n    bool validPalindrome(string s) {\\n        int n=s.size();\\n        if(n==1)\\n            return true;\\n        int l=0, r=n-1;\\n        while(l<r){\\n            if(s[l]==s[r]){\\n                l++;\\n                r--;\\n            }\\n            else{\\n                if(isPalindrome(s,l,r-1))\\n                    return true;\\n                else if(isPalindrome(s,l+1,r))\\n                    return true;\\n                else\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPalindrome(string s, int l, int r){ \\n      while(l<r){\\n          if(s[l]==s[r]){\\n              l++;\\n              r--;\\n          }\\n          else return false;\\n       }\\n       return true;\\n    } \\n    \\n    bool validPalindrome(string s) {\\n        int n=s.size();\\n        if(n==1)\\n            return true;\\n        int l=0, r=n-1;\\n        while(l<r){\\n            if(s[l]==s[r]){\\n                l++;\\n                r--;\\n            }\\n            else{\\n                if(isPalindrome(s,l,r-1))\\n                    return true;\\n                else if(isPalindrome(s,l+1,r))\\n                    return true;\\n                else\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905320,
                "title": "c-easy-to-understand-with-algorithm",
                "content": "**Please Upvote If It Helps**\\n\\n**Algorithm**\\n* Initialize the pointers for **left and right** also initialize the count val for counting **left deleted and right deelted chars**\\n\\n* Count the **left deleted chars** using a **while loop** untill our **left count value not exceed 1** or **string does not finish**\\n* Count the **right deleted chars** using a **while loop** untill our **left count value not exceed 1** or **string does not finish**\\n* then check cnt values \\n* **if cnt==0 or cnt == 1 return true (atmost one)**\\n* **if cnt>1 return false                      (freater then one)**\\n\\n```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) \\n    {\\n        // initializing the pointers\\n        int l = 0;\\n        int r = s.size()-1;\\n        \\n        // initializing the left right deleted cnt chars\\n        int cnt_l = 0;\\n        int cnt_r = 0;\\n        \\n        // for left deleted elements\\n        while(l<=r)\\n        {\\n            if(s[l]==s[r])\\n            {\\n                l++;\\n                r--;\\n            }\\n            else\\n            {\\n                cnt_l++;\\n                l++;\\n            }\\n            \\n            if(cnt_l>1)\\n                break;\\n        }\\n        \\n        // reinitializing the pointer for counting the right deleted chars\\n        l = 0;\\n        r = s.size()-1;\\n        \\n        // for right\\n        while(l<=r)\\n        {\\n            if(s[l]==s[r])\\n            {\\n                l++;\\n                r--;\\n            }\\n            else\\n            {\\n                cnt_r++;\\n                r--;\\n            }\\n            \\n            if(cnt_r>1)\\n                break;\\n        }\\n        \\n        // palindrom condition\\n        if(cnt_l==0 or cnt_r==0)\\n            return true;\\n        \\n        // atmost one char deleted condition\\n        if(cnt_l==1 or cnt_r==1)\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) \\n    {\\n        // initializing the pointers\\n        int l = 0;\\n        int r = s.size()-1;\\n        \\n        // initializing the left right deleted cnt chars\\n        int cnt_l = 0;\\n        int cnt_r = 0;\\n        \\n        // for left deleted elements\\n        while(l<=r)\\n        {\\n            if(s[l]==s[r])\\n            {\\n                l++;\\n                r--;\\n            }\\n            else\\n            {\\n                cnt_l++;\\n                l++;\\n            }\\n            \\n            if(cnt_l>1)\\n                break;\\n        }\\n        \\n        // reinitializing the pointer for counting the right deleted chars\\n        l = 0;\\n        r = s.size()-1;\\n        \\n        // for right\\n        while(l<=r)\\n        {\\n            if(s[l]==s[r])\\n            {\\n                l++;\\n                r--;\\n            }\\n            else\\n            {\\n                cnt_r++;\\n                r--;\\n            }\\n            \\n            if(cnt_r>1)\\n                break;\\n        }\\n        \\n        // palindrom condition\\n        if(cnt_l==0 or cnt_r==0)\\n            return true;\\n        \\n        // atmost one char deleted condition\\n        if(cnt_l==1 or cnt_r==1)\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905036,
                "title": "rust-clean-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn valid_palindrome(s: String) -> bool {\\n        let s = s.as_bytes();\\n        let n = s.len();\\n        for i in 0..n / 2 {\\n            if s[i] != s[n-i-1] {\\n                let l = &s[i..n-i-1];\\n                let r = &s[i+1..n-i];\\n                return Self::helper(l) || Self::helper(r);\\n            }\\n        }\\n        true\\n    }\\n    fn helper(s: &[u8]) -> bool {\\n        let n = s.len();\\n        (0..n / 2).all(|i| s[i] == s[n-i-1])\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn valid_palindrome(s: String) -> bool {\\n        let s = s.as_bytes();\\n        let n = s.len();\\n        for i in 0..n / 2 {\\n            if s[i] != s[n-i-1] {\\n                let l = &s[i..n-i-1];\\n                let r = &s[i+1..n-i];\\n                return Self::helper(l) || Self::helper(r);\\n            }\\n        }\\n        true\\n    }\\n    fn helper(s: &[u8]) -> bool {\\n        let n = s.len();\\n        (0..n / 2).all(|i| s[i] == s[n-i-1])\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1904982,
                "title": "c-easy-solution-with-o-n-complexity-and-o-1-space",
                "content": "1. First we check if the string is a palindrome.\\n2. If it isn\\'t a valid palindrome, we use 2 pointers to iterate to see if the characters are equal.\\n3. If a pair of character isn\\'t equal then we check if the string is a palindrome with the next start or end index.\\n```\\npublic class Solution {\\n    public bool IsPalindrome(string s, int start, int end)\\n    {\\n        while(start < end)\\n        {\\n            if(s[start] != s[end])\\n                return false;\\n            \\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public bool ValidPalindrome(string s) {\\n        \\n        if (IsPalindrome(s, 0, s.Length - 1))\\n            return true;\\n        else\\n        {\\n            for(int start = 0, end = s.Length - 1; start < end; start++, end--)\\n            {\\n                if (s[start] != s[end])\\n                    return (IsPalindrome(s, start + 1, end) || IsPalindrome(s, start, end - 1));\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsPalindrome(string s, int start, int end)\\n    {\\n        while(start < end)\\n        {\\n            if(s[start] != s[end])\\n                return false;\\n            \\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public bool ValidPalindrome(string s) {\\n        \\n        if (IsPalindrome(s, 0, s.Length - 1))\\n            return true;\\n        else\\n        {\\n            for(int start = 0, end = s.Length - 1; start < end; start++, end--)\\n            {\\n                if (s[start] != s[end])\\n                    return (IsPalindrome(s, start + 1, end) || IsPalindrome(s, start, end - 1));\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904917,
                "title": "3-approaches-brute-force-recursion-and-two-pointers",
                "content": "[Leetcode](https://leetcode.com/) [680. Valid Palindrome II](https://leetcode.com/problems/valid-palindrome-ii/).\\n\\nHere shows **3** Approaches to slove this problem: **Brue Force**, **Recursion** and **Two Pointers**.\\n\\n\\n# Brue Force\\n\\nLet\\'s start from the simplest method: \\n\\n- if $len(str) \\\\le 2$, definitely return $\\\\textit{true}$;\\n- if the string is a palindrome, return $\\\\textit{true}$; \\n- if not, enumerate each position as the deleted position, and then check the remaining strings is it a palindrome.\\n\\nTime complexity of this approach is $O(n^2)$, time limit will be exceeded.\\n\\n```java\\n    public static boolean validPalindrome_bf(String s) {\\n        int len = s.length();\\n        if (len <= 2 || validPalindrome(s, 0, len - 1)) {\\n            return true;\\n        }\\n\\n        for (int i = 0; i < len; i++) {\\n            String str = s.substring(0, i) + s.substring(i + 1, len);\\n            if (validPalindrome(str, 0, str.length() - 1)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    public static boolean validPalindrome(String s, int left, int right) {\\n        int len = s.length();\\n        if (left >= len || right < 0 || left > right) {\\n            return false;\\n        }\\n\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n^2)$\\n- **Space Complexity**: $O(1)$\\n\\n\\n# Recursion\\n \\n**Recursion** solution is also easy, it is silimar to the two pointers approach.\\n\\n```java\\n    // Recursive time: O(n) space: O(1) TimeOut\\n    public static boolean validPalindrome_recursive(String s) {\\n        return validPalindrome(s, 0, s.length() - 1, 1);\\n    }\\n\\n    public static boolean validPalindrome(String s, int left, int right, int cnt) {\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right)) {\\n                if (cnt > 0) {\\n                    return validPalindrome(s, left + 1, right, cnt - 1) || validPalindrome(s, left, right - 1, cnt - 1);\\n                } else {\\n                    return false;\\n                }\\n            }\\n\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n / 2)$\\n\\n\\n# Two Pointers\\n\\nAn efficient way to check if a string is a palindrome is to use two pointers.\\n\\nIf the characters pointed to by the two pointers are different, one of the two characters must be deleted. \\n\\nAt this time, we can divide it into two cases: \\n\\n1. delete the character corresponding to the left pointer, leaving the substring $s[low+1:high]$;\\n2. delete the character corresponding to the right pointer, leaving the substring $s[low:high\\u22121]$. \\n\\nWhen at least one of the two substrings is a palindrome, it means that the original string becomes a palindrome after deleting one character.\\n\\n```java\\n    // Two Pointers time: O(n) space: O(1)\\n    public static boolean validPalindrome_tp(String s) {\\n        int len = s.length();\\n        if (len <= 2) {\\n            return true;\\n        }\\n\\n        int left = 0;\\n        int right = len - 1;\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right)) {\\n                return validPalindrome(s, left + 1, right) || validPalindrome(s, left, right - 1);\\n            } else {\\n                left++;\\n                right--;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public static boolean validPalindrome(String s, int left, int right) {\\n        int len = s.length();\\n        if (left >= len || right < 0 || left > right) {\\n            return false;\\n        }\\n\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(1)$\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```java\\n    public static boolean validPalindrome_bf(String s) {\\n        int len = s.length();\\n        if (len <= 2 || validPalindrome(s, 0, len - 1)) {\\n            return true;\\n        }\\n\\n        for (int i = 0; i < len; i++) {\\n            String str = s.substring(0, i) + s.substring(i + 1, len);\\n            if (validPalindrome(str, 0, str.length() - 1)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    public static boolean validPalindrome(String s, int left, int right) {\\n        int len = s.length();\\n        if (left >= len || right < 0 || left > right) {\\n            return false;\\n        }\\n\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n```\n```java\\n    // Recursive time: O(n) space: O(1) TimeOut\\n    public static boolean validPalindrome_recursive(String s) {\\n        return validPalindrome(s, 0, s.length() - 1, 1);\\n    }\\n\\n    public static boolean validPalindrome(String s, int left, int right, int cnt) {\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right)) {\\n                if (cnt > 0) {\\n                    return validPalindrome(s, left + 1, right, cnt - 1) || validPalindrome(s, left, right - 1, cnt - 1);\\n                } else {\\n                    return false;\\n                }\\n            }\\n\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n```\n```java\\n    // Two Pointers time: O(n) space: O(1)\\n    public static boolean validPalindrome_tp(String s) {\\n        int len = s.length();\\n        if (len <= 2) {\\n            return true;\\n        }\\n\\n        int left = 0;\\n        int right = len - 1;\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right)) {\\n                return validPalindrome(s, left + 1, right) || validPalindrome(s, left, right - 1);\\n            } else {\\n                left++;\\n                right--;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public static boolean validPalindrome(String s, int left, int right) {\\n        int len = s.length();\\n        if (left >= len || right < 0 || left > right) {\\n            return false;\\n        }\\n\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1855361,
                "title": "easy-to-understand-python-solution-o-n-two-pointer",
                "content": "```\\nclass Solution(object):\\n    def validPalindrome(self, s):\\n        #s=\\'abc\\'\\n        i = 0\\n        j = len(s)-1\\n        str1 =\\'\\'\\n        str2=\\'\\'\\n        while i<j:\\n            if s[i] != s[j]:\\n                str1 = s[:i]+s[i+1:]\\n                str2 = s[:j] + s[j +1:]\\n                break\\n            i = i+1\\n            j = j-1\\n        if str1 == str1[::-1] or str2 == str2[::-1]:\\n            return True\\n        else:\\n            return False \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def validPalindrome(self, s):\\n        #s=\\'abc\\'\\n        i = 0\\n        j = len(s)-1\\n        str1 =\\'\\'\\n        str2=\\'\\'\\n        while i<j:\\n            if s[i] != s[j]:\\n                str1 = s[:i]+s[i+1:]\\n                str2 = s[:j] + s[j +1:]\\n                break\\n            i = i+1\\n            j = j-1\\n        if str1 == str1[::-1] or str2 == str2[::-1]:\\n            return True\\n        else:\\n            return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790519,
                "title": "c-really-short-o-n-solution-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        return solve(s, 0, s.size() - 1, false);\\n    }\\n    \\n    bool solve(string& s, int left, int right, bool skipped){\\n        while(left < right){\\n            if(s[left] != s[right]){\\n                if(skipped) return false;\\n                return solve(s, left + 1, right, true) || solve(s, left, right - 1, true); // skip the left or right element\\n            }\\n            left++; right--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        return solve(s, 0, s.size() - 1, false);\\n    }\\n    \\n    bool solve(string& s, int left, int right, bool skipped){\\n        while(left < right){\\n            if(s[left] != s[right]){\\n                if(skipped) return false;\\n                return solve(s, left + 1, right, true) || solve(s, left, right - 1, true); // skip the left or right element\\n            }\\n            left++; right--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696857,
                "title": "short-solution",
                "content": "This solution is not optimal, but it is short and easy to understand,\\n```\\nbool validPalindrome(char * s){\\n    bool grace = true, grace1 = true, grace2 = true;\\n    for (int start = 0, end = strlen(s) - 1 ; start < end ; start++, end--) {\\n        if (grace && s[start] != s[end]){grace = false;}\\n        if (!grace && s[start + 1] != s[end]){grace1 = false;}\\n        if (!grace && s[start] != s[end - 1]){grace2 = false;}\\n    }\\n    return grace1 || grace2;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool validPalindrome(char * s){\\n    bool grace = true, grace1 = true, grace2 = true;\\n    for (int start = 0, end = strlen(s) - 1 ; start < end ; start++, end--) {\\n        if (grace && s[start] != s[end]){grace = false;}\\n        if (!grace && s[start + 1] != s[end]){grace1 = false;}\\n        if (!grace && s[start] != s[end - 1]){grace2 = false;}\\n    }\\n    return grace1 || grace2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1690905,
                "title": "c-basic-approach-explained-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n\\t\\n        int start = 0;\\n        int end = s.length()-1;\\n        int count1 = 0, count2 = 0;\\n        \\n        while(start < end)\\n        {\\n            if(s[start] == s[end])\\n            {\\n                start++;\\n                end--;\\n            }\\n            else                   //for case like a b f e e b a  \\n            {                      //skip from start side(f) and count1++\\n                start++;\\n                count1++;\\n            }\\n        }\\n        \\n        start = 0, end= s.length()-1;\\n        while(start < end)\\n        {\\n            if(s[start] == s[end])\\n            {\\n                start++;\\n                end--;\\n            }\\n            else                   //for case like a b e e f b a  \\n            {                      //skip from end side(f) and count2++\\n                end--;\\n                count2++;\\n            }\\n        }\\n        \\n        if(count1 == 1 || count2 == 1)       //we skip only for one time then this is Palindrome\\n            return true;\\n        if(count1 == 0 || count2 == 0)       //if we will not skip then this is already a palindrome\\n            return true;\\n        \\n        return false;                        //if we have to skip more than one time then return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n\\t\\n        int start = 0;\\n        int end = s.length()-1;\\n        int count1 = 0, count2 = 0;\\n        \\n        while(start < end)\\n        {\\n            if(s[start] == s[end])\\n            {\\n                start++;\\n                end--;\\n            }\\n            else                   //for case like a b f e e b a  \\n            {                      //skip from start side(f) and count1++\\n                start++;\\n                count1++;\\n            }\\n        }\\n        \\n        start = 0, end= s.length()-1;\\n        while(start < end)\\n        {\\n            if(s[start] == s[end])\\n            {\\n                start++;\\n                end--;\\n            }\\n            else                   //for case like a b e e f b a  \\n            {                      //skip from end side(f) and count2++\\n                end--;\\n                count2++;\\n            }\\n        }\\n        \\n        if(count1 == 1 || count2 == 1)       //we skip only for one time then this is Palindrome\\n            return true;\\n        if(count1 == 0 || count2 == 0)       //if we will not skip then this is already a palindrome\\n            return true;\\n        \\n        return false;                        //if we have to skip more than one time then return false\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648623,
                "title": "beautiful-c-stl-solution-two-liner",
                "content": "STL funtions are pretty straight-forward.\\n```\\nbool validPalindrome(string s)\\n    {\\n        const auto [it, rit] = mismatch(cbegin(s), cend(s), crbegin(s));\\n        return it == cend(s) ||\\n               equal(it + 1, rit.base(), rit) ||\\n               equal(rit + 1, make_reverse_iterator(it), it);\\n    }\\n```\\n**If you have any doubts or suggestions, please feel free to comment.\\nIf you find this solution useful, you know where the upvote is :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool validPalindrome(string s)\\n    {\\n        const auto [it, rit] = mismatch(cbegin(s), cend(s), crbegin(s));\\n        return it == cend(s) ||\\n               equal(it + 1, rit.base(), rit) ||\\n               equal(rit + 1, make_reverse_iterator(it), it);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1644536,
                "title": "simple-2-pointer-approach-with-small-optimization-beats-95-time-and-99-memory",
                "content": "This code is similar to lots of other 2 pointer approaches except it uses a more efficient way of determining a simple palindrome. \\n\\n\\tclass Solution:\\n\\tdef validPalindrome(self, s: str) -> bool:\\n\\n\\t\\tlp = 0              #starts at beginning of string\\n\\t\\trp = len(s) - 1     #starts at end of string\\n\\n\\t\\twhile lp < rp:      #while end of string index > beginning of string index\\n\\t\\t\\tif s[lp] == s[rp]: #advance index, palindrome!\\n\\t\\t\\t\\tlp += 1\\n\\t\\t\\t\\trp -= 1\\n\\t\\t\\telse:           #palindrome encountered different letter\\n\\t\\t\\t\\tcand_s = s[:lp] + s[lp+1:]  #skips letter on the left pointer side (\\'abca\\' skips b)\\n\\t\\t\\t\\tif self.is_pal(cand_s):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tcand_s = s[:rp] + s[rp+1:]  #skips letter on the right pointer side (\\'abca\\' skips c)\\n\\t\\t\\t\\tif self.is_pal(cand_s):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\treturn False\\n\\n\\t\\treturn True                              #assuming no letter differences were encountered, just return True\\n\\n\\tdef is_pal(self, s: str) -> bool:\\n\\t\\trevS = s[::-1]                      #reverses string\\n\\t\\tif s == revS:                       #checks if palindrome\\n\\t\\t\\treturn True\\n\\t\\treturn False",
                "solutionTags": [
                    "Python"
                ],
                "code": "This code is similar to lots of other 2 pointer approaches except it uses a more efficient way of determining a simple palindrome. \\n\\n\\tclass Solution:\\n\\tdef validPalindrome(self, s: str) -> bool:\\n\\n\\t\\tlp = 0              #starts at beginning of string\\n\\t\\trp = len(s) - 1     #starts at end of string\\n\\n\\t\\twhile lp < rp:      #while end of string index > beginning of string index\\n\\t\\t\\tif s[lp] == s[rp]: #advance index, palindrome!\\n\\t\\t\\t\\tlp += 1\\n\\t\\t\\t\\trp -= 1\\n\\t\\t\\telse:           #palindrome encountered different letter\\n\\t\\t\\t\\tcand_s = s[:lp] + s[lp+1:]  #skips letter on the left pointer side (\\'abca\\' skips b)\\n\\t\\t\\t\\tif self.is_pal(cand_s):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tcand_s = s[:rp] + s[rp+1:]  #skips letter on the right pointer side (\\'abca\\' skips c)\\n\\t\\t\\t\\tif self.is_pal(cand_s):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\treturn False\\n\\n\\t\\treturn True                              #assuming no letter differences were encountered, just return True\\n\\n\\tdef is_pal(self, s: str) -> bool:\\n\\t\\trevS = s[::-1]                      #reverses string\\n\\t\\tif s == revS:                       #checks if palindrome\\n\\t\\t\\treturn True\\n\\t\\treturn False",
                "codeTag": "Java"
            },
            {
                "id": 1582167,
                "title": "typescript-javascript-solution-with-two-pointers",
                "content": "The gist of this solution is to work from the outside in. I created a second function in order to make the character deletion easy to perform.\\n\\nI\\'m using a single loop with double pointers specified and looping until the pointers meet.\\n\\nMost solutions perform a string reversal and comparision once a mismatch is found. I decided to instead just continue the loop by calling the method again using the substrings and specifying that you cannot do this again. The string reversal takes O(n) to perform anyway, so doing this doesn\\'t reduce complexity.\\n\\n```\\nconst validPalindrome = (s: string): boolean => isPalindrome(s, true);\\n\\nfunction isPalindrome(s: string, canDelete: boolean): boolean {\\n    // loop through the outer characters moving towards the middle\\n    for(let left = 0, right = s.length - 1; left < right; left++, right--) {\\n        // if any character doesn\\'t match\\n        if(s[left] !== s[right])\\n            // return false if cant delete or if removing the right or left character will suffice by checking if the remaining substring is a palindrome\\n            return canDelete && (isPalindrome(s.slice(left + 1, right + 1), false) || isPalindrome(s.slice(left, right), false));\\n    }\\n    // if you\\'ve made it through the loop, it\\'s a palindrome\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers"
                ],
                "code": "```\\nconst validPalindrome = (s: string): boolean => isPalindrome(s, true);\\n\\nfunction isPalindrome(s: string, canDelete: boolean): boolean {\\n    // loop through the outer characters moving towards the middle\\n    for(let left = 0, right = s.length - 1; left < right; left++, right--) {\\n        // if any character doesn\\'t match\\n        if(s[left] !== s[right])\\n            // return false if cant delete or if removing the right or left character will suffice by checking if the remaining substring is a palindrome\\n            return canDelete && (isPalindrome(s.slice(left + 1, right + 1), false) || isPalindrome(s.slice(left, right), false));\\n    }\\n    // if you\\'ve made it through the loop, it\\'s a palindrome\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1567330,
                "title": "python-3-two-pointer-approach",
                "content": "We already know a palindrome can only be formed if every s[i] and (len(s) - 1) - s[i] is the same, except if s has an odd number of characters, then the middle character can be ignored. Example aba <- is a palindrome. We also know that we can\\'t have something like abcda ever become a palindrome because more than 2 characters at  s[i] and (len(s) - 1) - s[i] are not identical so even if we remove one character, it will never work. Knowing this, we can safely say that if we have something like abca, we\\'re only subject to checking the first two characters,  s[i] and (len(s) - 1) - s[i] that don\\'t match. That is to say \\'b\\' and \\'c\\' are the first ones we\\'ll encounter so we just have to remove one of them, or rather, skip one of them and use the general palindrome checking algorithm to do the rest. If we remove one character, and it doesn\\'t return a palindrome, we\\'ll just remove the next, and if that does not return a palindrome, then it can never be a palindrome.\\n\\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        left = 0\\n        right = len(s) - 1\\n        \\n        while left < right:\\n            if s[left] != s[right]:\\n                return self.check_palindrome_with_skip(s, left) or self.check_palindrome_with_skip(s, right)\\n            else:\\n                left += 1\\n                right -= 1\\n                \\n        return True\\n            \\n    def check_palindrome_with_skip(self, s: str, int_to_skip: int) -> bool:\\n        left = 0\\n        right = len(s) - 1\\n        \\n        while left < right:\\n            if int_to_skip == left:\\n                left += 1\\n                continue\\n                \\n            if int_to_skip == right:\\n                right -= 1\\n                continue\\n            \\n            if s[left] != s[right]:\\n                return False\\n            else:\\n                left += 1\\n                right -= 1\\n            \\n        return True\\n    \\n```\\n\\nTime Complexity: O(n) for the validPalindrome function, and O(n) for the check_palindrom_with_skip function, which makes it O(2N), drop your contant, and you just have O(N), or linear time.\\n\\nSpace is of course O(1), we don\\'t use any extra data structure/space.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        left = 0\\n        right = len(s) - 1\\n        \\n        while left < right:\\n            if s[left] != s[right]:\\n                return self.check_palindrome_with_skip(s, left) or self.check_palindrome_with_skip(s, right)\\n            else:\\n                left += 1\\n                right -= 1\\n                \\n        return True\\n            \\n    def check_palindrome_with_skip(self, s: str, int_to_skip: int) -> bool:\\n        left = 0\\n        right = len(s) - 1\\n        \\n        while left < right:\\n            if int_to_skip == left:\\n                left += 1\\n                continue\\n                \\n            if int_to_skip == right:\\n                right -= 1\\n                continue\\n            \\n            if s[left] != s[right]:\\n                return False\\n            else:\\n                left += 1\\n                right -= 1\\n            \\n        return True\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555504,
                "title": "my-java-recursive-solution-beat-100",
                "content": "```\\n    public boolean validPalindrome(String s) {\\n        return helper(s, 0, s.length()-1, 0);\\n    }\\n    \\n    private boolean helper(String s, int i, int j, int sum){\\n        if(sum>1)\\n            return false;\\n        while(i<j && s.charAt(i)==s.charAt(j)){\\n            i++;j--;\\n        }\\n        if(i>=j)\\n            return true;\\n        else\\n            return helper(s, i+1, j, sum+1)|| helper(s, i, j-1, sum+1);\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean validPalindrome(String s) {\\n        return helper(s, 0, s.length()-1, 0);\\n    }\\n    \\n    private boolean helper(String s, int i, int j, int sum){\\n        if(sum>1)\\n            return false;\\n        while(i<j && s.charAt(i)==s.charAt(j)){\\n            i++;j--;\\n        }\\n        if(i>=j)\\n            return true;\\n        else\\n            return helper(s, i+1, j, sum+1)|| helper(s, i, j-1, sum+1);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1492149,
                "title": "simple-python-no-recursion",
                "content": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        if s == s[::-1]:\\n            return True\\n        counter = 0\\n        option = False\\n        i,j = 0, len(s) - 1\\n        while i <= j:\\n            if s[i] == s[j]:\\n                i += 1\\n                j -= 1\\n            else:\\n                if (s[i+1:j+1] == s[j:i:-1]) or (s[i:j] == s[j-1:i:-1]+s[i]):\\n                    return True\\n                else:\\n                    return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        if s == s[::-1]:\\n            return True\\n        counter = 0\\n        option = False\\n        i,j = 0, len(s) - 1\\n        while i <= j:\\n            if s[i] == s[j]:\\n                i += 1\\n                j -= 1\\n            else:\\n                if (s[i+1:j+1] == s[j:i:-1]) or (s[i:j] == s[j-1:i:-1]+s[i]):\\n                    return True\\n                else:\\n                    return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451296,
                "title": "python3-nice-solution-faster-than-96-60-memory-less-than-91-12",
                "content": "![image](https://assets.leetcode.com/users/images/1ee60d58-de0b-4b09-b256-5d2edb1cff31_1631070343.997665.png)\\n\\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n\\n        if s == s[::-1]:\\n            return True\\n        i, j = 0, len(s) - 1\\n        while i <= j:\\n            if s[i] != s[j]:\\n                s1, s2 = s[i + 1: j + 1], s[i: j]\\n                break\\n            i , j = i + 1, j - 1\\n\\n        return s1 == s1[::-1] or s2 == s2[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n\\n        if s == s[::-1]:\\n            return True\\n        i, j = 0, len(s) - 1\\n        while i <= j:\\n            if s[i] != s[j]:\\n                s1, s2 = s[i + 1: j + 1], s[i: j]\\n                break\\n            i , j = i + 1, j - 1\\n\\n        return s1 == s1[::-1] or s2 == s2[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445517,
                "title": "simple-c-solutions-90-beat-cpp-solution",
                "content": "```\\n  bool isPan(int i,int j,string s){\\n     while(i<j){\\n         if(s[i]!=s[j]){\\n             return false;\\n             }\\n         i++;\\n         j--;\\n         }\\n      return true;\\n      }\\n    bool validPalindrome(string s) {\\n  int i=0, j=s.size()-1;\\n     while(i<j){\\n         if(s[i]==s[j]){\\n             i++;\\n             j--;\\n             }\\n         else {\\n         return isPan(i+1,j,s) || isPan(i,j-1,s);\\n         }\\n         }\\n        return true;\\n        \\n    }\\n \\xA0 \\xA0```\\n\\t//please upvote if u like.  \\uD83D\\uDE4F\\uD83D\\uDC4D",
                "solutionTags": [],
                "code": "```\\n  bool isPan(int i,int j,string s){\\n     while(i<j){\\n         if(s[i]!=s[j]){\\n             return false;\\n             }\\n         i++;\\n         j--;\\n         }\\n      return true;\\n      }\\n    bool validPalindrome(string s) {\\n  int i=0, j=s.size()-1;\\n     while(i<j){\\n         if(s[i]==s[j]){\\n             i++;\\n             j--;\\n             }\\n         else {\\n         return isPan(i+1,j,s) || isPan(i,j-1,s);\\n         }\\n         }\\n        return true;\\n        \\n    }\\n \\xA0 \\xA0```",
                "codeTag": "Unknown"
            },
            {
                "id": 1423999,
                "title": "c-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // checks a part of string if it\\'s palindrome or not\\n    bool check(string A, int s, int e) {\\n        while(s <= e){\\n            if(A[s] != A[e])\\n                return false;\\n            \\n            s++;\\n            e--;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    bool validPalindrome(string A) {\\n        int s = 0;\\n        int e = A.size() - 1;\\n        while(s <= e) {\\n            if(A[s] != A[e]) {\\n                // delete s or e and check for [s+1 to e] or [s to e-1]\\n                if(check(A, s+1, e) || check(A, s, e-1))\\n                    return true;\\n                else\\n                    return false;\\n            }\\n            s++; \\n            e--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // checks a part of string if it\\'s palindrome or not\\n    bool check(string A, int s, int e) {\\n        while(s <= e){\\n            if(A[s] != A[e])\\n                return false;\\n            \\n            s++;\\n            e--;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    bool validPalindrome(string A) {\\n        int s = 0;\\n        int e = A.size() - 1;\\n        while(s <= e) {\\n            if(A[s] != A[e]) {\\n                // delete s or e and check for [s+1 to e] or [s to e-1]\\n                if(check(A, s+1, e) || check(A, s, e-1))\\n                    return true;\\n                else\\n                    return false;\\n            }\\n            s++; \\n            e--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421446,
                "title": "java-solution-runtime-beats-100-00-of-java-submissions",
                "content": "\\nclass Solution {\\n\\n    public boolean validPalindrome(String s) {\\n        \\n        return isPalindrome(s, 0, s.length()-1,0);\\n    }\\n    \\n    public boolean isPalindrome(String s, int start, int end, int deleted) {\\n        int pStart = start;\\n        int pEnd = end;\\n        \\n        while(pStart < pEnd) {\\n            if(s.charAt(pStart) != s.charAt(pEnd)) {\\n                if(deleted == 0 \\n                   && (isPalindrome(s, pStart + 1, pEnd, 1) || isPalindrome(s, pStart, pEnd-1, 1))) \\n                    return true;\\n                else\\n                    return false;\\n            }\\n            pStart++;\\n            pEnd--;\\n        }\\n        return true;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean validPalindrome(String s) {\\n        \\n        return isPalindrome(s, 0, s.length()-1,0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1343860,
                "title": "c-logic-explained-code-with-comments-easy-explained",
                "content": "* Lets build the logic first.\\nSay the given string is s=\"acbc\"\\nAt frist, we try to find where a mismatch occurs. Say we assain a pointer to the beginning and a pointer to the last position. i.e i=0,j=2;\\n* Now we check if s[i] != s[j], if it is so, then a mismatch occured. We can either delete s[i] and check if s is palindrome, or we can delete s[j] and check if s is palindorme. In this case, s[0]!=s[2], so we delete s[2], the rest is acb, which is not palindrome. Now we delete s[0], the string is now cbc which is a palindrome. So the final answer is Yes. \\nThe code is given below:\\n```\\nclass Solution {\\npublic:\\n    bool palin(string s,int index) //this function delete s[i] or s[j] \\n    {                                           // and checks whether rest is palindrome or not\\n        string temp1,temp2;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(i!=index) temp1+=s[i];\\n        }\\n        temp2=temp1;\\n        reverse(temp2.begin(),temp2.end());\\n        if(temp1==temp2) return true;\\n        return false;\\n    }\\n    bool validPalindrome(string s) {\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j]) //mismatch occured;\\n            {\\n                if(palin(s,i)==true) return true; //delete s[i] and check;\\n                if(palin(s,j)==true) return true; //delete s[j] and check;\\n                return false; \\n            }\\n            i++; // s[i]==s[j], so i++ and j-- \\n            j--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool palin(string s,int index) //this function delete s[i] or s[j] \\n    {                                           // and checks whether rest is palindrome or not\\n        string temp1,temp2;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(i!=index) temp1+=s[i];\\n        }\\n        temp2=temp1;\\n        reverse(temp2.begin(),temp2.end());\\n        if(temp1==temp2) return true;\\n        return false;\\n    }\\n    bool validPalindrome(string s) {\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j]) //mismatch occured;\\n            {\\n                if(palin(s,i)==true) return true; //delete s[i] and check;\\n                if(palin(s,j)==true) return true; //delete s[j] and check;\\n                return false; \\n            }\\n            i++; // s[i]==s[j], so i++ and j-- \\n            j--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317640,
                "title": "c-two-pointer-explained",
                "content": "```\\nclass Solution {\\npublic:\\n   /*\\n   Just maintain 2 pointers i.e for start and end of string\\n    Keep checking if they are same\\n\\n    If they are Same - then just check inside and keep going till you reach the center(left==right)(if       odd string) or left>right (if even string)\\n    If they are NOT same : You now have 2 options\\n    1) Remove Left Element and Check for the Rest of String OR\\n    2) Remove Right Element and Check for the Rest of the string.\\n    If either of them dont give palindrome then its not a palindorme.\\n    */\\n\\n    \\n    \\n    //using recursive function\\n    bool ispalindrome(string s,int left,int right,int count)\\n    {\\n        if(count>1)\\n            return false;\\n        while(left<=right)\\n        {\\n            if(s[left]!=s[right])\\n            {\\n                return (ispalindrome(s,left+1,right,count+1)||ispalindrome(s,left,right-1,count+1));\\n            }\\n            else\\n            {\\n                left++;\\n                right--;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n    \\n    \\n    bool validPalindrome(string s) {\\n        \\n        int count=0;\\n        int left=0;\\n        int right=s.size()-1;\\n        return ispalindrome(s,left,right,count);\\n        \\n    }\\n};\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   /*\\n   Just maintain 2 pointers i.e for start and end of string\\n    Keep checking if they are same\\n\\n    If they are Same - then just check inside and keep going till you reach the center(left==right)(if       odd string) or left>right (if even string)\\n    If they are NOT same : You now have 2 options\\n    1) Remove Left Element and Check for the Rest of String OR\\n    2) Remove Right Element and Check for the Rest of the string.\\n    If either of them dont give palindrome then its not a palindorme.\\n    */\\n\\n    \\n    \\n    //using recursive function\\n    bool ispalindrome(string s,int left,int right,int count)\\n    {\\n        if(count>1)\\n            return false;\\n        while(left<=right)\\n        {\\n            if(s[left]!=s[right])\\n            {\\n                return (ispalindrome(s,left+1,right,count+1)||ispalindrome(s,left,right-1,count+1));\\n            }\\n            else\\n            {\\n                left++;\\n                right--;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n    \\n    \\n    bool validPalindrome(string s) {\\n        \\n        int count=0;\\n        int left=0;\\n        int right=s.size()-1;\\n        return ispalindrome(s,left,right,count);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306406,
                "title": "kotlin-o-n-time-o-1-space",
                "content": "```\\n  fun validPalindrome(s: String): Boolean {\\n        var (start, end) = 0 to s.length-1\\n        while(start < end) {\\n            if(s[start++] != s[end--]) {\\n                return isPalindrome(s,start,end+1) || isPalindrome(s,start-1,end)\\n            }\\n        }\\n        return true\\n    }\\n    \\n   private fun isPalindrome(s: String, start: Int, end: Int) : Boolean {\\n        var (start, end) = start to end\\n        while(start < end) {\\n            if(s[start++] != s[end--])  return false\\n        }\\n        return true\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  fun validPalindrome(s: String): Boolean {\\n        var (start, end) = 0 to s.length-1\\n        while(start < end) {\\n            if(s[start++] != s[end--]) {\\n                return isPalindrome(s,start,end+1) || isPalindrome(s,start-1,end)\\n            }\\n        }\\n        return true\\n    }\\n    \\n   private fun isPalindrome(s: String, start: Int, end: Int) : Boolean {\\n        var (start, end) = start to end\\n        while(start < end) {\\n            if(s[start++] != s[end--])  return false\\n        }\\n        return true\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1303908,
                "title": "c-intuitive-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int cnt = 1;\\n    bool fun(int l,int r,string &s){\\n        if(l>=r) return true; \\n        if(s[l] == s[r]){\\n            return fun(l+1,r-1,s); \\n        }\\n        \\n        if(cnt == 1){\\n            cnt++;\\n            return (fun(l+1,r,s) or fun(l,r-1,s));\\n        }\\n        return false;\\n    }\\n    \\n    bool validPalindrome(string s) {\\n        int n = s.size()-1;\\n        return fun(0,n,s);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int cnt = 1;\\n    bool fun(int l,int r,string &s){\\n        if(l>=r) return true; \\n        if(s[l] == s[r]){\\n            return fun(l+1,r-1,s); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1212760,
                "title": "easiest-solution",
                "content": "**Please upvote to increase my motivation**\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s, int l, int r)\\n    {\\n        while(l<r)\\n        {\\n            if(s[l]!=s[r])\\n                return false;\\n            l++;\\n            r--;\\n        }\\n        \\n        return true;\\n    }\\n    bool validPalindrome(string s) {\\n        int l = 0;\\n        int r = s.length()-1;\\n        while(l<r)\\n        {\\n            if(s[l]!=s[r])\\n                break;\\n            l++;\\n            r--;\\n        }\\n        \\n        return(isValid(s,l+1,r) || isValid(s,l,r-1));\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isValid(string s, int l, int r)\\n    {\\n        while(l<r)\\n        {\\n            if(s[l]!=s[r])\\n                return false;\\n            l++;\\n            r--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1151249,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn valid_palindrome(s: String) -> bool {\\n        Self::helper(&s.as_bytes(), true)\\n    }\\n\\n    fn helper(chars: &[u8], can_skip: bool) -> bool {\\n        if chars.len() == 0 || chars.len() == 1 {\\n            return true;\\n        }\\n\\n        let mut i = 0;\\n        let mut j = chars.len() - 1;\\n        while i <= j {\\n            if chars[i] == chars[j] {\\n                i += 1;\\n                j -= 1;\\n                continue;\\n            }\\n            if !can_skip {\\n                return false;\\n            }\\n            if Self::helper(&chars[(i + 1)..=j], false) {\\n                return true;\\n            } else if Self::helper(&chars[i..=(j - 1)], false) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Two Pointers"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn valid_palindrome(s: String) -> bool {\\n        Self::helper(&s.as_bytes(), true)\\n    }\\n\\n    fn helper(chars: &[u8], can_skip: bool) -> bool {\\n        if chars.len() == 0 || chars.len() == 1 {\\n            return true;\\n        }\\n\\n        let mut i = 0;\\n        let mut j = chars.len() - 1;\\n        while i <= j {\\n            if chars[i] == chars[j] {\\n                i += 1;\\n                j -= 1;\\n                continue;\\n            }\\n            if !can_skip {\\n                return false;\\n            }\\n            if Self::helper(&chars[(i + 1)..=j], false) {\\n                return true;\\n            } else if Self::helper(&chars[i..=(j - 1)], false) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1149448,
                "title": "c-680-valid-palindrome-ii",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        for (int lo = 0, hi = s.size()-1; lo < hi; ++lo, --hi) {\\n            if (s[lo] != s[hi]) {\\n                for (int l = lo+1, h = hi; s[l] == s[h]; ++l, --h) \\n                    if (l >= h) return true; \\n                for (int l = lo, h = hi-1; s[l] == s[h]; ++l, --h) \\n                    if (l >= h) return true; \\n                return false; \\n            }\\n        }\\n        return true; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        for (int lo = 0, hi = s.size()-1; lo < hi; ++lo, --hi) {\\n            if (s[lo] != s[hi]) {\\n                for (int l = lo+1, h = hi; s[l] == s[h]; ++l, --h) \\n                    if (l >= h) return true; \\n                for (int l = lo, h = hi-1; s[l] == s[h]; ++l, --h) \\n                    if (l >= h) return true; \\n                return false; \\n            }\\n        }\\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081335,
                "title": "java-solution-with-two-pointers",
                "content": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int left = 0;\\n        int right = s.length()-1;\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right)) return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1);\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isPalindrome(String s, int left, int right){\\n        while (left < right){\\n            if (s.charAt(left) != s.charAt(right)) return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean validPalindrome(String s) {\\n        int left = 0;\\n        int right = s.length()-1;\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right)) return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1);\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isPalindrome(String s, int left, int right){\\n        while (left < right){\\n            if (s.charAt(left) != s.charAt(right)) return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 973998,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        S_1=list(s)\\n        S_2=list(s)\\n        if s==s[::-1]:\\n            return True\\n        for i in range(len(s)//2):\\n            if  s[i]!=s[-1-i]:\\n                S_1.pop(i)\\n                S_2.pop(-1-i)\\n                if S_1==S_1[::-1] or S_2==S_2[::-1]:\\n                    return True\\n                else:\\n                    return False\\n        return True\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        S_1=list(s)\\n        S_2=list(s)\\n        if s==s[::-1]:\\n            return True\\n        for i in range(len(s)//2):\\n            if  s[i]!=s[-1-i]:\\n                S_1.pop(i)\\n                S_2.pop(-1-i)\\n                if S_1==S_1[::-1] or S_2==S_2[::-1]:\\n                    return True\\n                else:\\n                    return False\\n        return True\\n",
                "codeTag": "Java"
            },
            {
                "id": 935342,
                "title": "javascript-solution",
                "content": "```\\nvar validPalindrome = function(s) {\\n    let left = 0;\\n    let right = s.length - 1;\\n    \\n    while (left < right) {\\n        if (s.charAt(left) != s.charAt(right)) {\\n            return isValid(left + 1, right) || isValid(left, right - 1);\\n        }\\n        left++;\\n        right--;\\n    }\\n    \\n    return true;\\n    \\n    \\n    function isValid(left, right) {\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar validPalindrome = function(s) {\\n    let left = 0;\\n    let right = s.length - 1;\\n    \\n    while (left < right) {\\n        if (s.charAt(left) != s.charAt(right)) {\\n            return isValid(left + 1, right) || isValid(left, right - 1);\\n        }\\n        left++;\\n        right--;\\n    }\\n    \\n    return true;\\n    \\n    \\n    function isValid(left, right) {\\n        while (left < right) {\\n            if (s.charAt(left) != s.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 930873,
                "title": "kotlin-o-n-time-and-o-1-space",
                "content": "\\n    fun validPalindrome(s: String): Boolean {\\n        var l = 0; var r = s.length - 1\\n        while (l < r) {\\n            if (s[l] != s[r]) {\\n                return isPalindrome(s, l + 1, r)\\n                    || isPalindrome(s, l, r - 1)\\n            }\\n            l++; r--\\n        }\\n        return true\\n    }\\n    fun isPalindrome(s: String, i: Int, j: Int): Boolean {\\n        var l = i; var r = j\\n        while (l < r) {\\n            if (s[l++] != s[r--]) return false\\n        }\\n        return true\\n    }\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "\\n    fun validPalindrome(s: String): Boolean {\\n        var l = 0; var r = s.length - 1\\n        while (l < r) {\\n            if (s[l] != s[r]) {\\n                return isPalindrome(s, l + 1, r)\\n                    || isPalindrome(s, l, r - 1)\\n            }\\n            l++; r--\\n        }\\n        return true\\n    }\\n    fun isPalindrome(s: String, i: Int, j: Int): Boolean {\\n        var l = i; var r = j\\n        while (l < r) {\\n            if (s[l++] != s[r--]) return false\\n        }\\n        return true\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 884413,
                "title": "python-string-reversed-manipulation-by-start-end-index-comparison",
                "content": "Check whether start, end index character is same. \\nif not, remove one char and check whether it is palindrome (after removing).\\n\\n```\\nclass Solution(object):\\n    def validPalindrome(self, s):\\n        i, j = 0, len(s)-1\\n        while i < j:\\n            if s[i] != s[j]:\\n                a=s[:i]+s[i+1:]\\n                b=s[:j]+s[j+1:]\\n                return a == a[::-1] or b == b[::-1]\\n            else:\\n                i += 1\\n                j -= 1\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def validPalindrome(self, s):\\n        i, j = 0, len(s)-1\\n        while i < j:\\n            if s[i] != s[j]:\\n                a=s[:i]+s[i+1:]\\n                b=s[:j]+s[j+1:]\\n                return a == a[::-1] or b == b[::-1]\\n            else:\\n                i += 1\\n                j -= 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851904,
                "title": "simple-easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n            # initialize left, right pointers\\n            l =0\\n            r = len(s)-1            \\n            while l <= r:\\n                if s[l] != s[r]:\\n                    # if the left and right does not match\\n                    # check the 2 possible strings by removing left, right characters are palindrome\\n                    one, two = s[l:r], s[l+1:r+1]\\n                    return (one == one[::-1]) or (two == two[::-1])                              \\n                l +=1\\n                r -=1                   \\n            return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n            # initialize left, right pointers\\n            l =0\\n            r = len(s)-1            \\n            while l <= r:\\n                if s[l] != s[r]:\\n                    # if the left and right does not match\\n                    # check the 2 possible strings by removing left, right characters are palindrome\\n                    one, two = s[l:r], s[l+1:r+1]\\n                    return (one == one[::-1]) or (two == two[::-1])                              \\n                l +=1\\n                r -=1                   \\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 634682,
                "title": "java-beats-100-and-generalise-for-at-most-k-character-delete",
                "content": "This is generalise solution for at most K character delete.\\n```\\npublic boolean helper(String s,int start, int end,int deleted,int k){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)){\\n                if(deleted==k){\\n                    return false;\\n                }\\n                return helper(s,start+1,end,deleted+1,k) || helper(s,start,end-1,deleted+1,k);\\n            }else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean validPalindrome(String s) {\\n        int k=1;    //at most k character delete\\n        return helper(s,0,s.length()-1,0,k);\\n\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic boolean helper(String s,int start, int end,int deleted,int k){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)){\\n                if(deleted==k){\\n                    return false;\\n                }\\n                return helper(s,start+1,end,deleted+1,k) || helper(s,start,end-1,deleted+1,k);\\n            }else{\\n                start++;\\n                end--;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean validPalindrome(String s) {\\n        int k=1;    //at most k character delete\\n        return helper(s,0,s.length()-1,0,k);\\n\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 597048,
                "title": "optimization-of-the-brute-force-approach",
                "content": "Reverse at the beginning only once, and then iterate over each character to see if the original & reversed strings are the same if that character is removed. Iterates over the string twice, but still O(n) runtime & space complexity\\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        rev = s[::-1]\\n        \\n        if s == rev:\\n            return True\\n        \\n        len_s = len(s)\\n        for i in range(len_s):\\n            if s[0:i]+s[i+1:] == rev[0:len_s - i - 1]+rev[len_s - i:]:\\n                return True\\n        \\n        return False",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Reverse at the beginning only once, and then iterate over each character to see if the original & reversed strings are the same if that character is removed. Iterates over the string twice, but still O(n) runtime & space complexity\\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        rev = s[::-1]\\n        \\n        if s == rev:\\n            return True\\n        \\n        len_s = len(s)\\n        for i in range(len_s):\\n            if s[0:i]+s[i+1:] == rev[0:len_s - i - 1]+rev[len_s - i:]:\\n                return True\\n        \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 525918,
                "title": "c-simple-solution",
                "content": "``` cpp\\n    bool validPalindrome(string s, bool fixed = false) {\\n        int l(0), r(s.size() - 1);\\n        while(l < r){\\n            if(s[l] != s[r]){\\n                if(fixed) return false;\\n                fixed = true;\\n                return validPalindrome(s.substr(l, r - l), fixed) || validPalindrome(s.substr(l + 1, r - l), fixed);\\n            }\\n            r--;\\n            l++;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` cpp\\n    bool validPalindrome(string s, bool fixed = false) {\\n        int l(0), r(s.size() - 1);\\n        while(l < r){\\n            if(s[l] != s[r]){\\n                if(fixed) return false;\\n                fixed = true;\\n                return validPalindrome(s.substr(l, r - l), fixed) || validPalindrome(s.substr(l + 1, r - l), fixed);\\n            }\\n            r--;\\n            l++;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 443573,
                "title": "two-simple-ruby-solution-without-using-reverse-two-pointers",
                "content": "```\\ndef valid_palindrome(s)\\n  l, r = 0, s.length-1\\n  @str = s\\n  while(l<r)\\n    return palindrome(l, r-1) || palindrome(l+1, r) if s[l] != s[r]\\n    l += 1\\n    r -= 1\\n  end\\n  true\\nend\\n```\\n**Iteration**\\n```\\ndef palindrome(l, r)\\n  while(l<r)\\n    return false if @str[l] != @str[r]\\n    l += 1\\n    r -= 1\\n  end\\n  true\\nend\\n```\\n**Recursion**\\n```\\ndef palindrome(l, r)\\n  return true if l >= r\\n  @str[l] == @str[r] && palindrome(l+1, r-1)\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef valid_palindrome(s)\\n  l, r = 0, s.length-1\\n  @str = s\\n  while(l<r)\\n    return palindrome(l, r-1) || palindrome(l+1, r) if s[l] != s[r]\\n    l += 1\\n    r -= 1\\n  end\\n  true\\nend\\n```\n```\\ndef palindrome(l, r)\\n  while(l<r)\\n    return false if @str[l] != @str[r]\\n    l += 1\\n    r -= 1\\n  end\\n  true\\nend\\n```\n```\\ndef palindrome(l, r)\\n  return true if l >= r\\n  @str[l] == @str[r] && palindrome(l+1, r-1)\\nend\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1575679,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1775839,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1575106,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1569587,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1565647,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1834185,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1895700,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1829461,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1818785,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1575925,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1575679,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1775839,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1575106,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1569587,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1565647,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1834185,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1895700,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1829461,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1818785,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1575925,
                "content": [
                    {
                        "username": "Bulbasaur2000",
                        "content": "**Firstly, donot worry if you are not able to understand the problem or come up with a valid logic. Even I too get stuck a lot in different problems. As long as you understand the concept, the logic after taking help, and able to code it, you are a champion **\\n\\nLogic: For this types of String Palindrome problems, its always better to start thinking using two pointer approach. The following approach is based on that concept.\\n\\nApproach: \\n1. Firstly check three basic corner cases of string length=0, string length=1 and string length=2. Return accordingly.\\n2. Use an extra O(n) space to store the array, reverse it and directly check if its pallindrome or not. \\n\\tThese two approaches will save a lot of time.\\n3. Using the concept of two pointers, start traversing the string character by character from front and from the\\n    back. If all the the characters comes up to be same, your string must be pallindrome.\\n4. If two characters comes up as not the same, try checking neglecting both the character one at a time, and check\\n    if the rest of available string is pallindrome or not **(clue: use another function for this checking part)**. \\n5. If it comes true even after neglecting any one of the unmatched character. Your string must be pallindrome. Else \\n   it cannot be a pallindrome.\\n   \\nNow code it. Happy Hunting!\\n**  If you find my solution helpful, kindly upvote my answer. It will help others and also motivate me.**\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Thanks for the post. This was exactly the logic I came up with. Just because this was an \\'easy\\' problem, I thought It will only take less time. I was wrong."
                    },
                    {
                        "username": "sjannali",
                        "content": "Great Post."
                    },
                    {
                        "username": "Subh001",
                        "content": " private boolean mismatch(String s){\\n       int n=s.length();\\n       for(int i=0,j=n-1;i<n-1&&j>=0;++i,--j){\\nif(s.charAt(i)!=s.charAt(j)){\\n    i++;\\n if(s.charAt(i)==s.charAt(j))   \\n return true;\\n}\\n       }\\n       return false;\\n\\nthis is that another function but i am getting wrong ans for \"atbbga\".....kindly help to resolve error"
                    },
                    {
                        "username": "PrasadChaskar",
                        "content": "Thank You \\nHelps me a lot ;-)"
                    },
                    {
                        "username": "cjatherton19",
                        "content": "I think this is a more of medium. So don\\'t be discouraged"
                    },
                    {
                        "username": "Wowtschikus",
                        "content": "same here"
                    },
                    {
                        "username": "milez",
                        "content": "How many of you were able to solve 458 out of 500, but ended up having to debug this string with length 100?\\nMany of us might try to simply check only once if `s[i] = s[j-1] or s[i+1] = s[j]` and think that would be enough. It is only with this edge test case do we notice that is not the case.\\n\\nRather than debugging it, I had to search for (458 out of 500) and luckily found one post that was in the same situation"
                    },
                    {
                        "username": "wangyawen12",
                        "content": "[@anurag-pathak](/anurag-pathak) same"
                    },
                    {
                        "username": "vfreitas00",
                        "content": "One way to help debugging is just making the string shorter. The problem in this case only happens in a set of 2–3 characters, just remove the rest and create a test case with like 6-8 characters."
                    },
                    {
                        "username": "Jordan-Rowland",
                        "content": "I'm also stuck on test cast 458 of 469. I use a temp variable called \"can_replace\" that starts as True, and then if a [j+1] or [j-1] condition passes, I change it to False and increment only one of the pointers, but still failing. Driving me crazy!\n\nI do, however, see what the issue is and I'm trying to solve it..."
                    },
                    {
                        "username": "19o6",
                        "content": "what did you find ?"
                    },
                    {
                        "username": "anurag-pathak",
                        "content": "Yeah I am also not getting why is that two condition not sufficient? Mine failing in 462nd test case though."
                    },
                    {
                        "username": "cbb011",
                        "content": "If one wanted to delete c, wouldn\\'t \"ab\" create a palindrome?"
                    },
                    {
                        "username": "mochiball",
                        "content": "ab != ba "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bruh how?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ab != ba"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/valid-palindrome-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sanyam0410",
                        "content": "  `462 Failed GANG`\\n\\n`Consider this : \"deddde\"`\\nHere if you you delete last \"e\" without even checking for deletion of first \"d\", the answer will be returned false. now if you delete first \"d\", you will get true. So here you have to check palindrome for both the deletions and then whichever gives true, we consider that as answer.\\n\\nCreate separate function for normal isPalindrome and then call for both the possibilities.\\n\\nUPVOTE if helped. "
                    },
                    {
                        "username": "vaysman",
                        "content": "Thanks. For me your example wasn\\'t relevant because at first I deleted first symbol and for \"deddde\" the test is passed.\\n\\nThe case when my logic was wrong is in \"abcbab\" (need to delete the last symbol instead of first)."
                    },
                    {
                        "username": "flaafy",
                        "content": "God bless you"
                    },
                    {
                        "username": "user9326oa",
                        "content": "very helpful"
                    },
                    {
                        "username": "avuzi",
                        "content": "Testcase \"ebcbbececabbacecbbcbe\" made me mad for a few minutes). But then I realized what is the problem.\ne b c b b ->e c e c a b b a c e ->c b b c b e\n'e' must be skipped and not 'c'"
                    },
                    {
                        "username": "anukrati12",
                        "content": "Stuck at this  test case : \"eeccccbebaeeabebccceea\"\\nmy program returns true for this test case because if you remove \"a\" from the end, then \"eeccccbebaeeabebcccee\" is a palindrome.\\n\\nbut the leet code test case and returns false. Why is that?"
                    },
                    {
                        "username": "Chusaa",
                        "content": "take a closer look"
                    },
                    {
                        "username": "jabae",
                        "content": "noob"
                    },
                    {
                        "username": "pequito193",
                        "content": "left side has 4c\\'s, right side has 3 c\\'s"
                    },
                    {
                        "username": "majszykpawel1996",
                        "content": "Any reason why this soulution gets timeout? For me it looks like its O(n) time, but it fails at one case\\'  `class Solution {\\n    \\n\\tpublic boolean validPalindrome(String s) {\\n        if(checkIfPalindrome(s, 0)) {\\n            return true;\\n        } else {\\n            for(int i = 0; i < s.length(); ++i) {\\n                if(checkIfPalindrome(s, i)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean checkIfPalindrome(String  str, int indexToIgnore) {\\n        int left = 0;\\n        int right = str.length() - 1;\\n        while (left < right) {\\n            if (left == indexToIgnore) {\\n                left++;\\n                continue;\\n            }\\n            if (right == indexToIgnore) {\\n                right--;\\n                continue;\\n            }\\n            if (str.charAt(left) != str.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "user5400vw",
                        "content": "minor but checkIfPalindrome(s, 0) is called twice"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "brother it is O(n^2) solution"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "please upvote\\n\\n ![image](https://assets.leetcode.com/users/images/b1958632-6143-40fa-9fa4-8e09363ff419_1635884238.2359433.png)\\n"
                    }
                ]
            },
            {
                "id": 1571975,
                "content": [
                    {
                        "username": "hongyanj",
                        "content": "I think this test case is missed:\\nacucucubucucucua"
                    },
                    {
                        "username": "karthikeyan4142",
                        "content": "Why abc is not a palindrome? If we remove one character, say it is \\'b\\' then, it become ac. ac==ca. so it forms a palindrome."
                    },
                    {
                        "username": "binarycoder006",
                        "content": "If we read it from starting it is a and c but if read it from end it is c then a\\ni.e it is not a palindrome."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "what if we remove \\'a\\' and \\'c\\'?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ac != ca"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "no :)"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "2 min | Hindi Video | 100 % You will understand\\nyoutube. com/watch?v=GQmPNs6tcZM"
                    },
                    {
                        "username": "amangaur6515",
                        "content": "linear time and constant space:\\n![image](https://assets.leetcode.com/users/images/7cbe0197-9d59-4369-bcf1-b8adf54d54dc_1649063322.0481198.png)\\n\\n\\n"
                    },
                    {
                        "username": "noormd",
                        "content": "Please don\\'t post solution in Discussion tab. Also you don\\'t need to pass the \\'str\\' in solve function. since it is a internal helper function, the input string is already accessible from outer scope."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "U can make it faster by removing variables x and y and substituting the expressions which were assigned to them (short circuit)"
                    },
                    {
                        "username": "ssumitbansal",
                        "content": "\"tebbem\" should return true. \\nProblem statement states that we can remove atmost 1 char \\nso if we remove \\'t\\' we can make -> ebmbe or bemeb\\nor if we remove \\'m\\' we can make ->ebtbe or beteb\\nAnyone else facing this or am i getting it wrong ?"
                    },
                    {
                        "username": "leet_0433",
                        "content": "order can\\'t be changed\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "No, you \"make\" it a palindrome by removing at most one char, nothing else. You can\\'t reorder the string."
                    },
                    {
                        "username": "Prahasit",
                        "content": "Why is this code wrong, I\\'m getting error in this output \"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga\" which passed 462/469 testcases\\n\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        l, r = 0, len(s)-1\\n        count=0\\n        while l<r:\\n            if s[l] == s[r]:\\n                l , r = l+1, r-1\\n            elif s[l+1] == s[r]:\\n                count+=1\\n                l = l + 1\\n            elif s[l] == s[r-1]:\\n                count+=1\\n                r = r - 1\\n            else:\\n                return False\\n            \\n            if count>1:\\n                return False\\n        return True"
                    },
                    {
                        "username": "vedranson",
                        "content": "At the first mismatch of s[l] and s[r] you have:\\n[ag ... mgml] cupuu ... uupucu [lmgm ... ga]\\nthen the code checks s[l+1] == s[r] and removes/ignores char \\'c\\' at s[l], but the char \\'u\\' to be removed/ignored is at s[r]."
                    },
                    {
                        "username": "Alcas1",
                        "content": "`cuppucu` Is a testcase that broke things for me. This is the difference between checking one side in the if statement vs checking both sides from then on. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is great palindrome problem for interviews because it prevents the compare with reverse() trick."
                    },
                    {
                        "username": "Tapeky",
                        "content": "Not as hard as people say. You can do it !"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "definitely one of the more difficult easy ones."
                    }
                ]
            },
            {
                "id": 1574913,
                "content": [
                    {
                        "username": "hongyanj",
                        "content": "I think this test case is missed:\\nacucucubucucucua"
                    },
                    {
                        "username": "karthikeyan4142",
                        "content": "Why abc is not a palindrome? If we remove one character, say it is \\'b\\' then, it become ac. ac==ca. so it forms a palindrome."
                    },
                    {
                        "username": "binarycoder006",
                        "content": "If we read it from starting it is a and c but if read it from end it is c then a\\ni.e it is not a palindrome."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "what if we remove \\'a\\' and \\'c\\'?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ac != ca"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "no :)"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "2 min | Hindi Video | 100 % You will understand\\nyoutube. com/watch?v=GQmPNs6tcZM"
                    },
                    {
                        "username": "amangaur6515",
                        "content": "linear time and constant space:\\n![image](https://assets.leetcode.com/users/images/7cbe0197-9d59-4369-bcf1-b8adf54d54dc_1649063322.0481198.png)\\n\\n\\n"
                    },
                    {
                        "username": "noormd",
                        "content": "Please don\\'t post solution in Discussion tab. Also you don\\'t need to pass the \\'str\\' in solve function. since it is a internal helper function, the input string is already accessible from outer scope."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "U can make it faster by removing variables x and y and substituting the expressions which were assigned to them (short circuit)"
                    },
                    {
                        "username": "ssumitbansal",
                        "content": "\"tebbem\" should return true. \\nProblem statement states that we can remove atmost 1 char \\nso if we remove \\'t\\' we can make -> ebmbe or bemeb\\nor if we remove \\'m\\' we can make ->ebtbe or beteb\\nAnyone else facing this or am i getting it wrong ?"
                    },
                    {
                        "username": "leet_0433",
                        "content": "order can\\'t be changed\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "No, you \"make\" it a palindrome by removing at most one char, nothing else. You can\\'t reorder the string."
                    },
                    {
                        "username": "Prahasit",
                        "content": "Why is this code wrong, I\\'m getting error in this output \"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga\" which passed 462/469 testcases\\n\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        l, r = 0, len(s)-1\\n        count=0\\n        while l<r:\\n            if s[l] == s[r]:\\n                l , r = l+1, r-1\\n            elif s[l+1] == s[r]:\\n                count+=1\\n                l = l + 1\\n            elif s[l] == s[r-1]:\\n                count+=1\\n                r = r - 1\\n            else:\\n                return False\\n            \\n            if count>1:\\n                return False\\n        return True"
                    },
                    {
                        "username": "vedranson",
                        "content": "At the first mismatch of s[l] and s[r] you have:\\n[ag ... mgml] cupuu ... uupucu [lmgm ... ga]\\nthen the code checks s[l+1] == s[r] and removes/ignores char \\'c\\' at s[l], but the char \\'u\\' to be removed/ignored is at s[r]."
                    },
                    {
                        "username": "Alcas1",
                        "content": "`cuppucu` Is a testcase that broke things for me. This is the difference between checking one side in the if statement vs checking both sides from then on. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is great palindrome problem for interviews because it prevents the compare with reverse() trick."
                    },
                    {
                        "username": "Tapeky",
                        "content": "Not as hard as people say. You can do it !"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "definitely one of the more difficult easy ones."
                    }
                ]
            },
            {
                "id": 1576569,
                "content": [
                    {
                        "username": "hongyanj",
                        "content": "I think this test case is missed:\\nacucucubucucucua"
                    },
                    {
                        "username": "karthikeyan4142",
                        "content": "Why abc is not a palindrome? If we remove one character, say it is \\'b\\' then, it become ac. ac==ca. so it forms a palindrome."
                    },
                    {
                        "username": "binarycoder006",
                        "content": "If we read it from starting it is a and c but if read it from end it is c then a\\ni.e it is not a palindrome."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "what if we remove \\'a\\' and \\'c\\'?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ac != ca"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "no :)"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "2 min | Hindi Video | 100 % You will understand\\nyoutube. com/watch?v=GQmPNs6tcZM"
                    },
                    {
                        "username": "amangaur6515",
                        "content": "linear time and constant space:\\n![image](https://assets.leetcode.com/users/images/7cbe0197-9d59-4369-bcf1-b8adf54d54dc_1649063322.0481198.png)\\n\\n\\n"
                    },
                    {
                        "username": "noormd",
                        "content": "Please don\\'t post solution in Discussion tab. Also you don\\'t need to pass the \\'str\\' in solve function. since it is a internal helper function, the input string is already accessible from outer scope."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "U can make it faster by removing variables x and y and substituting the expressions which were assigned to them (short circuit)"
                    },
                    {
                        "username": "ssumitbansal",
                        "content": "\"tebbem\" should return true. \\nProblem statement states that we can remove atmost 1 char \\nso if we remove \\'t\\' we can make -> ebmbe or bemeb\\nor if we remove \\'m\\' we can make ->ebtbe or beteb\\nAnyone else facing this or am i getting it wrong ?"
                    },
                    {
                        "username": "leet_0433",
                        "content": "order can\\'t be changed\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "No, you \"make\" it a palindrome by removing at most one char, nothing else. You can\\'t reorder the string."
                    },
                    {
                        "username": "Prahasit",
                        "content": "Why is this code wrong, I\\'m getting error in this output \"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga\" which passed 462/469 testcases\\n\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        l, r = 0, len(s)-1\\n        count=0\\n        while l<r:\\n            if s[l] == s[r]:\\n                l , r = l+1, r-1\\n            elif s[l+1] == s[r]:\\n                count+=1\\n                l = l + 1\\n            elif s[l] == s[r-1]:\\n                count+=1\\n                r = r - 1\\n            else:\\n                return False\\n            \\n            if count>1:\\n                return False\\n        return True"
                    },
                    {
                        "username": "vedranson",
                        "content": "At the first mismatch of s[l] and s[r] you have:\\n[ag ... mgml] cupuu ... uupucu [lmgm ... ga]\\nthen the code checks s[l+1] == s[r] and removes/ignores char \\'c\\' at s[l], but the char \\'u\\' to be removed/ignored is at s[r]."
                    },
                    {
                        "username": "Alcas1",
                        "content": "`cuppucu` Is a testcase that broke things for me. This is the difference between checking one side in the if statement vs checking both sides from then on. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is great palindrome problem for interviews because it prevents the compare with reverse() trick."
                    },
                    {
                        "username": "Tapeky",
                        "content": "Not as hard as people say. You can do it !"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "definitely one of the more difficult easy ones."
                    }
                ]
            },
            {
                "id": 1576578,
                "content": [
                    {
                        "username": "hongyanj",
                        "content": "I think this test case is missed:\\nacucucubucucucua"
                    },
                    {
                        "username": "karthikeyan4142",
                        "content": "Why abc is not a palindrome? If we remove one character, say it is \\'b\\' then, it become ac. ac==ca. so it forms a palindrome."
                    },
                    {
                        "username": "binarycoder006",
                        "content": "If we read it from starting it is a and c but if read it from end it is c then a\\ni.e it is not a palindrome."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "what if we remove \\'a\\' and \\'c\\'?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ac != ca"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "no :)"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "2 min | Hindi Video | 100 % You will understand\\nyoutube. com/watch?v=GQmPNs6tcZM"
                    },
                    {
                        "username": "amangaur6515",
                        "content": "linear time and constant space:\\n![image](https://assets.leetcode.com/users/images/7cbe0197-9d59-4369-bcf1-b8adf54d54dc_1649063322.0481198.png)\\n\\n\\n"
                    },
                    {
                        "username": "noormd",
                        "content": "Please don\\'t post solution in Discussion tab. Also you don\\'t need to pass the \\'str\\' in solve function. since it is a internal helper function, the input string is already accessible from outer scope."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "U can make it faster by removing variables x and y and substituting the expressions which were assigned to them (short circuit)"
                    },
                    {
                        "username": "ssumitbansal",
                        "content": "\"tebbem\" should return true. \\nProblem statement states that we can remove atmost 1 char \\nso if we remove \\'t\\' we can make -> ebmbe or bemeb\\nor if we remove \\'m\\' we can make ->ebtbe or beteb\\nAnyone else facing this or am i getting it wrong ?"
                    },
                    {
                        "username": "leet_0433",
                        "content": "order can\\'t be changed\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "No, you \"make\" it a palindrome by removing at most one char, nothing else. You can\\'t reorder the string."
                    },
                    {
                        "username": "Prahasit",
                        "content": "Why is this code wrong, I\\'m getting error in this output \"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga\" which passed 462/469 testcases\\n\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        l, r = 0, len(s)-1\\n        count=0\\n        while l<r:\\n            if s[l] == s[r]:\\n                l , r = l+1, r-1\\n            elif s[l+1] == s[r]:\\n                count+=1\\n                l = l + 1\\n            elif s[l] == s[r-1]:\\n                count+=1\\n                r = r - 1\\n            else:\\n                return False\\n            \\n            if count>1:\\n                return False\\n        return True"
                    },
                    {
                        "username": "vedranson",
                        "content": "At the first mismatch of s[l] and s[r] you have:\\n[ag ... mgml] cupuu ... uupucu [lmgm ... ga]\\nthen the code checks s[l+1] == s[r] and removes/ignores char \\'c\\' at s[l], but the char \\'u\\' to be removed/ignored is at s[r]."
                    },
                    {
                        "username": "Alcas1",
                        "content": "`cuppucu` Is a testcase that broke things for me. This is the difference between checking one side in the if statement vs checking both sides from then on. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is great palindrome problem for interviews because it prevents the compare with reverse() trick."
                    },
                    {
                        "username": "Tapeky",
                        "content": "Not as hard as people say. You can do it !"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "definitely one of the more difficult easy ones."
                    }
                ]
            },
            {
                "id": 1575061,
                "content": [
                    {
                        "username": "hongyanj",
                        "content": "I think this test case is missed:\\nacucucubucucucua"
                    },
                    {
                        "username": "karthikeyan4142",
                        "content": "Why abc is not a palindrome? If we remove one character, say it is \\'b\\' then, it become ac. ac==ca. so it forms a palindrome."
                    },
                    {
                        "username": "binarycoder006",
                        "content": "If we read it from starting it is a and c but if read it from end it is c then a\\ni.e it is not a palindrome."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "what if we remove \\'a\\' and \\'c\\'?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ac != ca"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "no :)"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "2 min | Hindi Video | 100 % You will understand\\nyoutube. com/watch?v=GQmPNs6tcZM"
                    },
                    {
                        "username": "amangaur6515",
                        "content": "linear time and constant space:\\n![image](https://assets.leetcode.com/users/images/7cbe0197-9d59-4369-bcf1-b8adf54d54dc_1649063322.0481198.png)\\n\\n\\n"
                    },
                    {
                        "username": "noormd",
                        "content": "Please don\\'t post solution in Discussion tab. Also you don\\'t need to pass the \\'str\\' in solve function. since it is a internal helper function, the input string is already accessible from outer scope."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "U can make it faster by removing variables x and y and substituting the expressions which were assigned to them (short circuit)"
                    },
                    {
                        "username": "ssumitbansal",
                        "content": "\"tebbem\" should return true. \\nProblem statement states that we can remove atmost 1 char \\nso if we remove \\'t\\' we can make -> ebmbe or bemeb\\nor if we remove \\'m\\' we can make ->ebtbe or beteb\\nAnyone else facing this or am i getting it wrong ?"
                    },
                    {
                        "username": "leet_0433",
                        "content": "order can\\'t be changed\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "No, you \"make\" it a palindrome by removing at most one char, nothing else. You can\\'t reorder the string."
                    },
                    {
                        "username": "Prahasit",
                        "content": "Why is this code wrong, I\\'m getting error in this output \"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga\" which passed 462/469 testcases\\n\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        l, r = 0, len(s)-1\\n        count=0\\n        while l<r:\\n            if s[l] == s[r]:\\n                l , r = l+1, r-1\\n            elif s[l+1] == s[r]:\\n                count+=1\\n                l = l + 1\\n            elif s[l] == s[r-1]:\\n                count+=1\\n                r = r - 1\\n            else:\\n                return False\\n            \\n            if count>1:\\n                return False\\n        return True"
                    },
                    {
                        "username": "vedranson",
                        "content": "At the first mismatch of s[l] and s[r] you have:\\n[ag ... mgml] cupuu ... uupucu [lmgm ... ga]\\nthen the code checks s[l+1] == s[r] and removes/ignores char \\'c\\' at s[l], but the char \\'u\\' to be removed/ignored is at s[r]."
                    },
                    {
                        "username": "Alcas1",
                        "content": "`cuppucu` Is a testcase that broke things for me. This is the difference between checking one side in the if statement vs checking both sides from then on. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is great palindrome problem for interviews because it prevents the compare with reverse() trick."
                    },
                    {
                        "username": "Tapeky",
                        "content": "Not as hard as people say. You can do it !"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "definitely one of the more difficult easy ones."
                    }
                ]
            },
            {
                "id": 2064737,
                "content": [
                    {
                        "username": "hongyanj",
                        "content": "I think this test case is missed:\\nacucucubucucucua"
                    },
                    {
                        "username": "karthikeyan4142",
                        "content": "Why abc is not a palindrome? If we remove one character, say it is \\'b\\' then, it become ac. ac==ca. so it forms a palindrome."
                    },
                    {
                        "username": "binarycoder006",
                        "content": "If we read it from starting it is a and c but if read it from end it is c then a\\ni.e it is not a palindrome."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "what if we remove \\'a\\' and \\'c\\'?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ac != ca"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "no :)"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "2 min | Hindi Video | 100 % You will understand\\nyoutube. com/watch?v=GQmPNs6tcZM"
                    },
                    {
                        "username": "amangaur6515",
                        "content": "linear time and constant space:\\n![image](https://assets.leetcode.com/users/images/7cbe0197-9d59-4369-bcf1-b8adf54d54dc_1649063322.0481198.png)\\n\\n\\n"
                    },
                    {
                        "username": "noormd",
                        "content": "Please don\\'t post solution in Discussion tab. Also you don\\'t need to pass the \\'str\\' in solve function. since it is a internal helper function, the input string is already accessible from outer scope."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "U can make it faster by removing variables x and y and substituting the expressions which were assigned to them (short circuit)"
                    },
                    {
                        "username": "ssumitbansal",
                        "content": "\"tebbem\" should return true. \\nProblem statement states that we can remove atmost 1 char \\nso if we remove \\'t\\' we can make -> ebmbe or bemeb\\nor if we remove \\'m\\' we can make ->ebtbe or beteb\\nAnyone else facing this or am i getting it wrong ?"
                    },
                    {
                        "username": "leet_0433",
                        "content": "order can\\'t be changed\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "No, you \"make\" it a palindrome by removing at most one char, nothing else. You can\\'t reorder the string."
                    },
                    {
                        "username": "Prahasit",
                        "content": "Why is this code wrong, I\\'m getting error in this output \"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga\" which passed 462/469 testcases\\n\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        l, r = 0, len(s)-1\\n        count=0\\n        while l<r:\\n            if s[l] == s[r]:\\n                l , r = l+1, r-1\\n            elif s[l+1] == s[r]:\\n                count+=1\\n                l = l + 1\\n            elif s[l] == s[r-1]:\\n                count+=1\\n                r = r - 1\\n            else:\\n                return False\\n            \\n            if count>1:\\n                return False\\n        return True"
                    },
                    {
                        "username": "vedranson",
                        "content": "At the first mismatch of s[l] and s[r] you have:\\n[ag ... mgml] cupuu ... uupucu [lmgm ... ga]\\nthen the code checks s[l+1] == s[r] and removes/ignores char \\'c\\' at s[l], but the char \\'u\\' to be removed/ignored is at s[r]."
                    },
                    {
                        "username": "Alcas1",
                        "content": "`cuppucu` Is a testcase that broke things for me. This is the difference between checking one side in the if statement vs checking both sides from then on. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is great palindrome problem for interviews because it prevents the compare with reverse() trick."
                    },
                    {
                        "username": "Tapeky",
                        "content": "Not as hard as people say. You can do it !"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "definitely one of the more difficult easy ones."
                    }
                ]
            },
            {
                "id": 2040099,
                "content": [
                    {
                        "username": "hongyanj",
                        "content": "I think this test case is missed:\\nacucucubucucucua"
                    },
                    {
                        "username": "karthikeyan4142",
                        "content": "Why abc is not a palindrome? If we remove one character, say it is \\'b\\' then, it become ac. ac==ca. so it forms a palindrome."
                    },
                    {
                        "username": "binarycoder006",
                        "content": "If we read it from starting it is a and c but if read it from end it is c then a\\ni.e it is not a palindrome."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "what if we remove \\'a\\' and \\'c\\'?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ac != ca"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "no :)"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "2 min | Hindi Video | 100 % You will understand\\nyoutube. com/watch?v=GQmPNs6tcZM"
                    },
                    {
                        "username": "amangaur6515",
                        "content": "linear time and constant space:\\n![image](https://assets.leetcode.com/users/images/7cbe0197-9d59-4369-bcf1-b8adf54d54dc_1649063322.0481198.png)\\n\\n\\n"
                    },
                    {
                        "username": "noormd",
                        "content": "Please don\\'t post solution in Discussion tab. Also you don\\'t need to pass the \\'str\\' in solve function. since it is a internal helper function, the input string is already accessible from outer scope."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "U can make it faster by removing variables x and y and substituting the expressions which were assigned to them (short circuit)"
                    },
                    {
                        "username": "ssumitbansal",
                        "content": "\"tebbem\" should return true. \\nProblem statement states that we can remove atmost 1 char \\nso if we remove \\'t\\' we can make -> ebmbe or bemeb\\nor if we remove \\'m\\' we can make ->ebtbe or beteb\\nAnyone else facing this or am i getting it wrong ?"
                    },
                    {
                        "username": "leet_0433",
                        "content": "order can\\'t be changed\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "No, you \"make\" it a palindrome by removing at most one char, nothing else. You can\\'t reorder the string."
                    },
                    {
                        "username": "Prahasit",
                        "content": "Why is this code wrong, I\\'m getting error in this output \"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga\" which passed 462/469 testcases\\n\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        l, r = 0, len(s)-1\\n        count=0\\n        while l<r:\\n            if s[l] == s[r]:\\n                l , r = l+1, r-1\\n            elif s[l+1] == s[r]:\\n                count+=1\\n                l = l + 1\\n            elif s[l] == s[r-1]:\\n                count+=1\\n                r = r - 1\\n            else:\\n                return False\\n            \\n            if count>1:\\n                return False\\n        return True"
                    },
                    {
                        "username": "vedranson",
                        "content": "At the first mismatch of s[l] and s[r] you have:\\n[ag ... mgml] cupuu ... uupucu [lmgm ... ga]\\nthen the code checks s[l+1] == s[r] and removes/ignores char \\'c\\' at s[l], but the char \\'u\\' to be removed/ignored is at s[r]."
                    },
                    {
                        "username": "Alcas1",
                        "content": "`cuppucu` Is a testcase that broke things for me. This is the difference between checking one side in the if statement vs checking both sides from then on. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is great palindrome problem for interviews because it prevents the compare with reverse() trick."
                    },
                    {
                        "username": "Tapeky",
                        "content": "Not as hard as people say. You can do it !"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "definitely one of the more difficult easy ones."
                    }
                ]
            },
            {
                "id": 2029815,
                "content": [
                    {
                        "username": "hongyanj",
                        "content": "I think this test case is missed:\\nacucucubucucucua"
                    },
                    {
                        "username": "karthikeyan4142",
                        "content": "Why abc is not a palindrome? If we remove one character, say it is \\'b\\' then, it become ac. ac==ca. so it forms a palindrome."
                    },
                    {
                        "username": "binarycoder006",
                        "content": "If we read it from starting it is a and c but if read it from end it is c then a\\ni.e it is not a palindrome."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "what if we remove \\'a\\' and \\'c\\'?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ac != ca"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "no :)"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "2 min | Hindi Video | 100 % You will understand\\nyoutube. com/watch?v=GQmPNs6tcZM"
                    },
                    {
                        "username": "amangaur6515",
                        "content": "linear time and constant space:\\n![image](https://assets.leetcode.com/users/images/7cbe0197-9d59-4369-bcf1-b8adf54d54dc_1649063322.0481198.png)\\n\\n\\n"
                    },
                    {
                        "username": "noormd",
                        "content": "Please don\\'t post solution in Discussion tab. Also you don\\'t need to pass the \\'str\\' in solve function. since it is a internal helper function, the input string is already accessible from outer scope."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "U can make it faster by removing variables x and y and substituting the expressions which were assigned to them (short circuit)"
                    },
                    {
                        "username": "ssumitbansal",
                        "content": "\"tebbem\" should return true. \\nProblem statement states that we can remove atmost 1 char \\nso if we remove \\'t\\' we can make -> ebmbe or bemeb\\nor if we remove \\'m\\' we can make ->ebtbe or beteb\\nAnyone else facing this or am i getting it wrong ?"
                    },
                    {
                        "username": "leet_0433",
                        "content": "order can\\'t be changed\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "No, you \"make\" it a palindrome by removing at most one char, nothing else. You can\\'t reorder the string."
                    },
                    {
                        "username": "Prahasit",
                        "content": "Why is this code wrong, I\\'m getting error in this output \"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga\" which passed 462/469 testcases\\n\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        l, r = 0, len(s)-1\\n        count=0\\n        while l<r:\\n            if s[l] == s[r]:\\n                l , r = l+1, r-1\\n            elif s[l+1] == s[r]:\\n                count+=1\\n                l = l + 1\\n            elif s[l] == s[r-1]:\\n                count+=1\\n                r = r - 1\\n            else:\\n                return False\\n            \\n            if count>1:\\n                return False\\n        return True"
                    },
                    {
                        "username": "vedranson",
                        "content": "At the first mismatch of s[l] and s[r] you have:\\n[ag ... mgml] cupuu ... uupucu [lmgm ... ga]\\nthen the code checks s[l+1] == s[r] and removes/ignores char \\'c\\' at s[l], but the char \\'u\\' to be removed/ignored is at s[r]."
                    },
                    {
                        "username": "Alcas1",
                        "content": "`cuppucu` Is a testcase that broke things for me. This is the difference between checking one side in the if statement vs checking both sides from then on. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is great palindrome problem for interviews because it prevents the compare with reverse() trick."
                    },
                    {
                        "username": "Tapeky",
                        "content": "Not as hard as people say. You can do it !"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "definitely one of the more difficult easy ones."
                    }
                ]
            },
            {
                "id": 2018673,
                "content": [
                    {
                        "username": "hongyanj",
                        "content": "I think this test case is missed:\\nacucucubucucucua"
                    },
                    {
                        "username": "karthikeyan4142",
                        "content": "Why abc is not a palindrome? If we remove one character, say it is \\'b\\' then, it become ac. ac==ca. so it forms a palindrome."
                    },
                    {
                        "username": "binarycoder006",
                        "content": "If we read it from starting it is a and c but if read it from end it is c then a\\ni.e it is not a palindrome."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "what if we remove \\'a\\' and \\'c\\'?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ac != ca"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "no :)"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "2 min | Hindi Video | 100 % You will understand\\nyoutube. com/watch?v=GQmPNs6tcZM"
                    },
                    {
                        "username": "amangaur6515",
                        "content": "linear time and constant space:\\n![image](https://assets.leetcode.com/users/images/7cbe0197-9d59-4369-bcf1-b8adf54d54dc_1649063322.0481198.png)\\n\\n\\n"
                    },
                    {
                        "username": "noormd",
                        "content": "Please don\\'t post solution in Discussion tab. Also you don\\'t need to pass the \\'str\\' in solve function. since it is a internal helper function, the input string is already accessible from outer scope."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "U can make it faster by removing variables x and y and substituting the expressions which were assigned to them (short circuit)"
                    },
                    {
                        "username": "ssumitbansal",
                        "content": "\"tebbem\" should return true. \\nProblem statement states that we can remove atmost 1 char \\nso if we remove \\'t\\' we can make -> ebmbe or bemeb\\nor if we remove \\'m\\' we can make ->ebtbe or beteb\\nAnyone else facing this or am i getting it wrong ?"
                    },
                    {
                        "username": "leet_0433",
                        "content": "order can\\'t be changed\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "No, you \"make\" it a palindrome by removing at most one char, nothing else. You can\\'t reorder the string."
                    },
                    {
                        "username": "Prahasit",
                        "content": "Why is this code wrong, I\\'m getting error in this output \"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga\" which passed 462/469 testcases\\n\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        l, r = 0, len(s)-1\\n        count=0\\n        while l<r:\\n            if s[l] == s[r]:\\n                l , r = l+1, r-1\\n            elif s[l+1] == s[r]:\\n                count+=1\\n                l = l + 1\\n            elif s[l] == s[r-1]:\\n                count+=1\\n                r = r - 1\\n            else:\\n                return False\\n            \\n            if count>1:\\n                return False\\n        return True"
                    },
                    {
                        "username": "vedranson",
                        "content": "At the first mismatch of s[l] and s[r] you have:\\n[ag ... mgml] cupuu ... uupucu [lmgm ... ga]\\nthen the code checks s[l+1] == s[r] and removes/ignores char \\'c\\' at s[l], but the char \\'u\\' to be removed/ignored is at s[r]."
                    },
                    {
                        "username": "Alcas1",
                        "content": "`cuppucu` Is a testcase that broke things for me. This is the difference between checking one side in the if statement vs checking both sides from then on. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is great palindrome problem for interviews because it prevents the compare with reverse() trick."
                    },
                    {
                        "username": "Tapeky",
                        "content": "Not as hard as people say. You can do it !"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "definitely one of the more difficult easy ones."
                    }
                ]
            },
            {
                "id": 2008951,
                "content": [
                    {
                        "username": "hongyanj",
                        "content": "I think this test case is missed:\\nacucucubucucucua"
                    },
                    {
                        "username": "karthikeyan4142",
                        "content": "Why abc is not a palindrome? If we remove one character, say it is \\'b\\' then, it become ac. ac==ca. so it forms a palindrome."
                    },
                    {
                        "username": "binarycoder006",
                        "content": "If we read it from starting it is a and c but if read it from end it is c then a\\ni.e it is not a palindrome."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "what if we remove \\'a\\' and \\'c\\'?"
                    },
                    {
                        "username": "DaudHTM",
                        "content": "ac != ca"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "no :)"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "2 min | Hindi Video | 100 % You will understand\\nyoutube. com/watch?v=GQmPNs6tcZM"
                    },
                    {
                        "username": "amangaur6515",
                        "content": "linear time and constant space:\\n![image](https://assets.leetcode.com/users/images/7cbe0197-9d59-4369-bcf1-b8adf54d54dc_1649063322.0481198.png)\\n\\n\\n"
                    },
                    {
                        "username": "noormd",
                        "content": "Please don\\'t post solution in Discussion tab. Also you don\\'t need to pass the \\'str\\' in solve function. since it is a internal helper function, the input string is already accessible from outer scope."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "U can make it faster by removing variables x and y and substituting the expressions which were assigned to them (short circuit)"
                    },
                    {
                        "username": "ssumitbansal",
                        "content": "\"tebbem\" should return true. \\nProblem statement states that we can remove atmost 1 char \\nso if we remove \\'t\\' we can make -> ebmbe or bemeb\\nor if we remove \\'m\\' we can make ->ebtbe or beteb\\nAnyone else facing this or am i getting it wrong ?"
                    },
                    {
                        "username": "leet_0433",
                        "content": "order can\\'t be changed\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "No, you \"make\" it a palindrome by removing at most one char, nothing else. You can\\'t reorder the string."
                    },
                    {
                        "username": "Prahasit",
                        "content": "Why is this code wrong, I\\'m getting error in this output \"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga\" which passed 462/469 testcases\\n\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        l, r = 0, len(s)-1\\n        count=0\\n        while l<r:\\n            if s[l] == s[r]:\\n                l , r = l+1, r-1\\n            elif s[l+1] == s[r]:\\n                count+=1\\n                l = l + 1\\n            elif s[l] == s[r-1]:\\n                count+=1\\n                r = r - 1\\n            else:\\n                return False\\n            \\n            if count>1:\\n                return False\\n        return True"
                    },
                    {
                        "username": "vedranson",
                        "content": "At the first mismatch of s[l] and s[r] you have:\\n[ag ... mgml] cupuu ... uupucu [lmgm ... ga]\\nthen the code checks s[l+1] == s[r] and removes/ignores char \\'c\\' at s[l], but the char \\'u\\' to be removed/ignored is at s[r]."
                    },
                    {
                        "username": "Alcas1",
                        "content": "`cuppucu` Is a testcase that broke things for me. This is the difference between checking one side in the if statement vs checking both sides from then on. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is great palindrome problem for interviews because it prevents the compare with reverse() trick."
                    },
                    {
                        "username": "Tapeky",
                        "content": "Not as hard as people say. You can do it !"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "definitely one of the more difficult easy ones."
                    }
                ]
            },
            {
                "id": 1985281,
                "content": [
                    {
                        "username": "aiswaryaa",
                        "content": "give tip"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "start checking form start and end index,,,whenever it hits that (start!=end) ,then pass it to another function which will check the reamin string is palindrome or not ,if its true return true ,otherwise false...  \n\n    NOTE: in the second function call u must have check two condition ,\n1st increase the starting index by one and check but the end index remains same (in this casse it  will ignore the 1st character from starting index) \n\nand 2nd one is: increase the end index by one, here start will be same (thus it willl check after ignoring the last index) and u have to check both the conditions ,to cover all the edge cases...\n"
                    },
                    {
                        "username": "varsha1531",
                        "content": "bool validPalindrome(string s) {\n      \n      int c=0;\n      int j=s.length()-1,i=0;\n      while(i<=j)\n      {\n          if(s[i]==s[j])\n          {\n              j--;\n              i++;\n          }\n          else \n          {\n              if(s[i]==s[j-1] )\n              {\n                  j=j-2;\n                  c++;\n                  i++;\n              }\n              else if(s[i+1]==s[j])\n              {\n                  i=i+2;\n                  c++;\n                  j--;\n              }\n              else{\n                  return false;\n              }\n          }\n          \n      }\n      \nreturn c<=1;\n     \n    } \nplz help me where am i going wrong\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": " `Consider this - ebcbbececabbacecbbcbe`\n \nI can't figure out why the LeetCode compiler refuses to accept my solution for \"ebcbbececabbacecbbcbe\" specific given input  [the input String isn't a palindrome at all ] . Can anyone lend a hand? Any insights or suggestions to resolve this compiler error would be greatly appreciated. Help me crack this puzzle.........\n"
                    },
                    {
                        "username": "vedranson",
                        "content": "First and last 5 chars: \\'ebcbb [...] bbcbe\\' make a valid palindrome. The rest is now \\'ececabbacec\\'. If you were to delete/ignore the leading \\'e\\', the rest \\'cecabbacec\\' is a valid palindrome."
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me figure out why my code is showing incorrect output for this string \"lfhnzyffurnskdlduhopgrssphgnbaxtuzmlwsxzamjtdqymgmmmmgmyxqdtjmazxwlmzutxabnghpssrgpohudldksnruffyznhfl\"\\nMy code is showing true but expected output is false. Can someone help me figure out what is wrong in my code \\n```class Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        int flag = 0;\\n        char uh;\\n        while(i<j)\\n        {\\n          while(!isalnum(s[i]))\\n          {\\n              i++;\\n          }\\n          while(!isalnum(s[j]))\\n          {\\n              j--;\\n          }\\n\\n          if(!(s[i]==s[j]) && flag==0)\\n          {\\n            flag =1;\\n            if (s[i + 1] == s[j])\\n            {\\n                i++;\\n                uh = s[i];\\n            }\\n\\n            else if (s[i] == s[j - 1])\\n            {\\n                uh = s[j];\\n                j--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n          }\\n          \\n          else if(!(s[i]==s[j]) && flag==1)\\n          {\\n              if((s[i]==uh || s[j]==uh))\\n              {\\n                if (s[i] == uh)\\n                    i++;\\n                else if (s[j] == uh)\\n                    j--;\\n              }\\n              else\\n              {\\n                  return false;\\n              }\\n          }\\n          else\\n          {\\n             i++;\\n             j--;\\n          }\\n        }\\n        return true;\\n    }\\n};```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Got it, I was removing all occurrences of the character"
                    },
                    {
                        "username": "10xvishal",
                        "content": "\"woicvixviciow\" why is this supposed to be false, after neglecting i its a valid palindrome \"wocvxvcow\""
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "you have to remove just 1 char in your input to make it a valid palindrome"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "seems that a testcase \"tebbem\" expects `false`. is \"ebbe\" not a valid palindrome? [@LeetCode](/LeetCode) ?"
                    },
                    {
                        "username": "10xvishal",
                        "content": "you will only get \"tebbe\" or \"ebbem\" after removing single char."
                    },
                    {
                        "username": "ankush920",
                        "content": "FULL EXPLAINED ||CODE || C++ ||0(N)\\nankush920\\n0\\nin a minute\\nIntuition\\nokk sit relax don\\'t frustate it\\'s easy but slightly different .\\n\\nremember must one mean --> can delete 0 or 1 character only\\nusing two pointer approach :-\\n-> i--> intial pointer , j--> final pointer\\n-> travese it from end , start both side (i++ , j-- );\\n-> if s[i] == s[j] --> satisfy palindrom condition okk go forward\\n->but if s[i] != s[j] so we can do two thing\\neither remove from left side ( i side deletion ) or righr side (j side deletion)\\n\\n(find useful upvote it vro :) )\\n-> i am choosing left first and right next and use counter( countI and countJ) to know whether i have chance to remove from left /right side or not\\n\\n**note i am not deleting from both side in my deletion condition box there is condition like that only one char is delete\\n\\n--> i use storeI and storeJ to for the remember point that where first inequality come and i was used my deletion power ( delete one character)\\nbecause in testcase like :-\\nif first inequality is come in string i go with \\'i\\' side deletion and it satisfy upto some length but not make my string completly palindromic because \\'j\\' side deletion make complete palindromic to my string so , at that i cann\\'t do \\'j\\' side deletion on present index\\n(it delete two character) i use that index where my first inequality ( or on which i use my i side is required to do it ** we only delete one character max**)\\n\\nso if both possibility fail mean (we check from i ,j side deletion )\\nreturn false otherwise true\\n\\nApproach\\nlinear traversal\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        \\n        int n = s.size();\\n        if( n  ==1)\\n        {\\n             return n;\\n        }\\n\\nint i = 0 , j = n-1;\\n\\nint countI = 0;\\nint countJ= 0;\\nint storeI =0;\\nint storeJ =0;\\n    while( i<=j)\\n    {\\n      \\n      if( s[i]!=s[j])\\n      {\\n          if( !countI)\\n          {\\n              countI=1;\\n              storeI =i;\\n              storeJ =j;\\n              i++;\\n              continue;\\n          }\\n\\n          if(!countJ)\\n          {\\n             i= storeI;\\n             j= storeJ; \\n             countJ =1;\\n             j--;\\n             continue;\\n          }\\n          return 0;\\n      }\\n\\n      i++;\\n      j--;\\n    }\\n\\nreturn true ;\\n    }\\n};"
                    },
                    {
                        "username": "Ardonite",
                        "content": "Hi,\\n\\nhow can expected be \"false\"?\\nIt must be true right?\\n\\nInput\\ns = \"tebbem\"\\n\\nOutput\\ntrue\\n\\nExpected\\nfalse"
                    },
                    {
                        "username": "underprocess",
                        "content": "you must remove t and m to make it palindrome but according to question s can be palindrome after deleting at most one character from it.so false."
                    },
                    {
                        "username": "darkpheonix2_O",
                        "content": "If you are unable to come up with any solution, think it like you skip one character from left and check for valid palindrome, if no solution is found save that index and now skip the right index to check for valid palindrome, it no valid palindrome is found then answer is false else true. Use two pointers left and right to check for valid palindrome."
                    },
                    {
                        "username": "aknownymous",
                        "content": "#### Can Someone tell me, how can I reduce its time complexity? Passes all the case except 402th. \n```\nclass Solution:\n    def pal(self,s):\n        if s==s[::-1]: return True\n        return False\n    def validPalindrome(self, s: str) -> bool:\n        if self.pal(s): return True\n        for i in range(len(s)):\n            c= list(s)\n            c.pop(i)\n            if self.pal(c): return True\n        return False\n```\n\n\n#### Test Case :\n```\n\"okelpsggfffjcbrxksywxjlwkreqaleuozasrpqssrwqnafcpurutghwgovmewwjqyeudyerbvccdbvoomncetrzgowzdmvfzuelummidrncazxgxmlgkutjyfgthpgiirrijsnxgcpvbkshzenutpgiglipedcwcrnspqsqfcfeodkjuhubpzrwfgvflmuexyalmwlitwciaaiqgruwdroxxoditxtpmfdfnkagaukeuyxbkjwkujredeuaidbnhuwrmxmpyeoomrokvmoythkirbjdhaohoxksgsvyvdtylazbryoqtwyytefpsysigwnykbwsjizweemjuuxdjtfautwvuywfhkzlhsbrgsyynvredkrjcducdwppalrdghzjuowbkbgmhwrmfbtqxevdaluwrrtrjltghiytbjugvdrmxlpvpttozlcinzqtrtnscfgkhmmglhzqkpjixxqflmycywxvhhoeeqgdwsvetbphhulczylfiurehhgjhbqqlaytwysupjuallphvvpohovrauewvphmvlcsalvxpvwuzyvjbziwnfyjdtglzzkceiiwbuqjiztidxixkwwyfvpnuucbtestwgchljweklejoxduaxoquvchivjbluxmpcbotwgktupjsfbazaclawkkwmtkigmuraapxufbwwbmqazrinavgiuyalbhifcqpgazrptwfmuvzqekycdujviondufakcnboxrlfnadcbpkwnomwmuwhwmvkrwglaxdvjbymcmpgcqcnelrmzhghndvdfrdfdkozgrzffhuaxghsjoizybbqhoijzgzdmnghaculluotbhtajdagptqmeccnzxvpedjnaydckhejghbuofmkoteoqkxkgtywtftxxptboxhowgknptmfsnvvunwblumqduomxvrmzqbnpnbnmnzuenjujcndsxtvwrcsnhvmmgjnkbdtemhhftpseosvhdxoorncynxkibnaxmufdnounrzbxqzrhgwtzbbzipbqwatzrtnhdbabnoglnrumbbnejduktmsxzuaoxmogrjqlgrbxnwyiqfwvlclqpsljktnjxqtmktdxdhkgbnsagyafukrrlxlkjsiljouzwfwtlodvfzfvdupqydvkufbbeqawqnnorghffoahelzvawxqpykxklzlhccvyepcdygxrpldnwzeqzuyjdkogmgdmfsezwqcrslpbxmnwvjxphcbmshayiodnnxwvahvsyleotqqlhirkjlatjnwmtmmsbkalmvdnupeejrykffsffyytugissgtmnyekjqitjfjncgrezpahvjknlbclkopsjtykfzpqlffvyeblcedfxjpsmdtuerffmaiiphomwkctufxsiauhctxsivqpltobdwybprkhchieimoitrjolnybwgqnmjrpkxazmwcasetwsxgqjlbhefssubuvpharcfxhsyscsriqvkotcackholuhfzradelmacojqbtncjhfwpfqwvbdxjvxomcgjiitstgxlskmzcsvhihwcvoxebboazklzvjbwabahyhmvrbewuxjbznehqrwccovzutpumalkpvaocwryvjyeezttwgithxltruftqkyxyfkgyfguavmmemueluvyfehbocgsekgznivscohwyhjwooegympcpesuujadzpvxbebensajfnnvywngawinqyxbeiuqheklyolibfktbmddllbgtqmgvctgefzjwzfnesltuqzytsfuenjblldtjilahswbwmphmakmeawekkpfoiiaozxspqiknxtxomxiqwuvfoenxemcldulgdttfrdyvoxjrnmbkxguworfgqzsxpijtefgguinlbixctiqcdqjvcnxwljpkfvftcqjdvkkoqvnrdbkhovmpcappqsmwuzrorqyvmusiemqbxjscejthwlycucoccnoewjekchjqxeeaxbyvneivxcdydqamzcvleohgxdzzcyngimxqzdhvllpycnvrvbowtowukelfvjovohtafapdezecrabznzmhmipjcbweqtrikczwqbuciyztrapbekfocryxrwmffphoivpwfiyosxpkyqywkvikzrvfudeoyvyissaubkowuvzpmsopvomseieivziqynovnaeapjfjfhjuzqtebrpqmwegzsvouuwptpqxcylqnabbrgiuvjhjtpqlrcixmcsyekcdxeixycwbocbezpetkqzrwyimikpjziimieyqoessjvqpypdnjpngvbfkifvuqsvcqfkwakdlvxfhneyfanbhqryrcbojqdnbbsadhcfxjmrjqwjjzxtusjqgkywatbrsszogjyreikgjqnucomibvajysnhvtodyxukkrcftiewcvjscmnyyrqkteohffqfehdrtjcaldwcukgnoclqwewabisdwevmynuzwlwikgsjwnmkmalkktmuiohcxyxzuxfogymsnjoefwxzwvaxvjqypzoocnydwggqyswygyajmwjczcrjdijsaoepwoqbekbzmpsdomsbkukirdlpzenohkpfexmahidgdlnvctvsvvcjpakiotoarnvfrpopdecxisdnqcdersoyuxypiicnhxvhvlqgfxlwnecdtfmsvuturggxxstxacnamdboyfoviavuimjnmzumsfmtpilvmzgfukxxwlhcmlyjfcxioderggkknwmilhnwebubywjtzvrfraijkdbafkgqfwooxbfwqknjtejesvqvauclxhoaivqtszuztdagbvxtzocksbbydqezqoghchyfgipfgckihnwvoqqejejfuiiarpkjfqrytxqwvwztwfuldyaxsczdvgoocbbndwndorkgjaqpdxchaspgwoylpclhiuxvjbfzalcyyxucygjwwynvvtklwcenuswoedrcnuwpegdlxtxavapdcwzukycdiqtvxytuuwwgtoljvcgdqqimrtrsdjvopgbyrfqoqeqdvvzqragwdkhbedxczdzgexgxgmbwgznogqnegoesellwuvezjmkujiixvkmsybocnuyomzyvajrgtldkminlbwbfxhbpalhreyuxnvyhumwcpwnscwaudmpzvuujnwiktxbzvczefnpjflaubhokplqmzzjtttdvrbxswmflsaueafokqthikxaogvwcgqhzlkimmwqherzlmnpkxxpfhgblfwpoiwvufkdbtvyixnsorwobajfcivuvcuudfqoroczjqocyevhqwgcjrhpmqlqbaqvdtvyovwnplzjhoylcsqpqqahxybrpzmidrdjrpcxewvsfqnxglpixmiertpjhezdtcgylhbxdcbjiavcsfyataialdjskqhrsqemygllpftrkaezmihzacbhmtbplaiufvodvkxhmyseacqoauufnwkhkmwvbpwheauxneglqdxnzepamermqayfxhpzklgdcsvhljdrphwcrfibblivigzognxoujeijlclqwrertsnrxlsdfuayckuqmcwznegmvwqqvivtwwcyufrlmnjonpfdmgvsflgidthqlxduryswstznfqhsynxzdzytooivftkjhnoebyydlosysfaepooamthyvfuxsikjymiiehavfijncwbqsyooshjhdxqugztfeenzwwtntftkvzqryeqhfnjyaunkzabpqkhkbichdpazhlvurjqbibqkdaouhmpnyfjfguwbvwtbtuhzzvtautrcixwklodvccwyxxwcdsxqgmbpxcsaomciqcgyubrjentajuwfygrucnjhubvtkwqpibxrmgwzcgilurzhbxvybkxyjbmvlfmairsesaydzwufjwbcbqvmuzkqgabteybwzcdtnqpzpngbaypdnzeiiljgcskixqofwkrptvlycvibbijjbdjjsbxihsluofdgzmkordkxsteviyyawtybxuzydoogjrezifywhogedcjmikqbujubpziqywijmbxnfmctlfkfxnrvctqgagsvxhgavgmsmbivnsaoacnjtcgmfpknvebxfxmkaapoczhjhkvyrjsbuwsojhlzagcedhkupyetzhexubqdpwbehgcnoauinbbfmvojmnklrlcbleuortsbjzzqdqwbsdvapqqfqxpetywemvhfffkojcfwfxjfzcgpxopbxcphqpmrrrkaplrmniigdryhifmufddkizgbhbgcxvcntujlwedemcluetinkzltzwjdrvzhelcmdktqpcitislwlkurqrhftqpccimqbcixvacdxdeepfrmuhvezpdgggevullgmvdpgouuxkzdhjewdijboumhmsboxhgzadjtwmeimdnavljnzdocsvcdkroqeulfaubhlcaamalpsukazggtwgpwdeqnpuedwwtjcrjdnokovvvtbjobvmeaqomfidmarizadomwrfedkusktxgbotdikfebmkrosgfpshynksglrtjiawdtidcvblzbewiqftxzyxdknnutfhqvanlscqqdxpjyqczbmzdfxcrctapwxqrokuexlbzmrdisdbzryowqwhzjxntrajzhfrsspiurmwuiarozvojsigivusihnzejxtoaljajmwazmeyoxodtgfnhsawbmbjcptsqwzrrlirrncipztqvkosqcyfyqfvbdnhwlmotffcbxczakkxqaynkemgwvdniaxrkvsskryiphzqpcgbsmixjfbdtxeemtbwydwgywxxofsayqohghjahnbsfwaqpzpbzofokykfcvlelnqhjnkdkvsigffqfebnkfjqumrkxcjlxubcpbpkhzddyhalpqrvjeduxpugfijyfgbzdhqfcwpoixmotpzybhfzgflhtqsublszjpeyagozzlxopflouxprnazfkyyklromjiwqqwijmorlkyykfzanrpxuolfpoxlzzogayepjzslbusqthlfgzfhbyzptomxiopwcfqhdzbgfyjifgupxudejvrqplahyddzhkpbpcbuxljcxkrmuqjfknbefqffgisvkdknjhqnlelvcfkykofozbpzpqawfsbnhajhghoqyasfoxxwygwdywbtmeextdbfjximsbgcpqzhpiyrkssvkrxaindvwgmeknyaqxkkazcxbcfftomlwhndbvfqyfycqsokvqtzpicnrrilrrzwqstpcjbmbwashnfgtdoxoyemzawmjajlaotxjeznhisuvigisjovzoraiuwmruipssrfhzjartnxjzhwqwoyrzbdsidrmzblxeukorqxwpatcrcxfdzmbzcqyjpxdqqcslnavqhftunnkdxyzxtfqiwebzlbvcditdwaijtrlgsknyhspfgsorkmbefkidtobgxtksukdefrwmodaziramdifmoqaemvbojbtvvvokondjrcjtwwdeupnqedwpgwtggzakusplamaaclhbuaflueqorkdcvscodznjlvandmiemwtjdazghxobsmhmuobjidwejhdzkxuuogpdvmglluvegggdpzevhumrfpeedxdcavxicbqmiccpqtfhrqruklwlsiticpqtkdmclehzvrdjwztlzkniteulcmedewljutncvxcgbhbgzikddfumfihyrdgiinmrlpakrrrmpqhpcxbpoxpgczfjxfwfcjokfffhvmewytepxqfqqpavdsbwqdqzzjbstrouelbclrlknmjovmfbbniuaoncghebwpdqbuxehzteypukhdecgazlhjoswubsjryvkhjhzcopaakmxfxbevnkpfmgctjncaoasnvibmsmgvaghxvsgagqtcvrnxfkfltcmfnxbmjiwyqizpbujubqkimjcdegohwyfizerjgoodyzuxbytwayyivetsxkdrokmzgdfoulshixbsjjdbjjibbivcylvtprkwfoqxikscgjliiezndpyabgnpzpqntdczwbyetbagqkzumvqbcbwjfuwzdyasesriamflvmbjyxkbyvxbhzruligczwgmrxbipqwktvbuhjncurgyfwujatnejrbuygcqicmoascxpbmgqxsdcwxxywccvdolkwxicrtuatvzzhutbtwvbwugfjfynpmhuoadkqbibqjruvlhzapdhcibkhkqpbazknuayjnfhqeyrqzvktftntwwzneeftzguqxdhjhsooysqbwcnjifvaheiimyjkisxufvyhtmaoopeafsysoldyybeonhjktfviootyzdzxnyshqfnztswsyrudxlqhtdiglfsvgmdfpnojnmlrfuycwwtvivqqwvmgenzwcmqukcyaufdslxrnstrerwqlcljiejuoxngozgivilbbifrcwhprdjlhvscdglkzphxfyaqmremapeznxdqlgenxuaehwpbvwmkhkwnfuuaoqcaesymhxkvdovfuialpbtmhbcazhimzeakrtfpllgymeqsrhqksjdlaiatayfscvaijbcdxbhlygctdzehjptreimxiplgxnqfsvwexcprjdrdimzprbyxhaqqpqsclyohjzlpnwvoyvtdvqabqlqmphrjcgwqhveycoqjzcoroqfduucvuvicfjabowrosnxiyvtbdkfuvwiopwflbghfpxxkpnmlzrehqwmmiklzhqgcwvgoaxkihtqkofaeuaslfmwsxbrvdtttjzzmqlpkohbualfjpnfezcvzbxtkiwnjuuvzpmduawcsnwpcwmuhyvnxuyerhlapbhxfbwblnimkdltgrjavyzmoyuncobysmkvxiijukmjzevuwlleseogenqgonzgwbmgxgxegzdzcxdebhkdwgarqzvvdqeqoqfrybgpovjdsrtrmiqqdgcvjlotgwwuutyxvtqidcykuzwcdpavaxtxldgepwuncrdeowsunecwlktvvnywwjgycuxyyclazfbjvxuihlcplyowgpsahcxdpqajgkrodnwdnbbcoogvdzcsxaydlufwtzwvwqxtyrqfjkpraiiufjejeqqovwnhikcgfpigfyhchgoqzeqdybbskcoztxvbgadtzuzstqviaohxlcuavqvsejetjnkqwfbxoowfqgkfabdkjiarfrvztjwybubewnhlimwnkkggredoixcfjylmchlwxxkufgzmvliptmfsmuzmnjmiuvaivofyobdmancaxtsxxggrutuvsmftdcenwlxfgqlvhvxhnciipyxuyosredcqndsixcedpoprfvnraotoikapjcvvsvtcvnldgdihamxefpkhonezpldrikukbsmodspmzbkebqowpeoasjidjrczcjwmjaygywsyqggwdyncoozpyqjvxavwzxwfeojnsmygofxuzxyxchoiumtkklamkmnwjsgkiwlwzunymvewdsibawewqlcongkucwdlacjtrdhefqffhoetkqryynmcsjvcweitfcrkkuxydotvhnsyjavbimocunqjgkieryjgozssrbtawykgqjsutxzjjwqjrmjxfchdasbbndqjobcryrqhbnafyenhfxvldkawkfqcvsquvfikfbvgnpjndpypqvjsseoqyeimiizjpkimiywrzqktepzebcobwcyxiexdckeyscmxicrlqptjhjvuigrbbanqlycxqptpwuuovszgewmqprbetqzujhfjfjpaeanvonyqizvieiesmovposmpzvuwokbuassiyvyoedufvrzkivkwyqykpxsoyifwpviohpffmwrxyrcofkebpartzyicubqwzckirtqewbcjpimhmznzbarcezedpafathovojvflekuwotwobvrvncypllvhdzqxmignyczzdxghoelvczmaqdydcxvienvybxaeexqjhckejweonccocucylwhtjecsjxbqmeisumvyqrorzuwmsqppacpmvohkbdrnvqokkvdjqctfvfkpjlwxncvjqdcqitcxiblniuggfetjipxszqgfrowugxkbmnrjxovydrfttdgludlcmexneofvuwqixmoxtxnkiqpsxzoaiiofpkkewaemkamhpmwbwshalijtdllbjneufstyzqutlsenfzwjzfegtcvgmqtgbllddmbtkfbiloylkehquiebxyqniwagnwyvnnfjasnebebxvpzdajuusepcpmygeoowjhywhocsvinzgkesgcobhefyvuleumemmvaugfygkfyxykqtfurtlxhtigwttzeeyjvyrwcoavpklamuptuzvoccwrqhenzbjxuwebrvmhyhabawbjvzlkzaobbexovcwhihvsczmkslxgtstiijgcmoxvjxdbvwqfpwfhjcntbqjocamledarzfhulohkcactokvqirscsyshxfcrahpvubussfehbljqgxswtesacwmzaxkprjmnqgwbynlojrtiomieihchkrpbywdbotlpqvisxtchuaisxfutckwmohpiiamffreutdmspjxfdeclbeyvfflqpzfkytjspoklcblnkjvhapzergcnjfjtiqjkeynmtgssigutyyffsffkyrjeepundvmlakbsmmtmwnjtaljkrihlqqtoelysvhavwxnndoiyahsmbchpxjvwnmxbplsrcqwzesfmdgmgokdjyuzqezwndlprxgydcpeyvcchlzlkxkypqxwavzlehaoffhgronnqwaqebbfukvdyqpudvfzfvdoltwfwzuojlisjklxlrrkufaygasnbgkhdxdtkmtqxjntkjlspqlclvwfqiywnxbrglqjrgomxoauzxsmtkudjenbbmurnlgonbabdhntrztawqbpizbbztwghrzqxbzrnuondfumxanbikxnycnrooxdhvsoesptfhhmetdbknjgmmvhnscrwvtxsdncjujneuznmnbnpnbqzmrvxmoudqmulbwnuvvnsfmtpnkgwohxobtpxxtftwytgkxkqoetokmfoubhgjehkcdyanjdepvxznccemqtpgadjathbtoullucahgnmdzgzjiohqbbyziojshgxauhffzrgzokdfdrfdvdnhghzmrlencqcgpmcmybjvdxalgwrkvmwhwumwmonwkpbcdanflrxobnckafudnoivjudcykeqzvumfwtprzagpqcfihblayuigvanirzaqmbwwbfuxpaarumgiktmwkkwalcazabfsjputkgwtobcpmxulbjvihcvuqoxaudxojelkewjlhcgwtsetbcuunpvfywwkxixditzijqubwiieckzzlgtdjyfnwizbjvyzuwvpxvlasclvmhpvweuarvohopvvhpllaujpusywtyalqqbhjghheruiflyzcluhhpbtevswdgqeeohhvxwycymlfqxxijpkqzhlgmmhkgfcsntrtqzniclzottpvplxmrdvgujbtyihgtljrtrrwuladvexqtbfmrwhmgbkbwoujzhgdrlappwdcudcjrkdervnyysgrbshlzkhfwyuvwtuaftjdxuujmeewzijswbkynwgisyspfetyywtqoyrbzalytdvyvsgskxohoahdjbrikhtyomvkormooeypmxmrwuhnbdiauederjukwjkbxyuekuagaknfdfmptxtidoxxordwurgqiaaicwtilwmlayxeumlfvgfwrzpbuhujkdoefcfqsqpsnrcwcdepilgigptunezhskbvpcgxnsjirriigphtgfyjtukglmxgxzacnrdimmuleuzfvmdzwogzrtecnmoovbdccvbreydueyqjwwemvogwhgturupcfanqwrssqprsazouelaqerkwljxwyskxrbcjfffggsplekod\"\n```"
                    }
                ]
            },
            {
                "id": 1980722,
                "content": [
                    {
                        "username": "aiswaryaa",
                        "content": "give tip"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "start checking form start and end index,,,whenever it hits that (start!=end) ,then pass it to another function which will check the reamin string is palindrome or not ,if its true return true ,otherwise false...  \n\n    NOTE: in the second function call u must have check two condition ,\n1st increase the starting index by one and check but the end index remains same (in this casse it  will ignore the 1st character from starting index) \n\nand 2nd one is: increase the end index by one, here start will be same (thus it willl check after ignoring the last index) and u have to check both the conditions ,to cover all the edge cases...\n"
                    },
                    {
                        "username": "varsha1531",
                        "content": "bool validPalindrome(string s) {\n      \n      int c=0;\n      int j=s.length()-1,i=0;\n      while(i<=j)\n      {\n          if(s[i]==s[j])\n          {\n              j--;\n              i++;\n          }\n          else \n          {\n              if(s[i]==s[j-1] )\n              {\n                  j=j-2;\n                  c++;\n                  i++;\n              }\n              else if(s[i+1]==s[j])\n              {\n                  i=i+2;\n                  c++;\n                  j--;\n              }\n              else{\n                  return false;\n              }\n          }\n          \n      }\n      \nreturn c<=1;\n     \n    } \nplz help me where am i going wrong\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": " `Consider this - ebcbbececabbacecbbcbe`\n \nI can't figure out why the LeetCode compiler refuses to accept my solution for \"ebcbbececabbacecbbcbe\" specific given input  [the input String isn't a palindrome at all ] . Can anyone lend a hand? Any insights or suggestions to resolve this compiler error would be greatly appreciated. Help me crack this puzzle.........\n"
                    },
                    {
                        "username": "vedranson",
                        "content": "First and last 5 chars: \\'ebcbb [...] bbcbe\\' make a valid palindrome. The rest is now \\'ececabbacec\\'. If you were to delete/ignore the leading \\'e\\', the rest \\'cecabbacec\\' is a valid palindrome."
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me figure out why my code is showing incorrect output for this string \"lfhnzyffurnskdlduhopgrssphgnbaxtuzmlwsxzamjtdqymgmmmmgmyxqdtjmazxwlmzutxabnghpssrgpohudldksnruffyznhfl\"\\nMy code is showing true but expected output is false. Can someone help me figure out what is wrong in my code \\n```class Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        int flag = 0;\\n        char uh;\\n        while(i<j)\\n        {\\n          while(!isalnum(s[i]))\\n          {\\n              i++;\\n          }\\n          while(!isalnum(s[j]))\\n          {\\n              j--;\\n          }\\n\\n          if(!(s[i]==s[j]) && flag==0)\\n          {\\n            flag =1;\\n            if (s[i + 1] == s[j])\\n            {\\n                i++;\\n                uh = s[i];\\n            }\\n\\n            else if (s[i] == s[j - 1])\\n            {\\n                uh = s[j];\\n                j--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n          }\\n          \\n          else if(!(s[i]==s[j]) && flag==1)\\n          {\\n              if((s[i]==uh || s[j]==uh))\\n              {\\n                if (s[i] == uh)\\n                    i++;\\n                else if (s[j] == uh)\\n                    j--;\\n              }\\n              else\\n              {\\n                  return false;\\n              }\\n          }\\n          else\\n          {\\n             i++;\\n             j--;\\n          }\\n        }\\n        return true;\\n    }\\n};```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Got it, I was removing all occurrences of the character"
                    },
                    {
                        "username": "10xvishal",
                        "content": "\"woicvixviciow\" why is this supposed to be false, after neglecting i its a valid palindrome \"wocvxvcow\""
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "you have to remove just 1 char in your input to make it a valid palindrome"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "seems that a testcase \"tebbem\" expects `false`. is \"ebbe\" not a valid palindrome? [@LeetCode](/LeetCode) ?"
                    },
                    {
                        "username": "10xvishal",
                        "content": "you will only get \"tebbe\" or \"ebbem\" after removing single char."
                    },
                    {
                        "username": "ankush920",
                        "content": "FULL EXPLAINED ||CODE || C++ ||0(N)\\nankush920\\n0\\nin a minute\\nIntuition\\nokk sit relax don\\'t frustate it\\'s easy but slightly different .\\n\\nremember must one mean --> can delete 0 or 1 character only\\nusing two pointer approach :-\\n-> i--> intial pointer , j--> final pointer\\n-> travese it from end , start both side (i++ , j-- );\\n-> if s[i] == s[j] --> satisfy palindrom condition okk go forward\\n->but if s[i] != s[j] so we can do two thing\\neither remove from left side ( i side deletion ) or righr side (j side deletion)\\n\\n(find useful upvote it vro :) )\\n-> i am choosing left first and right next and use counter( countI and countJ) to know whether i have chance to remove from left /right side or not\\n\\n**note i am not deleting from both side in my deletion condition box there is condition like that only one char is delete\\n\\n--> i use storeI and storeJ to for the remember point that where first inequality come and i was used my deletion power ( delete one character)\\nbecause in testcase like :-\\nif first inequality is come in string i go with \\'i\\' side deletion and it satisfy upto some length but not make my string completly palindromic because \\'j\\' side deletion make complete palindromic to my string so , at that i cann\\'t do \\'j\\' side deletion on present index\\n(it delete two character) i use that index where my first inequality ( or on which i use my i side is required to do it ** we only delete one character max**)\\n\\nso if both possibility fail mean (we check from i ,j side deletion )\\nreturn false otherwise true\\n\\nApproach\\nlinear traversal\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        \\n        int n = s.size();\\n        if( n  ==1)\\n        {\\n             return n;\\n        }\\n\\nint i = 0 , j = n-1;\\n\\nint countI = 0;\\nint countJ= 0;\\nint storeI =0;\\nint storeJ =0;\\n    while( i<=j)\\n    {\\n      \\n      if( s[i]!=s[j])\\n      {\\n          if( !countI)\\n          {\\n              countI=1;\\n              storeI =i;\\n              storeJ =j;\\n              i++;\\n              continue;\\n          }\\n\\n          if(!countJ)\\n          {\\n             i= storeI;\\n             j= storeJ; \\n             countJ =1;\\n             j--;\\n             continue;\\n          }\\n          return 0;\\n      }\\n\\n      i++;\\n      j--;\\n    }\\n\\nreturn true ;\\n    }\\n};"
                    },
                    {
                        "username": "Ardonite",
                        "content": "Hi,\\n\\nhow can expected be \"false\"?\\nIt must be true right?\\n\\nInput\\ns = \"tebbem\"\\n\\nOutput\\ntrue\\n\\nExpected\\nfalse"
                    },
                    {
                        "username": "underprocess",
                        "content": "you must remove t and m to make it palindrome but according to question s can be palindrome after deleting at most one character from it.so false."
                    },
                    {
                        "username": "darkpheonix2_O",
                        "content": "If you are unable to come up with any solution, think it like you skip one character from left and check for valid palindrome, if no solution is found save that index and now skip the right index to check for valid palindrome, it no valid palindrome is found then answer is false else true. Use two pointers left and right to check for valid palindrome."
                    },
                    {
                        "username": "aknownymous",
                        "content": "#### Can Someone tell me, how can I reduce its time complexity? Passes all the case except 402th. \n```\nclass Solution:\n    def pal(self,s):\n        if s==s[::-1]: return True\n        return False\n    def validPalindrome(self, s: str) -> bool:\n        if self.pal(s): return True\n        for i in range(len(s)):\n            c= list(s)\n            c.pop(i)\n            if self.pal(c): return True\n        return False\n```\n\n\n#### Test Case :\n```\n\"okelpsggfffjcbrxksywxjlwkreqaleuozasrpqssrwqnafcpurutghwgovmewwjqyeudyerbvccdbvoomncetrzgowzdmvfzuelummidrncazxgxmlgkutjyfgthpgiirrijsnxgcpvbkshzenutpgiglipedcwcrnspqsqfcfeodkjuhubpzrwfgvflmuexyalmwlitwciaaiqgruwdroxxoditxtpmfdfnkagaukeuyxbkjwkujredeuaidbnhuwrmxmpyeoomrokvmoythkirbjdhaohoxksgsvyvdtylazbryoqtwyytefpsysigwnykbwsjizweemjuuxdjtfautwvuywfhkzlhsbrgsyynvredkrjcducdwppalrdghzjuowbkbgmhwrmfbtqxevdaluwrrtrjltghiytbjugvdrmxlpvpttozlcinzqtrtnscfgkhmmglhzqkpjixxqflmycywxvhhoeeqgdwsvetbphhulczylfiurehhgjhbqqlaytwysupjuallphvvpohovrauewvphmvlcsalvxpvwuzyvjbziwnfyjdtglzzkceiiwbuqjiztidxixkwwyfvpnuucbtestwgchljweklejoxduaxoquvchivjbluxmpcbotwgktupjsfbazaclawkkwmtkigmuraapxufbwwbmqazrinavgiuyalbhifcqpgazrptwfmuvzqekycdujviondufakcnboxrlfnadcbpkwnomwmuwhwmvkrwglaxdvjbymcmpgcqcnelrmzhghndvdfrdfdkozgrzffhuaxghsjoizybbqhoijzgzdmnghaculluotbhtajdagptqmeccnzxvpedjnaydckhejghbuofmkoteoqkxkgtywtftxxptboxhowgknptmfsnvvunwblumqduomxvrmzqbnpnbnmnzuenjujcndsxtvwrcsnhvmmgjnkbdtemhhftpseosvhdxoorncynxkibnaxmufdnounrzbxqzrhgwtzbbzipbqwatzrtnhdbabnoglnrumbbnejduktmsxzuaoxmogrjqlgrbxnwyiqfwvlclqpsljktnjxqtmktdxdhkgbnsagyafukrrlxlkjsiljouzwfwtlodvfzfvdupqydvkufbbeqawqnnorghffoahelzvawxqpykxklzlhccvyepcdygxrpldnwzeqzuyjdkogmgdmfsezwqcrslpbxmnwvjxphcbmshayiodnnxwvahvsyleotqqlhirkjlatjnwmtmmsbkalmvdnupeejrykffsffyytugissgtmnyekjqitjfjncgrezpahvjknlbclkopsjtykfzpqlffvyeblcedfxjpsmdtuerffmaiiphomwkctufxsiauhctxsivqpltobdwybprkhchieimoitrjolnybwgqnmjrpkxazmwcasetwsxgqjlbhefssubuvpharcfxhsyscsriqvkotcackholuhfzradelmacojqbtncjhfwpfqwvbdxjvxomcgjiitstgxlskmzcsvhihwcvoxebboazklzvjbwabahyhmvrbewuxjbznehqrwccovzutpumalkpvaocwryvjyeezttwgithxltruftqkyxyfkgyfguavmmemueluvyfehbocgsekgznivscohwyhjwooegympcpesuujadzpvxbebensajfnnvywngawinqyxbeiuqheklyolibfktbmddllbgtqmgvctgefzjwzfnesltuqzytsfuenjblldtjilahswbwmphmakmeawekkpfoiiaozxspqiknxtxomxiqwuvfoenxemcldulgdttfrdyvoxjrnmbkxguworfgqzsxpijtefgguinlbixctiqcdqjvcnxwljpkfvftcqjdvkkoqvnrdbkhovmpcappqsmwuzrorqyvmusiemqbxjscejthwlycucoccnoewjekchjqxeeaxbyvneivxcdydqamzcvleohgxdzzcyngimxqzdhvllpycnvrvbowtowukelfvjovohtafapdezecrabznzmhmipjcbweqtrikczwqbuciyztrapbekfocryxrwmffphoivpwfiyosxpkyqywkvikzrvfudeoyvyissaubkowuvzpmsopvomseieivziqynovnaeapjfjfhjuzqtebrpqmwegzsvouuwptpqxcylqnabbrgiuvjhjtpqlrcixmcsyekcdxeixycwbocbezpetkqzrwyimikpjziimieyqoessjvqpypdnjpngvbfkifvuqsvcqfkwakdlvxfhneyfanbhqryrcbojqdnbbsadhcfxjmrjqwjjzxtusjqgkywatbrsszogjyreikgjqnucomibvajysnhvtodyxukkrcftiewcvjscmnyyrqkteohffqfehdrtjcaldwcukgnoclqwewabisdwevmynuzwlwikgsjwnmkmalkktmuiohcxyxzuxfogymsnjoefwxzwvaxvjqypzoocnydwggqyswygyajmwjczcrjdijsaoepwoqbekbzmpsdomsbkukirdlpzenohkpfexmahidgdlnvctvsvvcjpakiotoarnvfrpopdecxisdnqcdersoyuxypiicnhxvhvlqgfxlwnecdtfmsvuturggxxstxacnamdboyfoviavuimjnmzumsfmtpilvmzgfukxxwlhcmlyjfcxioderggkknwmilhnwebubywjtzvrfraijkdbafkgqfwooxbfwqknjtejesvqvauclxhoaivqtszuztdagbvxtzocksbbydqezqoghchyfgipfgckihnwvoqqejejfuiiarpkjfqrytxqwvwztwfuldyaxsczdvgoocbbndwndorkgjaqpdxchaspgwoylpclhiuxvjbfzalcyyxucygjwwynvvtklwcenuswoedrcnuwpegdlxtxavapdcwzukycdiqtvxytuuwwgtoljvcgdqqimrtrsdjvopgbyrfqoqeqdvvzqragwdkhbedxczdzgexgxgmbwgznogqnegoesellwuvezjmkujiixvkmsybocnuyomzyvajrgtldkminlbwbfxhbpalhreyuxnvyhumwcpwnscwaudmpzvuujnwiktxbzvczefnpjflaubhokplqmzzjtttdvrbxswmflsaueafokqthikxaogvwcgqhzlkimmwqherzlmnpkxxpfhgblfwpoiwvufkdbtvyixnsorwobajfcivuvcuudfqoroczjqocyevhqwgcjrhpmqlqbaqvdtvyovwnplzjhoylcsqpqqahxybrpzmidrdjrpcxewvsfqnxglpixmiertpjhezdtcgylhbxdcbjiavcsfyataialdjskqhrsqemygllpftrkaezmihzacbhmtbplaiufvodvkxhmyseacqoauufnwkhkmwvbpwheauxneglqdxnzepamermqayfxhpzklgdcsvhljdrphwcrfibblivigzognxoujeijlclqwrertsnrxlsdfuayckuqmcwznegmvwqqvivtwwcyufrlmnjonpfdmgvsflgidthqlxduryswstznfqhsynxzdzytooivftkjhnoebyydlosysfaepooamthyvfuxsikjymiiehavfijncwbqsyooshjhdxqugztfeenzwwtntftkvzqryeqhfnjyaunkzabpqkhkbichdpazhlvurjqbibqkdaouhmpnyfjfguwbvwtbtuhzzvtautrcixwklodvccwyxxwcdsxqgmbpxcsaomciqcgyubrjentajuwfygrucnjhubvtkwqpibxrmgwzcgilurzhbxvybkxyjbmvlfmairsesaydzwufjwbcbqvmuzkqgabteybwzcdtnqpzpngbaypdnzeiiljgcskixqofwkrptvlycvibbijjbdjjsbxihsluofdgzmkordkxsteviyyawtybxuzydoogjrezifywhogedcjmikqbujubpziqywijmbxnfmctlfkfxnrvctqgagsvxhgavgmsmbivnsaoacnjtcgmfpknvebxfxmkaapoczhjhkvyrjsbuwsojhlzagcedhkupyetzhexubqdpwbehgcnoauinbbfmvojmnklrlcbleuortsbjzzqdqwbsdvapqqfqxpetywemvhfffkojcfwfxjfzcgpxopbxcphqpmrrrkaplrmniigdryhifmufddkizgbhbgcxvcntujlwedemcluetinkzltzwjdrvzhelcmdktqpcitislwlkurqrhftqpccimqbcixvacdxdeepfrmuhvezpdgggevullgmvdpgouuxkzdhjewdijboumhmsboxhgzadjtwmeimdnavljnzdocsvcdkroqeulfaubhlcaamalpsukazggtwgpwdeqnpuedwwtjcrjdnokovvvtbjobvmeaqomfidmarizadomwrfedkusktxgbotdikfebmkrosgfpshynksglrtjiawdtidcvblzbewiqftxzyxdknnutfhqvanlscqqdxpjyqczbmzdfxcrctapwxqrokuexlbzmrdisdbzryowqwhzjxntrajzhfrsspiurmwuiarozvojsigivusihnzejxtoaljajmwazmeyoxodtgfnhsawbmbjcptsqwzrrlirrncipztqvkosqcyfyqfvbdnhwlmotffcbxczakkxqaynkemgwvdniaxrkvsskryiphzqpcgbsmixjfbdtxeemtbwydwgywxxofsayqohghjahnbsfwaqpzpbzofokykfcvlelnqhjnkdkvsigffqfebnkfjqumrkxcjlxubcpbpkhzddyhalpqrvjeduxpugfijyfgbzdhqfcwpoixmotpzybhfzgflhtqsublszjpeyagozzlxopflouxprnazfkyyklromjiwqqwijmorlkyykfzanrpxuolfpoxlzzogayepjzslbusqthlfgzfhbyzptomxiopwcfqhdzbgfyjifgupxudejvrqplahyddzhkpbpcbuxljcxkrmuqjfknbefqffgisvkdknjhqnlelvcfkykofozbpzpqawfsbnhajhghoqyasfoxxwygwdywbtmeextdbfjximsbgcpqzhpiyrkssvkrxaindvwgmeknyaqxkkazcxbcfftomlwhndbvfqyfycqsokvqtzpicnrrilrrzwqstpcjbmbwashnfgtdoxoyemzawmjajlaotxjeznhisuvigisjovzoraiuwmruipssrfhzjartnxjzhwqwoyrzbdsidrmzblxeukorqxwpatcrcxfdzmbzcqyjpxdqqcslnavqhftunnkdxyzxtfqiwebzlbvcditdwaijtrlgsknyhspfgsorkmbefkidtobgxtksukdefrwmodaziramdifmoqaemvbojbtvvvokondjrcjtwwdeupnqedwpgwtggzakusplamaaclhbuaflueqorkdcvscodznjlvandmiemwtjdazghxobsmhmuobjidwejhdzkxuuogpdvmglluvegggdpzevhumrfpeedxdcavxicbqmiccpqtfhrqruklwlsiticpqtkdmclehzvrdjwztlzkniteulcmedewljutncvxcgbhbgzikddfumfihyrdgiinmrlpakrrrmpqhpcxbpoxpgczfjxfwfcjokfffhvmewytepxqfqqpavdsbwqdqzzjbstrouelbclrlknmjovmfbbniuaoncghebwpdqbuxehzteypukhdecgazlhjoswubsjryvkhjhzcopaakmxfxbevnkpfmgctjncaoasnvibmsmgvaghxvsgagqtcvrnxfkfltcmfnxbmjiwyqizpbujubqkimjcdegohwyfizerjgoodyzuxbytwayyivetsxkdrokmzgdfoulshixbsjjdbjjibbivcylvtprkwfoqxikscgjliiezndpyabgnpzpqntdczwbyetbagqkzumvqbcbwjfuwzdyasesriamflvmbjyxkbyvxbhzruligczwgmrxbipqwktvbuhjncurgyfwujatnejrbuygcqicmoascxpbmgqxsdcwxxywccvdolkwxicrtuatvzzhutbtwvbwugfjfynpmhuoadkqbibqjruvlhzapdhcibkhkqpbazknuayjnfhqeyrqzvktftntwwzneeftzguqxdhjhsooysqbwcnjifvaheiimyjkisxufvyhtmaoopeafsysoldyybeonhjktfviootyzdzxnyshqfnztswsyrudxlqhtdiglfsvgmdfpnojnmlrfuycwwtvivqqwvmgenzwcmqukcyaufdslxrnstrerwqlcljiejuoxngozgivilbbifrcwhprdjlhvscdglkzphxfyaqmremapeznxdqlgenxuaehwpbvwmkhkwnfuuaoqcaesymhxkvdovfuialpbtmhbcazhimzeakrtfpllgymeqsrhqksjdlaiatayfscvaijbcdxbhlygctdzehjptreimxiplgxnqfsvwexcprjdrdimzprbyxhaqqpqsclyohjzlpnwvoyvtdvqabqlqmphrjcgwqhveycoqjzcoroqfduucvuvicfjabowrosnxiyvtbdkfuvwiopwflbghfpxxkpnmlzrehqwmmiklzhqgcwvgoaxkihtqkofaeuaslfmwsxbrvdtttjzzmqlpkohbualfjpnfezcvzbxtkiwnjuuvzpmduawcsnwpcwmuhyvnxuyerhlapbhxfbwblnimkdltgrjavyzmoyuncobysmkvxiijukmjzevuwlleseogenqgonzgwbmgxgxegzdzcxdebhkdwgarqzvvdqeqoqfrybgpovjdsrtrmiqqdgcvjlotgwwuutyxvtqidcykuzwcdpavaxtxldgepwuncrdeowsunecwlktvvnywwjgycuxyyclazfbjvxuihlcplyowgpsahcxdpqajgkrodnwdnbbcoogvdzcsxaydlufwtzwvwqxtyrqfjkpraiiufjejeqqovwnhikcgfpigfyhchgoqzeqdybbskcoztxvbgadtzuzstqviaohxlcuavqvsejetjnkqwfbxoowfqgkfabdkjiarfrvztjwybubewnhlimwnkkggredoixcfjylmchlwxxkufgzmvliptmfsmuzmnjmiuvaivofyobdmancaxtsxxggrutuvsmftdcenwlxfgqlvhvxhnciipyxuyosredcqndsixcedpoprfvnraotoikapjcvvsvtcvnldgdihamxefpkhonezpldrikukbsmodspmzbkebqowpeoasjidjrczcjwmjaygywsyqggwdyncoozpyqjvxavwzxwfeojnsmygofxuzxyxchoiumtkklamkmnwjsgkiwlwzunymvewdsibawewqlcongkucwdlacjtrdhefqffhoetkqryynmcsjvcweitfcrkkuxydotvhnsyjavbimocunqjgkieryjgozssrbtawykgqjsutxzjjwqjrmjxfchdasbbndqjobcryrqhbnafyenhfxvldkawkfqcvsquvfikfbvgnpjndpypqvjsseoqyeimiizjpkimiywrzqktepzebcobwcyxiexdckeyscmxicrlqptjhjvuigrbbanqlycxqptpwuuovszgewmqprbetqzujhfjfjpaeanvonyqizvieiesmovposmpzvuwokbuassiyvyoedufvrzkivkwyqykpxsoyifwpviohpffmwrxyrcofkebpartzyicubqwzckirtqewbcjpimhmznzbarcezedpafathovojvflekuwotwobvrvncypllvhdzqxmignyczzdxghoelvczmaqdydcxvienvybxaeexqjhckejweonccocucylwhtjecsjxbqmeisumvyqrorzuwmsqppacpmvohkbdrnvqokkvdjqctfvfkpjlwxncvjqdcqitcxiblniuggfetjipxszqgfrowugxkbmnrjxovydrfttdgludlcmexneofvuwqixmoxtxnkiqpsxzoaiiofpkkewaemkamhpmwbwshalijtdllbjneufstyzqutlsenfzwjzfegtcvgmqtgbllddmbtkfbiloylkehquiebxyqniwagnwyvnnfjasnebebxvpzdajuusepcpmygeoowjhywhocsvinzgkesgcobhefyvuleumemmvaugfygkfyxykqtfurtlxhtigwttzeeyjvyrwcoavpklamuptuzvoccwrqhenzbjxuwebrvmhyhabawbjvzlkzaobbexovcwhihvsczmkslxgtstiijgcmoxvjxdbvwqfpwfhjcntbqjocamledarzfhulohkcactokvqirscsyshxfcrahpvubussfehbljqgxswtesacwmzaxkprjmnqgwbynlojrtiomieihchkrpbywdbotlpqvisxtchuaisxfutckwmohpiiamffreutdmspjxfdeclbeyvfflqpzfkytjspoklcblnkjvhapzergcnjfjtiqjkeynmtgssigutyyffsffkyrjeepundvmlakbsmmtmwnjtaljkrihlqqtoelysvhavwxnndoiyahsmbchpxjvwnmxbplsrcqwzesfmdgmgokdjyuzqezwndlprxgydcpeyvcchlzlkxkypqxwavzlehaoffhgronnqwaqebbfukvdyqpudvfzfvdoltwfwzuojlisjklxlrrkufaygasnbgkhdxdtkmtqxjntkjlspqlclvwfqiywnxbrglqjrgomxoauzxsmtkudjenbbmurnlgonbabdhntrztawqbpizbbztwghrzqxbzrnuondfumxanbikxnycnrooxdhvsoesptfhhmetdbknjgmmvhnscrwvtxsdncjujneuznmnbnpnbqzmrvxmoudqmulbwnuvvnsfmtpnkgwohxobtpxxtftwytgkxkqoetokmfoubhgjehkcdyanjdepvxznccemqtpgadjathbtoullucahgnmdzgzjiohqbbyziojshgxauhffzrgzokdfdrfdvdnhghzmrlencqcgpmcmybjvdxalgwrkvmwhwumwmonwkpbcdanflrxobnckafudnoivjudcykeqzvumfwtprzagpqcfihblayuigvanirzaqmbwwbfuxpaarumgiktmwkkwalcazabfsjputkgwtobcpmxulbjvihcvuqoxaudxojelkewjlhcgwtsetbcuunpvfywwkxixditzijqubwiieckzzlgtdjyfnwizbjvyzuwvpxvlasclvmhpvweuarvohopvvhpllaujpusywtyalqqbhjghheruiflyzcluhhpbtevswdgqeeohhvxwycymlfqxxijpkqzhlgmmhkgfcsntrtqzniclzottpvplxmrdvgujbtyihgtljrtrrwuladvexqtbfmrwhmgbkbwoujzhgdrlappwdcudcjrkdervnyysgrbshlzkhfwyuvwtuaftjdxuujmeewzijswbkynwgisyspfetyywtqoyrbzalytdvyvsgskxohoahdjbrikhtyomvkormooeypmxmrwuhnbdiauederjukwjkbxyuekuagaknfdfmptxtidoxxordwurgqiaaicwtilwmlayxeumlfvgfwrzpbuhujkdoefcfqsqpsnrcwcdepilgigptunezhskbvpcgxnsjirriigphtgfyjtukglmxgxzacnrdimmuleuzfvmdzwogzrtecnmoovbdccvbreydueyqjwwemvogwhgturupcfanqwrssqprsazouelaqerkwljxwyskxrbcjfffggsplekod\"\n```"
                    }
                ]
            },
            {
                "id": 1970027,
                "content": [
                    {
                        "username": "aiswaryaa",
                        "content": "give tip"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "start checking form start and end index,,,whenever it hits that (start!=end) ,then pass it to another function which will check the reamin string is palindrome or not ,if its true return true ,otherwise false...  \n\n    NOTE: in the second function call u must have check two condition ,\n1st increase the starting index by one and check but the end index remains same (in this casse it  will ignore the 1st character from starting index) \n\nand 2nd one is: increase the end index by one, here start will be same (thus it willl check after ignoring the last index) and u have to check both the conditions ,to cover all the edge cases...\n"
                    },
                    {
                        "username": "varsha1531",
                        "content": "bool validPalindrome(string s) {\n      \n      int c=0;\n      int j=s.length()-1,i=0;\n      while(i<=j)\n      {\n          if(s[i]==s[j])\n          {\n              j--;\n              i++;\n          }\n          else \n          {\n              if(s[i]==s[j-1] )\n              {\n                  j=j-2;\n                  c++;\n                  i++;\n              }\n              else if(s[i+1]==s[j])\n              {\n                  i=i+2;\n                  c++;\n                  j--;\n              }\n              else{\n                  return false;\n              }\n          }\n          \n      }\n      \nreturn c<=1;\n     \n    } \nplz help me where am i going wrong\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": " `Consider this - ebcbbececabbacecbbcbe`\n \nI can't figure out why the LeetCode compiler refuses to accept my solution for \"ebcbbececabbacecbbcbe\" specific given input  [the input String isn't a palindrome at all ] . Can anyone lend a hand? Any insights or suggestions to resolve this compiler error would be greatly appreciated. Help me crack this puzzle.........\n"
                    },
                    {
                        "username": "vedranson",
                        "content": "First and last 5 chars: \\'ebcbb [...] bbcbe\\' make a valid palindrome. The rest is now \\'ececabbacec\\'. If you were to delete/ignore the leading \\'e\\', the rest \\'cecabbacec\\' is a valid palindrome."
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me figure out why my code is showing incorrect output for this string \"lfhnzyffurnskdlduhopgrssphgnbaxtuzmlwsxzamjtdqymgmmmmgmyxqdtjmazxwlmzutxabnghpssrgpohudldksnruffyznhfl\"\\nMy code is showing true but expected output is false. Can someone help me figure out what is wrong in my code \\n```class Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        int flag = 0;\\n        char uh;\\n        while(i<j)\\n        {\\n          while(!isalnum(s[i]))\\n          {\\n              i++;\\n          }\\n          while(!isalnum(s[j]))\\n          {\\n              j--;\\n          }\\n\\n          if(!(s[i]==s[j]) && flag==0)\\n          {\\n            flag =1;\\n            if (s[i + 1] == s[j])\\n            {\\n                i++;\\n                uh = s[i];\\n            }\\n\\n            else if (s[i] == s[j - 1])\\n            {\\n                uh = s[j];\\n                j--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n          }\\n          \\n          else if(!(s[i]==s[j]) && flag==1)\\n          {\\n              if((s[i]==uh || s[j]==uh))\\n              {\\n                if (s[i] == uh)\\n                    i++;\\n                else if (s[j] == uh)\\n                    j--;\\n              }\\n              else\\n              {\\n                  return false;\\n              }\\n          }\\n          else\\n          {\\n             i++;\\n             j--;\\n          }\\n        }\\n        return true;\\n    }\\n};```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Got it, I was removing all occurrences of the character"
                    },
                    {
                        "username": "10xvishal",
                        "content": "\"woicvixviciow\" why is this supposed to be false, after neglecting i its a valid palindrome \"wocvxvcow\""
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "you have to remove just 1 char in your input to make it a valid palindrome"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "seems that a testcase \"tebbem\" expects `false`. is \"ebbe\" not a valid palindrome? [@LeetCode](/LeetCode) ?"
                    },
                    {
                        "username": "10xvishal",
                        "content": "you will only get \"tebbe\" or \"ebbem\" after removing single char."
                    },
                    {
                        "username": "ankush920",
                        "content": "FULL EXPLAINED ||CODE || C++ ||0(N)\\nankush920\\n0\\nin a minute\\nIntuition\\nokk sit relax don\\'t frustate it\\'s easy but slightly different .\\n\\nremember must one mean --> can delete 0 or 1 character only\\nusing two pointer approach :-\\n-> i--> intial pointer , j--> final pointer\\n-> travese it from end , start both side (i++ , j-- );\\n-> if s[i] == s[j] --> satisfy palindrom condition okk go forward\\n->but if s[i] != s[j] so we can do two thing\\neither remove from left side ( i side deletion ) or righr side (j side deletion)\\n\\n(find useful upvote it vro :) )\\n-> i am choosing left first and right next and use counter( countI and countJ) to know whether i have chance to remove from left /right side or not\\n\\n**note i am not deleting from both side in my deletion condition box there is condition like that only one char is delete\\n\\n--> i use storeI and storeJ to for the remember point that where first inequality come and i was used my deletion power ( delete one character)\\nbecause in testcase like :-\\nif first inequality is come in string i go with \\'i\\' side deletion and it satisfy upto some length but not make my string completly palindromic because \\'j\\' side deletion make complete palindromic to my string so , at that i cann\\'t do \\'j\\' side deletion on present index\\n(it delete two character) i use that index where my first inequality ( or on which i use my i side is required to do it ** we only delete one character max**)\\n\\nso if both possibility fail mean (we check from i ,j side deletion )\\nreturn false otherwise true\\n\\nApproach\\nlinear traversal\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        \\n        int n = s.size();\\n        if( n  ==1)\\n        {\\n             return n;\\n        }\\n\\nint i = 0 , j = n-1;\\n\\nint countI = 0;\\nint countJ= 0;\\nint storeI =0;\\nint storeJ =0;\\n    while( i<=j)\\n    {\\n      \\n      if( s[i]!=s[j])\\n      {\\n          if( !countI)\\n          {\\n              countI=1;\\n              storeI =i;\\n              storeJ =j;\\n              i++;\\n              continue;\\n          }\\n\\n          if(!countJ)\\n          {\\n             i= storeI;\\n             j= storeJ; \\n             countJ =1;\\n             j--;\\n             continue;\\n          }\\n          return 0;\\n      }\\n\\n      i++;\\n      j--;\\n    }\\n\\nreturn true ;\\n    }\\n};"
                    },
                    {
                        "username": "Ardonite",
                        "content": "Hi,\\n\\nhow can expected be \"false\"?\\nIt must be true right?\\n\\nInput\\ns = \"tebbem\"\\n\\nOutput\\ntrue\\n\\nExpected\\nfalse"
                    },
                    {
                        "username": "underprocess",
                        "content": "you must remove t and m to make it palindrome but according to question s can be palindrome after deleting at most one character from it.so false."
                    },
                    {
                        "username": "darkpheonix2_O",
                        "content": "If you are unable to come up with any solution, think it like you skip one character from left and check for valid palindrome, if no solution is found save that index and now skip the right index to check for valid palindrome, it no valid palindrome is found then answer is false else true. Use two pointers left and right to check for valid palindrome."
                    },
                    {
                        "username": "aknownymous",
                        "content": "#### Can Someone tell me, how can I reduce its time complexity? Passes all the case except 402th. \n```\nclass Solution:\n    def pal(self,s):\n        if s==s[::-1]: return True\n        return False\n    def validPalindrome(self, s: str) -> bool:\n        if self.pal(s): return True\n        for i in range(len(s)):\n            c= list(s)\n            c.pop(i)\n            if self.pal(c): return True\n        return False\n```\n\n\n#### Test Case :\n```\n\"okelpsggfffjcbrxksywxjlwkreqaleuozasrpqssrwqnafcpurutghwgovmewwjqyeudyerbvccdbvoomncetrzgowzdmvfzuelummidrncazxgxmlgkutjyfgthpgiirrijsnxgcpvbkshzenutpgiglipedcwcrnspqsqfcfeodkjuhubpzrwfgvflmuexyalmwlitwciaaiqgruwdroxxoditxtpmfdfnkagaukeuyxbkjwkujredeuaidbnhuwrmxmpyeoomrokvmoythkirbjdhaohoxksgsvyvdtylazbryoqtwyytefpsysigwnykbwsjizweemjuuxdjtfautwvuywfhkzlhsbrgsyynvredkrjcducdwppalrdghzjuowbkbgmhwrmfbtqxevdaluwrrtrjltghiytbjugvdrmxlpvpttozlcinzqtrtnscfgkhmmglhzqkpjixxqflmycywxvhhoeeqgdwsvetbphhulczylfiurehhgjhbqqlaytwysupjuallphvvpohovrauewvphmvlcsalvxpvwuzyvjbziwnfyjdtglzzkceiiwbuqjiztidxixkwwyfvpnuucbtestwgchljweklejoxduaxoquvchivjbluxmpcbotwgktupjsfbazaclawkkwmtkigmuraapxufbwwbmqazrinavgiuyalbhifcqpgazrptwfmuvzqekycdujviondufakcnboxrlfnadcbpkwnomwmuwhwmvkrwglaxdvjbymcmpgcqcnelrmzhghndvdfrdfdkozgrzffhuaxghsjoizybbqhoijzgzdmnghaculluotbhtajdagptqmeccnzxvpedjnaydckhejghbuofmkoteoqkxkgtywtftxxptboxhowgknptmfsnvvunwblumqduomxvrmzqbnpnbnmnzuenjujcndsxtvwrcsnhvmmgjnkbdtemhhftpseosvhdxoorncynxkibnaxmufdnounrzbxqzrhgwtzbbzipbqwatzrtnhdbabnoglnrumbbnejduktmsxzuaoxmogrjqlgrbxnwyiqfwvlclqpsljktnjxqtmktdxdhkgbnsagyafukrrlxlkjsiljouzwfwtlodvfzfvdupqydvkufbbeqawqnnorghffoahelzvawxqpykxklzlhccvyepcdygxrpldnwzeqzuyjdkogmgdmfsezwqcrslpbxmnwvjxphcbmshayiodnnxwvahvsyleotqqlhirkjlatjnwmtmmsbkalmvdnupeejrykffsffyytugissgtmnyekjqitjfjncgrezpahvjknlbclkopsjtykfzpqlffvyeblcedfxjpsmdtuerffmaiiphomwkctufxsiauhctxsivqpltobdwybprkhchieimoitrjolnybwgqnmjrpkxazmwcasetwsxgqjlbhefssubuvpharcfxhsyscsriqvkotcackholuhfzradelmacojqbtncjhfwpfqwvbdxjvxomcgjiitstgxlskmzcsvhihwcvoxebboazklzvjbwabahyhmvrbewuxjbznehqrwccovzutpumalkpvaocwryvjyeezttwgithxltruftqkyxyfkgyfguavmmemueluvyfehbocgsekgznivscohwyhjwooegympcpesuujadzpvxbebensajfnnvywngawinqyxbeiuqheklyolibfktbmddllbgtqmgvctgefzjwzfnesltuqzytsfuenjblldtjilahswbwmphmakmeawekkpfoiiaozxspqiknxtxomxiqwuvfoenxemcldulgdttfrdyvoxjrnmbkxguworfgqzsxpijtefgguinlbixctiqcdqjvcnxwljpkfvftcqjdvkkoqvnrdbkhovmpcappqsmwuzrorqyvmusiemqbxjscejthwlycucoccnoewjekchjqxeeaxbyvneivxcdydqamzcvleohgxdzzcyngimxqzdhvllpycnvrvbowtowukelfvjovohtafapdezecrabznzmhmipjcbweqtrikczwqbuciyztrapbekfocryxrwmffphoivpwfiyosxpkyqywkvikzrvfudeoyvyissaubkowuvzpmsopvomseieivziqynovnaeapjfjfhjuzqtebrpqmwegzsvouuwptpqxcylqnabbrgiuvjhjtpqlrcixmcsyekcdxeixycwbocbezpetkqzrwyimikpjziimieyqoessjvqpypdnjpngvbfkifvuqsvcqfkwakdlvxfhneyfanbhqryrcbojqdnbbsadhcfxjmrjqwjjzxtusjqgkywatbrsszogjyreikgjqnucomibvajysnhvtodyxukkrcftiewcvjscmnyyrqkteohffqfehdrtjcaldwcukgnoclqwewabisdwevmynuzwlwikgsjwnmkmalkktmuiohcxyxzuxfogymsnjoefwxzwvaxvjqypzoocnydwggqyswygyajmwjczcrjdijsaoepwoqbekbzmpsdomsbkukirdlpzenohkpfexmahidgdlnvctvsvvcjpakiotoarnvfrpopdecxisdnqcdersoyuxypiicnhxvhvlqgfxlwnecdtfmsvuturggxxstxacnamdboyfoviavuimjnmzumsfmtpilvmzgfukxxwlhcmlyjfcxioderggkknwmilhnwebubywjtzvrfraijkdbafkgqfwooxbfwqknjtejesvqvauclxhoaivqtszuztdagbvxtzocksbbydqezqoghchyfgipfgckihnwvoqqejejfuiiarpkjfqrytxqwvwztwfuldyaxsczdvgoocbbndwndorkgjaqpdxchaspgwoylpclhiuxvjbfzalcyyxucygjwwynvvtklwcenuswoedrcnuwpegdlxtxavapdcwzukycdiqtvxytuuwwgtoljvcgdqqimrtrsdjvopgbyrfqoqeqdvvzqragwdkhbedxczdzgexgxgmbwgznogqnegoesellwuvezjmkujiixvkmsybocnuyomzyvajrgtldkminlbwbfxhbpalhreyuxnvyhumwcpwnscwaudmpzvuujnwiktxbzvczefnpjflaubhokplqmzzjtttdvrbxswmflsaueafokqthikxaogvwcgqhzlkimmwqherzlmnpkxxpfhgblfwpoiwvufkdbtvyixnsorwobajfcivuvcuudfqoroczjqocyevhqwgcjrhpmqlqbaqvdtvyovwnplzjhoylcsqpqqahxybrpzmidrdjrpcxewvsfqnxglpixmiertpjhezdtcgylhbxdcbjiavcsfyataialdjskqhrsqemygllpftrkaezmihzacbhmtbplaiufvodvkxhmyseacqoauufnwkhkmwvbpwheauxneglqdxnzepamermqayfxhpzklgdcsvhljdrphwcrfibblivigzognxoujeijlclqwrertsnrxlsdfuayckuqmcwznegmvwqqvivtwwcyufrlmnjonpfdmgvsflgidthqlxduryswstznfqhsynxzdzytooivftkjhnoebyydlosysfaepooamthyvfuxsikjymiiehavfijncwbqsyooshjhdxqugztfeenzwwtntftkvzqryeqhfnjyaunkzabpqkhkbichdpazhlvurjqbibqkdaouhmpnyfjfguwbvwtbtuhzzvtautrcixwklodvccwyxxwcdsxqgmbpxcsaomciqcgyubrjentajuwfygrucnjhubvtkwqpibxrmgwzcgilurzhbxvybkxyjbmvlfmairsesaydzwufjwbcbqvmuzkqgabteybwzcdtnqpzpngbaypdnzeiiljgcskixqofwkrptvlycvibbijjbdjjsbxihsluofdgzmkordkxsteviyyawtybxuzydoogjrezifywhogedcjmikqbujubpziqywijmbxnfmctlfkfxnrvctqgagsvxhgavgmsmbivnsaoacnjtcgmfpknvebxfxmkaapoczhjhkvyrjsbuwsojhlzagcedhkupyetzhexubqdpwbehgcnoauinbbfmvojmnklrlcbleuortsbjzzqdqwbsdvapqqfqxpetywemvhfffkojcfwfxjfzcgpxopbxcphqpmrrrkaplrmniigdryhifmufddkizgbhbgcxvcntujlwedemcluetinkzltzwjdrvzhelcmdktqpcitislwlkurqrhftqpccimqbcixvacdxdeepfrmuhvezpdgggevullgmvdpgouuxkzdhjewdijboumhmsboxhgzadjtwmeimdnavljnzdocsvcdkroqeulfaubhlcaamalpsukazggtwgpwdeqnpuedwwtjcrjdnokovvvtbjobvmeaqomfidmarizadomwrfedkusktxgbotdikfebmkrosgfpshynksglrtjiawdtidcvblzbewiqftxzyxdknnutfhqvanlscqqdxpjyqczbmzdfxcrctapwxqrokuexlbzmrdisdbzryowqwhzjxntrajzhfrsspiurmwuiarozvojsigivusihnzejxtoaljajmwazmeyoxodtgfnhsawbmbjcptsqwzrrlirrncipztqvkosqcyfyqfvbdnhwlmotffcbxczakkxqaynkemgwvdniaxrkvsskryiphzqpcgbsmixjfbdtxeemtbwydwgywxxofsayqohghjahnbsfwaqpzpbzofokykfcvlelnqhjnkdkvsigffqfebnkfjqumrkxcjlxubcpbpkhzddyhalpqrvjeduxpugfijyfgbzdhqfcwpoixmotpzybhfzgflhtqsublszjpeyagozzlxopflouxprnazfkyyklromjiwqqwijmorlkyykfzanrpxuolfpoxlzzogayepjzslbusqthlfgzfhbyzptomxiopwcfqhdzbgfyjifgupxudejvrqplahyddzhkpbpcbuxljcxkrmuqjfknbefqffgisvkdknjhqnlelvcfkykofozbpzpqawfsbnhajhghoqyasfoxxwygwdywbtmeextdbfjximsbgcpqzhpiyrkssvkrxaindvwgmeknyaqxkkazcxbcfftomlwhndbvfqyfycqsokvqtzpicnrrilrrzwqstpcjbmbwashnfgtdoxoyemzawmjajlaotxjeznhisuvigisjovzoraiuwmruipssrfhzjartnxjzhwqwoyrzbdsidrmzblxeukorqxwpatcrcxfdzmbzcqyjpxdqqcslnavqhftunnkdxyzxtfqiwebzlbvcditdwaijtrlgsknyhspfgsorkmbefkidtobgxtksukdefrwmodaziramdifmoqaemvbojbtvvvokondjrcjtwwdeupnqedwpgwtggzakusplamaaclhbuaflueqorkdcvscodznjlvandmiemwtjdazghxobsmhmuobjidwejhdzkxuuogpdvmglluvegggdpzevhumrfpeedxdcavxicbqmiccpqtfhrqruklwlsiticpqtkdmclehzvrdjwztlzkniteulcmedewljutncvxcgbhbgzikddfumfihyrdgiinmrlpakrrrmpqhpcxbpoxpgczfjxfwfcjokfffhvmewytepxqfqqpavdsbwqdqzzjbstrouelbclrlknmjovmfbbniuaoncghebwpdqbuxehzteypukhdecgazlhjoswubsjryvkhjhzcopaakmxfxbevnkpfmgctjncaoasnvibmsmgvaghxvsgagqtcvrnxfkfltcmfnxbmjiwyqizpbujubqkimjcdegohwyfizerjgoodyzuxbytwayyivetsxkdrokmzgdfoulshixbsjjdbjjibbivcylvtprkwfoqxikscgjliiezndpyabgnpzpqntdczwbyetbagqkzumvqbcbwjfuwzdyasesriamflvmbjyxkbyvxbhzruligczwgmrxbipqwktvbuhjncurgyfwujatnejrbuygcqicmoascxpbmgqxsdcwxxywccvdolkwxicrtuatvzzhutbtwvbwugfjfynpmhuoadkqbibqjruvlhzapdhcibkhkqpbazknuayjnfhqeyrqzvktftntwwzneeftzguqxdhjhsooysqbwcnjifvaheiimyjkisxufvyhtmaoopeafsysoldyybeonhjktfviootyzdzxnyshqfnztswsyrudxlqhtdiglfsvgmdfpnojnmlrfuycwwtvivqqwvmgenzwcmqukcyaufdslxrnstrerwqlcljiejuoxngozgivilbbifrcwhprdjlhvscdglkzphxfyaqmremapeznxdqlgenxuaehwpbvwmkhkwnfuuaoqcaesymhxkvdovfuialpbtmhbcazhimzeakrtfpllgymeqsrhqksjdlaiatayfscvaijbcdxbhlygctdzehjptreimxiplgxnqfsvwexcprjdrdimzprbyxhaqqpqsclyohjzlpnwvoyvtdvqabqlqmphrjcgwqhveycoqjzcoroqfduucvuvicfjabowrosnxiyvtbdkfuvwiopwflbghfpxxkpnmlzrehqwmmiklzhqgcwvgoaxkihtqkofaeuaslfmwsxbrvdtttjzzmqlpkohbualfjpnfezcvzbxtkiwnjuuvzpmduawcsnwpcwmuhyvnxuyerhlapbhxfbwblnimkdltgrjavyzmoyuncobysmkvxiijukmjzevuwlleseogenqgonzgwbmgxgxegzdzcxdebhkdwgarqzvvdqeqoqfrybgpovjdsrtrmiqqdgcvjlotgwwuutyxvtqidcykuzwcdpavaxtxldgepwuncrdeowsunecwlktvvnywwjgycuxyyclazfbjvxuihlcplyowgpsahcxdpqajgkrodnwdnbbcoogvdzcsxaydlufwtzwvwqxtyrqfjkpraiiufjejeqqovwnhikcgfpigfyhchgoqzeqdybbskcoztxvbgadtzuzstqviaohxlcuavqvsejetjnkqwfbxoowfqgkfabdkjiarfrvztjwybubewnhlimwnkkggredoixcfjylmchlwxxkufgzmvliptmfsmuzmnjmiuvaivofyobdmancaxtsxxggrutuvsmftdcenwlxfgqlvhvxhnciipyxuyosredcqndsixcedpoprfvnraotoikapjcvvsvtcvnldgdihamxefpkhonezpldrikukbsmodspmzbkebqowpeoasjidjrczcjwmjaygywsyqggwdyncoozpyqjvxavwzxwfeojnsmygofxuzxyxchoiumtkklamkmnwjsgkiwlwzunymvewdsibawewqlcongkucwdlacjtrdhefqffhoetkqryynmcsjvcweitfcrkkuxydotvhnsyjavbimocunqjgkieryjgozssrbtawykgqjsutxzjjwqjrmjxfchdasbbndqjobcryrqhbnafyenhfxvldkawkfqcvsquvfikfbvgnpjndpypqvjsseoqyeimiizjpkimiywrzqktepzebcobwcyxiexdckeyscmxicrlqptjhjvuigrbbanqlycxqptpwuuovszgewmqprbetqzujhfjfjpaeanvonyqizvieiesmovposmpzvuwokbuassiyvyoedufvrzkivkwyqykpxsoyifwpviohpffmwrxyrcofkebpartzyicubqwzckirtqewbcjpimhmznzbarcezedpafathovojvflekuwotwobvrvncypllvhdzqxmignyczzdxghoelvczmaqdydcxvienvybxaeexqjhckejweonccocucylwhtjecsjxbqmeisumvyqrorzuwmsqppacpmvohkbdrnvqokkvdjqctfvfkpjlwxncvjqdcqitcxiblniuggfetjipxszqgfrowugxkbmnrjxovydrfttdgludlcmexneofvuwqixmoxtxnkiqpsxzoaiiofpkkewaemkamhpmwbwshalijtdllbjneufstyzqutlsenfzwjzfegtcvgmqtgbllddmbtkfbiloylkehquiebxyqniwagnwyvnnfjasnebebxvpzdajuusepcpmygeoowjhywhocsvinzgkesgcobhefyvuleumemmvaugfygkfyxykqtfurtlxhtigwttzeeyjvyrwcoavpklamuptuzvoccwrqhenzbjxuwebrvmhyhabawbjvzlkzaobbexovcwhihvsczmkslxgtstiijgcmoxvjxdbvwqfpwfhjcntbqjocamledarzfhulohkcactokvqirscsyshxfcrahpvubussfehbljqgxswtesacwmzaxkprjmnqgwbynlojrtiomieihchkrpbywdbotlpqvisxtchuaisxfutckwmohpiiamffreutdmspjxfdeclbeyvfflqpzfkytjspoklcblnkjvhapzergcnjfjtiqjkeynmtgssigutyyffsffkyrjeepundvmlakbsmmtmwnjtaljkrihlqqtoelysvhavwxnndoiyahsmbchpxjvwnmxbplsrcqwzesfmdgmgokdjyuzqezwndlprxgydcpeyvcchlzlkxkypqxwavzlehaoffhgronnqwaqebbfukvdyqpudvfzfvdoltwfwzuojlisjklxlrrkufaygasnbgkhdxdtkmtqxjntkjlspqlclvwfqiywnxbrglqjrgomxoauzxsmtkudjenbbmurnlgonbabdhntrztawqbpizbbztwghrzqxbzrnuondfumxanbikxnycnrooxdhvsoesptfhhmetdbknjgmmvhnscrwvtxsdncjujneuznmnbnpnbqzmrvxmoudqmulbwnuvvnsfmtpnkgwohxobtpxxtftwytgkxkqoetokmfoubhgjehkcdyanjdepvxznccemqtpgadjathbtoullucahgnmdzgzjiohqbbyziojshgxauhffzrgzokdfdrfdvdnhghzmrlencqcgpmcmybjvdxalgwrkvmwhwumwmonwkpbcdanflrxobnckafudnoivjudcykeqzvumfwtprzagpqcfihblayuigvanirzaqmbwwbfuxpaarumgiktmwkkwalcazabfsjputkgwtobcpmxulbjvihcvuqoxaudxojelkewjlhcgwtsetbcuunpvfywwkxixditzijqubwiieckzzlgtdjyfnwizbjvyzuwvpxvlasclvmhpvweuarvohopvvhpllaujpusywtyalqqbhjghheruiflyzcluhhpbtevswdgqeeohhvxwycymlfqxxijpkqzhlgmmhkgfcsntrtqzniclzottpvplxmrdvgujbtyihgtljrtrrwuladvexqtbfmrwhmgbkbwoujzhgdrlappwdcudcjrkdervnyysgrbshlzkhfwyuvwtuaftjdxuujmeewzijswbkynwgisyspfetyywtqoyrbzalytdvyvsgskxohoahdjbrikhtyomvkormooeypmxmrwuhnbdiauederjukwjkbxyuekuagaknfdfmptxtidoxxordwurgqiaaicwtilwmlayxeumlfvgfwrzpbuhujkdoefcfqsqpsnrcwcdepilgigptunezhskbvpcgxnsjirriigphtgfyjtukglmxgxzacnrdimmuleuzfvmdzwogzrtecnmoovbdccvbreydueyqjwwemvogwhgturupcfanqwrssqprsazouelaqerkwljxwyskxrbcjfffggsplekod\"\n```"
                    }
                ]
            },
            {
                "id": 1933499,
                "content": [
                    {
                        "username": "aiswaryaa",
                        "content": "give tip"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "start checking form start and end index,,,whenever it hits that (start!=end) ,then pass it to another function which will check the reamin string is palindrome or not ,if its true return true ,otherwise false...  \n\n    NOTE: in the second function call u must have check two condition ,\n1st increase the starting index by one and check but the end index remains same (in this casse it  will ignore the 1st character from starting index) \n\nand 2nd one is: increase the end index by one, here start will be same (thus it willl check after ignoring the last index) and u have to check both the conditions ,to cover all the edge cases...\n"
                    },
                    {
                        "username": "varsha1531",
                        "content": "bool validPalindrome(string s) {\n      \n      int c=0;\n      int j=s.length()-1,i=0;\n      while(i<=j)\n      {\n          if(s[i]==s[j])\n          {\n              j--;\n              i++;\n          }\n          else \n          {\n              if(s[i]==s[j-1] )\n              {\n                  j=j-2;\n                  c++;\n                  i++;\n              }\n              else if(s[i+1]==s[j])\n              {\n                  i=i+2;\n                  c++;\n                  j--;\n              }\n              else{\n                  return false;\n              }\n          }\n          \n      }\n      \nreturn c<=1;\n     \n    } \nplz help me where am i going wrong\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": " `Consider this - ebcbbececabbacecbbcbe`\n \nI can't figure out why the LeetCode compiler refuses to accept my solution for \"ebcbbececabbacecbbcbe\" specific given input  [the input String isn't a palindrome at all ] . Can anyone lend a hand? Any insights or suggestions to resolve this compiler error would be greatly appreciated. Help me crack this puzzle.........\n"
                    },
                    {
                        "username": "vedranson",
                        "content": "First and last 5 chars: \\'ebcbb [...] bbcbe\\' make a valid palindrome. The rest is now \\'ececabbacec\\'. If you were to delete/ignore the leading \\'e\\', the rest \\'cecabbacec\\' is a valid palindrome."
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me figure out why my code is showing incorrect output for this string \"lfhnzyffurnskdlduhopgrssphgnbaxtuzmlwsxzamjtdqymgmmmmgmyxqdtjmazxwlmzutxabnghpssrgpohudldksnruffyznhfl\"\\nMy code is showing true but expected output is false. Can someone help me figure out what is wrong in my code \\n```class Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        int flag = 0;\\n        char uh;\\n        while(i<j)\\n        {\\n          while(!isalnum(s[i]))\\n          {\\n              i++;\\n          }\\n          while(!isalnum(s[j]))\\n          {\\n              j--;\\n          }\\n\\n          if(!(s[i]==s[j]) && flag==0)\\n          {\\n            flag =1;\\n            if (s[i + 1] == s[j])\\n            {\\n                i++;\\n                uh = s[i];\\n            }\\n\\n            else if (s[i] == s[j - 1])\\n            {\\n                uh = s[j];\\n                j--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n          }\\n          \\n          else if(!(s[i]==s[j]) && flag==1)\\n          {\\n              if((s[i]==uh || s[j]==uh))\\n              {\\n                if (s[i] == uh)\\n                    i++;\\n                else if (s[j] == uh)\\n                    j--;\\n              }\\n              else\\n              {\\n                  return false;\\n              }\\n          }\\n          else\\n          {\\n             i++;\\n             j--;\\n          }\\n        }\\n        return true;\\n    }\\n};```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Got it, I was removing all occurrences of the character"
                    },
                    {
                        "username": "10xvishal",
                        "content": "\"woicvixviciow\" why is this supposed to be false, after neglecting i its a valid palindrome \"wocvxvcow\""
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "you have to remove just 1 char in your input to make it a valid palindrome"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "seems that a testcase \"tebbem\" expects `false`. is \"ebbe\" not a valid palindrome? [@LeetCode](/LeetCode) ?"
                    },
                    {
                        "username": "10xvishal",
                        "content": "you will only get \"tebbe\" or \"ebbem\" after removing single char."
                    },
                    {
                        "username": "ankush920",
                        "content": "FULL EXPLAINED ||CODE || C++ ||0(N)\\nankush920\\n0\\nin a minute\\nIntuition\\nokk sit relax don\\'t frustate it\\'s easy but slightly different .\\n\\nremember must one mean --> can delete 0 or 1 character only\\nusing two pointer approach :-\\n-> i--> intial pointer , j--> final pointer\\n-> travese it from end , start both side (i++ , j-- );\\n-> if s[i] == s[j] --> satisfy palindrom condition okk go forward\\n->but if s[i] != s[j] so we can do two thing\\neither remove from left side ( i side deletion ) or righr side (j side deletion)\\n\\n(find useful upvote it vro :) )\\n-> i am choosing left first and right next and use counter( countI and countJ) to know whether i have chance to remove from left /right side or not\\n\\n**note i am not deleting from both side in my deletion condition box there is condition like that only one char is delete\\n\\n--> i use storeI and storeJ to for the remember point that where first inequality come and i was used my deletion power ( delete one character)\\nbecause in testcase like :-\\nif first inequality is come in string i go with \\'i\\' side deletion and it satisfy upto some length but not make my string completly palindromic because \\'j\\' side deletion make complete palindromic to my string so , at that i cann\\'t do \\'j\\' side deletion on present index\\n(it delete two character) i use that index where my first inequality ( or on which i use my i side is required to do it ** we only delete one character max**)\\n\\nso if both possibility fail mean (we check from i ,j side deletion )\\nreturn false otherwise true\\n\\nApproach\\nlinear traversal\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        \\n        int n = s.size();\\n        if( n  ==1)\\n        {\\n             return n;\\n        }\\n\\nint i = 0 , j = n-1;\\n\\nint countI = 0;\\nint countJ= 0;\\nint storeI =0;\\nint storeJ =0;\\n    while( i<=j)\\n    {\\n      \\n      if( s[i]!=s[j])\\n      {\\n          if( !countI)\\n          {\\n              countI=1;\\n              storeI =i;\\n              storeJ =j;\\n              i++;\\n              continue;\\n          }\\n\\n          if(!countJ)\\n          {\\n             i= storeI;\\n             j= storeJ; \\n             countJ =1;\\n             j--;\\n             continue;\\n          }\\n          return 0;\\n      }\\n\\n      i++;\\n      j--;\\n    }\\n\\nreturn true ;\\n    }\\n};"
                    },
                    {
                        "username": "Ardonite",
                        "content": "Hi,\\n\\nhow can expected be \"false\"?\\nIt must be true right?\\n\\nInput\\ns = \"tebbem\"\\n\\nOutput\\ntrue\\n\\nExpected\\nfalse"
                    },
                    {
                        "username": "underprocess",
                        "content": "you must remove t and m to make it palindrome but according to question s can be palindrome after deleting at most one character from it.so false."
                    },
                    {
                        "username": "darkpheonix2_O",
                        "content": "If you are unable to come up with any solution, think it like you skip one character from left and check for valid palindrome, if no solution is found save that index and now skip the right index to check for valid palindrome, it no valid palindrome is found then answer is false else true. Use two pointers left and right to check for valid palindrome."
                    },
                    {
                        "username": "aknownymous",
                        "content": "#### Can Someone tell me, how can I reduce its time complexity? Passes all the case except 402th. \n```\nclass Solution:\n    def pal(self,s):\n        if s==s[::-1]: return True\n        return False\n    def validPalindrome(self, s: str) -> bool:\n        if self.pal(s): return True\n        for i in range(len(s)):\n            c= list(s)\n            c.pop(i)\n            if self.pal(c): return True\n        return False\n```\n\n\n#### Test Case :\n```\n\"okelpsggfffjcbrxksywxjlwkreqaleuozasrpqssrwqnafcpurutghwgovmewwjqyeudyerbvccdbvoomncetrzgowzdmvfzuelummidrncazxgxmlgkutjyfgthpgiirrijsnxgcpvbkshzenutpgiglipedcwcrnspqsqfcfeodkjuhubpzrwfgvflmuexyalmwlitwciaaiqgruwdroxxoditxtpmfdfnkagaukeuyxbkjwkujredeuaidbnhuwrmxmpyeoomrokvmoythkirbjdhaohoxksgsvyvdtylazbryoqtwyytefpsysigwnykbwsjizweemjuuxdjtfautwvuywfhkzlhsbrgsyynvredkrjcducdwppalrdghzjuowbkbgmhwrmfbtqxevdaluwrrtrjltghiytbjugvdrmxlpvpttozlcinzqtrtnscfgkhmmglhzqkpjixxqflmycywxvhhoeeqgdwsvetbphhulczylfiurehhgjhbqqlaytwysupjuallphvvpohovrauewvphmvlcsalvxpvwuzyvjbziwnfyjdtglzzkceiiwbuqjiztidxixkwwyfvpnuucbtestwgchljweklejoxduaxoquvchivjbluxmpcbotwgktupjsfbazaclawkkwmtkigmuraapxufbwwbmqazrinavgiuyalbhifcqpgazrptwfmuvzqekycdujviondufakcnboxrlfnadcbpkwnomwmuwhwmvkrwglaxdvjbymcmpgcqcnelrmzhghndvdfrdfdkozgrzffhuaxghsjoizybbqhoijzgzdmnghaculluotbhtajdagptqmeccnzxvpedjnaydckhejghbuofmkoteoqkxkgtywtftxxptboxhowgknptmfsnvvunwblumqduomxvrmzqbnpnbnmnzuenjujcndsxtvwrcsnhvmmgjnkbdtemhhftpseosvhdxoorncynxkibnaxmufdnounrzbxqzrhgwtzbbzipbqwatzrtnhdbabnoglnrumbbnejduktmsxzuaoxmogrjqlgrbxnwyiqfwvlclqpsljktnjxqtmktdxdhkgbnsagyafukrrlxlkjsiljouzwfwtlodvfzfvdupqydvkufbbeqawqnnorghffoahelzvawxqpykxklzlhccvyepcdygxrpldnwzeqzuyjdkogmgdmfsezwqcrslpbxmnwvjxphcbmshayiodnnxwvahvsyleotqqlhirkjlatjnwmtmmsbkalmvdnupeejrykffsffyytugissgtmnyekjqitjfjncgrezpahvjknlbclkopsjtykfzpqlffvyeblcedfxjpsmdtuerffmaiiphomwkctufxsiauhctxsivqpltobdwybprkhchieimoitrjolnybwgqnmjrpkxazmwcasetwsxgqjlbhefssubuvpharcfxhsyscsriqvkotcackholuhfzradelmacojqbtncjhfwpfqwvbdxjvxomcgjiitstgxlskmzcsvhihwcvoxebboazklzvjbwabahyhmvrbewuxjbznehqrwccovzutpumalkpvaocwryvjyeezttwgithxltruftqkyxyfkgyfguavmmemueluvyfehbocgsekgznivscohwyhjwooegympcpesuujadzpvxbebensajfnnvywngawinqyxbeiuqheklyolibfktbmddllbgtqmgvctgefzjwzfnesltuqzytsfuenjblldtjilahswbwmphmakmeawekkpfoiiaozxspqiknxtxomxiqwuvfoenxemcldulgdttfrdyvoxjrnmbkxguworfgqzsxpijtefgguinlbixctiqcdqjvcnxwljpkfvftcqjdvkkoqvnrdbkhovmpcappqsmwuzrorqyvmusiemqbxjscejthwlycucoccnoewjekchjqxeeaxbyvneivxcdydqamzcvleohgxdzzcyngimxqzdhvllpycnvrvbowtowukelfvjovohtafapdezecrabznzmhmipjcbweqtrikczwqbuciyztrapbekfocryxrwmffphoivpwfiyosxpkyqywkvikzrvfudeoyvyissaubkowuvzpmsopvomseieivziqynovnaeapjfjfhjuzqtebrpqmwegzsvouuwptpqxcylqnabbrgiuvjhjtpqlrcixmcsyekcdxeixycwbocbezpetkqzrwyimikpjziimieyqoessjvqpypdnjpngvbfkifvuqsvcqfkwakdlvxfhneyfanbhqryrcbojqdnbbsadhcfxjmrjqwjjzxtusjqgkywatbrsszogjyreikgjqnucomibvajysnhvtodyxukkrcftiewcvjscmnyyrqkteohffqfehdrtjcaldwcukgnoclqwewabisdwevmynuzwlwikgsjwnmkmalkktmuiohcxyxzuxfogymsnjoefwxzwvaxvjqypzoocnydwggqyswygyajmwjczcrjdijsaoepwoqbekbzmpsdomsbkukirdlpzenohkpfexmahidgdlnvctvsvvcjpakiotoarnvfrpopdecxisdnqcdersoyuxypiicnhxvhvlqgfxlwnecdtfmsvuturggxxstxacnamdboyfoviavuimjnmzumsfmtpilvmzgfukxxwlhcmlyjfcxioderggkknwmilhnwebubywjtzvrfraijkdbafkgqfwooxbfwqknjtejesvqvauclxhoaivqtszuztdagbvxtzocksbbydqezqoghchyfgipfgckihnwvoqqejejfuiiarpkjfqrytxqwvwztwfuldyaxsczdvgoocbbndwndorkgjaqpdxchaspgwoylpclhiuxvjbfzalcyyxucygjwwynvvtklwcenuswoedrcnuwpegdlxtxavapdcwzukycdiqtvxytuuwwgtoljvcgdqqimrtrsdjvopgbyrfqoqeqdvvzqragwdkhbedxczdzgexgxgmbwgznogqnegoesellwuvezjmkujiixvkmsybocnuyomzyvajrgtldkminlbwbfxhbpalhreyuxnvyhumwcpwnscwaudmpzvuujnwiktxbzvczefnpjflaubhokplqmzzjtttdvrbxswmflsaueafokqthikxaogvwcgqhzlkimmwqherzlmnpkxxpfhgblfwpoiwvufkdbtvyixnsorwobajfcivuvcuudfqoroczjqocyevhqwgcjrhpmqlqbaqvdtvyovwnplzjhoylcsqpqqahxybrpzmidrdjrpcxewvsfqnxglpixmiertpjhezdtcgylhbxdcbjiavcsfyataialdjskqhrsqemygllpftrkaezmihzacbhmtbplaiufvodvkxhmyseacqoauufnwkhkmwvbpwheauxneglqdxnzepamermqayfxhpzklgdcsvhljdrphwcrfibblivigzognxoujeijlclqwrertsnrxlsdfuayckuqmcwznegmvwqqvivtwwcyufrlmnjonpfdmgvsflgidthqlxduryswstznfqhsynxzdzytooivftkjhnoebyydlosysfaepooamthyvfuxsikjymiiehavfijncwbqsyooshjhdxqugztfeenzwwtntftkvzqryeqhfnjyaunkzabpqkhkbichdpazhlvurjqbibqkdaouhmpnyfjfguwbvwtbtuhzzvtautrcixwklodvccwyxxwcdsxqgmbpxcsaomciqcgyubrjentajuwfygrucnjhubvtkwqpibxrmgwzcgilurzhbxvybkxyjbmvlfmairsesaydzwufjwbcbqvmuzkqgabteybwzcdtnqpzpngbaypdnzeiiljgcskixqofwkrptvlycvibbijjbdjjsbxihsluofdgzmkordkxsteviyyawtybxuzydoogjrezifywhogedcjmikqbujubpziqywijmbxnfmctlfkfxnrvctqgagsvxhgavgmsmbivnsaoacnjtcgmfpknvebxfxmkaapoczhjhkvyrjsbuwsojhlzagcedhkupyetzhexubqdpwbehgcnoauinbbfmvojmnklrlcbleuortsbjzzqdqwbsdvapqqfqxpetywemvhfffkojcfwfxjfzcgpxopbxcphqpmrrrkaplrmniigdryhifmufddkizgbhbgcxvcntujlwedemcluetinkzltzwjdrvzhelcmdktqpcitislwlkurqrhftqpccimqbcixvacdxdeepfrmuhvezpdgggevullgmvdpgouuxkzdhjewdijboumhmsboxhgzadjtwmeimdnavljnzdocsvcdkroqeulfaubhlcaamalpsukazggtwgpwdeqnpuedwwtjcrjdnokovvvtbjobvmeaqomfidmarizadomwrfedkusktxgbotdikfebmkrosgfpshynksglrtjiawdtidcvblzbewiqftxzyxdknnutfhqvanlscqqdxpjyqczbmzdfxcrctapwxqrokuexlbzmrdisdbzryowqwhzjxntrajzhfrsspiurmwuiarozvojsigivusihnzejxtoaljajmwazmeyoxodtgfnhsawbmbjcptsqwzrrlirrncipztqvkosqcyfyqfvbdnhwlmotffcbxczakkxqaynkemgwvdniaxrkvsskryiphzqpcgbsmixjfbdtxeemtbwydwgywxxofsayqohghjahnbsfwaqpzpbzofokykfcvlelnqhjnkdkvsigffqfebnkfjqumrkxcjlxubcpbpkhzddyhalpqrvjeduxpugfijyfgbzdhqfcwpoixmotpzybhfzgflhtqsublszjpeyagozzlxopflouxprnazfkyyklromjiwqqwijmorlkyykfzanrpxuolfpoxlzzogayepjzslbusqthlfgzfhbyzptomxiopwcfqhdzbgfyjifgupxudejvrqplahyddzhkpbpcbuxljcxkrmuqjfknbefqffgisvkdknjhqnlelvcfkykofozbpzpqawfsbnhajhghoqyasfoxxwygwdywbtmeextdbfjximsbgcpqzhpiyrkssvkrxaindvwgmeknyaqxkkazcxbcfftomlwhndbvfqyfycqsokvqtzpicnrrilrrzwqstpcjbmbwashnfgtdoxoyemzawmjajlaotxjeznhisuvigisjovzoraiuwmruipssrfhzjartnxjzhwqwoyrzbdsidrmzblxeukorqxwpatcrcxfdzmbzcqyjpxdqqcslnavqhftunnkdxyzxtfqiwebzlbvcditdwaijtrlgsknyhspfgsorkmbefkidtobgxtksukdefrwmodaziramdifmoqaemvbojbtvvvokondjrcjtwwdeupnqedwpgwtggzakusplamaaclhbuaflueqorkdcvscodznjlvandmiemwtjdazghxobsmhmuobjidwejhdzkxuuogpdvmglluvegggdpzevhumrfpeedxdcavxicbqmiccpqtfhrqruklwlsiticpqtkdmclehzvrdjwztlzkniteulcmedewljutncvxcgbhbgzikddfumfihyrdgiinmrlpakrrrmpqhpcxbpoxpgczfjxfwfcjokfffhvmewytepxqfqqpavdsbwqdqzzjbstrouelbclrlknmjovmfbbniuaoncghebwpdqbuxehzteypukhdecgazlhjoswubsjryvkhjhzcopaakmxfxbevnkpfmgctjncaoasnvibmsmgvaghxvsgagqtcvrnxfkfltcmfnxbmjiwyqizpbujubqkimjcdegohwyfizerjgoodyzuxbytwayyivetsxkdrokmzgdfoulshixbsjjdbjjibbivcylvtprkwfoqxikscgjliiezndpyabgnpzpqntdczwbyetbagqkzumvqbcbwjfuwzdyasesriamflvmbjyxkbyvxbhzruligczwgmrxbipqwktvbuhjncurgyfwujatnejrbuygcqicmoascxpbmgqxsdcwxxywccvdolkwxicrtuatvzzhutbtwvbwugfjfynpmhuoadkqbibqjruvlhzapdhcibkhkqpbazknuayjnfhqeyrqzvktftntwwzneeftzguqxdhjhsooysqbwcnjifvaheiimyjkisxufvyhtmaoopeafsysoldyybeonhjktfviootyzdzxnyshqfnztswsyrudxlqhtdiglfsvgmdfpnojnmlrfuycwwtvivqqwvmgenzwcmqukcyaufdslxrnstrerwqlcljiejuoxngozgivilbbifrcwhprdjlhvscdglkzphxfyaqmremapeznxdqlgenxuaehwpbvwmkhkwnfuuaoqcaesymhxkvdovfuialpbtmhbcazhimzeakrtfpllgymeqsrhqksjdlaiatayfscvaijbcdxbhlygctdzehjptreimxiplgxnqfsvwexcprjdrdimzprbyxhaqqpqsclyohjzlpnwvoyvtdvqabqlqmphrjcgwqhveycoqjzcoroqfduucvuvicfjabowrosnxiyvtbdkfuvwiopwflbghfpxxkpnmlzrehqwmmiklzhqgcwvgoaxkihtqkofaeuaslfmwsxbrvdtttjzzmqlpkohbualfjpnfezcvzbxtkiwnjuuvzpmduawcsnwpcwmuhyvnxuyerhlapbhxfbwblnimkdltgrjavyzmoyuncobysmkvxiijukmjzevuwlleseogenqgonzgwbmgxgxegzdzcxdebhkdwgarqzvvdqeqoqfrybgpovjdsrtrmiqqdgcvjlotgwwuutyxvtqidcykuzwcdpavaxtxldgepwuncrdeowsunecwlktvvnywwjgycuxyyclazfbjvxuihlcplyowgpsahcxdpqajgkrodnwdnbbcoogvdzcsxaydlufwtzwvwqxtyrqfjkpraiiufjejeqqovwnhikcgfpigfyhchgoqzeqdybbskcoztxvbgadtzuzstqviaohxlcuavqvsejetjnkqwfbxoowfqgkfabdkjiarfrvztjwybubewnhlimwnkkggredoixcfjylmchlwxxkufgzmvliptmfsmuzmnjmiuvaivofyobdmancaxtsxxggrutuvsmftdcenwlxfgqlvhvxhnciipyxuyosredcqndsixcedpoprfvnraotoikapjcvvsvtcvnldgdihamxefpkhonezpldrikukbsmodspmzbkebqowpeoasjidjrczcjwmjaygywsyqggwdyncoozpyqjvxavwzxwfeojnsmygofxuzxyxchoiumtkklamkmnwjsgkiwlwzunymvewdsibawewqlcongkucwdlacjtrdhefqffhoetkqryynmcsjvcweitfcrkkuxydotvhnsyjavbimocunqjgkieryjgozssrbtawykgqjsutxzjjwqjrmjxfchdasbbndqjobcryrqhbnafyenhfxvldkawkfqcvsquvfikfbvgnpjndpypqvjsseoqyeimiizjpkimiywrzqktepzebcobwcyxiexdckeyscmxicrlqptjhjvuigrbbanqlycxqptpwuuovszgewmqprbetqzujhfjfjpaeanvonyqizvieiesmovposmpzvuwokbuassiyvyoedufvrzkivkwyqykpxsoyifwpviohpffmwrxyrcofkebpartzyicubqwzckirtqewbcjpimhmznzbarcezedpafathovojvflekuwotwobvrvncypllvhdzqxmignyczzdxghoelvczmaqdydcxvienvybxaeexqjhckejweonccocucylwhtjecsjxbqmeisumvyqrorzuwmsqppacpmvohkbdrnvqokkvdjqctfvfkpjlwxncvjqdcqitcxiblniuggfetjipxszqgfrowugxkbmnrjxovydrfttdgludlcmexneofvuwqixmoxtxnkiqpsxzoaiiofpkkewaemkamhpmwbwshalijtdllbjneufstyzqutlsenfzwjzfegtcvgmqtgbllddmbtkfbiloylkehquiebxyqniwagnwyvnnfjasnebebxvpzdajuusepcpmygeoowjhywhocsvinzgkesgcobhefyvuleumemmvaugfygkfyxykqtfurtlxhtigwttzeeyjvyrwcoavpklamuptuzvoccwrqhenzbjxuwebrvmhyhabawbjvzlkzaobbexovcwhihvsczmkslxgtstiijgcmoxvjxdbvwqfpwfhjcntbqjocamledarzfhulohkcactokvqirscsyshxfcrahpvubussfehbljqgxswtesacwmzaxkprjmnqgwbynlojrtiomieihchkrpbywdbotlpqvisxtchuaisxfutckwmohpiiamffreutdmspjxfdeclbeyvfflqpzfkytjspoklcblnkjvhapzergcnjfjtiqjkeynmtgssigutyyffsffkyrjeepundvmlakbsmmtmwnjtaljkrihlqqtoelysvhavwxnndoiyahsmbchpxjvwnmxbplsrcqwzesfmdgmgokdjyuzqezwndlprxgydcpeyvcchlzlkxkypqxwavzlehaoffhgronnqwaqebbfukvdyqpudvfzfvdoltwfwzuojlisjklxlrrkufaygasnbgkhdxdtkmtqxjntkjlspqlclvwfqiywnxbrglqjrgomxoauzxsmtkudjenbbmurnlgonbabdhntrztawqbpizbbztwghrzqxbzrnuondfumxanbikxnycnrooxdhvsoesptfhhmetdbknjgmmvhnscrwvtxsdncjujneuznmnbnpnbqzmrvxmoudqmulbwnuvvnsfmtpnkgwohxobtpxxtftwytgkxkqoetokmfoubhgjehkcdyanjdepvxznccemqtpgadjathbtoullucahgnmdzgzjiohqbbyziojshgxauhffzrgzokdfdrfdvdnhghzmrlencqcgpmcmybjvdxalgwrkvmwhwumwmonwkpbcdanflrxobnckafudnoivjudcykeqzvumfwtprzagpqcfihblayuigvanirzaqmbwwbfuxpaarumgiktmwkkwalcazabfsjputkgwtobcpmxulbjvihcvuqoxaudxojelkewjlhcgwtsetbcuunpvfywwkxixditzijqubwiieckzzlgtdjyfnwizbjvyzuwvpxvlasclvmhpvweuarvohopvvhpllaujpusywtyalqqbhjghheruiflyzcluhhpbtevswdgqeeohhvxwycymlfqxxijpkqzhlgmmhkgfcsntrtqzniclzottpvplxmrdvgujbtyihgtljrtrrwuladvexqtbfmrwhmgbkbwoujzhgdrlappwdcudcjrkdervnyysgrbshlzkhfwyuvwtuaftjdxuujmeewzijswbkynwgisyspfetyywtqoyrbzalytdvyvsgskxohoahdjbrikhtyomvkormooeypmxmrwuhnbdiauederjukwjkbxyuekuagaknfdfmptxtidoxxordwurgqiaaicwtilwmlayxeumlfvgfwrzpbuhujkdoefcfqsqpsnrcwcdepilgigptunezhskbvpcgxnsjirriigphtgfyjtukglmxgxzacnrdimmuleuzfvmdzwogzrtecnmoovbdccvbreydueyqjwwemvogwhgturupcfanqwrssqprsazouelaqerkwljxwyskxrbcjfffggsplekod\"\n```"
                    }
                ]
            },
            {
                "id": 1926291,
                "content": [
                    {
                        "username": "aiswaryaa",
                        "content": "give tip"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "start checking form start and end index,,,whenever it hits that (start!=end) ,then pass it to another function which will check the reamin string is palindrome or not ,if its true return true ,otherwise false...  \n\n    NOTE: in the second function call u must have check two condition ,\n1st increase the starting index by one and check but the end index remains same (in this casse it  will ignore the 1st character from starting index) \n\nand 2nd one is: increase the end index by one, here start will be same (thus it willl check after ignoring the last index) and u have to check both the conditions ,to cover all the edge cases...\n"
                    },
                    {
                        "username": "varsha1531",
                        "content": "bool validPalindrome(string s) {\n      \n      int c=0;\n      int j=s.length()-1,i=0;\n      while(i<=j)\n      {\n          if(s[i]==s[j])\n          {\n              j--;\n              i++;\n          }\n          else \n          {\n              if(s[i]==s[j-1] )\n              {\n                  j=j-2;\n                  c++;\n                  i++;\n              }\n              else if(s[i+1]==s[j])\n              {\n                  i=i+2;\n                  c++;\n                  j--;\n              }\n              else{\n                  return false;\n              }\n          }\n          \n      }\n      \nreturn c<=1;\n     \n    } \nplz help me where am i going wrong\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": " `Consider this - ebcbbececabbacecbbcbe`\n \nI can't figure out why the LeetCode compiler refuses to accept my solution for \"ebcbbececabbacecbbcbe\" specific given input  [the input String isn't a palindrome at all ] . Can anyone lend a hand? Any insights or suggestions to resolve this compiler error would be greatly appreciated. Help me crack this puzzle.........\n"
                    },
                    {
                        "username": "vedranson",
                        "content": "First and last 5 chars: \\'ebcbb [...] bbcbe\\' make a valid palindrome. The rest is now \\'ececabbacec\\'. If you were to delete/ignore the leading \\'e\\', the rest \\'cecabbacec\\' is a valid palindrome."
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me figure out why my code is showing incorrect output for this string \"lfhnzyffurnskdlduhopgrssphgnbaxtuzmlwsxzamjtdqymgmmmmgmyxqdtjmazxwlmzutxabnghpssrgpohudldksnruffyznhfl\"\\nMy code is showing true but expected output is false. Can someone help me figure out what is wrong in my code \\n```class Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        int flag = 0;\\n        char uh;\\n        while(i<j)\\n        {\\n          while(!isalnum(s[i]))\\n          {\\n              i++;\\n          }\\n          while(!isalnum(s[j]))\\n          {\\n              j--;\\n          }\\n\\n          if(!(s[i]==s[j]) && flag==0)\\n          {\\n            flag =1;\\n            if (s[i + 1] == s[j])\\n            {\\n                i++;\\n                uh = s[i];\\n            }\\n\\n            else if (s[i] == s[j - 1])\\n            {\\n                uh = s[j];\\n                j--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n          }\\n          \\n          else if(!(s[i]==s[j]) && flag==1)\\n          {\\n              if((s[i]==uh || s[j]==uh))\\n              {\\n                if (s[i] == uh)\\n                    i++;\\n                else if (s[j] == uh)\\n                    j--;\\n              }\\n              else\\n              {\\n                  return false;\\n              }\\n          }\\n          else\\n          {\\n             i++;\\n             j--;\\n          }\\n        }\\n        return true;\\n    }\\n};```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Got it, I was removing all occurrences of the character"
                    },
                    {
                        "username": "10xvishal",
                        "content": "\"woicvixviciow\" why is this supposed to be false, after neglecting i its a valid palindrome \"wocvxvcow\""
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "you have to remove just 1 char in your input to make it a valid palindrome"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "seems that a testcase \"tebbem\" expects `false`. is \"ebbe\" not a valid palindrome? [@LeetCode](/LeetCode) ?"
                    },
                    {
                        "username": "10xvishal",
                        "content": "you will only get \"tebbe\" or \"ebbem\" after removing single char."
                    },
                    {
                        "username": "ankush920",
                        "content": "FULL EXPLAINED ||CODE || C++ ||0(N)\\nankush920\\n0\\nin a minute\\nIntuition\\nokk sit relax don\\'t frustate it\\'s easy but slightly different .\\n\\nremember must one mean --> can delete 0 or 1 character only\\nusing two pointer approach :-\\n-> i--> intial pointer , j--> final pointer\\n-> travese it from end , start both side (i++ , j-- );\\n-> if s[i] == s[j] --> satisfy palindrom condition okk go forward\\n->but if s[i] != s[j] so we can do two thing\\neither remove from left side ( i side deletion ) or righr side (j side deletion)\\n\\n(find useful upvote it vro :) )\\n-> i am choosing left first and right next and use counter( countI and countJ) to know whether i have chance to remove from left /right side or not\\n\\n**note i am not deleting from both side in my deletion condition box there is condition like that only one char is delete\\n\\n--> i use storeI and storeJ to for the remember point that where first inequality come and i was used my deletion power ( delete one character)\\nbecause in testcase like :-\\nif first inequality is come in string i go with \\'i\\' side deletion and it satisfy upto some length but not make my string completly palindromic because \\'j\\' side deletion make complete palindromic to my string so , at that i cann\\'t do \\'j\\' side deletion on present index\\n(it delete two character) i use that index where my first inequality ( or on which i use my i side is required to do it ** we only delete one character max**)\\n\\nso if both possibility fail mean (we check from i ,j side deletion )\\nreturn false otherwise true\\n\\nApproach\\nlinear traversal\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        \\n        int n = s.size();\\n        if( n  ==1)\\n        {\\n             return n;\\n        }\\n\\nint i = 0 , j = n-1;\\n\\nint countI = 0;\\nint countJ= 0;\\nint storeI =0;\\nint storeJ =0;\\n    while( i<=j)\\n    {\\n      \\n      if( s[i]!=s[j])\\n      {\\n          if( !countI)\\n          {\\n              countI=1;\\n              storeI =i;\\n              storeJ =j;\\n              i++;\\n              continue;\\n          }\\n\\n          if(!countJ)\\n          {\\n             i= storeI;\\n             j= storeJ; \\n             countJ =1;\\n             j--;\\n             continue;\\n          }\\n          return 0;\\n      }\\n\\n      i++;\\n      j--;\\n    }\\n\\nreturn true ;\\n    }\\n};"
                    },
                    {
                        "username": "Ardonite",
                        "content": "Hi,\\n\\nhow can expected be \"false\"?\\nIt must be true right?\\n\\nInput\\ns = \"tebbem\"\\n\\nOutput\\ntrue\\n\\nExpected\\nfalse"
                    },
                    {
                        "username": "underprocess",
                        "content": "you must remove t and m to make it palindrome but according to question s can be palindrome after deleting at most one character from it.so false."
                    },
                    {
                        "username": "darkpheonix2_O",
                        "content": "If you are unable to come up with any solution, think it like you skip one character from left and check for valid palindrome, if no solution is found save that index and now skip the right index to check for valid palindrome, it no valid palindrome is found then answer is false else true. Use two pointers left and right to check for valid palindrome."
                    },
                    {
                        "username": "aknownymous",
                        "content": "#### Can Someone tell me, how can I reduce its time complexity? Passes all the case except 402th. \n```\nclass Solution:\n    def pal(self,s):\n        if s==s[::-1]: return True\n        return False\n    def validPalindrome(self, s: str) -> bool:\n        if self.pal(s): return True\n        for i in range(len(s)):\n            c= list(s)\n            c.pop(i)\n            if self.pal(c): return True\n        return False\n```\n\n\n#### Test Case :\n```\n\"okelpsggfffjcbrxksywxjlwkreqaleuozasrpqssrwqnafcpurutghwgovmewwjqyeudyerbvccdbvoomncetrzgowzdmvfzuelummidrncazxgxmlgkutjyfgthpgiirrijsnxgcpvbkshzenutpgiglipedcwcrnspqsqfcfeodkjuhubpzrwfgvflmuexyalmwlitwciaaiqgruwdroxxoditxtpmfdfnkagaukeuyxbkjwkujredeuaidbnhuwrmxmpyeoomrokvmoythkirbjdhaohoxksgsvyvdtylazbryoqtwyytefpsysigwnykbwsjizweemjuuxdjtfautwvuywfhkzlhsbrgsyynvredkrjcducdwppalrdghzjuowbkbgmhwrmfbtqxevdaluwrrtrjltghiytbjugvdrmxlpvpttozlcinzqtrtnscfgkhmmglhzqkpjixxqflmycywxvhhoeeqgdwsvetbphhulczylfiurehhgjhbqqlaytwysupjuallphvvpohovrauewvphmvlcsalvxpvwuzyvjbziwnfyjdtglzzkceiiwbuqjiztidxixkwwyfvpnuucbtestwgchljweklejoxduaxoquvchivjbluxmpcbotwgktupjsfbazaclawkkwmtkigmuraapxufbwwbmqazrinavgiuyalbhifcqpgazrptwfmuvzqekycdujviondufakcnboxrlfnadcbpkwnomwmuwhwmvkrwglaxdvjbymcmpgcqcnelrmzhghndvdfrdfdkozgrzffhuaxghsjoizybbqhoijzgzdmnghaculluotbhtajdagptqmeccnzxvpedjnaydckhejghbuofmkoteoqkxkgtywtftxxptboxhowgknptmfsnvvunwblumqduomxvrmzqbnpnbnmnzuenjujcndsxtvwrcsnhvmmgjnkbdtemhhftpseosvhdxoorncynxkibnaxmufdnounrzbxqzrhgwtzbbzipbqwatzrtnhdbabnoglnrumbbnejduktmsxzuaoxmogrjqlgrbxnwyiqfwvlclqpsljktnjxqtmktdxdhkgbnsagyafukrrlxlkjsiljouzwfwtlodvfzfvdupqydvkufbbeqawqnnorghffoahelzvawxqpykxklzlhccvyepcdygxrpldnwzeqzuyjdkogmgdmfsezwqcrslpbxmnwvjxphcbmshayiodnnxwvahvsyleotqqlhirkjlatjnwmtmmsbkalmvdnupeejrykffsffyytugissgtmnyekjqitjfjncgrezpahvjknlbclkopsjtykfzpqlffvyeblcedfxjpsmdtuerffmaiiphomwkctufxsiauhctxsivqpltobdwybprkhchieimoitrjolnybwgqnmjrpkxazmwcasetwsxgqjlbhefssubuvpharcfxhsyscsriqvkotcackholuhfzradelmacojqbtncjhfwpfqwvbdxjvxomcgjiitstgxlskmzcsvhihwcvoxebboazklzvjbwabahyhmvrbewuxjbznehqrwccovzutpumalkpvaocwryvjyeezttwgithxltruftqkyxyfkgyfguavmmemueluvyfehbocgsekgznivscohwyhjwooegympcpesuujadzpvxbebensajfnnvywngawinqyxbeiuqheklyolibfktbmddllbgtqmgvctgefzjwzfnesltuqzytsfuenjblldtjilahswbwmphmakmeawekkpfoiiaozxspqiknxtxomxiqwuvfoenxemcldulgdttfrdyvoxjrnmbkxguworfgqzsxpijtefgguinlbixctiqcdqjvcnxwljpkfvftcqjdvkkoqvnrdbkhovmpcappqsmwuzrorqyvmusiemqbxjscejthwlycucoccnoewjekchjqxeeaxbyvneivxcdydqamzcvleohgxdzzcyngimxqzdhvllpycnvrvbowtowukelfvjovohtafapdezecrabznzmhmipjcbweqtrikczwqbuciyztrapbekfocryxrwmffphoivpwfiyosxpkyqywkvikzrvfudeoyvyissaubkowuvzpmsopvomseieivziqynovnaeapjfjfhjuzqtebrpqmwegzsvouuwptpqxcylqnabbrgiuvjhjtpqlrcixmcsyekcdxeixycwbocbezpetkqzrwyimikpjziimieyqoessjvqpypdnjpngvbfkifvuqsvcqfkwakdlvxfhneyfanbhqryrcbojqdnbbsadhcfxjmrjqwjjzxtusjqgkywatbrsszogjyreikgjqnucomibvajysnhvtodyxukkrcftiewcvjscmnyyrqkteohffqfehdrtjcaldwcukgnoclqwewabisdwevmynuzwlwikgsjwnmkmalkktmuiohcxyxzuxfogymsnjoefwxzwvaxvjqypzoocnydwggqyswygyajmwjczcrjdijsaoepwoqbekbzmpsdomsbkukirdlpzenohkpfexmahidgdlnvctvsvvcjpakiotoarnvfrpopdecxisdnqcdersoyuxypiicnhxvhvlqgfxlwnecdtfmsvuturggxxstxacnamdboyfoviavuimjnmzumsfmtpilvmzgfukxxwlhcmlyjfcxioderggkknwmilhnwebubywjtzvrfraijkdbafkgqfwooxbfwqknjtejesvqvauclxhoaivqtszuztdagbvxtzocksbbydqezqoghchyfgipfgckihnwvoqqejejfuiiarpkjfqrytxqwvwztwfuldyaxsczdvgoocbbndwndorkgjaqpdxchaspgwoylpclhiuxvjbfzalcyyxucygjwwynvvtklwcenuswoedrcnuwpegdlxtxavapdcwzukycdiqtvxytuuwwgtoljvcgdqqimrtrsdjvopgbyrfqoqeqdvvzqragwdkhbedxczdzgexgxgmbwgznogqnegoesellwuvezjmkujiixvkmsybocnuyomzyvajrgtldkminlbwbfxhbpalhreyuxnvyhumwcpwnscwaudmpzvuujnwiktxbzvczefnpjflaubhokplqmzzjtttdvrbxswmflsaueafokqthikxaogvwcgqhzlkimmwqherzlmnpkxxpfhgblfwpoiwvufkdbtvyixnsorwobajfcivuvcuudfqoroczjqocyevhqwgcjrhpmqlqbaqvdtvyovwnplzjhoylcsqpqqahxybrpzmidrdjrpcxewvsfqnxglpixmiertpjhezdtcgylhbxdcbjiavcsfyataialdjskqhrsqemygllpftrkaezmihzacbhmtbplaiufvodvkxhmyseacqoauufnwkhkmwvbpwheauxneglqdxnzepamermqayfxhpzklgdcsvhljdrphwcrfibblivigzognxoujeijlclqwrertsnrxlsdfuayckuqmcwznegmvwqqvivtwwcyufrlmnjonpfdmgvsflgidthqlxduryswstznfqhsynxzdzytooivftkjhnoebyydlosysfaepooamthyvfuxsikjymiiehavfijncwbqsyooshjhdxqugztfeenzwwtntftkvzqryeqhfnjyaunkzabpqkhkbichdpazhlvurjqbibqkdaouhmpnyfjfguwbvwtbtuhzzvtautrcixwklodvccwyxxwcdsxqgmbpxcsaomciqcgyubrjentajuwfygrucnjhubvtkwqpibxrmgwzcgilurzhbxvybkxyjbmvlfmairsesaydzwufjwbcbqvmuzkqgabteybwzcdtnqpzpngbaypdnzeiiljgcskixqofwkrptvlycvibbijjbdjjsbxihsluofdgzmkordkxsteviyyawtybxuzydoogjrezifywhogedcjmikqbujubpziqywijmbxnfmctlfkfxnrvctqgagsvxhgavgmsmbivnsaoacnjtcgmfpknvebxfxmkaapoczhjhkvyrjsbuwsojhlzagcedhkupyetzhexubqdpwbehgcnoauinbbfmvojmnklrlcbleuortsbjzzqdqwbsdvapqqfqxpetywemvhfffkojcfwfxjfzcgpxopbxcphqpmrrrkaplrmniigdryhifmufddkizgbhbgcxvcntujlwedemcluetinkzltzwjdrvzhelcmdktqpcitislwlkurqrhftqpccimqbcixvacdxdeepfrmuhvezpdgggevullgmvdpgouuxkzdhjewdijboumhmsboxhgzadjtwmeimdnavljnzdocsvcdkroqeulfaubhlcaamalpsukazggtwgpwdeqnpuedwwtjcrjdnokovvvtbjobvmeaqomfidmarizadomwrfedkusktxgbotdikfebmkrosgfpshynksglrtjiawdtidcvblzbewiqftxzyxdknnutfhqvanlscqqdxpjyqczbmzdfxcrctapwxqrokuexlbzmrdisdbzryowqwhzjxntrajzhfrsspiurmwuiarozvojsigivusihnzejxtoaljajmwazmeyoxodtgfnhsawbmbjcptsqwzrrlirrncipztqvkosqcyfyqfvbdnhwlmotffcbxczakkxqaynkemgwvdniaxrkvsskryiphzqpcgbsmixjfbdtxeemtbwydwgywxxofsayqohghjahnbsfwaqpzpbzofokykfcvlelnqhjnkdkvsigffqfebnkfjqumrkxcjlxubcpbpkhzddyhalpqrvjeduxpugfijyfgbzdhqfcwpoixmotpzybhfzgflhtqsublszjpeyagozzlxopflouxprnazfkyyklromjiwqqwijmorlkyykfzanrpxuolfpoxlzzogayepjzslbusqthlfgzfhbyzptomxiopwcfqhdzbgfyjifgupxudejvrqplahyddzhkpbpcbuxljcxkrmuqjfknbefqffgisvkdknjhqnlelvcfkykofozbpzpqawfsbnhajhghoqyasfoxxwygwdywbtmeextdbfjximsbgcpqzhpiyrkssvkrxaindvwgmeknyaqxkkazcxbcfftomlwhndbvfqyfycqsokvqtzpicnrrilrrzwqstpcjbmbwashnfgtdoxoyemzawmjajlaotxjeznhisuvigisjovzoraiuwmruipssrfhzjartnxjzhwqwoyrzbdsidrmzblxeukorqxwpatcrcxfdzmbzcqyjpxdqqcslnavqhftunnkdxyzxtfqiwebzlbvcditdwaijtrlgsknyhspfgsorkmbefkidtobgxtksukdefrwmodaziramdifmoqaemvbojbtvvvokondjrcjtwwdeupnqedwpgwtggzakusplamaaclhbuaflueqorkdcvscodznjlvandmiemwtjdazghxobsmhmuobjidwejhdzkxuuogpdvmglluvegggdpzevhumrfpeedxdcavxicbqmiccpqtfhrqruklwlsiticpqtkdmclehzvrdjwztlzkniteulcmedewljutncvxcgbhbgzikddfumfihyrdgiinmrlpakrrrmpqhpcxbpoxpgczfjxfwfcjokfffhvmewytepxqfqqpavdsbwqdqzzjbstrouelbclrlknmjovmfbbniuaoncghebwpdqbuxehzteypukhdecgazlhjoswubsjryvkhjhzcopaakmxfxbevnkpfmgctjncaoasnvibmsmgvaghxvsgagqtcvrnxfkfltcmfnxbmjiwyqizpbujubqkimjcdegohwyfizerjgoodyzuxbytwayyivetsxkdrokmzgdfoulshixbsjjdbjjibbivcylvtprkwfoqxikscgjliiezndpyabgnpzpqntdczwbyetbagqkzumvqbcbwjfuwzdyasesriamflvmbjyxkbyvxbhzruligczwgmrxbipqwktvbuhjncurgyfwujatnejrbuygcqicmoascxpbmgqxsdcwxxywccvdolkwxicrtuatvzzhutbtwvbwugfjfynpmhuoadkqbibqjruvlhzapdhcibkhkqpbazknuayjnfhqeyrqzvktftntwwzneeftzguqxdhjhsooysqbwcnjifvaheiimyjkisxufvyhtmaoopeafsysoldyybeonhjktfviootyzdzxnyshqfnztswsyrudxlqhtdiglfsvgmdfpnojnmlrfuycwwtvivqqwvmgenzwcmqukcyaufdslxrnstrerwqlcljiejuoxngozgivilbbifrcwhprdjlhvscdglkzphxfyaqmremapeznxdqlgenxuaehwpbvwmkhkwnfuuaoqcaesymhxkvdovfuialpbtmhbcazhimzeakrtfpllgymeqsrhqksjdlaiatayfscvaijbcdxbhlygctdzehjptreimxiplgxnqfsvwexcprjdrdimzprbyxhaqqpqsclyohjzlpnwvoyvtdvqabqlqmphrjcgwqhveycoqjzcoroqfduucvuvicfjabowrosnxiyvtbdkfuvwiopwflbghfpxxkpnmlzrehqwmmiklzhqgcwvgoaxkihtqkofaeuaslfmwsxbrvdtttjzzmqlpkohbualfjpnfezcvzbxtkiwnjuuvzpmduawcsnwpcwmuhyvnxuyerhlapbhxfbwblnimkdltgrjavyzmoyuncobysmkvxiijukmjzevuwlleseogenqgonzgwbmgxgxegzdzcxdebhkdwgarqzvvdqeqoqfrybgpovjdsrtrmiqqdgcvjlotgwwuutyxvtqidcykuzwcdpavaxtxldgepwuncrdeowsunecwlktvvnywwjgycuxyyclazfbjvxuihlcplyowgpsahcxdpqajgkrodnwdnbbcoogvdzcsxaydlufwtzwvwqxtyrqfjkpraiiufjejeqqovwnhikcgfpigfyhchgoqzeqdybbskcoztxvbgadtzuzstqviaohxlcuavqvsejetjnkqwfbxoowfqgkfabdkjiarfrvztjwybubewnhlimwnkkggredoixcfjylmchlwxxkufgzmvliptmfsmuzmnjmiuvaivofyobdmancaxtsxxggrutuvsmftdcenwlxfgqlvhvxhnciipyxuyosredcqndsixcedpoprfvnraotoikapjcvvsvtcvnldgdihamxefpkhonezpldrikukbsmodspmzbkebqowpeoasjidjrczcjwmjaygywsyqggwdyncoozpyqjvxavwzxwfeojnsmygofxuzxyxchoiumtkklamkmnwjsgkiwlwzunymvewdsibawewqlcongkucwdlacjtrdhefqffhoetkqryynmcsjvcweitfcrkkuxydotvhnsyjavbimocunqjgkieryjgozssrbtawykgqjsutxzjjwqjrmjxfchdasbbndqjobcryrqhbnafyenhfxvldkawkfqcvsquvfikfbvgnpjndpypqvjsseoqyeimiizjpkimiywrzqktepzebcobwcyxiexdckeyscmxicrlqptjhjvuigrbbanqlycxqptpwuuovszgewmqprbetqzujhfjfjpaeanvonyqizvieiesmovposmpzvuwokbuassiyvyoedufvrzkivkwyqykpxsoyifwpviohpffmwrxyrcofkebpartzyicubqwzckirtqewbcjpimhmznzbarcezedpafathovojvflekuwotwobvrvncypllvhdzqxmignyczzdxghoelvczmaqdydcxvienvybxaeexqjhckejweonccocucylwhtjecsjxbqmeisumvyqrorzuwmsqppacpmvohkbdrnvqokkvdjqctfvfkpjlwxncvjqdcqitcxiblniuggfetjipxszqgfrowugxkbmnrjxovydrfttdgludlcmexneofvuwqixmoxtxnkiqpsxzoaiiofpkkewaemkamhpmwbwshalijtdllbjneufstyzqutlsenfzwjzfegtcvgmqtgbllddmbtkfbiloylkehquiebxyqniwagnwyvnnfjasnebebxvpzdajuusepcpmygeoowjhywhocsvinzgkesgcobhefyvuleumemmvaugfygkfyxykqtfurtlxhtigwttzeeyjvyrwcoavpklamuptuzvoccwrqhenzbjxuwebrvmhyhabawbjvzlkzaobbexovcwhihvsczmkslxgtstiijgcmoxvjxdbvwqfpwfhjcntbqjocamledarzfhulohkcactokvqirscsyshxfcrahpvubussfehbljqgxswtesacwmzaxkprjmnqgwbynlojrtiomieihchkrpbywdbotlpqvisxtchuaisxfutckwmohpiiamffreutdmspjxfdeclbeyvfflqpzfkytjspoklcblnkjvhapzergcnjfjtiqjkeynmtgssigutyyffsffkyrjeepundvmlakbsmmtmwnjtaljkrihlqqtoelysvhavwxnndoiyahsmbchpxjvwnmxbplsrcqwzesfmdgmgokdjyuzqezwndlprxgydcpeyvcchlzlkxkypqxwavzlehaoffhgronnqwaqebbfukvdyqpudvfzfvdoltwfwzuojlisjklxlrrkufaygasnbgkhdxdtkmtqxjntkjlspqlclvwfqiywnxbrglqjrgomxoauzxsmtkudjenbbmurnlgonbabdhntrztawqbpizbbztwghrzqxbzrnuondfumxanbikxnycnrooxdhvsoesptfhhmetdbknjgmmvhnscrwvtxsdncjujneuznmnbnpnbqzmrvxmoudqmulbwnuvvnsfmtpnkgwohxobtpxxtftwytgkxkqoetokmfoubhgjehkcdyanjdepvxznccemqtpgadjathbtoullucahgnmdzgzjiohqbbyziojshgxauhffzrgzokdfdrfdvdnhghzmrlencqcgpmcmybjvdxalgwrkvmwhwumwmonwkpbcdanflrxobnckafudnoivjudcykeqzvumfwtprzagpqcfihblayuigvanirzaqmbwwbfuxpaarumgiktmwkkwalcazabfsjputkgwtobcpmxulbjvihcvuqoxaudxojelkewjlhcgwtsetbcuunpvfywwkxixditzijqubwiieckzzlgtdjyfnwizbjvyzuwvpxvlasclvmhpvweuarvohopvvhpllaujpusywtyalqqbhjghheruiflyzcluhhpbtevswdgqeeohhvxwycymlfqxxijpkqzhlgmmhkgfcsntrtqzniclzottpvplxmrdvgujbtyihgtljrtrrwuladvexqtbfmrwhmgbkbwoujzhgdrlappwdcudcjrkdervnyysgrbshlzkhfwyuvwtuaftjdxuujmeewzijswbkynwgisyspfetyywtqoyrbzalytdvyvsgskxohoahdjbrikhtyomvkormooeypmxmrwuhnbdiauederjukwjkbxyuekuagaknfdfmptxtidoxxordwurgqiaaicwtilwmlayxeumlfvgfwrzpbuhujkdoefcfqsqpsnrcwcdepilgigptunezhskbvpcgxnsjirriigphtgfyjtukglmxgxzacnrdimmuleuzfvmdzwogzrtecnmoovbdccvbreydueyqjwwemvogwhgturupcfanqwrssqprsazouelaqerkwljxwyskxrbcjfffggsplekod\"\n```"
                    }
                ]
            },
            {
                "id": 1914253,
                "content": [
                    {
                        "username": "aiswaryaa",
                        "content": "give tip"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "start checking form start and end index,,,whenever it hits that (start!=end) ,then pass it to another function which will check the reamin string is palindrome or not ,if its true return true ,otherwise false...  \n\n    NOTE: in the second function call u must have check two condition ,\n1st increase the starting index by one and check but the end index remains same (in this casse it  will ignore the 1st character from starting index) \n\nand 2nd one is: increase the end index by one, here start will be same (thus it willl check after ignoring the last index) and u have to check both the conditions ,to cover all the edge cases...\n"
                    },
                    {
                        "username": "varsha1531",
                        "content": "bool validPalindrome(string s) {\n      \n      int c=0;\n      int j=s.length()-1,i=0;\n      while(i<=j)\n      {\n          if(s[i]==s[j])\n          {\n              j--;\n              i++;\n          }\n          else \n          {\n              if(s[i]==s[j-1] )\n              {\n                  j=j-2;\n                  c++;\n                  i++;\n              }\n              else if(s[i+1]==s[j])\n              {\n                  i=i+2;\n                  c++;\n                  j--;\n              }\n              else{\n                  return false;\n              }\n          }\n          \n      }\n      \nreturn c<=1;\n     \n    } \nplz help me where am i going wrong\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": " `Consider this - ebcbbececabbacecbbcbe`\n \nI can't figure out why the LeetCode compiler refuses to accept my solution for \"ebcbbececabbacecbbcbe\" specific given input  [the input String isn't a palindrome at all ] . Can anyone lend a hand? Any insights or suggestions to resolve this compiler error would be greatly appreciated. Help me crack this puzzle.........\n"
                    },
                    {
                        "username": "vedranson",
                        "content": "First and last 5 chars: \\'ebcbb [...] bbcbe\\' make a valid palindrome. The rest is now \\'ececabbacec\\'. If you were to delete/ignore the leading \\'e\\', the rest \\'cecabbacec\\' is a valid palindrome."
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me figure out why my code is showing incorrect output for this string \"lfhnzyffurnskdlduhopgrssphgnbaxtuzmlwsxzamjtdqymgmmmmgmyxqdtjmazxwlmzutxabnghpssrgpohudldksnruffyznhfl\"\\nMy code is showing true but expected output is false. Can someone help me figure out what is wrong in my code \\n```class Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        int flag = 0;\\n        char uh;\\n        while(i<j)\\n        {\\n          while(!isalnum(s[i]))\\n          {\\n              i++;\\n          }\\n          while(!isalnum(s[j]))\\n          {\\n              j--;\\n          }\\n\\n          if(!(s[i]==s[j]) && flag==0)\\n          {\\n            flag =1;\\n            if (s[i + 1] == s[j])\\n            {\\n                i++;\\n                uh = s[i];\\n            }\\n\\n            else if (s[i] == s[j - 1])\\n            {\\n                uh = s[j];\\n                j--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n          }\\n          \\n          else if(!(s[i]==s[j]) && flag==1)\\n          {\\n              if((s[i]==uh || s[j]==uh))\\n              {\\n                if (s[i] == uh)\\n                    i++;\\n                else if (s[j] == uh)\\n                    j--;\\n              }\\n              else\\n              {\\n                  return false;\\n              }\\n          }\\n          else\\n          {\\n             i++;\\n             j--;\\n          }\\n        }\\n        return true;\\n    }\\n};```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Got it, I was removing all occurrences of the character"
                    },
                    {
                        "username": "10xvishal",
                        "content": "\"woicvixviciow\" why is this supposed to be false, after neglecting i its a valid palindrome \"wocvxvcow\""
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "you have to remove just 1 char in your input to make it a valid palindrome"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "seems that a testcase \"tebbem\" expects `false`. is \"ebbe\" not a valid palindrome? [@LeetCode](/LeetCode) ?"
                    },
                    {
                        "username": "10xvishal",
                        "content": "you will only get \"tebbe\" or \"ebbem\" after removing single char."
                    },
                    {
                        "username": "ankush920",
                        "content": "FULL EXPLAINED ||CODE || C++ ||0(N)\\nankush920\\n0\\nin a minute\\nIntuition\\nokk sit relax don\\'t frustate it\\'s easy but slightly different .\\n\\nremember must one mean --> can delete 0 or 1 character only\\nusing two pointer approach :-\\n-> i--> intial pointer , j--> final pointer\\n-> travese it from end , start both side (i++ , j-- );\\n-> if s[i] == s[j] --> satisfy palindrom condition okk go forward\\n->but if s[i] != s[j] so we can do two thing\\neither remove from left side ( i side deletion ) or righr side (j side deletion)\\n\\n(find useful upvote it vro :) )\\n-> i am choosing left first and right next and use counter( countI and countJ) to know whether i have chance to remove from left /right side or not\\n\\n**note i am not deleting from both side in my deletion condition box there is condition like that only one char is delete\\n\\n--> i use storeI and storeJ to for the remember point that where first inequality come and i was used my deletion power ( delete one character)\\nbecause in testcase like :-\\nif first inequality is come in string i go with \\'i\\' side deletion and it satisfy upto some length but not make my string completly palindromic because \\'j\\' side deletion make complete palindromic to my string so , at that i cann\\'t do \\'j\\' side deletion on present index\\n(it delete two character) i use that index where my first inequality ( or on which i use my i side is required to do it ** we only delete one character max**)\\n\\nso if both possibility fail mean (we check from i ,j side deletion )\\nreturn false otherwise true\\n\\nApproach\\nlinear traversal\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        \\n        int n = s.size();\\n        if( n  ==1)\\n        {\\n             return n;\\n        }\\n\\nint i = 0 , j = n-1;\\n\\nint countI = 0;\\nint countJ= 0;\\nint storeI =0;\\nint storeJ =0;\\n    while( i<=j)\\n    {\\n      \\n      if( s[i]!=s[j])\\n      {\\n          if( !countI)\\n          {\\n              countI=1;\\n              storeI =i;\\n              storeJ =j;\\n              i++;\\n              continue;\\n          }\\n\\n          if(!countJ)\\n          {\\n             i= storeI;\\n             j= storeJ; \\n             countJ =1;\\n             j--;\\n             continue;\\n          }\\n          return 0;\\n      }\\n\\n      i++;\\n      j--;\\n    }\\n\\nreturn true ;\\n    }\\n};"
                    },
                    {
                        "username": "Ardonite",
                        "content": "Hi,\\n\\nhow can expected be \"false\"?\\nIt must be true right?\\n\\nInput\\ns = \"tebbem\"\\n\\nOutput\\ntrue\\n\\nExpected\\nfalse"
                    },
                    {
                        "username": "underprocess",
                        "content": "you must remove t and m to make it palindrome but according to question s can be palindrome after deleting at most one character from it.so false."
                    },
                    {
                        "username": "darkpheonix2_O",
                        "content": "If you are unable to come up with any solution, think it like you skip one character from left and check for valid palindrome, if no solution is found save that index and now skip the right index to check for valid palindrome, it no valid palindrome is found then answer is false else true. Use two pointers left and right to check for valid palindrome."
                    },
                    {
                        "username": "aknownymous",
                        "content": "#### Can Someone tell me, how can I reduce its time complexity? Passes all the case except 402th. \n```\nclass Solution:\n    def pal(self,s):\n        if s==s[::-1]: return True\n        return False\n    def validPalindrome(self, s: str) -> bool:\n        if self.pal(s): return True\n        for i in range(len(s)):\n            c= list(s)\n            c.pop(i)\n            if self.pal(c): return True\n        return False\n```\n\n\n#### Test Case :\n```\n\"okelpsggfffjcbrxksywxjlwkreqaleuozasrpqssrwqnafcpurutghwgovmewwjqyeudyerbvccdbvoomncetrzgowzdmvfzuelummidrncazxgxmlgkutjyfgthpgiirrijsnxgcpvbkshzenutpgiglipedcwcrnspqsqfcfeodkjuhubpzrwfgvflmuexyalmwlitwciaaiqgruwdroxxoditxtpmfdfnkagaukeuyxbkjwkujredeuaidbnhuwrmxmpyeoomrokvmoythkirbjdhaohoxksgsvyvdtylazbryoqtwyytefpsysigwnykbwsjizweemjuuxdjtfautwvuywfhkzlhsbrgsyynvredkrjcducdwppalrdghzjuowbkbgmhwrmfbtqxevdaluwrrtrjltghiytbjugvdrmxlpvpttozlcinzqtrtnscfgkhmmglhzqkpjixxqflmycywxvhhoeeqgdwsvetbphhulczylfiurehhgjhbqqlaytwysupjuallphvvpohovrauewvphmvlcsalvxpvwuzyvjbziwnfyjdtglzzkceiiwbuqjiztidxixkwwyfvpnuucbtestwgchljweklejoxduaxoquvchivjbluxmpcbotwgktupjsfbazaclawkkwmtkigmuraapxufbwwbmqazrinavgiuyalbhifcqpgazrptwfmuvzqekycdujviondufakcnboxrlfnadcbpkwnomwmuwhwmvkrwglaxdvjbymcmpgcqcnelrmzhghndvdfrdfdkozgrzffhuaxghsjoizybbqhoijzgzdmnghaculluotbhtajdagptqmeccnzxvpedjnaydckhejghbuofmkoteoqkxkgtywtftxxptboxhowgknptmfsnvvunwblumqduomxvrmzqbnpnbnmnzuenjujcndsxtvwrcsnhvmmgjnkbdtemhhftpseosvhdxoorncynxkibnaxmufdnounrzbxqzrhgwtzbbzipbqwatzrtnhdbabnoglnrumbbnejduktmsxzuaoxmogrjqlgrbxnwyiqfwvlclqpsljktnjxqtmktdxdhkgbnsagyafukrrlxlkjsiljouzwfwtlodvfzfvdupqydvkufbbeqawqnnorghffoahelzvawxqpykxklzlhccvyepcdygxrpldnwzeqzuyjdkogmgdmfsezwqcrslpbxmnwvjxphcbmshayiodnnxwvahvsyleotqqlhirkjlatjnwmtmmsbkalmvdnupeejrykffsffyytugissgtmnyekjqitjfjncgrezpahvjknlbclkopsjtykfzpqlffvyeblcedfxjpsmdtuerffmaiiphomwkctufxsiauhctxsivqpltobdwybprkhchieimoitrjolnybwgqnmjrpkxazmwcasetwsxgqjlbhefssubuvpharcfxhsyscsriqvkotcackholuhfzradelmacojqbtncjhfwpfqwvbdxjvxomcgjiitstgxlskmzcsvhihwcvoxebboazklzvjbwabahyhmvrbewuxjbznehqrwccovzutpumalkpvaocwryvjyeezttwgithxltruftqkyxyfkgyfguavmmemueluvyfehbocgsekgznivscohwyhjwooegympcpesuujadzpvxbebensajfnnvywngawinqyxbeiuqheklyolibfktbmddllbgtqmgvctgefzjwzfnesltuqzytsfuenjblldtjilahswbwmphmakmeawekkpfoiiaozxspqiknxtxomxiqwuvfoenxemcldulgdttfrdyvoxjrnmbkxguworfgqzsxpijtefgguinlbixctiqcdqjvcnxwljpkfvftcqjdvkkoqvnrdbkhovmpcappqsmwuzrorqyvmusiemqbxjscejthwlycucoccnoewjekchjqxeeaxbyvneivxcdydqamzcvleohgxdzzcyngimxqzdhvllpycnvrvbowtowukelfvjovohtafapdezecrabznzmhmipjcbweqtrikczwqbuciyztrapbekfocryxrwmffphoivpwfiyosxpkyqywkvikzrvfudeoyvyissaubkowuvzpmsopvomseieivziqynovnaeapjfjfhjuzqtebrpqmwegzsvouuwptpqxcylqnabbrgiuvjhjtpqlrcixmcsyekcdxeixycwbocbezpetkqzrwyimikpjziimieyqoessjvqpypdnjpngvbfkifvuqsvcqfkwakdlvxfhneyfanbhqryrcbojqdnbbsadhcfxjmrjqwjjzxtusjqgkywatbrsszogjyreikgjqnucomibvajysnhvtodyxukkrcftiewcvjscmnyyrqkteohffqfehdrtjcaldwcukgnoclqwewabisdwevmynuzwlwikgsjwnmkmalkktmuiohcxyxzuxfogymsnjoefwxzwvaxvjqypzoocnydwggqyswygyajmwjczcrjdijsaoepwoqbekbzmpsdomsbkukirdlpzenohkpfexmahidgdlnvctvsvvcjpakiotoarnvfrpopdecxisdnqcdersoyuxypiicnhxvhvlqgfxlwnecdtfmsvuturggxxstxacnamdboyfoviavuimjnmzumsfmtpilvmzgfukxxwlhcmlyjfcxioderggkknwmilhnwebubywjtzvrfraijkdbafkgqfwooxbfwqknjtejesvqvauclxhoaivqtszuztdagbvxtzocksbbydqezqoghchyfgipfgckihnwvoqqejejfuiiarpkjfqrytxqwvwztwfuldyaxsczdvgoocbbndwndorkgjaqpdxchaspgwoylpclhiuxvjbfzalcyyxucygjwwynvvtklwcenuswoedrcnuwpegdlxtxavapdcwzukycdiqtvxytuuwwgtoljvcgdqqimrtrsdjvopgbyrfqoqeqdvvzqragwdkhbedxczdzgexgxgmbwgznogqnegoesellwuvezjmkujiixvkmsybocnuyomzyvajrgtldkminlbwbfxhbpalhreyuxnvyhumwcpwnscwaudmpzvuujnwiktxbzvczefnpjflaubhokplqmzzjtttdvrbxswmflsaueafokqthikxaogvwcgqhzlkimmwqherzlmnpkxxpfhgblfwpoiwvufkdbtvyixnsorwobajfcivuvcuudfqoroczjqocyevhqwgcjrhpmqlqbaqvdtvyovwnplzjhoylcsqpqqahxybrpzmidrdjrpcxewvsfqnxglpixmiertpjhezdtcgylhbxdcbjiavcsfyataialdjskqhrsqemygllpftrkaezmihzacbhmtbplaiufvodvkxhmyseacqoauufnwkhkmwvbpwheauxneglqdxnzepamermqayfxhpzklgdcsvhljdrphwcrfibblivigzognxoujeijlclqwrertsnrxlsdfuayckuqmcwznegmvwqqvivtwwcyufrlmnjonpfdmgvsflgidthqlxduryswstznfqhsynxzdzytooivftkjhnoebyydlosysfaepooamthyvfuxsikjymiiehavfijncwbqsyooshjhdxqugztfeenzwwtntftkvzqryeqhfnjyaunkzabpqkhkbichdpazhlvurjqbibqkdaouhmpnyfjfguwbvwtbtuhzzvtautrcixwklodvccwyxxwcdsxqgmbpxcsaomciqcgyubrjentajuwfygrucnjhubvtkwqpibxrmgwzcgilurzhbxvybkxyjbmvlfmairsesaydzwufjwbcbqvmuzkqgabteybwzcdtnqpzpngbaypdnzeiiljgcskixqofwkrptvlycvibbijjbdjjsbxihsluofdgzmkordkxsteviyyawtybxuzydoogjrezifywhogedcjmikqbujubpziqywijmbxnfmctlfkfxnrvctqgagsvxhgavgmsmbivnsaoacnjtcgmfpknvebxfxmkaapoczhjhkvyrjsbuwsojhlzagcedhkupyetzhexubqdpwbehgcnoauinbbfmvojmnklrlcbleuortsbjzzqdqwbsdvapqqfqxpetywemvhfffkojcfwfxjfzcgpxopbxcphqpmrrrkaplrmniigdryhifmufddkizgbhbgcxvcntujlwedemcluetinkzltzwjdrvzhelcmdktqpcitislwlkurqrhftqpccimqbcixvacdxdeepfrmuhvezpdgggevullgmvdpgouuxkzdhjewdijboumhmsboxhgzadjtwmeimdnavljnzdocsvcdkroqeulfaubhlcaamalpsukazggtwgpwdeqnpuedwwtjcrjdnokovvvtbjobvmeaqomfidmarizadomwrfedkusktxgbotdikfebmkrosgfpshynksglrtjiawdtidcvblzbewiqftxzyxdknnutfhqvanlscqqdxpjyqczbmzdfxcrctapwxqrokuexlbzmrdisdbzryowqwhzjxntrajzhfrsspiurmwuiarozvojsigivusihnzejxtoaljajmwazmeyoxodtgfnhsawbmbjcptsqwzrrlirrncipztqvkosqcyfyqfvbdnhwlmotffcbxczakkxqaynkemgwvdniaxrkvsskryiphzqpcgbsmixjfbdtxeemtbwydwgywxxofsayqohghjahnbsfwaqpzpbzofokykfcvlelnqhjnkdkvsigffqfebnkfjqumrkxcjlxubcpbpkhzddyhalpqrvjeduxpugfijyfgbzdhqfcwpoixmotpzybhfzgflhtqsublszjpeyagozzlxopflouxprnazfkyyklromjiwqqwijmorlkyykfzanrpxuolfpoxlzzogayepjzslbusqthlfgzfhbyzptomxiopwcfqhdzbgfyjifgupxudejvrqplahyddzhkpbpcbuxljcxkrmuqjfknbefqffgisvkdknjhqnlelvcfkykofozbpzpqawfsbnhajhghoqyasfoxxwygwdywbtmeextdbfjximsbgcpqzhpiyrkssvkrxaindvwgmeknyaqxkkazcxbcfftomlwhndbvfqyfycqsokvqtzpicnrrilrrzwqstpcjbmbwashnfgtdoxoyemzawmjajlaotxjeznhisuvigisjovzoraiuwmruipssrfhzjartnxjzhwqwoyrzbdsidrmzblxeukorqxwpatcrcxfdzmbzcqyjpxdqqcslnavqhftunnkdxyzxtfqiwebzlbvcditdwaijtrlgsknyhspfgsorkmbefkidtobgxtksukdefrwmodaziramdifmoqaemvbojbtvvvokondjrcjtwwdeupnqedwpgwtggzakusplamaaclhbuaflueqorkdcvscodznjlvandmiemwtjdazghxobsmhmuobjidwejhdzkxuuogpdvmglluvegggdpzevhumrfpeedxdcavxicbqmiccpqtfhrqruklwlsiticpqtkdmclehzvrdjwztlzkniteulcmedewljutncvxcgbhbgzikddfumfihyrdgiinmrlpakrrrmpqhpcxbpoxpgczfjxfwfcjokfffhvmewytepxqfqqpavdsbwqdqzzjbstrouelbclrlknmjovmfbbniuaoncghebwpdqbuxehzteypukhdecgazlhjoswubsjryvkhjhzcopaakmxfxbevnkpfmgctjncaoasnvibmsmgvaghxvsgagqtcvrnxfkfltcmfnxbmjiwyqizpbujubqkimjcdegohwyfizerjgoodyzuxbytwayyivetsxkdrokmzgdfoulshixbsjjdbjjibbivcylvtprkwfoqxikscgjliiezndpyabgnpzpqntdczwbyetbagqkzumvqbcbwjfuwzdyasesriamflvmbjyxkbyvxbhzruligczwgmrxbipqwktvbuhjncurgyfwujatnejrbuygcqicmoascxpbmgqxsdcwxxywccvdolkwxicrtuatvzzhutbtwvbwugfjfynpmhuoadkqbibqjruvlhzapdhcibkhkqpbazknuayjnfhqeyrqzvktftntwwzneeftzguqxdhjhsooysqbwcnjifvaheiimyjkisxufvyhtmaoopeafsysoldyybeonhjktfviootyzdzxnyshqfnztswsyrudxlqhtdiglfsvgmdfpnojnmlrfuycwwtvivqqwvmgenzwcmqukcyaufdslxrnstrerwqlcljiejuoxngozgivilbbifrcwhprdjlhvscdglkzphxfyaqmremapeznxdqlgenxuaehwpbvwmkhkwnfuuaoqcaesymhxkvdovfuialpbtmhbcazhimzeakrtfpllgymeqsrhqksjdlaiatayfscvaijbcdxbhlygctdzehjptreimxiplgxnqfsvwexcprjdrdimzprbyxhaqqpqsclyohjzlpnwvoyvtdvqabqlqmphrjcgwqhveycoqjzcoroqfduucvuvicfjabowrosnxiyvtbdkfuvwiopwflbghfpxxkpnmlzrehqwmmiklzhqgcwvgoaxkihtqkofaeuaslfmwsxbrvdtttjzzmqlpkohbualfjpnfezcvzbxtkiwnjuuvzpmduawcsnwpcwmuhyvnxuyerhlapbhxfbwblnimkdltgrjavyzmoyuncobysmkvxiijukmjzevuwlleseogenqgonzgwbmgxgxegzdzcxdebhkdwgarqzvvdqeqoqfrybgpovjdsrtrmiqqdgcvjlotgwwuutyxvtqidcykuzwcdpavaxtxldgepwuncrdeowsunecwlktvvnywwjgycuxyyclazfbjvxuihlcplyowgpsahcxdpqajgkrodnwdnbbcoogvdzcsxaydlufwtzwvwqxtyrqfjkpraiiufjejeqqovwnhikcgfpigfyhchgoqzeqdybbskcoztxvbgadtzuzstqviaohxlcuavqvsejetjnkqwfbxoowfqgkfabdkjiarfrvztjwybubewnhlimwnkkggredoixcfjylmchlwxxkufgzmvliptmfsmuzmnjmiuvaivofyobdmancaxtsxxggrutuvsmftdcenwlxfgqlvhvxhnciipyxuyosredcqndsixcedpoprfvnraotoikapjcvvsvtcvnldgdihamxefpkhonezpldrikukbsmodspmzbkebqowpeoasjidjrczcjwmjaygywsyqggwdyncoozpyqjvxavwzxwfeojnsmygofxuzxyxchoiumtkklamkmnwjsgkiwlwzunymvewdsibawewqlcongkucwdlacjtrdhefqffhoetkqryynmcsjvcweitfcrkkuxydotvhnsyjavbimocunqjgkieryjgozssrbtawykgqjsutxzjjwqjrmjxfchdasbbndqjobcryrqhbnafyenhfxvldkawkfqcvsquvfikfbvgnpjndpypqvjsseoqyeimiizjpkimiywrzqktepzebcobwcyxiexdckeyscmxicrlqptjhjvuigrbbanqlycxqptpwuuovszgewmqprbetqzujhfjfjpaeanvonyqizvieiesmovposmpzvuwokbuassiyvyoedufvrzkivkwyqykpxsoyifwpviohpffmwrxyrcofkebpartzyicubqwzckirtqewbcjpimhmznzbarcezedpafathovojvflekuwotwobvrvncypllvhdzqxmignyczzdxghoelvczmaqdydcxvienvybxaeexqjhckejweonccocucylwhtjecsjxbqmeisumvyqrorzuwmsqppacpmvohkbdrnvqokkvdjqctfvfkpjlwxncvjqdcqitcxiblniuggfetjipxszqgfrowugxkbmnrjxovydrfttdgludlcmexneofvuwqixmoxtxnkiqpsxzoaiiofpkkewaemkamhpmwbwshalijtdllbjneufstyzqutlsenfzwjzfegtcvgmqtgbllddmbtkfbiloylkehquiebxyqniwagnwyvnnfjasnebebxvpzdajuusepcpmygeoowjhywhocsvinzgkesgcobhefyvuleumemmvaugfygkfyxykqtfurtlxhtigwttzeeyjvyrwcoavpklamuptuzvoccwrqhenzbjxuwebrvmhyhabawbjvzlkzaobbexovcwhihvsczmkslxgtstiijgcmoxvjxdbvwqfpwfhjcntbqjocamledarzfhulohkcactokvqirscsyshxfcrahpvubussfehbljqgxswtesacwmzaxkprjmnqgwbynlojrtiomieihchkrpbywdbotlpqvisxtchuaisxfutckwmohpiiamffreutdmspjxfdeclbeyvfflqpzfkytjspoklcblnkjvhapzergcnjfjtiqjkeynmtgssigutyyffsffkyrjeepundvmlakbsmmtmwnjtaljkrihlqqtoelysvhavwxnndoiyahsmbchpxjvwnmxbplsrcqwzesfmdgmgokdjyuzqezwndlprxgydcpeyvcchlzlkxkypqxwavzlehaoffhgronnqwaqebbfukvdyqpudvfzfvdoltwfwzuojlisjklxlrrkufaygasnbgkhdxdtkmtqxjntkjlspqlclvwfqiywnxbrglqjrgomxoauzxsmtkudjenbbmurnlgonbabdhntrztawqbpizbbztwghrzqxbzrnuondfumxanbikxnycnrooxdhvsoesptfhhmetdbknjgmmvhnscrwvtxsdncjujneuznmnbnpnbqzmrvxmoudqmulbwnuvvnsfmtpnkgwohxobtpxxtftwytgkxkqoetokmfoubhgjehkcdyanjdepvxznccemqtpgadjathbtoullucahgnmdzgzjiohqbbyziojshgxauhffzrgzokdfdrfdvdnhghzmrlencqcgpmcmybjvdxalgwrkvmwhwumwmonwkpbcdanflrxobnckafudnoivjudcykeqzvumfwtprzagpqcfihblayuigvanirzaqmbwwbfuxpaarumgiktmwkkwalcazabfsjputkgwtobcpmxulbjvihcvuqoxaudxojelkewjlhcgwtsetbcuunpvfywwkxixditzijqubwiieckzzlgtdjyfnwizbjvyzuwvpxvlasclvmhpvweuarvohopvvhpllaujpusywtyalqqbhjghheruiflyzcluhhpbtevswdgqeeohhvxwycymlfqxxijpkqzhlgmmhkgfcsntrtqzniclzottpvplxmrdvgujbtyihgtljrtrrwuladvexqtbfmrwhmgbkbwoujzhgdrlappwdcudcjrkdervnyysgrbshlzkhfwyuvwtuaftjdxuujmeewzijswbkynwgisyspfetyywtqoyrbzalytdvyvsgskxohoahdjbrikhtyomvkormooeypmxmrwuhnbdiauederjukwjkbxyuekuagaknfdfmptxtidoxxordwurgqiaaicwtilwmlayxeumlfvgfwrzpbuhujkdoefcfqsqpsnrcwcdepilgigptunezhskbvpcgxnsjirriigphtgfyjtukglmxgxzacnrdimmuleuzfvmdzwogzrtecnmoovbdccvbreydueyqjwwemvogwhgturupcfanqwrssqprsazouelaqerkwljxwyskxrbcjfffggsplekod\"\n```"
                    }
                ]
            },
            {
                "id": 1870896,
                "content": [
                    {
                        "username": "aiswaryaa",
                        "content": "give tip"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "start checking form start and end index,,,whenever it hits that (start!=end) ,then pass it to another function which will check the reamin string is palindrome or not ,if its true return true ,otherwise false...  \n\n    NOTE: in the second function call u must have check two condition ,\n1st increase the starting index by one and check but the end index remains same (in this casse it  will ignore the 1st character from starting index) \n\nand 2nd one is: increase the end index by one, here start will be same (thus it willl check after ignoring the last index) and u have to check both the conditions ,to cover all the edge cases...\n"
                    },
                    {
                        "username": "varsha1531",
                        "content": "bool validPalindrome(string s) {\n      \n      int c=0;\n      int j=s.length()-1,i=0;\n      while(i<=j)\n      {\n          if(s[i]==s[j])\n          {\n              j--;\n              i++;\n          }\n          else \n          {\n              if(s[i]==s[j-1] )\n              {\n                  j=j-2;\n                  c++;\n                  i++;\n              }\n              else if(s[i+1]==s[j])\n              {\n                  i=i+2;\n                  c++;\n                  j--;\n              }\n              else{\n                  return false;\n              }\n          }\n          \n      }\n      \nreturn c<=1;\n     \n    } \nplz help me where am i going wrong\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": " `Consider this - ebcbbececabbacecbbcbe`\n \nI can't figure out why the LeetCode compiler refuses to accept my solution for \"ebcbbececabbacecbbcbe\" specific given input  [the input String isn't a palindrome at all ] . Can anyone lend a hand? Any insights or suggestions to resolve this compiler error would be greatly appreciated. Help me crack this puzzle.........\n"
                    },
                    {
                        "username": "vedranson",
                        "content": "First and last 5 chars: \\'ebcbb [...] bbcbe\\' make a valid palindrome. The rest is now \\'ececabbacec\\'. If you were to delete/ignore the leading \\'e\\', the rest \\'cecabbacec\\' is a valid palindrome."
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me figure out why my code is showing incorrect output for this string \"lfhnzyffurnskdlduhopgrssphgnbaxtuzmlwsxzamjtdqymgmmmmgmyxqdtjmazxwlmzutxabnghpssrgpohudldksnruffyznhfl\"\\nMy code is showing true but expected output is false. Can someone help me figure out what is wrong in my code \\n```class Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        int flag = 0;\\n        char uh;\\n        while(i<j)\\n        {\\n          while(!isalnum(s[i]))\\n          {\\n              i++;\\n          }\\n          while(!isalnum(s[j]))\\n          {\\n              j--;\\n          }\\n\\n          if(!(s[i]==s[j]) && flag==0)\\n          {\\n            flag =1;\\n            if (s[i + 1] == s[j])\\n            {\\n                i++;\\n                uh = s[i];\\n            }\\n\\n            else if (s[i] == s[j - 1])\\n            {\\n                uh = s[j];\\n                j--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n          }\\n          \\n          else if(!(s[i]==s[j]) && flag==1)\\n          {\\n              if((s[i]==uh || s[j]==uh))\\n              {\\n                if (s[i] == uh)\\n                    i++;\\n                else if (s[j] == uh)\\n                    j--;\\n              }\\n              else\\n              {\\n                  return false;\\n              }\\n          }\\n          else\\n          {\\n             i++;\\n             j--;\\n          }\\n        }\\n        return true;\\n    }\\n};```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Got it, I was removing all occurrences of the character"
                    },
                    {
                        "username": "10xvishal",
                        "content": "\"woicvixviciow\" why is this supposed to be false, after neglecting i its a valid palindrome \"wocvxvcow\""
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "you have to remove just 1 char in your input to make it a valid palindrome"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "seems that a testcase \"tebbem\" expects `false`. is \"ebbe\" not a valid palindrome? [@LeetCode](/LeetCode) ?"
                    },
                    {
                        "username": "10xvishal",
                        "content": "you will only get \"tebbe\" or \"ebbem\" after removing single char."
                    },
                    {
                        "username": "ankush920",
                        "content": "FULL EXPLAINED ||CODE || C++ ||0(N)\\nankush920\\n0\\nin a minute\\nIntuition\\nokk sit relax don\\'t frustate it\\'s easy but slightly different .\\n\\nremember must one mean --> can delete 0 or 1 character only\\nusing two pointer approach :-\\n-> i--> intial pointer , j--> final pointer\\n-> travese it from end , start both side (i++ , j-- );\\n-> if s[i] == s[j] --> satisfy palindrom condition okk go forward\\n->but if s[i] != s[j] so we can do two thing\\neither remove from left side ( i side deletion ) or righr side (j side deletion)\\n\\n(find useful upvote it vro :) )\\n-> i am choosing left first and right next and use counter( countI and countJ) to know whether i have chance to remove from left /right side or not\\n\\n**note i am not deleting from both side in my deletion condition box there is condition like that only one char is delete\\n\\n--> i use storeI and storeJ to for the remember point that where first inequality come and i was used my deletion power ( delete one character)\\nbecause in testcase like :-\\nif first inequality is come in string i go with \\'i\\' side deletion and it satisfy upto some length but not make my string completly palindromic because \\'j\\' side deletion make complete palindromic to my string so , at that i cann\\'t do \\'j\\' side deletion on present index\\n(it delete two character) i use that index where my first inequality ( or on which i use my i side is required to do it ** we only delete one character max**)\\n\\nso if both possibility fail mean (we check from i ,j side deletion )\\nreturn false otherwise true\\n\\nApproach\\nlinear traversal\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        \\n        int n = s.size();\\n        if( n  ==1)\\n        {\\n             return n;\\n        }\\n\\nint i = 0 , j = n-1;\\n\\nint countI = 0;\\nint countJ= 0;\\nint storeI =0;\\nint storeJ =0;\\n    while( i<=j)\\n    {\\n      \\n      if( s[i]!=s[j])\\n      {\\n          if( !countI)\\n          {\\n              countI=1;\\n              storeI =i;\\n              storeJ =j;\\n              i++;\\n              continue;\\n          }\\n\\n          if(!countJ)\\n          {\\n             i= storeI;\\n             j= storeJ; \\n             countJ =1;\\n             j--;\\n             continue;\\n          }\\n          return 0;\\n      }\\n\\n      i++;\\n      j--;\\n    }\\n\\nreturn true ;\\n    }\\n};"
                    },
                    {
                        "username": "Ardonite",
                        "content": "Hi,\\n\\nhow can expected be \"false\"?\\nIt must be true right?\\n\\nInput\\ns = \"tebbem\"\\n\\nOutput\\ntrue\\n\\nExpected\\nfalse"
                    },
                    {
                        "username": "underprocess",
                        "content": "you must remove t and m to make it palindrome but according to question s can be palindrome after deleting at most one character from it.so false."
                    },
                    {
                        "username": "darkpheonix2_O",
                        "content": "If you are unable to come up with any solution, think it like you skip one character from left and check for valid palindrome, if no solution is found save that index and now skip the right index to check for valid palindrome, it no valid palindrome is found then answer is false else true. Use two pointers left and right to check for valid palindrome."
                    },
                    {
                        "username": "aknownymous",
                        "content": "#### Can Someone tell me, how can I reduce its time complexity? Passes all the case except 402th. \n```\nclass Solution:\n    def pal(self,s):\n        if s==s[::-1]: return True\n        return False\n    def validPalindrome(self, s: str) -> bool:\n        if self.pal(s): return True\n        for i in range(len(s)):\n            c= list(s)\n            c.pop(i)\n            if self.pal(c): return True\n        return False\n```\n\n\n#### Test Case :\n```\n\"okelpsggfffjcbrxksywxjlwkreqaleuozasrpqssrwqnafcpurutghwgovmewwjqyeudyerbvccdbvoomncetrzgowzdmvfzuelummidrncazxgxmlgkutjyfgthpgiirrijsnxgcpvbkshzenutpgiglipedcwcrnspqsqfcfeodkjuhubpzrwfgvflmuexyalmwlitwciaaiqgruwdroxxoditxtpmfdfnkagaukeuyxbkjwkujredeuaidbnhuwrmxmpyeoomrokvmoythkirbjdhaohoxksgsvyvdtylazbryoqtwyytefpsysigwnykbwsjizweemjuuxdjtfautwvuywfhkzlhsbrgsyynvredkrjcducdwppalrdghzjuowbkbgmhwrmfbtqxevdaluwrrtrjltghiytbjugvdrmxlpvpttozlcinzqtrtnscfgkhmmglhzqkpjixxqflmycywxvhhoeeqgdwsvetbphhulczylfiurehhgjhbqqlaytwysupjuallphvvpohovrauewvphmvlcsalvxpvwuzyvjbziwnfyjdtglzzkceiiwbuqjiztidxixkwwyfvpnuucbtestwgchljweklejoxduaxoquvchivjbluxmpcbotwgktupjsfbazaclawkkwmtkigmuraapxufbwwbmqazrinavgiuyalbhifcqpgazrptwfmuvzqekycdujviondufakcnboxrlfnadcbpkwnomwmuwhwmvkrwglaxdvjbymcmpgcqcnelrmzhghndvdfrdfdkozgrzffhuaxghsjoizybbqhoijzgzdmnghaculluotbhtajdagptqmeccnzxvpedjnaydckhejghbuofmkoteoqkxkgtywtftxxptboxhowgknptmfsnvvunwblumqduomxvrmzqbnpnbnmnzuenjujcndsxtvwrcsnhvmmgjnkbdtemhhftpseosvhdxoorncynxkibnaxmufdnounrzbxqzrhgwtzbbzipbqwatzrtnhdbabnoglnrumbbnejduktmsxzuaoxmogrjqlgrbxnwyiqfwvlclqpsljktnjxqtmktdxdhkgbnsagyafukrrlxlkjsiljouzwfwtlodvfzfvdupqydvkufbbeqawqnnorghffoahelzvawxqpykxklzlhccvyepcdygxrpldnwzeqzuyjdkogmgdmfsezwqcrslpbxmnwvjxphcbmshayiodnnxwvahvsyleotqqlhirkjlatjnwmtmmsbkalmvdnupeejrykffsffyytugissgtmnyekjqitjfjncgrezpahvjknlbclkopsjtykfzpqlffvyeblcedfxjpsmdtuerffmaiiphomwkctufxsiauhctxsivqpltobdwybprkhchieimoitrjolnybwgqnmjrpkxazmwcasetwsxgqjlbhefssubuvpharcfxhsyscsriqvkotcackholuhfzradelmacojqbtncjhfwpfqwvbdxjvxomcgjiitstgxlskmzcsvhihwcvoxebboazklzvjbwabahyhmvrbewuxjbznehqrwccovzutpumalkpvaocwryvjyeezttwgithxltruftqkyxyfkgyfguavmmemueluvyfehbocgsekgznivscohwyhjwooegympcpesuujadzpvxbebensajfnnvywngawinqyxbeiuqheklyolibfktbmddllbgtqmgvctgefzjwzfnesltuqzytsfuenjblldtjilahswbwmphmakmeawekkpfoiiaozxspqiknxtxomxiqwuvfoenxemcldulgdttfrdyvoxjrnmbkxguworfgqzsxpijtefgguinlbixctiqcdqjvcnxwljpkfvftcqjdvkkoqvnrdbkhovmpcappqsmwuzrorqyvmusiemqbxjscejthwlycucoccnoewjekchjqxeeaxbyvneivxcdydqamzcvleohgxdzzcyngimxqzdhvllpycnvrvbowtowukelfvjovohtafapdezecrabznzmhmipjcbweqtrikczwqbuciyztrapbekfocryxrwmffphoivpwfiyosxpkyqywkvikzrvfudeoyvyissaubkowuvzpmsopvomseieivziqynovnaeapjfjfhjuzqtebrpqmwegzsvouuwptpqxcylqnabbrgiuvjhjtpqlrcixmcsyekcdxeixycwbocbezpetkqzrwyimikpjziimieyqoessjvqpypdnjpngvbfkifvuqsvcqfkwakdlvxfhneyfanbhqryrcbojqdnbbsadhcfxjmrjqwjjzxtusjqgkywatbrsszogjyreikgjqnucomibvajysnhvtodyxukkrcftiewcvjscmnyyrqkteohffqfehdrtjcaldwcukgnoclqwewabisdwevmynuzwlwikgsjwnmkmalkktmuiohcxyxzuxfogymsnjoefwxzwvaxvjqypzoocnydwggqyswygyajmwjczcrjdijsaoepwoqbekbzmpsdomsbkukirdlpzenohkpfexmahidgdlnvctvsvvcjpakiotoarnvfrpopdecxisdnqcdersoyuxypiicnhxvhvlqgfxlwnecdtfmsvuturggxxstxacnamdboyfoviavuimjnmzumsfmtpilvmzgfukxxwlhcmlyjfcxioderggkknwmilhnwebubywjtzvrfraijkdbafkgqfwooxbfwqknjtejesvqvauclxhoaivqtszuztdagbvxtzocksbbydqezqoghchyfgipfgckihnwvoqqejejfuiiarpkjfqrytxqwvwztwfuldyaxsczdvgoocbbndwndorkgjaqpdxchaspgwoylpclhiuxvjbfzalcyyxucygjwwynvvtklwcenuswoedrcnuwpegdlxtxavapdcwzukycdiqtvxytuuwwgtoljvcgdqqimrtrsdjvopgbyrfqoqeqdvvzqragwdkhbedxczdzgexgxgmbwgznogqnegoesellwuvezjmkujiixvkmsybocnuyomzyvajrgtldkminlbwbfxhbpalhreyuxnvyhumwcpwnscwaudmpzvuujnwiktxbzvczefnpjflaubhokplqmzzjtttdvrbxswmflsaueafokqthikxaogvwcgqhzlkimmwqherzlmnpkxxpfhgblfwpoiwvufkdbtvyixnsorwobajfcivuvcuudfqoroczjqocyevhqwgcjrhpmqlqbaqvdtvyovwnplzjhoylcsqpqqahxybrpzmidrdjrpcxewvsfqnxglpixmiertpjhezdtcgylhbxdcbjiavcsfyataialdjskqhrsqemygllpftrkaezmihzacbhmtbplaiufvodvkxhmyseacqoauufnwkhkmwvbpwheauxneglqdxnzepamermqayfxhpzklgdcsvhljdrphwcrfibblivigzognxoujeijlclqwrertsnrxlsdfuayckuqmcwznegmvwqqvivtwwcyufrlmnjonpfdmgvsflgidthqlxduryswstznfqhsynxzdzytooivftkjhnoebyydlosysfaepooamthyvfuxsikjymiiehavfijncwbqsyooshjhdxqugztfeenzwwtntftkvzqryeqhfnjyaunkzabpqkhkbichdpazhlvurjqbibqkdaouhmpnyfjfguwbvwtbtuhzzvtautrcixwklodvccwyxxwcdsxqgmbpxcsaomciqcgyubrjentajuwfygrucnjhubvtkwqpibxrmgwzcgilurzhbxvybkxyjbmvlfmairsesaydzwufjwbcbqvmuzkqgabteybwzcdtnqpzpngbaypdnzeiiljgcskixqofwkrptvlycvibbijjbdjjsbxihsluofdgzmkordkxsteviyyawtybxuzydoogjrezifywhogedcjmikqbujubpziqywijmbxnfmctlfkfxnrvctqgagsvxhgavgmsmbivnsaoacnjtcgmfpknvebxfxmkaapoczhjhkvyrjsbuwsojhlzagcedhkupyetzhexubqdpwbehgcnoauinbbfmvojmnklrlcbleuortsbjzzqdqwbsdvapqqfqxpetywemvhfffkojcfwfxjfzcgpxopbxcphqpmrrrkaplrmniigdryhifmufddkizgbhbgcxvcntujlwedemcluetinkzltzwjdrvzhelcmdktqpcitislwlkurqrhftqpccimqbcixvacdxdeepfrmuhvezpdgggevullgmvdpgouuxkzdhjewdijboumhmsboxhgzadjtwmeimdnavljnzdocsvcdkroqeulfaubhlcaamalpsukazggtwgpwdeqnpuedwwtjcrjdnokovvvtbjobvmeaqomfidmarizadomwrfedkusktxgbotdikfebmkrosgfpshynksglrtjiawdtidcvblzbewiqftxzyxdknnutfhqvanlscqqdxpjyqczbmzdfxcrctapwxqrokuexlbzmrdisdbzryowqwhzjxntrajzhfrsspiurmwuiarozvojsigivusihnzejxtoaljajmwazmeyoxodtgfnhsawbmbjcptsqwzrrlirrncipztqvkosqcyfyqfvbdnhwlmotffcbxczakkxqaynkemgwvdniaxrkvsskryiphzqpcgbsmixjfbdtxeemtbwydwgywxxofsayqohghjahnbsfwaqpzpbzofokykfcvlelnqhjnkdkvsigffqfebnkfjqumrkxcjlxubcpbpkhzddyhalpqrvjeduxpugfijyfgbzdhqfcwpoixmotpzybhfzgflhtqsublszjpeyagozzlxopflouxprnazfkyyklromjiwqqwijmorlkyykfzanrpxuolfpoxlzzogayepjzslbusqthlfgzfhbyzptomxiopwcfqhdzbgfyjifgupxudejvrqplahyddzhkpbpcbuxljcxkrmuqjfknbefqffgisvkdknjhqnlelvcfkykofozbpzpqawfsbnhajhghoqyasfoxxwygwdywbtmeextdbfjximsbgcpqzhpiyrkssvkrxaindvwgmeknyaqxkkazcxbcfftomlwhndbvfqyfycqsokvqtzpicnrrilrrzwqstpcjbmbwashnfgtdoxoyemzawmjajlaotxjeznhisuvigisjovzoraiuwmruipssrfhzjartnxjzhwqwoyrzbdsidrmzblxeukorqxwpatcrcxfdzmbzcqyjpxdqqcslnavqhftunnkdxyzxtfqiwebzlbvcditdwaijtrlgsknyhspfgsorkmbefkidtobgxtksukdefrwmodaziramdifmoqaemvbojbtvvvokondjrcjtwwdeupnqedwpgwtggzakusplamaaclhbuaflueqorkdcvscodznjlvandmiemwtjdazghxobsmhmuobjidwejhdzkxuuogpdvmglluvegggdpzevhumrfpeedxdcavxicbqmiccpqtfhrqruklwlsiticpqtkdmclehzvrdjwztlzkniteulcmedewljutncvxcgbhbgzikddfumfihyrdgiinmrlpakrrrmpqhpcxbpoxpgczfjxfwfcjokfffhvmewytepxqfqqpavdsbwqdqzzjbstrouelbclrlknmjovmfbbniuaoncghebwpdqbuxehzteypukhdecgazlhjoswubsjryvkhjhzcopaakmxfxbevnkpfmgctjncaoasnvibmsmgvaghxvsgagqtcvrnxfkfltcmfnxbmjiwyqizpbujubqkimjcdegohwyfizerjgoodyzuxbytwayyivetsxkdrokmzgdfoulshixbsjjdbjjibbivcylvtprkwfoqxikscgjliiezndpyabgnpzpqntdczwbyetbagqkzumvqbcbwjfuwzdyasesriamflvmbjyxkbyvxbhzruligczwgmrxbipqwktvbuhjncurgyfwujatnejrbuygcqicmoascxpbmgqxsdcwxxywccvdolkwxicrtuatvzzhutbtwvbwugfjfynpmhuoadkqbibqjruvlhzapdhcibkhkqpbazknuayjnfhqeyrqzvktftntwwzneeftzguqxdhjhsooysqbwcnjifvaheiimyjkisxufvyhtmaoopeafsysoldyybeonhjktfviootyzdzxnyshqfnztswsyrudxlqhtdiglfsvgmdfpnojnmlrfuycwwtvivqqwvmgenzwcmqukcyaufdslxrnstrerwqlcljiejuoxngozgivilbbifrcwhprdjlhvscdglkzphxfyaqmremapeznxdqlgenxuaehwpbvwmkhkwnfuuaoqcaesymhxkvdovfuialpbtmhbcazhimzeakrtfpllgymeqsrhqksjdlaiatayfscvaijbcdxbhlygctdzehjptreimxiplgxnqfsvwexcprjdrdimzprbyxhaqqpqsclyohjzlpnwvoyvtdvqabqlqmphrjcgwqhveycoqjzcoroqfduucvuvicfjabowrosnxiyvtbdkfuvwiopwflbghfpxxkpnmlzrehqwmmiklzhqgcwvgoaxkihtqkofaeuaslfmwsxbrvdtttjzzmqlpkohbualfjpnfezcvzbxtkiwnjuuvzpmduawcsnwpcwmuhyvnxuyerhlapbhxfbwblnimkdltgrjavyzmoyuncobysmkvxiijukmjzevuwlleseogenqgonzgwbmgxgxegzdzcxdebhkdwgarqzvvdqeqoqfrybgpovjdsrtrmiqqdgcvjlotgwwuutyxvtqidcykuzwcdpavaxtxldgepwuncrdeowsunecwlktvvnywwjgycuxyyclazfbjvxuihlcplyowgpsahcxdpqajgkrodnwdnbbcoogvdzcsxaydlufwtzwvwqxtyrqfjkpraiiufjejeqqovwnhikcgfpigfyhchgoqzeqdybbskcoztxvbgadtzuzstqviaohxlcuavqvsejetjnkqwfbxoowfqgkfabdkjiarfrvztjwybubewnhlimwnkkggredoixcfjylmchlwxxkufgzmvliptmfsmuzmnjmiuvaivofyobdmancaxtsxxggrutuvsmftdcenwlxfgqlvhvxhnciipyxuyosredcqndsixcedpoprfvnraotoikapjcvvsvtcvnldgdihamxefpkhonezpldrikukbsmodspmzbkebqowpeoasjidjrczcjwmjaygywsyqggwdyncoozpyqjvxavwzxwfeojnsmygofxuzxyxchoiumtkklamkmnwjsgkiwlwzunymvewdsibawewqlcongkucwdlacjtrdhefqffhoetkqryynmcsjvcweitfcrkkuxydotvhnsyjavbimocunqjgkieryjgozssrbtawykgqjsutxzjjwqjrmjxfchdasbbndqjobcryrqhbnafyenhfxvldkawkfqcvsquvfikfbvgnpjndpypqvjsseoqyeimiizjpkimiywrzqktepzebcobwcyxiexdckeyscmxicrlqptjhjvuigrbbanqlycxqptpwuuovszgewmqprbetqzujhfjfjpaeanvonyqizvieiesmovposmpzvuwokbuassiyvyoedufvrzkivkwyqykpxsoyifwpviohpffmwrxyrcofkebpartzyicubqwzckirtqewbcjpimhmznzbarcezedpafathovojvflekuwotwobvrvncypllvhdzqxmignyczzdxghoelvczmaqdydcxvienvybxaeexqjhckejweonccocucylwhtjecsjxbqmeisumvyqrorzuwmsqppacpmvohkbdrnvqokkvdjqctfvfkpjlwxncvjqdcqitcxiblniuggfetjipxszqgfrowugxkbmnrjxovydrfttdgludlcmexneofvuwqixmoxtxnkiqpsxzoaiiofpkkewaemkamhpmwbwshalijtdllbjneufstyzqutlsenfzwjzfegtcvgmqtgbllddmbtkfbiloylkehquiebxyqniwagnwyvnnfjasnebebxvpzdajuusepcpmygeoowjhywhocsvinzgkesgcobhefyvuleumemmvaugfygkfyxykqtfurtlxhtigwttzeeyjvyrwcoavpklamuptuzvoccwrqhenzbjxuwebrvmhyhabawbjvzlkzaobbexovcwhihvsczmkslxgtstiijgcmoxvjxdbvwqfpwfhjcntbqjocamledarzfhulohkcactokvqirscsyshxfcrahpvubussfehbljqgxswtesacwmzaxkprjmnqgwbynlojrtiomieihchkrpbywdbotlpqvisxtchuaisxfutckwmohpiiamffreutdmspjxfdeclbeyvfflqpzfkytjspoklcblnkjvhapzergcnjfjtiqjkeynmtgssigutyyffsffkyrjeepundvmlakbsmmtmwnjtaljkrihlqqtoelysvhavwxnndoiyahsmbchpxjvwnmxbplsrcqwzesfmdgmgokdjyuzqezwndlprxgydcpeyvcchlzlkxkypqxwavzlehaoffhgronnqwaqebbfukvdyqpudvfzfvdoltwfwzuojlisjklxlrrkufaygasnbgkhdxdtkmtqxjntkjlspqlclvwfqiywnxbrglqjrgomxoauzxsmtkudjenbbmurnlgonbabdhntrztawqbpizbbztwghrzqxbzrnuondfumxanbikxnycnrooxdhvsoesptfhhmetdbknjgmmvhnscrwvtxsdncjujneuznmnbnpnbqzmrvxmoudqmulbwnuvvnsfmtpnkgwohxobtpxxtftwytgkxkqoetokmfoubhgjehkcdyanjdepvxznccemqtpgadjathbtoullucahgnmdzgzjiohqbbyziojshgxauhffzrgzokdfdrfdvdnhghzmrlencqcgpmcmybjvdxalgwrkvmwhwumwmonwkpbcdanflrxobnckafudnoivjudcykeqzvumfwtprzagpqcfihblayuigvanirzaqmbwwbfuxpaarumgiktmwkkwalcazabfsjputkgwtobcpmxulbjvihcvuqoxaudxojelkewjlhcgwtsetbcuunpvfywwkxixditzijqubwiieckzzlgtdjyfnwizbjvyzuwvpxvlasclvmhpvweuarvohopvvhpllaujpusywtyalqqbhjghheruiflyzcluhhpbtevswdgqeeohhvxwycymlfqxxijpkqzhlgmmhkgfcsntrtqzniclzottpvplxmrdvgujbtyihgtljrtrrwuladvexqtbfmrwhmgbkbwoujzhgdrlappwdcudcjrkdervnyysgrbshlzkhfwyuvwtuaftjdxuujmeewzijswbkynwgisyspfetyywtqoyrbzalytdvyvsgskxohoahdjbrikhtyomvkormooeypmxmrwuhnbdiauederjukwjkbxyuekuagaknfdfmptxtidoxxordwurgqiaaicwtilwmlayxeumlfvgfwrzpbuhujkdoefcfqsqpsnrcwcdepilgigptunezhskbvpcgxnsjirriigphtgfyjtukglmxgxzacnrdimmuleuzfvmdzwogzrtecnmoovbdccvbreydueyqjwwemvogwhgturupcfanqwrssqprsazouelaqerkwljxwyskxrbcjfffggsplekod\"\n```"
                    }
                ]
            },
            {
                "id": 1867335,
                "content": [
                    {
                        "username": "aiswaryaa",
                        "content": "give tip"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "start checking form start and end index,,,whenever it hits that (start!=end) ,then pass it to another function which will check the reamin string is palindrome or not ,if its true return true ,otherwise false...  \n\n    NOTE: in the second function call u must have check two condition ,\n1st increase the starting index by one and check but the end index remains same (in this casse it  will ignore the 1st character from starting index) \n\nand 2nd one is: increase the end index by one, here start will be same (thus it willl check after ignoring the last index) and u have to check both the conditions ,to cover all the edge cases...\n"
                    },
                    {
                        "username": "varsha1531",
                        "content": "bool validPalindrome(string s) {\n      \n      int c=0;\n      int j=s.length()-1,i=0;\n      while(i<=j)\n      {\n          if(s[i]==s[j])\n          {\n              j--;\n              i++;\n          }\n          else \n          {\n              if(s[i]==s[j-1] )\n              {\n                  j=j-2;\n                  c++;\n                  i++;\n              }\n              else if(s[i+1]==s[j])\n              {\n                  i=i+2;\n                  c++;\n                  j--;\n              }\n              else{\n                  return false;\n              }\n          }\n          \n      }\n      \nreturn c<=1;\n     \n    } \nplz help me where am i going wrong\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": " `Consider this - ebcbbececabbacecbbcbe`\n \nI can't figure out why the LeetCode compiler refuses to accept my solution for \"ebcbbececabbacecbbcbe\" specific given input  [the input String isn't a palindrome at all ] . Can anyone lend a hand? Any insights or suggestions to resolve this compiler error would be greatly appreciated. Help me crack this puzzle.........\n"
                    },
                    {
                        "username": "vedranson",
                        "content": "First and last 5 chars: \\'ebcbb [...] bbcbe\\' make a valid palindrome. The rest is now \\'ececabbacec\\'. If you were to delete/ignore the leading \\'e\\', the rest \\'cecabbacec\\' is a valid palindrome."
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me figure out why my code is showing incorrect output for this string \"lfhnzyffurnskdlduhopgrssphgnbaxtuzmlwsxzamjtdqymgmmmmgmyxqdtjmazxwlmzutxabnghpssrgpohudldksnruffyznhfl\"\\nMy code is showing true but expected output is false. Can someone help me figure out what is wrong in my code \\n```class Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        int flag = 0;\\n        char uh;\\n        while(i<j)\\n        {\\n          while(!isalnum(s[i]))\\n          {\\n              i++;\\n          }\\n          while(!isalnum(s[j]))\\n          {\\n              j--;\\n          }\\n\\n          if(!(s[i]==s[j]) && flag==0)\\n          {\\n            flag =1;\\n            if (s[i + 1] == s[j])\\n            {\\n                i++;\\n                uh = s[i];\\n            }\\n\\n            else if (s[i] == s[j - 1])\\n            {\\n                uh = s[j];\\n                j--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n          }\\n          \\n          else if(!(s[i]==s[j]) && flag==1)\\n          {\\n              if((s[i]==uh || s[j]==uh))\\n              {\\n                if (s[i] == uh)\\n                    i++;\\n                else if (s[j] == uh)\\n                    j--;\\n              }\\n              else\\n              {\\n                  return false;\\n              }\\n          }\\n          else\\n          {\\n             i++;\\n             j--;\\n          }\\n        }\\n        return true;\\n    }\\n};```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Got it, I was removing all occurrences of the character"
                    },
                    {
                        "username": "10xvishal",
                        "content": "\"woicvixviciow\" why is this supposed to be false, after neglecting i its a valid palindrome \"wocvxvcow\""
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "you have to remove just 1 char in your input to make it a valid palindrome"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "seems that a testcase \"tebbem\" expects `false`. is \"ebbe\" not a valid palindrome? [@LeetCode](/LeetCode) ?"
                    },
                    {
                        "username": "10xvishal",
                        "content": "you will only get \"tebbe\" or \"ebbem\" after removing single char."
                    },
                    {
                        "username": "ankush920",
                        "content": "FULL EXPLAINED ||CODE || C++ ||0(N)\\nankush920\\n0\\nin a minute\\nIntuition\\nokk sit relax don\\'t frustate it\\'s easy but slightly different .\\n\\nremember must one mean --> can delete 0 or 1 character only\\nusing two pointer approach :-\\n-> i--> intial pointer , j--> final pointer\\n-> travese it from end , start both side (i++ , j-- );\\n-> if s[i] == s[j] --> satisfy palindrom condition okk go forward\\n->but if s[i] != s[j] so we can do two thing\\neither remove from left side ( i side deletion ) or righr side (j side deletion)\\n\\n(find useful upvote it vro :) )\\n-> i am choosing left first and right next and use counter( countI and countJ) to know whether i have chance to remove from left /right side or not\\n\\n**note i am not deleting from both side in my deletion condition box there is condition like that only one char is delete\\n\\n--> i use storeI and storeJ to for the remember point that where first inequality come and i was used my deletion power ( delete one character)\\nbecause in testcase like :-\\nif first inequality is come in string i go with \\'i\\' side deletion and it satisfy upto some length but not make my string completly palindromic because \\'j\\' side deletion make complete palindromic to my string so , at that i cann\\'t do \\'j\\' side deletion on present index\\n(it delete two character) i use that index where my first inequality ( or on which i use my i side is required to do it ** we only delete one character max**)\\n\\nso if both possibility fail mean (we check from i ,j side deletion )\\nreturn false otherwise true\\n\\nApproach\\nlinear traversal\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        \\n        int n = s.size();\\n        if( n  ==1)\\n        {\\n             return n;\\n        }\\n\\nint i = 0 , j = n-1;\\n\\nint countI = 0;\\nint countJ= 0;\\nint storeI =0;\\nint storeJ =0;\\n    while( i<=j)\\n    {\\n      \\n      if( s[i]!=s[j])\\n      {\\n          if( !countI)\\n          {\\n              countI=1;\\n              storeI =i;\\n              storeJ =j;\\n              i++;\\n              continue;\\n          }\\n\\n          if(!countJ)\\n          {\\n             i= storeI;\\n             j= storeJ; \\n             countJ =1;\\n             j--;\\n             continue;\\n          }\\n          return 0;\\n      }\\n\\n      i++;\\n      j--;\\n    }\\n\\nreturn true ;\\n    }\\n};"
                    },
                    {
                        "username": "Ardonite",
                        "content": "Hi,\\n\\nhow can expected be \"false\"?\\nIt must be true right?\\n\\nInput\\ns = \"tebbem\"\\n\\nOutput\\ntrue\\n\\nExpected\\nfalse"
                    },
                    {
                        "username": "underprocess",
                        "content": "you must remove t and m to make it palindrome but according to question s can be palindrome after deleting at most one character from it.so false."
                    },
                    {
                        "username": "darkpheonix2_O",
                        "content": "If you are unable to come up with any solution, think it like you skip one character from left and check for valid palindrome, if no solution is found save that index and now skip the right index to check for valid palindrome, it no valid palindrome is found then answer is false else true. Use two pointers left and right to check for valid palindrome."
                    },
                    {
                        "username": "aknownymous",
                        "content": "#### Can Someone tell me, how can I reduce its time complexity? Passes all the case except 402th. \n```\nclass Solution:\n    def pal(self,s):\n        if s==s[::-1]: return True\n        return False\n    def validPalindrome(self, s: str) -> bool:\n        if self.pal(s): return True\n        for i in range(len(s)):\n            c= list(s)\n            c.pop(i)\n            if self.pal(c): return True\n        return False\n```\n\n\n#### Test Case :\n```\n\"okelpsggfffjcbrxksywxjlwkreqaleuozasrpqssrwqnafcpurutghwgovmewwjqyeudyerbvccdbvoomncetrzgowzdmvfzuelummidrncazxgxmlgkutjyfgthpgiirrijsnxgcpvbkshzenutpgiglipedcwcrnspqsqfcfeodkjuhubpzrwfgvflmuexyalmwlitwciaaiqgruwdroxxoditxtpmfdfnkagaukeuyxbkjwkujredeuaidbnhuwrmxmpyeoomrokvmoythkirbjdhaohoxksgsvyvdtylazbryoqtwyytefpsysigwnykbwsjizweemjuuxdjtfautwvuywfhkzlhsbrgsyynvredkrjcducdwppalrdghzjuowbkbgmhwrmfbtqxevdaluwrrtrjltghiytbjugvdrmxlpvpttozlcinzqtrtnscfgkhmmglhzqkpjixxqflmycywxvhhoeeqgdwsvetbphhulczylfiurehhgjhbqqlaytwysupjuallphvvpohovrauewvphmvlcsalvxpvwuzyvjbziwnfyjdtglzzkceiiwbuqjiztidxixkwwyfvpnuucbtestwgchljweklejoxduaxoquvchivjbluxmpcbotwgktupjsfbazaclawkkwmtkigmuraapxufbwwbmqazrinavgiuyalbhifcqpgazrptwfmuvzqekycdujviondufakcnboxrlfnadcbpkwnomwmuwhwmvkrwglaxdvjbymcmpgcqcnelrmzhghndvdfrdfdkozgrzffhuaxghsjoizybbqhoijzgzdmnghaculluotbhtajdagptqmeccnzxvpedjnaydckhejghbuofmkoteoqkxkgtywtftxxptboxhowgknptmfsnvvunwblumqduomxvrmzqbnpnbnmnzuenjujcndsxtvwrcsnhvmmgjnkbdtemhhftpseosvhdxoorncynxkibnaxmufdnounrzbxqzrhgwtzbbzipbqwatzrtnhdbabnoglnrumbbnejduktmsxzuaoxmogrjqlgrbxnwyiqfwvlclqpsljktnjxqtmktdxdhkgbnsagyafukrrlxlkjsiljouzwfwtlodvfzfvdupqydvkufbbeqawqnnorghffoahelzvawxqpykxklzlhccvyepcdygxrpldnwzeqzuyjdkogmgdmfsezwqcrslpbxmnwvjxphcbmshayiodnnxwvahvsyleotqqlhirkjlatjnwmtmmsbkalmvdnupeejrykffsffyytugissgtmnyekjqitjfjncgrezpahvjknlbclkopsjtykfzpqlffvyeblcedfxjpsmdtuerffmaiiphomwkctufxsiauhctxsivqpltobdwybprkhchieimoitrjolnybwgqnmjrpkxazmwcasetwsxgqjlbhefssubuvpharcfxhsyscsriqvkotcackholuhfzradelmacojqbtncjhfwpfqwvbdxjvxomcgjiitstgxlskmzcsvhihwcvoxebboazklzvjbwabahyhmvrbewuxjbznehqrwccovzutpumalkpvaocwryvjyeezttwgithxltruftqkyxyfkgyfguavmmemueluvyfehbocgsekgznivscohwyhjwooegympcpesuujadzpvxbebensajfnnvywngawinqyxbeiuqheklyolibfktbmddllbgtqmgvctgefzjwzfnesltuqzytsfuenjblldtjilahswbwmphmakmeawekkpfoiiaozxspqiknxtxomxiqwuvfoenxemcldulgdttfrdyvoxjrnmbkxguworfgqzsxpijtefgguinlbixctiqcdqjvcnxwljpkfvftcqjdvkkoqvnrdbkhovmpcappqsmwuzrorqyvmusiemqbxjscejthwlycucoccnoewjekchjqxeeaxbyvneivxcdydqamzcvleohgxdzzcyngimxqzdhvllpycnvrvbowtowukelfvjovohtafapdezecrabznzmhmipjcbweqtrikczwqbuciyztrapbekfocryxrwmffphoivpwfiyosxpkyqywkvikzrvfudeoyvyissaubkowuvzpmsopvomseieivziqynovnaeapjfjfhjuzqtebrpqmwegzsvouuwptpqxcylqnabbrgiuvjhjtpqlrcixmcsyekcdxeixycwbocbezpetkqzrwyimikpjziimieyqoessjvqpypdnjpngvbfkifvuqsvcqfkwakdlvxfhneyfanbhqryrcbojqdnbbsadhcfxjmrjqwjjzxtusjqgkywatbrsszogjyreikgjqnucomibvajysnhvtodyxukkrcftiewcvjscmnyyrqkteohffqfehdrtjcaldwcukgnoclqwewabisdwevmynuzwlwikgsjwnmkmalkktmuiohcxyxzuxfogymsnjoefwxzwvaxvjqypzoocnydwggqyswygyajmwjczcrjdijsaoepwoqbekbzmpsdomsbkukirdlpzenohkpfexmahidgdlnvctvsvvcjpakiotoarnvfrpopdecxisdnqcdersoyuxypiicnhxvhvlqgfxlwnecdtfmsvuturggxxstxacnamdboyfoviavuimjnmzumsfmtpilvmzgfukxxwlhcmlyjfcxioderggkknwmilhnwebubywjtzvrfraijkdbafkgqfwooxbfwqknjtejesvqvauclxhoaivqtszuztdagbvxtzocksbbydqezqoghchyfgipfgckihnwvoqqejejfuiiarpkjfqrytxqwvwztwfuldyaxsczdvgoocbbndwndorkgjaqpdxchaspgwoylpclhiuxvjbfzalcyyxucygjwwynvvtklwcenuswoedrcnuwpegdlxtxavapdcwzukycdiqtvxytuuwwgtoljvcgdqqimrtrsdjvopgbyrfqoqeqdvvzqragwdkhbedxczdzgexgxgmbwgznogqnegoesellwuvezjmkujiixvkmsybocnuyomzyvajrgtldkminlbwbfxhbpalhreyuxnvyhumwcpwnscwaudmpzvuujnwiktxbzvczefnpjflaubhokplqmzzjtttdvrbxswmflsaueafokqthikxaogvwcgqhzlkimmwqherzlmnpkxxpfhgblfwpoiwvufkdbtvyixnsorwobajfcivuvcuudfqoroczjqocyevhqwgcjrhpmqlqbaqvdtvyovwnplzjhoylcsqpqqahxybrpzmidrdjrpcxewvsfqnxglpixmiertpjhezdtcgylhbxdcbjiavcsfyataialdjskqhrsqemygllpftrkaezmihzacbhmtbplaiufvodvkxhmyseacqoauufnwkhkmwvbpwheauxneglqdxnzepamermqayfxhpzklgdcsvhljdrphwcrfibblivigzognxoujeijlclqwrertsnrxlsdfuayckuqmcwznegmvwqqvivtwwcyufrlmnjonpfdmgvsflgidthqlxduryswstznfqhsynxzdzytooivftkjhnoebyydlosysfaepooamthyvfuxsikjymiiehavfijncwbqsyooshjhdxqugztfeenzwwtntftkvzqryeqhfnjyaunkzabpqkhkbichdpazhlvurjqbibqkdaouhmpnyfjfguwbvwtbtuhzzvtautrcixwklodvccwyxxwcdsxqgmbpxcsaomciqcgyubrjentajuwfygrucnjhubvtkwqpibxrmgwzcgilurzhbxvybkxyjbmvlfmairsesaydzwufjwbcbqvmuzkqgabteybwzcdtnqpzpngbaypdnzeiiljgcskixqofwkrptvlycvibbijjbdjjsbxihsluofdgzmkordkxsteviyyawtybxuzydoogjrezifywhogedcjmikqbujubpziqywijmbxnfmctlfkfxnrvctqgagsvxhgavgmsmbivnsaoacnjtcgmfpknvebxfxmkaapoczhjhkvyrjsbuwsojhlzagcedhkupyetzhexubqdpwbehgcnoauinbbfmvojmnklrlcbleuortsbjzzqdqwbsdvapqqfqxpetywemvhfffkojcfwfxjfzcgpxopbxcphqpmrrrkaplrmniigdryhifmufddkizgbhbgcxvcntujlwedemcluetinkzltzwjdrvzhelcmdktqpcitislwlkurqrhftqpccimqbcixvacdxdeepfrmuhvezpdgggevullgmvdpgouuxkzdhjewdijboumhmsboxhgzadjtwmeimdnavljnzdocsvcdkroqeulfaubhlcaamalpsukazggtwgpwdeqnpuedwwtjcrjdnokovvvtbjobvmeaqomfidmarizadomwrfedkusktxgbotdikfebmkrosgfpshynksglrtjiawdtidcvblzbewiqftxzyxdknnutfhqvanlscqqdxpjyqczbmzdfxcrctapwxqrokuexlbzmrdisdbzryowqwhzjxntrajzhfrsspiurmwuiarozvojsigivusihnzejxtoaljajmwazmeyoxodtgfnhsawbmbjcptsqwzrrlirrncipztqvkosqcyfyqfvbdnhwlmotffcbxczakkxqaynkemgwvdniaxrkvsskryiphzqpcgbsmixjfbdtxeemtbwydwgywxxofsayqohghjahnbsfwaqpzpbzofokykfcvlelnqhjnkdkvsigffqfebnkfjqumrkxcjlxubcpbpkhzddyhalpqrvjeduxpugfijyfgbzdhqfcwpoixmotpzybhfzgflhtqsublszjpeyagozzlxopflouxprnazfkyyklromjiwqqwijmorlkyykfzanrpxuolfpoxlzzogayepjzslbusqthlfgzfhbyzptomxiopwcfqhdzbgfyjifgupxudejvrqplahyddzhkpbpcbuxljcxkrmuqjfknbefqffgisvkdknjhqnlelvcfkykofozbpzpqawfsbnhajhghoqyasfoxxwygwdywbtmeextdbfjximsbgcpqzhpiyrkssvkrxaindvwgmeknyaqxkkazcxbcfftomlwhndbvfqyfycqsokvqtzpicnrrilrrzwqstpcjbmbwashnfgtdoxoyemzawmjajlaotxjeznhisuvigisjovzoraiuwmruipssrfhzjartnxjzhwqwoyrzbdsidrmzblxeukorqxwpatcrcxfdzmbzcqyjpxdqqcslnavqhftunnkdxyzxtfqiwebzlbvcditdwaijtrlgsknyhspfgsorkmbefkidtobgxtksukdefrwmodaziramdifmoqaemvbojbtvvvokondjrcjtwwdeupnqedwpgwtggzakusplamaaclhbuaflueqorkdcvscodznjlvandmiemwtjdazghxobsmhmuobjidwejhdzkxuuogpdvmglluvegggdpzevhumrfpeedxdcavxicbqmiccpqtfhrqruklwlsiticpqtkdmclehzvrdjwztlzkniteulcmedewljutncvxcgbhbgzikddfumfihyrdgiinmrlpakrrrmpqhpcxbpoxpgczfjxfwfcjokfffhvmewytepxqfqqpavdsbwqdqzzjbstrouelbclrlknmjovmfbbniuaoncghebwpdqbuxehzteypukhdecgazlhjoswubsjryvkhjhzcopaakmxfxbevnkpfmgctjncaoasnvibmsmgvaghxvsgagqtcvrnxfkfltcmfnxbmjiwyqizpbujubqkimjcdegohwyfizerjgoodyzuxbytwayyivetsxkdrokmzgdfoulshixbsjjdbjjibbivcylvtprkwfoqxikscgjliiezndpyabgnpzpqntdczwbyetbagqkzumvqbcbwjfuwzdyasesriamflvmbjyxkbyvxbhzruligczwgmrxbipqwktvbuhjncurgyfwujatnejrbuygcqicmoascxpbmgqxsdcwxxywccvdolkwxicrtuatvzzhutbtwvbwugfjfynpmhuoadkqbibqjruvlhzapdhcibkhkqpbazknuayjnfhqeyrqzvktftntwwzneeftzguqxdhjhsooysqbwcnjifvaheiimyjkisxufvyhtmaoopeafsysoldyybeonhjktfviootyzdzxnyshqfnztswsyrudxlqhtdiglfsvgmdfpnojnmlrfuycwwtvivqqwvmgenzwcmqukcyaufdslxrnstrerwqlcljiejuoxngozgivilbbifrcwhprdjlhvscdglkzphxfyaqmremapeznxdqlgenxuaehwpbvwmkhkwnfuuaoqcaesymhxkvdovfuialpbtmhbcazhimzeakrtfpllgymeqsrhqksjdlaiatayfscvaijbcdxbhlygctdzehjptreimxiplgxnqfsvwexcprjdrdimzprbyxhaqqpqsclyohjzlpnwvoyvtdvqabqlqmphrjcgwqhveycoqjzcoroqfduucvuvicfjabowrosnxiyvtbdkfuvwiopwflbghfpxxkpnmlzrehqwmmiklzhqgcwvgoaxkihtqkofaeuaslfmwsxbrvdtttjzzmqlpkohbualfjpnfezcvzbxtkiwnjuuvzpmduawcsnwpcwmuhyvnxuyerhlapbhxfbwblnimkdltgrjavyzmoyuncobysmkvxiijukmjzevuwlleseogenqgonzgwbmgxgxegzdzcxdebhkdwgarqzvvdqeqoqfrybgpovjdsrtrmiqqdgcvjlotgwwuutyxvtqidcykuzwcdpavaxtxldgepwuncrdeowsunecwlktvvnywwjgycuxyyclazfbjvxuihlcplyowgpsahcxdpqajgkrodnwdnbbcoogvdzcsxaydlufwtzwvwqxtyrqfjkpraiiufjejeqqovwnhikcgfpigfyhchgoqzeqdybbskcoztxvbgadtzuzstqviaohxlcuavqvsejetjnkqwfbxoowfqgkfabdkjiarfrvztjwybubewnhlimwnkkggredoixcfjylmchlwxxkufgzmvliptmfsmuzmnjmiuvaivofyobdmancaxtsxxggrutuvsmftdcenwlxfgqlvhvxhnciipyxuyosredcqndsixcedpoprfvnraotoikapjcvvsvtcvnldgdihamxefpkhonezpldrikukbsmodspmzbkebqowpeoasjidjrczcjwmjaygywsyqggwdyncoozpyqjvxavwzxwfeojnsmygofxuzxyxchoiumtkklamkmnwjsgkiwlwzunymvewdsibawewqlcongkucwdlacjtrdhefqffhoetkqryynmcsjvcweitfcrkkuxydotvhnsyjavbimocunqjgkieryjgozssrbtawykgqjsutxzjjwqjrmjxfchdasbbndqjobcryrqhbnafyenhfxvldkawkfqcvsquvfikfbvgnpjndpypqvjsseoqyeimiizjpkimiywrzqktepzebcobwcyxiexdckeyscmxicrlqptjhjvuigrbbanqlycxqptpwuuovszgewmqprbetqzujhfjfjpaeanvonyqizvieiesmovposmpzvuwokbuassiyvyoedufvrzkivkwyqykpxsoyifwpviohpffmwrxyrcofkebpartzyicubqwzckirtqewbcjpimhmznzbarcezedpafathovojvflekuwotwobvrvncypllvhdzqxmignyczzdxghoelvczmaqdydcxvienvybxaeexqjhckejweonccocucylwhtjecsjxbqmeisumvyqrorzuwmsqppacpmvohkbdrnvqokkvdjqctfvfkpjlwxncvjqdcqitcxiblniuggfetjipxszqgfrowugxkbmnrjxovydrfttdgludlcmexneofvuwqixmoxtxnkiqpsxzoaiiofpkkewaemkamhpmwbwshalijtdllbjneufstyzqutlsenfzwjzfegtcvgmqtgbllddmbtkfbiloylkehquiebxyqniwagnwyvnnfjasnebebxvpzdajuusepcpmygeoowjhywhocsvinzgkesgcobhefyvuleumemmvaugfygkfyxykqtfurtlxhtigwttzeeyjvyrwcoavpklamuptuzvoccwrqhenzbjxuwebrvmhyhabawbjvzlkzaobbexovcwhihvsczmkslxgtstiijgcmoxvjxdbvwqfpwfhjcntbqjocamledarzfhulohkcactokvqirscsyshxfcrahpvubussfehbljqgxswtesacwmzaxkprjmnqgwbynlojrtiomieihchkrpbywdbotlpqvisxtchuaisxfutckwmohpiiamffreutdmspjxfdeclbeyvfflqpzfkytjspoklcblnkjvhapzergcnjfjtiqjkeynmtgssigutyyffsffkyrjeepundvmlakbsmmtmwnjtaljkrihlqqtoelysvhavwxnndoiyahsmbchpxjvwnmxbplsrcqwzesfmdgmgokdjyuzqezwndlprxgydcpeyvcchlzlkxkypqxwavzlehaoffhgronnqwaqebbfukvdyqpudvfzfvdoltwfwzuojlisjklxlrrkufaygasnbgkhdxdtkmtqxjntkjlspqlclvwfqiywnxbrglqjrgomxoauzxsmtkudjenbbmurnlgonbabdhntrztawqbpizbbztwghrzqxbzrnuondfumxanbikxnycnrooxdhvsoesptfhhmetdbknjgmmvhnscrwvtxsdncjujneuznmnbnpnbqzmrvxmoudqmulbwnuvvnsfmtpnkgwohxobtpxxtftwytgkxkqoetokmfoubhgjehkcdyanjdepvxznccemqtpgadjathbtoullucahgnmdzgzjiohqbbyziojshgxauhffzrgzokdfdrfdvdnhghzmrlencqcgpmcmybjvdxalgwrkvmwhwumwmonwkpbcdanflrxobnckafudnoivjudcykeqzvumfwtprzagpqcfihblayuigvanirzaqmbwwbfuxpaarumgiktmwkkwalcazabfsjputkgwtobcpmxulbjvihcvuqoxaudxojelkewjlhcgwtsetbcuunpvfywwkxixditzijqubwiieckzzlgtdjyfnwizbjvyzuwvpxvlasclvmhpvweuarvohopvvhpllaujpusywtyalqqbhjghheruiflyzcluhhpbtevswdgqeeohhvxwycymlfqxxijpkqzhlgmmhkgfcsntrtqzniclzottpvplxmrdvgujbtyihgtljrtrrwuladvexqtbfmrwhmgbkbwoujzhgdrlappwdcudcjrkdervnyysgrbshlzkhfwyuvwtuaftjdxuujmeewzijswbkynwgisyspfetyywtqoyrbzalytdvyvsgskxohoahdjbrikhtyomvkormooeypmxmrwuhnbdiauederjukwjkbxyuekuagaknfdfmptxtidoxxordwurgqiaaicwtilwmlayxeumlfvgfwrzpbuhujkdoefcfqsqpsnrcwcdepilgigptunezhskbvpcgxnsjirriigphtgfyjtukglmxgxzacnrdimmuleuzfvmdzwogzrtecnmoovbdccvbreydueyqjwwemvogwhgturupcfanqwrssqprsazouelaqerkwljxwyskxrbcjfffggsplekod\"\n```"
                    }
                ]
            },
            {
                "id": 1739609,
                "content": [
                    {
                        "username": "aiswaryaa",
                        "content": "give tip"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "start checking form start and end index,,,whenever it hits that (start!=end) ,then pass it to another function which will check the reamin string is palindrome or not ,if its true return true ,otherwise false...  \n\n    NOTE: in the second function call u must have check two condition ,\n1st increase the starting index by one and check but the end index remains same (in this casse it  will ignore the 1st character from starting index) \n\nand 2nd one is: increase the end index by one, here start will be same (thus it willl check after ignoring the last index) and u have to check both the conditions ,to cover all the edge cases...\n"
                    },
                    {
                        "username": "varsha1531",
                        "content": "bool validPalindrome(string s) {\n      \n      int c=0;\n      int j=s.length()-1,i=0;\n      while(i<=j)\n      {\n          if(s[i]==s[j])\n          {\n              j--;\n              i++;\n          }\n          else \n          {\n              if(s[i]==s[j-1] )\n              {\n                  j=j-2;\n                  c++;\n                  i++;\n              }\n              else if(s[i+1]==s[j])\n              {\n                  i=i+2;\n                  c++;\n                  j--;\n              }\n              else{\n                  return false;\n              }\n          }\n          \n      }\n      \nreturn c<=1;\n     \n    } \nplz help me where am i going wrong\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": " `Consider this - ebcbbececabbacecbbcbe`\n \nI can't figure out why the LeetCode compiler refuses to accept my solution for \"ebcbbececabbacecbbcbe\" specific given input  [the input String isn't a palindrome at all ] . Can anyone lend a hand? Any insights or suggestions to resolve this compiler error would be greatly appreciated. Help me crack this puzzle.........\n"
                    },
                    {
                        "username": "vedranson",
                        "content": "First and last 5 chars: \\'ebcbb [...] bbcbe\\' make a valid palindrome. The rest is now \\'ececabbacec\\'. If you were to delete/ignore the leading \\'e\\', the rest \\'cecabbacec\\' is a valid palindrome."
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me figure out why my code is showing incorrect output for this string \"lfhnzyffurnskdlduhopgrssphgnbaxtuzmlwsxzamjtdqymgmmmmgmyxqdtjmazxwlmzutxabnghpssrgpohudldksnruffyznhfl\"\\nMy code is showing true but expected output is false. Can someone help me figure out what is wrong in my code \\n```class Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        int flag = 0;\\n        char uh;\\n        while(i<j)\\n        {\\n          while(!isalnum(s[i]))\\n          {\\n              i++;\\n          }\\n          while(!isalnum(s[j]))\\n          {\\n              j--;\\n          }\\n\\n          if(!(s[i]==s[j]) && flag==0)\\n          {\\n            flag =1;\\n            if (s[i + 1] == s[j])\\n            {\\n                i++;\\n                uh = s[i];\\n            }\\n\\n            else if (s[i] == s[j - 1])\\n            {\\n                uh = s[j];\\n                j--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n          }\\n          \\n          else if(!(s[i]==s[j]) && flag==1)\\n          {\\n              if((s[i]==uh || s[j]==uh))\\n              {\\n                if (s[i] == uh)\\n                    i++;\\n                else if (s[j] == uh)\\n                    j--;\\n              }\\n              else\\n              {\\n                  return false;\\n              }\\n          }\\n          else\\n          {\\n             i++;\\n             j--;\\n          }\\n        }\\n        return true;\\n    }\\n};```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Got it, I was removing all occurrences of the character"
                    },
                    {
                        "username": "10xvishal",
                        "content": "\"woicvixviciow\" why is this supposed to be false, after neglecting i its a valid palindrome \"wocvxvcow\""
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "you have to remove just 1 char in your input to make it a valid palindrome"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "seems that a testcase \"tebbem\" expects `false`. is \"ebbe\" not a valid palindrome? [@LeetCode](/LeetCode) ?"
                    },
                    {
                        "username": "10xvishal",
                        "content": "you will only get \"tebbe\" or \"ebbem\" after removing single char."
                    },
                    {
                        "username": "ankush920",
                        "content": "FULL EXPLAINED ||CODE || C++ ||0(N)\\nankush920\\n0\\nin a minute\\nIntuition\\nokk sit relax don\\'t frustate it\\'s easy but slightly different .\\n\\nremember must one mean --> can delete 0 or 1 character only\\nusing two pointer approach :-\\n-> i--> intial pointer , j--> final pointer\\n-> travese it from end , start both side (i++ , j-- );\\n-> if s[i] == s[j] --> satisfy palindrom condition okk go forward\\n->but if s[i] != s[j] so we can do two thing\\neither remove from left side ( i side deletion ) or righr side (j side deletion)\\n\\n(find useful upvote it vro :) )\\n-> i am choosing left first and right next and use counter( countI and countJ) to know whether i have chance to remove from left /right side or not\\n\\n**note i am not deleting from both side in my deletion condition box there is condition like that only one char is delete\\n\\n--> i use storeI and storeJ to for the remember point that where first inequality come and i was used my deletion power ( delete one character)\\nbecause in testcase like :-\\nif first inequality is come in string i go with \\'i\\' side deletion and it satisfy upto some length but not make my string completly palindromic because \\'j\\' side deletion make complete palindromic to my string so , at that i cann\\'t do \\'j\\' side deletion on present index\\n(it delete two character) i use that index where my first inequality ( or on which i use my i side is required to do it ** we only delete one character max**)\\n\\nso if both possibility fail mean (we check from i ,j side deletion )\\nreturn false otherwise true\\n\\nApproach\\nlinear traversal\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        \\n        int n = s.size();\\n        if( n  ==1)\\n        {\\n             return n;\\n        }\\n\\nint i = 0 , j = n-1;\\n\\nint countI = 0;\\nint countJ= 0;\\nint storeI =0;\\nint storeJ =0;\\n    while( i<=j)\\n    {\\n      \\n      if( s[i]!=s[j])\\n      {\\n          if( !countI)\\n          {\\n              countI=1;\\n              storeI =i;\\n              storeJ =j;\\n              i++;\\n              continue;\\n          }\\n\\n          if(!countJ)\\n          {\\n             i= storeI;\\n             j= storeJ; \\n             countJ =1;\\n             j--;\\n             continue;\\n          }\\n          return 0;\\n      }\\n\\n      i++;\\n      j--;\\n    }\\n\\nreturn true ;\\n    }\\n};"
                    },
                    {
                        "username": "Ardonite",
                        "content": "Hi,\\n\\nhow can expected be \"false\"?\\nIt must be true right?\\n\\nInput\\ns = \"tebbem\"\\n\\nOutput\\ntrue\\n\\nExpected\\nfalse"
                    },
                    {
                        "username": "underprocess",
                        "content": "you must remove t and m to make it palindrome but according to question s can be palindrome after deleting at most one character from it.so false."
                    },
                    {
                        "username": "darkpheonix2_O",
                        "content": "If you are unable to come up with any solution, think it like you skip one character from left and check for valid palindrome, if no solution is found save that index and now skip the right index to check for valid palindrome, it no valid palindrome is found then answer is false else true. Use two pointers left and right to check for valid palindrome."
                    },
                    {
                        "username": "aknownymous",
                        "content": "#### Can Someone tell me, how can I reduce its time complexity? Passes all the case except 402th. \n```\nclass Solution:\n    def pal(self,s):\n        if s==s[::-1]: return True\n        return False\n    def validPalindrome(self, s: str) -> bool:\n        if self.pal(s): return True\n        for i in range(len(s)):\n            c= list(s)\n            c.pop(i)\n            if self.pal(c): return True\n        return False\n```\n\n\n#### Test Case :\n```\n\"okelpsggfffjcbrxksywxjlwkreqaleuozasrpqssrwqnafcpurutghwgovmewwjqyeudyerbvccdbvoomncetrzgowzdmvfzuelummidrncazxgxmlgkutjyfgthpgiirrijsnxgcpvbkshzenutpgiglipedcwcrnspqsqfcfeodkjuhubpzrwfgvflmuexyalmwlitwciaaiqgruwdroxxoditxtpmfdfnkagaukeuyxbkjwkujredeuaidbnhuwrmxmpyeoomrokvmoythkirbjdhaohoxksgsvyvdtylazbryoqtwyytefpsysigwnykbwsjizweemjuuxdjtfautwvuywfhkzlhsbrgsyynvredkrjcducdwppalrdghzjuowbkbgmhwrmfbtqxevdaluwrrtrjltghiytbjugvdrmxlpvpttozlcinzqtrtnscfgkhmmglhzqkpjixxqflmycywxvhhoeeqgdwsvetbphhulczylfiurehhgjhbqqlaytwysupjuallphvvpohovrauewvphmvlcsalvxpvwuzyvjbziwnfyjdtglzzkceiiwbuqjiztidxixkwwyfvpnuucbtestwgchljweklejoxduaxoquvchivjbluxmpcbotwgktupjsfbazaclawkkwmtkigmuraapxufbwwbmqazrinavgiuyalbhifcqpgazrptwfmuvzqekycdujviondufakcnboxrlfnadcbpkwnomwmuwhwmvkrwglaxdvjbymcmpgcqcnelrmzhghndvdfrdfdkozgrzffhuaxghsjoizybbqhoijzgzdmnghaculluotbhtajdagptqmeccnzxvpedjnaydckhejghbuofmkoteoqkxkgtywtftxxptboxhowgknptmfsnvvunwblumqduomxvrmzqbnpnbnmnzuenjujcndsxtvwrcsnhvmmgjnkbdtemhhftpseosvhdxoorncynxkibnaxmufdnounrzbxqzrhgwtzbbzipbqwatzrtnhdbabnoglnrumbbnejduktmsxzuaoxmogrjqlgrbxnwyiqfwvlclqpsljktnjxqtmktdxdhkgbnsagyafukrrlxlkjsiljouzwfwtlodvfzfvdupqydvkufbbeqawqnnorghffoahelzvawxqpykxklzlhccvyepcdygxrpldnwzeqzuyjdkogmgdmfsezwqcrslpbxmnwvjxphcbmshayiodnnxwvahvsyleotqqlhirkjlatjnwmtmmsbkalmvdnupeejrykffsffyytugissgtmnyekjqitjfjncgrezpahvjknlbclkopsjtykfzpqlffvyeblcedfxjpsmdtuerffmaiiphomwkctufxsiauhctxsivqpltobdwybprkhchieimoitrjolnybwgqnmjrpkxazmwcasetwsxgqjlbhefssubuvpharcfxhsyscsriqvkotcackholuhfzradelmacojqbtncjhfwpfqwvbdxjvxomcgjiitstgxlskmzcsvhihwcvoxebboazklzvjbwabahyhmvrbewuxjbznehqrwccovzutpumalkpvaocwryvjyeezttwgithxltruftqkyxyfkgyfguavmmemueluvyfehbocgsekgznivscohwyhjwooegympcpesuujadzpvxbebensajfnnvywngawinqyxbeiuqheklyolibfktbmddllbgtqmgvctgefzjwzfnesltuqzytsfuenjblldtjilahswbwmphmakmeawekkpfoiiaozxspqiknxtxomxiqwuvfoenxemcldulgdttfrdyvoxjrnmbkxguworfgqzsxpijtefgguinlbixctiqcdqjvcnxwljpkfvftcqjdvkkoqvnrdbkhovmpcappqsmwuzrorqyvmusiemqbxjscejthwlycucoccnoewjekchjqxeeaxbyvneivxcdydqamzcvleohgxdzzcyngimxqzdhvllpycnvrvbowtowukelfvjovohtafapdezecrabznzmhmipjcbweqtrikczwqbuciyztrapbekfocryxrwmffphoivpwfiyosxpkyqywkvikzrvfudeoyvyissaubkowuvzpmsopvomseieivziqynovnaeapjfjfhjuzqtebrpqmwegzsvouuwptpqxcylqnabbrgiuvjhjtpqlrcixmcsyekcdxeixycwbocbezpetkqzrwyimikpjziimieyqoessjvqpypdnjpngvbfkifvuqsvcqfkwakdlvxfhneyfanbhqryrcbojqdnbbsadhcfxjmrjqwjjzxtusjqgkywatbrsszogjyreikgjqnucomibvajysnhvtodyxukkrcftiewcvjscmnyyrqkteohffqfehdrtjcaldwcukgnoclqwewabisdwevmynuzwlwikgsjwnmkmalkktmuiohcxyxzuxfogymsnjoefwxzwvaxvjqypzoocnydwggqyswygyajmwjczcrjdijsaoepwoqbekbzmpsdomsbkukirdlpzenohkpfexmahidgdlnvctvsvvcjpakiotoarnvfrpopdecxisdnqcdersoyuxypiicnhxvhvlqgfxlwnecdtfmsvuturggxxstxacnamdboyfoviavuimjnmzumsfmtpilvmzgfukxxwlhcmlyjfcxioderggkknwmilhnwebubywjtzvrfraijkdbafkgqfwooxbfwqknjtejesvqvauclxhoaivqtszuztdagbvxtzocksbbydqezqoghchyfgipfgckihnwvoqqejejfuiiarpkjfqrytxqwvwztwfuldyaxsczdvgoocbbndwndorkgjaqpdxchaspgwoylpclhiuxvjbfzalcyyxucygjwwynvvtklwcenuswoedrcnuwpegdlxtxavapdcwzukycdiqtvxytuuwwgtoljvcgdqqimrtrsdjvopgbyrfqoqeqdvvzqragwdkhbedxczdzgexgxgmbwgznogqnegoesellwuvezjmkujiixvkmsybocnuyomzyvajrgtldkminlbwbfxhbpalhreyuxnvyhumwcpwnscwaudmpzvuujnwiktxbzvczefnpjflaubhokplqmzzjtttdvrbxswmflsaueafokqthikxaogvwcgqhzlkimmwqherzlmnpkxxpfhgblfwpoiwvufkdbtvyixnsorwobajfcivuvcuudfqoroczjqocyevhqwgcjrhpmqlqbaqvdtvyovwnplzjhoylcsqpqqahxybrpzmidrdjrpcxewvsfqnxglpixmiertpjhezdtcgylhbxdcbjiavcsfyataialdjskqhrsqemygllpftrkaezmihzacbhmtbplaiufvodvkxhmyseacqoauufnwkhkmwvbpwheauxneglqdxnzepamermqayfxhpzklgdcsvhljdrphwcrfibblivigzognxoujeijlclqwrertsnrxlsdfuayckuqmcwznegmvwqqvivtwwcyufrlmnjonpfdmgvsflgidthqlxduryswstznfqhsynxzdzytooivftkjhnoebyydlosysfaepooamthyvfuxsikjymiiehavfijncwbqsyooshjhdxqugztfeenzwwtntftkvzqryeqhfnjyaunkzabpqkhkbichdpazhlvurjqbibqkdaouhmpnyfjfguwbvwtbtuhzzvtautrcixwklodvccwyxxwcdsxqgmbpxcsaomciqcgyubrjentajuwfygrucnjhubvtkwqpibxrmgwzcgilurzhbxvybkxyjbmvlfmairsesaydzwufjwbcbqvmuzkqgabteybwzcdtnqpzpngbaypdnzeiiljgcskixqofwkrptvlycvibbijjbdjjsbxihsluofdgzmkordkxsteviyyawtybxuzydoogjrezifywhogedcjmikqbujubpziqywijmbxnfmctlfkfxnrvctqgagsvxhgavgmsmbivnsaoacnjtcgmfpknvebxfxmkaapoczhjhkvyrjsbuwsojhlzagcedhkupyetzhexubqdpwbehgcnoauinbbfmvojmnklrlcbleuortsbjzzqdqwbsdvapqqfqxpetywemvhfffkojcfwfxjfzcgpxopbxcphqpmrrrkaplrmniigdryhifmufddkizgbhbgcxvcntujlwedemcluetinkzltzwjdrvzhelcmdktqpcitislwlkurqrhftqpccimqbcixvacdxdeepfrmuhvezpdgggevullgmvdpgouuxkzdhjewdijboumhmsboxhgzadjtwmeimdnavljnzdocsvcdkroqeulfaubhlcaamalpsukazggtwgpwdeqnpuedwwtjcrjdnokovvvtbjobvmeaqomfidmarizadomwrfedkusktxgbotdikfebmkrosgfpshynksglrtjiawdtidcvblzbewiqftxzyxdknnutfhqvanlscqqdxpjyqczbmzdfxcrctapwxqrokuexlbzmrdisdbzryowqwhzjxntrajzhfrsspiurmwuiarozvojsigivusihnzejxtoaljajmwazmeyoxodtgfnhsawbmbjcptsqwzrrlirrncipztqvkosqcyfyqfvbdnhwlmotffcbxczakkxqaynkemgwvdniaxrkvsskryiphzqpcgbsmixjfbdtxeemtbwydwgywxxofsayqohghjahnbsfwaqpzpbzofokykfcvlelnqhjnkdkvsigffqfebnkfjqumrkxcjlxubcpbpkhzddyhalpqrvjeduxpugfijyfgbzdhqfcwpoixmotpzybhfzgflhtqsublszjpeyagozzlxopflouxprnazfkyyklromjiwqqwijmorlkyykfzanrpxuolfpoxlzzogayepjzslbusqthlfgzfhbyzptomxiopwcfqhdzbgfyjifgupxudejvrqplahyddzhkpbpcbuxljcxkrmuqjfknbefqffgisvkdknjhqnlelvcfkykofozbpzpqawfsbnhajhghoqyasfoxxwygwdywbtmeextdbfjximsbgcpqzhpiyrkssvkrxaindvwgmeknyaqxkkazcxbcfftomlwhndbvfqyfycqsokvqtzpicnrrilrrzwqstpcjbmbwashnfgtdoxoyemzawmjajlaotxjeznhisuvigisjovzoraiuwmruipssrfhzjartnxjzhwqwoyrzbdsidrmzblxeukorqxwpatcrcxfdzmbzcqyjpxdqqcslnavqhftunnkdxyzxtfqiwebzlbvcditdwaijtrlgsknyhspfgsorkmbefkidtobgxtksukdefrwmodaziramdifmoqaemvbojbtvvvokondjrcjtwwdeupnqedwpgwtggzakusplamaaclhbuaflueqorkdcvscodznjlvandmiemwtjdazghxobsmhmuobjidwejhdzkxuuogpdvmglluvegggdpzevhumrfpeedxdcavxicbqmiccpqtfhrqruklwlsiticpqtkdmclehzvrdjwztlzkniteulcmedewljutncvxcgbhbgzikddfumfihyrdgiinmrlpakrrrmpqhpcxbpoxpgczfjxfwfcjokfffhvmewytepxqfqqpavdsbwqdqzzjbstrouelbclrlknmjovmfbbniuaoncghebwpdqbuxehzteypukhdecgazlhjoswubsjryvkhjhzcopaakmxfxbevnkpfmgctjncaoasnvibmsmgvaghxvsgagqtcvrnxfkfltcmfnxbmjiwyqizpbujubqkimjcdegohwyfizerjgoodyzuxbytwayyivetsxkdrokmzgdfoulshixbsjjdbjjibbivcylvtprkwfoqxikscgjliiezndpyabgnpzpqntdczwbyetbagqkzumvqbcbwjfuwzdyasesriamflvmbjyxkbyvxbhzruligczwgmrxbipqwktvbuhjncurgyfwujatnejrbuygcqicmoascxpbmgqxsdcwxxywccvdolkwxicrtuatvzzhutbtwvbwugfjfynpmhuoadkqbibqjruvlhzapdhcibkhkqpbazknuayjnfhqeyrqzvktftntwwzneeftzguqxdhjhsooysqbwcnjifvaheiimyjkisxufvyhtmaoopeafsysoldyybeonhjktfviootyzdzxnyshqfnztswsyrudxlqhtdiglfsvgmdfpnojnmlrfuycwwtvivqqwvmgenzwcmqukcyaufdslxrnstrerwqlcljiejuoxngozgivilbbifrcwhprdjlhvscdglkzphxfyaqmremapeznxdqlgenxuaehwpbvwmkhkwnfuuaoqcaesymhxkvdovfuialpbtmhbcazhimzeakrtfpllgymeqsrhqksjdlaiatayfscvaijbcdxbhlygctdzehjptreimxiplgxnqfsvwexcprjdrdimzprbyxhaqqpqsclyohjzlpnwvoyvtdvqabqlqmphrjcgwqhveycoqjzcoroqfduucvuvicfjabowrosnxiyvtbdkfuvwiopwflbghfpxxkpnmlzrehqwmmiklzhqgcwvgoaxkihtqkofaeuaslfmwsxbrvdtttjzzmqlpkohbualfjpnfezcvzbxtkiwnjuuvzpmduawcsnwpcwmuhyvnxuyerhlapbhxfbwblnimkdltgrjavyzmoyuncobysmkvxiijukmjzevuwlleseogenqgonzgwbmgxgxegzdzcxdebhkdwgarqzvvdqeqoqfrybgpovjdsrtrmiqqdgcvjlotgwwuutyxvtqidcykuzwcdpavaxtxldgepwuncrdeowsunecwlktvvnywwjgycuxyyclazfbjvxuihlcplyowgpsahcxdpqajgkrodnwdnbbcoogvdzcsxaydlufwtzwvwqxtyrqfjkpraiiufjejeqqovwnhikcgfpigfyhchgoqzeqdybbskcoztxvbgadtzuzstqviaohxlcuavqvsejetjnkqwfbxoowfqgkfabdkjiarfrvztjwybubewnhlimwnkkggredoixcfjylmchlwxxkufgzmvliptmfsmuzmnjmiuvaivofyobdmancaxtsxxggrutuvsmftdcenwlxfgqlvhvxhnciipyxuyosredcqndsixcedpoprfvnraotoikapjcvvsvtcvnldgdihamxefpkhonezpldrikukbsmodspmzbkebqowpeoasjidjrczcjwmjaygywsyqggwdyncoozpyqjvxavwzxwfeojnsmygofxuzxyxchoiumtkklamkmnwjsgkiwlwzunymvewdsibawewqlcongkucwdlacjtrdhefqffhoetkqryynmcsjvcweitfcrkkuxydotvhnsyjavbimocunqjgkieryjgozssrbtawykgqjsutxzjjwqjrmjxfchdasbbndqjobcryrqhbnafyenhfxvldkawkfqcvsquvfikfbvgnpjndpypqvjsseoqyeimiizjpkimiywrzqktepzebcobwcyxiexdckeyscmxicrlqptjhjvuigrbbanqlycxqptpwuuovszgewmqprbetqzujhfjfjpaeanvonyqizvieiesmovposmpzvuwokbuassiyvyoedufvrzkivkwyqykpxsoyifwpviohpffmwrxyrcofkebpartzyicubqwzckirtqewbcjpimhmznzbarcezedpafathovojvflekuwotwobvrvncypllvhdzqxmignyczzdxghoelvczmaqdydcxvienvybxaeexqjhckejweonccocucylwhtjecsjxbqmeisumvyqrorzuwmsqppacpmvohkbdrnvqokkvdjqctfvfkpjlwxncvjqdcqitcxiblniuggfetjipxszqgfrowugxkbmnrjxovydrfttdgludlcmexneofvuwqixmoxtxnkiqpsxzoaiiofpkkewaemkamhpmwbwshalijtdllbjneufstyzqutlsenfzwjzfegtcvgmqtgbllddmbtkfbiloylkehquiebxyqniwagnwyvnnfjasnebebxvpzdajuusepcpmygeoowjhywhocsvinzgkesgcobhefyvuleumemmvaugfygkfyxykqtfurtlxhtigwttzeeyjvyrwcoavpklamuptuzvoccwrqhenzbjxuwebrvmhyhabawbjvzlkzaobbexovcwhihvsczmkslxgtstiijgcmoxvjxdbvwqfpwfhjcntbqjocamledarzfhulohkcactokvqirscsyshxfcrahpvubussfehbljqgxswtesacwmzaxkprjmnqgwbynlojrtiomieihchkrpbywdbotlpqvisxtchuaisxfutckwmohpiiamffreutdmspjxfdeclbeyvfflqpzfkytjspoklcblnkjvhapzergcnjfjtiqjkeynmtgssigutyyffsffkyrjeepundvmlakbsmmtmwnjtaljkrihlqqtoelysvhavwxnndoiyahsmbchpxjvwnmxbplsrcqwzesfmdgmgokdjyuzqezwndlprxgydcpeyvcchlzlkxkypqxwavzlehaoffhgronnqwaqebbfukvdyqpudvfzfvdoltwfwzuojlisjklxlrrkufaygasnbgkhdxdtkmtqxjntkjlspqlclvwfqiywnxbrglqjrgomxoauzxsmtkudjenbbmurnlgonbabdhntrztawqbpizbbztwghrzqxbzrnuondfumxanbikxnycnrooxdhvsoesptfhhmetdbknjgmmvhnscrwvtxsdncjujneuznmnbnpnbqzmrvxmoudqmulbwnuvvnsfmtpnkgwohxobtpxxtftwytgkxkqoetokmfoubhgjehkcdyanjdepvxznccemqtpgadjathbtoullucahgnmdzgzjiohqbbyziojshgxauhffzrgzokdfdrfdvdnhghzmrlencqcgpmcmybjvdxalgwrkvmwhwumwmonwkpbcdanflrxobnckafudnoivjudcykeqzvumfwtprzagpqcfihblayuigvanirzaqmbwwbfuxpaarumgiktmwkkwalcazabfsjputkgwtobcpmxulbjvihcvuqoxaudxojelkewjlhcgwtsetbcuunpvfywwkxixditzijqubwiieckzzlgtdjyfnwizbjvyzuwvpxvlasclvmhpvweuarvohopvvhpllaujpusywtyalqqbhjghheruiflyzcluhhpbtevswdgqeeohhvxwycymlfqxxijpkqzhlgmmhkgfcsntrtqzniclzottpvplxmrdvgujbtyihgtljrtrrwuladvexqtbfmrwhmgbkbwoujzhgdrlappwdcudcjrkdervnyysgrbshlzkhfwyuvwtuaftjdxuujmeewzijswbkynwgisyspfetyywtqoyrbzalytdvyvsgskxohoahdjbrikhtyomvkormooeypmxmrwuhnbdiauederjukwjkbxyuekuagaknfdfmptxtidoxxordwurgqiaaicwtilwmlayxeumlfvgfwrzpbuhujkdoefcfqsqpsnrcwcdepilgigptunezhskbvpcgxnsjirriigphtgfyjtukglmxgxzacnrdimmuleuzfvmdzwogzrtecnmoovbdccvbreydueyqjwwemvogwhgturupcfanqwrssqprsazouelaqerkwljxwyskxrbcjfffggsplekod\"\n```"
                    }
                ]
            },
            {
                "id": 1732172,
                "content": [
                    {
                        "username": "aiswaryaa",
                        "content": "give tip"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "start checking form start and end index,,,whenever it hits that (start!=end) ,then pass it to another function which will check the reamin string is palindrome or not ,if its true return true ,otherwise false...  \n\n    NOTE: in the second function call u must have check two condition ,\n1st increase the starting index by one and check but the end index remains same (in this casse it  will ignore the 1st character from starting index) \n\nand 2nd one is: increase the end index by one, here start will be same (thus it willl check after ignoring the last index) and u have to check both the conditions ,to cover all the edge cases...\n"
                    },
                    {
                        "username": "varsha1531",
                        "content": "bool validPalindrome(string s) {\n      \n      int c=0;\n      int j=s.length()-1,i=0;\n      while(i<=j)\n      {\n          if(s[i]==s[j])\n          {\n              j--;\n              i++;\n          }\n          else \n          {\n              if(s[i]==s[j-1] )\n              {\n                  j=j-2;\n                  c++;\n                  i++;\n              }\n              else if(s[i+1]==s[j])\n              {\n                  i=i+2;\n                  c++;\n                  j--;\n              }\n              else{\n                  return false;\n              }\n          }\n          \n      }\n      \nreturn c<=1;\n     \n    } \nplz help me where am i going wrong\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": " `Consider this - ebcbbececabbacecbbcbe`\n \nI can't figure out why the LeetCode compiler refuses to accept my solution for \"ebcbbececabbacecbbcbe\" specific given input  [the input String isn't a palindrome at all ] . Can anyone lend a hand? Any insights or suggestions to resolve this compiler error would be greatly appreciated. Help me crack this puzzle.........\n"
                    },
                    {
                        "username": "vedranson",
                        "content": "First and last 5 chars: \\'ebcbb [...] bbcbe\\' make a valid palindrome. The rest is now \\'ececabbacec\\'. If you were to delete/ignore the leading \\'e\\', the rest \\'cecabbacec\\' is a valid palindrome."
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me figure out why my code is showing incorrect output for this string \"lfhnzyffurnskdlduhopgrssphgnbaxtuzmlwsxzamjtdqymgmmmmgmyxqdtjmazxwlmzutxabnghpssrgpohudldksnruffyznhfl\"\\nMy code is showing true but expected output is false. Can someone help me figure out what is wrong in my code \\n```class Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        int flag = 0;\\n        char uh;\\n        while(i<j)\\n        {\\n          while(!isalnum(s[i]))\\n          {\\n              i++;\\n          }\\n          while(!isalnum(s[j]))\\n          {\\n              j--;\\n          }\\n\\n          if(!(s[i]==s[j]) && flag==0)\\n          {\\n            flag =1;\\n            if (s[i + 1] == s[j])\\n            {\\n                i++;\\n                uh = s[i];\\n            }\\n\\n            else if (s[i] == s[j - 1])\\n            {\\n                uh = s[j];\\n                j--;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n          }\\n          \\n          else if(!(s[i]==s[j]) && flag==1)\\n          {\\n              if((s[i]==uh || s[j]==uh))\\n              {\\n                if (s[i] == uh)\\n                    i++;\\n                else if (s[j] == uh)\\n                    j--;\\n              }\\n              else\\n              {\\n                  return false;\\n              }\\n          }\\n          else\\n          {\\n             i++;\\n             j--;\\n          }\\n        }\\n        return true;\\n    }\\n};```"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Got it, I was removing all occurrences of the character"
                    },
                    {
                        "username": "10xvishal",
                        "content": "\"woicvixviciow\" why is this supposed to be false, after neglecting i its a valid palindrome \"wocvxvcow\""
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "you have to remove just 1 char in your input to make it a valid palindrome"
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "seems that a testcase \"tebbem\" expects `false`. is \"ebbe\" not a valid palindrome? [@LeetCode](/LeetCode) ?"
                    },
                    {
                        "username": "10xvishal",
                        "content": "you will only get \"tebbe\" or \"ebbem\" after removing single char."
                    },
                    {
                        "username": "ankush920",
                        "content": "FULL EXPLAINED ||CODE || C++ ||0(N)\\nankush920\\n0\\nin a minute\\nIntuition\\nokk sit relax don\\'t frustate it\\'s easy but slightly different .\\n\\nremember must one mean --> can delete 0 or 1 character only\\nusing two pointer approach :-\\n-> i--> intial pointer , j--> final pointer\\n-> travese it from end , start both side (i++ , j-- );\\n-> if s[i] == s[j] --> satisfy palindrom condition okk go forward\\n->but if s[i] != s[j] so we can do two thing\\neither remove from left side ( i side deletion ) or righr side (j side deletion)\\n\\n(find useful upvote it vro :) )\\n-> i am choosing left first and right next and use counter( countI and countJ) to know whether i have chance to remove from left /right side or not\\n\\n**note i am not deleting from both side in my deletion condition box there is condition like that only one char is delete\\n\\n--> i use storeI and storeJ to for the remember point that where first inequality come and i was used my deletion power ( delete one character)\\nbecause in testcase like :-\\nif first inequality is come in string i go with \\'i\\' side deletion and it satisfy upto some length but not make my string completly palindromic because \\'j\\' side deletion make complete palindromic to my string so , at that i cann\\'t do \\'j\\' side deletion on present index\\n(it delete two character) i use that index where my first inequality ( or on which i use my i side is required to do it ** we only delete one character max**)\\n\\nso if both possibility fail mean (we check from i ,j side deletion )\\nreturn false otherwise true\\n\\nApproach\\nlinear traversal\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    bool validPalindrome(string s) {\\n        \\n        int n = s.size();\\n        if( n  ==1)\\n        {\\n             return n;\\n        }\\n\\nint i = 0 , j = n-1;\\n\\nint countI = 0;\\nint countJ= 0;\\nint storeI =0;\\nint storeJ =0;\\n    while( i<=j)\\n    {\\n      \\n      if( s[i]!=s[j])\\n      {\\n          if( !countI)\\n          {\\n              countI=1;\\n              storeI =i;\\n              storeJ =j;\\n              i++;\\n              continue;\\n          }\\n\\n          if(!countJ)\\n          {\\n             i= storeI;\\n             j= storeJ; \\n             countJ =1;\\n             j--;\\n             continue;\\n          }\\n          return 0;\\n      }\\n\\n      i++;\\n      j--;\\n    }\\n\\nreturn true ;\\n    }\\n};"
                    },
                    {
                        "username": "Ardonite",
                        "content": "Hi,\\n\\nhow can expected be \"false\"?\\nIt must be true right?\\n\\nInput\\ns = \"tebbem\"\\n\\nOutput\\ntrue\\n\\nExpected\\nfalse"
                    },
                    {
                        "username": "underprocess",
                        "content": "you must remove t and m to make it palindrome but according to question s can be palindrome after deleting at most one character from it.so false."
                    },
                    {
                        "username": "darkpheonix2_O",
                        "content": "If you are unable to come up with any solution, think it like you skip one character from left and check for valid palindrome, if no solution is found save that index and now skip the right index to check for valid palindrome, it no valid palindrome is found then answer is false else true. Use two pointers left and right to check for valid palindrome."
                    },
                    {
                        "username": "aknownymous",
                        "content": "#### Can Someone tell me, how can I reduce its time complexity? Passes all the case except 402th. \n```\nclass Solution:\n    def pal(self,s):\n        if s==s[::-1]: return True\n        return False\n    def validPalindrome(self, s: str) -> bool:\n        if self.pal(s): return True\n        for i in range(len(s)):\n            c= list(s)\n            c.pop(i)\n            if self.pal(c): return True\n        return False\n```\n\n\n#### Test Case :\n```\n\"okelpsggfffjcbrxksywxjlwkreqaleuozasrpqssrwqnafcpurutghwgovmewwjqyeudyerbvccdbvoomncetrzgowzdmvfzuelummidrncazxgxmlgkutjyfgthpgiirrijsnxgcpvbkshzenutpgiglipedcwcrnspqsqfcfeodkjuhubpzrwfgvflmuexyalmwlitwciaaiqgruwdroxxoditxtpmfdfnkagaukeuyxbkjwkujredeuaidbnhuwrmxmpyeoomrokvmoythkirbjdhaohoxksgsvyvdtylazbryoqtwyytefpsysigwnykbwsjizweemjuuxdjtfautwvuywfhkzlhsbrgsyynvredkrjcducdwppalrdghzjuowbkbgmhwrmfbtqxevdaluwrrtrjltghiytbjugvdrmxlpvpttozlcinzqtrtnscfgkhmmglhzqkpjixxqflmycywxvhhoeeqgdwsvetbphhulczylfiurehhgjhbqqlaytwysupjuallphvvpohovrauewvphmvlcsalvxpvwuzyvjbziwnfyjdtglzzkceiiwbuqjiztidxixkwwyfvpnuucbtestwgchljweklejoxduaxoquvchivjbluxmpcbotwgktupjsfbazaclawkkwmtkigmuraapxufbwwbmqazrinavgiuyalbhifcqpgazrptwfmuvzqekycdujviondufakcnboxrlfnadcbpkwnomwmuwhwmvkrwglaxdvjbymcmpgcqcnelrmzhghndvdfrdfdkozgrzffhuaxghsjoizybbqhoijzgzdmnghaculluotbhtajdagptqmeccnzxvpedjnaydckhejghbuofmkoteoqkxkgtywtftxxptboxhowgknptmfsnvvunwblumqduomxvrmzqbnpnbnmnzuenjujcndsxtvwrcsnhvmmgjnkbdtemhhftpseosvhdxoorncynxkibnaxmufdnounrzbxqzrhgwtzbbzipbqwatzrtnhdbabnoglnrumbbnejduktmsxzuaoxmogrjqlgrbxnwyiqfwvlclqpsljktnjxqtmktdxdhkgbnsagyafukrrlxlkjsiljouzwfwtlodvfzfvdupqydvkufbbeqawqnnorghffoahelzvawxqpykxklzlhccvyepcdygxrpldnwzeqzuyjdkogmgdmfsezwqcrslpbxmnwvjxphcbmshayiodnnxwvahvsyleotqqlhirkjlatjnwmtmmsbkalmvdnupeejrykffsffyytugissgtmnyekjqitjfjncgrezpahvjknlbclkopsjtykfzpqlffvyeblcedfxjpsmdtuerffmaiiphomwkctufxsiauhctxsivqpltobdwybprkhchieimoitrjolnybwgqnmjrpkxazmwcasetwsxgqjlbhefssubuvpharcfxhsyscsriqvkotcackholuhfzradelmacojqbtncjhfwpfqwvbdxjvxomcgjiitstgxlskmzcsvhihwcvoxebboazklzvjbwabahyhmvrbewuxjbznehqrwccovzutpumalkpvaocwryvjyeezttwgithxltruftqkyxyfkgyfguavmmemueluvyfehbocgsekgznivscohwyhjwooegympcpesuujadzpvxbebensajfnnvywngawinqyxbeiuqheklyolibfktbmddllbgtqmgvctgefzjwzfnesltuqzytsfuenjblldtjilahswbwmphmakmeawekkpfoiiaozxspqiknxtxomxiqwuvfoenxemcldulgdttfrdyvoxjrnmbkxguworfgqzsxpijtefgguinlbixctiqcdqjvcnxwljpkfvftcqjdvkkoqvnrdbkhovmpcappqsmwuzrorqyvmusiemqbxjscejthwlycucoccnoewjekchjqxeeaxbyvneivxcdydqamzcvleohgxdzzcyngimxqzdhvllpycnvrvbowtowukelfvjovohtafapdezecrabznzmhmipjcbweqtrikczwqbuciyztrapbekfocryxrwmffphoivpwfiyosxpkyqywkvikzrvfudeoyvyissaubkowuvzpmsopvomseieivziqynovnaeapjfjfhjuzqtebrpqmwegzsvouuwptpqxcylqnabbrgiuvjhjtpqlrcixmcsyekcdxeixycwbocbezpetkqzrwyimikpjziimieyqoessjvqpypdnjpngvbfkifvuqsvcqfkwakdlvxfhneyfanbhqryrcbojqdnbbsadhcfxjmrjqwjjzxtusjqgkywatbrsszogjyreikgjqnucomibvajysnhvtodyxukkrcftiewcvjscmnyyrqkteohffqfehdrtjcaldwcukgnoclqwewabisdwevmynuzwlwikgsjwnmkmalkktmuiohcxyxzuxfogymsnjoefwxzwvaxvjqypzoocnydwggqyswygyajmwjczcrjdijsaoepwoqbekbzmpsdomsbkukirdlpzenohkpfexmahidgdlnvctvsvvcjpakiotoarnvfrpopdecxisdnqcdersoyuxypiicnhxvhvlqgfxlwnecdtfmsvuturggxxstxacnamdboyfoviavuimjnmzumsfmtpilvmzgfukxxwlhcmlyjfcxioderggkknwmilhnwebubywjtzvrfraijkdbafkgqfwooxbfwqknjtejesvqvauclxhoaivqtszuztdagbvxtzocksbbydqezqoghchyfgipfgckihnwvoqqejejfuiiarpkjfqrytxqwvwztwfuldyaxsczdvgoocbbndwndorkgjaqpdxchaspgwoylpclhiuxvjbfzalcyyxucygjwwynvvtklwcenuswoedrcnuwpegdlxtxavapdcwzukycdiqtvxytuuwwgtoljvcgdqqimrtrsdjvopgbyrfqoqeqdvvzqragwdkhbedxczdzgexgxgmbwgznogqnegoesellwuvezjmkujiixvkmsybocnuyomzyvajrgtldkminlbwbfxhbpalhreyuxnvyhumwcpwnscwaudmpzvuujnwiktxbzvczefnpjflaubhokplqmzzjtttdvrbxswmflsaueafokqthikxaogvwcgqhzlkimmwqherzlmnpkxxpfhgblfwpoiwvufkdbtvyixnsorwobajfcivuvcuudfqoroczjqocyevhqwgcjrhpmqlqbaqvdtvyovwnplzjhoylcsqpqqahxybrpzmidrdjrpcxewvsfqnxglpixmiertpjhezdtcgylhbxdcbjiavcsfyataialdjskqhrsqemygllpftrkaezmihzacbhmtbplaiufvodvkxhmyseacqoauufnwkhkmwvbpwheauxneglqdxnzepamermqayfxhpzklgdcsvhljdrphwcrfibblivigzognxoujeijlclqwrertsnrxlsdfuayckuqmcwznegmvwqqvivtwwcyufrlmnjonpfdmgvsflgidthqlxduryswstznfqhsynxzdzytooivftkjhnoebyydlosysfaepooamthyvfuxsikjymiiehavfijncwbqsyooshjhdxqugztfeenzwwtntftkvzqryeqhfnjyaunkzabpqkhkbichdpazhlvurjqbibqkdaouhmpnyfjfguwbvwtbtuhzzvtautrcixwklodvccwyxxwcdsxqgmbpxcsaomciqcgyubrjentajuwfygrucnjhubvtkwqpibxrmgwzcgilurzhbxvybkxyjbmvlfmairsesaydzwufjwbcbqvmuzkqgabteybwzcdtnqpzpngbaypdnzeiiljgcskixqofwkrptvlycvibbijjbdjjsbxihsluofdgzmkordkxsteviyyawtybxuzydoogjrezifywhogedcjmikqbujubpziqywijmbxnfmctlfkfxnrvctqgagsvxhgavgmsmbivnsaoacnjtcgmfpknvebxfxmkaapoczhjhkvyrjsbuwsojhlzagcedhkupyetzhexubqdpwbehgcnoauinbbfmvojmnklrlcbleuortsbjzzqdqwbsdvapqqfqxpetywemvhfffkojcfwfxjfzcgpxopbxcphqpmrrrkaplrmniigdryhifmufddkizgbhbgcxvcntujlwedemcluetinkzltzwjdrvzhelcmdktqpcitislwlkurqrhftqpccimqbcixvacdxdeepfrmuhvezpdgggevullgmvdpgouuxkzdhjewdijboumhmsboxhgzadjtwmeimdnavljnzdocsvcdkroqeulfaubhlcaamalpsukazggtwgpwdeqnpuedwwtjcrjdnokovvvtbjobvmeaqomfidmarizadomwrfedkusktxgbotdikfebmkrosgfpshynksglrtjiawdtidcvblzbewiqftxzyxdknnutfhqvanlscqqdxpjyqczbmzdfxcrctapwxqrokuexlbzmrdisdbzryowqwhzjxntrajzhfrsspiurmwuiarozvojsigivusihnzejxtoaljajmwazmeyoxodtgfnhsawbmbjcptsqwzrrlirrncipztqvkosqcyfyqfvbdnhwlmotffcbxczakkxqaynkemgwvdniaxrkvsskryiphzqpcgbsmixjfbdtxeemtbwydwgywxxofsayqohghjahnbsfwaqpzpbzofokykfcvlelnqhjnkdkvsigffqfebnkfjqumrkxcjlxubcpbpkhzddyhalpqrvjeduxpugfijyfgbzdhqfcwpoixmotpzybhfzgflhtqsublszjpeyagozzlxopflouxprnazfkyyklromjiwqqwijmorlkyykfzanrpxuolfpoxlzzogayepjzslbusqthlfgzfhbyzptomxiopwcfqhdzbgfyjifgupxudejvrqplahyddzhkpbpcbuxljcxkrmuqjfknbefqffgisvkdknjhqnlelvcfkykofozbpzpqawfsbnhajhghoqyasfoxxwygwdywbtmeextdbfjximsbgcpqzhpiyrkssvkrxaindvwgmeknyaqxkkazcxbcfftomlwhndbvfqyfycqsokvqtzpicnrrilrrzwqstpcjbmbwashnfgtdoxoyemzawmjajlaotxjeznhisuvigisjovzoraiuwmruipssrfhzjartnxjzhwqwoyrzbdsidrmzblxeukorqxwpatcrcxfdzmbzcqyjpxdqqcslnavqhftunnkdxyzxtfqiwebzlbvcditdwaijtrlgsknyhspfgsorkmbefkidtobgxtksukdefrwmodaziramdifmoqaemvbojbtvvvokondjrcjtwwdeupnqedwpgwtggzakusplamaaclhbuaflueqorkdcvscodznjlvandmiemwtjdazghxobsmhmuobjidwejhdzkxuuogpdvmglluvegggdpzevhumrfpeedxdcavxicbqmiccpqtfhrqruklwlsiticpqtkdmclehzvrdjwztlzkniteulcmedewljutncvxcgbhbgzikddfumfihyrdgiinmrlpakrrrmpqhpcxbpoxpgczfjxfwfcjokfffhvmewytepxqfqqpavdsbwqdqzzjbstrouelbclrlknmjovmfbbniuaoncghebwpdqbuxehzteypukhdecgazlhjoswubsjryvkhjhzcopaakmxfxbevnkpfmgctjncaoasnvibmsmgvaghxvsgagqtcvrnxfkfltcmfnxbmjiwyqizpbujubqkimjcdegohwyfizerjgoodyzuxbytwayyivetsxkdrokmzgdfoulshixbsjjdbjjibbivcylvtprkwfoqxikscgjliiezndpyabgnpzpqntdczwbyetbagqkzumvqbcbwjfuwzdyasesriamflvmbjyxkbyvxbhzruligczwgmrxbipqwktvbuhjncurgyfwujatnejrbuygcqicmoascxpbmgqxsdcwxxywccvdolkwxicrtuatvzzhutbtwvbwugfjfynpmhuoadkqbibqjruvlhzapdhcibkhkqpbazknuayjnfhqeyrqzvktftntwwzneeftzguqxdhjhsooysqbwcnjifvaheiimyjkisxufvyhtmaoopeafsysoldyybeonhjktfviootyzdzxnyshqfnztswsyrudxlqhtdiglfsvgmdfpnojnmlrfuycwwtvivqqwvmgenzwcmqukcyaufdslxrnstrerwqlcljiejuoxngozgivilbbifrcwhprdjlhvscdglkzphxfyaqmremapeznxdqlgenxuaehwpbvwmkhkwnfuuaoqcaesymhxkvdovfuialpbtmhbcazhimzeakrtfpllgymeqsrhqksjdlaiatayfscvaijbcdxbhlygctdzehjptreimxiplgxnqfsvwexcprjdrdimzprbyxhaqqpqsclyohjzlpnwvoyvtdvqabqlqmphrjcgwqhveycoqjzcoroqfduucvuvicfjabowrosnxiyvtbdkfuvwiopwflbghfpxxkpnmlzrehqwmmiklzhqgcwvgoaxkihtqkofaeuaslfmwsxbrvdtttjzzmqlpkohbualfjpnfezcvzbxtkiwnjuuvzpmduawcsnwpcwmuhyvnxuyerhlapbhxfbwblnimkdltgrjavyzmoyuncobysmkvxiijukmjzevuwlleseogenqgonzgwbmgxgxegzdzcxdebhkdwgarqzvvdqeqoqfrybgpovjdsrtrmiqqdgcvjlotgwwuutyxvtqidcykuzwcdpavaxtxldgepwuncrdeowsunecwlktvvnywwjgycuxyyclazfbjvxuihlcplyowgpsahcxdpqajgkrodnwdnbbcoogvdzcsxaydlufwtzwvwqxtyrqfjkpraiiufjejeqqovwnhikcgfpigfyhchgoqzeqdybbskcoztxvbgadtzuzstqviaohxlcuavqvsejetjnkqwfbxoowfqgkfabdkjiarfrvztjwybubewnhlimwnkkggredoixcfjylmchlwxxkufgzmvliptmfsmuzmnjmiuvaivofyobdmancaxtsxxggrutuvsmftdcenwlxfgqlvhvxhnciipyxuyosredcqndsixcedpoprfvnraotoikapjcvvsvtcvnldgdihamxefpkhonezpldrikukbsmodspmzbkebqowpeoasjidjrczcjwmjaygywsyqggwdyncoozpyqjvxavwzxwfeojnsmygofxuzxyxchoiumtkklamkmnwjsgkiwlwzunymvewdsibawewqlcongkucwdlacjtrdhefqffhoetkqryynmcsjvcweitfcrkkuxydotvhnsyjavbimocunqjgkieryjgozssrbtawykgqjsutxzjjwqjrmjxfchdasbbndqjobcryrqhbnafyenhfxvldkawkfqcvsquvfikfbvgnpjndpypqvjsseoqyeimiizjpkimiywrzqktepzebcobwcyxiexdckeyscmxicrlqptjhjvuigrbbanqlycxqptpwuuovszgewmqprbetqzujhfjfjpaeanvonyqizvieiesmovposmpzvuwokbuassiyvyoedufvrzkivkwyqykpxsoyifwpviohpffmwrxyrcofkebpartzyicubqwzckirtqewbcjpimhmznzbarcezedpafathovojvflekuwotwobvrvncypllvhdzqxmignyczzdxghoelvczmaqdydcxvienvybxaeexqjhckejweonccocucylwhtjecsjxbqmeisumvyqrorzuwmsqppacpmvohkbdrnvqokkvdjqctfvfkpjlwxncvjqdcqitcxiblniuggfetjipxszqgfrowugxkbmnrjxovydrfttdgludlcmexneofvuwqixmoxtxnkiqpsxzoaiiofpkkewaemkamhpmwbwshalijtdllbjneufstyzqutlsenfzwjzfegtcvgmqtgbllddmbtkfbiloylkehquiebxyqniwagnwyvnnfjasnebebxvpzdajuusepcpmygeoowjhywhocsvinzgkesgcobhefyvuleumemmvaugfygkfyxykqtfurtlxhtigwttzeeyjvyrwcoavpklamuptuzvoccwrqhenzbjxuwebrvmhyhabawbjvzlkzaobbexovcwhihvsczmkslxgtstiijgcmoxvjxdbvwqfpwfhjcntbqjocamledarzfhulohkcactokvqirscsyshxfcrahpvubussfehbljqgxswtesacwmzaxkprjmnqgwbynlojrtiomieihchkrpbywdbotlpqvisxtchuaisxfutckwmohpiiamffreutdmspjxfdeclbeyvfflqpzfkytjspoklcblnkjvhapzergcnjfjtiqjkeynmtgssigutyyffsffkyrjeepundvmlakbsmmtmwnjtaljkrihlqqtoelysvhavwxnndoiyahsmbchpxjvwnmxbplsrcqwzesfmdgmgokdjyuzqezwndlprxgydcpeyvcchlzlkxkypqxwavzlehaoffhgronnqwaqebbfukvdyqpudvfzfvdoltwfwzuojlisjklxlrrkufaygasnbgkhdxdtkmtqxjntkjlspqlclvwfqiywnxbrglqjrgomxoauzxsmtkudjenbbmurnlgonbabdhntrztawqbpizbbztwghrzqxbzrnuondfumxanbikxnycnrooxdhvsoesptfhhmetdbknjgmmvhnscrwvtxsdncjujneuznmnbnpnbqzmrvxmoudqmulbwnuvvnsfmtpnkgwohxobtpxxtftwytgkxkqoetokmfoubhgjehkcdyanjdepvxznccemqtpgadjathbtoullucahgnmdzgzjiohqbbyziojshgxauhffzrgzokdfdrfdvdnhghzmrlencqcgpmcmybjvdxalgwrkvmwhwumwmonwkpbcdanflrxobnckafudnoivjudcykeqzvumfwtprzagpqcfihblayuigvanirzaqmbwwbfuxpaarumgiktmwkkwalcazabfsjputkgwtobcpmxulbjvihcvuqoxaudxojelkewjlhcgwtsetbcuunpvfywwkxixditzijqubwiieckzzlgtdjyfnwizbjvyzuwvpxvlasclvmhpvweuarvohopvvhpllaujpusywtyalqqbhjghheruiflyzcluhhpbtevswdgqeeohhvxwycymlfqxxijpkqzhlgmmhkgfcsntrtqzniclzottpvplxmrdvgujbtyihgtljrtrrwuladvexqtbfmrwhmgbkbwoujzhgdrlappwdcudcjrkdervnyysgrbshlzkhfwyuvwtuaftjdxuujmeewzijswbkynwgisyspfetyywtqoyrbzalytdvyvsgskxohoahdjbrikhtyomvkormooeypmxmrwuhnbdiauederjukwjkbxyuekuagaknfdfmptxtidoxxordwurgqiaaicwtilwmlayxeumlfvgfwrzpbuhujkdoefcfqsqpsnrcwcdepilgigptunezhskbvpcgxnsjirriigphtgfyjtukglmxgxzacnrdimmuleuzfvmdzwogzrtecnmoovbdccvbreydueyqjwwemvogwhgturupcfanqwrssqprsazouelaqerkwljxwyskxrbcjfffggsplekod\"\n```"
                    }
                ]
            }
        ]
    }
]