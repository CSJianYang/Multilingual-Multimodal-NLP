[
    {
        "title": "Longest ZigZag Path in a Binary Tree",
        "question_content": "You are given the root of a binary tree.\nA ZigZag path for a binary tree is defined as follow:\n\n\tChoose any node in the binary tree and a direction (right or left).\n\tIf the current direction is right, move to the right child of the current node; otherwise, move to the left child.\n\tChange the direction from right to left or from left to right.\n\tRepeat the second and third steps until you can't move in the tree.\n\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\nReturn the longest ZigZag path contained in that tree.\n&nbsp;\nExample 1:\n\nInput: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\nOutput: 3\nExplanation: Longest ZigZag path in blue nodes (right -> left -> right).\n\nExample 2:\n\nInput: root = [1,1,1,null,1,null,null,1,1,null,1]\nOutput: 4\nExplanation: Longest ZigZag path in blue nodes (left -> right -> left -> right).\n\nExample 3:\n\nInput: root = [1]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 5 * 104].\n\t1 <= Node.val <= 100",
        "solutions": [
            {
                "id": 531867,
                "title": "java-python-dfs-solution",
                "content": "## **Explanation**\\nRecursive return `[left, right, result]`, where:\\n`left` is the maximum length in direction of `root.left`\\n`right` is the maximum length in direction of `root.right`\\n`result` is the maximum length in the whole sub tree.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(height)`\\n<br>\\n\\n**Java**\\n```java\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root)[2];\\n    }\\n\\n    private int[] dfs(TreeNode root) {\\n        if (root == null) return new int[]{-1, -1, -1};\\n        int[] left = dfs(root.left), right = dfs(root.right);\\n        int res = Math.max(Math.max(left[1], right[0]) + 1, Math.max(left[2], right[2]));\\n        return new int[]{left[1] + 1, right[0] + 1, res};\\n    }\\n```\\n**C++**\\nby @SuperWhw\\n```cpp\\n    int longestZigZag(TreeNode* root) {\\n        return dfs(root)[2];\\n    }\\n\\n    vector<int> dfs(TreeNode* root) {\\n        if (!root) return { -1, -1, -1};\\n        vector<int> left = dfs(root->left), right = dfs(root->right);\\n        int res = max(max(left[1], right[0]) + 1, max(left[2], right[2]));\\n        return {left[1] + 1, right[0] + 1, res};\\n    }\\n```\\n**Python:**\\n```py\\n    def longestZigZag(self, root):\\n        def dfs(root):\\n            if not root: return [-1, -1, -1]\\n            left, right = dfs(root.left), dfs(root.right)\\n            return [left[1] + 1, right[0] + 1, max(left[1] + 1, right[0] + 1, left[2], right[2])]\\n        return dfs(root)[-1]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root)[2];\\n    }\\n\\n    private int[] dfs(TreeNode root) {\\n        if (root == null) return new int[]{-1, -1, -1};\\n        int[] left = dfs(root.left), right = dfs(root.right);\\n        int res = Math.max(Math.max(left[1], right[0]) + 1, Math.max(left[2], right[2]));\\n        return new int[]{left[1] + 1, right[0] + 1, res};\\n    }\\n```\n```cpp\\n    int longestZigZag(TreeNode* root) {\\n        return dfs(root)[2];\\n    }\\n\\n    vector<int> dfs(TreeNode* root) {\\n        if (!root) return { -1, -1, -1};\\n        vector<int> left = dfs(root->left), right = dfs(root->right);\\n        int res = max(max(left[1], right[0]) + 1, max(left[2], right[2]));\\n        return {left[1] + 1, right[0] + 1, res};\\n    }\\n```\n```py\\n    def longestZigZag(self, root):\\n        def dfs(root):\\n            if not root: return [-1, -1, -1]\\n            left, right = dfs(root.left), dfs(root.right)\\n            return [left[1] + 1, right[0] + 1, max(left[1] + 1, right[0] + 1, left[2], right[2])]\\n        return dfs(root)[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 534418,
                "title": "java-c-dfs-solution-with-comment-o-n-clean-code",
                "content": "**Java**\\n```java\\nclass Solution {\\n    int maxStep = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, true, 0);\\n        dfs(root, false, 0);\\n        return maxStep;\\n    }\\n    private void dfs(TreeNode root, boolean isLeft, int step) {\\n        if (root == null) return;\\n        maxStep = Math.max(maxStep, step); // update max step sofar\\n        if (isLeft) {\\n            dfs(root.left, false, step + 1); // keep going from root to left\\n            dfs(root.right, true, 1); // restart going from root to right\\n        } else {\\n            dfs(root.right, true, step + 1); // keep going from root to right\\n            dfs(root.left, false, 1); // restart going from root to left\\n        }\\n    }\\n}\\n```\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int maxStep = 0;\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root, true, 0);\\n        dfs(root, false, 0);\\n        return maxStep;\\n    }\\n    void dfs(TreeNode* root, bool isLeft, int step) {\\n        if (!root) return;\\n        maxStep = max(maxStep, step); // update max step sofar\\n        if (isLeft) {\\n            dfs(root->left, false, step + 1); // keep going from root to left\\n            dfs(root->right, true, 1); // restart going from root to right\\n        } else {\\n            dfs(root->right, true, step + 1); // keep going from root to right\\n            dfs(root->left, false, 1); // restart going from root to left\\n        }\\n    }\\n};\\n```\\nComplexity:\\n- Time: `O(n)`, it will visit all the nodes and each node once.\\n- Space: `O(h)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    int maxStep = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, true, 0);\\n        dfs(root, false, 0);\\n        return maxStep;\\n    }\\n    private void dfs(TreeNode root, boolean isLeft, int step) {\\n        if (root == null) return;\\n        maxStep = Math.max(maxStep, step); // update max step sofar\\n        if (isLeft) {\\n            dfs(root.left, false, step + 1); // keep going from root to left\\n            dfs(root.right, true, 1); // restart going from root to right\\n        } else {\\n            dfs(root.right, true, step + 1); // keep going from root to right\\n            dfs(root.left, false, 1); // restart going from root to left\\n        }\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxStep = 0;\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root, true, 0);\\n        dfs(root, false, 0);\\n        return maxStep;\\n    }\\n    void dfs(TreeNode* root, bool isLeft, int step) {\\n        if (!root) return;\\n        maxStep = max(maxStep, step); // update max step sofar\\n        if (isLeft) {\\n            dfs(root->left, false, step + 1); // keep going from root to left\\n            dfs(root->right, true, 1); // restart going from root to right\\n        } else {\\n            dfs(root->right, true, step + 1); // keep going from root to right\\n            dfs(root->left, false, 1); // restart going from root to left\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159847,
                "title": "c-easy-simple-traversal",
                "content": "Parameters:\\nl = count of max zigzag which reaches current Node by moving LEFT  from par  Node.\\nr = count of max zigzag which reaches current Node by moving RIGHT from par Node.\\n- Now update ans upto current node\\n- then send l+1 to RIGHT\\n- and r+1 to LEFT\\nPlease \\uD83D\\uDE4F  do upvote \\uD83D\\uDC4D if you find my solution apt\\uD83E\\uDD18\\n```\\nvoid ziggy(TreeNode* root, int l , int r, int& ans){\\n        if(!root) return;\\n         ans = max(ans, l);\\n         ans = max(ans, r);\\n        ziggy(root->left, 0, l+1, ans);\\n        \\n        ziggy(root->right, r+1, 0, ans);\\n        \\n        return;\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int l=0;\\n        int r=0;\\n        int ans=0;\\n        ziggy(root, l,r,ans);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nvoid ziggy(TreeNode* root, int l , int r, int& ans){\\n        if(!root) return;\\n         ans = max(ans, l);\\n         ans = max(ans, r);\\n        ziggy(root->left, 0, l+1, ans);\\n        \\n        ziggy(root->right, r+1, 0, ans);\\n        \\n        return;\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int l=0;\\n        int r=0;\\n        int ans=0;\\n        ziggy(root, l,r,ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433060,
                "title": "image-explanation-easy-complete-intuition-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Longest ZigZag Path in a Binary Tree` by `Aryan Mittal`\\n![Microsoft5.png](https://assets.leetcode.com/users/images/95f272ac-7e6c-4122-a4f2-eee277eae354_1681870513.1834931.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/dc700053-7e28-4c89-9ccb-9b8eea23527b_1681866335.4239633.png)\\n![image.png](https://assets.leetcode.com/users/images/8408a910-3d92-4f43-9ea9-93bad63ae219_1681866345.8971014.png)\\n![image.png](https://assets.leetcode.com/users/images/4d52de15-84e1-4195-b926-a32a5a9a9263_1681866360.3134615.png)\\n![image.png](https://assets.leetcode.com/users/images/cb3f3fb3-3880-4d9b-b53f-a17dcb8c4c69_1681866371.5972638.png)\\n![image.png](https://assets.leetcode.com/users/images/3ae64e23-b322-4456-84fe-2ee3afc519bc_1681866383.361797.png)\\n![image.png](https://assets.leetcode.com/users/images/ef889cfa-8a54-45d7-ab07-cce747455a6a_1681866390.8031855.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\n    public:\\n    int maxLength=0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength=max(maxLength,currLength);\\n        solve(root->left,0,dir?currLength+1:1);\\n        solve(root->right,1,dir?1:currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxLength=0;\\n    public void solve(TreeNode root,int dir,int currLength){\\n        if(root==null) return;\\n        maxLength=Math.max(maxLength,currLength);\\n        if(dir==1){\\n            solve(root.left,0,currLength+1);\\n            solve(root.right,1,1);\\n        }\\n        else{\\n            solve(root.right,1,currLength+1);\\n            solve(root.left,0,1);\\n        }\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.maxLength = 0\\n        def solve(node, deep, dir):\\n            self.maxLength = max(self.maxLength, deep)\\n\\n            if node.left is not None:\\n                solve(node.left, deep+1,\\'left\\') if dir != \\'left\\' else solve(node.left, 1, \\'left\\')\\n            if node.right is not None:\\n                solve(node.right, deep+1, \\'right\\') if dir != \\'right\\' else solve(node.right, 1, \\'right\\')\\n        solve(root, 0, \\'\\')\\n        return self.maxLength\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```C++ []\\nclass Solution {\\n    public:\\n    int maxLength=0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength=max(maxLength,currLength);\\n        solve(root->left,0,dir?currLength+1:1);\\n        solve(root->right,1,dir?1:currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxLength=0;\\n    public void solve(TreeNode root,int dir,int currLength){\\n        if(root==null) return;\\n        maxLength=Math.max(maxLength,currLength);\\n        if(dir==1){\\n            solve(root.left,0,currLength+1);\\n            solve(root.right,1,1);\\n        }\\n        else{\\n            solve(root.right,1,currLength+1);\\n            solve(root.left,0,1);\\n        }\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.maxLength = 0\\n        def solve(node, deep, dir):\\n            self.maxLength = max(self.maxLength, deep)\\n\\n            if node.left is not None:\\n                solve(node.left, deep+1,\\'left\\') if dir != \\'left\\' else solve(node.left, 1, \\'left\\')\\n            if node.right is not None:\\n                solve(node.right, deep+1, \\'right\\') if dir != \\'right\\' else solve(node.right, 1, \\'right\\')\\n        solve(root, 0, \\'\\')\\n        return self.maxLength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531880,
                "title": "simple-java-code-with-comments",
                "content": "```\\nstatic int max = 0;\\npublic static int longestZigZag(TreeNode root) {\\n        if (root == null) return -1;// if null return -1\\n        max = 0;\\n        helper(root.right, 1, true);// go right\\n        helper(root.left, 1, false);// go left\\n        return max;\\n    }\\n\\n    private static void helper(TreeNode root, int step, boolean isRight) {\\n        if (root == null) return;\\n        max = Math.max(max, step);\\n        if (isRight) {// if coming from right go left\\n            helper(root.left, step + 1, false);\\n            helper(root.right, 1, true);//try again from start\\n        } else {// else coming from left then go right\\n            helper(root.right, step + 1, true);\\n            helper(root.left, 1, false);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int max = 0;\\npublic static int longestZigZag(TreeNode root) {\\n        if (root == null) return -1;// if null return -1\\n        max = 0;\\n        helper(root.right, 1, true);// go right\\n        helper(root.left, 1, false);// go left\\n        return max;\\n    }\\n\\n    private static void helper(TreeNode root, int step, boolean isRight) {\\n        if (root == null) return;\\n        max = Math.max(max, step);\\n        if (isRight) {// if coming from right go left\\n            helper(root.left, step + 1, false);\\n            helper(root.right, 1, true);//try again from start\\n        } else {// else coming from left then go right\\n            helper(root.right, step + 1, true);\\n            helper(root.left, 1, false);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433417,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>To find the longest zigzag path in a binary tree, we can traverse the tree using DFS (Depth-First-Search) and at each node, keep track of the maximum length of the zigzag path seen so far.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>1. Initialize a variable ans to 0 to keep track of the maximum length of the zigzag path seen so far.\\n>2. Initialize a stack with the root node and two additional values n (the length of the zigzag path seen so far) and left (a boolean value indicating if the last traversal was to the left or not, where None represents the root node).\\n>3. Pop a node, n, and left from the stack.\\n>4. If the node is not None, update ans to max(ans, n).\\n>5. Add the left child to the stack with n + 1 as the new length and set left to 1 (indicating the last traversal was to the left) if the previous node was to the left or None, else set left to 0 (indicating the last traversal was to the right).\\n>6. Add the right child to the stack with n + 1 as the new length and set left to 0 (indicating the last traversal was to the right) if the previous node was to the right or None, else set left to 1 (indicating the last traversal was to the left).\\n>7. Repeat steps 3-6 until the stack is empty.\\n>8. Return ans\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n >O(N) where N is the number of nodes in the tree, as we visit every node exactly once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>O(N) as we need to store all the nodes in the worst case (i.e., a skewed tree).\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n```java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        int ans = 0;\\n        Stack<Triplet> stack = new Stack<>();\\n        stack.push(new Triplet(root, 0, null));\\n        while (!stack.isEmpty()) {\\n            Triplet triplet = stack.pop();\\n            TreeNode node = triplet.node;\\n            int n = triplet.n;\\n            Integer left = triplet.left;\\n            if (node != null) {\\n                ans = Math.max(ans, n);\\n                stack.push(new Triplet(node.left, left != null && left == 0 ? n + 1 : 1, 1));\\n                stack.push(new Triplet(node.right, left != null && left == 1 ? n + 1 : 1, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass Triplet {\\n    TreeNode node;\\n    int n;\\n    Integer left;\\n    \\n    public Triplet(TreeNode node, int n, Integer left) {\\n        this.node = node;\\n        this.n = n;\\n        this.left = left;\\n    }\\n}\\n\\n```\\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def longestZigZag(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        stack = [(root, 0, None)]\\n        while stack:\\n            node, n, left = stack.pop()\\n            if node:\\n                ans = max(ans, n)\\n                stack.append((node.left, 1 if left else n + 1, 1))\\n                stack.append((node.right, n + 1 if left else 1, 0))\\n        return ans\\n\\n```\\n\\n\\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar longestZigZag = function(root) {\\n    let ans = 0;\\n    const stack = [[root, 0, null]];\\n    while (stack.length > 0) {\\n        const [node, n, left] = stack.pop();\\n        if (node) {\\n            ans = Math.max(ans, n);\\n            stack.push([node.left, left != null && left == 0 ? n + 1 : 1, 1]);\\n            stack.push([node.right, left != null && left == 1 ? n + 1 : 1, 0]);\\n        }\\n    }\\n    return ans;\\n};\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        int ans = 0;\\n        Stack<Triplet> stack = new Stack<>();\\n        stack.push(new Triplet(root, 0, null));\\n        while (!stack.isEmpty()) {\\n            Triplet triplet = stack.pop();\\n            TreeNode node = triplet.node;\\n            int n = triplet.n;\\n            Integer left = triplet.left;\\n            if (node != null) {\\n                ans = Math.max(ans, n);\\n                stack.push(new Triplet(node.left, left != null && left == 0 ? n + 1 : 1, 1));\\n                stack.push(new Triplet(node.right, left != null && left == 1 ? n + 1 : 1, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass Triplet {\\n    TreeNode node;\\n    int n;\\n    Integer left;\\n    \\n    public Triplet(TreeNode node, int n, Integer left) {\\n        this.node = node;\\n        this.n = n;\\n        this.left = left;\\n    }\\n}\\n\\n```\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def longestZigZag(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        stack = [(root, 0, None)]\\n        while stack:\\n            node, n, left = stack.pop()\\n            if node:\\n                ans = max(ans, n)\\n                stack.append((node.left, 1 if left else n + 1, 1))\\n                stack.append((node.right, n + 1 if left else 1, 0))\\n        return ans\\n\\n```\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar longestZigZag = function(root) {\\n    let ans = 0;\\n    const stack = [[root, 0, null]];\\n    while (stack.length > 0) {\\n        const [node, n, left] = stack.pop();\\n        if (node) {\\n            ans = Math.max(ans, n);\\n            stack.push([node.left, left != null && left == 0 ? n + 1 : 1, 1]);\\n            stack.push([node.right, left != null && left == 1 ? n + 1 : 1, 0]);\\n        }\\n    }\\n    return ans;\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531990,
                "title": "python-bfs-solution",
                "content": "BFS with queue\\nMain structure is `[node, from_, zigzag_len]`, where\\n`node` - is a current node,\\n`from_` - string with info about previous move (may be \\'l\\' if I came to current node from left or \\'r\\' if I came from left)\\n`zigzag_len` - length of zigzag path\\n\\nUPDATE: Thank you, @bunnyd! I updated code.\\n\\n```Python\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0   \\n        \\n        deq = deque()\\n        max_zigzag_size = 0\\n        \\n        if root.left:\\n            deq.append((root.left, \\'l\\', 1))\\n        if root.right:\\n            deq.append((root.right, \\'r\\', 1))\\n\\n        while deq:\\n            node, from_, zigzag_size = deq.popleft()\\n            max_zigzag_size = max(zigzag_size, max_zigzag_size) # update max len of zigzag path\\n            if node.left:\\n                if from_ == \\'l\\':  # if came from left\\n                    deq.append((node.left, \"l\", 1)) # set length of zigzag path to 1\\n                if from_ == \\'r\\':  # if came from right\\n                    deq.append((node.left, \"l\", zigzag_size + 1)) # increase length of zigzag path \\n            if node.right:\\n                if from_ == \\'l\\':\\n                    deq.append((node.right, \"r\", zigzag_size + 1))\\n                if from_ == \\'r\\':\\n                    deq.append((node.right, \"r\", 1))\\n        return max_zigzag_size  \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```Python\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0   \\n        \\n        deq = deque()\\n        max_zigzag_size = 0\\n        \\n        if root.left:\\n            deq.append((root.left, \\'l\\', 1))\\n        if root.right:\\n            deq.append((root.right, \\'r\\', 1))\\n\\n        while deq:\\n            node, from_, zigzag_size = deq.popleft()\\n            max_zigzag_size = max(zigzag_size, max_zigzag_size) # update max len of zigzag path\\n            if node.left:\\n                if from_ == \\'l\\':  # if came from left\\n                    deq.append((node.left, \"l\", 1)) # set length of zigzag path to 1\\n                if from_ == \\'r\\':  # if came from right\\n                    deq.append((node.left, \"l\", zigzag_size + 1)) # increase length of zigzag path \\n            if node.right:\\n                if from_ == \\'l\\':\\n                    deq.append((node.right, \"r\", zigzag_size + 1))\\n                if from_ == \\'r\\':\\n                    deq.append((node.right, \"r\", 1))\\n        return max_zigzag_size  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 531808,
                "title": "java-recursion-try-each-node-as-a-zigzag-root-then-return-valid-sum-to-parent",
                "content": "```java\\nclass Solution {\\n    int result = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, true);\\n        return result;\\n    }\\n    \\n    public int dfs(TreeNode node, boolean isLeft){\\n        if(node == null){\\n            return 0;\\n        }\\n        //try start here\\n        int l = dfs(node.left, false);\\n        int r = dfs(node.right, true);\\n        result = Math.max(result, l);\\n        result = Math.max(result, r);\\n        //return sum for parent\\n        return 1 + (isLeft ? l : r);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    int result = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, true);\\n        return result;\\n    }\\n    \\n    public int dfs(TreeNode node, boolean isLeft){\\n        if(node == null){\\n            return 0;\\n        }\\n        //try start here\\n        int l = dfs(node.left, false);\\n        int r = dfs(node.right, true);\\n        result = Math.max(result, l);\\n        result = Math.max(result, r);\\n        //return sum for parent\\n        return 1 + (isLeft ? l : r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534863,
                "title": "c-minimalizm",
                "content": "Traverse the tree tracking whether we come from `left` or not.\\n- Continue traversing in the oposite direction and increment `depth`.\\n- Or, start a new traversal in the same direction, resetting `depth` to zero. \\n\\n```cpp\\nint dfs(TreeNode* n, bool left, int depth) {\\n    return n == nullptr ? depth : \\n        max(dfs(left ? n->left : n->right, !left, depth + 1),\\n            dfs(left ? n->right : n->left, left, 0));\\n}\\nint longestZigZag(TreeNode* root) {\\n    return max(dfs(root, true, -1), dfs(root, false, -1));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dfs(TreeNode* n, bool left, int depth) {\\n    return n == nullptr ? depth : \\n        max(dfs(left ? n->left : n->right, !left, depth + 1),\\n            dfs(left ? n->right : n->left, left, 0));\\n}\\nint longestZigZag(TreeNode* root) {\\n    return max(dfs(root, true, -1), dfs(root, false, -1));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433160,
                "title": "leetcode-the-hard-way-dfs-explained-line-by-line",
                "content": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\n // TC: O(n)\\n // SC: O(n)\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root, int isLeft, int cnt) {\\n        // root is nullptr, we can return `cnt`\\n        if (!root) return cnt;\\n        // if `isLeft` is true, we have two choices\\n        // 1. go to right making a zipzag path - increase the cnt by 1 \\n        // 2. still go to left - starting a new zigzag path - hence cnt is set to 0\\n        if (isLeft) return max(dfs(root->right, 0, cnt + 1), dfs(root->left, 1, 0));\\n        // similarly, we apply the same logic for the opposite direction\\n        return max(dfs(root->left, 1, cnt + 1), dfs(root->right, 0, 0));\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        // go through left-subtree and right-subtree\\n        // get the max result\\n        return max(dfs(root->left, 1, 0), dfs(root->right, 0, 0));\\n    }\\n};\\n```\\n\\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node, isLeft, cnt):\\n            # root is None, we can return `cnt`\\n            if node is None: return cnt\\n            # if `isLeft` is true, we have two choices\\n            # 1. go to right making a zipzag path - increase the cnt by 1\\n            # 2. still go to left - starting a new zigzag path - hence cnt is set to 0\\n            if isLeft:  return max(dfs(node.right, 0, cnt + 1), dfs(node.left, 1, 0))\\n            # similarly, we apply the same logic for the opposite direction\\n            return max(dfs(node.left, 1, cnt + 1), dfs(node.right, 0, 0))\\n        # go through left-subtree and right-subtree and get the max result\\n        return max(dfs(root.left, 1, 0), dfs(root.right, 0, 0))\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\n // TC: O(n)\\n // SC: O(n)\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root, int isLeft, int cnt) {\\n        // root is nullptr, we can return `cnt`\\n        if (!root) return cnt;\\n        // if `isLeft` is true, we have two choices\\n        // 1. go to right making a zipzag path - increase the cnt by 1 \\n        // 2. still go to left - starting a new zigzag path - hence cnt is set to 0\\n        if (isLeft) return max(dfs(root->right, 0, cnt + 1), dfs(root->left, 1, 0));\\n        // similarly, we apply the same logic for the opposite direction\\n        return max(dfs(root->left, 1, cnt + 1), dfs(root->right, 0, 0));\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        // go through left-subtree and right-subtree\\n        // get the max result\\n        return max(dfs(root->left, 1, 0), dfs(root->right, 0, 0));\\n    }\\n};\\n```\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node, isLeft, cnt):\\n            # root is None, we can return `cnt`\\n            if node is None: return cnt\\n            # if `isLeft` is true, we have two choices\\n            # 1. go to right making a zipzag path - increase the cnt by 1\\n            # 2. still go to left - starting a new zigzag path - hence cnt is set to 0\\n            if isLeft:  return max(dfs(node.right, 0, cnt + 1), dfs(node.left, 1, 0))\\n            # similarly, we apply the same logic for the opposite direction\\n            return max(dfs(node.left, 1, cnt + 1), dfs(node.right, 0, 0))\\n        # go through left-subtree and right-subtree and get the max result\\n        return max(dfs(root.left, 1, 0), dfs(root.right, 0, 0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433646,
                "title": "c-easy-recursion-approach-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        if(!root->right && !root->left)\\n            return 0;\\n        return solve(root, 0, false);\\n    }\\n    int solve(TreeNode* root, int length, bool shouldGoLeft) {\\n        if(!root)\\n            return length;\\n\\n        int left = 0;\\n        int right = 0;\\n        int tmp = 0;\\n\\n        if(shouldGoLeft && !root->left) {\\n            tmp = length;\\n            length = 0;\\n        } else if(!shouldGoLeft && !root->right) {\\n            tmp = length;\\n            length = 0;\\n        }\\n\\n        right = solve(root->right, shouldGoLeft ? 1: length + 1, true);\\n        left = solve(root->left, shouldGoLeft ? length + 1 : 1, false);\\n\\n        return std::max({left, right, tmp});\\n    }\\n};\\n```\\n![_za_kompom_yapfiles.ru-min (online-video-cutter.com).gif](https://assets.leetcode.com/users/images/255a229e-59b8-4d7a-b910-87108c171e71_1681884320.5500047.gif)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        if(!root->right && !root->left)\\n            return 0;\\n        return solve(root, 0, false);\\n    }\\n    int solve(TreeNode* root, int length, bool shouldGoLeft) {\\n        if(!root)\\n            return length;\\n\\n        int left = 0;\\n        int right = 0;\\n        int tmp = 0;\\n\\n        if(shouldGoLeft && !root->left) {\\n            tmp = length;\\n            length = 0;\\n        } else if(!shouldGoLeft && !root->right) {\\n            tmp = length;\\n            length = 0;\\n        }\\n\\n        right = solve(root->right, shouldGoLeft ? 1: length + 1, true);\\n        left = solve(root->left, shouldGoLeft ? length + 1 : 1, false);\\n\\n        return std::max({left, right, tmp});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433024,
                "title": "c-recursion",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res = 0;\\n\\n    void solve(TreeNode* node, bool goLeft, int currPathLen) {\\n        if (!node) return;\\n        res = max(res, currPathLen);\\n        if (goLeft) {\\n            solve(node->left, false, currPathLen + 1);\\n            solve(node->right, true, 1);\\n        } else {\\n            solve(node->right, true, currPathLen + 1);\\n            solve(node->left, false, 1);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root, true, 0);\\n        solve(root, false, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res = 0;\\n\\n    void solve(TreeNode* node, bool goLeft, int currPathLen) {\\n        if (!node) return;\\n        res = max(res, currPathLen);\\n        if (goLeft) {\\n            solve(node->left, false, currPathLen + 1);\\n            solve(node->right, true, 1);\\n        } else {\\n            solve(node->right, true, currPathLen + 1);\\n            solve(node->left, false, 1);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root, true, 0);\\n        solve(root, false, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432989,
                "title": "dfs-solution-with-explanation-c-go",
                "content": "My approach is DFS. My `DFS` function takes `TreeNode`(current node), `bool`(direction), `int`(ZigZag count).\\nWe have two options:\\n1. We continue with direction (if previous was right, we go to left, else we go to right) and increment count. \\n2. We coutinue with another direction (if previous was right, we go to right, else we go to left) and reset count.\\n\\nAnd we choose maximum from this two options.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(depth)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nC#\\n```\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root) {\\n        return Math.Max(DFS(root.left, true, 0), DFS(root.right, false, 0));\\n    }\\n\\n    int DFS(TreeNode node, bool isLeft, int count) {\\n        if (node == null) {\\n            return count;\\n        }\\n\\n        if (isLeft) {\\n            return Math.Max(DFS(node.left, true, 0), DFS(node.right, false, count+1));\\n        }\\n        return Math.Max(DFS(node.left, true, count+1), DFS(node.right, false, 0));\\n    }\\n}\\n```\\nGo\\n```\\nfunc longestZigZag(root *TreeNode) int {\\n\\treturn max(dfs(root.Left, true, 0), dfs(root.Right, false, 0))\\n}\\n\\nfunc dfs(node *TreeNode, isLeft bool, count int) int {\\n\\tif node == nil {\\n\\t\\treturn count\\n\\t}\\n\\n\\tif isLeft {\\n\\t\\treturn max(dfs(node.Left, true, 0), dfs(node.Right, false, count+1))\\n\\t}\\n\\n\\treturn max(dfs(node.Left, true, count+1), dfs(node.Right, false, 0))\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root) {\\n        return Math.Max(DFS(root.left, true, 0), DFS(root.right, false, 0));\\n    }\\n\\n    int DFS(TreeNode node, bool isLeft, int count) {\\n        if (node == null) {\\n            return count;\\n        }\\n\\n        if (isLeft) {\\n            return Math.Max(DFS(node.left, true, 0), DFS(node.right, false, count+1));\\n        }\\n        return Math.Max(DFS(node.left, true, count+1), DFS(node.right, false, 0));\\n    }\\n}\\n```\n```\\nfunc longestZigZag(root *TreeNode) int {\\n\\treturn max(dfs(root.Left, true, 0), dfs(root.Right, false, 0))\\n}\\n\\nfunc dfs(node *TreeNode, isLeft bool, count int) int {\\n\\tif node == nil {\\n\\t\\treturn count\\n\\t}\\n\\n\\tif isLeft {\\n\\t\\treturn max(dfs(node.Left, true, 0), dfs(node.Right, false, count+1))\\n\\t}\\n\\n\\treturn max(dfs(node.Left, true, count+1), dfs(node.Right, false, 0))\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532399,
                "title": "java-beats-100-percent-with-explanation",
                "content": "I never liked a code which is succint but hard to understand. Specially you need to remember there will be others too who will look at that code and may need to do refactoring. Always liked a code which is easy to understand.\\n\\n```\\npublic int longestZigZag(TreeNode root) {\\n        return longestZigZagHelper(root, 0, 0, true, true);\\n    }\\n\\n    /**\\n\\t * max - current max as we go down to traverse the tree, while coming up it becomes the max possible in that branch \\n\\t * curMax - current max as we go down to travere the tree\\n     * fromLeft - did we land on node as left child\\n     * fromRight - did we land on node as right child\\n     */\\n    private int longestZigZagHelper(TreeNode node, int curMax, int max, boolean fromLeft, boolean fromRight) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        if (node.left == null && node.right == null) {\\n            /**\\n             * when we hit a child node, return the max to upper node.\\n             */\\n            return max;\\n        }\\n        int leftMax = Integer.MIN_VALUE;\\n        if (node.left != null) {\\n            if (fromLeft) {\\n                /**\\n                 * To handle cases like\\n                 *         1\\n                 *        / \\\\      at least max should be 1.\\n                 *       1   1\\n                 */\\n                max = Math.max(max, 1);\\n                leftMax = longestZigZagHelper(node.left, 1, max, true, false);\\n            } else {\\n                /**\\n                 * we are moving on zigzag path as we landed on node being a right child and our next step\\n                 * will be on left child.\\n                 */\\n                max = Math.max(max, curMax + 1);\\n                leftMax = longestZigZagHelper(node.left, curMax + 1, max, true, false);\\n            }\\n        }\\n        int rightMax = Integer.MIN_VALUE;\\n        if (node.right != null) {\\n            if (fromRight) {\\n                /**\\n                 * as mention in above to handle cases\\n                 */\\n                max = Math.max(max, 1);\\n                rightMax = longestZigZagHelper(node.right, 1, max, false, true);\\n            } else {\\n                /**\\n                 * we are moving on zigzag path as we landed on node being a right child and our next step\\n                 * will be on left child.\\n                 */\\n                max = Math.max(max, curMax + 1);\\n                rightMax = longestZigZagHelper(node.right, curMax + 1, max, false, true);\\n            }\\n        }\\n        /**\\n         * return the max zigzag from right child or from left child whatever is max\\n         */\\n        return Math.max(leftMax, rightMax);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int longestZigZag(TreeNode root) {\\n        return longestZigZagHelper(root, 0, 0, true, true);\\n    }\\n\\n    /**\\n\\t * max - current max as we go down to traverse the tree, while coming up it becomes the max possible in that branch \\n\\t * curMax - current max as we go down to travere the tree\\n     * fromLeft - did we land on node as left child\\n     * fromRight - did we land on node as right child\\n     */\\n    private int longestZigZagHelper(TreeNode node, int curMax, int max, boolean fromLeft, boolean fromRight) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        if (node.left == null && node.right == null) {\\n            /**\\n             * when we hit a child node, return the max to upper node.\\n             */\\n            return max;\\n        }\\n        int leftMax = Integer.MIN_VALUE;\\n        if (node.left != null) {\\n            if (fromLeft) {\\n                /**\\n                 * To handle cases like\\n                 *         1\\n                 *        / \\\\      at least max should be 1.\\n                 *       1   1\\n                 */\\n                max = Math.max(max, 1);\\n                leftMax = longestZigZagHelper(node.left, 1, max, true, false);\\n            } else {\\n                /**\\n                 * we are moving on zigzag path as we landed on node being a right child and our next step\\n                 * will be on left child.\\n                 */\\n                max = Math.max(max, curMax + 1);\\n                leftMax = longestZigZagHelper(node.left, curMax + 1, max, true, false);\\n            }\\n        }\\n        int rightMax = Integer.MIN_VALUE;\\n        if (node.right != null) {\\n            if (fromRight) {\\n                /**\\n                 * as mention in above to handle cases\\n                 */\\n                max = Math.max(max, 1);\\n                rightMax = longestZigZagHelper(node.right, 1, max, false, true);\\n            } else {\\n                /**\\n                 * we are moving on zigzag path as we landed on node being a right child and our next step\\n                 * will be on left child.\\n                 */\\n                max = Math.max(max, curMax + 1);\\n                rightMax = longestZigZagHelper(node.right, curMax + 1, max, false, true);\\n            }\\n        }\\n        /**\\n         * return the max zigzag from right child or from left child whatever is max\\n         */\\n        return Math.max(leftMax, rightMax);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433067,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def helper(root, right, total):\\n            if not root:\\n                return total\\n            \\n            l = helper(root.left, False, total+1 if right else 1)\\n            r = helper(root.right, True, total+1 if not right else 1)\\n\\n            return max(l,r)\\n        \\n        return helper(root, None, 0) - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def helper(root, right, total):\\n            if not root:\\n                return total\\n            \\n            l = helper(root.left, False, total+1 if right else 1)\\n            r = helper(root.right, True, total+1 if not right else 1)\\n\\n            return max(l,r)\\n        \\n        return helper(root, None, 0) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531869,
                "title": "python-simple-recursion",
                "content": "```\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        res=0\\n        def helper(root,direction):\\n            nonlocal res\\n            if not root:\\n                return 0\\n            left=helper(root.left,\\'left\\')\\n            right=helper(root.right,\\'right\\')\\n            res=max(res,left+1,right+1)\\n            return right+1 if direction==\\'left\\' else left+1\\n         \\n        if not root:\\n            return 0\\n        helper(root,\\'left\\')\\n        helper(root,\\'right\\')\\n        return res-1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        res=0\\n        def helper(root,direction):\\n            nonlocal res\\n            if not root:\\n                return 0\\n            left=helper(root.left,\\'left\\')\\n            right=helper(root.right,\\'right\\')\\n            res=max(res,left+1,right+1)\\n            return right+1 if direction==\\'left\\' else left+1\\n         \\n        if not root:\\n            return 0\\n        helper(root,\\'left\\')\\n        helper(root,\\'right\\')\\n        return res-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862418,
                "title": "python-clean-solution-without-pain-image-and-explanation-beats-98",
                "content": "# Intuition\\nMany solutions to this problem on LeetCode can lead to eye strain due to their convoluted logic or excessive code. Here, we\\'re aiming to provide a simple and clean solution, which doesn\\'t compromise on efficiency or readability.\\n\\nTo understand the approach, consider the test case: \\n\\n```[1,1,1,1,1,null,1,null,null,null,null,1,1,null,1]```\\n\\nOn the associated tree diagram, we have highlighted two significant ZigZag paths. An orange path, of length 2, proceeds leftwards from the root, and a green path, of length 3, originates from the right branch of the root.\\n![image.png](https://assets.leetcode.com/users/images/75227891-a05a-4f54-9e55-c8b979c54ec4_1691146564.682754.png)\\n\\n# Approach\\nOur algorithm is rooted in the idea of tracking the length of the ZigZag paths as we traverse the tree, using depth-first search (DFS). The current path length is maintained in two variables - `left` and `right`. At each node, if we go left, we update `left` by adding 1 to `right` and reset `right` to 0. Conversely, if we go right, we add 1 to `left` and reset `left` to 0. This way, we always start a new path with either (0,1) or (1,0).\\n\\nEach ZigZag path length is continuously compared to a global maximum (`self.maxi`), and `self.maxi` is updated whenever a larger ZigZag path is found. At the end, `self.maxi` holds the length of the longest ZigZag path in the tree.\\n\\n# Complexity\\n- Time complexity: : O(n), where n is the number of nodes in the tree. This is because we are doing a single DFS traversal of the tree.\\n\\n- Space complexity: O(h), where h is the height of the tree. This accounts for the maximum size of the implicit call stack for the DFS traversal.\\n\\n---\\n\\nThis solution manages to achieve excellent performance without resorting to eye-gouging code, providing an accessible and elegant approach to a potentially complex problem.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.maxi = 0\\n\\n        def dfs(node, left, right):\\n            self.maxi = max(self.maxi, left, right)\\n\\n            if node.left:\\n                dfs(node.left, right + 1, 0)\\n\\n            if node.right:\\n                dfs(node.right, 0, left + 1)\\n\\n        dfs(root, 0, 0)\\n        return self.maxi\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```[1,1,1,1,1,null,1,null,null,null,null,1,1,null,1]```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.maxi = 0\\n\\n        def dfs(node, left, right):\\n            self.maxi = max(self.maxi, left, right)\\n\\n            if node.left:\\n                dfs(node.left, right + 1, 0)\\n\\n            if node.right:\\n                dfs(node.right, 0, left + 1)\\n\\n        dfs(root, 0, 0)\\n        return self.maxi\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433364,
                "title": "java-solution-easy-steps",
                "content": "```\\nclass Solution {\\n    int max=0;\\n    public int longestZigZag(TreeNode root) {\\n       if (root == null) return -1;\\n        max = 0;\\n        helper(root.right, 1, true);\\n        helper(root.left, 1, false);\\n        return max;   \\n    }\\n     private  void helper(TreeNode root, int step, boolean isRight) {\\n        if (root == null) return;\\n        max = Math.max(max, step);\\n        if (isRight) {\\n            helper(root.left, step + 1, false);\\n            helper(root.right, 1, true);\\n        } else {\\n            helper(root.right, step + 1, true);\\n            helper(root.left, 1, false);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int max=0;\\n    public int longestZigZag(TreeNode root) {\\n       if (root == null) return -1;\\n        max = 0;\\n        helper(root.right, 1, true);\\n        helper(root.left, 1, false);\\n        return max;   \\n    }\\n     private  void helper(TreeNode root, int step, boolean isRight) {\\n        if (root == null) return;\\n        max = Math.max(max, step);\\n        if (isRight) {\\n            helper(root.left, step + 1, false);\\n            helper(root.right, 1, true);\\n        } else {\\n            helper(root.right, step + 1, true);\\n            helper(root.left, 1, false);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433028,
                "title": "easy-solution-of-java-c-with-explanation-beginner-friendly",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n\\nclass Solution {\\n    int MAX;\\n    Map<TreeNode, int []> dp;\\n    public int longestZigZag(TreeNode root) {\\n        \\n        //postorder traversal\\n        //Map stores left from node and right from node\\n        dp = new HashMap<>();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    //returns max length from here if you go in a particular direction\\n    private void dfs(TreeNode root){\\n        if(root == null) return;\\n\\n        if(root.left == null && root.right == null){\\n            dp.put(root, new int[]{0,0});\\n            return;\\n        }\\n        //In dp value int []\\n        //index 0 represents left direction\\n        //index 1 represents right direction\\n        dfs(root.left);\\n        dfs(root.right);\\n\\n        int left = 0, right = 0;\\n\\n        if(dp.get(root.left) != null)\\n            left = 1 + dp.get(root.left)[1]; //we go right after left\\n        \\n        if(dp.get(root.right) != null)\\n            right = 1 + dp.get(root.right)[0]; //we go left after right\\n        dp.put(root, new int[]{left, right});\\n        MAX = Math.max(MAX, Math.max(left,right));\\n    }\\n}\\n```\\nC++\\n```\\n#include <iostream>\\n#include <unordered_map>\\n#include <vector>\\n\\nusing namespace std;\\n\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left;\\n    TreeNode* right;\\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n};\\n\\nclass Solution {\\n    int MAX;\\n    unordered_map<TreeNode*, vector<int>> dp;\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        dp.clear();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n\\n        if (!root->left && !root->right) {\\n            dp[root] = {0, 0};\\n            return;\\n        }\\n\\n        dfs(root->left);\\n        dfs(root->right);\\n\\n        int left = 0, right = 0;\\n\\n        if (dp.find(root->left) != dp.end())\\n            left = 1 + dp[root->left][1];\\n\\n        if (dp.find(root->right) != dp.end())\\n            right = 1 + dp[root->right][0];\\n\\n        dp[root] = {left, right};\\n        MAX = max(MAX, max(left, right));\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    int MAX;\\n    Map<TreeNode, int []> dp;\\n    public int longestZigZag(TreeNode root) {\\n        \\n        //postorder traversal\\n        //Map stores left from node and right from node\\n        dp = new HashMap<>();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    //returns max length from here if you go in a particular direction\\n    private void dfs(TreeNode root){\\n        if(root == null) return;\\n\\n        if(root.left == null && root.right == null){\\n            dp.put(root, new int[]{0,0});\\n            return;\\n        }\\n        //In dp value int []\\n        //index 0 represents left direction\\n        //index 1 represents right direction\\n        dfs(root.left);\\n        dfs(root.right);\\n\\n        int left = 0, right = 0;\\n\\n        if(dp.get(root.left) != null)\\n            left = 1 + dp.get(root.left)[1]; //we go right after left\\n        \\n        if(dp.get(root.right) != null)\\n            right = 1 + dp.get(root.right)[0]; //we go left after right\\n        dp.put(root, new int[]{left, right});\\n        MAX = Math.max(MAX, Math.max(left,right));\\n    }\\n}\\n```\n```\\n#include <iostream>\\n#include <unordered_map>\\n#include <vector>\\n\\nusing namespace std;\\n\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left;\\n    TreeNode* right;\\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n};\\n\\nclass Solution {\\n    int MAX;\\n    unordered_map<TreeNode*, vector<int>> dp;\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        dp.clear();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n\\n        if (!root->left && !root->right) {\\n            dp[root] = {0, 0};\\n            return;\\n        }\\n\\n        dfs(root->left);\\n        dfs(root->right);\\n\\n        int left = 0, right = 0;\\n\\n        if (dp.find(root->left) != dp.end())\\n            left = 1 + dp[root->left][1];\\n\\n        if (dp.find(root->right) != dp.end())\\n            right = 1 + dp[root->right][0];\\n\\n        dp[root] = {left, right};\\n        MAX = max(MAX, max(left, right));\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2283892,
                "title": "c-easiest-solution-using-memoization",
                "content": "Explanation:- Traverse the binary tree in a postorder manner and at each node we will calculate the longest zigzag path considering that node as a root and storing the ans in a Map . At each node if the left child is not null we will pass a boolean variable to true to indicate that it should choose the next node as right and similarly if right node is not null we will pass false to indiacate that it should go to the left  and if it cannot move we will simply return 1;\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    map<pair<TreeNode*,bool>,int>mp;\\n    int longestZigZag(TreeNode* root) {\\n      preorder(root);\\n        return ans;\\n        \\n    }\\n    void preorder(TreeNode*root){\\n        if(root!=NULL){\\n            if(root->left!=NULL){\\n                ans=max(ans,findzig(root->left,true));   // passing the left child with true so that it will move right\\n               \\n            }\\n            if(root->right!=NULL){\\n                ans=max(ans,findzig(root->right,false)); //passing the right child with false so that it will move left\\n              \\n            }\\n            preorder(root->left);  \\n            preorder(root->right);\\n        }\\n    }\\n    int findzig(TreeNode*root,bool chk){\\n        if(mp.find({root,chk})!=mp.end()) return mp[{root,chk}];   // checking if the node is already been computed \\n        if(chk){\\n            // go right\\n            if(root->right!=NULL){\\n                return mp[{root,chk}]=1+findzig(root->right,!chk); // moving left in next iteration\\n            }\\n            }else{\\n                if(root->left!=NULL){\\n                    return mp[{root,chk}]=1+findzig(root->left,!chk); // moving right in next iteration\\n                }\\n            }\\n        return mp[{root,chk}]=1;\\n    }\\n};\\n```\\nPlease upvote if U like my explanation",
                "solutionTags": [
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    map<pair<TreeNode*,bool>,int>mp;\\n    int longestZigZag(TreeNode* root) {\\n      preorder(root);\\n        return ans;\\n        \\n    }\\n    void preorder(TreeNode*root){\\n        if(root!=NULL){\\n            if(root->left!=NULL){\\n                ans=max(ans,findzig(root->left,true));   // passing the left child with true so that it will move right\\n               \\n            }\\n            if(root->right!=NULL){\\n                ans=max(ans,findzig(root->right,false)); //passing the right child with false so that it will move left\\n              \\n            }\\n            preorder(root->left);  \\n            preorder(root->right);\\n        }\\n    }\\n    int findzig(TreeNode*root,bool chk){\\n        if(mp.find({root,chk})!=mp.end()) return mp[{root,chk}];   // checking if the node is already been computed \\n        if(chk){\\n            // go right\\n            if(root->right!=NULL){\\n                return mp[{root,chk}]=1+findzig(root->right,!chk); // moving left in next iteration\\n            }\\n            }else{\\n                if(root->left!=NULL){\\n                    return mp[{root,chk}]=1+findzig(root->left,!chk); // moving right in next iteration\\n                }\\n            }\\n        return mp[{root,chk}]=1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 682415,
                "title": "java-simple-dfs",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root.left, 1, true);\\n        dfs(root.right, 1, false);\\n        return res;\\n    }\\n    \\n    private void dfs(TreeNode node, int prev, boolean left) {\\n        if (node == null) return;\\n        res = Math.max(res, prev);\\n        dfs(node.left, 1 + (left ? 0 : prev), true);\\n        dfs(node.right,1 + (left ? prev : 0), false);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root.left, 1, true);\\n        dfs(root.right, 1, false);\\n        return res;\\n    }\\n    \\n    private void dfs(TreeNode node, int prev, boolean left) {\\n        if (node == null) return;\\n        res = Math.max(res, prev);\\n        dfs(node.left, 1 + (left ? 0 : prev), true);\\n        dfs(node.right,1 + (left ? prev : 0), false);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433664,
                "title": "java-recursion",
                "content": "```\\nclass Solution {\\n    int LongestPath = 0;\\n    public int longestZigZag(TreeNode root) {\\n        int[] a = helper(root);\\n        return LongestPath;\\n    }\\n    \\n    //  {Longest Path Ending At leftNode, Longest Path Ending At RightNode}\\n    public int[] helper(TreeNode root) {\\n        if (root == null) {\\n            return new int[]{-1, -1};\\n        }\\n        int[] left = helper(root.left);\\n        int[] right = helper(root.right);\\n        int[] answer = new int[]{left[1] + 1, right[0] + 1};\\n        LongestPath = Math.max(LongestPath, Math.max(answer[0], answer[1]));\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int LongestPath = 0;\\n    public int longestZigZag(TreeNode root) {\\n        int[] a = helper(root);\\n        return LongestPath;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3434051,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\nlet ans = 0;\\n\\nvar dfs = (root,left,steps) => {\\n    if(root == undefined){\\n        return \\n    }\\n\\n    ans = Math.max(ans,steps)\\n\\n    if(left){\\n        dfs(root.left, !left, steps+1)\\n        dfs(root.right, left, 1)\\n    }\\n    else{\\n        dfs(root.left, left, 1)\\n        dfs(root.right, !left, steps+1)\\n    }\\n}\\n\\nvar longestZigZag = function(root) {\\n    ans = 0\\n\\n    dfs(root,true,0)\\n    dfs(root,false,0)\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nlet ans = 0;\\n\\nvar dfs = (root,left,steps) => {\\n    if(root == undefined){\\n        return \\n    }\\n\\n    ans = Math.max(ans,steps)\\n\\n    if(left){\\n        dfs(root.left, !left, steps+1)\\n        dfs(root.right, left, 1)\\n    }\\n    else{\\n        dfs(root.left, left, 1)\\n        dfs(root.right, !left, steps+1)\\n    }\\n}\\n\\nvar longestZigZag = function(root) {\\n    ans = 0\\n\\n    dfs(root,true,0)\\n    dfs(root,false,0)\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1878082,
                "title": "c-dfs-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(TreeNode* root , int score, int dir){\\n        if(root == NULL) return ;\\n        ans = max(ans, score);\\n        if(dir == 0)  {solve(root->right, score + 1, 1); solve(root->left, 1, 0);}\\n        else {solve(root->left, score + 1, 0); solve(root->right, 1, 1);}\\n        \\n    }\\n    int longestZigZag(TreeNode* root) {\\n           solve(root->left, 1, 0);\\n           solve(root->right, 1, 1);\\n           return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int ans = 0;\\n    void solve(TreeNode* root , int score, int dir){\\n        if(root == NULL) return ;\\n        ans = max(ans, score);\\n        if(dir == 0)  {solve(root->right, score + 1, 1); solve(root->left, 1, 0);}",
                "codeTag": "Java"
            },
            {
                "id": 550153,
                "title": "10-lines-clean-easy-to-understand-well-explained-code",
                "content": "Recurse through the tree. Return for every node what is the max path len if we go left from current node and what is the max path len if we go right from current node. Keep track of maximum. \\n\\n```python\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\t\\n        self.ans = 0  # global variable to store answer\\n\\t\\t\\n        def recurse(root):\\n\\t\\t\\t# if null return -1 because length is defined \\n\\t\\t\\t# as the number of nodes visited - 1. \\n            if not root: return (-1,-1) \\n\\t\\t\\t\\n\\t\\t\\t# l1 is max path len if we go left from current node and r1 if we go right\\t\\t\\t\\t\\t\\t\\n            l1,r1 = recurse(root.left)\\n            l2,r2 = recurse(root.right)\\n\\t\\t\\t# Notice that if we go left from current node then we have no other choice but\\n\\t\\t\\t# to go right from node.left to make the path zigzag. \\n\\t\\t\\t# That is why  r1 + 1 is the max path len  if we go left from current node. \\n\\t\\t\\t# Same logic for l2 + 1\\n            self.ans = max(self.ans, max(r1 + 1, l2 + 1))\\n            return (r1 + 1, l2 + 1)\\n\\t\\t\\t\\n        recurse(root)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\t\\n        self.ans = 0  # global variable to store answer\\n\\t\\t\\n        def recurse(root):\\n\\t\\t\\t# if null return -1 because length is defined \\n\\t\\t\\t# as the number of nodes visited - 1. \\n            if not root: return (-1,-1) \\n\\t\\t\\t\\n\\t\\t\\t# l1 is max path len if we go left from current node and r1 if we go right\\t\\t\\t\\t\\t\\t\\n            l1,r1 = recurse(root.left)\\n            l2,r2 = recurse(root.right)\\n\\t\\t\\t# Notice that if we go left from current node then we have no other choice but\\n\\t\\t\\t# to go right from node.left to make the path zigzag. \\n\\t\\t\\t# That is why  r1 + 1 is the max path len  if we go left from current node. \\n\\t\\t\\t# Same logic for l2 + 1\\n            self.ans = max(self.ans, max(r1 + 1, l2 + 1))\\n            return (r1 + 1, l2 + 1)\\n\\t\\t\\t\\n        recurse(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433173,
                "title": "python3-solution",
                "content": "\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        stack=[(root,0,None)]\\n        while stack:\\n            node,n,left=stack.pop()\\n            if node:\\n                ans=max(ans,n)\\n                stack.append((node.left,1 if left else n+1,1))\\n                stack.append((node.right,n+1 if left else 1,0))\\n\\n        return ans        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        stack=[(root,0,None)]\\n        while stack:\\n            node,n,left=stack.pop()\\n            if node:\\n                ans=max(ans,n)\\n                stack.append((node.left,1 if left else n+1,1))\\n                stack.append((node.right,n+1 if left else 1,0))\\n\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 713290,
                "title": "clean-c-recursive-solution",
                "content": "```\\nint maxPath;\\nvoid dfs(TreeNode *root,bool goLeft, int pathCovered){\\n\\tif(!root) return;\\n\\tmaxPath = max(maxPath,pathCovered);\\n\\tif(goLeft){\\n\\t\\tdfs(root->left,false,pathCovered+1);\\n\\t\\tdfs(root->right,true,1);\\n\\t}else{\\n\\t\\tdfs(root->left,false,1);\\n\\t\\tdfs(root->right,true,pathCovered+1);\\n\\t}\\n}\\nint longestZigZag(TreeNode* root) {\\n\\tmaxPath = 0;\\n\\tdfs(root,false,0);\\n\\tdfs(root,true,0);\\n\\treturn maxPath;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxPath;\\nvoid dfs(TreeNode *root,bool goLeft, int pathCovered){\\n\\tif(!root) return;\\n\\tmaxPath = max(maxPath,pathCovered);\\n\\tif(goLeft){\\n\\t\\tdfs(root->left,false,pathCovered+1);\\n\\t\\tdfs(root->right,true,1);\\n\\t}else{\\n\\t\\tdfs(root->left,false,1);\\n\\t\\tdfs(root->right,true,pathCovered+1);\\n\\t}\\n}\\nint longestZigZag(TreeNode* root) {\\n\\tmaxPath = 0;\\n\\tdfs(root,false,0);\\n\\tdfs(root,true,0);\\n\\treturn maxPath;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433774,
                "title": "c-solution-using-recursion-in-0-n-and-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlways think of the zigzag path that can be formed using current node via left subtree and right subtree and find the maximum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the current node is a null node return a pair of {0,0} denoting the zigzag path is of length 0. Now, for every node calculate maximum zigzag path using left subtree and then using right subtree and maximize the ans.\\n\\n# Complexity\\n- Time complexity: O(n) -> where n is the number of nodes in tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) -> space used + O(h) -> where h is the maximum height of tree i.e. recursion stack space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> helper(TreeNode* root, int &ans) {\\n        if(root == NULL) return {0,0};\\n        pair<int,int> l = helper(root->left,ans);\\n        ans = max(ans,1+l.second);\\n        pair<int,int> r = helper(root->right,ans);\\n        ans = max(ans,1+r.first);\\n        return {1+l.second,1+r.first};\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        helper(root,ans);\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> helper(TreeNode* root, int &ans) {\\n        if(root == NULL) return {0,0};\\n        pair<int,int> l = helper(root->left,ans);\\n        ans = max(ans,1+l.second);\\n        pair<int,int> r = helper(root->right,ans);\\n        ans = max(ans,1+r.first);\\n        return {1+l.second,1+r.first};\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        helper(root,ans);\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777694,
                "title": "c-easy-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        queue<pair<pair<TreeNode*,char>,int>>q;\\n        if(!root)\\n            return 0;\\n        if(root->left)\\n            q.push({{root->left,\\'L\\'},1});\\n        if(root->right)\\n            q.push({{root->right,\\'R\\'},1});\\n        int maxiLen = 0;\\n        while(!q.empty())\\n        {\\n            pair<pair<TreeNode*,char>,int> pr = q.front();q.pop();\\n            \\n            TreeNode* node = pr.first.first;\\n            char nodeDir = pr.first.second;\\n            int len = pr.second;\\n            \\n            maxiLen = max(maxiLen, len);\\n           //  cout<<node->val<< \" \"<<nodeDir<<\" \"<<len<<endl;\\n            if(node->left)\\n            {\\n                if(nodeDir == \\'L\\')\\n                    q.push({{node->left,\\'L\\'},1});\\n                else\\n                    q.push({{node->left,\\'L\\'},len+1});\\n            }\\n            if(node->right)\\n            {\\n                if(nodeDir == \\'R\\')\\n                    q.push({{node->right,\\'R\\'},1});\\n                else\\n                    q.push({{node->right,\\'R\\'},len+1});\\n            }\\n        }\\n        return maxiLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        queue<pair<pair<TreeNode*,char>,int>>q;\\n        if(!root)\\n            return 0;\\n        if(root->left)\\n            q.push({{root->left,\\'L\\'},1});\\n        if(root->right)\\n            q.push({{root->right,\\'R\\'},1});\\n        int maxiLen = 0;\\n        while(!q.empty())\\n        {\\n            pair<pair<TreeNode*,char>,int> pr = q.front();q.pop();\\n            \\n            TreeNode* node = pr.first.first;\\n            char nodeDir = pr.first.second;\\n            int len = pr.second;\\n            \\n            maxiLen = max(maxiLen, len);\\n           //  cout<<node->val<< \" \"<<nodeDir<<\" \"<<len<<endl;\\n            if(node->left)\\n            {\\n                if(nodeDir == \\'L\\')\\n                    q.push({{node->left,\\'L\\'},1});\\n                else\\n                    q.push({{node->left,\\'L\\'},len+1});\\n            }\\n            if(node->right)\\n            {\\n                if(nodeDir == \\'R\\')\\n                    q.push({{node->right,\\'R\\'},1});\\n                else\\n                    q.push({{node->right,\\'R\\'},len+1});\\n            }\\n        }\\n        return maxiLen;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 538986,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) Use two counters for left `L` and right `R` to track each node\\'s maximum zig-zag length, ie. similar to Kadane\\'s algorithm we track the \"best ending here\" at each `node` as we traverse the tree.\\n\\n**\\uD83E\\uDD14 Recurrence relations:** let `node` be a child of the `last` node seen during a DFS traversal of the tree\\n* if `node` is the *right* child of `last`, then `L[node] = 1 + R[last]`\\n* if `node` if the *left* child of `last`, then `R[node] = 1 + L[last]`\\n\\n\\uD83C\\uDFAF Return the maximum value of `L` and `R` minus `1`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun longestZigZag(root: TreeNode?): Int {\\n        var (L, R) = Pair(mutableMapOf<TreeNode?, Int>(), mutableMapOf<TreeNode?, Int>())\\n        fun go(node: TreeNode? = root, last: TreeNode? = null) {\\n            if (node == null)\\n                return\\n            L[node] = 1 + if (last != null && last.left != node) R[last] ?: 0 else 0\\n            R[node] = 1 + if (last != null && last.right != node) L[last] ?: 0 else 0\\n            go(node?.left, node)\\n            go(node?.right, node)\\n        }\\n        go()\\n        return Math.max(L.values.max()!!, R.values.max()!!) - 1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet longestZigZag = (root, L = new Map(), R = new Map()) => {\\n    let go = (node = root, last = null) => {\\n        if (!node)\\n            return;\\n        L.set(node, 1 + (last && last.left != node ? (R.get(last) || 0) : 0));\\n        R.set(node, 1 + (last && last.right != node ? (L.get(last) || 0) : 0));\\n        go(node.left, node);\\n        go(node.right, node);\\n    };\\n    go();\\n    return Math.max(...L.values(), ...R.values()) - 1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        L = Counter()\\n        R = Counter()\\n        def go(node = root, last = None):\\n            if not node:\\n                return\\n            L[node] = 1 + (R[last] if last and last.left != node else 0)\\n            R[node] = 1 + (L[last] if last and last.right != node else 0)\\n            go(node.left, node)\\n            go(node.right, node)\\n        go()\\n        return max(*L.values(), *R.values()) - 1\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using fun = function<void(TreeNode*, TreeNode*)>;\\n    using Map = unordered_map<TreeNode*, int>;\\n    using VI = vector<int>;\\n    int longestZigZag(TreeNode* root, Map L = {}, Map R = {}, VI cands = {}) {\\n        fun go = [&](auto node, auto last) {\\n            if (!node)\\n                return;\\n            L[node] = 1 + (last && last->left != node ? R[last] : 0);\\n            R[node] = 1 + (last && last->right != node ? L[last] : 0);\\n            go(node->left, node);\\n            go(node->right, node);\\n        };\\n        go(root, nullptr);\\n        transform(L.begin(), L.end(), back_inserter(cands), [](auto& pair) { return pair.second; });\\n        transform(R.begin(), R.end(), back_inserter(cands), [](auto& pair) { return pair.second; });\\n        return *max_element(cands.begin(), cands.end()) - 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun longestZigZag(root: TreeNode?): Int {\\n        var (L, R) = Pair(mutableMapOf<TreeNode?, Int>(), mutableMapOf<TreeNode?, Int>())\\n        fun go(node: TreeNode? = root, last: TreeNode? = null) {\\n            if (node == null)\\n                return\\n            L[node] = 1 + if (last != null && last.left != node) R[last] ?: 0 else 0\\n            R[node] = 1 + if (last != null && last.right != node) L[last] ?: 0 else 0\\n            go(node?.left, node)\\n            go(node?.right, node)\\n        }\\n        go()\\n        return Math.max(L.values.max()!!, R.values.max()!!) - 1\\n    }\\n}\\n```\n```\\nlet longestZigZag = (root, L = new Map(), R = new Map()) => {\\n    let go = (node = root, last = null) => {\\n        if (!node)\\n            return;\\n        L.set(node, 1 + (last && last.left != node ? (R.get(last) || 0) : 0));\\n        R.set(node, 1 + (last && last.right != node ? (L.get(last) || 0) : 0));\\n        go(node.left, node);\\n        go(node.right, node);\\n    };\\n    go();\\n    return Math.max(...L.values(), ...R.values()) - 1;\\n};\\n```\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        L = Counter()\\n        R = Counter()\\n        def go(node = root, last = None):\\n            if not node:\\n                return\\n            L[node] = 1 + (R[last] if last and last.left != node else 0)\\n            R[node] = 1 + (L[last] if last and last.right != node else 0)\\n            go(node.left, node)\\n            go(node.right, node)\\n        go()\\n        return max(*L.values(), *R.values()) - 1\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<void(TreeNode*, TreeNode*)>;\\n    using Map = unordered_map<TreeNode*, int>;\\n    using VI = vector<int>;\\n    int longestZigZag(TreeNode* root, Map L = {}, Map R = {}, VI cands = {}) {\\n        fun go = [&](auto node, auto last) {\\n            if (!node)\\n                return;\\n            L[node] = 1 + (last && last->left != node ? R[last] : 0);\\n            R[node] = 1 + (last && last->right != node ? L[last] : 0);\\n            go(node->left, node);\\n            go(node->right, node);\\n        };\\n        go(root, nullptr);\\n        transform(L.begin(), L.end(), back_inserter(cands), [](auto& pair) { return pair.second; });\\n        transform(R.begin(), R.end(), back_inserter(cands), [](auto& pair) { return pair.second; });\\n        return *max_element(cands.begin(), cands.end()) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531878,
                "title": "python-iterative-dfs",
                "content": "```\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        ans = 0\\n        nodes = [(root, False, 0), (root, True, 0)]\\n        while nodes:\\n            node, right, length = nodes.pop()\\n            if node:\\n\\t\\t\\t\\tans = max(ans, length)\\n\\t\\t\\t\\tnodes.append((node.right if right else node.left, not right, length + 1))\\n\\t\\t\\t\\tnodes.append((node.left if right else node.right, right, 1))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        ans = 0\\n        nodes = [(root, False, 0), (root, True, 0)]\\n        while nodes:\\n            node, right, length = nodes.pop()\\n            if node:\\n\\t\\t\\t\\tans = max(ans, length)\\n\\t\\t\\t\\tnodes.append((node.right if right else node.left, not right, length + 1))\\n\\t\\t\\t\\tnodes.append((node.left if right else node.right, right, 1))\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3435925,
                "title": "dfs-solution-java-solution-o-n",
                "content": "# Approach\\n1. The code follows a depth-first search (DFS) approach to traverse the binary tree and find the longest zigzag path. It uses a recursive helper function called dfs to perform the DFS.\\n2. The **dfs function** takes a node, a length of the path so far, and a boolean flag indicating whether the previous node traversed was a left child or a right child.\\n3. For each node, the function updates the **ans** variable if the current length is greater than the current **ans**. It then recursively calls itself on the node\\'s left and right child nodes, passing the length of the path so far incremented by 1, and the opposite of the **isLeft** flag of the current node.\\n4. By doing this, the function explores all possible zigzag paths in the binary tree and returns the length of the longest one. \\n5. The main function calls the **dfs function** twice, once for the left subtree of the root node with **isLeft** set to true and once for the right subtree of the root node with **isLeft** set to false. \\n6. Finally, it returns the value of **ans**, which holds the length of the longest zigzag path found.\\n\\n---\\n\\n- **DO NOT USE** *static int ans=0* , it will give error in the next testcase.\\n\\n# Complexity\\n- Time complexity: The time complexity of the given code is **O(n)**, where n is the number of nodes in the binary tree. \\n\\n- Space complexity: The space complexity of the code is **O(h)**, where h is the height of the binary tree.\\n\\n# Code\\n```\\nclass Solution {\\n     int ans=0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root.left,1,true);\\n        dfs(root.right,1,false);\\n        return ans;\\n        \\n    }\\n    public void dfs(TreeNode node,int len,boolean isLeft)\\n    {\\n        if(node==null)\\n            return;\\n        ans=Math.max(len,ans);\\n        if(isLeft)\\n        {\\n            dfs(node.right,len+1,false);\\n            dfs(node.left,1,true);\\n        }\\n        else\\n        {\\n            dfs(node.right,1,false);\\n            dfs(node.left,len+1,true);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n     int ans=0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root.left,1,true);\\n        dfs(root.right,1,false);\\n        return ans;\\n        \\n    }\\n    public void dfs(TreeNode node,int len,boolean isLeft)\\n    {\\n        if(node==null)\\n            return;\\n        ans=Math.max(len,ans);\\n        if(isLeft)\\n        {\\n            dfs(node.right,len+1,false);\\n            dfs(node.left,1,true);\\n        }\\n        else\\n        {\\n            dfs(node.right,1,false);\\n            dfs(node.left,len+1,true);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435126,
                "title": "beginner-friendly-solution-c-solution-95-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The idea is to get the maximum length of zigzag sequence for each node.\\n- Checking Left-Right-Left or Right-Left-Right, sequence for each node.\\n\\n# Approach\\nChoose a convention to traverse in a zigzag manner, for example\\n> 0 or false  for going left\\n>1 or true for going right\\n\\nThe idea is to traverse the tree in a zigzag manner\\n1. If node is Null, return the control back\\n2. For every node check the maximum length of \\n[left zigzag sequence(L->R->L), Right Zigzag sequence (R->L->R)]\\n3. If the sequence continue, keep increasing the length \\n4. Else, make the current node as the starting point and repeat steps 1,2,3,4\\n5. For each recursive call, keep updating the maximum length \\n\\nOnce all the nodes have been traversed, return the maximum length - 1\\n\\n# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity : $$O(1)$$, Ignoring the Recursive stack that was used\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution // Direction = 0, means we went left\\n{              // Direction = 1, means we went right\\npublic:\\n    int max_len = 0; // Store the maximum length in the max_lenwer variable\\n    void Get_Maximum_Length(TreeNode *node, int direction, int curr_length)\\n    {\\n        if (node == NULL) // If Node is Null, then its an end point\\n            return;       // Just return back the control\\n\\n        max_len = max(max_len, curr_length); // Storing the maximum length so far\\n\\n        if (direction == 0) // If Direction is 0,\\n        {                   // i.e. The current Node is the left part of the sequence\\n\\n            // Now we go right and increase the current length by 1\\n            Get_Maximum_Length(node->right, 1, curr_length + 1);\\n\\n            // If we go left again, we will not be making a zigzag sequence\\n            // And so we have to neglect the current length.\\n            // And find a path with current node as the starting point\\n            // Therefore we hold the current node as centre and traverse to the left\\n            // We send curr_length as 2, because if the left exists then surely there will\\n            // At least Two nodes in this sequence, hence length = 2\\n            Get_Maximum_Length(node->left, 0, 2);\\n        }\\n        else // Direction is 1,\\n        {    // i.e. The current Node is the right part of the sequence\\n\\n            // Now we go left and increase the current length by 1\\n            Get_Maximum_Length(node->left, 0, curr_length + 1);\\n\\n            // If we go right again, we will not be making a zigzag sequence\\n            // And so we have to neglect the current length.\\n            // And find a path with current node as the starting point\\n            // Therefore we hold the current node as centre and traverse to the right\\n            // We send curr_length as 2, because if the right exists then surely there will\\n            // At least Two nodes in this sequence, and hence length = 2\\n            Get_Maximum_Length(node->right, 1, 2);\\n        }\\n    }\\n    int longestZigZag(TreeNode *root)\\n    {\\n        // Check the maximum length to the left\\n        Get_Maximum_Length(root, 0, 1);\\n        // Check the maximum length to the right\\n        Get_Maximum_Length(root, 1, 1);\\n        // Returning max_len - 1, as asked in the question\\n        return max_len - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution // Direction = 0, means we went left\\n{              // Direction = 1, means we went right\\npublic:\\n    int max_len = 0; // Store the maximum length in the max_lenwer variable\\n    void Get_Maximum_Length(TreeNode *node, int direction, int curr_length)\\n    {\\n        if (node == NULL) // If Node is Null, then its an end point\\n            return;       // Just return back the control\\n\\n        max_len = max(max_len, curr_length); // Storing the maximum length so far\\n\\n        if (direction == 0) // If Direction is 0,\\n        {                   // i.e. The current Node is the left part of the sequence\\n\\n            // Now we go right and increase the current length by 1\\n            Get_Maximum_Length(node->right, 1, curr_length + 1);\\n\\n            // If we go left again, we will not be making a zigzag sequence\\n            // And so we have to neglect the current length.\\n            // And find a path with current node as the starting point\\n            // Therefore we hold the current node as centre and traverse to the left\\n            // We send curr_length as 2, because if the left exists then surely there will\\n            // At least Two nodes in this sequence, hence length = 2\\n            Get_Maximum_Length(node->left, 0, 2);\\n        }\\n        else // Direction is 1,\\n        {    // i.e. The current Node is the right part of the sequence\\n\\n            // Now we go left and increase the current length by 1\\n            Get_Maximum_Length(node->left, 0, curr_length + 1);\\n\\n            // If we go right again, we will not be making a zigzag sequence\\n            // And so we have to neglect the current length.\\n            // And find a path with current node as the starting point\\n            // Therefore we hold the current node as centre and traverse to the right\\n            // We send curr_length as 2, because if the right exists then surely there will\\n            // At least Two nodes in this sequence, and hence length = 2\\n            Get_Maximum_Length(node->right, 1, 2);\\n        }\\n    }\\n    int longestZigZag(TreeNode *root)\\n    {\\n        // Check the maximum length to the left\\n        Get_Maximum_Length(root, 0, 1);\\n        // Check the maximum length to the right\\n        Get_Maximum_Length(root, 1, 1);\\n        // Returning max_len - 1, as asked in the question\\n        return max_len - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434714,
                "title": "c-solution-easy-and-explained-recursive-code-commented-and-explained",
                "content": "![20230419_121913000_iOS.jpg](https://assets.leetcode.com/users/images/e4729c9b-4349-4601-8796-45d714581655_1681907007.8512464.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void zig(bool dir,int &max_len,TreeNode* node,int length){\\n        if(node == NULL){\\n            return;\\n        }\\n        max_len = max(length,max_len);\\n        zig(0,max_len,node->left,dir?length+1:1); // dir=0 i.e. 0 means left node, if dir=1 that means this node was at right side previously and if dir=0 that means that this node was at left side previously\\n        zig(1,max_len,node->right,dir?1:length+1); // dir=1 i.e. 1 means right node,  \\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int max_len=0;\\n        zig(0,max_len,root,0);  // At root node, left and right both nodes qualify as the zig-zag path\\n        zig(1,max_len,root,0);  // That\\'s why we called function 2 times with different dir\\n        return max_len;        \\n    }\\n};\\n```\\n![upvote cat.jpeg](https://assets.leetcode.com/users/images/6ac9f885-df47-414d-8e35-b20f6bc3b9ed_1681906739.2323492.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void zig(bool dir,int &max_len,TreeNode* node,int length){\\n        if(node == NULL){\\n            return;\\n        }\\n        max_len = max(length,max_len);\\n        zig(0,max_len,node->left,dir?length+1:1); // dir=0 i.e. 0 means left node, if dir=1 that means this node was at right side previously and if dir=0 that means that this node was at left side previously\\n        zig(1,max_len,node->right,dir?1:length+1); // dir=1 i.e. 1 means right node,  \\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int max_len=0;\\n        zig(0,max_len,root,0);  // At root node, left and right both nodes qualify as the zig-zag path\\n        zig(1,max_len,root,0);  // That\\'s why we called function 2 times with different dir\\n        return max_len;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433533,
                "title": "easy-c-solution-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int maxLen = 0;\\n        dfs(root, maxLen);\\n        return maxLen;\\n    }\\n    \\n    pair<int, int> dfs(TreeNode* node, int& maxLen) {\\n        if (!node) {\\n            return {0, 0};\\n        }\\n        \\n        auto left = dfs(node->left, maxLen);\\n        auto right = dfs(node->right, maxLen);\\n        \\n        int leftMax = left.second, rightMax = right.first;\\n        maxLen = max(maxLen, max(leftMax, rightMax));\\n        \\n        return {1 + left.second, 1 + right.first};\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int maxLen = 0;\\n        dfs(root, maxLen);\\n        return maxLen;\\n    }\\n    \\n    pair<int, int> dfs(TreeNode* node, int& maxLen) {\\n        if (!node) {\\n            return {0, 0};\\n        }\\n        \\n        auto left = dfs(node->left, maxLen);\\n        auto right = dfs(node->right, maxLen);\\n        \\n        int leftMax = left.second, rightMax = right.first;\\n        maxLen = max(maxLen, max(leftMax, rightMax));\\n        \\n        return {1 + left.second, 1 + right.first};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433531,
                "title": "python3-solution-with-explanation-longest-zigzag-path-in-a-binary-tree",
                "content": "**Approach** :\\n\\nWe can use a recursive Depth First Search (DFS) approach to traverse the binary tree and keep track of the length of the longest ZigZag path seen so far.\\n\\nWe can define a helper function **dfs** that takes four arguments: the current node being visited, the length of the longest ZigZag path seen so far when the last move was to the left, the length of the longest ZigZag path seen so far when the last move was to the right, and the overall maximum length of any ZigZag path seen so far.\\n\\nIn each recursive call of the **dfs** function, we update the overall maximum length seen so far to the maximum of the current **max_len**, **left_len**, and **right_len**. We then make two recursive calls, one for the left child and one for the right child. We update the length of the ZigZag path seen so far in the left and right recursive calls based on the direction of the last move (left or right) and set the other length to zero.\\n\\nFinally, we return the updated **max_len** value after all nodes in the binary tree have been visited.\\n\\n**Time Complexity** :\\n\\nThe time complexity of this approach is **O(n)**, where **n** is the number of nodes in the binary tree. This is because we visit each node exactly once during the DFS traversal.\\n\\n**Space Complexity** :\\n\\nThe space complexity of this approach is **O(h)**, where **h** is the height of the binary tree. This is because the depth of the recursive call stack is equal to the height of the binary tree.\\n\\n**Solution** :\\n\\n```\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        def dfs(node: TreeNode, left_len: int, right_len: int, max_len: int) -> int:\\n            if not node:\\n                return max_len\\n            max_len = max(max_len, left_len, right_len)\\n            return max(\\n                dfs(node.left, 0, left_len + 1, max_len),\\n                dfs(node.right, right_len + 1, 0, max_len),\\n            )\\n        return dfs(root, 0, 0, 0)\\n````",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        def dfs(node: TreeNode, left_len: int, right_len: int, max_len: int) -> int:\\n            if not node:\\n                return max_len\\n            max_len = max(max_len, left_len, right_len)\\n            return max(\\n                dfs(node.left, 0, left_len + 1, max_len),\\n                dfs(node.right, right_len + 1, 0, max_len),\\n            )\\n        return dfs(root, 0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974248,
                "title": "c-readable-code-using-pair-class-and-recursion-o-n-complexity",
                "content": "```\\nclass Pair {\\npublic:\\n    int forwardSlash = -1;\\n    int backwardSlash = -1;\\n    int maxZZ = 0;\\n};\\n\\nclass Solution {\\npublic:\\n    Pair findZigZag(TreeNode* root){\\n        if(!root) {\\n            Pair nodeAns;\\n            return nodeAns; //returning default values i.e., -1, -1, 0\\n        }\\n        \\n        Pair left = findZigZag(root->left);\\n        Pair right = findZigZag(root->right);\\n        \\n        Pair nodeAns;\\n        \\n\\t\\t//finding maximium ZigZag path -> [continious or past maximum path]\\n        nodeAns.maxZZ = max(max(left.maxZZ, right.maxZZ) ,max(left.backwardSlash, right.forwardSlash)+1); \\n\\t\\t\\n\\t\\t//finding current path\\n\\t\\t\\n\\t\\t//Remember we need to find Zig Zag path ->relate the following code accordingly!\\n        nodeAns.forwardSlash = left.backwardSlash +1;\\n        nodeAns.backwardSlash = right.forwardSlash +1;\\n        \\n        return nodeAns;\\n    }\\n    \\n    \\n    int longestZigZag(TreeNode* root) {\\n        Pair maxi = findZigZag(root);\\n        \\n        return maxi.maxZZ;\\n    }\\n};\\n```\\n\\n-> The code is not completely explained because I want to make sure that you\\'ll try to think on your own and understand better. This will make sure that the next time you see a similar question you can realize and apply this approach on your own.\\n\\n-> If you still cannot understand my approach feel free to ask me in comments... I\\'ll definitely try to help as soon as possible!\\n\\nThank you\\nP.S.:-  Please upvote if you like my approach!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Pair {\\npublic:\\n    int forwardSlash = -1;\\n    int backwardSlash = -1;\\n    int maxZZ = 0;\\n};\\n\\nclass Solution {\\npublic:\\n    Pair findZigZag(TreeNode* root){\\n        if(!root) {\\n            Pair nodeAns;\\n            return nodeAns; //returning default values i.e., -1, -1, 0\\n        }\\n        \\n        Pair left = findZigZag(root->left);\\n        Pair right = findZigZag(root->right);\\n        \\n        Pair nodeAns;\\n        \\n\\t\\t//finding maximium ZigZag path -> [continious or past maximum path]\\n        nodeAns.maxZZ = max(max(left.maxZZ, right.maxZZ) ,max(left.backwardSlash, right.forwardSlash)+1); \\n\\t\\t\\n\\t\\t//finding current path\\n\\t\\t\\n\\t\\t//Remember we need to find Zig Zag path ->relate the following code accordingly!\\n        nodeAns.forwardSlash = left.backwardSlash +1;\\n        nodeAns.backwardSlash = right.forwardSlash +1;\\n        \\n        return nodeAns;\\n    }\\n    \\n    \\n    int longestZigZag(TreeNode* root) {\\n        Pair maxi = findZigZag(root);\\n        \\n        return maxi.maxZZ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549701,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int maxi = 0;\\n    pair<int, int> rec(TreeNode *root)\\n    {\\n        if (root == NULL)\\n        {\\n            return {0, 0};\\n        }\\n        pair<int, int> left = rec(root->left);\\n        pair<int, int> right = rec(root->right);\\n        maxi = max({maxi,1 + left.second,1 + right.first});\\n        return {1 + left.second, 1 + right.first};\\n    }\\n\\n    int longestZigZag(TreeNode *root)\\n    {\\n        rec(root);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maxi = 0;\\n    pair<int, int> rec(TreeNode *root)\\n    {\\n        if (root == NULL)\\n        {\\n            return {0, 0};\\n        }\\n        pair<int, int> left = rec(root->left);\\n        pair<int, int> right = rec(root->right);\\n        maxi = max({maxi,1 + left.second,1 + right.first});\\n        return {1 + left.second, 1 + right.first};\\n    }\\n\\n    int longestZigZag(TreeNode *root)\\n    {\\n        rec(root);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794014,
                "title": "c-passing-data-from-bottom-to-up",
                "content": "**Keep in mind:-** There are always two methods to pass data from one node to another node in recursion(except global variable)\\n1. from top to bottom\\n2.  from bottom to up\\n3.  to solve any problem(specifically of tree) always think like this,it will help.\\n\\nI am returning ```{left,right}``` from every node,\\n1. left means-> length of path starting from that node and moving towards left,\\n2.  right means:- length of path starting from that node and moving towards right\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    int longestZigZag(TreeNode* root) {\\n        ans=0;\\n        find(root);\\n        return ans-1;\\n    }\\n    pair<int,int> find(TreeNode*root){\\n        if(!root)\\n            return {0,0};\\n        auto left=find(root->left);\\n        auto right=find(root->right);\\n        int leftCnt=1+left.second,rightCnt=1+right.first;\\n        ans=max(ans,max(leftCnt,rightCnt));\\n        return {leftCnt,rightCnt};\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```{left,right}```\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    int longestZigZag(TreeNode* root) {\\n        ans=0;\\n        find(root);\\n        return ans-1;\\n    }\\n    pair<int,int> find(TreeNode*root){\\n        if(!root)\\n            return {0,0};\\n        auto left=find(root->left);\\n        auto right=find(root->right);\\n        int leftCnt=1+left.second,rightCnt=1+right.first;\\n        ans=max(ans,max(leftCnt,rightCnt));\\n        return {leftCnt,rightCnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536952,
                "title": "python-recursion-sol-and-iteration-sol-easy-and-clean",
                "content": "# Iteration\\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        if not root: return res\\n        q= deque() # node, isLeft, depth\\n        if root.left: \\n            q.append((root.left,True,1))\\n        if root.right:\\n            q.append((root.right, False,1))\\n        \\n        while q:\\n            node,isleft,depth = q.popleft()\\n            res = max(res,depth)\\n            if isleft:\\n                if node.right: \\n                    q.append((node.right,False,depth+1))\\n                if node.left:\\n                    q.append((node.left,True,1))\\n                \\n            else:\\n                if node.left:\\n                    q.append((node.left,True,depth+1))\\n                if node.right:\\n                    q.append((node.right,False,1))\\n        return res\\n```\\n# Recursion\\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.res = 0\\n        self.dfs(root.left,True,1)\\n        self.dfs(root.right,False,1)\\n        return self.res\\n    \\n    def dfs(self,node,isLeft,depth):\\n        if not node: return\\n        self.res = max(self.res,depth)\\n        \\n        if isLeft:\\n            self.dfs(node.left,True,1)\\n            self.dfs(node.right,False,depth+1)\\n        else:\\n            self.dfs(node.left,True,depth+1)\\n            self.dfs(node.right,False,1)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        if not root: return res\\n        q= deque() # node, isLeft, depth\\n        if root.left: \\n            q.append((root.left,True,1))\\n        if root.right:\\n            q.append((root.right, False,1))\\n        \\n        while q:\\n            node,isleft,depth = q.popleft()\\n            res = max(res,depth)\\n            if isleft:\\n                if node.right: \\n                    q.append((node.right,False,depth+1))\\n                if node.left:\\n                    q.append((node.left,True,1))\\n                \\n            else:\\n                if node.left:\\n                    q.append((node.left,True,depth+1))\\n                if node.right:\\n                    q.append((node.right,False,1))\\n        return res\\n```\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.res = 0\\n        self.dfs(root.left,True,1)\\n        self.dfs(root.right,False,1)\\n        return self.res\\n    \\n    def dfs(self,node,isLeft,depth):\\n        if not node: return\\n        self.res = max(self.res,depth)\\n        \\n        if isLeft:\\n            self.dfs(node.left,True,1)\\n            self.dfs(node.right,False,depth+1)\\n        else:\\n            self.dfs(node.left,True,depth+1)\\n            self.dfs(node.right,False,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436432,
                "title": "java-c-javascript-step-by-step-to-1-liner",
                "content": "# Approach\\nDo a DFS keeping track of `left` zigzag path and `right` zigzag path terminating at current `node`. They are both `0` at `root`.\\n\\n`left` zigzag path means current `node` is a left child of its parent and similar definition for `right`.\\n\\nIf we move to `node.left` (a left turn), we are able to extend `right` zigzag path by 1. Also note from `node.left`\\'s point of view, this `right + 1` is actually a *left* zigzag path (because `node.left` is a left child of its parent). *right* zigzag path however becomes `0` since `node.left` is not a right child of its parent. So `node.left` receives `left = right + 1` and `right = 0` from its parent.\\n\\nSimilar reasoning applies for `node.right`.\\n\\nOur path terminates when we reach a `null` node but by that point, we have already counted `leaf node -> null` into the path, so we just take `max(left, right) - 1`. (We are only interested in either `left` or `right` but since other would anyway be `0`, `max()` would work).\\n\\n# Code\\n\\nJava\\n```\\nclass Solution {\\n    private int dfs(TreeNode node, int left, int right) {\\n        if (node == null) return Math.max(left, right) - 1;\\n        int bestPathLeft = dfs(node.left, right + 1, 0);\\n        int bestPathRight = dfs(node.right, 0, left + 1);\\n        return Math.max(bestPathLeft, bestPathRight);\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root, 0, 0);\\n    }\\n}\\n```\\n\\nOptimization 1: If we set initial path values as `-1`, we don\\'t need to do `max() - 1` at `null` node.\\nOptimization 2: Let\\'s use ternary operator.\\n\\n```\\nclass Solution {\\n    private int dfs(TreeNode node, int left, int right) {\\n        return node == null ? Math.max(left, right) : Math.max(dfs(node.left, right + 1, -1), dfs(node.right, -1, left + 1));\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root, -1, -1);\\n    }\\n}\\n```\\n\\nOptimization 3: Use a language that allows default parameters. \\uD83D\\uDE09\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root, int left = -1, int right = -1) {\\n        return !root ? max(left, right) : max(longestZigZag(root->left, right + 1), longestZigZag(root->right, -1, left + 1));\\n    }\\n};\\n```\\n\\nJavaScript\\n```\\nvar longestZigZag = function(root, left = -1, right = -1) {\\n    return !root ? Math.max(left, right) : Math.max(longestZigZag(root.left, right + 1), longestZigZag(root.right, -1, left + 1))\\n};\\n```\\n\\nTime complexity: $$O(n)$$\\nSpace complexity: $$O(n)$$\\n\\nP.S. Don\\'t write such code at work \\uD83D\\uDE05",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    private int dfs(TreeNode node, int left, int right) {\\n        if (node == null) return Math.max(left, right) - 1;\\n        int bestPathLeft = dfs(node.left, right + 1, 0);\\n        int bestPathRight = dfs(node.right, 0, left + 1);\\n        return Math.max(bestPathLeft, bestPathRight);\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root, 0, 0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int dfs(TreeNode node, int left, int right) {\\n        return node == null ? Math.max(left, right) : Math.max(dfs(node.left, right + 1, -1), dfs(node.right, -1, left + 1));\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root, -1, -1);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root, int left = -1, int right = -1) {\\n        return !root ? max(left, right) : max(longestZigZag(root->left, right + 1), longestZigZag(root->right, -1, left + 1));\\n    }\\n};\\n```\n```\\nvar longestZigZag = function(root, left = -1, right = -1) {\\n    return !root ? Math.max(left, right) : Math.max(longestZigZag(root.left, right + 1), longestZigZag(root.right, -1, left + 1))\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436056,
                "title": "java-binary-tree-longest-zigzag-path",
                "content": "\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n     public void dfs(AtomicInteger count, boolean right, TreeNode start, AtomicInteger maxCount)\\n     {\\n         if (start != null)\\n         {\\n             count.set(count.get() + 1);\\n             right = !right;\\n             dfs(count, right, !right ? start.right : start.left, maxCount);\\n             right = !right;\\n             count.set(count.get() + 1);\\n             dfs(count, right, right ? start.left : start.right, maxCount);\\n         }\\n         else {\\n             maxCount.set(Math.max(maxCount.get(), count.get()));\\n             count.set(-1);\\n         }\\n     }\\n     \\n    public int longestZigZag(TreeNode root) {\\n        AtomicInteger count = new AtomicInteger(-1);\\n        AtomicInteger maxCount = new AtomicInteger(0);\\n        dfs(count, true, root, maxCount);\\n         return maxCount.get();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n     public void dfs(AtomicInteger count, boolean right, TreeNode start, AtomicInteger maxCount)\\n     {\\n         if (start != null)\\n         {\\n             count.set(count.get() + 1);\\n             right = !right;\\n             dfs(count, right, !right ? start.right : start.left, maxCount);\\n             right = !right;\\n             count.set(count.get() + 1);\\n             dfs(count, right, right ? start.left : start.right, maxCount);\\n         }\\n         else {\\n             maxCount.set(Math.max(maxCount.get(), count.get()));\\n             count.set(-1);\\n         }\\n     }\\n     \\n    public int longestZigZag(TreeNode root) {\\n        AtomicInteger count = new AtomicInteger(-1);\\n        AtomicInteger maxCount = new AtomicInteger(0);\\n        dfs(count, true, root, maxCount);\\n         return maxCount.get();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434940,
                "title": "day-109-easy-recursion-approach-c",
                "content": "# Intuition and Approach\\nWe have to simply traverse all possible *zig-zag routes* in the tree\\nand we have condition that we have to go in left and right direction alternatively everytime , we can also start taking the path from any internal node\\n\\nSo, we have to go in all possible routes and find the max answer\\n\\nFirstly we have to make a direction factor which tells us which direction(i.e. left or right) we have to go in\\nso if we have to go right the direction : `dir = 1` and for left direction : `dir =0`\\n\\nNow we also have to create an answer(`ans`) factor which calculate our current path length  \\n\\nNow go to code section to understand question better,\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int max_ans=0;\\n    void solve(TreeNode* root,int dir,int ans){\\n        // left = 0, right = 1  --> parameter for taking the direction\\n        //base condition\\n        if(!root){return;}\\n\\n        //updating the answer\\n        max_ans = max(max_ans,ans);\\n\\n        if(dir==0){\\n            //going in the left direction\\n            solve(root->left,1,ans+1);\\n            //going in the right direction again to see if path is possible in the right direction\\n            //ans=1 because we already started our path\\n            solve(root->right,0,1);\\n        }\\n        else{\\n            //going in the right direction\\n            solve(root->right,0,ans+1);\\n            //going in the left direction again to see if path is possible in the left direction\\n            //ans=1 because we already started our path \\n            solve(root->left,1,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        //condition to go in left part\\n        solve(root,0,0);\\n        //condition to go in right part\\n        solve(root,1,0);\\n        return max_ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int max_ans=0;\\n    void solve(TreeNode* root,int dir,int ans){\\n        // left = 0, right = 1  --> parameter for taking the direction\\n        //base condition\\n        if(!root){return;}\\n\\n        //updating the answer\\n        max_ans = max(max_ans,ans);\\n\\n        if(dir==0){\\n            //going in the left direction\\n            solve(root->left,1,ans+1);\\n            //going in the right direction again to see if path is possible in the right direction\\n            //ans=1 because we already started our path\\n            solve(root->right,0,1);\\n        }\\n        else{\\n            //going in the right direction\\n            solve(root->right,0,ans+1);\\n            //going in the left direction again to see if path is possible in the left direction\\n            //ans=1 because we already started our path \\n            solve(root->left,1,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        //condition to go in left part\\n        solve(root,0,0);\\n        //condition to go in right part\\n        solve(root,1,0);\\n        return max_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434260,
                "title": "java-full-explaination-comments-lbeginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just need to keep track of previous move we took \\ni.e we took left or we took right.\\nSimultaneously we need to check the following condition and move forward :-\\nIf we took left then next step we need to take is right and If we took right then next step we need to take is left\\n**Note :-** \\nIf we took left and we dont have next step right then from left will calculate new max zig zag steps we can go and vice versa we need to check for right too. \\n\\n# Complexity\\n- Time complexity: O(N), where N is the number of nodes in the tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(H), where H is the height of the tree.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int maxStep = 0;//to keep track of max no. of steps\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left != null){\\n            helper(root.left,1,false,true);\\n        }\\n        if(root.right != null){\\n            helper(root.right,1,true,false);\\n        }\\n        return maxStep;\\n    }\\n    public void helper(TreeNode node,int step,boolean canGoLeft,boolean canGoRight){\\n        maxStep = Math.max(step,maxStep);//calculate the max at that step\\n        //it means previous step we took was right\\n        if(canGoLeft){\\n            if(node.left != null){\\n                helper(node.left,step+1,false,true);\\n            }\\n            //calculating new zigzag from here onwards\\n            if(node.right != null){\\n                helper(node.right,1,true,false);\\n            }\\n        }\\n        //it means previous step we took was left\\n        if(canGoRight){\\n            if(node.right != null){\\n                helper(node.right,step+1,true,false);\\n            }\\n            //calculating new zigzag from here onwards\\n            if(node.left != null){\\n                helper(node.left,1,false,true);\\n            }\\n        }\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int maxStep = 0;//to keep track of max no. of steps\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left != null){\\n            helper(root.left,1,false,true);\\n        }\\n        if(root.right != null){\\n            helper(root.right,1,true,false);\\n        }\\n        return maxStep;\\n    }\\n    public void helper(TreeNode node,int step,boolean canGoLeft,boolean canGoRight){\\n        maxStep = Math.max(step,maxStep);//calculate the max at that step\\n        //it means previous step we took was right\\n        if(canGoLeft){\\n            if(node.left != null){\\n                helper(node.left,step+1,false,true);\\n            }\\n            //calculating new zigzag from here onwards\\n            if(node.right != null){\\n                helper(node.right,1,true,false);\\n            }\\n        }\\n        //it means previous step we took was left\\n        if(canGoRight){\\n            if(node.right != null){\\n                helper(node.right,step+1,true,false);\\n            }\\n            //calculating new zigzag from here onwards\\n            if(node.left != null){\\n                helper(node.left,1,false,true);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433432,
                "title": "java-dfs-beats-99-8-lines-clean-simple",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ on the stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int max = 0;\\n\\n  private int longestZigZag(TreeNode node, boolean isRight) {\\n    if (node == null) return 0;\\n\\n    var l = longestZigZag(node.left, true);\\n    var r = longestZigZag(node.right, false);\\n\\n    max = Math.max(max, 1 + (isRight ? l : r));\\n\\n    return 1 + (isRight ? r : l);\\n  }\\n\\n  public int longestZigZag(TreeNode root) {\\n    return Math.max(longestZigZag(root, true), max) - 1;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  int max = 0;\\n\\n  private int longestZigZag(TreeNode node, boolean isRight) {\\n    if (node == null) return 0;\\n\\n    var l = longestZigZag(node.left, true);\\n    var r = longestZigZag(node.right, false);\\n\\n    max = Math.max(max, 1 + (isRight ? l : r));\\n\\n    return 1 + (isRight ? r : l);\\n  }\\n\\n  public int longestZigZag(TreeNode root) {\\n    return Math.max(longestZigZag(root, true), max) - 1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433045,
                "title": "a-simple-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar longestZigZag = function(root) {\\n    let max = 0;\\n    \\n    const helper = (node, prev, length) => {\\n    \\n        if(node === null)\\n            return null;\\n        \\n        max = Math.max(max, length);\\n        \\n        helper(node.left, \"l\" , prev === \"r\" ? length + 1 : 1);\\n        helper(node.right, \"r\" , prev === \"l\" ? length + 1 : 1);\\n    }\\n    \\n    \\n    helper(root, \"l\", 0); \\n    helper(root, \"r\", 0);\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar longestZigZag = function(root) {\\n    let max = 0;\\n    \\n    const helper = (node, prev, length) => {\\n    \\n        if(node === null)\\n            return null;\\n        \\n        max = Math.max(max, length);\\n        \\n        helper(node.left, \"l\" , prev === \"r\" ? length + 1 : 1);\\n        helper(node.right, \"r\" , prev === \"l\" ? length + 1 : 1);\\n    }\\n    \\n    \\n    helper(root, \"l\", 0); \\n    helper(root, \"r\", 0);\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1244271,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    vector<int>postorder(TreeNode* root){\\n        \\n        if(root == NULL)\\n            return {-1, -1};\\n        \\n        int left = postorder(root->left)[1] + 1;\\n        int right = postorder(root->right)[0] + 1;\\n        \\n        ans = max({ans, left, right});\\n        return {left, right};\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        \\n        postorder(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    vector<int>postorder(TreeNode* root){\\n        \\n        if(root == NULL)\\n            return {-1, -1};\\n        \\n        int left = postorder(root->left)[1] + 1;\\n        int right = postorder(root->right)[0] + 1;\\n        \\n        ans = max({ans, left, right});\\n        return {left, right};\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        \\n        postorder(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231674,
                "title": "c-solution-memoization-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //0->left,1->right,2->initial node ,both ways possible\\n    \\n    map< pair<TreeNode*,int>,int>mp; \\n    int recurs(TreeNode* root,int direction)\\n    {\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n        \\n        if(mp[{root,direction}]!=0)\\n        {\\n                return mp[{root,direction}];\\n        }\\n        \\n        if(direction==0)\\n        {\\n            return mp[{root,direction}]= recurs(root->right,1)+1;\\n        }\\n        else if(direction==1)\\n        {\\n             return mp[{root,direction}]=recurs(root->left,0)+1;\\n        }\\n        else\\n        {\\n            return mp[{root,direction}]=max(recurs(root->right,1)+1,recurs(root->left,0)+1);\\n        }\\n    }\\n    \\n    \\n    int ans=0;\\n    void pre(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        \\n        ans=max(recurs(root,2),ans);\\n        pre(root->left);\\n        pre(root->right);\\n    }\\n\\n    \\n    \\n    int longestZigZag(TreeNode* root) {\\n        pre(root);\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //0->left,1->right,2->initial node ,both ways possible\\n    \\n    map< pair<TreeNode*,int>,int>mp; \\n    int recurs(TreeNode* root,int direction)\\n    {\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n        \\n        if(mp[{root,direction}]!=0)\\n        {\\n                return mp[{root,direction}];\\n        }\\n        \\n        if(direction==0)\\n        {\\n            return mp[{root,direction}]= recurs(root->right,1)+1;\\n        }\\n        else if(direction==1)\\n        {\\n             return mp[{root,direction}]=recurs(root->left,0)+1;\\n        }\\n        else\\n        {\\n            return mp[{root,direction}]=max(recurs(root->right,1)+1,recurs(root->left,0)+1);\\n        }\\n    }\\n    \\n    \\n    int ans=0;\\n    void pre(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        \\n        ans=max(recurs(root,2),ans);\\n        pre(root->left);\\n        pre(root->right);\\n    }\\n\\n    \\n    \\n    int longestZigZag(TreeNode* root) {\\n        pre(root);\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532242,
                "title": "python-dfs-explanation",
                "content": "* Use \"check\" as a checker that come from which side (left or right)\\n* if come from root, check = 0\\n* elif come from left node, check = 1\\n* elif come from right node, check = 2 \\n* \"count\" is a number of continuous zigzag nodes\\n* \"self.res\" is keep the maximum of \"count\" \\n\\n\\'\\'\\'\\n\\n\\n\\tdef longestZigZag(self, root):\\n\\t\\t\\tcheck = 0 # left = 1, right = 2\\n\\t\\t\\tcount = 0\\n\\t\\t\\tself.res = 0\\n\\n\\t\\t\\tdef dfs(node, count, check):\\n\\t\\t\\t\\tif node:\\n\\t\\t\\t\\t\\tif check == 1: # from left                    \\n\\t\\t\\t\\t\\t\\tdfs(node.left, 0, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, count+1, 2)\\n\\t\\t\\t\\t\\telif check == 2: # from right\\n\\t\\t\\t\\t\\t\\tdfs(node.left, count+1, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, 0, 2)\\n\\t\\t\\t\\t\\telif check == 0: # from root\\n\\t\\t\\t\\t\\t\\tdfs(node.left, count, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, count, 2)\\n\\t\\t\\t\\tself.res = max(self.res, count)\\n\\t\\t\\tdfs(root, count, check)\\n\\t\\t\\treturn self.res\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "* Use \"check\" as a checker that come from which side (left or right)\\n* if come from root, check = 0\\n* elif come from left node, check = 1\\n* elif come from right node, check = 2 \\n* \"count\" is a number of continuous zigzag nodes\\n* \"self.res\" is keep the maximum of \"count\" \\n\\n\\'\\'\\'\\n\\n\\n\\tdef longestZigZag(self, root):\\n\\t\\t\\tcheck = 0 # left = 1, right = 2\\n\\t\\t\\tcount = 0\\n\\t\\t\\tself.res = 0\\n\\n\\t\\t\\tdef dfs(node, count, check):\\n\\t\\t\\t\\tif node:\\n\\t\\t\\t\\t\\tif check == 1: # from left                    \\n\\t\\t\\t\\t\\t\\tdfs(node.left, 0, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, count+1, 2)\\n\\t\\t\\t\\t\\telif check == 2: # from right\\n\\t\\t\\t\\t\\t\\tdfs(node.left, count+1, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, 0, 2)\\n\\t\\t\\t\\t\\telif check == 0: # from root\\n\\t\\t\\t\\t\\t\\tdfs(node.left, count, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, count, 2)\\n\\t\\t\\t\\tself.res = max(self.res, count)\\n\\t\\t\\tdfs(root, count, check)\\n\\t\\t\\treturn self.res\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 531819,
                "title": "c-top-down-recusrion",
                "content": "```\\n#define LEFT 0\\n#define RIGHT 1\\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    void maxZigZag(TreeNode* root, int dir, int curr)\\n    {\\n        if(!root) return;\\n        \\n        //cout<<root->val<<endl;\\n        max1=max(max1,curr);\\n        if(dir==LEFT)\\n        {\\n            if(root->left)\\n            {\\n                maxZigZag(root->left, RIGHT, curr+1);\\n            }\\n            if(root->right){\\n                maxZigZag(root->right, LEFT, 1);\\n            }\\n        }\\n        else\\n        {\\n            if(root->right)\\n            {\\n                maxZigZag(root->right, LEFT, curr+1);\\n            }\\n            if(root->left)\\n            {\\n                maxZigZag(root->left, RIGHT, 1);\\n            }\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        maxZigZag(root,LEFT,0);\\n        return max1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define LEFT 0\\n#define RIGHT 1\\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    void maxZigZag(TreeNode* root, int dir, int curr)\\n    {\\n        if(!root) return;\\n        \\n        //cout<<root->val<<endl;\\n        max1=max(max1,curr);\\n        if(dir==LEFT)\\n        {\\n            if(root->left)\\n            {\\n                maxZigZag(root->left, RIGHT, curr+1);\\n            }\\n            if(root->right){\\n                maxZigZag(root->right, LEFT, 1);\\n            }\\n        }\\n        else\\n        {\\n            if(root->right)\\n            {\\n                maxZigZag(root->right, LEFT, curr+1);\\n            }\\n            if(root->left)\\n            {\\n                maxZigZag(root->left, RIGHT, 1);\\n            }\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        maxZigZag(root,LEFT,0);\\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3435726,
                "title": "c-solution-easy-approach-recursive-code",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count(TreeNode* root,int check,int ans){\\n        if(!root)\\n          return ans;\\n        if(check==0)   //for left child\\n        {\\n            int a=0;\\n            a=count(root->left,1,ans+1);    //zigzag start from any previous node\\n            a=max(a,count(root->right,0,0)); //new zigzag from current node\\n            return a;   //maxi. length of zigzag upto current node\\n        }\\n        if(check==1)   //for right child\\n        {\\n            int b=0;\\n            b=count(root->right,0,ans+1);    //zigzag start from any previous node\\n            b=max(b,count(root->left,1,0));  //new zigzag from current node\\n            return b;   //maxi. length of zigzag upto current node\\n        }\\n        return max(count(root->left,1,0),count(root->right,0,0)); //for root( left child and right child)\\n    }\\n    int longestZigZag(TreeNode* root) {\\n       if(!root)\\n         return 0;\\n        int ans=count(root,-1,0);\\n        return ans;\\n    }\\n};\\n```\\n#Please UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count(TreeNode* root,int check,int ans){\\n        if(!root)\\n          return ans;\\n        if(check==0)   //for left child\\n        {\\n            int a=0;\\n            a=count(root->left,1,ans+1);    //zigzag start from any previous node\\n            a=max(a,count(root->right,0,0)); //new zigzag from current node\\n            return a;   //maxi. length of zigzag upto current node\\n        }\\n        if(check==1)   //for right child\\n        {\\n            int b=0;\\n            b=count(root->right,0,ans+1);    //zigzag start from any previous node\\n            b=max(b,count(root->left,1,0));  //new zigzag from current node\\n            return b;   //maxi. length of zigzag upto current node\\n        }\\n        return max(count(root->left,1,0),count(root->right,0,0)); //for root( left child and right child)\\n    }\\n    int longestZigZag(TreeNode* root) {\\n       if(!root)\\n         return 0;\\n        int ans=count(root,-1,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435693,
                "title": "accepted-swift-solution-using-dfs",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var maxSteps = 0\\n    func longestZigZag(_ root: TreeNode?) -> Int {\\n        dfs(root?.right, true, 1)\\n        dfs(root?.left, false, 1)\\n        return maxSteps\\n    }\\n\\n    func dfs(_ node: TreeNode?, _ isLeft: Bool, _ steps: Int) {\\n        if node == nil {\\n            return\\n        }\\n        maxSteps = max(maxSteps, steps)\\n        if isLeft {\\n            dfs(node?.left, false, steps+1)\\n            dfs(node?.right, true, 1)\\n        } else {\\n            dfs(node?.right, true, steps+1)\\n            dfs(node?.left, false, 1)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var maxSteps = 0\\n    func longestZigZag(_ root: TreeNode?) -> Int {\\n        dfs(root?.right, true, 1)\\n        dfs(root?.left, false, 1)\\n        return maxSteps\\n    }\\n\\n    func dfs(_ node: TreeNode?, _ isLeft: Bool, _ steps: Int) {\\n        if node == nil {\\n            return\\n        }\\n        maxSteps = max(maxSteps, steps)\\n        if isLeft {\\n            dfs(node?.left, false, steps+1)\\n            dfs(node?.right, true, 1)\\n        } else {\\n            dfs(node?.right, true, steps+1)\\n            dfs(node?.left, false, 1)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435555,
                "title": "c-easy-code-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxC = 0;\\n    void count(TreeNode *node, int dir, int curr)\\n    {\\n        if(node == NULL)\\n            return;\\n        maxC = max(maxC, curr);\\n\\n        if(dir == 1){\\n           count(node -> left, 0, curr + 1);\\n            count(node -> right, 1, 1);\\n        }\\n        else\\n        {\\n            count(node -> right, 1, curr + 1);\\n            count(node -> left, 0, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n\\t    // 1 for left, 0 for right\\n        count(root, 1, 0);\\n        count(root, 0, 0);\\n        return maxC;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxC = 0;\\n    void count(TreeNode *node, int dir, int curr)\\n    {\\n        if(node == NULL)\\n            return;\\n        maxC = max(maxC, curr);\\n\\n        if(dir == 1){\\n           count(node -> left, 0, curr + 1);\\n            count(node -> right, 1, 1);\\n        }\\n        else\\n        {\\n            count(node -> right, 1, curr + 1);\\n            count(node -> left, 0, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n\\t    // 1 for left, 0 for right\\n        count(root, 1, 0);\\n        count(root, 0, 0);\\n        return maxC;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435338,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    void solve(TreeNode* node, bool goLeft, int currPathLen) \\n    {\\n        if (!node) return;\\n        res = max(res, currPathLen);\\n        if (goLeft) \\n        {\\n            solve(node->left, false, currPathLen + 1);\\n            solve(node->right, true, 1);\\n        }\\n         else \\n         {\\n            solve(node->right, true, currPathLen + 1);\\n            solve(node->left, false, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root)\\n     {\\n        solve(root, true, 0);\\n        solve(root, false, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    void solve(TreeNode* node, bool goLeft, int currPathLen) \\n    {\\n        if (!node) return;\\n        res = max(res, currPathLen);\\n        if (goLeft) \\n        {\\n            solve(node->left, false, currPathLen + 1);\\n            solve(node->right, true, 1);\\n        }\\n         else \\n         {\\n            solve(node->right, true, currPathLen + 1);\\n            solve(node->left, false, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root)\\n     {\\n        solve(root, true, 0);\\n        solve(root, false, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434952,
                "title": "time-space-98-beats-c-easy-to-understand-dfs",
                "content": "````\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int &ans,int s,int d){\\n        if(root == NULL){\\n            return;\\n        }\\n        ans = max(ans,d);\\n        if(s==1){\\n            solve(root->left,ans,0,d+1);\\n            solve(root->right,ans,1,1);\\n        }else{\\n            solve(root->right,ans,1,d+1);\\n            solve(root->left,ans,0,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        solve(root->left,ans,0,1);\\n        solve(root->right,ans,1,1);\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int &ans,int s,int d){\\n        if(root == NULL){\\n            return;\\n        }\\n        ans = max(ans,d);\\n        if(s==1){\\n            solve(root->left,ans,0,d+1);\\n            solve(root->right,ans,1,1);\\n        }else{\\n            solve(root->right,ans,1,d+1);\\n            solve(root->left,ans,0,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        solve(root->left,ans,0,1);\\n        solve(root->right,ans,1,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434378,
                "title": "java-python-kotlin-golang-intuitive-dfs-recursive-solution",
                "content": "# Intuition\\nAt first , it looks like a DFS to calculate the height of a BST.\\nThen the zigzag forces to alternate direction (right or left). If previous node explored was `left`, then the next node must be `right` ( vice-versa). We have to keep track if the current node should explore left or right.\\n\\n# Approach\\n\\nWe have to keep track if the current node should explore left or right.\\nIn addition not to have a global variable, the level is passed in parameter to the recursive function.\\n\\n```Java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(longestZigZag(root, true, 0), longestZigZag(root, false, 0));\\n    }\\n\\n    public int longestZigZag(TreeNode root, boolean isLeft, int level) {\\n        //System.out.println(\"isLeft = \" + isLeft + \" root = \" + root + \" level = \"+ level);\\n        if(root == null) return level;\\n        \\n        if(isLeft){\\n            if(root.left == null) return level;\\n            return longestZigZag(root.left, false, level + 1);\\n        }else{\\n            if(root.right == null) return level;\\n            return longestZigZag(root.right, true, level + 1);\\n        }\\n\\n    }\\n}\\n```\\n\\nAt first, my initial implementation worked on all except the first example. I assumed the longest always starts from the root node.\\n\\n\\n![leetcode_sample_1_1702.png](https://assets.leetcode.com/users/images/9ab48f18-91f7-4817-b872-cd4845763cf7_1681897926.6954088.png)\\n\\nBut example 1, the longest zig zag doesn\\'t start at the root node. But at the first right child of the root node.\\n`If direction stays the same twice, we have to reset the level to zero`. Otherwise increment the level by one.\\n\\n## Illustration from a left Node\\n```\\n    // TDLR\\n    return Math.max(longestZigZag(root.left, false, level + 1), longestZigZag(root.left, true, 0));\\n\\n    // more detail on this one line.\\n    /**\\n    *\\n    *      x\\n    *     /\\n    *    x\\n    *   /\\n    *  x\\n    *\\n    **/\\n    int leftOfLeft = longestZigZag(root.left, true, 0); // reset level to 0\\n\\n    /**\\n    *\\n    *      x\\n    *     /\\n    *    x\\n    *     \\\\\\n    *      x\\n    *\\n    **/\\n    int rightOfLeft = longestZigZag(root.left, false, level + 1); // keep the zig zag, so increment the level\\n\\n```\\n\\n# Complexity\\n\\n- Time complexity:\\nO(n) , we explore all tree nodes\\n\\n- Space complexity:\\nO(height)\\n\\n# Code\\n\\n```Java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(longestZigZag(root, true, 0), longestZigZag(root, false, 0));\\n    }\\n\\n    public int longestZigZag(TreeNode root, boolean isLeft, int level) {\\n        if(root == null) return level;\\n        \\n        if(isLeft){\\n            if(root.left == null) return level;\\n            // the BST doesn\\'t have to start from the root node. If the same direction is done twice, reset the level to 0\\n            return Math.max(longestZigZag(root.left, false, level + 1), longestZigZag(root.left, true, 0));\\n        }else{\\n            if(root.right == null) return level;\\n            return Math.max(longestZigZag(root.right, true, level + 1), longestZigZag(root.right, false, 0));\\n        }\\n\\n    }\\n}\\n```\\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def longestZigZag(root: Optional[TreeNode], isLeft: bool, level: int) -> int:\\n            if root is None:\\n                return level\\n            \\n            if isLeft:\\n                if root.left is None: return level\\n                return max(longestZigZag(root.left, False, level + 1), longestZigZag(root.left, True, 0))\\n            else:\\n                if root.right is None: return level\\n                return max(longestZigZag(root.right, True, level + 1), longestZigZag(root.right, False, 0))\\n        \\n        return max(longestZigZag(root, True, 0), longestZigZag(root, False, 0))\\n```\\n```kotlin []\\n/**\\n * Example:\\n * var ti = TreeNode(5)\\n * var v = ti.`val`\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n    fun longestZigZag(root: TreeNode?): Int {\\n        return maxOf(longestZigZag(root, true, 0),  longestZigZag(root, false, 0))\\n    }\\n\\n    fun longestZigZag(root: TreeNode?, isLeft: Boolean, level: Int): Int {\\n        if(root == null) return level\\n\\n        if(isLeft){\\n            return root?.left?.let{\\n                 maxOf(longestZigZag(it, false, level + 1), longestZigZag(it,  true, 0))\\n            } ?: level\\n        }else{\\n            return root?.right?.let{\\n                 maxOf(longestZigZag(it, true, level + 1), longestZigZag(it, false, 0))\\n            } ?: level\\n        }\\n    }\\n}\\n\\n```\\n```golang []\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc longestZigZag(root *TreeNode) int {\\n\\treturn max(longestZigZagRec(root, true, 0), longestZigZagRec(root, false, 0))\\n}\\n\\nfunc longestZigZagRec(root *TreeNode, isLeft bool, level int) int {\\n\\tif root == nil {\\n\\t\\treturn level\\n\\t}\\n\\n\\tif isLeft {\\n\\t\\tleft := root.Left\\n\\t\\tif left == nil { return  level}\\n\\t\\treturn max(longestZigZagRec(left, false, level +1 ), longestZigZagRec(left, true, 0))\\n\\t}else{\\n\\t\\tright := root.Right\\n\\t\\tif right == nil {return  level}\\n\\t\\treturn max(longestZigZagRec(right, true, level+1), longestZigZagRec(right, false, 0))\\n\\t}\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```\\n\\nThanks for reading until the end.\\nIf some code is not fluent in their native programming language, please suggest in the comment section.\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Go",
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(longestZigZag(root, true, 0), longestZigZag(root, false, 0));\\n    }\\n\\n    public int longestZigZag(TreeNode root, boolean isLeft, int level) {\\n        //System.out.println(\"isLeft = \" + isLeft + \" root = \" + root + \" level = \"+ level);\\n        if(root == null) return level;\\n        \\n        if(isLeft){\\n            if(root.left == null) return level;\\n            return longestZigZag(root.left, false, level + 1);\\n        }else{\\n            if(root.right == null) return level;\\n            return longestZigZag(root.right, true, level + 1);\\n        }\\n\\n    }\\n}\\n```\n```\\n    // TDLR\\n    return Math.max(longestZigZag(root.left, false, level + 1), longestZigZag(root.left, true, 0));\\n\\n    // more detail on this one line.\\n    /**\\n    *\\n    *      x\\n    *     /\\n    *    x\\n    *   /\\n    *  x\\n    *\\n    **/\\n    int leftOfLeft = longestZigZag(root.left, true, 0); // reset level to 0\\n\\n    /**\\n    *\\n    *      x\\n    *     /\\n    *    x\\n    *     \\\\\\n    *      x\\n    *\\n    **/\\n    int rightOfLeft = longestZigZag(root.left, false, level + 1); // keep the zig zag, so increment the level\\n\\n```\n```Java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(longestZigZag(root, true, 0), longestZigZag(root, false, 0));\\n    }\\n\\n    public int longestZigZag(TreeNode root, boolean isLeft, int level) {\\n        if(root == null) return level;\\n        \\n        if(isLeft){\\n            if(root.left == null) return level;\\n            // the BST doesn\\'t have to start from the root node. If the same direction is done twice, reset the level to 0\\n            return Math.max(longestZigZag(root.left, false, level + 1), longestZigZag(root.left, true, 0));\\n        }else{\\n            if(root.right == null) return level;\\n            return Math.max(longestZigZag(root.right, true, level + 1), longestZigZag(root.right, false, 0));\\n        }\\n\\n    }\\n}\\n```\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def longestZigZag(root: Optional[TreeNode], isLeft: bool, level: int) -> int:\\n            if root is None:\\n                return level\\n            \\n            if isLeft:\\n                if root.left is None: return level\\n                return max(longestZigZag(root.left, False, level + 1), longestZigZag(root.left, True, 0))\\n            else:\\n                if root.right is None: return level\\n                return max(longestZigZag(root.right, True, level + 1), longestZigZag(root.right, False, 0))\\n        \\n        return max(longestZigZag(root, True, 0), longestZigZag(root, False, 0))\\n```\n```kotlin []\\n/**\\n * Example:\\n * var ti = TreeNode(5)\\n * var v = ti.`val`\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n    fun longestZigZag(root: TreeNode?): Int {\\n        return maxOf(longestZigZag(root, true, 0),  longestZigZag(root, false, 0))\\n    }\\n\\n    fun longestZigZag(root: TreeNode?, isLeft: Boolean, level: Int): Int {\\n        if(root == null) return level\\n\\n        if(isLeft){\\n            return root?.left?.let{\\n                 maxOf(longestZigZag(it, false, level + 1), longestZigZag(it,  true, 0))\\n            } ?: level\\n        }else{\\n            return root?.right?.let{\\n                 maxOf(longestZigZag(it, true, level + 1), longestZigZag(it, false, 0))\\n            } ?: level\\n        }\\n    }\\n}\\n\\n```\n```golang []\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc longestZigZag(root *TreeNode) int {\\n\\treturn max(longestZigZagRec(root, true, 0), longestZigZagRec(root, false, 0))\\n}\\n\\nfunc longestZigZagRec(root *TreeNode, isLeft bool, level int) int {\\n\\tif root == nil {\\n\\t\\treturn level\\n\\t}\\n\\n\\tif isLeft {\\n\\t\\tleft := root.Left\\n\\t\\tif left == nil { return  level}\\n\\t\\treturn max(longestZigZagRec(left, false, level +1 ), longestZigZagRec(left, true, 0))\\n\\t}else{\\n\\t\\tright := root.Right\\n\\t\\tif right == nil {return  level}\\n\\t\\treturn max(longestZigZagRec(right, true, level+1), longestZigZagRec(right, false, 0))\\n\\t}\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433966,
                "title": "easy-solution-in-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use 0 for nodes coming from the left and 1 for nodes coming from the right.\\n\\nFirstly, we declare a function that counts the zigzag path. One thing to notice is that if a node comes from the left and then goes left again, the zigzag path will be 1. If a node comes from the left and goes to the right, the zigzag path count will increase by 1 from the previous count and vice versa.\\n\\nThe \"solve\" function takes three parameters: \"root\", which is the treenode, \"dir\" which determines the direction the nodes are coming from, and \"len\" which shows the length of the zigzag path until the current node.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N), where N represents the total number of nodes in the tree. This is because we traverse each node precisely once.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n\\n    void solve(TreeNode* root, int dir, int len){\\n        if(root==NULL)  \\n            return;\\n        ans = max(ans, len);\\n        if(dir==0){\\n            // node comes from the left and then goes left again, the zigzag path will be 1.\\n            solve(root->left, 0, 1);\\n            // node comes from the left and goes to the right, the zigzag path count will increase by 1 from the previous count.\\n            solve(root->right, 1, len+1);\\n        }else{\\n            // node comes from the right and then goes right again, the zigzag path will be 1.\\n            solve(root->left, 0, len+1);\\n            // node comes from the right and goes to the left, the zigzag path count will increase by 1 from the previous count.\\n            solve(root->right, 1, 1);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root->left, 0, 1);\\n        solve(root->right, 1, 1);\\n        return ans;\\n    }\\n};\\n```\\n\\n![images.jpg](https://assets.leetcode.com/users/images/ff765eb1-bf72-408a-a59f-828ffa968ac9_1681889626.1299875.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n\\n    void solve(TreeNode* root, int dir, int len){\\n        if(root==NULL)  \\n            return;\\n        ans = max(ans, len);\\n        if(dir==0){\\n            // node comes from the left and then goes left again, the zigzag path will be 1.\\n            solve(root->left, 0, 1);\\n            // node comes from the left and goes to the right, the zigzag path count will increase by 1 from the previous count.\\n            solve(root->right, 1, len+1);\\n        }else{\\n            // node comes from the right and then goes right again, the zigzag path will be 1.\\n            solve(root->left, 0, len+1);\\n            // node comes from the right and goes to the left, the zigzag path count will increase by 1 from the previous count.\\n            solve(root->right, 1, 1);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root->left, 0, 1);\\n        solve(root->right, 1, 1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433861,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public:\\n    int maxLength=0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength=max(maxLength,currLength);\\n        solve(root->left,0,dir?currLength+1:1);\\n        solve(root->right,1,dir?1:currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    int maxLength=0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength=max(maxLength,currLength);\\n        solve(root->left,0,dir?currLength+1:1);\\n        solve(root->right,1,dir?1:currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433693,
                "title": "post-order-dfs-c",
                "content": "```\\nclass Solution {\\n    pair<int, int> dfs(TreeNode* root, int &ans) {\\n        if(!root) return {0, 0};\\n\\n        auto l = dfs(root -> left, ans);\\n        auto r = dfs(root -> right, ans);\\n\\n        int maxLeft = 1 + l.second;\\n        int maxRight = 1 + r.first;\\n        ans = max(ans, max(maxLeft, maxRight) - 1);\\n\\n        return {maxLeft, maxRight};\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    pair<int, int> dfs(TreeNode* root, int &ans) {\\n        if(!root) return {0, 0};\\n\\n        auto l = dfs(root -> left, ans);\\n        auto r = dfs(root -> right, ans);\\n\\n        int maxLeft = 1 + l.second;\\n        int maxRight = 1 + r.first;\\n        ans = max(ans, max(maxLeft, maxRight) - 1);\\n\\n        return {maxLeft, maxRight};\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433476,
                "title": "simple-python-solution-breadth-first-search",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        q= deque()\\n        q.append([root,\\'\\',0])\\n        ans=0\\n        while(q):\\n            u,prev_dir,cnt=q.popleft()\\n            ans= max(ans,cnt)\\n            if(u.left):\\n                if(prev_dir==\\'r\\'):\\n                    q.append([u.left,\\'l\\',cnt+1])\\n                else:\\n                    q.append([u.left,\\'l\\',1])\\n            if(u.right):\\n                if(prev_dir==\\'l\\'):\\n                    q.append([u.right,\\'r\\',cnt+1])\\n                else:\\n                    q.append([u.right,\\'r\\',1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        q= deque()\\n        q.append([root,\\'\\',0])\\n        ans=0\\n        while(q):\\n            u,prev_dir,cnt=q.popleft()\\n            ans= max(ans,cnt)\\n            if(u.left):\\n                if(prev_dir==\\'r\\'):\\n                    q.append([u.left,\\'l\\',cnt+1])\\n                else:\\n                    q.append([u.left,\\'l\\',1])\\n            if(u.right):\\n                if(prev_dir==\\'l\\'):\\n                    q.append([u.right,\\'r\\',cnt+1])\\n                else:\\n                    q.append([u.right,\\'r\\',1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433419,
                "title": "beats-100-c-15-lines-using-dfs",
                "content": "# Intuition\\nTo understand the intuition behind the given code, we can think of a zigzag path in a binary tree as a path that alternates between going left and going right. The length of the path is the number of edges traversed in the path. For example, in the tree below, the zigzag path with length 4 is indicated by the bold edges:\\n\\n\\n# Approach\\nThe code uses a depth-first search (DFS) approach to traverse the given binary tree. For each node, it computes three values: the length of the longest zigzag path starting from the node and going left, the length of the longest zigzag path starting from the node and going right, and the maximum length of zigzag path found so far in the tree. The maximum length of zigzag path can be obtained by taking the maximum of the three values computed for the root node.\\n\\nThe DFS function dfs takes a node as input and returns a list of three integers. If the node is None, it returns [-1, -1, -1] to indicate that there is no path. Otherwise, it recursively calls dfs on the left and right subtrees of the node and computes the three values described above using the values returned by the recursive calls.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        vector<int> res = dfs(root);\\n        return res[2];\\n    }\\nprivate:\\n    vector<int> dfs(TreeNode* node) {\\n        if (node == nullptr) return {-1, -1, -1};\\n        vector<int> lsubt = dfs(node->left);\\n        vector<int> rsubt = dfs(node->right);\\n        int llen = lsubt[1] + 1;\\n        int rlen = rsubt[0] + 1;\\n        int maxlen = max({llen, rlen, lsubt[2], rsubt[2]});\\n        return {llen, rlen, maxlen};\\n    }\\n};\\n```\\n\\nPlease Upvote",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        vector<int> res = dfs(root);\\n        return res[2];\\n    }\\nprivate:\\n    vector<int> dfs(TreeNode* node) {\\n        if (node == nullptr) return {-1, -1, -1};\\n        vector<int> lsubt = dfs(node->left);\\n        vector<int> rsubt = dfs(node->right);\\n        int llen = lsubt[1] + 1;\\n        int rlen = rsubt[0] + 1;\\n        int maxlen = max({llen, rlen, lsubt[2], rsubt[2]});\\n        return {llen, rlen, maxlen};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433178,
                "title": "ruby-dfs-solution",
                "content": "# Code\\n```\\ndef dfs(root, left, count)\\n  return unless root\\n  @max = [@max, count].max\\n  dfs(root.left, false, left ? count+1 : 1)\\n  dfs(root.right, true, !left ? count+1 : 1)\\nend\\n\\ndef longest_zig_zag(root)\\n  @max = 0\\n  dfs(root, true, 0)\\n  dfs(root, false, 0)\\n  @max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef dfs(root, left, count)\\n  return unless root\\n  @max = [@max, count].max\\n  dfs(root.left, false, left ? count+1 : 1)\\n  dfs(root.right, true, !left ? count+1 : 1)\\nend\\n\\ndef longest_zig_zag(root)\\n  @max = 0\\n  dfs(root, true, 0)\\n  dfs(root, false, 0)\\n  @max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3433050,
                "title": "javascript-4-lines-dfs-time-o-n-100-space-o-n",
                "content": "# Complexity\\n- Time complexity: O(n), beats 100%\\n- Space complexity: O(n), beats 80.4%\\n\\n# Code\\n```\\nconst f = ( r, p, v ) => {\\n    if ( !r ) return v - 1\\n    if ( p ) return Math.max( f( r.left, 0, v+1 ), f( r.right, 1, 1 ) )\\n    else return Math.max( f( r.right, 1, v+1 ), f( r.left, 0, 1 ) )\\n}, longestZigZag = r => Math.max( f( r.left, 0, 1 ), f( r.right, 1, 1 ) )\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nconst f = ( r, p, v ) => {\\n    if ( !r ) return v - 1\\n    if ( p ) return Math.max( f( r.left, 0, v+1 ), f( r.right, 1, 1 ) )\\n    else return Math.max( f( r.right, 1, v+1 ), f( r.left, 0, 1 ) )\\n}, longestZigZag = r => Math.max( f( r.left, 0, 1 ), f( r.right, 1, 1 ) )\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2839142,
                "title": "java-simple-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public void helper(TreeNode root, int temp, String dir) {\\n        ans = Math.max(ans, temp);\\n        if(root == null)\\n            return;\\n        \\n        if(dir.equals(\"left\")) {\\n            helper(root.right, temp + 1, \"right\");\\n            helper(root.left, 1, \"left\");\\n        }\\n        if(dir.equals(\"right\")) {\\n            helper(root.right, 1, \"right\");\\n            helper(root.left, temp + 1, \"left\");\\n        }\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        if(root == null | (root.left == null && root.right == null))\\n            return 0;\\n        helper(root.left, 1, \"left\");\\n        helper(root.right, 1, \"right\");\\n        return ans-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public void helper(TreeNode root, int temp, String dir) {\\n        ans = Math.max(ans, temp);\\n        if(root == null)\\n            return;\\n        \\n        if(dir.equals(\"left\")) {\\n            helper(root.right, temp + 1, \"right\");\\n            helper(root.left, 1, \"left\");\\n        }\\n        if(dir.equals(\"right\")) {\\n            helper(root.right, 1, \"right\");\\n            helper(root.left, temp + 1, \"left\");\\n        }\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        if(root == null | (root.left == null && root.right == null))\\n            return 0;\\n        helper(root.left, 1, \"left\");\\n        helper(root.right, 1, \"right\");\\n        return ans-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870342,
                "title": "o-n-java-solution-with-comment-explanation-easy-to-understand",
                "content": "**Logic :** \\nEvery node have two choices : \\n- Follow the parent direction what his parent want\\n- Don\\'t follow the parent given direction and go reverse direction (may be find longest path)\\n\\nThen update the `max ` accordingly `parent_direction_longest_length` and `child_own_direction_longest_length`.\\n\\n```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root, false);\\n        solve(root, true);\\n        return max;\\n    }\\n\\n    // Right direction -> dir = true\\n    // Left direction -> dir = false\\n    public int solve(TreeNode node, boolean dir) {\\n        if (node == null) return -1;\\n\\n        // if we go right dir from node\\n        int right = ((node.right == null) ? -1 : solve(node.right, false)) + 1;\\n        \\n        // if we go left dir from node\\n        int left = ((node.left == null) ? -1 : solve(node.left, true)) + 1;\\n\\n        // if child is not serious about parent direction\\n        // He want to go own direction for check longest path (reverse of given parent direction)\\n        int childDirProfit = (dir) ? left : right;\\n        // if coming from right go left and vice versa for parent\\n        int parentDirProfit = (dir) ? right : left; \\n\\n        // update the max\\n        max = Math.max(max, Math.max(childDirProfit, parentDirProfit));\\n        \\n        // return what parent wanted\\n        return parentDirProfit;\\n    }\\n}\\n```\\nIt\\'s a simple DFS Solution so it will take `O(n)` times.\\nn = number of node in Tree.\\n\\n\\n**Don\\'t Forget to upvote if you found it helpful :)**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root, false);\\n        solve(root, true);\\n        return max;\\n    }\\n\\n    // Right direction -> dir = true\\n    // Left direction -> dir = false\\n    public int solve(TreeNode node, boolean dir) {\\n        if (node == null) return -1;\\n\\n        // if we go right dir from node\\n        int right = ((node.right == null) ? -1 : solve(node.right, false)) + 1;\\n        \\n        // if we go left dir from node\\n        int left = ((node.left == null) ? -1 : solve(node.left, true)) + 1;\\n\\n        // if child is not serious about parent direction\\n        // He want to go own direction for check longest path (reverse of given parent direction)\\n        int childDirProfit = (dir) ? left : right;\\n        // if coming from right go left and vice versa for parent\\n        int parentDirProfit = (dir) ? right : left; \\n\\n        // update the max\\n        max = Math.max(max, Math.max(childDirProfit, parentDirProfit));\\n        \\n        // return what parent wanted\\n        return parentDirProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457821,
                "title": "c-commented-o-n-postorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // keeps track of no. of nodes in longest zig zag path\\n    int res = 0;\\n    \\n    // post order manner\\n    vector<int> traverse(TreeNode *root){\\n        if(!root) return {0, 0}; // by default NULL node returns path with 0 nodes,\\n        \\n        vector<int> leftDir = traverse(root->left);\\n        vector<int> rightDir = traverse(root->right);\\n        \\n        // currDir[0] - left side and currDir[1] - right side\\n        vector<int> currDir = {0, 0};\\n        \\n        // current\\'s node longest zig zag path in \\'left\\' will be 1 + its left child\\'s \\'right\\' path \\n        currDir[0] = leftDir[1] + 1;\\n        \\n        // current\\'s node longest zig zag path in \\'right\\' will be 1 + its right child\\'s \\'left\\' path\\n        currDir[1] = rightDir[0] + 1;\\n        \\n        // updating the answer\\n        res = max(res, max(currDir[0], currDir[1]));\\n        \\n        return currDir;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        // traverse the whole tree\\n        traverse(root);\\n        \\n        return res - 1; // -1 because we have maximum of number of nodes not path\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // keeps track of no. of nodes in longest zig zag path\\n    int res = 0;\\n    \\n    // post order manner\\n    vector<int> traverse(TreeNode *root){\\n        if(!root) return {0, 0}; // by default NULL node returns path with 0 nodes,\\n        \\n        vector<int> leftDir = traverse(root->left);\\n        vector<int> rightDir = traverse(root->right);\\n        \\n        // currDir[0] - left side and currDir[1] - right side\\n        vector<int> currDir = {0, 0};\\n        \\n        // current\\'s node longest zig zag path in \\'left\\' will be 1 + its left child\\'s \\'right\\' path \\n        currDir[0] = leftDir[1] + 1;\\n        \\n        // current\\'s node longest zig zag path in \\'right\\' will be 1 + its right child\\'s \\'left\\' path\\n        currDir[1] = rightDir[0] + 1;\\n        \\n        // updating the answer\\n        res = max(res, max(currDir[0], currDir[1]));\\n        \\n        return currDir;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        // traverse the whole tree\\n        traverse(root);\\n        \\n        return res - 1; // -1 because we have maximum of number of nodes not path\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414516,
                "title": "recursive-solution-beats-96-72-beginner-friendly-c",
                "content": "We have two options at a particular node.\\nOption 1. we go to same ZigZag path coming from above and add one more edge to previous value.\\nOption 2. we go to different direction than the path coming from above but from here length of path will start from one.\\nThere are two variables one is ans which store overall answer and second is currLength which stores length of path till this node.\\n\\n```\\nclass Solution {\\n    void traverse(TreeNode *root, bool leftToRight, int &ans, int currLength)\\n    {\\n        if (root == NULL)\\n        {\\n            return;\\n        }\\n\\n        ans = max(ans, currLength);\\n\\n        if (leftToRight)\\n        {\\n            traverse(root->right, !leftToRight, ans, currLength + 1);  // option 1\\n            traverse(root->left, leftToRight, ans, 1);                 // option 2\\n        }\\n        else\\n        {\\n            traverse(root->left, !leftToRight, ans, currLength + 1); // option 1\\n            traverse(root->right, leftToRight, ans, 1);              // option 2\\n        }\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        traverse(root, true, ans, 0);\\n        return ans;\\n    }\\n};\\n```\\n\\nTime complexity :-\\n\\tLet us assume that there are N nodes in tree and we are visiting each node ones so time complexity for average case and worst case both is O(N).\\n\\t\\nSpace complexity :-\\n\\tAs you might think that we are calling each node ones so N number of function calls(in funciton stack) will be stored but at any point of time function calls stored will be equal to H (Height of Tree).\\nBecause we are traversing one path at a time so average case space complexity will be O(Log(n)). Worst case will be for skewed tree O(N).\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void traverse(TreeNode *root, bool leftToRight, int &ans, int currLength)\\n    {\\n        if (root == NULL)\\n        {\\n            return;\\n        }\\n\\n        ans = max(ans, currLength);\\n\\n        if (leftToRight)\\n        {\\n            traverse(root->right, !leftToRight, ans, currLength + 1);  // option 1\\n            traverse(root->left, leftToRight, ans, 1);                 // option 2\\n        }\\n        else\\n        {\\n            traverse(root->left, !leftToRight, ans, currLength + 1); // option 1\\n            traverse(root->right, leftToRight, ans, 1);              // option 2\\n        }\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        traverse(root, true, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400458,
                "title": "smallest-and-cleanest-code-ever-dfs-98-95-c",
                "content": "We are defining direction as if its true than go to right else left \\n```\\nclass Solution {\\n    void dfs(TreeNode* root, bool direction, int &ans, int travel){\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        ans = max(ans, travel);\\n        dfs(direction ? root->right : root->left, !direction, ans, travel + 1);\\n        dfs(direction ? root->left : root->right, direction, ans, 1); //This call is to make their own path\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, true, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(TreeNode* root, bool direction, int &ans, int travel){\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        ans = max(ans, travel);\\n        dfs(direction ? root->right : root->left, !direction, ans, travel + 1);\\n        dfs(direction ? root->left : root->right, direction, ans, 1); //This call is to make their own path\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, true, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357661,
                "title": "c-solution-using-pair-left-right-and-maintaining-a-max-variable",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode *root, int &max_zig){\\n        if(root==NULL){\\n            return {0,0};\\n        }\\n        \\n        // pair contain left and right info\\n        // pair<left,right>\\n        // lsub pair contain <left,right> info means if root want right info it can take right and respectively \\n        \\n        pair<int,int> lsub = solve(root->left, max_zig);\\n        pair<int,int> rsub = solve(root->right, max_zig);\\n        \\n        // if given root is right part of parent root \\n        // so left part of our given root will contain 1 + right_subtree.right part\\n        int left = 1 + rsub.second;\\n        \\n        //if root is left part of parent root\\n        int right = 1+ lsub.first;\\n        \\n        // max_zig for maintaining maximum zigzag pattern found in entire traversal\\n        max_zig = max(max_zig,max(left,right));\\n        \\n        return {left,right};\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        if(root==NULL || (root->left==NULL && root->right==NULL)) return 0;\\n        int max_zig = 0;\\n        pair<int,int> res = solve(root,max_zig);\\n        return max_zig-1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode *root, int &max_zig){\\n        if(root==NULL){\\n            return {0,0};\\n        }\\n        \\n        // pair contain left and right info\\n        // pair<left,right>\\n        // lsub pair contain <left,right> info means if root want right info it can take right and respectively \\n        \\n        pair<int,int> lsub = solve(root->left, max_zig);\\n        pair<int,int> rsub = solve(root->right, max_zig);\\n        \\n        // if given root is right part of parent root \\n        // so left part of our given root will contain 1 + right_subtree.right part\\n        int left = 1 + rsub.second;\\n        \\n        //if root is left part of parent root\\n        int right = 1+ lsub.first;\\n        \\n        // max_zig for maintaining maximum zigzag pattern found in entire traversal\\n        max_zig = max(max_zig,max(left,right));\\n        \\n        return {left,right};\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        if(root==NULL || (root->left==NULL && root->right==NULL)) return 0;\\n        int max_zig = 0;\\n        pair<int,int> res = solve(root,max_zig);\\n        return max_zig-1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246342,
                "title": "c-short-and-concise-solution-with-explanation-memoization",
                "content": "##### Hi!\\n##### I have kept my code as short as possible.\\n##### Please upvote if you like it and feel free to share your opinion.*\\n```\\nclass Solution {\\npublic:\\n\\t// pair to store the length of pattern at current node depending on the direction\\n    map<pair<TreeNode*,bool>,int>mp;\\n\\t\\n    int helper(TreeNode* root,bool isRight,int length){\\n        if(!root)\\n            return length-1; // -1 to remove the extra step taken to reach NULL node\\n\\t\\t\\t\\n        if(mp.find({root,isRight})!=mp.end()) //check memo\\n            return mp[{root,isRight}];\\n\\t\\t\\t\\n\\t\\t\\t/*   now we have two choices\\n\\t\\t\\t*    either continue the pattern or start pattern from the begining  \\n\\t\\t\\t*    or start a new pattern with length 1\\n\\t\\t\\t*    memoize and return max of both*/\\n\\t\\t\\t\\n        if(isRight)\\n            mp[{root,isRight}]= max(helper(root->left,false,length+1),helper(root->right,true,1)); \\n        else\\n            mp[{root,isRight}]= max(helper(root->right,true,length+1),helper(root->left,false,1));\\n        return mp[{root,isRight}];\\n    }\\n\\t\\n    int longestZigZag(TreeNode* root) {\\n        return max(helper(root->right,true,1),helper(root->left,false,1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// pair to store the length of pattern at current node depending on the direction\\n    map<pair<TreeNode*,bool>,int>mp;\\n\\t\\n    int helper(TreeNode* root,bool isRight,int length){\\n        if(!root)\\n            return length-1; // -1 to remove the extra step taken to reach NULL node\\n\\t\\t\\t\\n        if(mp.find({root,isRight})!=mp.end()) //check memo\\n            return mp[{root,isRight}];\\n\\t\\t\\t\\n\\t\\t\\t/*   now we have two choices\\n\\t\\t\\t*    either continue the pattern or start pattern from the begining  \\n\\t\\t\\t*    or start a new pattern with length 1\\n\\t\\t\\t*    memoize and return max of both*/\\n\\t\\t\\t\\n        if(isRight)\\n            mp[{root,isRight}]= max(helper(root->left,false,length+1),helper(root->right,true,1)); \\n        else\\n            mp[{root,isRight}]= max(helper(root->right,true,length+1),helper(root->left,false,1));\\n        return mp[{root,isRight}];\\n    }\\n\\t\\n    int longestZigZag(TreeNode* root) {\\n        return max(helper(root->right,true,1),helper(root->left,false,1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888591,
                "title": "simple-java-code-with-recursion-no-arrays-used",
                "content": "There are 5 cases, \\n\\n1. The highest zig zag traversak has been reached at the current node. No more zig zag traversals can be performed, either because it is a leaf node or further traversals are all in the same direction\\n2. The highest traversal is found by continuing the current zig zag traversal in the left subtree\\n3. The highest traversal is found by continuing the current zig zag traversal in the right subtree\\n4. The highest traversal exists in left subtree, but is unconnected to the current zig zag traversal\\n5. The highest traversal exists in right subtree, but is unconnected to the current zig zag traversal\\n\\nWhen the the previous traversal is a left move and the next traversal is right move or vice versa, we increment the traversal count. This is because it is part of the same zig zag traversal. \\n\\nIf the previous traversal and next traversal are the same (i.e. left followed by left or right followed by right), then it is the start of a new zig zag traversal and the count is reset to 1. \\n\\nThe unconnected zig zag traversals in the left and right subtrees can be smaller than zig zag traversal of reaching the current node. We must get the max value of the current traversal value with the traversal values of left and right subtree.\\n\\nIf a leaf node is reached, the zig zag count are returned as is, since no more traversal can happen\\n\\n```\\n    public int longestZigZag(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        return Math.max(root.left != null ? performZigZag(root.left, 1, true) : 0, \\n                        root.right != null ? performZigZag(root.right, 1, false) : 0);\\n        \\n    }\\n    \\n    public int performZigZag(TreeNode node, int count, boolean prevLeft) {           \\n        if (node.left == null && node.right == null) {\\n            return count;\\n        }\\n        \\n        return Math.max(count, Math.max(\\n            node.left != null ? performZigZag(node.left, prevLeft ? 1 : count + 1, true) : 0, \\n            node.right != null ? performZigZag(node.right, prevLeft ? count + 1 : 1, false) : 0));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestZigZag(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        return Math.max(root.left != null ? performZigZag(root.left, 1, true) : 0, \\n                        root.right != null ? performZigZag(root.right, 1, false) : 0);\\n        \\n    }\\n    \\n    public int performZigZag(TreeNode node, int count, boolean prevLeft) {           \\n        if (node.left == null && node.right == null) {\\n            return count;\\n        }\\n        \\n        return Math.max(count, Math.max(\\n            node.left != null ? performZigZag(node.left, prevLeft ? 1 : count + 1, true) : 0, \\n            node.right != null ? performZigZag(node.right, prevLeft ? count + 1 : 1, false) : 0));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 837271,
                "title": "java-dfs-solution-similar-to-lc-124",
                "content": "This problem can be solved simialr to https://leetcode.com/problems/binary-tree-maximum-path-sum/\\n\\nYou can consider the individial subtree by itself or consider the parent. So, check both possibilities.\\n\\nFurther optimization include, memoization to reduce the recHelper calls.\\n```\\n    int ans = Integer.MIN_VALUE;\\n    private int dfs(TreeNode root, boolean isLeft) {\\n        if (root == null)\\n            return -1;\\n        \\n        int left = dfs(root.left, true) + 1;\\n        int right = dfs(root.right, false) + 1;\\n        \\n        ans = Math.max(ans, Math.max(left, right));\\n        \\n        if (isLeft) {\\n            return right;\\n        } else {\\n            return left;\\n        }\\n    }\\n    \\n    public int longestZigZag(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        \\n        int left = dfs(root.left, true);\\n        int right = dfs(root.right, false);\\n        ans = Math.max(ans, Math.max(left, right) + 1);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int ans = Integer.MIN_VALUE;\\n    private int dfs(TreeNode root, boolean isLeft) {\\n        if (root == null)\\n            return -1;\\n        \\n        int left = dfs(root.left, true) + 1;\\n        int right = dfs(root.right, false) + 1;\\n        \\n        ans = Math.max(ans, Math.max(left, right));\\n        \\n        if (isLeft) {\\n            return right;\\n        } else {\\n            return left;\\n        }\\n    }\\n    \\n    public int longestZigZag(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        \\n        int left = dfs(root.left, true);\\n        int right = dfs(root.right, false);\\n        ans = Math.max(ans, Math.max(left, right) + 1);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739536,
                "title": "python-clean-dfs",
                "content": "```\\nclass Solution:\\n    def longestZigZag(self, root):\\n\\n        self.max_length = 0\\n        self.find_path(root, root)\\n        return self.max_length-1\\n    def find_path(self, root, parent):\\n        if root is None:\\n            return 0\\n        left = self.find_path(root.left, root)\\n        right = self.find_path(root.right, root)\\n\\n        self.max_length = max(self.max_length, max(left, right)+1)\\n\\n        if root == parent.left:\\n            return right+1\\n        else:\\n            return left+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root):\\n\\n        self.max_length = 0\\n        self.find_path(root, root)\\n        return self.max_length-1\\n    def find_path(self, root, parent):\\n        if root is None:\\n            return 0\\n        left = self.find_path(root.left, root)\\n        right = self.find_path(root.right, root)\\n\\n        self.max_length = max(self.max_length, max(left, right)+1)\\n\\n        if root == parent.left:\\n            return right+1\\n        else:\\n            return left+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722647,
                "title": "c-postorder-traversal-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int result=0;\\n    pair<int,int> postorder(TreeNode* root)\\n    {\\n        if(root==NULL) return {0,0};\\n        \\n        pair<int,int>curr;\\n        \\n        pair<int,int>left=postorder(root->left);\\n        pair<int,int>right=postorder(root->right);\\n        \\n        int lefttoright=1+left.second;//ZigZag path length If we take right from left child\\n        int righttoleft=1+right.first;//ZigZag path length If we take left from right child\\n        result=max(result,max(left.second,right.first));//Stores Maximum length zig zag path\\n        curr={lefttoright,righttoleft};\\n        return curr;\\n    }\\n    \\n    \\n    int longestZigZag(TreeNode* root) {\\n      postorder(root);\\n      return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int result=0;\\n    pair<int,int> postorder(TreeNode* root)\\n    {\\n        if(root==NULL) return {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 531859,
                "title": "python-dfs-with-direction-of-parent",
                "content": "The idea is to use DFS with direction where the node came from. If the child node has a same direction, reset the count to 1. Otherwise, keep incremeting the count.\\n\\n``` py\\n\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        def dfs(node, parent, cnt):\\n            if not node:\\n                return\\n\\t\\t\\tself.res = max(self.res, cnt)\\n            dfs(node.left, \\'left\\', (cnt + 1) if parent == \\'right\\' else 1)\\n            dfs(node.right, \\'right\\', (cnt + 1) if parent == \\'left\\' else 1)    \\n\\n        self.res = 0\\n        dfs(root, None, 0)\\n        return self.res\\n\\t\\t\\n```\\t\\t",
                "solutionTags": [],
                "code": "``` py\\n\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        def dfs(node, parent, cnt):\\n            if not node:\\n                return\\n\\t\\t\\tself.res = max(self.res, cnt)\\n            dfs(node.left, \\'left\\', (cnt + 1) if parent == \\'right\\' else 1)\\n            dfs(node.right, \\'right\\', (cnt + 1) if parent == \\'left\\' else 1)    \\n\\n        self.res = 0\\n        dfs(root, None, 0)\\n        return self.res\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962256,
                "title": "easy-java-dfs-with-and-without-global-variable-and-with-global-variable",
                "content": "Method 1: Using global variable\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root==null)\\n            return -1;\\n        helper(root.right,1,true);\\n        helper(root.left,1,false);\\n        return max;\\n    }\\n    public void helper(TreeNode root,int step, boolean isright){\\n        if(root==null)\\n            return ;\\n        max = Math.max(max,step);\\n        if(isright){\\n            helper(root.left,step+1,false);\\n            helper(root.right,1,true);\\n        }\\n        else{\\n            helper(root.right,step+1,true);\\n            helper(root.left,1,false);\\n        }\\n    }\\n}\\n```\\n\\nMethod 2: Without Global variable\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        if(root==null)\\n            return -1;\\n        return Math.max(helper(root.right,1,true),\\n        helper(root.left,1,false));\\n    }\\n    public int helper(TreeNode root,int step, boolean isright){\\n        if(root==null)\\n            return 0;\\n        int left = 0;\\n        int right = 0;\\n        if(isright){\\n            left = helper(root.left,step+1,false);\\n            right = helper(root.right,1,true);\\n        }\\n        else{\\n            right = helper(root.right,step+1,true);\\n            left = helper(root.left,1,false);\\n        }\\n        return Math.max(step,Math.max(left,right));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root==null)\\n            return -1;\\n        helper(root.right,1,true);\\n        helper(root.left,1,false);\\n        return max;\\n    }\\n    public void helper(TreeNode root,int step, boolean isright){\\n        if(root==null)\\n            return ;\\n        max = Math.max(max,step);\\n        if(isright){\\n            helper(root.left,step+1,false);\\n            helper(root.right,1,true);\\n        }\\n        else{\\n            helper(root.right,step+1,true);\\n            helper(root.left,1,false);\\n        }\\n    }\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        if(root==null)\\n            return -1;\\n        return Math.max(helper(root.right,1,true),\\n        helper(root.left,1,false));\\n    }\\n    public int helper(TreeNode root,int step, boolean isright){\\n        if(root==null)\\n            return 0;\\n        int left = 0;\\n        int right = 0;\\n        if(isright){\\n            left = helper(root.left,step+1,false);\\n            right = helper(root.right,1,true);\\n        }\\n        else{\\n            right = helper(root.right,step+1,true);\\n            left = helper(root.left,1,false);\\n        }\\n        return Math.max(step,Math.max(left,right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598938,
                "title": "python-solution-using-recursion-and-further-memoization",
                "content": "\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        dp = {}\\n\\n        def chk(node , dir):\\n            if node == None: return 0\\n\\n            if (node , dir) in dp: return dp[(node , dir)]\\n\\n            if dir == \"left\":\\n                if node.right:\\n                    dp[(node , dir)] = 1 + chk(node.right , \"right\")\\n                    return dp[(node , dir)]\\n\\n            elif dir == \"right\":\\n                if node.left:\\n                    dp[(node , dir)] = 1 + chk(node.left , \"left\")\\n                    return dp[(node , dir)]\\n            return 0\\n\\n        ans = -1\\n        def inorder(node):\\n            nonlocal ans\\n            if node == None: return \\n            inorder(node.left)\\n            ans = max( ans , chk(node , \"left\") )\\n            ans = max( ans , chk(node , \"right\"))\\n            inorder(node.right)\\n        \\n        inorder(root)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        dp = {}\\n\\n        def chk(node , dir):\\n            if node == None: return 0\\n\\n            if (node , dir) in dp: return dp[(node , dir)]\\n\\n            if dir == \"left\":\\n                if node.right:\\n                    dp[(node , dir)] = 1 + chk(node.right , \"right\")\\n                    return dp[(node , dir)]\\n\\n            elif dir == \"right\":\\n                if node.left:\\n                    dp[(node , dir)] = 1 + chk(node.left , \"left\")\\n                    return dp[(node , dir)]\\n            return 0\\n\\n        ans = -1\\n        def inorder(node):\\n            nonlocal ans\\n            if node == None: return \\n            inorder(node.left)\\n            ans = max( ans , chk(node , \"left\") )\\n            ans = max( ans , chk(node , \"right\"))\\n            inorder(node.right)\\n        \\n        inorder(root)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457726,
                "title": "java-dfs-no-global-variables",
                "content": "# Approach\\nDFS with in-place calculation of result. Addition of global result field can make execution faster since we will not need to make extra max comparison, but I prefer to keep the class clean, if possible.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nodes)$$\\n\\n- Space complexity:\\n$$O(height)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(helper(root, 0, true), helper(root, 0, false));\\n    }\\n\\n    private int helper(TreeNode node, int path, boolean isLeft) {\\n        if (node == null) return 0;\\n        int left = helper(node.left, isLeft ? 0 : path + 1, !isLeft);\\n        int right = helper(node.right, isLeft ? path + 1 : 0, !isLeft);\\n        return Math.max(path, Math.max(left, right));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(helper(root, 0, true), helper(root, 0, false));\\n    }\\n\\n    private int helper(TreeNode node, int path, boolean isLeft) {\\n        if (node == null) return 0;\\n        int left = helper(node.left, isLeft ? 0 : path + 1, !isLeft);\\n        int right = helper(node.right, isLeft ? path + 1 : 0, !isLeft);\\n        return Math.max(path, Math.max(left, right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450296,
                "title": "c-find-longest-zigzag-in-binary-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\n#define LEFT    -1\\n#define RIGHT   1\\n#define START   0\\n\\nint max = 0;\\n\\n// Recursion to check all the ZigZag variations\\nvoid longestZigZagRecur(struct TreeNode* root, int way, int length_curr)\\n{\\n    if(length_curr > max)\\n    {\\n        max = length_curr;\\n    }\\n\\n    if((root->right == NULL) && (root->left == NULL))\\n    {\\n        return;\\n    }\\n\\n    if(root->right != NULL)\\n    {\\n        longestZigZagRecur(root->right, RIGHT, ((way == LEFT))? length_curr + 1 : 1);\\n    }\\n\\n    if(root->left != NULL)\\n    {\\n        longestZigZagRecur(root->left, LEFT, ((way == RIGHT))? length_curr + 1 : 1);\\n    }\\n}\\n\\nint longestZigZag(struct TreeNode* root)\\n{\\n    max = 0;\\n\\n    if(root->left == NULL && root->right == NULL)\\n    {\\n        return 0;\\n    }\\n\\n    longestZigZagRecur(root, START, 1);\\n\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\n#define LEFT    -1\\n#define RIGHT   1\\n#define START   0\\n\\nint max = 0;\\n\\n// Recursion to check all the ZigZag variations\\nvoid longestZigZagRecur(struct TreeNode* root, int way, int length_curr)\\n{\\n    if(length_curr > max)\\n    {\\n        max = length_curr;\\n    }\\n\\n    if((root->right == NULL) && (root->left == NULL))\\n    {\\n        return;\\n    }\\n\\n    if(root->right != NULL)\\n    {\\n        longestZigZagRecur(root->right, RIGHT, ((way == LEFT))? length_curr + 1 : 1);\\n    }\\n\\n    if(root->left != NULL)\\n    {\\n        longestZigZagRecur(root->left, LEFT, ((way == RIGHT))? length_curr + 1 : 1);\\n    }\\n}\\n\\nint longestZigZag(struct TreeNode* root)\\n{\\n    max = 0;\\n\\n    if(root->left == NULL && root->right == NULL)\\n    {\\n        return 0;\\n    }\\n\\n    longestZigZagRecur(root, START, 1);\\n\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440174,
                "title": "java-o-n-recursion",
                "content": "# Intuition\\nThe one way that comes to mind is to find all possible paths but with given nodes can as much as $$10 ^ 4$$ this solution goes in n$$O(n ^2)$$\\nSo intuition was to optimize this approach. \\nTo optimize we can do:\\n1. keep track of know length and calculate the max length in one traversal\\n2. reduce the unnecessary paths (as valid paths are only zigzags so we can eliminate non-zigzag paths)\\n3. eliminate the calculation of subpaths as parent paths already are bigger than subpath (implies function strictly follows zigzag path)\\n\\n# Approach\\n1. create a function that can traverse the tree in the zigZag pattern (recursive functions work in case of trees) \\n2. maintain a global variable max and update it at every end of each path (i.e. where root == null)\\n3. for every node start a new calculation for the opposite direction with length 0 (this will calculate strictly the opposite direction as a path in the same direction, starting a calculation from current node will be a subpath of the already calculated path)\\n\\n# Complexity\\n- Time complexity:\\nIn this approach each node is visited only once so time complexity $$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n       zigZag(root, 0, 0);\\n       return max;\\n    }\\n\\n    //score is current number of nodes in path\\n    //direction 0 is for left and 1 for right\\n    public void zigZag(TreeNode root, int score, int direction){\\n        if(root == null){\\n            //zigZag fuction caculates the number of nodes for max path so length will be score - 1, i.e. for 4 nodes path will be 3.\\n            max = Math.max(max, score - 1);\\n            return;\\n        }\\n\\n        if(direction == 0){\\n            zigZag(root.left, score+1, 1);\\n            //spliting into opposite possiblity with score 1 i.e. reseting score to 0 and +1 of root node\\n            zigZag(root.right, 1, 0);\\n        }else{\\n            zigZag(root.right, score+1, 0);\\n            zigZag(root.left, 1, 1);\\n        }\\n    }\\n}\\n```\\n# **Its my first solution, Please tell me if I\\'ve messed up**\\n![images.jfif](https://assets.leetcode.com/users/images/76597852-b4f1-4146-9ba1-ae0e37c73e2d_1682059638.439474.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n       zigZag(root, 0, 0);\\n       return max;\\n    }\\n\\n    //score is current number of nodes in path\\n    //direction 0 is for left and 1 for right\\n    public void zigZag(TreeNode root, int score, int direction){\\n        if(root == null){\\n            //zigZag fuction caculates the number of nodes for max path so length will be score - 1, i.e. for 4 nodes path will be 3.\\n            max = Math.max(max, score - 1);\\n            return;\\n        }\\n\\n        if(direction == 0){\\n            zigZag(root.left, score+1, 1);\\n            //spliting into opposite possiblity with score 1 i.e. reseting score to 0 and +1 of root node\\n            zigZag(root.right, 1, 0);\\n        }else{\\n            zigZag(root.right, score+1, 0);\\n            zigZag(root.left, 1, 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436431,
                "title": "intuitive-python-solution-solution-blog",
                "content": "# Welcome to my Solution Blog!\\n![Copy of Copy of 617 ALG (2).png](https://assets.leetcode.com/users/images/9f9bbc79-74b6-4bb1-9383-7e44175139f7_1681946631.0889835.png)\\n\\n**Base Case:**\\nWhen you hit a leaf node -> return the depth and it\\'ll propagate up the tree and be returned!\\n\\n**Two Paths from here!**\\n\\nIf you went left previously, take the maximum of:\\n1. the current depth\\n2. now going down the right path, and incrementing the depth by 1\\n3. go down the left path AGAIN, and reset depth to 0\\n\\nThen repeat this logic (but reversed) for if you went right previously.\\n\\n\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        return max(self.helper(root.left, True, 0), self.helper(root.right, False, 0))\\n    \\n    def helper(self, root, isLeft, depth):\\n        if not root: return depth\\n\\n        if isLeft:\\n            depth = max(\\n                depth,\\n                self.helper(root.right, False, depth + 1),\\n                self.helper(root.left, True, 0)\\n            )\\n        \\n        else: # otherwise we previously went\\n            depth = max(\\n                depth,\\n                self.helper(root.left, True, depth + 1),\\n                self.helper(root.right, False, 0)\\n            )\\n        return depth\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        return max(self.helper(root.left, True, 0), self.helper(root.right, False, 0))\\n    \\n    def helper(self, root, isLeft, depth):\\n        if not root: return depth\\n\\n        if isLeft:\\n            depth = max(\\n                depth,\\n                self.helper(root.right, False, depth + 1),\\n                self.helper(root.left, True, 0)\\n            )\\n        \\n        else: # otherwise we previously went\\n            depth = max(\\n                depth,\\n                self.helper(root.left, True, depth + 1),\\n                self.helper(root.right, False, 0)\\n            )\\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436145,
                "title": "easy-c-top-down-solution",
                "content": "# Intuition\\nJust consider as waterfalling with bouncing.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\nTop Down \\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n\\nclass Solution {\\npublic:\\n\\n    int max=0;\\n    void lng(TreeNode* root,bool dir,int ln){\\n        if(max<ln)max=ln;\\n        if(dir){//dir == 1 as root direction is right\\n            if(root->left !=nullptr) lng(root->left,0,ln+1);//right to left increase length\\n            if(root->right !=nullptr)lng(root->right,1,1);//new starting point\\n        }\\n        else{//dir == 0 as root direction is left\\n            if(root->left !=nullptr) lng(root->left,0,1);//new starting point\\n            if(root->right !=nullptr)lng(root->right,1,ln+1);//left to right increase length\\n        }\\n        return ;\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(root)lng(root, 0, 0);\\n        return max;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int max=0;\\n    void lng(TreeNode* root,bool dir,int ln){\\n        if(max<ln)max=ln;\\n        if(dir){//dir == 1 as root direction is right\\n            if(root->left !=nullptr) lng(root->left,0,ln+1);//right to left increase length\\n            if(root->right !=nullptr)lng(root->right,1,1);//new starting point\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3435540,
                "title": "java-recursive-solution-pre-order-traversal",
                "content": "# Intuition\\nTraverse the tree and keep a boolean to identify reft and left and keep count accordingly.\\n# Approach\\nTraverse the tree\\n    keep boolean to identify previous move\\n    increment/set count accordingly\\n    check for max and update\\nreturn max;\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left != null){\\n            traverse(root.left,true,1);\\n        }\\n        if(root.right != null){\\n            traverse(root.right,false,1);\\n        }\\n        return max;\\n    }\\n    public void traverse(TreeNode root,boolean left,int count){\\n        if(max < count){\\n            max = count;\\n        }\\n        if(root.left != null){\\n            traverse(root.left,true,!left?count+1:1);\\n        }\\n        if(root.right != null){\\n            traverse(root.right,false,left?count+1:1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left != null){\\n            traverse(root.left,true,1);\\n        }\\n        if(root.right != null){\\n            traverse(root.right,false,1);\\n        }\\n        return max;\\n    }\\n    public void traverse(TreeNode root,boolean left,int count){\\n        if(max < count){\\n            max = count;\\n        }\\n        if(root.left != null){\\n            traverse(root.left,true,!left?count+1:1);\\n        }\\n        if(root.right != null){\\n            traverse(root.right,false,left?count+1:1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435468,
                "title": "c-easy-solution-easy-recursion-solution",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint ans=0;\\n    void dfs(TreeNode* root,bool last,int len)\\n    {\\n        if(!root) return;\\n        ans=max(ans,len);\\n        if(!last)\\n        {\\n            dfs(root->left,false,1);\\n            dfs(root->right,true,len+1);\\n        }\\n        else\\n        {\\n            dfs(root->left,false,len+1);\\n            dfs(root->right,true,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root->left,false,1);\\n        dfs(root->right,true,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint ans=0;\\n    void dfs(TreeNode* root,bool last,int len)\\n    {\\n        if(!root) return;\\n        ans=max(ans,len);\\n        if(!last)\\n        {\\n            dfs(root->left,false,1);\\n            dfs(root->right,true,len+1);\\n        }\\n        else\\n        {\\n            dfs(root->left,false,len+1);\\n            dfs(root->right,true,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root->left,false,1);\\n        dfs(root->right,true,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435314,
                "title": "python3-dfs-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n\\n        def dfs(root,direction,depth):\\n            \\n            nonlocal res\\n            if not root:\\n                return \\n            res=max(res,depth)\\n\\n            if direction==-1:\\n                dfs(root.right,1,depth+1)\\n                dfs(root.left,-1,1)\\n\\n            else:\\n                dfs(root.left,-1,depth+1)\\n                dfs(root.right,1,1)\\n            \\n        res=0\\n        dfs(root,1,0)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n\\n        def dfs(root,direction,depth):\\n            \\n            nonlocal res\\n            if not root:\\n                return \\n            res=max(res,depth)\\n\\n            if direction==-1:\\n                dfs(root.right,1,depth+1)\\n                dfs(root.left,-1,1)\\n\\n            else:\\n                dfs(root.left,-1,depth+1)\\n                dfs(root.right,1,1)\\n            \\n        res=0\\n        dfs(root,1,0)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434968,
                "title": "easy-solution-in-java-recursion",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxLen = 0;\\n    public int longestZigZag(TreeNode root) {\\n        helper(root, 0, 0);  \\n        helper(root, 1, 0);  \\n        return maxLen;  \\n    }\\n\\n    public void helper(TreeNode root, int path, int currentLen){\\n        if(root == null)\\n            return;\\n        maxLen = Math.max(maxLen, currentLen);\\n        if(path == 1)\\n        {\\n            helper(root.left, 0, currentLen + 1);\\n            helper(root.right, 1, 1);\\n        }\\n        else\\n        {\\n            helper(root.right, 1, currentLen + 1);\\n            helper(root.left, 0, 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxLen = 0;\\n    public int longestZigZag(TreeNode root) {\\n        helper(root, 0, 0);  \\n        helper(root, 1, 0);  \\n        return maxLen;  \\n    }\\n\\n    public void helper(TreeNode root, int path, int currentLen){\\n        if(root == null)\\n            return;\\n        maxLen = Math.max(maxLen, currentLen);\\n        if(path == 1)\\n        {\\n            helper(root.left, 0, currentLen + 1);\\n            helper(root.right, 1, 1);\\n        }\\n        else\\n        {\\n            helper(root.right, 1, currentLen + 1);\\n            helper(root.left, 0, 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434642,
                "title": "java-beats-100-optimal-solution-easy-explanation-beginner-friendly-dfs",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n**CODE WITHOUT COMMENTS BELOW**\\n\\n**UPVOTE PLEASE !!!**\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max=0; // to store max\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left!=null){\\n           helper(root.left,true,1);    // going left adding 1 node\\n        }\\n        if(root.right!=null){\\n            helper(root.right,false,1); // going right adding 1 node\\n        }\\n        return max;\\n        \\n    }\\n    //BOOLEAN LEFT to know if arrived at this node by traversing left or right\\n    public void helper(TreeNode root,boolean left,int val){\\n        if(root.left==null && root.right==null){\\n            //LEAF NODE return val\\n            max=Math.max(val,max);\\n            return;\\n        }\\n      \\n        if(left){  \\n            //if arrived from left then right node should be included \\n            if(root.right!=null){\\n             helper(root.right,false,val+1);  //+1 node as right node is present\\n            }else{\\n                max=Math.max(val,max);    //if right node not present compare the val to max\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,1);   // starting as 1st node as it has already arrived from left so going left would be starting a new chain\\n\\n            }\\n        }else{\\n           \\n             if(root.right!=null){\\n                 helper(root.right,false,1);\\n            }\\n             //if arrived from right then left node should be included \\n            if(root.left!=null){\\n                helper(root.left,true,val+1); //+1 node as right node is present\\n\\n            }\\n            else{\\n                max=Math.max(val,max);    //if left node not present compare the val to max\\n            }\\n\\n        }\\n        \\n    }\\n}\\n```\\n**CODE WITHOUT COMMENTS**\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max=0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left!=null){\\n           helper(root.left,true,1);\\n        }\\n        if(root.right!=null){\\n            helper(root.right,false,1);\\n        }\\n        return max;\\n        \\n    }\\n    public void helper(TreeNode root,boolean left,int val){\\n        if(root.left==null && root.right==null){\\n            max=Math.max(val,max);\\n            return;\\n        }\\n        if(left){\\n            if(root.right!=null){\\n             helper(root.right,false,val+1);\\n            }else{\\n                max=Math.max(val,max);\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,1);\\n            }\\n        }else{\\n             if(root.right!=null){\\n                 helper(root.right,false,1);\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,val+1);\\n            }\\n            else{\\n                max=Math.max(val,max);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max=0; // to store max\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left!=null){\\n           helper(root.left,true,1);    // going left adding 1 node\\n        }\\n        if(root.right!=null){\\n            helper(root.right,false,1); // going right adding 1 node\\n        }\\n        return max;\\n        \\n    }\\n    //BOOLEAN LEFT to know if arrived at this node by traversing left or right\\n    public void helper(TreeNode root,boolean left,int val){\\n        if(root.left==null && root.right==null){\\n            //LEAF NODE return val\\n            max=Math.max(val,max);\\n            return;\\n        }\\n      \\n        if(left){  \\n            //if arrived from left then right node should be included \\n            if(root.right!=null){\\n             helper(root.right,false,val+1);  //+1 node as right node is present\\n            }else{\\n                max=Math.max(val,max);    //if right node not present compare the val to max\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,1);   // starting as 1st node as it has already arrived from left so going left would be starting a new chain\\n\\n            }\\n        }else{\\n           \\n             if(root.right!=null){\\n                 helper(root.right,false,1);\\n            }\\n             //if arrived from right then left node should be included \\n            if(root.left!=null){\\n                helper(root.left,true,val+1); //+1 node as right node is present\\n\\n            }\\n            else{\\n                max=Math.max(val,max);    //if left node not present compare the val to max\\n            }\\n\\n        }\\n        \\n    }\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max=0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left!=null){\\n           helper(root.left,true,1);\\n        }\\n        if(root.right!=null){\\n            helper(root.right,false,1);\\n        }\\n        return max;\\n        \\n    }\\n    public void helper(TreeNode root,boolean left,int val){\\n        if(root.left==null && root.right==null){\\n            max=Math.max(val,max);\\n            return;\\n        }\\n        if(left){\\n            if(root.right!=null){\\n             helper(root.right,false,val+1);\\n            }else{\\n                max=Math.max(val,max);\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,1);\\n            }\\n        }else{\\n             if(root.right!=null){\\n                 helper(root.right,false,1);\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,val+1);\\n            }\\n            else{\\n                max=Math.max(val,max);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434458,
                "title": "optimised-solution-with-easy-and-complete-explanation",
                "content": "# Intuition\\nTo solve this problem, we can perform a depth-first search (DFS) on the binary tree, keeping track of the length of the longest ZigZag path seen so far. For each node, we need to check both the left and right subtrees to see if there are any ZigZag paths that pass through the node.\\n\\n# Approach\\nTo do this, we can define a helper function dfs that takes in a node and a boolean flag indicating whether we are currently traversing the left or right subtree. If we are traversing the left subtree, we update the length of the longest ZigZag path seen so far by adding the length of the longest ZigZag path in the right subtree of the current node plus 1 (for the current node). Similarly, if we are traversing the right subtree, we update the length of the longest ZigZag path seen so far by adding the length of the longest ZigZag path in the left subtree of the current node plus 1.\\n\\nWe can then call this helper function on the root node, passing in a flag indicating that we are not currently traversing any subtree (i.e., the root node is not part of any ZigZag path). Finally, we return the length of the longest ZigZag path seen so far.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int max_length = 0;\\n        dfs(root, false, 0, max_length); // Start with root node, not traversing any subtree\\n        dfs(root, true, 0, max_length); // Start with root node, traversing right subtree\\n        return max_length;\\n    }\\n    \\n    void dfs(TreeNode* node, bool is_right, int length, int& max_length) {\\n        if (!node) return;\\n        max_length = max(max_length, length); // Update max_length with current ZigZag path length\\n        \\n        if (is_right) { // Traversing right subtree\\n            dfs(node->right, false, length + 1, max_length); // Check left subtree\\n            dfs(node->left, true, 1, max_length); // Check right subtree\\n        } else { // Traversing left subtree\\n            dfs(node->left, true, length + 1, max_length); // Check right subtree\\n            dfs(node->right, false, 1, max_length); // Check left subtree\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int max_length = 0;\\n        dfs(root, false, 0, max_length); // Start with root node, not traversing any subtree\\n        dfs(root, true, 0, max_length); // Start with root node, traversing right subtree\\n        return max_length;\\n    }\\n    \\n    void dfs(TreeNode* node, bool is_right, int length, int& max_length) {\\n        if (!node) return;\\n        max_length = max(max_length, length); // Update max_length with current ZigZag path length\\n        \\n        if (is_right) { // Traversing right subtree\\n            dfs(node->right, false, length + 1, max_length); // Check left subtree\\n            dfs(node->left, true, 1, max_length); // Check right subtree\\n        } else { // Traversing left subtree\\n            dfs(node->left, true, length + 1, max_length); // Check right subtree\\n            dfs(node->right, false, 1, max_length); // Check left subtree\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434428,
                "title": "go-clean-recursive-solution",
                "content": "```\\nfunc longestZigZag(root *TreeNode) int {\\n    res := 0\\n    \\n    var walk func(*TreeNode, int, int)\\n    walk = func(root* TreeNode, l, r int) {\\n        if root != nil {\\n            res = max(res, l, r)\\n            walk(root.Left, r + 1, 0)\\n            walk(root.Right, 0, l + 1)\\n        }\\n    }\\n    \\n    walk(root, 0, 0)\\n    return res\\n}\\n\\nfunc max(a ...int) int {\\n    res := a[0]\\n    for _, v := range a {\\n        if v > res {\\n            res = v\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestZigZag(root *TreeNode) int {\\n    res := 0\\n    \\n    var walk func(*TreeNode, int, int)\\n    walk = func(root* TreeNode, l, r int) {\\n        if root != nil {\\n            res = max(res, l, r)\\n            walk(root.Left, r + 1, 0)\\n            walk(root.Right, 0, l + 1)\\n        }\\n    }\\n    \\n    walk(root, 0, 0)\\n    return res\\n}\\n\\nfunc max(a ...int) int {\\n    res := a[0]\\n    for _, v := range a {\\n        if v > res {\\n            res = v\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3434362,
                "title": "javascript-simple-recursive-solution",
                "content": "# Approach\\nRecursively: \\n- if root is null, return -1 to compensate the +1 from previous call to result to 0\\n- if root is left child, recursively check its right subtree and add root edge to it. Then recursively check its left subtree and assign max of these values to ans. We always want to return the right subtree max here, so we can continue to add up to that path.\\n- if root is right child, do the same, but mirrored (instead of right subtree we\\'ll return right one)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nconst LEFT = 0\\nconst RIGHT = 1\\nlet ans = 0\\n\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nconst longestZigZag = root => {\\n    ans = 0\\n    const left = 1 + recLongestZigZag(root.left, LEFT)\\n    const right = 1 + recLongestZigZag(root.right, RIGHT)\\n    ans = Math.max(\\n        left,\\n        right,\\n        ans,\\n    )\\n    return ans\\n}\\n\\nconst recLongestZigZag = (root, dir) => {\\n    if (root === null) return -1\\n    const left = 1 + recLongestZigZag(root.left, LEFT)\\n    const right = 1 + recLongestZigZag(root.right, RIGHT)\\n    ans = Math.max(ans, left, right)\\n    return dir === LEFT ? right : left\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nconst LEFT = 0\\nconst RIGHT = 1\\nlet ans = 0\\n\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nconst longestZigZag = root => {\\n    ans = 0\\n    const left = 1 + recLongestZigZag(root.left, LEFT)\\n    const right = 1 + recLongestZigZag(root.right, RIGHT)\\n    ans = Math.max(\\n        left,\\n        right,\\n        ans,\\n    )\\n    return ans\\n}\\n\\nconst recLongestZigZag = (root, dir) => {\\n    if (root === null) return -1\\n    const left = 1 + recLongestZigZag(root.left, LEFT)\\n    const right = 1 + recLongestZigZag(root.right, RIGHT)\\n    ans = Math.max(ans, left, right)\\n    return dir === LEFT ? right : left\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3434187,
                "title": "tree-depth-first-search",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(h)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar longestZigZag = function(root) {\\n    var maxZigZag = 0;\\n    function dfs(root, zig, zigzag) {\\n        if(root == null)\\n            return;\\n        maxZigZag = Math.max(maxZigZag, zigzag);\\n        dfs(root.left, -1, 1 + ((zig == 1) ? zigzag : 0));\\n        dfs(root.right, 1, 1 + ((zig == -1) ? zigzag : 0));\\n    };\\n    dfs(root, 0, 0);\\n    return maxZigZag;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nvar longestZigZag = function(root) {\\n    var maxZigZag = 0;\\n    function dfs(root, zig, zigzag) {\\n        if(root == null)\\n            return;\\n        maxZigZag = Math.max(maxZigZag, zigzag);\\n        dfs(root.left, -1, 1 + ((zig == 1) ? zigzag : 0));\\n        dfs(root.right, 1, 1 + ((zig == -1) ? zigzag : 0));\\n    };\\n    dfs(root, 0, 0);\\n    return maxZigZag;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3434039,
                "title": "java-dfs-explained",
                "content": "# Solution:\\n```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        // we are currently standing on the root node\\n        dfs(root.left, 1, false);   // call for left\\n        dfs(root.right, 1, true);   // call for right\\n        // Why 1? Because from root to root\\'s left or right \\n        // is a distance of 1 unit\\n        return max;\\n    }\\n\\n    // the parameter boolean goRight will let us know \\n    // if we took the right direction or the left direction\\n    private void dfs(TreeNode root, int depth, boolean goRight) {\\n        if (root == null) {\\n            return;\\n        }\\n        // update max distance\\n        max = Math.max(max, depth); \\n        // if we had took right direction\\n        if (goRight) {\\n            // we have 2 options:\\n            // Go left: That\\'d be a zigzag order so distance + 1\\n            dfs(root.left, depth + 1, false);\\n            // Go right: Zigzag order is broken so distance resets to 1\\n            dfs(root.right, 1, true);\\n        } \\n        // Else if we had took a left direction\\n        else {\\n            // we have 2 options:\\n            // Go left: Zigzag order is broken so distance resets to 1\\n            dfs(root.left, 1, false);\\n            // Go right: That\\'d be a zigzag order so distance + 1\\n            dfs(root.right, depth + 1, true);\\n        }\\n        // In each call we set goRight true or false accordingly \\n        // if we are moving to left or right\\n\\n        // Also, why are we resetting the distance to 1 and not 0?\\n        // Because, from current node to next node where we are \\n        // stepping on, the distance is 1, so we set it to 1.\\n    }\\n}\\n```\\n---\\n\\nIn the above solution, we stood at the root and called our recursive method on left and right in the `longestZigZag()` method.\\n\\nWe can also call the recursive method only once in `longestZigZag()` by calling it on the root node itself, setting `goRight` parameter to anything, because we are just stepping our foot on it, it doesn\\'t matter if we came from left or right. The distance would be `0` at root because we can\\'t count our steps if we came from emptiness. We start counting after we start stepping afterwards from root node.  Everything will just be the same from there.\\n```\\ndfs(root, 0, false);\\n```\\n---\\n## Clean solution:\\n```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, 0, false); \\n        return max;\\n    }\\n\\n    private void dfs(TreeNode root, int depth, boolean goRight) {\\n        if (root == null) \\n            return;\\n        }\\n        max = Math.max(max, depth); \\n        if (goRight) {\\n            dfs(root.left, depth + 1, false);\\n            dfs(root.right, 1, true);\\n        } else {dfs(root.left, 1, false);\\n            dfs(root.right, depth + 1, true);\\n        }\\n    }\\n}\\n```\\n---\\n### Time complexity: $$O(n)$$\\n### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        // we are currently standing on the root node\\n        dfs(root.left, 1, false);   // call for left\\n        dfs(root.right, 1, true);   // call for right\\n        // Why 1? Because from root to root\\'s left or right \\n        // is a distance of 1 unit\\n        return max;\\n    }\\n\\n    // the parameter boolean goRight will let us know \\n    // if we took the right direction or the left direction\\n    private void dfs(TreeNode root, int depth, boolean goRight) {\\n        if (root == null) {\\n            return;\\n        }\\n        // update max distance\\n        max = Math.max(max, depth); \\n        // if we had took right direction\\n        if (goRight) {\\n            // we have 2 options:\\n            // Go left: That\\'d be a zigzag order so distance + 1\\n            dfs(root.left, depth + 1, false);\\n            // Go right: Zigzag order is broken so distance resets to 1\\n            dfs(root.right, 1, true);\\n        } \\n        // Else if we had took a left direction\\n        else {\\n            // we have 2 options:\\n            // Go left: Zigzag order is broken so distance resets to 1\\n            dfs(root.left, 1, false);\\n            // Go right: That\\'d be a zigzag order so distance + 1\\n            dfs(root.right, depth + 1, true);\\n        }\\n        // In each call we set goRight true or false accordingly \\n        // if we are moving to left or right\\n\\n        // Also, why are we resetting the distance to 1 and not 0?\\n        // Because, from current node to next node where we are \\n        // stepping on, the distance is 1, so we set it to 1.\\n    }\\n}\\n```\n```\\ndfs(root, 0, false);\\n```\n```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, 0, false); \\n        return max;\\n    }\\n\\n    private void dfs(TreeNode root, int depth, boolean goRight) {\\n        if (root == null) \\n            return;\\n        }\\n        max = Math.max(max, depth); \\n        if (goRight) {\\n            dfs(root.left, depth + 1, false);\\n            dfs(root.right, 1, true);\\n        } else {dfs(root.left, 1, false);\\n            dfs(root.right, depth + 1, true);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433906,
                "title": "java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        harsh(root,1,1,0);\\n        return ans;\\n    }\\n    int ans=0;\\n    public void harsh(TreeNode root,int l,int r,int s){\\n        ans=Math.max(ans,s);\\n        if(root.left!=null) harsh(root.left,0,1,s*l+1);\\n        if(root.right!=null) harsh(root.right,1,0,s*r+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        harsh(root,1,1,0);\\n        return ans;\\n    }\\n    int ans=0;\\n    public void harsh(TreeNode root,int l,int r,int s){\\n        ans=Math.max(ans,s);\\n        if(root.left!=null) harsh(root.left,0,1,s*l+1);\\n        if(root.right!=null) harsh(root.right,1,0,s*r+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433704,
                "title": "c-recursive-code-to-optimised-code",
                "content": "**Recursive Code**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    //int cnt=0;\\n    int maxi=1;\\n    void f(TreeNode* root,string dir,int cnt)\\n    {\\n        if(root==NULL)\\n        {\\n            maxi=max(maxi,cnt);\\n            return;\\n        }\\n        if(dir==\"right\")\\n            f(root->right,\"left\",cnt+1);\\n        else\\n            f(root->left,\"right\",cnt+1);\\n    }\\n    void f1(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n            f(root,\"left\",0);\\n            f(root,\"right\",0);\\n        f1(root->left);\\n        f1(root->right);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        f1(root);\\n        return maxi-1;\\n    }\\n};\\n```\\n**Optimised Code**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    void f(TreeNode* root,string dir,int cnt)\\n    {\\n        if(root==NULL)\\n            return;\\n        maxi=max(maxi,cnt);\\n        if(dir==\"left\")\\n        {\\n           f(root->right,\"right\",cnt+1);\\n           f(root->left,\"left\",1);\\n        }\\n        else\\n        {\\n            f(root->left,\"left\",cnt+1);\\n            f(root->right,\"right\",1);\\n        }\\n        \\n    }\\n    int longestZigZag(TreeNode* root) {\\n        f(root,\"left\",0);\\n        f(root,\"right\",0);\\n        return (maxi==INT_MIN)?0:maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    //int cnt=0;\\n    int maxi=1;\\n    void f(TreeNode* root,string dir,int cnt)\\n    {\\n        if(root==NULL)\\n        {\\n            maxi=max(maxi,cnt);\\n            return;\\n        }\\n        if(dir==\"right\")\\n            f(root->right,\"left\",cnt+1);\\n        else\\n            f(root->left,\"right\",cnt+1);\\n    }\\n    void f1(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n            f(root,\"left\",0);\\n            f(root,\"right\",0);\\n        f1(root->left);\\n        f1(root->right);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        f1(root);\\n        return maxi-1;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    void f(TreeNode* root,string dir,int cnt)\\n    {\\n        if(root==NULL)\\n            return;\\n        maxi=max(maxi,cnt);\\n        if(dir==\"left\")\\n        {\\n           f(root->right,\"right\",cnt+1);\\n           f(root->left,\"left\",1);\\n        }\\n        else\\n        {\\n            f(root->left,\"left\",cnt+1);\\n            f(root->right,\"right\",1);\\n        }\\n        \\n    }\\n    int longestZigZag(TreeNode* root) {\\n        f(root,\"left\",0);\\n        f(root,\"right\",0);\\n        return (maxi==INT_MIN)?0:maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433462,
                "title": "python-short-and-clean-dfs-functional-programming",
                "content": "# Approach\\n1. Define `longest_zig_zag` which takes a `node` and returns:\\n    - longest zigzig beginning from `node` and taking `left` edge.\\n    - longest zigzag beginning from `node` and taking `right` edge.\\n    - longest zigzag beginning anywhere in the subtree of `node`. (This is the desired answer)\\n\\n2. Recursively, call `longest_zig_zag` on `left` and `right` subtrees.\\n\\n3. Now, compute the result values for `node` based on the results of subtrees as shown in the code below.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode | None) -> int:\\n        def longest_zig_zag(node: TreeNode | None) -> tuple[int, int, int]:\\n            if node is None: return -1, -1, -1\\n\\n            _, lt_node_max, lt_tree_max = longest_zig_zag(node.left)\\n            rt_node_max, _, rt_tree_max = longest_zig_zag(node.right)\\n\\n            lt, rt = lt_node_max + 1, rt_node_max + 1\\n            return lt, rt, max(lt_tree_max, rt_tree_max, lt, rt)\\n        \\n        return longest_zig_zag(root)[-1]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode | None) -> int:\\n        def longest_zig_zag(node: TreeNode | None) -> tuple[int, int, int]:\\n            if node is None: return -1, -1, -1\\n\\n            _, lt_node_max, lt_tree_max = longest_zig_zag(node.left)\\n            rt_node_max, _, rt_tree_max = longest_zig_zag(node.right)\\n\\n            lt, rt = lt_node_max + 1, rt_node_max + 1\\n            return lt, rt, max(lt_tree_max, rt_tree_max, lt, rt)\\n        \\n        return longest_zig_zag(root)[-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433449,
                "title": "python-simple-python-solution-using-dfs-recursion",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 377 ms, faster than 83.88% of Python3 online submissions for Longest ZigZag Path in a Binary Tree.\\n# Memory Usage: 60.9 MB, less than 69.60% of Python3 online submissions for Longest ZigZag Path in a Binary Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n\\t\\t\\tself.result = 0\\n\\n\\t\\t\\tdef DFS(node, current_max_path, direction):\\n\\n\\t\\t\\t\\tif node != None:\\n\\n\\t\\t\\t\\t\\tself.result = max(self.result, current_max_path)\\n\\n\\t\\t\\t\\t\\tif direction:\\n\\t\\t\\t\\t\\t\\tDFS(node.right , current_max_path + 1 , False)\\n\\t\\t\\t\\t\\t\\tDFS(node.left , 1 , True)\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tDFS(node.left , current_max_path + 1 , True)\\n\\t\\t\\t\\t\\t\\tDFS(node.right , 1 , False)\\n\\n\\t\\t\\tif root.left:\\n\\t\\t\\t\\tDFS(root.left , 1 , True)\\n\\n\\t\\t\\tif root.right:\\n\\t\\t\\t\\tDFS(root.right , 1 , False)\\n\\n\\t\\t\\treturn self.result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 377 ms, faster than 83.88% of Python3 online submissions for Longest ZigZag Path in a Binary Tree.\\n# Memory Usage: 60.9 MB, less than 69.60% of Python3 online submissions for Longest ZigZag Path in a Binary Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n\\t\\t\\tself.result = 0\\n\\n\\t\\t\\tdef DFS(node, current_max_path, direction):\\n\\n\\t\\t\\t\\tif node != None:\\n\\n\\t\\t\\t\\t\\tself.result = max(self.result, current_max_path)\\n\\n\\t\\t\\t\\t\\tif direction:\\n\\t\\t\\t\\t\\t\\tDFS(node.right , current_max_path + 1 , False)\\n\\t\\t\\t\\t\\t\\tDFS(node.left , 1 , True)\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tDFS(node.left , current_max_path + 1 , True)\\n\\t\\t\\t\\t\\t\\tDFS(node.right , 1 , False)\\n\\n\\t\\t\\tif root.left:\\n\\t\\t\\t\\tDFS(root.left , 1 , True)\\n\\n\\t\\t\\tif root.right:\\n\\t\\t\\t\\tDFS(root.right , 1 , False)\\n\\n\\t\\t\\treturn self.result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3433343,
                "title": "iterative-dfs-solution-in-rust",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn longest_zig_zag(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut max_len = 0;\\n        let mut stack = vec![(root, true, 0)];\\n        while let Some((node, is_left, len)) = stack.pop() {\\n            if let Some(node) = node {\\n                max_len = max_len.max(len);\\n                let &TreeNode { ref left, ref right, .. } = &*node.borrow();\\n                stack.push((left.as_ref().map(Rc::clone), true, if is_left { 1 } else { len + 1 }));\\n                stack.push((right.as_ref().map(Rc::clone), false, if is_left { len + 1 } else { 1 }));\\n            }\\n        }\\n        max_len\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn longest_zig_zag(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut max_len = 0;\\n        let mut stack = vec![(root, true, 0)];\\n        while let Some((node, is_left, len)) = stack.pop() {\\n            if let Some(node) = node {\\n                max_len = max_len.max(len);\\n                let &TreeNode { ref left, ref right, .. } = &*node.borrow();\\n                stack.push((left.as_ref().map(Rc::clone), true, if is_left { 1 } else { len + 1 }));\\n                stack.push((right.as_ref().map(Rc::clone), false, if is_left { len + 1 } else { 1 }));\\n            }\\n        }\\n        max_len\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433226,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* node, int dir, int len) {\\n        if (node == NULL) return len;\\n        int left = dfs(node->left, 1, (dir == 0 ? len + 1 : 0));\\n        int right = dfs(node->right, 0, (dir == 1 ? len + 1 : 0));\\n        return max(left, right);\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        int left = dfs(root->left, 1, 0);\\n        int right = dfs(root->right, 0, 0);\\n        return max(left, right);\\n    }\\n};\\n\\n```\\nOther solution modified from the javascript code of comments\\n```\\nclass Solution {\\npublic:\\n    int getLength(TreeNode* root, bool flag, int& res) {\\n    if (root == nullptr) {\\n        return 0;\\n    }\\n    \\n    int left_path = getLength(root->left, true, res);\\n    int right_path = getLength(root->right, false, res);\\n    res = max(res, max(left_path, right_path));\\n    \\n    if (flag) {\\n        return 1 + right_path;\\n    } else {\\n        return 1 + left_path;\\n    }\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n    int res = 0;\\n    getLength(root, true, res);\\n    getLength(root, false, res);\\n    return res;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* node, int dir, int len) {\\n        if (node == NULL) return len;\\n        int left = dfs(node->left, 1, (dir == 0 ? len + 1 : 0));\\n        int right = dfs(node->right, 0, (dir == 1 ? len + 1 : 0));\\n        return max(left, right);\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        int left = dfs(root->left, 1, 0);\\n        int right = dfs(root->right, 0, 0);\\n        return max(left, right);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int getLength(TreeNode* root, bool flag, int& res) {\\n    if (root == nullptr) {\\n        return 0;\\n    }\\n    \\n    int left_path = getLength(root->left, true, res);\\n    int right_path = getLength(root->right, false, res);\\n    res = max(res, max(left_path, right_path));\\n    \\n    if (flag) {\\n        return 1 + right_path;\\n    } else {\\n        return 1 + left_path;\\n    }\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n    int res = 0;\\n    getLength(root, true, res);\\n    getLength(root, false, res);\\n    return res;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433044,
                "title": "python-readable-dfs-recursion",
                "content": "\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def longestZigZag(self, root):\\n        def dfsLeft(node, count):\\n            if not node:\\n                return count\\n            left, right = dfsLeft(node.left, 0), dfsRight(node.right, count + 1)\\n            return max(left, right)\\n            \\n        def dfsRight(node, count):\\n            if not node:\\n                return count\\n            left, right = dfsLeft(node.left, count + 1), dfsRight(node.right, 0)\\n            return max(left, right)\\n\\n        return max(dfsLeft(root.left, 0), dfsRight(root.right, 0))\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def longestZigZag(self, root):\\n        def dfsLeft(node, count):\\n            if not node:\\n                return count\\n            left, right = dfsLeft(node.left, 0), dfsRight(node.right, count + 1)\\n            return max(left, right)\\n            \\n        def dfsRight(node, count):\\n            if not node:\\n                return count\\n            left, right = dfsLeft(node.left, count + 1), dfsRight(node.right, 0)\\n            return max(left, right)\\n\\n        return max(dfsLeft(root.left, 0), dfsRight(root.right, 0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432953,
                "title": "daily-leetcoding-challenge-april-day-19",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3310421,
                "title": "c-java-simple-dfs-solution",
                "content": "1. If the current node is a left child, \\n    - `dfs(node->right,currLen+1)` to continue the ZigZag path\\n    - `dfs(node->left,1)`- Start a new ZigZag path from current node (left direction)\\n2. If the current node is a right child,\\n    - `dfs(node->left,currLen+1)` to continue the ZigZag path\\n    - `dfs(node->right,1)` - Start a new ZigZag path from current node (right direction)\\n\\nSo we can do a DFS traversal from root in both directions and at each node update the maximum length of the path (edges in the path).\\n\\n```C++ []\\nclass Solution {\\n    public:\\n    int maxLength = 0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength = max(maxLength, currLength);\\n        // At each node, two choices\\n        // Continue the previous path in the alternate direction\\n        // Start a new path in the same direction\\n        solve(root->left, 0, (dir)? currLength+1 : 1);\\n        solve(root->right, 1, (dir)? 1 : currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root, 0, 0);\\n        solve(root, 1, 0);\\n        return maxLength;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxLength=0;\\n    public void solve(TreeNode root,int dir,int currLength){\\n        if(root==null) return;\\n        maxLength=Math.max(maxLength,currLength);\\n        // At each node, two choices\\n        // Continue the previous path in the alternate direction\\n        // Start a new path in the same direction\\n        if(dir==1){\\n            solve(root.left,0,currLength+1);\\n            solve(root.right,1,1);\\n        }\\n        else{\\n            solve(root.right,1,currLength+1);\\n            solve(root.left,0,1);\\n        }\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```C++ []\\nclass Solution {\\n    public:\\n    int maxLength = 0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength = max(maxLength, currLength);\\n        // At each node, two choices\\n        // Continue the previous path in the alternate direction\\n        // Start a new path in the same direction\\n        solve(root->left, 0, (dir)? currLength+1 : 1);\\n        solve(root->right, 1, (dir)? 1 : currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root, 0, 0);\\n        solve(root, 1, 0);\\n        return maxLength;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxLength=0;\\n    public void solve(TreeNode root,int dir,int currLength){\\n        if(root==null) return;\\n        maxLength=Math.max(maxLength,currLength);\\n        // At each node, two choices\\n        // Continue the previous path in the alternate direction\\n        // Start a new path in the same direction\\n        if(dir==1){\\n            solve(root.left,0,currLength+1);\\n            solve(root.right,1,1);\\n        }\\n        else{\\n            solve(root.right,1,currLength+1);\\n            solve(root.left,0,1);\\n        }\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070087,
                "title": "pyhon-easy-soultion-to-understand-with-explanation-beast-90",
                "content": "# Approach\\nWe want to cut zigzag. lets say we are the left son, when we want to get the lenght of left path of our right child(The opposite if we are the right son ).\\nSo for each node we call the same function to our childs. the base case is a None node and we return 0. After that we check which son are we and increase result based on the path lenght from the child.\\n\\nright[0] means go to the right child and give me the length of the left path.\\nleft[1] means go to the left child and give me the length of the right path.\\n\\n# Complexity\\n- Time complexity:\\nO(n): we are doing kind of a dfs scan , which is known for being O(n)\\n\\n- Space complexity:\\nO(1): we are not using any extra memory.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n        result = 0\\n        def dfs(node,parent):\\n            nonlocal result \\n            if node is None:\\n                return (0,0)\\n            left = dfs(node.left,node)\\n            right = dfs(node.right,node)\\n            if parent.left==node\\n                result = max(result,right[0]+1)\\n            else:\\n                result = max(result,left[1]+1)\\n            return (left[1]+1,right[0]+1)\\n        dfs(root.left,root)\\n        dfs(root.right,root)\\n        return result\\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n        result = 0\\n        def dfs(node,parent):\\n            nonlocal result \\n            if node is None:\\n                return (0,0)\\n            left = dfs(node.left,node)\\n            right = dfs(node.right,node)\\n            if parent.left==node\\n                result = max(result,right[0]+1)\\n            else:\\n                result = max(result,left[1]+1)\\n            return (left[1]+1,right[0]+1)\\n        dfs(root.left,root)\\n        dfs(root.right,root)\\n        return result\\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688910,
                "title": "java-o-n-dp-solution-with-explanation-and-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition 1 - We will do post order traversal as we want to use the results of the children stored in a DP natured map data structure.\\n\\nIntuition 2 - We will use 2 persistent variables namely a dp map and a MAX variable. that signify the following:\\n1. ***DP map*** -> Will store an int array of size 2 consisting of the max zigzag length if you start from this root in both left and right direction. Index 0 holds the left scenario and 1 holds the right scenario.\\n2. ***MAX*** -> used to calculate max length seen so far.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter every postorder computation DP will hold <Key, Value> as <Current Node reference, Array[max distance from here if you go left, max distance from here if you go right]>\\n\\n# Complexity\\n- Time complexity: O(n) where n is the number of nodes as we go over every node just once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) as dp is the size of nodes as keys and values are constant of size 2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int MAX;\\n    Map<TreeNode, int []> dp;\\n    public int longestZigZag(TreeNode root) {\\n        \\n        //postorder traversal\\n        //Map stores left from node and right from node\\n        dp = new HashMap<>();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    //returns max length from here if you go in a particular direction\\n    private void dfs(TreeNode root){\\n        if(root == null) return;\\n\\n        if(root.left == null && root.right == null){\\n            dp.put(root, new int[]{0,0});\\n            return;\\n        }\\n        //In dp value int []\\n        //index 0 represents left direction\\n        //index 1 represents right direction\\n        dfs(root.left);\\n        dfs(root.right);\\n\\n        int left = 0, right = 0;\\n\\n        if(dp.get(root.left) != null)\\n            left = 1 + dp.get(root.left)[1]; //we go right after left\\n        \\n        if(dp.get(root.right) != null)\\n            right = 1 + dp.get(root.right)[0]; //we go left after right\\n        dp.put(root, new int[]{left, right});\\n        MAX = Math.max(MAX, Math.max(left,right));\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    int MAX;\\n    Map<TreeNode, int []> dp;\\n    public int longestZigZag(TreeNode root) {\\n        \\n        //postorder traversal\\n        //Map stores left from node and right from node\\n        dp = new HashMap<>();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    //returns max length from here if you go in a particular direction\\n    private void dfs(TreeNode root){\\n        if(root == null) return;\\n\\n        if(root.left == null && root.right == null){\\n            dp.put(root, new int[]{0,0});\\n            return;\\n        }\\n        //In dp value int []\\n        //index 0 represents left direction\\n        //index 1 represents right direction\\n        dfs(root.left);\\n        dfs(root.right);\\n\\n        int left = 0, right = 0;\\n\\n        if(dp.get(root.left) != null)\\n            left = 1 + dp.get(root.left)[1]; //we go right after left\\n        \\n        if(dp.get(root.right) != null)\\n            right = 1 + dp.get(root.right)[0]; //we go left after right\\n        dp.put(root, new int[]{left, right});\\n        MAX = Math.max(MAX, Math.max(left,right));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679946,
                "title": "c",
                "content": "Runtime: 125 ms, faster than 100.00% of C online submissions for Longest ZigZag Path in a Binary Tree.\\nMemory Usage: 53.5 MB, less than 28.57% of C online submissions for Longest ZigZag Path in a Binary Tree.\\n```\\ntypedef struct{\\n    int l;\\n    int r;\\n}Data;\\n\\nData process(struct TreeNode* root,int* max){\\n    Data ret;\\n    if(root == NULL){\\n        ret.l = -1;\\n        ret.r = -1;\\n        return ret;\\n    }\\n    Data dLTree = process(root->left, max);\\n    Data dRTree = process(root->right, max);\\n    \\n    ret.l = 1 + dRTree.r;\\n    ret.r = 1 + dLTree.l;\\n    *max  = fmax( fmax(ret.l, *max), ret.r);\\n    return ret;\\n}\\n\\nint longestZigZag(struct TreeNode* root){\\n    int max = 0;\\n    process(root, &max);\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\ntypedef struct{\\n    int l;\\n    int r;\\n}Data;\\n\\nData process(struct TreeNode* root,int* max){\\n    Data ret;\\n    if(root == NULL){\\n        ret.l = -1;\\n        ret.r = -1;\\n        return ret;\\n    }\\n    Data dLTree = process(root->left, max);\\n    Data dRTree = process(root->right, max);\\n    \\n    ret.l = 1 + dRTree.r;\\n    ret.r = 1 + dLTree.l;\\n    *max  = fmax( fmax(ret.l, *max), ret.r);\\n    return ret;\\n}\\n\\nint longestZigZag(struct TreeNode* root){\\n    int max = 0;\\n    process(root, &max);\\n    return max;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2609933,
                "title": "easy-js-beginner-solution",
                "content": "Theory:\\n\\n1. Longest zigzag path can either begin from \"left\" or \"right\" edge. Hence need to find max from these two.\\n2. When we are at root, we will start by saying that, we have taken hypothetical path \"l\" or \"r\" with length 0.\\n3. when we are at left node, we check whether the prev edge we took is \"r\". If yes increase the path length. else we need to start new journey from here because Left - > Left is not zigzag.\\n4. Similarly when we are at right node we check if the prev edge we took is \"l\". If yes, our zigzag path will increase by one. If not, then new journey will start from here because Right -> Right path is not zigzag. \\n\\n```\\nvar longestZigZag = function(root) {\\n    let max = 0;\\n    \\n    const helper = (node, prev, length) => {\\n    \\n        if(node === null)\\n            return null;\\n        \\n        max = Math.max(max, length);\\n        \\n        helper(node.left, \"l\" , prev === \"r\" ? length + 1 : 1);\\n        helper(node.right, \"r\" , prev === \"l\" ? length + 1 : 1);\\n    }\\n    \\n    \\n    helper(root, \"l\", 0); \\n    helper(root, \"r\", 0);\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar longestZigZag = function(root) {\\n    let max = 0;\\n    \\n    const helper = (node, prev, length) => {\\n    \\n        if(node === null)\\n            return null;\\n        \\n        max = Math.max(max, length);\\n        \\n        helper(node.left, \"l\" , prev === \"r\" ? length + 1 : 1);\\n        helper(node.right, \"r\" , prev === \"l\" ? length + 1 : 1);\\n    }\\n    \\n    \\n    helper(root, \"l\", 0); \\n    helper(root, \"r\", 0);\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2559539,
                "title": "python3-iterative-dfs-using-stack-99-time-91-space-o-n-time-o-n-space",
                "content": "Initialize stack with root.left and root.right because the direction when entering the root node is undefined. If you do double left or double right, restart the count.\\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        \\n        LEFT = 0\\n        RIGHT = 1\\n            \\n        stack = []\\n        if root.left:\\n            stack.append((root.left, LEFT, 1))\\n        if root.right:\\n            stack.append((root.right, RIGHT, 1))\\n            \\n        longest = 0\\n        while stack:\\n            node, direction, count = stack.pop()\\n            \\n            longest = max(longest, count)\\n            if direction == LEFT:\\n                if node.left:\\n                    stack.append((node.left, LEFT, 1))\\n                if node.right:\\n                    stack.append((node.right, RIGHT, count+1))\\n            else:\\n                if node.right:\\n                    stack.append((node.right, RIGHT, 1))\\n                if node.left:\\n                    stack.append((node.left, LEFT, count+1))\\n        return longest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        \\n        LEFT = 0\\n        RIGHT = 1\\n            \\n        stack = []\\n        if root.left:\\n            stack.append((root.left, LEFT, 1))\\n        if root.right:\\n            stack.append((root.right, RIGHT, 1))\\n            \\n        longest = 0\\n        while stack:\\n            node, direction, count = stack.pop()\\n            \\n            longest = max(longest, count)\\n            if direction == LEFT:\\n                if node.left:\\n                    stack.append((node.left, LEFT, 1))\\n                if node.right:\\n                    stack.append((node.right, RIGHT, count+1))\\n            else:\\n                if node.right:\\n                    stack.append((node.right, RIGHT, 1))\\n                if node.left:\\n                    stack.append((node.left, LEFT, count+1))\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436026,
                "title": "o-n-recursion-5-line-c-code",
                "content": "```\\nint zigzag(TreeNode* root, int dir, int val){\\n        if(root==NULL) return val;\\n        return dir==-1? max(zigzag(root->right,1,val+1),zigzag(root->left,-1,0)) : max(zigzag(root->left,-1,val+1),zigzag(root->right,1,0));\\n    }   \\n    int longestZigZag(TreeNode* root) {\\n        return max(zigzag(root->left,-1,0),zigzag(root->right,1,0));\\n    }\\n```",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nint zigzag(TreeNode* root, int dir, int val){\\n        if(root==NULL) return val;\\n        return dir==-1? max(zigzag(root->right,1,val+1),zigzag(root->left,-1,0)) : max(zigzag(root->left,-1,val+1),zigzag(root->right,1,0));\\n    }   \\n    int longestZigZag(TreeNode* root) {\\n        return max(zigzag(root->left,-1,0),zigzag(root->right,1,0));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2126462,
                "title": "java-solution-with-comments-and-clean-code",
                "content": "```\\nclass Solution {\\n\\n    int ans = 0;    //global variable ans to store and compare longest path\\n    \\n    public int longestZigZag(TreeNode root) {\\n\\t\\n\\t\\t//to keep a record of previous traversal boolean flag is used \\n        pathFinder(root.left,true,0);       //from root to left and then to right so flag is true\\n        pathFinder(root.right,false,0);     //from root to right and then  to left so flag is false\\n        return ans;\\n    }\\n    \\n    public void pathFinder(TreeNode root, boolean flag, int sum){\\n\\t\\n\\t\\t//base condition\\n        if(root==null){\\n            ans = Math.max(ans,sum);\\n            return;\\n        }\\n        \\n\\t\\t//true means we have to go right.\\n        if(flag){\\n            pathFinder(root.right,false,sum+1);  //recursive call for root.right\\n            pathFinder(root.left,true,0);        //but there can be new ZigZag path from root.left\\n        }\\n        else{\\n\\t\\t\\t//we have to go left\\n            pathFinder(root.left,true,sum+1);  //recursive call for root.left\\n            pathFinder(root.right,false,0);    //but there can be new ZigZag path from root.left\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    int ans = 0;    //global variable ans to store and compare longest path\\n    \\n    public int longestZigZag(TreeNode root) {\\n\\t\\n\\t\\t//to keep a record of previous traversal boolean flag is used \\n        pathFinder(root.left,true,0);       //from root to left and then to right so flag is true\\n        pathFinder(root.right,false,0);     //from root to right and then  to left so flag is false\\n        return ans;\\n    }\\n    \\n    public void pathFinder(TreeNode root, boolean flag, int sum){\\n\\t\\n\\t\\t//base condition\\n        if(root==null){\\n            ans = Math.max(ans,sum);\\n            return;\\n        }\\n        \\n\\t\\t//true means we have to go right.\\n        if(flag){\\n            pathFinder(root.right,false,sum+1);  //recursive call for root.right\\n            pathFinder(root.left,true,0);        //but there can be new ZigZag path from root.left\\n        }\\n        else{\\n\\t\\t\\t//we have to go left\\n            pathFinder(root.left,true,sum+1);  //recursive call for root.left\\n            pathFinder(root.right,false,0);    //but there can be new ZigZag path from root.left\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806903,
                "title": "c-dfs-super-simple-o-n-and-o-1",
                "content": "We use 2 variables pleft and pright which contain the length of longest zigzag path ending at the current node given the current node is a left child or a right child of its parent respectively.\\nIf the current node has a right child, the length of zigzag path ending with this right child will be pleft+1. Similarly for the case when the current node has a left child.\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* root, int pleft, int pright){\\n        if(root==NULL) return ;\\n        if(root->right){\\n            ans = max(ans, pleft+1);\\n            fun(root->right, 0, pleft+1); //pright of the right child is the new lenght of zigzag path = pleft+1\\n        }\\n        if(root->left){\\n            ans = max(ans, pright+1);\\n            fun(root->left, pright+1, 0);\\n            \\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* root, int pleft, int pright){\\n        if(root==NULL) return ;\\n        if(root->right){\\n            ans = max(ans, pleft+1);\\n            fun(root->right, 0, pleft+1); //pright of the right child is the new lenght of zigzag path = pleft+1\\n        }\\n        if(root->left){\\n            ans = max(ans, pright+1);\\n            fun(root->left, pright+1, 0);\\n            \\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791746,
                "title": "java-dfs-clean-easy-to-understand-with-explanation-solution-o-n",
                "content": "```\\nprivate enum Direction {\\n\\tRIGHT, LEFT;\\n}\\n\\npublic int longestZigZag(TreeNode root) {\\n\\treturn dfs(root, 0, null); // Start from the root no directions yet\\n}\\n\\nprivate int dfs(TreeNode node, int sum, Direction dir) {\\n\\tif (node == null) return sum - 1; // If the cur node is null just remove the plus 1 from sum\\n\\t// When going to a node if we are coming from the same direction than we would need to reset the sum to 1\\n\\tint left = dfs(node.left, dir == Direction.LEFT ? 1 : sum + 1, Direction.LEFT);\\n\\tint right = dfs(node.right, dir == Direction.RIGHT ? 1 : sum + 1, Direction.RIGHT);\\n\\n\\treturn Math.max(left, right); // Return the maximum of the left and the right\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nprivate enum Direction {\\n\\tRIGHT, LEFT;\\n}\\n\\npublic int longestZigZag(TreeNode root) {\\n\\treturn dfs(root, 0, null); // Start from the root no directions yet\\n}\\n\\nprivate int dfs(TreeNode node, int sum, Direction dir) {\\n\\tif (node == null) return sum - 1; // If the cur node is null just remove the plus 1 from sum\\n\\t// When going to a node if we are coming from the same direction than we would need to reset the sum to 1\\n\\tint left = dfs(node.left, dir == Direction.LEFT ? 1 : sum + 1, Direction.LEFT);\\n\\tint right = dfs(node.right, dir == Direction.RIGHT ? 1 : sum + 1, Direction.RIGHT);\\n\\n\\treturn Math.max(left, right); // Return the maximum of the left and the right\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766450,
                "title": "java-simple-approach-explained-with-comments",
                "content": "```\\nclass Solution {\\n   int max = 0;\\n\\n\\tpublic int longestZigZag(TreeNode root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n        // start with depth (indicates count of nodes in zigzag path sofar) zero in both directions\\n\\t\\tpath(root.left, 0, false);\\n\\t\\tpath(root.right, 0, true);\\n        // return max zigzag path found\\n\\t\\treturn max;\\n\\t}\\n\\n\\t//using boolean value direction: false-left true-right\\n\\tpublic void path(TreeNode node, int depth, boolean direction) {\\n        // capture max depth of zigzag path captured sofar in global variable max\\n\\t\\tmax = Math.max(max, depth);\\n\\t\\tif (node == null)\\n\\t\\t\\treturn;\\n        // if previous direction is right(i.e direction is true) and we r heading towards left increment depth+1 as it counts towards valid zigzag path\\n\\t\\totherwise its important that we need to reset because current zigzag path breaks here and we need to start again to see if there is any other zigzag path from this node.\\n\\t\\tpath(node.left, direction ? depth + 1 : 0, false);\\n        // likewise if previous zigzag path is left(i.e direction is false) and we r heading towards right increment depth+1 is it counts towards valid zigzag path \\n\\t\\totherwise reset current count sofar and start again from here\\n\\t\\tpath(node.right, !direction ? depth + 1 : 0, true);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   int max = 0;\\n\\n\\tpublic int longestZigZag(TreeNode root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n        // start with depth (indicates count of nodes in zigzag path sofar) zero in both directions\\n\\t\\tpath(root.left, 0, false);\\n\\t\\tpath(root.right, 0, true);\\n        // return max zigzag path found\\n\\t\\treturn max;\\n\\t}\\n\\n\\t//using boolean value direction: false-left true-right\\n\\tpublic void path(TreeNode node, int depth, boolean direction) {\\n        // capture max depth of zigzag path captured sofar in global variable max\\n\\t\\tmax = Math.max(max, depth);\\n\\t\\tif (node == null)\\n\\t\\t\\treturn;\\n        // if previous direction is right(i.e direction is true) and we r heading towards left increment depth+1 as it counts towards valid zigzag path\\n\\t\\totherwise its important that we need to reset because current zigzag path breaks here and we need to start again to see if there is any other zigzag path from this node.\\n\\t\\tpath(node.left, direction ? depth + 1 : 0, false);\\n        // likewise if previous zigzag path is left(i.e direction is false) and we r heading towards right increment depth+1 is it counts towards valid zigzag path \\n\\t\\totherwise reset current count sofar and start again from here\\n\\t\\tpath(node.right, !direction ? depth + 1 : 0, true);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713560,
                "title": "c-simple-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    int dfs(TreeNode* node, bool isLeftChild = true){\\n        if (node == nullptr) return -1;\\n        \\n        int left = dfs(node -> left, true) + 1;\\n        int right = dfs(node -> right, false) + 1;\\n        \\n        ans = max(ans, max(left, right));\\n        return (isLeftChild) ? right : left;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        dfs(root); //root has no father, therefore it could be either true or false\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    int dfs(TreeNode* node, bool isLeftChild = true){\\n        if (node == nullptr) return -1;\\n        \\n        int left = dfs(node -> left, true) + 1;\\n        int right = dfs(node -> right, false) + 1;\\n        \\n        ans = max(ans, max(left, right));\\n        return (isLeftChild) ? right : left;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        dfs(root); //root has no father, therefore it could be either true or false\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637424,
                "title": "c",
                "content": "```\\n    //0->left\\n    //1->right\\n    int a = 0;\\n    int b = 0;\\n    map<pair<TreeNode*,bool>,int> mp;\\n    int solve(TreeNode* root, bool flag){\\n        if (root==NULL){\\n            return -1;\\n        }\\n        \\n        if (mp.find({root,flag})!=mp.end()){\\n            return mp[{root,flag}];\\n        }\\n        if (flag==0){\\n            return mp[{root,flag}]=1+solve(root->right,1);\\n        }\\n        else{\\n            return mp[{root,flag}]=1+solve(root->left,0);\\n        }\\n    }\\n    void dfs(TreeNode* root){\\n        if (root==NULL){\\n            return;\\n        }\\n        a  = max(a,solve(root,0));\\n        b = max(b,solve(root,1));\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root);\\n       \\n        return max(a,b);\\n    }\\n};",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\n    //0->left\\n    //1->right\\n    int a = 0;\\n    int b = 0;\\n    map<pair<TreeNode*,bool>,int> mp;\\n    int solve(TreeNode* root, bool flag){\\n        if (root==NULL){\\n            return -1;\\n        }\\n        \\n        if (mp.find({root,flag})!=mp.end()){\\n            return mp[{root,flag}];\\n        }\\n        if (flag==0){\\n            return mp[{root,flag}]=1+solve(root->right,1);\\n        }\\n        else{\\n            return mp[{root,flag}]=1+solve(root->left,0);\\n        }\\n    }\\n    void dfs(TreeNode* root){\\n        if (root==NULL){\\n            return;\\n        }\\n        a  = max(a,solve(root,0));\\n        b = max(b,solve(root,1));\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root);\\n       \\n        return max(a,b);\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1495111,
                "title": "c-inorder-traversal",
                "content": "```\\n \\nclass Solution {\\npublic:\\n    int ans;\\n    \\n    void inorder(TreeNode* root,bool dir,int len){\\n        \\n        if(root==NULL) return ;\\n         \\n        ans=max(ans,len);\\n        if(dir==0){\\n            inorder(root->left,1,len+1);\\n            inorder(root->right,0,1);\\n        }\\n        else{\\n             inorder(root->right,0,len+1);\\n             inorder(root->left,1,1);\\n        }\\n         \\n        return ;\\n       } \\n    \\n    int longestZigZag(TreeNode* root) {\\n        ans=0;\\n         inorder(root->left,1, 1);\\n         inorder(root->right,0, 1);\\n        \\n        return ans ;\\n    }\\n};\\n```\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int ans=0; \\n    \\n    pair<int,int>  dfs(TreeNode* root){\\n        \\n        if(!root)  return {-1,-1};\\n        \\n        auto [l1,l2]= dfs(root->left);\\n        auto [r1,r2]= dfs(root->right);\\n         \\n        ans=max({ans,l2+1,r1+1});\\n        \\n        return {l2+1,r1+1};  \\n        \\n    }\\n      \\n    int longestZigZag(TreeNode* root) {\\n        \\n        dfs(root); \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n \\nclass Solution {\\npublic:\\n    int ans;\\n    \\n    void inorder(TreeNode* root,bool dir,int len){\\n        \\n        if(root==NULL) return ;\\n         \\n        ans=max(ans,len);\\n        if(dir==0){\\n            inorder(root->left,1,len+1);\\n            inorder(root->right,0,1);\\n        }\\n        else{\\n             inorder(root->right,0,len+1);\\n             inorder(root->left,1,1);\\n        }\\n         \\n        return ;\\n       } \\n    \\n    int longestZigZag(TreeNode* root) {\\n        ans=0;\\n         inorder(root->left,1, 1);\\n         inorder(root->right,0, 1);\\n        \\n        return ans ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int ans=0; \\n    \\n    pair<int,int>  dfs(TreeNode* root){\\n        \\n        if(!root)  return {-1,-1};\\n        \\n        auto [l1,l2]= dfs(root->left);\\n        auto [r1,r2]= dfs(root->right);\\n         \\n        ans=max({ans,l2+1,r1+1});\\n        \\n        return {l2+1,r1+1};  \\n        \\n    }\\n      \\n    int longestZigZag(TreeNode* root) {\\n        \\n        dfs(root); \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447927,
                "title": "simple-recursion-in-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int max_val=0;\\n    int fun(TreeNode* temp,bool isLeft)\\n    {\\n        if(!temp) return 0;\\n        int l = fun(temp->left,0);\\n        int r = fun(temp->right,1);\\n        max_val = max({max_val,l,r});\\n        return 1+(isLeft?l:r);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        fun(root,0);\\n        return max_val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int max_val=0;\\n    int fun(TreeNode* temp,bool isLeft)\\n    {\\n        if(!temp) return 0;\\n        int l = fun(temp->left,0);\\n        int r = fun(temp->right,1);\\n        max_val = max({max_val,l,r});\\n        return 1+(isLeft?l:r);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        fun(root,0);\\n        return max_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344683,
                "title": "dp-dfs-java-thinking-in-terms-of-subproblems",
                "content": "This solution is not a clever solution, but it shows how to think in terms of subproblems and thinking about what choices do you have at each subproblem. Always start with the base case and your initial caller because they give clues as to what your choices are. \\n\\nThe way I thought about it was: `If I\\'m at the root, then what is the longest chain I can make? I don\\'t know, so I will check my left and right`. Then I saw in the example that the longest zigzag does not necessarily need to originate from the root. That means `the longest zigzag can originate from any node`. At every node, I can choose to extend my current chain, OR I can try to act as the root of the chain. I don\\'t know which is better, so I try both of them in the recursion. If I am extending, I add 1 to the length to the next call. If I am acting as the root of the chain, the chain length is now only 1 for the next caller.\\n```\\nclass Solution {\\n  private static final int LEFT = 0;\\n  private static final int RIGHT = 1;\\n  int max = 0;\\n  public int longestZigZag(TreeNode root) {\\n    Set<TreeNode> dp = new HashSet<>();\\n    traverse(root.left, LEFT, 1, dp);\\n    traverse(root.right, RIGHT, 1, dp);\\n    return max;\\n  }\\n  \\n  public void traverse(TreeNode root, int prevDir, int length, Set<TreeNode> dp) {\\n    if(root == null) return;\\n    if(dp.contains(root)) return;\\n    \\n    // extend\\n    if(prevDir == LEFT) {\\n      traverse(root.right, RIGHT, length+1, dp);\\n    } else {\\n      traverse(root.left, LEFT, length+1, dp); \\n    }\\n    \\n    // act as source\\n    traverse(root.left, LEFT, 1, dp);\\n    traverse(root.right, RIGHT, 1, dp);\\n    max = Math.max(max, length);\\n    dp.add(root);\\n  }\\n}\\n```\\n\\nUpvote if this helped you \\uD83D\\uDC4D",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  private static final int LEFT = 0;\\n  private static final int RIGHT = 1;\\n  int max = 0;\\n  public int longestZigZag(TreeNode root) {\\n    Set<TreeNode> dp = new HashSet<>();\\n    traverse(root.left, LEFT, 1, dp);\\n    traverse(root.right, RIGHT, 1, dp);\\n    return max;\\n  }\\n  \\n  public void traverse(TreeNode root, int prevDir, int length, Set<TreeNode> dp) {\\n    if(root == null) return;\\n    if(dp.contains(root)) return;\\n    \\n    // extend\\n    if(prevDir == LEFT) {\\n      traverse(root.right, RIGHT, length+1, dp);\\n    } else {\\n      traverse(root.left, LEFT, length+1, dp); \\n    }\\n    \\n    // act as source\\n    traverse(root.left, LEFT, 1, dp);\\n    traverse(root.right, RIGHT, 1, dp);\\n    max = Math.max(max, length);\\n    dp.add(root);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278621,
                "title": "c-short-and-simple-dfs-solution",
                "content": "```\\nint solve(TreeNode* root, bool isRightChild, int &ans) {\\n\\tif(!root) return 0;\\n\\tint l = solve(root->left, false, ans);\\n\\tint r = solve(root->right, true, ans);\\n\\tans = max(ans, max(l, r) + 1);\\n\\treturn isRightChild ? l+1 : r+1;\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n\\tint ans = 0;\\n\\tsolve(root, false, ans);\\n\\treturn ans - 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint solve(TreeNode* root, bool isRightChild, int &ans) {\\n\\tif(!root) return 0;\\n\\tint l = solve(root->left, false, ans);\\n\\tint r = solve(root->right, true, ans);\\n\\tans = max(ans, max(l, r) + 1);\\n\\treturn isRightChild ? l+1 : r+1;\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n\\tint ans = 0;\\n\\tsolve(root, false, ans);\\n\\treturn ans - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764324,
                "title": "easy-java-dfs",
                "content": "```\\nclass Solution {    \\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(dfs(root, true, -1), dfs(root, false, -1));\\n    }\\n    \\n    int dfs(TreeNode node, boolean toLeft, int path) {\\n        if (node == null) {\\n            return path;\\n        }\\n        int ans = -1;\\n        if (toLeft) {\\n            ans = dfs(node.left, false, path + 1);\\n            ans = Math.max(ans, dfs(node.right, true, 0));\\n        } else {\\n            ans = dfs(node.right, true, path + 1);\\n            ans = Math.max(ans, dfs(node.left, false, 0));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {    \\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(dfs(root, true, -1), dfs(root, false, -1));\\n    }\\n    \\n    int dfs(TreeNode node, boolean toLeft, int path) {\\n        if (node == null) {\\n            return path;\\n        }\\n        int ans = -1;\\n        if (toLeft) {\\n            ans = dfs(node.left, false, path + 1);\\n            ans = Math.max(ans, dfs(node.right, true, 0));\\n        } else {\\n            ans = dfs(node.right, true, path + 1);\\n            ans = Math.max(ans, dfs(node.left, false, 0));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726933,
                "title": "python3-clean-bfs-solution-using-deque",
                "content": "I am using a deque for BFS in python.\\nThe node of the BFS will be **{curr_node, state(can be \\'L\\' or \\'R\\'), longestdistance}** where longest distance = longest zigzag distance so far.\\n\\nNow if your current state is \\'L\\' and a right child exist for the current node, we will extend the current longest distance by 1 (same case for state \\'R\\' and existence of a left child)\\n\\n```\\nfrom collections import deque\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        # dequeu node : [curr_node, state, longestdistance]\\n        ans = 0\\n        q = deque([[root, \\'A\\', 0]])\\n        while (len(q) != 0):\\n            top, state, dist = q[0]\\n            ans = max(ans, dist)\\n            q.popleft()\\n            if state == \\'A\\':\\n                if top.left:\\n                    q.append([top.left, \\'L\\', 1])\\n                if top.right:\\n                    q.append([top.right, \\'R\\', 1])\\n            else:\\n                if state == \\'L\\':\\n                    if top.left:\\n                        q.append([top.left, \\'L\\', 1])\\n                    if top.right:\\n                        q.append([top.right, \\'R\\', dist+1])\\n                if state == \\'R\\':\\n                    if top.left:\\n                        q.append([top.left, \\'L\\', dist+1])\\n                    if top.right:\\n                        q.append([top.right, \\'R\\', 1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        # dequeu node : [curr_node, state, longestdistance]\\n        ans = 0\\n        q = deque([[root, \\'A\\', 0]])\\n        while (len(q) != 0):\\n            top, state, dist = q[0]\\n            ans = max(ans, dist)\\n            q.popleft()\\n            if state == \\'A\\':\\n                if top.left:\\n                    q.append([top.left, \\'L\\', 1])\\n                if top.right:\\n                    q.append([top.right, \\'R\\', 1])\\n            else:\\n                if state == \\'L\\':\\n                    if top.left:\\n                        q.append([top.left, \\'L\\', 1])\\n                    if top.right:\\n                        q.append([top.right, \\'R\\', dist+1])\\n                if state == \\'R\\':\\n                    if top.left:\\n                        q.append([top.left, \\'L\\', dist+1])\\n                    if top.right:\\n                        q.append([top.right, \\'R\\', 1])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 713022,
                "title": "java-top-down-easy-clean-solution-o-n",
                "content": "We follow a top down approach. \\nWe keep track of : \\n1. The direction we came from .\\n2. The distance of zig zag path till now.  If its a LL, RR combo, we start as new and take as the distance to be zero.\\n\\n```\\n  int gl;\\n    public int longestZigZag(TreeNode root) {\\n        if(root == null || root.left == null && root.right == null)return 0;\\n        helper(root.left,0,0);\\n        helper(root.right,1,0);\\n        return gl+1;\\n    }\\n    void helper(TreeNode root,int d,int distTillNow){\\n        if(root == null)return;\\n        gl = Math.max(distTillNow,gl);\\n     \\n        helper(root.left,0,d == 0 ? 0 : distTillNow+1);\\n        helper(root.right,1,d == 1 ? 0 : distTillNow+1);\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "We follow a top down approach. \\nWe keep track of : \\n1. The direction we came from .\\n2. The distance of zig zag path till now.  If its a LL, RR combo, we start as new and take as the distance to be zero.\\n\\n```\\n  int gl;\\n    public int longestZigZag(TreeNode root) {\\n        if(root == null || root.left == null && root.right == null)return 0;\\n        helper(root.left,0,0);\\n        helper(root.right,1,0);\\n        return gl+1;\\n    }\\n    void helper(TreeNode root,int d,int distTillNow){\\n        if(root == null)return;\\n        gl = Math.max(distTillNow,gl);\\n     \\n        helper(root.left,0,d == 0 ? 0 : distTillNow+1);\\n        helper(root.right,1,d == 1 ? 0 : distTillNow+1);\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 614941,
                "title": "simple-recursion-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,int l,int r,int &ans,int cur){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            ans=max(ans,cur);\\n            return;\\n        }\\n        if(l){\\n            ans=max(ans,cur);\\n            fun(root->left,1,0,ans,1);\\n            fun(root->right,0,1,ans,cur+1);\\n        }\\n        else if(r){\\n            ans=max(ans,cur);\\n            fun(root->right,0,1,ans,1);\\n            fun(root->left,1,0,ans,cur+1);\\n        }\\n        return;\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int re=0,an=0;\\n        fun(root->left,1,0,an,re+1);\\n        fun(root->right,0,1,an,re+1);\\n        return an;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,int l,int r,int &ans,int cur){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            ans=max(ans,cur);\\n            return;\\n        }\\n        if(l){\\n            ans=max(ans,cur);\\n            fun(root->left,1,0,ans,1);\\n            fun(root->right,0,1,ans,cur+1);\\n        }\\n        else if(r){\\n            ans=max(ans,cur);\\n            fun(root->right,0,1,ans,1);\\n            fun(root->left,1,0,ans,cur+1);\\n        }\\n        return;\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int re=0,an=0;\\n        fun(root->left,1,0,an,re+1);\\n        fun(root->right,0,1,an,re+1);\\n        return an;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531828,
                "title": "java-dfs-keep-a-parameter-for-direction",
                "content": "```\\nclass Solution {\\n    static int max = 0;\\n    public static void dfs(TreeNode root, int prev, int curr) {\\n        max = Math.max(max, curr);\\n        if(root == null) return;\\n        if(prev == 1) {\\n            dfs(root.left, -1, curr + 1);\\n            dfs(root.right, 1, 0);\\n            return;\\n        } else if(prev == 0) {\\n            dfs(root.left, -1, 0);\\n            dfs(root.right, 1, 0);\\n            return;\\n        } else {\\n            dfs(root.left, -1, 0);\\n            dfs(root.right, 1, curr + 1);\\n            return;\\n        }\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        max = 0;\\n        dfs(root, 0, 0);\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static int max = 0;\\n    public static void dfs(TreeNode root, int prev, int curr) {\\n        max = Math.max(max, curr);\\n        if(root == null) return;\\n        if(prev == 1) {\\n            dfs(root.left, -1, curr + 1);\\n            dfs(root.right, 1, 0);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 531806,
                "title": "c-recursion",
                "content": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int zz(TreeNode* root, bool dir) {\\n        if (!root) return -1;\\n        return 1 + (dir ? zz(root->left, !dir) : zz(root->right, !dir));\\n    }\\n    \\n    int longestZigZag(TreeNode* root, int mark=0) {\\n        if (!root) return 0;\\n\\t\\t// we only need to go both left and right in the first step\\n\\t\\t// if we go to left, we ignore the right branch of the left node since it is already checked in the previous zig-zag\\n\\t\\t// if we go to right, we ignore the left branch of the right node since it is already checked in the previous zig-zag\\n        return  max(max(mark >= 0 ? zz(root, true) : 0, mark <= 0 ? zz(root, false) : 0),\\n                    max(longestZigZag(root->left, 1), longestZigZag(root->right, -1)));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int zz(TreeNode* root, bool dir) {\\n        if (!root) return -1;\\n        return 1 + (dir ? zz(root->left, !dir) : zz(root->right, !dir));\\n    }\\n    \\n    int longestZigZag(TreeNode* root, int mark=0) {\\n        if (!root) return 0;\\n\\t\\t// we only need to go both left and right in the first step\\n\\t\\t// if we go to left, we ignore the right branch of the left node since it is already checked in the previous zig-zag\\n\\t\\t// if we go to right, we ignore the left branch of the right node since it is already checked in the previous zig-zag\\n        return  max(max(mark >= 0 ? zz(root, true) : 0, mark <= 0 ? zz(root, false) : 0),\\n                    max(longestZigZag(root->left, 1), longestZigZag(root->right, -1)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058328,
                "title": "c-beats-99-simple-recursion",
                "content": "# Intuition\\nAt each Node in the tree, you have the option to continue the pattern and go right/left accordingly or start a new path with length 1 to the opposing direction.\\n\\n# Approach\\n- The `length` argument is passed by value, and at any point in the recursion stack will contain the current maximum length of zigzag pattern.\\n- We don\\'t need to compare the recursive call answers, so just the maximum `length` at any point contains the answer.\\n- We need to start the recursion call from both left and right at the root.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n): All nodes are visited once as the recursive call structure is unique.\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int ans = -1;\\n    // 0 is left, 1 is right\\n    void _getLongestPath(TreeNode* curr, int direction, int length) {\\n        if(!curr) return;\\n        if(direction == 0) {\\n            _getLongestPath(curr->right, 1, length+1);\\n            _getLongestPath(curr->left, 0, 1);\\n        }\\n        else {\\n            _getLongestPath(curr->left, 0, length+1);\\n            _getLongestPath(curr->right, 1, 1);\\n        }\\n        ans = max(ans, length);\\n    }\\n\\n\\n    int longestZigZag(TreeNode* root) {\\n        unordered_map<TreeNode*, int> dp;\\n        _getLongestPath(root, 0, 0);\\n        _getLongestPath(root, 1, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int ans = -1;\\n    // 0 is left, 1 is right\\n    void _getLongestPath(TreeNode* curr, int direction, int length) {\\n        if(!curr) return;\\n        if(direction == 0) {\\n            _getLongestPath(curr->right, 1, length+1);\\n            _getLongestPath(curr->left, 0, 1);\\n        }\\n        else {\\n            _getLongestPath(curr->left, 0, length+1);\\n            _getLongestPath(curr->right, 1, 1);\\n        }\\n        ans = max(ans, length);\\n    }\\n\\n\\n    int longestZigZag(TreeNode* root) {\\n        unordered_map<TreeNode*, int> dp;\\n        _getLongestPath(root, 0, 0);\\n        _getLongestPath(root, 1, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976088,
                "title": "optimized-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Definition of TreeNode: This part defines the structure of a binary tree node, including its value, left child, and right child.\\n\\n2. helper Function: This function is a recursive helper that traverses the binary tree, tracking the current zigzag length (steps) and the maximum zigzag length encountered so far (maxSum). The goLeft parameter determines whether the next move should be towards the left child (if true) or right child (if false). The base case of the recursion is when the root is nullptr, in which case the function returns.\\n\\n3. Update maxSum: Before exploring child nodes, the helper function updates maxSum with the current steps value. This is done at each node to ensure that the function keeps track of the maximum zigzag length encountered so far.\\n\\n4. Recursive Calls: Depending on the goLeft value, the function calls itself recursively for the left and right children. If moving left, it increments steps and moves to the right child, and vice versa if moving right. This alternation helps keep track of zigzag paths.\\n\\n5. longestZigZag Function: This function initializes the maxSum variable to -1 (to handle the case where there\\'s no zigzag path), and then it calls the helper function with the root of the binary tree, starting with a steps value of 0, and sets goLeft to true. It returns the final maxSum value.\\n\\n5. Null Checks: Your code includes proper null checks to handle cases where the input root is null, as well as within the recursive helper function to avoid accessing the properties of a null node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,int steps,int& maxSum,bool goLeft) {\\n        if (root == nullptr) {\\n            return; // Null check to handle base case\\n        }\\n        \\n        maxSum = max(maxSum,steps);\\n\\n        if(goLeft == true) {\\n            helper(root->left,steps+1,maxSum,false);\\n\\n            helper(root->right,1,maxSum,true);\\n        }\\n\\n        else {\\n            helper(root->left,1,maxSum,false);\\n\\n            helper(root->right,steps+1,maxSum,true);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        int maxSum = -1;\\n        if(root == NULL)\\n            return 0;\\n\\n        bool goLeft = true;\\n\\n        helper(root,0,maxSum,goLeft);\\n\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,int steps,int& maxSum,bool goLeft) {\\n        if (root == nullptr) {\\n            return; // Null check to handle base case\\n        }\\n        \\n        maxSum = max(maxSum,steps);\\n\\n        if(goLeft == true) {\\n            helper(root->left,steps+1,maxSum,false);\\n\\n            helper(root->right,1,maxSum,true);\\n        }\\n\\n        else {\\n            helper(root->left,1,maxSum,false);\\n\\n            helper(root->right,steps+1,maxSum,true);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        int maxSum = -1;\\n        if(root == NULL)\\n            return 0;\\n\\n        bool goLeft = true;\\n\\n        helper(root,0,maxSum,goLeft);\\n\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954439,
                "title": "simple-traversal-o-n-with-java",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        foo(root.left,false,1);\\n        foo(root.right,true,1);\\n        return max;\\n    }\\n    private void foo(TreeNode node, boolean isRight, int counter){\\n        if(node==null){\\n            return;\\n        }\\n        max = Math.max(max,counter);\\n        foo(node.left, false, isRight ? counter + 1 : 1);\\n        foo(node.right, true, !isRight ? counter + 1 : 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        foo(root.left,false,1);\\n        foo(root.right,true,1);\\n        return max;\\n    }\\n    private void foo(TreeNode node, boolean isRight, int counter){\\n        if(node==null){\\n            return;\\n        }\\n        max = Math.max(max,counter);\\n        foo(node.left, false, isRight ? counter + 1 : 1);\\n        foo(node.right, true, !isRight ? counter + 1 : 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710322,
                "title": "java-short-and-sweet-beats-99",
                "content": "```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        int l = root.left == null ? 0 : lzz(root.left, 1, false);\\n        int r = root.right == null ? 0 : lzz(root.right, 1, true);\\n        return Math.max(l, r);\\n    }\\n\\n    public int lzz(TreeNode n, int len, boolean parentLeft) {\\n        int l = n.left == null ? len : lzz(n.left, parentLeft ? len + 1 : 1, false);\\n        int r = n.right == null ? len : lzz(n.right, parentLeft ? 1 : len + 1, true);\\n        return Math.max(l, r);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        int l = root.left == null ? 0 : lzz(root.left, 1, false);\\n        int r = root.right == null ? 0 : lzz(root.right, 1, true);\\n        return Math.max(l, r);\\n    }\\n\\n    public int lzz(TreeNode n, int len, boolean parentLeft) {\\n        int l = n.left == null ? len : lzz(n.left, parentLeft ? len + 1 : 1, false);\\n        int r = n.right == null ? len : lzz(n.right, parentLeft ? 1 : len + 1, true);\\n        return Math.max(l, r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641666,
                "title": "write-your-own-its-simple-try-harder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndfs\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndfs\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^nodes)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nodes)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* node,char state,int ct){\\n        cout<<endl<<state<<endl;\\n        int t;\\n        if(node->left){\\n            if(state==\\'r\\' || state==\\'o\\'){\\n                t=ct+1;\\n                // cout<<node->left->val<<state;\\n                ans=max(t,ans);\\n            }\\n            else{\\n                // cout<<endl;\\n                t=1;\\n            }\\n            dfs(node->left,\\'l\\',t);\\n        }\\n        if(node->right){\\n            if(state==\\'l\\' || state==\\'o\\'){\\n                t=ct+1;\\n                // cout<<node->right->val<<state;\\n                ans=max(t,ans);\\n            }\\n            else{\\n                // cout<<endl;\\n                t=1;\\n            }\\n            dfs(node->right,\\'r\\',t);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        dfs(root,\\'o\\',0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* node,char state,int ct){\\n        cout<<endl<<state<<endl;\\n        int t;\\n        if(node->left){\\n            if(state==\\'r\\' || state==\\'o\\'){\\n                t=ct+1;\\n                // cout<<node->left->val<<state;\\n                ans=max(t,ans);\\n            }\\n            else{\\n                // cout<<endl;\\n                t=1;\\n            }\\n            dfs(node->left,\\'l\\',t);\\n        }\\n        if(node->right){\\n            if(state==\\'l\\' || state==\\'o\\'){\\n                t=ct+1;\\n                // cout<<node->right->val<<state;\\n                ans=max(t,ans);\\n            }\\n            else{\\n                // cout<<endl;\\n                t=1;\\n            }\\n            dfs(node->right,\\'r\\',t);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        dfs(root,\\'o\\',0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3615829,
                "title": "c-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root)\\n    {\\n        Queue<(TreeNode, string, int)> q = new Queue<(TreeNode, string, int)>();\\n        q.Enqueue((root, \"\", 0));\\n        int ans = 0;\\n\\n        while (q.Count > 0)\\n        {\\n            (TreeNode u, string prevDir, int cnt) = q.Dequeue();\\n            ans = Math.Max(ans, cnt);\\n\\n            if (u.left != null)\\n            {\\n                if (prevDir == \"r\")\\n                    q.Enqueue((u.left, \"l\", cnt + 1));\\n                else\\n                    q.Enqueue((u.left, \"l\", 1));\\n            }\\n\\n            if (u.right != null)\\n            {\\n                if (prevDir == \"l\")\\n                    q.Enqueue((u.right, \"r\", cnt + 1));\\n                else\\n                    q.Enqueue((u.right, \"r\", 1));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root)\\n    {\\n        Queue<(TreeNode, string, int)> q = new Queue<(TreeNode, string, int)>();\\n        q.Enqueue((root, \"\", 0));\\n        int ans = 0;\\n\\n        while (q.Count > 0)\\n        {\\n            (TreeNode u, string prevDir, int cnt) = q.Dequeue();\\n            ans = Math.Max(ans, cnt);\\n\\n            if (u.left != null)\\n            {\\n                if (prevDir == \"r\")\\n                    q.Enqueue((u.left, \"l\", cnt + 1));\\n                else\\n                    q.Enqueue((u.left, \"l\", 1));\\n            }\\n\\n            if (u.right != null)\\n            {\\n                if (prevDir == \"l\")\\n                    q.Enqueue((u.right, \"r\", cnt + 1));\\n                else\\n                    q.Enqueue((u.right, \"r\", 1));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581544,
                "title": "python-efficient-and-easy-depth-first-search-dfs-solution",
                "content": "# Approach\\nTo solve this problem, we can use the DFS (Depth-First Search) approach while keeping track of the previous traversal. When the previous traversal goes to the left, the next traversal to the right can make use of the previous height. However, if the next traversal goes to the left again, its height will start from 0 because it no longer follows the zigzag pattern. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def dfs(self, tree, h=0, state=None):\\n        if tree is None:\\n            self.max_h = max(h, self.max_h)\\n            return\\n        \\n        self.dfs(tree.left, h+1 if state==\"right\" else 0, \"left\")\\n        self.dfs(tree.right, h+1 if state==\"left\" else 0, \"right\")\\n        \\n\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.max_h = 0\\n        self.dfs(root)\\n        return self.max_h\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def dfs(self, tree, h=0, state=None):\\n        if tree is None:\\n            self.max_h = max(h, self.max_h)\\n            return\\n        \\n        self.dfs(tree.left, h+1 if state==\"right\" else 0, \"left\")\\n        self.dfs(tree.right, h+1 if state==\"left\" else 0, \"right\")\\n        \\n\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.max_h = 0\\n        self.dfs(root)\\n        return self.max_h\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545526,
                "title": "c-hard-qn-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStep=0;\\n    \\n    void helper(TreeNode* root, bool goLeft, int step){\\n        if(root==NULL){ return; }\\n        maxStep= max(maxStep, step);\\n        \\n        if(goLeft==true){ // I want to go left\\n            helper(root->left, false, step+1); // I went left, so step+1, now in the next step, I want to go right, so goLeft= false \\n            helper(root->right, true, 1); // I went right, step reseted\\n        }\\n        else if(goLeft==false){ // I want to go right\\n            helper(root->right, true, step+1); // I went right, so step+1, now In next step, I want to go left, so goLeft= true\\n            helper(root->left, false, 1); // I went left, step reseted\\n        }\\n        return;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        maxStep=0;\\n        helper(root, true, 0); // from root, we will move to left, and we have taken 0 steps till now\\n        helper(root, false, 0); // from root, we will move to right, and we have taken 0 steps till now\\n        return maxStep;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStep=0;\\n    \\n    void helper(TreeNode* root, bool goLeft, int step){\\n        if(root==NULL){ return; }\\n        maxStep= max(maxStep, step);\\n        \\n        if(goLeft==true){ // I want to go left\\n            helper(root->left, false, step+1); // I went left, so step+1, now in the next step, I want to go right, so goLeft= false \\n            helper(root->right, true, 1); // I went right, step reseted\\n        }\\n        else if(goLeft==false){ // I want to go right\\n            helper(root->right, true, step+1); // I went right, so step+1, now In next step, I want to go left, so goLeft= true\\n            helper(root->left, false, 1); // I went left, step reseted\\n        }\\n        return;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        maxStep=0;\\n        helper(root, true, 0); // from root, we will move to left, and we have taken 0 steps till now\\n        helper(root, false, 0); // from root, we will move to right, and we have taken 0 steps till now\\n        return maxStep;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442431,
                "title": "binbin-is-very-close-to-cry-when-solving-this-problem-wuwuwuwu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        if root.left is None and root.right is None:\\n            return 0\\n        \\n        self.maxV = 1\\n        def choosepath(node,d,n):\\n            \\n            self.maxV = max(n, self.maxV) \\n            if d == 1:\\n                if node.left is not None:\\n                    choosepath(node.left,-1,n+1)\\n                if node.right is not None:\\n                    choosepath(node.right,1,1)\\n            if d == -1:\\n                if node.right is not None:\\n                    choosepath(node.right,1,n+1)\\n                if node.left is not None:\\n                    choosepath(node.left,-1,1)\\n            \\n        \\n        choosepath(root,1,0)\\n        return self.maxV\\n      \\n       \\n\\n\\n            \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        if root.left is None and root.right is None:\\n            return 0\\n        \\n        self.maxV = 1\\n        def choosepath(node,d,n):\\n            \\n            self.maxV = max(n, self.maxV) \\n            if d == 1:\\n                if node.left is not None:\\n                    choosepath(node.left,-1,n+1)\\n                if node.right is not None:\\n                    choosepath(node.right,1,1)\\n            if d == -1:\\n                if node.right is not None:\\n                    choosepath(node.right,1,n+1)\\n                if node.left is not None:\\n                    choosepath(node.left,-1,1)\\n            \\n        \\n        choosepath(root,1,0)\\n        return self.maxV\\n      \\n       \\n\\n\\n            \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442310,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\\n *   var value: Int = _value\\n *   var left: TreeNode = _left\\n *   var right: TreeNode = _right\\n * }\\n */\\nobject Solution {\\n    def longestZigZag(root: TreeNode): Int = {\\n      def dfs(root: TreeNode, direction: Int, curDepth: Int, maxDepth: Int):Int = {\\n        if (root == null) {\\n          (maxDepth max curDepth) - 1\\n        } else  if (direction == 0) {\\n          dfs(root.left, 1, curDepth + 1, maxDepth max (curDepth + 1)) max dfs(root.right, 0, 1, maxDepth max (curDepth + 1))\\n        } else  {\\n          dfs(root.right, 0, curDepth + 1, maxDepth max (curDepth + 1)) max dfs(root.left, 1, 1, maxDepth max (curDepth + 1))\\n        }\\n      }\\n      dfs(root, 0, 0, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\\n *   var value: Int = _value\\n *   var left: TreeNode = _left\\n *   var right: TreeNode = _right\\n * }\\n */\\nobject Solution {\\n    def longestZigZag(root: TreeNode): Int = {\\n      def dfs(root: TreeNode, direction: Int, curDepth: Int, maxDepth: Int):Int = {\\n        if (root == null) {\\n          (maxDepth max curDepth) - 1\\n        } else  if (direction == 0) {\\n          dfs(root.left, 1, curDepth + 1, maxDepth max (curDepth + 1)) max dfs(root.right, 0, 1, maxDepth max (curDepth + 1))\\n        } else  {\\n          dfs(root.right, 0, curDepth + 1, maxDepth max (curDepth + 1)) max dfs(root.left, 1, 1, maxDepth max (curDepth + 1))\\n        }\\n      }\\n      dfs(root, 0, 0, 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439359,
                "title": "map-level-order-traversal-o-n-time-and-space",
                "content": "> # ***Mastering the art of problem-solving - give my LeetCode solution an upvote if you agree!***\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHi there! In this solution, I will explain the code that you have given me. The code is a solution to the problem of finding the longest zigzag path in a binary tree. A zigzag path is a sequence of nodes such that each node is either the left child or the right child of its parent, and the direction alternates between left and right. For example, in the following tree, the longest zigzag path is [1, 3, 2, 6, 7], which has length 4.\\n\\n   ```\\n    1\\n   / \\\\\\n  2   3\\n / \\\\ / \\\\\\n4  6 5  7\\n```\\n\\nThe code uses a map to store the length of the longest zigzag path ending at each node and each direction (left or right). The key of the map is a pair of a node pointer and a boolean value, where the boolean value indicates whether the last move was to the left (true) or to the right (false). The value of the map is an integer representing the length of the zigzag path.\\n\\nThe code also uses a recursive function called traverse to update the map for each node and each direction. The function takes two parameters: a node pointer and a boolean value indicating whether the current move is to the left or to the right. The function does the following:\\n\\n- If the node is null, return.\\n- If the current move is to the left, call traverse on the left child with false as the next move, and update the map for the current node and direction by adding one to the map value for the left child and false.\\n- If the current move is to the right, call traverse on the right child with true as the next move, and update the map for the current node and direction by adding one to the map value for the right child and true.\\n\\nThe code also uses a queue to perform a level order traversal of the tree. For each node in the queue, it checks if it has been visited by looking up in the map. If not, it calls traverse on that node with both directions (true and false). Then it adds its left and right children to the queue if they are not null.\\n\\nFinally, the code iterates over all the entries in the map and finds the maximum value among them. This is the length of the longest zigzag path in the tree. It subtracts one from this value because it counts from zero.\\n\\nI hope this solution helped you understand how this code works. If you have any questions or feedback, please leave a comment below. Thank you for reading!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    map<pair<TreeNode*,bool>,int> map;\\n    void traverse(TreeNode* root,bool isLeft){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(isLeft){\\n            traverse(root->left,false);\\n            map[{root,true}]=map[{root->left,false}]+1;\\n        }\\n        else{\\n            traverse(root->right,true);\\n            map[{root,false}]=map[{root->right,true}]+1;\\n        }\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        ios_base::sync_with_stdio(false);\\n        int ans = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* temp = q.front();\\n            q.pop();\\n            if(map.find({temp,false})==map.end()){\\n                traverse(temp,false);\\n            }\\n            if(map.find({temp,true})==map.end()){\\n                traverse(temp,true);\\n            }\\n            if(temp->left){\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                q.push(temp->right);\\n            }\\n        }\\n        for(auto it:map){\\n            ans=max(ans,it.second);\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    1\\n   / \\\\\\n  2   3\\n / \\\\ / \\\\\\n4  6 5  7\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    map<pair<TreeNode*,bool>,int> map;\\n    void traverse(TreeNode* root,bool isLeft){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(isLeft){\\n            traverse(root->left,false);\\n            map[{root,true}]=map[{root->left,false}]+1;\\n        }\\n        else{\\n            traverse(root->right,true);\\n            map[{root,false}]=map[{root->right,true}]+1;\\n        }\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        ios_base::sync_with_stdio(false);\\n        int ans = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* temp = q.front();\\n            q.pop();\\n            if(map.find({temp,false})==map.end()){\\n                traverse(temp,false);\\n            }\\n            if(map.find({temp,true})==map.end()){\\n                traverse(temp,true);\\n            }\\n            if(temp->left){\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                q.push(temp->right);\\n            }\\n        }\\n        for(auto it:map){\\n            ans=max(ans,it.second);\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437219,
                "title": "easy-approach-beats-95-of-python-users",
                "content": "\\n**HELLO GUYS **\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.a=0\\n        def fun(root,i,pre):\\n            if root==None:\\n                return\\n            if pre==1:\\n                fun(root.left,1,1)\\n                fun(root.right,i+1,2)\\n            elif pre==2:\\n                fun(root.left,i+1,1)\\n                fun(root.right,1,2)\\n            else:\\n                fun(root.left,i+1,1)\\n                fun(root.right,i+1,2)\\n            if self.a<i:\\n                self.a=i\\n        fun(root,0,0)\\n        return self.a\\n```\\n# **Please vote up if you like the solution**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.a=0\\n        def fun(root,i,pre):\\n            if root==None:\\n                return\\n            if pre==1:\\n                fun(root.left,1,1)\\n                fun(root.right,i+1,2)\\n            elif pre==2:\\n                fun(root.left,i+1,1)\\n                fun(root.right,1,2)\\n            else:\\n                fun(root.left,i+1,1)\\n                fun(root.right,i+1,2)\\n            if self.a<i:\\n                self.a=i\\n        fun(root,0,0)\\n        return self.a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436871,
                "title": "easiest-java-solution-using-common-sense-and-memoization",
                "content": "# Intuition\\nCommon sense and Tricky memoization\\n\\n# Approach\\nEasy Recursion and Memoization!\\n\\n# Complexity\\n- Time complexity:\\nlinear time\\n\\n- Space complexity:\\nO(n) where n is the size of HashMap\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max_m=Integer.MIN_VALUE;\\n    public int helper(boolean left, boolean right, TreeNode root,int max,HashMap<TreeNode,Integer> dp)\\n    {\\n        if(root==null)\\n\\t        return 0;\\n\\t        if(dp.containsKey(root))\\n\\t        \\treturn dp.get(root);\\n\\t        if(left==true && root.left!=null)\\n\\t        helper(false,true,root.left,max+1,dp);\\n\\t        if(right==true && root.right!=null)\\n\\t        helper(true,false,root.right,max+1,dp);\\n\\t        max_m=Math.max(max_m,max);\\n\\t        dp.put(root, max_m);\\n\\t        max=0;\\n\\t        helper(false,true,root.left,1,dp);\\n\\t        helper(true,false,root.right,1,dp);\\n\\t        return max_m;\\n    }\\n    public int longestZigZag(TreeNode root) {\\n      if(root.left==null && root.right==null)\\n\\t        return 0;\\n\\t        HashMap<TreeNode, Integer> dp=new HashMap<>();\\n\\t        return Math.max(helper(false,true,root.left,1,dp),helper(true,false,root.right,1,dp));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max_m=Integer.MIN_VALUE;\\n    public int helper(boolean left, boolean right, TreeNode root,int max,HashMap<TreeNode,Integer> dp)\\n    {\\n        if(root==null)\\n\\t        return 0;\\n\\t        if(dp.containsKey(root))\\n\\t        \\treturn dp.get(root);\\n\\t        if(left==true && root.left!=null)\\n\\t        helper(false,true,root.left,max+1,dp);\\n\\t        if(right==true && root.right!=null)\\n\\t        helper(true,false,root.right,max+1,dp);\\n\\t        max_m=Math.max(max_m,max);\\n\\t        dp.put(root, max_m);\\n\\t        max=0;\\n\\t        helper(false,true,root.left,1,dp);\\n\\t        helper(true,false,root.right,1,dp);\\n\\t        return max_m;\\n    }\\n    public int longestZigZag(TreeNode root) {\\n      if(root.left==null && root.right==null)\\n\\t        return 0;\\n\\t        HashMap<TreeNode, Integer> dp=new HashMap<>();\\n\\t        return Math.max(helper(false,true,root.left,1,dp),helper(true,false,root.right,1,dp));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436785,
                "title": "have-track-of-prev-direction-c-easy-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    void dfs(TreeNode*root, char prev, int cnt)\\n    {\\n        if(!root) return;\\n        ans=max(ans,cnt);\\n        \\n\\t\\t//root node condition as there is no prev direction\\n        if(prev==\\'?\\')   \\n        {\\n            dfs(root->left,\\'l\\',1);\\n            dfs(root->right,\\'r\\',1);\\n        }                           \\n        else if(prev==\\'l\\')  //if we came to current node from left edge\\n        {\\n            dfs(root->left,\\'l\\',1);\\n            dfs(root->right,\\'r\\',cnt+1);\\n        }\\n        else if(prev==\\'r\\')  //if we came to current node by right edge\\n        {\\n            dfs(root->left,\\'l\\',cnt+1);\\n            dfs(root->right,\\'r\\',1);\\n        }\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        dfs(root,\\'?\\',0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    void dfs(TreeNode*root, char prev, int cnt)\\n    {\\n        if(!root) return;\\n        ans=max(ans,cnt);\\n        \\n\\t\\t//root node condition as there is no prev direction\\n        if(prev==\\'?\\')   \\n        {\\n            dfs(root->left,\\'l\\',1);\\n            dfs(root->right,\\'r\\',1);\\n        }                           \\n        else if(prev==\\'l\\')  //if we came to current node from left edge\\n        {\\n            dfs(root->left,\\'l\\',1);\\n            dfs(root->right,\\'r\\',cnt+1);\\n        }\\n        else if(prev==\\'r\\')  //if we came to current node by right edge\\n        {\\n            dfs(root->left,\\'l\\',cnt+1);\\n            dfs(root->right,\\'r\\',1);\\n        }\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        dfs(root,\\'?\\',0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436290,
                "title": "simple-c-solution-with-explanation",
                "content": "# Intuition\\n\\n# Approach\\nWe keep the state of child that it\\'s created from left or Right edge. Also, keep the total of number edges upto current node that follows the zigzag rules.\\n\\nSolved using dfs.\\nif comes from left but going to right add +1 with existing value \\nor call with 0 as zigzag len\\n\\nif comes from right but going to left add +1 with existing value\\nor call with 0 as zigzat len\\n\\n# Complexity\\n- Time complexity:\\nO(n).\\n**Explanation**\\nHere n is the total number of node in the tree. We will visit each node exactly one time.\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\nprivate:\\n    int dfs(TreeNode* cur, int state = 0, int tot = 0) {\\n        if(cur==nullptr) return (tot - 1);\\n\\n        int left = dfs(cur->left, -1, 1 + ((state!=-1)?tot:0));\\n        int right = dfs(cur->right, +1, 1 + ((state!=1)?tot:0));    \\n\\n        return max(left, right);\\n    }\\n\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        return dfs(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\nprivate:\\n    int dfs(TreeNode* cur, int state = 0, int tot = 0) {\\n        if(cur==nullptr) return (tot - 1);\\n\\n        int left = dfs(cur->left, -1, 1 + ((state!=-1)?tot:0));\\n        int right = dfs(cur->right, +1, 1 + ((state!=1)?tot:0));    \\n\\n        return max(left, right);\\n    }\\n\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        return dfs(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436266,
                "title": "90-faster-java-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    // create maxi to compare with every len\\n    public int maxi = 0;\\n    public void helper(TreeNode root,int LorR, int len){\\n        if(root == null) return; // if we reach end of leaf node then simply return\\n        maxi = Math.max(len,maxi); // compare with maxi and len, which evere greater just store it in maxi\\n        if(LorR == 0){ // if previous node was left node, ie LorR == 0\\n            // here we have two choices \\n            helper(root.right,1,len+1); // 1. if previous was left then next will be right node, \\n            // then increase len & LorR == right == 1\\n            helper(root.left,0,1); // 2. for next node will left node, then it will node follow zig zag, then change len = 1\\n        } else{ // ifprevious node was right node ie LorR == 1\\n            helper(root.left,0,len+1);\\n            helper(root.right,1,1);\\n        }\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        // LorR == 0, for left & at starting len = 1\\n        helper(root.left,0,1); // call for left part\\n        // LorR == 1, for right\\n        helper(root.right,1,1); // call fpr right part\\n        return maxi;\\n    }\\n}\\n```\\n![478xve.jpg](https://assets.leetcode.com/users/images/12f5b4ad-1d51-42a6-a0b9-0048d2afd02a_1681938100.5555906.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // create maxi to compare with every len\\n    public int maxi = 0;\\n    public void helper(TreeNode root,int LorR, int len){\\n        if(root == null) return; // if we reach end of leaf node then simply return\\n        maxi = Math.max(len,maxi); // compare with maxi and len, which evere greater just store it in maxi\\n        if(LorR == 0){ // if previous node was left node, ie LorR == 0\\n            // here we have two choices \\n            helper(root.right,1,len+1); // 1. if previous was left then next will be right node, \\n            // then increase len & LorR == right == 1\\n            helper(root.left,0,1); // 2. for next node will left node, then it will node follow zig zag, then change len = 1\\n        } else{ // ifprevious node was right node ie LorR == 1\\n            helper(root.left,0,len+1);\\n            helper(root.right,1,1);\\n        }\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        // LorR == 0, for left & at starting len = 1\\n        helper(root.left,0,1); // call for left part\\n        // LorR == 1, for right\\n        helper(root.right,1,1); // call fpr right part\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436142,
                "title": "c-easy-and-readable-solution-faster-than-75-less-than-50",
                "content": "![image.png](https://assets.leetcode.com/users/images/b391f1ae-9338-4294-bf54-93e5541b46b0_1681934251.1040218.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root) {\\n        int left = Helper (root, true, 0);\\n        int right = Helper (root, false, 0);\\n        int ans = Math.Max(left, right);\\n        return ans - 1;\\n    }\\n\\n    int Helper (TreeNode node, bool isLeft, int length)\\n    {\\n        if(node == null)\\n            return length;\\n        int current = isLeft ?  Helper(node.right, !isLeft, length + 1) : Helper(node.left, !isLeft, length + 1);\\n        int alternate = isLeft ? Helper(node.left, isLeft, 1) : Helper(node.right, isLeft, 1);\\n        int maxLength = Math.Max(current, alternate);\\n        return maxLength;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root) {\\n        int left = Helper (root, true, 0);\\n        int right = Helper (root, false, 0);\\n        int ans = Math.Max(left, right);\\n        return ans - 1;\\n    }\\n\\n    int Helper (TreeNode node, bool isLeft, int length)\\n    {\\n        if(node == null)\\n            return length;\\n        int current = isLeft ?  Helper(node.right, !isLeft, length + 1) : Helper(node.left, !isLeft, length + 1);\\n        int alternate = isLeft ? Helper(node.left, isLeft, 1) : Helper(node.right, isLeft, 1);\\n        int maxLength = Math.Max(current, alternate);\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435870,
                "title": "java-solution-with-o-n-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne way is to find all the zig-zag path and find the longest one. But in this approach the time complexity will O(n^2) which is not so good.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo optimize the algorithm for traversing a binary tree, we aim to reduce the time complexity from O(n^2) to O(n) or O(nlogn). This means that we need to traverse the tree only once. To achieve this, we should keep track of the longest path seen so far at every step of the traversal. This will allow us to determine the longest path in the tree without having to revisit any nodes, resulting in a more efficient solution with a lower time complexity. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) : Because we go on every note exactly once from top to bottom.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(h) : As we do dfs , so the recursive stack depth can be max O(depth) of nodes of tree.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n //dir 0 = L , 1 == R\\nclass Solution {\\npublic int maxLength=0;\\npublic void zigZagPath(TreeNode root,String dir,int currLength){\\nif(root==null) return;\\nmaxLength=Math.max(maxLength,currLength);\\nif(dir==\"R\"){\\n    zigZagPath(root.left,\"L\",currLength+1);\\n    zigZagPath(root.right,\"R\",1);\\n}\\nelse{\\n    zigZagPath(root.right,\"R\",currLength+1);\\n    zigZagPath(root.left,\"L\",1);\\n}\\n}\\npublic int longestZigZag(TreeNode root) {\\n    zigZagPath(root,\"L\",0);\\n    zigZagPath(root,\"R\",0); \\n    return maxLength;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n //dir 0 = L , 1 == R\\nclass Solution {\\npublic int maxLength=0;\\npublic void zigZagPath(TreeNode root,String dir,int currLength){\\nif(root==null) return;\\nmaxLength=Math.max(maxLength,currLength);\\nif(dir==\"R\"){\\n    zigZagPath(root.left,\"L\",currLength+1);\\n    zigZagPath(root.right,\"R\",1);\\n}\\nelse{\\n    zigZagPath(root.right,\"R\",currLength+1);\\n    zigZagPath(root.left,\"L\",1);\\n}\\n}\\npublic int longestZigZag(TreeNode root) {\\n    zigZagPath(root,\"L\",0);\\n    zigZagPath(root,\"R\",0); \\n    return maxLength;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435744,
                "title": "c-accepted-no-dp-a-easy-approach-using-dfs",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// Direction = true   means we move to left node\\n//Direction = false   means we move to right node\\n//depth  = when we go one side down we call the function again and increase the depth by one\\n//maxdepth = we track the max depth\\nint maxdepth=0;\\n   void solve(TreeNode* root,bool Direction,int depth){\\n     if(root==NULL){\\n         return;\\n         //no icrease in depth\\n     }\\n     if(Direction){ //Direction = true   means we move to left node\\n       solve(root->left,false,depth+1);//and increase the depth by 1 and for zig zig we set the direction as false\\n          solve(root->right,true,1);//if suppose we we are not going left(as zig zig)so we put depath as 1 and start a new chain \\n     }\\n     else{\\n        solve(root->right,true,depth+1);//Direction = true   means we move to left node//and increase the depth by 1 and for zig zig we set the direction as false\\n        solve(root->left,false,1);//if suppose we we are not going right(as zig zig)so we put depath as 1 and start a new chain \\n     }\\n     maxdepth =max(maxdepth,depth);\\n   }\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,true,0);\\n         solve(root,true,0);\\n         return maxdepth;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// Direction = true   means we move to left node\\n//Direction = false   means we move to right node\\n//depth  = when we go one side down we call the function again and increase the depth by one\\n//maxdepth = we track the max depth\\nint maxdepth=0;\\n   void solve(TreeNode* root,bool Direction,int depth){\\n     if(root==NULL){\\n         return;\\n         //no icrease in depth\\n     }\\n     if(Direction){ //Direction = true   means we move to left node\\n       solve(root->left,false,depth+1);//and increase the depth by 1 and for zig zig we set the direction as false\\n          solve(root->right,true,1);//if suppose we we are not going left(as zig zig)so we put depath as 1 and start a new chain \\n     }\\n     else{\\n        solve(root->right,true,depth+1);//Direction = true   means we move to left node//and increase the depth by 1 and for zig zig we set the direction as false\\n        solve(root->left,false,1);//if suppose we we are not going right(as zig zig)so we put depath as 1 and start a new chain \\n     }\\n     maxdepth =max(maxdepth,depth);\\n   }\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,true,0);\\n         solve(root,true,0);\\n         return maxdepth;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435575,
                "title": "easy-java-dfs-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is to solve the question using dfs keeping track of the path being zigzag or straight.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n) where n is the number of TreeNodes\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void dfs(TreeNode curr, String path, int count){\\n        if(curr == null){\\n            return;\\n        }\\n\\n\\n        if(count > max){\\n            max = count;\\n        }\\n\\n\\n        if(path == \"right\" || path == \"\"){\\n            dfs(curr.left, \"left\", count+1);\\n        }else{\\n            dfs(curr.left, \"left\", 1);\\n        }\\n\\n\\n        if(path == \"left\" || path == \"\"){\\n            dfs(curr.right, \"right\", count + 1);\\n        }else{\\n            dfs(curr.right, \"right\", 1);\\n        }\\n        \\n    }\\n\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        String path = \"\";\\n        dfs(root, path, 0);\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void dfs(TreeNode curr, String path, int count){\\n        if(curr == null){\\n            return;\\n        }\\n\\n\\n        if(count > max){\\n            max = count;\\n        }\\n\\n\\n        if(path == \"right\" || path == \"\"){\\n            dfs(curr.left, \"left\", count+1);\\n        }else{\\n            dfs(curr.left, \"left\", 1);\\n        }\\n\\n\\n        if(path == \"left\" || path == \"\"){\\n            dfs(curr.right, \"right\", count + 1);\\n        }else{\\n            dfs(curr.right, \"right\", 1);\\n        }\\n        \\n    }\\n\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        String path = \"\";\\n        dfs(root, path, 0);\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435548,
                "title": "c-recursion-easy-approach",
                "content": "Here is my c++ code for thi problem.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void chk(TreeNode* root, int dir, int cnt){\\n        if(!root){return;}\\n        ans=max(ans, cnt);\\n        if(dir){\\n            chk(root->left, 0, cnt+1);\\n            chk(root->right, 1, 1);\\n        }\\n        else{\\n            chk(root->right, 1, cnt+1);\\n            chk(root->left, 0, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root){return 0;}\\n        chk(root, 1, 0);\\n        chk(root, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void chk(TreeNode* root, int dir, int cnt){\\n        if(!root){return;}\\n        ans=max(ans, cnt);\\n        if(dir){\\n            chk(root->left, 0, cnt+1);\\n            chk(root->right, 1, 1);\\n        }\\n        else{\\n            chk(root->right, 1, cnt+1);\\n            chk(root->left, 0, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root){return 0;}\\n        chk(root, 1, 0);\\n        chk(root, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435375,
                "title": "simple-recursion-approach-very-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void helper(TreeNode* root, int dis, int dir){\\n        if(!root) return ;\\n        ans = max(ans, dis);\\n        if(dir == 1){\\n            helper(root->left, dis+1, 0);\\n            helper(root->right,1,1);\\n        }\\n        else {\\n            helper(root->right, dis+1, 1);\\n            helper(root->left,1,0);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        helper(root,0,1);\\n        helper(root,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void helper(TreeNode* root, int dis, int dir){\\n        if(!root) return ;\\n        ans = max(ans, dis);\\n        if(dir == 1){\\n            helper(root->left, dis+1, 0);\\n            helper(root->right,1,1);\\n        }\\n        else {\\n            helper(root->right, dis+1, 1);\\n            helper(root->left,1,0);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        helper(root,0,1);\\n        helper(root,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435346,
                "title": "best-c-solution-one-time-traverse-the-tree",
                "content": "\\n\\n# Code\\n```\\n\\n #define pi  pair<int, int>\\n #define ppi pair<int, pi>\\nclass Solution {\\npublic:\\n    ppi solve(TreeNode* root)    {\\n        if(root == NULL)    return {0, {-1, -1}};\\n        ppi l = solve(root -> left);\\n        ppi r = solve(root -> right);\\n        ppi temp;\\n        temp.second.first = l.second.second + 1;\\n        temp.second.second = r.second.first + 1;\\n        temp.first=max(max(l.first, r.first), max(temp.second.first, temp.second.second));\\n        return temp;\\n    }\\n\\n\\n    int longestZigZag(TreeNode* root) {\\n        return solve(root).first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\n #define pi  pair<int, int>\\n #define ppi pair<int, pi>\\nclass Solution {\\npublic:\\n    ppi solve(TreeNode* root)    {\\n        if(root == NULL)    return {0, {-1, -1}};\\n        ppi l = solve(root -> left);\\n        ppi r = solve(root -> right);\\n        ppi temp;\\n        temp.second.first = l.second.second + 1;\\n        temp.second.second = r.second.first + 1;\\n        temp.first=max(max(l.first, r.first), max(temp.second.first, temp.second.second));\\n        return temp;\\n    }\\n\\n\\n    int longestZigZag(TreeNode* root) {\\n        return solve(root).first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435317,
                "title": "scan-node-itself-and-left-and-right-for-thenode",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* r) {\\n        int res = 0;\\n        bool l =true;\\n        solve(r,res,l,0);\\n        solve(r,res,!l,0);\\n        return res;\\n        \\n    }\\n    \\n    void solve(TreeNode* r,int &res, bool l, int t)\\n    {\\n        if(!r)\\n            return;\\n        res = max(res, t);\\n        if(l)\\n        {\\n            solve(r->left,res,!l,t+1);\\n            solve(r->right,res,l,1);\\n        }\\n        else\\n        {\\n            solve(r->right,res,!l,t+1);\\n            solve(r->left,res,l,1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* r) {\\n        int res = 0;\\n        bool l =true;\\n        solve(r,res,l,0);\\n        solve(r,res,!l,0);\\n        return res;\\n        \\n    }\\n    \\n    void solve(TreeNode* r,int &res, bool l, int t)\\n    {\\n        if(!r)\\n            return;\\n        res = max(res, t);\\n        if(l)\\n        {\\n            solve(r->left,res,!l,t+1);\\n            solve(r->right,res,l,1);\\n        }\\n        else\\n        {\\n            solve(r->right,res,!l,t+1);\\n            solve(r->left,res,l,1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435304,
                "title": "simple-recursive-easy-to-understand-cpp",
                "content": "# Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou are given the root of a binary tree.\\n\\nA ZigZag path for a binary tree is defined as follow:\\n\\nChoose any node in the binary tree and a direction (right or left).\\nIf the current direction is right, move to the right child of the current node; otherwise, move to the left child.\\nChange the direction from right to left or from left to right.\\nRepeat the second and third steps until you can\\'t move in the tree.\\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\\n\\nReturn the longest ZigZag path contained in that tree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n`The solve function is a recursive helper function that calculates the zigzag length of a given subtree rooted at root. The function takes three parameters: root which is a pointer to the root node of the current subtree, isleft which is a boolean variable that indicates whether the current node is a left child or a right child of its parent, and len which is the length of the zigzag path up to the current node. If root is NULL, the function returns 0 as there is no zigzag path in that subtree.\\n\\nIn the solve function, the left and right children of the current node are recursively explored, and their respective zigzag lengths are calculated by calling solve recursively with updated parameters. The isleft parameter is used to determine the direction of the zigzag path at each node: if isleft is true, the path is going left to right, and if isleft is false, the path is going right to left. The len parameter is updated based on the direction of the zigzag path at the current node.\\n\\nOnce the zigzag lengths of the left and right children have been calculated, the solve function returns the maximum zigzag length between the left child, right child, and the current node. This is done by taking the maximum of len, lh, and rh.\\n\\nThe longestZigZag function is the main function that calculates the longest zigzag path in the binary tree. It first checks if the root is NULL and returns 0 if it is. It then calculates the zigzag lengths of the left and right children by calling solve with updated parameters. Finally, it returns the maximum zigzag length between the left child and the right child by taking the maximum of lh and rh.`\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(H) height of tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, bool isleft, int len)\\n{\\n    if(root==NULL) return 0; // If the root is NULL, return 0 as there is no zigzag path\\n\\n    int lh = solve(root->left,true, isleft?1:len+1); // Recursively calculate the zigzag length for the left child\\n    int rh = solve(root->right,false,isleft?len+1:1); // Recursively calculate the zigzag length for the right child\\n\\n    return max(len,max(lh,rh)); // Return the maximum zigzag length between the left child, right child, and the current node\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n    \\n    if(root==NULL) return 0; // If the root is NULL, return 0 as there is no zigzag path\\n\\n    int lh = solve(root->left,true,1); // Calculate the zigzag length for the left child\\n    int rh = solve(root->right,false,1); // Calculate the zigzag length for the right child\\n\\n    return max(lh,rh); // Return the maximum zigzag length between the left child and the right child\\n}\\n};\\n```\\n![PLEASE UPVOTE.jpg](https://assets.leetcode.com/users/images/2edcfb93-5a2f-4695-88af-3f8a85708fc0_1681919198.8154056.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, bool isleft, int len)\\n{\\n    if(root==NULL) return 0; // If the root is NULL, return 0 as there is no zigzag path\\n\\n    int lh = solve(root->left,true, isleft?1:len+1); // Recursively calculate the zigzag length for the left child\\n    int rh = solve(root->right,false,isleft?len+1:1); // Recursively calculate the zigzag length for the right child\\n\\n    return max(len,max(lh,rh)); // Return the maximum zigzag length between the left child, right child, and the current node\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n    \\n    if(root==NULL) return 0; // If the root is NULL, return 0 as there is no zigzag path\\n\\n    int lh = solve(root->left,true,1); // Calculate the zigzag length for the left child\\n    int rh = solve(root->right,false,1); // Calculate the zigzag length for the right child\\n\\n    return max(lh,rh); // Return the maximum zigzag length between the left child and the right child\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435283,
                "title": "runtime-100-00-faster-memory-usage-less-than-97-92",
                "content": "```\\nclass Solution {\\n    static int ct;\\n    public int longestZigZag(TreeNode root) {\\n        ct = 0;\\n        if(root.left!=null)recur(root.left,\\'l\\',1);\\n        if(root.right!=null)recur(root.right,\\'r\\',1);\\n        return ct;\\n    }\\n    private static void recur(TreeNode root, char c, int x){\\n        if(x>ct)ct = x;\\n        if(c==\\'l\\'){\\n            if(root.left!=null)recur(root.left,\\'l\\',1);\\n            if(root.right!=null)recur(root.right,\\'r\\',x+1);\\n        }else{\\n            if(root.left!=null)recur(root.left,\\'l\\',x+1);\\n            if(root.right!=null)recur(root.right,\\'r\\',1);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    static int ct;\\n    public int longestZigZag(TreeNode root) {\\n        ct = 0;\\n        if(root.left!=null)recur(root.left,\\'l\\',1);\\n        if(root.right!=null)recur(root.right,\\'r\\',1);\\n        return ct;\\n    }\\n    private static void recur(TreeNode root, char c, int x){\\n        if(x>ct)ct = x;\\n        if(c==\\'l\\'){\\n            if(root.left!=null)recur(root.left,\\'l\\',1);\\n            if(root.right!=null)recur(root.right,\\'r\\',x+1);\\n        }else{\\n            if(root.left!=null)recur(root.left,\\'l\\',x+1);\\n            if(root.right!=null)recur(root.right,\\'r\\',1);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435164,
                "title": "simple-c-solution-recursion",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int sol(TreeNode *root, bool d, int l){\\n        if(root == NULL) return l;\\n\\n        if(d == 0){\\n            return max(sol(root->left, 0, 0), sol(root->right, 1, l+1));\\n        }\\n        else{\\n            return max(sol(root->left, 0, 1+l), sol(root->right, 1, 0));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n         if(root == NULL) return 0;\\n\\n         return max(sol(root->left, 0, 0), sol(root->right, 1, 0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int sol(TreeNode *root, bool d, int l){\\n        if(root == NULL) return l;\\n\\n        if(d == 0){\\n            return max(sol(root->left, 0, 0), sol(root->right, 1, l+1));\\n        }\\n        else{\\n            return max(sol(root->left, 0, 1+l), sol(root->right, 1, 0));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n         if(root == NULL) return 0;\\n\\n         return max(sol(root->left, 0, 0), sol(root->right, 1, 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1868047,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868130,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868023,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868680,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868336,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868150,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868053,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868857,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868595,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868285,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868047,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868130,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868023,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868680,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868336,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868150,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868053,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868857,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868595,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868285,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868005,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 2069060,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1868638,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1868250,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1868030,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1868190,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 2065036,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 2031715,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1924319,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1911286,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1895120,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1891095,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868753,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868598,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868563,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868541,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868522,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868504,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868492,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868491,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Sum BST in Binary Tree",
        "question_content": "<p>Given a <strong>binary tree</strong> <code>root</code>, return <em>the maximum sum of all keys of <strong>any</strong> sub-tree which is also a Binary Search Tree (BST)</em>.</p>\n\n<p>Assume a BST is defined as follows:</p>\n\n<ul>\n\t<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>\n\t<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/30/sample_1_1709.png\" style=\"width: 320px; height: 250px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]\n<strong>Output:</strong> 20\n<strong>Explanation:</strong> Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/30/sample_2_1709.png\" style=\"width: 134px; height: 180px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [4,3,null,1,2]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [-4,-2,-5]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> All values are negatives. Return an empty BST.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 4 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-4 * 10<sup>4</sup> &lt;= Node.val &lt;= 4 * 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 531822,
                "title": "java-post-order-traverse-with-comment-clean-code",
                "content": "```java\\nclass Solution {\\n    private int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        postOrderTraverse(root);\\n        return maxSum;\\n    }\\n    private int[] postOrderTraverse(TreeNode root) {\\n        if (root == null) return new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE, 0}; // {min, max, sum}, initialize min=MAX_VALUE, max=MIN_VALUE\\n        int[] left = postOrderTraverse(root.left);\\n        int[] right = postOrderTraverse(root.right);\\n        // The BST is the tree:\\n        if (!(     left != null             // the left subtree must be BST\\n                && right != null            // the right subtree must be BST\\n                && root.val > left[1]       // the root\\'s key must greater than maximum keys of the left subtree\\n                && root.val < right[0]))    // the root\\'s key must lower than minimum keys of the right subtree\\n            return null;\\n        int sum = root.val + left[2] + right[2]; // now it\\'s a BST make `root` as root\\n        maxSum = Math.max(maxSum, sum);\\n        int min = Math.min(root.val, left[0]);\\n        int max = Math.max(root.val, right[1]);\\n        return new int[]{min, max, sum};\\n    }\\n}\\n```\\n**Complexity:**\\n- Time: `O(n)`\\n- Space: `O(h)`, where `h` is the height of the binary tree\\n\\n\\n**Similar problem**\\n[98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    private int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        postOrderTraverse(root);\\n        return maxSum;\\n    }\\n    private int[] postOrderTraverse(TreeNode root) {\\n        if (root == null) return new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE, 0}; // {min, max, sum}, initialize min=MAX_VALUE, max=MIN_VALUE\\n        int[] left = postOrderTraverse(root.left);\\n        int[] right = postOrderTraverse(root.right);\\n        // The BST is the tree:\\n        if (!(     left != null             // the left subtree must be BST\\n                && right != null            // the right subtree must be BST\\n                && root.val > left[1]       // the root\\'s key must greater than maximum keys of the left subtree\\n                && root.val < right[0]))    // the root\\'s key must lower than minimum keys of the right subtree\\n            return null;\\n        int sum = root.val + left[2] + right[2]; // now it\\'s a BST make `root` as root\\n        maxSum = Math.max(maxSum, sum);\\n        int min = Math.min(root.val, left[0]);\\n        int max = Math.max(root.val, right[1]);\\n        return new int[]{min, max, sum};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126183,
                "title": "c-recursion-easy-to-understand",
                "content": "**Code:**\\n```\\nint ans;\\nclass prop{\\npublic:\\n    bool bst;       //to check if tree is bst\\n    int ma;         //max value in a tree\\n    int mi;         //min value in an tree\\n    int ms;         //current maximum sum\\n    prop(){\\n        bst=true;\\n        ma=INT_MIN;\\n        mi=INT_MAX;\\n        ms=0;\\n    }\\n};\\nclass Solution {\\npublic:\\n    prop calcSum(TreeNode* root){\\n        if (root == NULL){\\n            return prop();\\n        }\\n        prop p;\\n        prop pl = calcSum(root->left);                        //recursive call for left sub-tree\\n        prop pr = calcSum(root->right);                       //recursive call for right sub-tree\\n\\t\\t\\n\\t\\t//if sub-tree including this node is bst\\n        if ( pl.bst==true && pr.bst==true && root->val>pl.ma && root->val<pr.mi ){\\n            p.bst = true;                                                      //current tree is a bst\\n            p.ms = pl.ms + pr.ms + root->val;          \\n            p.mi  = min(root->val, pl.mi);\\n            p.ma = max(root->val, pr.ma);\\n        }\\n\\t\\t//if current tree is not a bst\\n        else {\\n            p.bst=false;\\n            p.ms=max(pl.ms, pr.ms);\\n        }\\n\\t\\t\\n        ans=max(ans, p.ms);\\n        return p;\\n    }\\n    int maxSumBST(TreeNode* root){\\n        ans = 0;\\n        calcSum(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint ans;\\nclass prop{\\npublic:\\n    bool bst;       //to check if tree is bst\\n    int ma;         //max value in a tree\\n    int mi;         //min value in an tree\\n    int ms;         //current maximum sum\\n    prop(){\\n        bst=true;\\n        ma=INT_MIN;\\n        mi=INT_MAX;\\n        ms=0;\\n    }\\n};\\nclass Solution {\\npublic:\\n    prop calcSum(TreeNode* root){\\n        if (root == NULL){\\n            return prop();\\n        }\\n        prop p;\\n        prop pl = calcSum(root->left);                        //recursive call for left sub-tree\\n        prop pr = calcSum(root->right);                       //recursive call for right sub-tree\\n\\t\\t\\n\\t\\t//if sub-tree including this node is bst\\n        if ( pl.bst==true && pr.bst==true && root->val>pl.ma && root->val<pr.mi ){\\n            p.bst = true;                                                      //current tree is a bst\\n            p.ms = pl.ms + pr.ms + root->val;          \\n            p.mi  = min(root->val, pl.mi);\\n            p.ma = max(root->val, pr.ma);\\n        }\\n\\t\\t//if current tree is not a bst\\n        else {\\n            p.bst=false;\\n            p.ms=max(pl.ms, pr.ms);\\n        }\\n\\t\\t\\n        ans=max(ans, p.ms);\\n        return p;\\n    }\\n    int maxSumBST(TreeNode* root){\\n        ans = 0;\\n        calcSum(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534877,
                "title": "java-one-pass-post-order-dfs-o-n",
                "content": "```\\nclass Solution {\\n    int max;\\n    public int maxSumBST(TreeNode root) {\\n        max = 0;\\n        findMaxSum(root);\\n        return max;\\n    }\\n    \\n    //int[]{isBST(0/1), largest, smallest, sum}\\n    public int[] findMaxSum(TreeNode node){\\n        if(node==null){\\n            return new int[]{1, Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\\n        }\\n        int[] left = findMaxSum(node.left);\\n        int[] right = findMaxSum(node.right);\\n        boolean isBST = left[0]==1 && right[0]==1 && node.val>left[1] && node.val<right[2];\\n        int sum = node.val + left[3] + right[3];\\n        if(isBST){\\n            max = Math.max(max, sum);\\n        }\\n        return new int[]{isBST?1:0, Math.max(node.val,right[1]), Math.min(node.val,left[2]), sum};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max;\\n    public int maxSumBST(TreeNode root) {\\n        max = 0;\\n        findMaxSum(root);\\n        return max;\\n    }\\n    \\n    //int[]{isBST(0/1), largest, smallest, sum}\\n    public int[] findMaxSum(TreeNode node){\\n        if(node==null){\\n            return new int[]{1, Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\\n        }\\n        int[] left = findMaxSum(node.left);\\n        int[] right = findMaxSum(node.right);\\n        boolean isBST = left[0]==1 && right[0]==1 && node.val>left[1] && node.val<right[2];\\n        int sum = node.val + left[3] + right[3];\\n        if(isBST){\\n            max = Math.max(max, sum);\\n        }\\n        return new int[]{isBST?1:0, Math.max(node.val,right[1]), Math.min(node.val,left[2]), sum};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531826,
                "title": "c-o-n-record-min-max-and-sum",
                "content": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // {smallest_num, largest_num, curr_sum} of a tree\\n    vector<int> traverse(TreeNode* root, int& ans) {\\n        if (!root) return {INT_MAX, INT_MIN, 0};\\n        vector<int> left(traverse(root->left, ans)), right(traverse(root->right, ans));\\n\\t\\t// check if a tree is BST\\n        if (left.empty() || right.empty() || root->val <= left[1] || root->val >= right[0]) return {};\\n\\t\\t// if BST, update ans\\n        int curr_sum = left[2] + right[2] + root->val;\\n        ans = max(ans, curr_sum);\\n        return {min(left[0], root->val), max(right[1], root->val), curr_sum};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans(0);\\n        traverse(root, ans);\\n        return max(0, ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // {smallest_num, largest_num, curr_sum} of a tree\\n    vector<int> traverse(TreeNode* root, int& ans) {\\n        if (!root) return {INT_MAX, INT_MIN, 0};\\n        vector<int> left(traverse(root->left, ans)), right(traverse(root->right, ans));\\n\\t\\t// check if a tree is BST\\n        if (left.empty() || right.empty() || root->val <= left[1] || root->val >= right[0]) return {};\\n\\t\\t// if BST, update ans\\n        int curr_sum = left[2] + right[2] + root->val;\\n        ans = max(ans, curr_sum);\\n        return {min(left[0], root->val), max(right[1], root->val), curr_sum};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans(0);\\n        traverse(root, ans);\\n        return max(0, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531800,
                "title": "python-easy-traversal-with-explanation",
                "content": "**Idea**\\nFor each subtree, we return 4 elements.\\n1. the status of this subtree, `1` means it\\'s empty, `2` means it\\'s a BST, `0` means it\\'s not a BST\\n2. size of this subtree (we only care about size of BST though)\\n3. the minimal value in this subtree\\n4. the maximal value in this subtree\\n\\nThen we only need to make sure for every BST\\n- both of its children are BST\\n- the right bound of its left child is smaller than `root.val`\\n- the left bound of its right child is larger than `root.val`\\n\\n**Complexity**\\nTime: `O(N)`\\nSpace: `O(logN)` for function calls, worst case `O(N)` if the given tree is not balanced\\n\\n**Python 3**\\n```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        res = 0\\n        def traverse(root):\\n            \\'\\'\\'return status_of_bst, size_of_bst, left_bound, right_bound\\'\\'\\'\\n            nonlocal res\\n            if not root: return 1, 0, None, None # this subtree is empty\\n            \\n            ls, l, ll, lr = traverse(root.left)\\n            rs, r, rl, rr = traverse(root.right)\\n            \\n            if ((ls == 2 and lr < root.val) or ls == 1) and ((rs == 2 and rl > root.val) or rs == 1):\\n\\t\\t        # this subtree is a BST\\n                size = root.val + l + r\\n                res = max(res, size)\\n                return 2, size, (ll if ll is not None else root.val), (rr if rr is not None else root.val)\\n            return 0, None, None, None # this subtree is not a BST\\n        \\n        traverse(root)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Interactive"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        res = 0\\n        def traverse(root):\\n            \\'\\'\\'return status_of_bst, size_of_bst, left_bound, right_bound\\'\\'\\'\\n            nonlocal res\\n            if not root: return 1, 0, None, None # this subtree is empty\\n            \\n            ls, l, ll, lr = traverse(root.left)\\n            rs, r, rl, rr = traverse(root.right)\\n            \\n            if ((ls == 2 and lr < root.val) or ls == 1) and ((rs == 2 and rl > root.val) or rs == 1):\\n\\t\\t        # this subtree is a BST\\n                size = root.val + l + r\\n                res = max(res, size)\\n                return 2, size, (ll if ll is not None else root.val), (rr if rr is not None else root.val)\\n            return 0, None, None, None # this subtree is not a BST\\n        \\n        traverse(root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162388,
                "title": "c-use-dfs-class-object-simple-efficient-solution",
                "content": "**TC: O(N) - DFS Traversal\\nSC: O(N) - Auxiliary recursion stack space**\\n\\n**Code:**\\n```\\nclass NodeValue {\\npublic: \\n    int minNode, maxNode, maxSum;\\n    \\n    NodeValue(int minNode, int maxNode, int maxSum)\\n    {\\n        this->minNode = minNode;\\n        this->maxNode = maxNode;\\n        this->maxSum = maxSum;\\n    }\\n};\\n\\nclass Solution {\\n    \\nprivate:\\n    NodeValue maxSumBSTHelper(TreeNode* root)\\n    {\\n        if(!root) return NodeValue(INT_MAX, INT_MIN, 0);\\n        \\n        auto left = maxSumBSTHelper(root->left);\\n        auto right = maxSumBSTHelper(root->right);\\n        \\n        if(left.maxNode < root->val && root->val < right.minNode)\\n        {\\n            //if BT is BST\\n            sum = max(sum, root->val + left.maxSum + right.maxSum);\\n            \\n            return NodeValue(min(root->val, left.minNode), max(root->val, right.maxNode), root->val + left.maxSum + right.maxSum);\\n            \\n        }\\n        \\n        return NodeValue(INT_MIN, INT_MAX, max(left.maxSum, right.maxSum));   \\n    }\\n    \\npublic:\\n    int sum=0;\\n    int maxSumBST(TreeNode* root) \\n    {\\n        maxSumBSTHelper(root);\\n        return sum>0 ? sum : 0;\\n        \\n    }\\n};\\n```\\n\\n**Please upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass NodeValue {\\npublic: \\n    int minNode, maxNode, maxSum;\\n    \\n    NodeValue(int minNode, int maxNode, int maxSum)\\n    {\\n        this->minNode = minNode;\\n        this->maxNode = maxNode;\\n        this->maxSum = maxSum;\\n    }\\n};\\n\\nclass Solution {\\n    \\nprivate:\\n    NodeValue maxSumBSTHelper(TreeNode* root)\\n    {\\n        if(!root) return NodeValue(INT_MAX, INT_MIN, 0);\\n        \\n        auto left = maxSumBSTHelper(root->left);\\n        auto right = maxSumBSTHelper(root->right);\\n        \\n        if(left.maxNode < root->val && root->val < right.minNode)\\n        {\\n            //if BT is BST\\n            sum = max(sum, root->val + left.maxSum + right.maxSum);\\n            \\n            return NodeValue(min(root->val, left.minNode), max(root->val, right.maxNode), root->val + left.maxSum + right.maxSum);\\n            \\n        }\\n        \\n        return NodeValue(INT_MIN, INT_MAX, max(left.maxSum, right.maxSum));   \\n    }\\n    \\npublic:\\n    int sum=0;\\n    int maxSumBST(TreeNode* root) \\n    {\\n        maxSumBSTHelper(root);\\n        return sum>0 ? sum : 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839174,
                "title": "java-dfs-with-explanation-faster-than-99",
                "content": "At each node we want to know 2 things:\\n - Is this node the root of a valid BST?\\n - What is the sum of the subtree?\\n\\nIf we know these 2 pieces of information about each node, then finding the final solution is trivial.\\n\\nThe main idea of this problem is to start at the bottom (leaf) nodes and work our way up the tree, remembering the \"2 things\" about each node on the way up. To encapsulate the data nicely, we can define a custom data structure that adds relevant data we need to the given `TreeNode` class:\\n\\n```\\n    static class NodeWrapper {\\n        final TreeNode node;\\n        int sum;\\n        int max;\\n        int min;\\n        boolean validBST = true;\\n        public NodeWrapper(TreeNode node) {\\n            this.node = node;\\n            this.sum = node.val;\\n            this.max = node.val;\\n            this.min = node.val;\\n        }\\n    }\\n```\\n\\nTo obtain the final solution, we perform a post-order DFS and use the `NodeWrapper` for the left and right subtrees of each node to determine the original 2 pieces of information we need: is the current node a BST, and what is the sum of the subtree.\\n\\nThe final solution looks like this:\\n\\n```\\nclass Solution {\\n    \\n    int maxSum = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        findMaxSum(root);\\n        return maxSum;\\n    }\\n    \\n    private NodeWrapper findMaxSum(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        \\n        NodeWrapper leftTree = findMaxSum(root.left);\\n        NodeWrapper rightTree = findMaxSum(root.right);\\n        \\n        NodeWrapper curNode = new NodeWrapper(root);\\n        if (leftTree != null) {\\n            curNode.sum += leftTree.sum;\\n            curNode.max = Math.max(root.val, leftTree.max);\\n            curNode.min = Math.min(root.val, leftTree.min);\\n            curNode.validBST = leftTree.validBST && leftTree.max < root.val;\\n        }\\n        if (rightTree != null) {\\n            curNode.sum += rightTree.sum;\\n            curNode.max = Math.max(curNode.max, rightTree.max);\\n            curNode.min = Math.min(curNode.min, rightTree.min);\\n            curNode.validBST &= rightTree.validBST && rightTree.min > root.val;\\n        }\\n\\n        if (curNode.validBST) {\\n            maxSum = Math.max(maxSum, curNode.sum);   \\n        }\\n        return curNode;\\n    }\\n        \\n    static class NodeWrapper {\\n        final TreeNode node;\\n        int sum;\\n        int max;\\n        int min;\\n        boolean validBST = true;\\n        public NodeWrapper(TreeNode node) {\\n            this.node = node;\\n            this.sum = node.val;\\n            this.max = node.val;\\n            this.min = node.val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    static class NodeWrapper {\\n        final TreeNode node;\\n        int sum;\\n        int max;\\n        int min;\\n        boolean validBST = true;\\n        public NodeWrapper(TreeNode node) {\\n            this.node = node;\\n            this.sum = node.val;\\n            this.max = node.val;\\n            this.min = node.val;\\n        }\\n    }\\n```\n```\\nclass Solution {\\n    \\n    int maxSum = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        findMaxSum(root);\\n        return maxSum;\\n    }\\n    \\n    private NodeWrapper findMaxSum(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        \\n        NodeWrapper leftTree = findMaxSum(root.left);\\n        NodeWrapper rightTree = findMaxSum(root.right);\\n        \\n        NodeWrapper curNode = new NodeWrapper(root);\\n        if (leftTree != null) {\\n            curNode.sum += leftTree.sum;\\n            curNode.max = Math.max(root.val, leftTree.max);\\n            curNode.min = Math.min(root.val, leftTree.min);\\n            curNode.validBST = leftTree.validBST && leftTree.max < root.val;\\n        }\\n        if (rightTree != null) {\\n            curNode.sum += rightTree.sum;\\n            curNode.max = Math.max(curNode.max, rightTree.max);\\n            curNode.min = Math.min(curNode.min, rightTree.min);\\n            curNode.validBST &= rightTree.validBST && rightTree.min > root.val;\\n        }\\n\\n        if (curNode.validBST) {\\n            maxSum = Math.max(maxSum, curNode.sum);   \\n        }\\n        return curNode;\\n    }\\n        \\n    static class NodeWrapper {\\n        final TreeNode node;\\n        int sum;\\n        int max;\\n        int min;\\n        boolean validBST = true;\\n        public NodeWrapper(TreeNode node) {\\n            this.node = node;\\n            this.sum = node.val;\\n            this.max = node.val;\\n            this.min = node.val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534900,
                "title": "c-naive-correct",
                "content": "**Update** the first solution is accepted, but it\\'s not accurate. See the second solution below.\\n\\nWhy this problem is marked hard?\\n\\nWe traverse the tree and return INT_MIN if it is not BST. Otherwise, we return the sum of its node values.\\n\\nIf sums for the both left and right subtrees is not INT_MIN (both subtrees are BST), we then check if the value of the current node is greater then left node value, and lower than right node value. If it is, we return the sum of the entire subtree.\\n\\nOtherwise, return INT_MIN.\\n\\n```cpp\\nint maxSum = 0;\\nint dfs(TreeNode* n) {\\n    if (n == nullptr) return 0;\\n    auto ls = dfs(n->left), rs = dfs(n->right);\\n    if (ls != INT_MIN && rs != INT_MIN) {\\n        if ((n->left == nullptr || n->left->val < n->val) \\n            && (n->right == nullptr || n->right->val > n->val)) {\\n            maxSum = max(maxSum, n->val + ls + rs);\\n            return n->val + ls + rs;\\n        }\\n    }\\n    return INT_MIN;\\n}\\nint maxSumBST(TreeNode* root) {\\n    dfs(root);\\n    return maxSum;\\n}\\n```\\n\\n**Updated Solution**\\nThe solution above is accepted, however, as [hiepit](https://leetcode.com/hiepit/) and [MohammedShoaib](https://leetcode.com/mohammedshoaib/) pointed out, it produces wrong result for use case like this: `[4,2,6,1,5,3,9]`. To address it, we need to also track the minimum and maximum value of the subtree, and check that the node value is greater than the maximum, and less than the minimum of left and right subtrees, respectfully.\\n\\nSo, instead of just sum, below we return tree values: {sum, min value, max value}.\\n```cpp\\n#define ANIMAL_STYLE 1\\n```\\n```cpp\\nint max_sum = 0;\\narray<int, 3> dfs(TreeNode* n) {\\n    auto l = n->left ? dfs(n->left) : array<int, 3>{0, n->val, n->val - 1};\\n    auto r = n->right ? dfs(n->right) : array<int, 3>{0, n->val + 1, n->val};\\n    if (l[2] < n->val && n->val < r[1]) {\\n        max_sum = max(max_sum, n->val + l[0] + r[0]);\\n        return {n->val + l[0] + r[0], l[1], r[2]};        \\n    }\\n    return {0, INT_MIN, INT_MAX};\\n}\\nint maxSumBST(TreeNode* root) {\\n    dfs(root);\\n    return max_sum;\\n}\\n```\\n```cpp\\n#undef ANIMAL_STYLE\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxSum = 0;\\nint dfs(TreeNode* n) {\\n    if (n == nullptr) return 0;\\n    auto ls = dfs(n->left), rs = dfs(n->right);\\n    if (ls != INT_MIN && rs != INT_MIN) {\\n        if ((n->left == nullptr || n->left->val < n->val) \\n            && (n->right == nullptr || n->right->val > n->val)) {\\n            maxSum = max(maxSum, n->val + ls + rs);\\n            return n->val + ls + rs;\\n        }\\n    }\\n    return INT_MIN;\\n}\\nint maxSumBST(TreeNode* root) {\\n    dfs(root);\\n    return maxSum;\\n}\\n```\n```cpp\\n#define ANIMAL_STYLE 1\\n```\n```cpp\\nint max_sum = 0;\\narray<int, 3> dfs(TreeNode* n) {\\n    auto l = n->left ? dfs(n->left) : array<int, 3>{0, n->val, n->val - 1};\\n    auto r = n->right ? dfs(n->right) : array<int, 3>{0, n->val + 1, n->val};\\n    if (l[2] < n->val && n->val < r[1]) {\\n        max_sum = max(max_sum, n->val + l[0] + r[0]);\\n        return {n->val + l[0] + r[0], l[1], r[2]};        \\n    }\\n    return {0, INT_MIN, INT_MAX};\\n}\\nint maxSumBST(TreeNode* root) {\\n    dfs(root);\\n    return max_sum;\\n}\\n```\n```cpp\\n#undef ANIMAL_STYLE\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1555163,
                "title": "c-postorder-traversal-easy-to-understand-dfs",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    class bst {\\n    public:\\n      bool isbst;\\n      int max;\\n      int min;\\n      int sum;\\n    };\\n\\n    bst Bst(TreeNode* root) {\\n\\n      if (root == nullptr)\\n      {  \\n        bst bres;            // Base Case\\n        bres.isbst = true;\\n        bres.max = INT_MIN;\\n        bres.min = INT_MAX;\\n        bres.sum = 0;\\n        return bres;\\n      }\\n      bst l = Bst(root->left); // left sub-tree\\n      bst r = Bst(root->right); // right sub-tree\\n\\n      bst ans;\\n\\n      ans.max = max(root->val, max(l.max, r.max));\\n      ans.min = min(root->val, min(l.min, r.min));\\n\\n      // Check if current tree is Bst or not ?\\n      ans.isbst = l.isbst && r.isbst && (l.max < root->val && r.min > root->val);\\n\\n      if(ans.isbst){\\n          ans.sum = l.sum + r.sum + root->val;\\n          ans.min = min(root->val, min(l.min, r.min));\\n          ans.max = max(root->val, max(l.max, r.max));\\n      }\\n      else\\n          ans.sum = max(l.sum, r.sum);\\n      \\n      res = max(res, ans.sum);\\n      return ans;\\n    }\\n    \\n    int res = INT_MIN;\\n    int maxSumBST(TreeNode* root) {\\n        Bst(root);\\n        return res > 0 ? res : 0;\\n    }\\n};\\n```\\nHope you liked it , kindly upvote !!\\nComment down your queries \\nHappy Coding \\uD83E\\uDD17",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class bst {\\n    public:\\n      bool isbst;\\n      int max;\\n      int min;\\n      int sum;\\n    };\\n\\n    bst Bst(TreeNode* root) {\\n\\n      if (root == nullptr)\\n      {  \\n        bst bres;            // Base Case\\n        bres.isbst = true;\\n        bres.max = INT_MIN;\\n        bres.min = INT_MAX;\\n        bres.sum = 0;\\n        return bres;\\n      }\\n      bst l = Bst(root->left); // left sub-tree\\n      bst r = Bst(root->right); // right sub-tree\\n\\n      bst ans;\\n\\n      ans.max = max(root->val, max(l.max, r.max));\\n      ans.min = min(root->val, min(l.min, r.min));\\n\\n      // Check if current tree is Bst or not ?\\n      ans.isbst = l.isbst && r.isbst && (l.max < root->val && r.min > root->val);\\n\\n      if(ans.isbst){\\n          ans.sum = l.sum + r.sum + root->val;\\n          ans.min = min(root->val, min(l.min, r.min));\\n          ans.max = max(root->val, max(l.max, r.max));\\n      }\\n      else\\n          ans.sum = max(l.sum, r.sum);\\n      \\n      res = max(res, ans.sum);\\n      return ans;\\n    }\\n    \\n    int res = INT_MIN;\\n    int maxSumBST(TreeNode* root) {\\n        Bst(root);\\n        return res > 0 ? res : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990802,
                "title": "c-recursive-faster-than-99-with-explanation",
                "content": "From the definition of a BST, we can figure out that we need a recursive solution - in order to find out whether a subtree at a given node is a BST, we first need to find out whether its children are BSTs. Once we know that left and right subtrees of the node are BSTs, we need to check whether left subtree contains only values that are less than the node\\'s value, and right subtree contains values that are greater than the node\\'s value. Because we need multiple different values for each child, we can make our helper function return a structure with all those values. One more piece of inormation that is needed for calculating the max sum of any BST subtree would be the sum of all values in the subtree, and we can return it as part of our helper structure. Note that we can also solve this without ```isBst``` field in the structure if we use other fields to make up for it, but I think this way is more intuitive and more readable.\\n\\n```\\nclass Solution {\\n    struct S {\\n        bool isBST;\\n        int minVal, maxVal, sum;\\n    };\\n    \\n    S helper(TreeNode *node, int &res) {\\n        if (!node) {\\n            return { true, INT_MAX, INT_MIN, 0 };\\n        }\\n        S l = helper(node->left, res);\\n        S r = helper(node->right, res);\\n        if (l.isBST && r.isBST && l.maxVal < node->val && r.minVal > node->val) {\\n            int sum = l.sum + r.sum + node->val;\\n            res = max(res, sum);\\n            return { true, min(l.minVal, node->val), max(r.maxVal, node->val), sum };\\n        } else {\\n            return { false, 0, 0, 0 };\\n        }\\n    }\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int res = 0;\\n        helper(root, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```isBst```\n```\\nclass Solution {\\n    struct S {\\n        bool isBST;\\n        int minVal, maxVal, sum;\\n    };\\n    \\n    S helper(TreeNode *node, int &res) {\\n        if (!node) {\\n            return { true, INT_MAX, INT_MIN, 0 };\\n        }\\n        S l = helper(node->left, res);\\n        S r = helper(node->right, res);\\n        if (l.isBST && r.isBST && l.maxVal < node->val && r.minVal > node->val) {\\n            int sum = l.sum + r.sum + node->val;\\n            res = max(res, sum);\\n            return { true, min(l.minVal, node->val), max(r.maxVal, node->val), sum };\\n        } else {\\n            return { false, 0, 0, 0 };\\n        }\\n    }\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int res = 0;\\n        helper(root, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598444,
                "title": "java-easy-and-intuitive-solution-all-approaches-brute-to-optimal-99-78-faster",
                "content": "# Brute\\n**Code**\\n```java\\npublic class MaxSumBSTinBT {\\n    int maxsum = 0;\\n    public int maxSumBSTBrute(TreeNode root) {\\n        if(root == null) return 0;\\n\\n        if(isValidBST(root))\\n            maxsum = Math.max(maxsum, sumTree(root));\\n\\n        maxSumBSTBrute(root.left);\\n        maxSumBSTBrute(root.right);\\n\\n        return maxsum;\\n    }\\n\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBSTUtil(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    private boolean isValidBSTUtil(TreeNode root, long minRange, long maxRange) {\\n        if(root == null) return true;\\n\\n        if(root.val <= minRange || root.val >= maxRange) return false;\\n\\n        return isValidBSTUtil(root.left, minRange, root.val) && isValidBSTUtil(root.right, root.val, maxRange);\\n    }\\n\\n    public int sumTree(TreeNode root) {\\n        if(root == null) return 0;\\n\\n        return root.val + sumTree(root.left) + sumTree(root.right);\\n    }\\n}\\n```\\n\\n**Explanation**\\nThis code will give time limit exceeded when ran but this is very intuitive solution.\\nIn this we are doing following steps:\\n- we check at a particular node starting from root node that if the tree starting from this node is valid bst or not. \\n\\t- if it is then we update our maxsum value.\\n- then we call recursively on left and right subtree\\n- finally return maxsum value which is by default 0 as sum cannot be smaller than 0.\\n- \\n---\\n<br>\\n\\n# Brute - slightly better\\n```java\\npublic class MaxSumBSTinBTBetter {\\n    int maxsum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n\\n        boolean isBST = isValidBST(root);\\n        int[] sumAndNeg = new int[2];\\n        sumAndNeg = sumTree(root, sumAndNeg);\\n\\n        if(isBST)\\n            maxsum = Math.max(maxsum, sumAndNeg[0]);\\n\\n        if(!isBST || sumAndNeg[1] == 1) {\\n            maxSumBST(root.left);\\n            maxSumBST(root.right);\\n        }\\n\\n        return maxsum;\\n    }\\n\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBSTUtil(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    private boolean isValidBSTUtil(TreeNode root, long minRange, long maxRange) {\\n        if(root == null) return true;\\n\\n        if(root.val <= minRange || root.val >= maxRange) return false;\\n\\n        return isValidBSTUtil(root.left, minRange, root.val) && isValidBSTUtil(root.right, root.val, maxRange);\\n    }\\n\\n    public int[] sumTree(TreeNode root, int[] arr) {\\n        if(root == null) return new int[]{0, arr[1]};\\n\\n        if(root.val < 0) {\\n            arr[1] = 1;\\n        }\\n        arr[0] = root.val + sumTree(root.left, arr)[0] + sumTree(root.right, arr)[0];\\n        return arr;\\n    }\\n}\\n```\\n\\n**Explanation**\\nThis too will give time limit exceeded but I\\'ve included these to provide brute force solutions as well which are foundation for builing a solution, our next solution though will be optimal.\\nNow see in given figure\\n![image](https://assets.leetcode.com/users/images/7ab01813-9787-4c40-9eb6-e8d882452e0f_1638005873.081496.png)\\n\\nwhen we got to know that tree with root 3 is a bst why do we need to check for left and right subtree, when we could just return the sum of entire tree isn\\'t it?\\nNo. In the constraints we are given that tree also contains negative nodes for which sum could be reduced, so in this solution of ours we check if the tree doesn\\'t have any negative node then just don\\'t call on left and right otherwise do.\\n\\n---\\n<br>\\n\\n# Final Optimal Solution\\n\\n![image](https://assets.leetcode.com/users/images/f2dc9222-2289-4c11-9587-375b2369f9a5_1638006460.8124442.png)\\n\\n```java\\npublic class MaxSumBSTinBTOptimal {\\n    int maxsum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        postorder(root);\\n        return maxsum;\\n    }\\n\\n    private int[] postorder(TreeNode root) {\\n        if(root == null)\\n            return new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE, 0}; // {min, max, sum}\\n\\n        // postorder -> Left Right Root\\n        int[] leftTree = postorder(root.left);\\n        int[] rightTree = postorder(root.right);\\n\\n        if(leftTree == null ||\\n                rightTree == null ||\\n                root.val <= leftTree[1] ||\\n                root.val >= rightTree[0]\\n        ) {\\n            return null;\\n        }\\n\\n        int sum = root.val + leftTree[2] + rightTree[2];\\n        maxsum = Math.max(maxsum, sum);\\n\\n        int max = Math.max(root.val, rightTree[1]);\\n        int min = Math.min(root.val, leftTree[0]);\\n\\n        return new int[]{min, max, sum};\\n    }\\n}\\n```\\n\\n**Explanation**\\nIn this solution we do a postorder traversal which is (Left -> Right -> Root) \\n\\nStep by step definition of algorithm goes as follow:-\\n- the array which is returned from postorder function contains 3 values, minimum from right subtree, maximum from left subtree, and sum of nodes in tree.\\n\\n```java\\nif(leftTree == null ||\\n\\t\\trightTree == null ||\\n\\t\\troot.val <= leftTree[1] ||\\n\\t\\troot.val >= rightTree[0]\\n) {\\n\\treturn null;\\n}\\n```\\n- This says that if either left subtree is not bst or right subtree is not a bst or root.val is less than maximum of left tree or greater than min from right then return null.\\n\\n- Then we calculate sum, min and max along with updating maxsum.\\n- then we return an array containing all 3.\\n\\nHope it helps\\nDo upvote and smile\\nThanks",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic class MaxSumBSTinBT {\\n    int maxsum = 0;\\n    public int maxSumBSTBrute(TreeNode root) {\\n        if(root == null) return 0;\\n\\n        if(isValidBST(root))\\n            maxsum = Math.max(maxsum, sumTree(root));\\n\\n        maxSumBSTBrute(root.left);\\n        maxSumBSTBrute(root.right);\\n\\n        return maxsum;\\n    }\\n\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBSTUtil(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    private boolean isValidBSTUtil(TreeNode root, long minRange, long maxRange) {\\n        if(root == null) return true;\\n\\n        if(root.val <= minRange || root.val >= maxRange) return false;\\n\\n        return isValidBSTUtil(root.left, minRange, root.val) && isValidBSTUtil(root.right, root.val, maxRange);\\n    }\\n\\n    public int sumTree(TreeNode root) {\\n        if(root == null) return 0;\\n\\n        return root.val + sumTree(root.left) + sumTree(root.right);\\n    }\\n}\\n```\n```java\\npublic class MaxSumBSTinBTBetter {\\n    int maxsum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n\\n        boolean isBST = isValidBST(root);\\n        int[] sumAndNeg = new int[2];\\n        sumAndNeg = sumTree(root, sumAndNeg);\\n\\n        if(isBST)\\n            maxsum = Math.max(maxsum, sumAndNeg[0]);\\n\\n        if(!isBST || sumAndNeg[1] == 1) {\\n            maxSumBST(root.left);\\n            maxSumBST(root.right);\\n        }\\n\\n        return maxsum;\\n    }\\n\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBSTUtil(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    private boolean isValidBSTUtil(TreeNode root, long minRange, long maxRange) {\\n        if(root == null) return true;\\n\\n        if(root.val <= minRange || root.val >= maxRange) return false;\\n\\n        return isValidBSTUtil(root.left, minRange, root.val) && isValidBSTUtil(root.right, root.val, maxRange);\\n    }\\n\\n    public int[] sumTree(TreeNode root, int[] arr) {\\n        if(root == null) return new int[]{0, arr[1]};\\n\\n        if(root.val < 0) {\\n            arr[1] = 1;\\n        }\\n        arr[0] = root.val + sumTree(root.left, arr)[0] + sumTree(root.right, arr)[0];\\n        return arr;\\n    }\\n}\\n```\n```java\\npublic class MaxSumBSTinBTOptimal {\\n    int maxsum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        postorder(root);\\n        return maxsum;\\n    }\\n\\n    private int[] postorder(TreeNode root) {\\n        if(root == null)\\n            return new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE, 0}; // {min, max, sum}\\n\\n        // postorder -> Left Right Root\\n        int[] leftTree = postorder(root.left);\\n        int[] rightTree = postorder(root.right);\\n\\n        if(leftTree == null ||\\n                rightTree == null ||\\n                root.val <= leftTree[1] ||\\n                root.val >= rightTree[0]\\n        ) {\\n            return null;\\n        }\\n\\n        int sum = root.val + leftTree[2] + rightTree[2];\\n        maxsum = Math.max(maxsum, sum);\\n\\n        int max = Math.max(root.val, rightTree[1]);\\n        int min = Math.min(root.val, leftTree[0]);\\n\\n        return new int[]{min, max, sum};\\n    }\\n}\\n```\n```java\\nif(leftTree == null ||\\n\\t\\trightTree == null ||\\n\\t\\troot.val <= leftTree[1] ||\\n\\t\\troot.val >= rightTree[0]\\n) {\\n\\treturn null;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897682,
                "title": "java-easy-to-understand-code",
                "content": "Hi, This code is self explanatory! Do Upvote if u like it.\\nAlso this can be used to find the maximum size of BST present in a binary tree with a slight modification.\\n\\n```\\nclass Solution {\\n    int maxSum = 0;  //maxSum initialized to maintain it at every step and made global so no need to pass in function\\n    class NodePair{ /// this class will be viewed as a single node of tree\\n        int min, max, sum;\\n    }\\n    public NodePair getSum(TreeNode root){\\n        if(root == null){  // if null then return sum 0 and minimum value as Int max and max value as Int min\\n            NodePair a = new NodePair();\\n            a.min = Integer.MAX_VALUE;\\n            a.max = Integer.MIN_VALUE;\\n            a.sum = 0;\\n            return a;\\n        }\\n        NodePair main = new NodePair();\\n        NodePair left = getSum(root.left);  //recursion till leftmost node\\n        NodePair right = getSum(root.right);  //recursion till rightmost node\\n        \\n        if(left.max < root.val && root.val < right.min){  //validating the bst\\n            main.min = Math.min(root.val, Math.min(left.min, right.min));\\n            main.max = Math.max(root.val, Math.max(left.max, right.max));\\n            main.sum = root.val + left.sum + right.sum;\\n            maxSum = Math.max(maxSum,main.sum);\\n        }\\n        else{\\n            main.min = Integer.MIN_VALUE;  // if not bst then just pass the sum calculated as of now\\n            main.max = Integer.MAX_VALUE;\\n            main.sum = Math.max(left.sum,right.sum);\\n        }\\n        return main;\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        NodePair temp = new NodePair();\\n        temp = getSum(root);\\n        return maxSum > 0 ? maxSum : 0;\\n    }\\n}\\n```\\n\\nThis is the code to find the size of maximum BST :\\n\\n```\\nclass Solution {\\n    class NodePair{ /// this class will be viewed as a single node of tree\\n        int min, max, size;\\n    }\\n    public NodePair getSize(TreeNode root){\\n        if(root == null){  // if null then return size 0 and minimum value as Int max and max value as Int min\\n            NodePair a = new NodePair();\\n            a.min = Integer.MAX_VALUE;\\n            a.max = Integer.MIN_VALUE;\\n            a.size = 0;\\n            return a;\\n        }\\n        NodePair main = new NodePair();\\n        NodePair left = getSize(root.left);  //recursion till leftmost node\\n        NodePair right = getSize(root.right);  //recursion till rightmost node\\n        \\n        if(left.max < root.val && root.val < right.min){  //validating the bst\\n            main.min = Math.min(root.val, Math.min(left.min, right.min));\\n            main.max = Math.max(root.val, Math.max(left.max, right.max));\\n            main.size = 1 + left.size + right.size;\\n        }\\n        else{\\n            main.min = Integer.MIN_VALUE;  // if not bst then just pass the size calculated as of now\\n            main.max = Integer.MAX_VALUE;\\n            main.size = Math.max(left.size,right.size);\\n        }\\n        return main;\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        return getSize(root).size;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int maxSum = 0;  //maxSum initialized to maintain it at every step and made global so no need to pass in function\\n    class NodePair{ /// this class will be viewed as a single node of tree\\n        int min, max, sum;\\n    }\\n    public NodePair getSum(TreeNode root){\\n        if(root == null){  // if null then return sum 0 and minimum value as Int max and max value as Int min\\n            NodePair a = new NodePair();\\n            a.min = Integer.MAX_VALUE;\\n            a.max = Integer.MIN_VALUE;\\n            a.sum = 0;\\n            return a;\\n        }\\n        NodePair main = new NodePair();\\n        NodePair left = getSum(root.left);  //recursion till leftmost node\\n        NodePair right = getSum(root.right);  //recursion till rightmost node\\n        \\n        if(left.max < root.val && root.val < right.min){  //validating the bst\\n            main.min = Math.min(root.val, Math.min(left.min, right.min));\\n            main.max = Math.max(root.val, Math.max(left.max, right.max));\\n            main.sum = root.val + left.sum + right.sum;\\n            maxSum = Math.max(maxSum,main.sum);\\n        }\\n        else{\\n            main.min = Integer.MIN_VALUE;  // if not bst then just pass the sum calculated as of now\\n            main.max = Integer.MAX_VALUE;\\n            main.sum = Math.max(left.sum,right.sum);\\n        }\\n        return main;\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        NodePair temp = new NodePair();\\n        temp = getSum(root);\\n        return maxSum > 0 ? maxSum : 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    class NodePair{ /// this class will be viewed as a single node of tree\\n        int min, max, size;\\n    }\\n    public NodePair getSize(TreeNode root){\\n        if(root == null){  // if null then return size 0 and minimum value as Int max and max value as Int min\\n            NodePair a = new NodePair();\\n            a.min = Integer.MAX_VALUE;\\n            a.max = Integer.MIN_VALUE;\\n            a.size = 0;\\n            return a;\\n        }\\n        NodePair main = new NodePair();\\n        NodePair left = getSize(root.left);  //recursion till leftmost node\\n        NodePair right = getSize(root.right);  //recursion till rightmost node\\n        \\n        if(left.max < root.val && root.val < right.min){  //validating the bst\\n            main.min = Math.min(root.val, Math.min(left.min, right.min));\\n            main.max = Math.max(root.val, Math.max(left.max, right.max));\\n            main.size = 1 + left.size + right.size;\\n        }\\n        else{\\n            main.min = Integer.MIN_VALUE;  // if not bst then just pass the size calculated as of now\\n            main.max = Integer.MAX_VALUE;\\n            main.size = Math.max(left.size,right.size);\\n        }\\n        return main;\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        return getSize(root).size;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549773,
                "title": "well-commented-c-solution-intuitive-but-efficient-solution",
                "content": "Intuitive solution which handles all cases well.\\n\\n```\\nclass Solution {\\npublic:\\n \\n//ans will store our final ans     \\nint ans =0;\\n\\nstruct str{\\n    int stn; // Sum till now of the present node value and it\\'s left and right subtree \\n    int max; // Min value in subtree \\n    int min; // Max value in subtree \\n    int ans; // Sum of largest BST which which is a subtree of the present node \\n    bool isBST; // If subtree is BST \\n}; \\n \\n  \\nstr util(TreeNode* root){\\n    \\n    //if root is NULL\\n    if (root == NULL) \\n        return {0, INT_MIN, INT_MAX, 0, true}; \\n    \\n    //if root is a leaf node\\n    if (root->left == NULL && root->right == NULL) \\n        return {root->val, root->val, root->val, root->val, true}; \\n \\n    //recurring for the left and right subtrees\\n    str lt = util(root->left); \\n    str rt = util(root->right); \\n    \\n    //create a structure to return the values for the current node\\n    str ret_cur; \\n    ret_cur.stn = (root->val + lt.stn + rt.stn);\\n    \\n    // If whole tree rooted under current root is BST\\n    if (lt.isBST && rt.isBST && lt.max < root->val && rt.min > root->val) {\\n        \\n        //update the max and the min for the present node\\n        ret_cur.min = min(lt.min, root->val); \\n        ret_cur.max = max(rt.max, root->val); \\n        \\n        //update answer for tree rooted under current \\'root\\' \\n        ret_cur.ans = ret_cur.stn; \\n        ret_cur.isBST = true; \\n        \\n        //update the overall final ans\\n        ans = max(ans, ret_cur.ans);\\n        \\n        //return the ret_cur to the calling function\\n        return ret_cur;\\n        \\n    }\\n   \\n    //if whole tree is not BST, return maximum of left and right subtrees \\n    ret_cur.ans = max(lt.ans, rt.ans);\\n    \\n    //update the overall final ans\\n    ans = max(ret_cur.ans,ans);\\n    \\n    //since the tree rooted with the current node is not a  BST\\n    ret_cur.isBST = false; \\n  \\n    //return the ret_cur\\n    return ret_cur; \\n} \\n\\n    \\n    \\nint maxSumBST(TreeNode* root) {\\n    //return 0 for the base case when the given tree is NULL\\n    if(root==NULL)\\n\\t    return 0;\\n    return max(ans,util(root).ans);\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n \\n//ans will store our final ans     \\nint ans =0;\\n\\nstruct str{\\n    int stn; // Sum till now of the present node value and it\\'s left and right subtree \\n    int max; // Min value in subtree \\n    int min; // Max value in subtree \\n    int ans; // Sum of largest BST which which is a subtree of the present node \\n    bool isBST; // If subtree is BST \\n}; \\n \\n  \\nstr util(TreeNode* root){\\n    \\n    //if root is NULL\\n    if (root == NULL) \\n        return {0, INT_MIN, INT_MAX, 0, true}; \\n    \\n    //if root is a leaf node\\n    if (root->left == NULL && root->right == NULL) \\n        return {root->val, root->val, root->val, root->val, true}; \\n \\n    //recurring for the left and right subtrees\\n    str lt = util(root->left); \\n    str rt = util(root->right); \\n    \\n    //create a structure to return the values for the current node\\n    str ret_cur; \\n    ret_cur.stn = (root->val + lt.stn + rt.stn);\\n    \\n    // If whole tree rooted under current root is BST\\n    if (lt.isBST && rt.isBST && lt.max < root->val && rt.min > root->val) {\\n        \\n        //update the max and the min for the present node\\n        ret_cur.min = min(lt.min, root->val); \\n        ret_cur.max = max(rt.max, root->val); \\n        \\n        //update answer for tree rooted under current \\'root\\' \\n        ret_cur.ans = ret_cur.stn; \\n        ret_cur.isBST = true; \\n        \\n        //update the overall final ans\\n        ans = max(ans, ret_cur.ans);\\n        \\n        //return the ret_cur to the calling function\\n        return ret_cur;\\n        \\n    }\\n   \\n    //if whole tree is not BST, return maximum of left and right subtrees \\n    ret_cur.ans = max(lt.ans, rt.ans);\\n    \\n    //update the overall final ans\\n    ans = max(ret_cur.ans,ans);\\n    \\n    //since the tree rooted with the current node is not a  BST\\n    ret_cur.isBST = false; \\n  \\n    //return the ret_cur\\n    return ret_cur; \\n} \\n\\n    \\n    \\nint maxSumBST(TreeNode* root) {\\n    //return 0 for the base case when the given tree is NULL\\n    if(root==NULL)\\n\\t    return 0;\\n    return max(ans,util(root).ans);\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406626,
                "title": "c-most-detailed-explaination-each-line-of-code-explained",
                "content": "## Approach\\n--> we will start from `leaf nodes` and for any node we will first find answer for it\\'s children means it\\'s `left and right nodes` so for that we need a traversal technique which will first find answer for left and right and then for root. so this traversal is `Post order(left -> right -> root)`.\\n\\nNow we know 2 things till now:\\n\\n```\\n1. we will start from leaf nodes\\n2. we will use postorder\\n```\\n\\n==> Now first we have to check if any subtree is valid BST or not and for that any node have to satisfy these 2 conditions:\\n\\n```\\n1. Current node\\'s value must be greater than maximum value in it\\'s left subtree\\n2. Current node\\'s value must be smaller than minimum value in it\\'s right subtree\\n```\\n\\n--> Now for each node we will store `4` things:\\n\\n```\\n1. If it\\'s subtree(Including that node itself) is BST or not\\n2. Max sum till now\\n3. minimum value in that tree\\n4. maximum value in that tree\\n```\\n\\n--> Now the question is how we can store these values?\\n\\nSo we can use `pair` or we can use `Class` or `struct` so store these 4 values for each node.\\n\\nThe class will look like this:\\n\\n```cpp\\nclass Info {\\n    public:\\n        int ms; // maximum sum till now\\n        int mini; // minimum value in tree\\n        int maxi; // maximum value in tree\\n        bool isbst; // true if current tree is bst or false.\\n        // default values\\n        Info(){\\n            ms = 0;\\n            mini = INT_MAX;\\n            maxi = INT_MIN;\\n            isbst = true;\\n        }\\n};\\n```\\n\\nNow for each node, we will first find answers for it\\'s left and right subtree (In postorder manner).\\n\\n```cpp\\nInfo node;\\nInfo nodeleft = solve(root->left);\\nInfo noderight = solve(root->right);\\n```\\n\\nNow we have answers for it\\'s left and right subtree now we just have to check if `The subtree is BST including the current node` and we already know the conditions:\\n\\n```\\n1. nodeleft.isbst must be true\\n2. noderight.isbst must be true\\n3. the max value of leftsubtree i.e. nodeleft.maxi must be lower than root->val\\n4. the min value of rightsubtree i.e. noderight.mini must be greater than root->val\\n```\\n\\nIf it satisfies all 4 conditions then we know that `it\\'s a BST`. so we will add `root->val` in `nodeleft.ms + noderight.ms` which will be total sum of this tree.\\n\\n- `node.mini` will be minimum value of `root->val` and `nodeleft.mini`\\n- `node.maxi` will be maximum value of `root->val` and `noderight.maxi`\\n\\nLet\\'s see this part in code:\\n\\n```cpp\\nif(nodeleft.isbst && noderight.isbst && root->val > nodeleft.maxi && root->val < noderight.mini){\\n\\tnode.isbst = true;\\n\\tnode.ms = root->val + nodeleft.ms + noderight.ms;\\n\\tnode.mini = min(root->val,nodeleft.mini);\\n\\tnode.maxi = max(root->val,noderight.maxi);\\n}\\n```\\n\\n--> Now if the above conditions is false then we will mark `node.isbst` as false but `node.ms` will be maximum of `nodeleft.ms and noderight.ms` because we might found any answer in any one of the subtree so we will **not** reset it.\\n\\n```cpp\\nelse{\\n\\tnode.isbst = false;\\n\\tnode.ms = max(nodeleft.ms,noderight.ms);\\n}\\n```\\n\\n>Remember that node.mini and node.maxi will not be changed in this case so it will have the default values which are `INT_MAX` and `INT_MIN`.\\n\\n--> At last maintain one global variable `ans` which will be our final answer and modify our ans and return `node`.\\n\\n```cpp\\nans = max(ans,node.ms);\\nreturn node;\\n```\\n\\n---\\n\\n--> So now let\\'s see the full code:\\n\\n## Final Code:\\n\\n```cpp\\nclass Info {\\n    public:\\n        int ms;\\n        int mini;\\n        int maxi;\\n        bool isbst;\\n        Info(){\\n            ms = 0;\\n            mini = INT_MAX;\\n            maxi = INT_MIN;\\n            isbst = true;\\n        }\\n};\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    Info solve(TreeNode* root){\\n        if(root == NULL){\\n            return Info();\\n        }      \\n        Info node;\\n        Info nodeleft = solve(root->left);\\n        Info noderight = solve(root->right);\\n        if(nodeleft.isbst && noderight.isbst && root->val > nodeleft.maxi && root->val < noderight.mini){\\n            node.isbst = true;\\n            node.ms = root->val + nodeleft.ms + noderight.ms;\\n            node.mini = min(root->val,nodeleft.mini);\\n            node.maxi = max(root->val,noderight.maxi);\\n        }\\n        else{\\n            node.isbst = false;\\n            node.ms = max(nodeleft.ms,noderight.ms);\\n        }\\n        ans = max(ans,node.ms);\\n        return node;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n    }\\n```\\n---\\n\\nIf you liked this explaination then please upvote \\uD83D\\uDE00 and if you want more explainations like this then checkout it [here](https://github.com/shivam1317/DSA-Notes).\\n\\nThanks for reading.",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n1. we will start from leaf nodes\\n2. we will use postorder\\n```\n```\\n1. Current node\\'s value must be greater than maximum value in it\\'s left subtree\\n2. Current node\\'s value must be smaller than minimum value in it\\'s right subtree\\n```\n```\\n1. If it\\'s subtree(Including that node itself) is BST or not\\n2. Max sum till now\\n3. minimum value in that tree\\n4. maximum value in that tree\\n```\n```cpp\\nclass Info {\\n    public:\\n        int ms; // maximum sum till now\\n        int mini; // minimum value in tree\\n        int maxi; // maximum value in tree\\n        bool isbst; // true if current tree is bst or false.\\n        // default values\\n        Info(){\\n            ms = 0;\\n            mini = INT_MAX;\\n            maxi = INT_MIN;\\n            isbst = true;\\n        }\\n};\\n```\n```cpp\\nInfo node;\\nInfo nodeleft = solve(root->left);\\nInfo noderight = solve(root->right);\\n```\n```\\n1. nodeleft.isbst must be true\\n2. noderight.isbst must be true\\n3. the max value of leftsubtree i.e. nodeleft.maxi must be lower than root->val\\n4. the min value of rightsubtree i.e. noderight.mini must be greater than root->val\\n```\n```cpp\\nif(nodeleft.isbst && noderight.isbst && root->val > nodeleft.maxi && root->val < noderight.mini){\\n\\tnode.isbst = true;\\n\\tnode.ms = root->val + nodeleft.ms + noderight.ms;\\n\\tnode.mini = min(root->val,nodeleft.mini);\\n\\tnode.maxi = max(root->val,noderight.maxi);\\n}\\n```\n```cpp\\nelse{\\n\\tnode.isbst = false;\\n\\tnode.ms = max(nodeleft.ms,noderight.ms);\\n}\\n```\n```cpp\\nans = max(ans,node.ms);\\nreturn node;\\n```\n```cpp\\nclass Info {\\n    public:\\n        int ms;\\n        int mini;\\n        int maxi;\\n        bool isbst;\\n        Info(){\\n            ms = 0;\\n            mini = INT_MAX;\\n            maxi = INT_MIN;\\n            isbst = true;\\n        }\\n};\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    Info solve(TreeNode* root){\\n        if(root == NULL){\\n            return Info();\\n        }      \\n        Info node;\\n        Info nodeleft = solve(root->left);\\n        Info noderight = solve(root->right);\\n        if(nodeleft.isbst && noderight.isbst && root->val > nodeleft.maxi && root->val < noderight.mini){\\n            node.isbst = true;\\n            node.ms = root->val + nodeleft.ms + noderight.ms;\\n            node.mini = min(root->val,nodeleft.mini);\\n            node.maxi = max(root->val,noderight.maxi);\\n        }\\n        else{\\n            node.isbst = false;\\n            node.ms = max(nodeleft.ms,noderight.ms);\\n        }\\n        ans = max(ans,node.ms);\\n        return node;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245609,
                "title": "c-simple-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\t// here mx and mn are used to find minimum and maximum node in the current subtree\\n\\t// function return the sum of nodes of the subtree.\\n\\t\\n    int rec(TreeNode *root,int &mx,int &mn,int &a)\\n    {\\n        if(!root) return 0;\\n        \\n\\t// lmn,lmx will find the minimum and maximum node in the left subtree \\n\\t// similarly, rmn,rmx will find minimum and maximum node in the right subtree\\n\\t\\t\\n        int lmn,rmn,rmx,lmx;\\n        \\n        lmn=rmn=INT_MAX;\\n        lmx=rmx=INT_MIN;\\n\\t\\t\\n        int l=rec(root->left,lmx,lmn,a);\\n        int r=rec(root->right,rmx,rmn,a);\\n        \\n        int val=l+r+root->val;\\n    \\n\\t// if the left maximum is less than and right minimum is greater than current node\\n\\t// than the subtree rooted at current node is BST.\\n\\t\\t\\n        if((lmx<(root->val)) and (rmn>(root->val)))\\n        {\\n            a=max(a,val);\\n            mx=max(root->val,rmx);\\n            mn=min(root->val,lmn);\\n        }\\n        else\\n        {\\n            mx=INT_MAX;\\n            mn=INT_MIN;\\n        }\\n        return val;        \\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        int a=0;\\n        int mx=INT_MIN,mn=INT_MAX;\\n        rec(root,mx,mn,a);\\n        return a;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n*  Time - O(n)\\n*  Space - O(h) , h is height of tree\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// here mx and mn are used to find minimum and maximum node in the current subtree\\n\\t// function return the sum of nodes of the subtree.\\n\\t\\n    int rec(TreeNode *root,int &mx,int &mn,int &a)\\n    {\\n        if(!root) return 0;\\n        \\n\\t// lmn,lmx will find the minimum and maximum node in the left subtree \\n\\t// similarly, rmn,rmx will find minimum and maximum node in the right subtree\\n\\t\\t\\n        int lmn,rmn,rmx,lmx;\\n        \\n        lmn=rmn=INT_MAX;\\n        lmx=rmx=INT_MIN;\\n\\t\\t\\n        int l=rec(root->left,lmx,lmn,a);\\n        int r=rec(root->right,rmx,rmn,a);\\n        \\n        int val=l+r+root->val;\\n    \\n\\t// if the left maximum is less than and right minimum is greater than current node\\n\\t// than the subtree rooted at current node is BST.\\n\\t\\t\\n        if((lmx<(root->val)) and (rmn>(root->val)))\\n        {\\n            a=max(a,val);\\n            mx=max(root->val,rmx);\\n            mn=min(root->val,lmn);\\n        }\\n        else\\n        {\\n            mx=INT_MAX;\\n            mn=INT_MIN;\\n        }\\n        return val;        \\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        int a=0;\\n        int mx=INT_MIN,mn=INT_MAX;\\n        rec(root,mx,mn,a);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684444,
                "title": "java-simple-dfs-use-output-class",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    public class Output{\\n        boolean bst;\\n        int sum, min, max;\\n        public Output(boolean bst, int sum, int min, int max) {\\n            this.bst = bst;\\n            this.sum = sum;\\n            this.min = min;\\n            this.max = max;\\n        }\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root);\\n        return res;\\n    }\\n    \\n    private Output dfs(TreeNode node) {\\n        boolean isBST = false;\\n        int sum = 0, min = 0, max = 0;\\n        if (node.left == null && node.right == null) {\\n            res = Math.max(res, node.val);\\n            return new Output(true, node.val, node.val, node.val);\\n        }\\n        if (node.left == null) {\\n            Output right = dfs(node.right);\\n            isBST = right.bst && node.val < right.min;\\n            if (isBST) res = Math.max(res, node.val + right.sum);\\n            return new Output(isBST, node.val + right.sum, node.val, right.max);\\n        }\\n        \\n        if (node.right == null) {\\n            Output left = dfs(node.left);\\n            isBST = left.bst && node.val > left.max;\\n            if (isBST) res = Math.max(res, node.val + left.sum);\\n            return new Output(isBST, node.val + left.sum, left.min, node.val);\\n        }\\n        \\n        Output left = dfs(node.left), right = dfs(node.right);\\n        isBST = left.bst && right.bst && node.val > left.max && node.val < right.min;\\n        if (isBST) res = Math.max(res, node.val + left.sum + right.sum);\\n        return new Output(isBST, node.val + left.sum + right.sum, left.min, right.max);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public class Output{\\n        boolean bst;\\n        int sum, min, max;\\n        public Output(boolean bst, int sum, int min, int max) {\\n            this.bst = bst;\\n            this.sum = sum;\\n            this.min = min;\\n            this.max = max;\\n        }\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root);\\n        return res;\\n    }\\n    \\n    private Output dfs(TreeNode node) {\\n        boolean isBST = false;\\n        int sum = 0, min = 0, max = 0;\\n        if (node.left == null && node.right == null) {\\n            res = Math.max(res, node.val);\\n            return new Output(true, node.val, node.val, node.val);\\n        }\\n        if (node.left == null) {\\n            Output right = dfs(node.right);\\n            isBST = right.bst && node.val < right.min;\\n            if (isBST) res = Math.max(res, node.val + right.sum);\\n            return new Output(isBST, node.val + right.sum, node.val, right.max);\\n        }\\n        \\n        if (node.right == null) {\\n            Output left = dfs(node.left);\\n            isBST = left.bst && node.val > left.max;\\n            if (isBST) res = Math.max(res, node.val + left.sum);\\n            return new Output(isBST, node.val + left.sum, left.min, node.val);\\n        }\\n        \\n        Output left = dfs(node.left), right = dfs(node.right);\\n        isBST = left.bst && right.bst && node.val > left.max && node.val < right.min;\\n        if (isBST) res = Math.max(res, node.val + left.sum + right.sum);\\n        return new Output(isBST, node.val + left.sum + right.sum, left.min, right.max);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 571513,
                "title": "python-recursion-easy-to-understand",
                "content": "```python\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        self.ans = 0\\n        \\n        def maxSum(root):\\n            if not root:\\n                return True, [float(\\'inf\\'), float(\\'-inf\\')], 0\\n            \\n            l, l_range, l_sum = maxSum(root.left)\\n            r, r_range, r_sum = maxSum(root.right)\\n            \\n            if l and r and l_range[1] < root.val < r_range[0]:\\n                total = l_sum + r_sum + root.val\\n                self.ans = max(self.ans, total)\\n                return True, [min(l_range[0], root.val), max(r_range[1], root.val)], total\\n            \\n            return False, [float(\\'inf\\'), float(\\'-inf\\')], None\\n        \\n        _, __, ___ = maxSum(root)\\n        return self.ans\\n```\\n\\nuse bottom-up way to return a bool to indicate if subtree is valid bst and a range and sum of the subtree.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        self.ans = 0\\n        \\n        def maxSum(root):\\n            if not root:\\n                return True, [float(\\'inf\\'), float(\\'-inf\\')], 0\\n            \\n            l, l_range, l_sum = maxSum(root.left)\\n            r, r_range, r_sum = maxSum(root.right)\\n            \\n            if l and r and l_range[1] < root.val < r_range[0]:\\n                total = l_sum + r_sum + root.val\\n                self.ans = max(self.ans, total)\\n                return True, [min(l_range[0], root.val), max(r_range[1], root.val)], total\\n            \\n            return False, [float(\\'inf\\'), float(\\'-inf\\')], None\\n        \\n        _, __, ___ = maxSum(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505666,
                "title": "c-easy-with-t-c-o-n-love-babbar-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck Left Subtree valid or not,\\nthen check right subtree is valid or not,\\nthen check maxLeft < root->data < minRight to confirm if it\\'s a BST\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need 3 variables of type int: maxi, mini, sum.\\nAnd 1 bool type: isBST\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\nclass info\\n{\\n    public: \\n    int maxi;\\n    int mini;\\n    bool isBST;\\n    int sum;\\n};\\n\\ninfo solve(TreeNode* root, int &ans)\\n{\\n    // base case\\n    if(root==NULL)\\n    {\\n        return {INT_MIN, INT_MAX, true, 0};\\n    }\\n\\n    info left=solve(root->left, ans);\\n    info right=solve(root->right, ans);\\n\\n    info currNode;\\n\\n    currNode.sum=left.sum + right.sum + root->val;\\n    currNode.maxi=max(root->val, right.maxi);\\n    currNode.mini=min(root->val, left.mini);\\n\\n    if(left.isBST && right.isBST && (root->val > left.maxi && root->val < right.mini))\\n    {\\n        currNode.isBST=true;\\n    }\\n    else\\n    {\\n        currNode.isBST=false;\\n    }\\n\\n    // answer update\\n    if(currNode.isBST)\\n    {\\n        ans=max(ans, currNode.sum);\\n    }\\n\\n    return currNode;\\n}\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n        int maxSum=0;\\n        info temp=solve(root, maxSum);\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\nclass info\\n{\\n    public: \\n    int maxi;\\n    int mini;\\n    bool isBST;\\n    int sum;\\n};\\n\\ninfo solve(TreeNode* root, int &ans)\\n{\\n    // base case\\n    if(root==NULL)\\n    {\\n        return {INT_MIN, INT_MAX, true, 0};\\n    }\\n\\n    info left=solve(root->left, ans);\\n    info right=solve(root->right, ans);\\n\\n    info currNode;\\n\\n    currNode.sum=left.sum + right.sum + root->val;\\n    currNode.maxi=max(root->val, right.maxi);\\n    currNode.mini=min(root->val, left.mini);\\n\\n    if(left.isBST && right.isBST && (root->val > left.maxi && root->val < right.mini))\\n    {\\n        currNode.isBST=true;\\n    }\\n    else\\n    {\\n        currNode.isBST=false;\\n    }\\n\\n    // answer update\\n    if(currNode.isBST)\\n    {\\n        ans=max(ans, currNode.sum);\\n    }\\n\\n    return currNode;\\n}\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n        int maxSum=0;\\n        info temp=solve(root, maxSum);\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297160,
                "title": "c-dfs-validate-binary-search-tree-extra-step-o-n",
                "content": "This is basically [98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/) with extra step of calculating the sum of each valid subtree.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        \\n        helper(root, ans);\\n        \\n        return ans;\\n    }\\n    \\n    tuple<int, int, int> helper(TreeNode* root, int& ans) { // min, max, sum\\n        if (not root) {\\n            // base case\\n            return {INT_MAX, INT_MIN, 0};\\n        }\\n        \\n        auto [leftMin, leftMax, leftSum] = helper(root->left, ans);\\n        auto [rightMin, rightMax, rightSum] = helper(root->right, ans);\\n        \\n        if (root->val > leftMax and root->val < rightMin) {\\n            // valid bst\\n            int sum = leftSum + root->val + rightSum;\\n            ans = max(ans, sum);\\n\\n            return {min(root->val, leftMin), max(root->val, rightMax), sum};\\n        }\\n        \\n        // invalid bst\\n        return {INT_MIN, INT_MAX, 0};\\n    }\\n};\\n```\\n\\nTime complexity - O(N).\\nSpace complexity - O(H).",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        \\n        helper(root, ans);\\n        \\n        return ans;\\n    }\\n    \\n    tuple<int, int, int> helper(TreeNode* root, int& ans) { // min, max, sum\\n        if (not root) {\\n            // base case\\n            return {INT_MAX, INT_MIN, 0};\\n        }\\n        \\n        auto [leftMin, leftMax, leftSum] = helper(root->left, ans);\\n        auto [rightMin, rightMax, rightSum] = helper(root->right, ans);\\n        \\n        if (root->val > leftMax and root->val < rightMin) {\\n            // valid bst\\n            int sum = leftSum + root->val + rightSum;\\n            ans = max(ans, sum);\\n\\n            return {min(root->val, leftMin), max(root->val, rightMax), sum};\\n        }\\n        \\n        // invalid bst\\n        return {INT_MIN, INT_MAX, 0};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531967,
                "title": "python-easy-to-understand-recursive-solution",
                "content": "The code is straightforward. Key is to accumulate the sum bottom-up and nullify the sum once the BST property is violated.\\n```python\\ndef maxSumBST(self, root: TreeNode) -> int:\\n    if not root:\\n        return 0\\n    self.s = 0\\n    def helper(cur):\\n        a, amin, amax = helper(cur.left) if cur.left else (0, float(\\'inf\\'), float(\\'-inf\\'))\\n        b, bmin, bmax = helper(cur.right) if cur.right else (0, float(\\'inf\\'), float(\\'-inf\\'))\\n        if a is not None and b is not None:\\n            if cur.val > amax and cur.val < bmin:\\n                s = cur.val + a + b\\n                self.s = max(self.s, s)\\n                return s, min(cur.val, amin), max(cur.val, bmax)\\n        return (None, None, None)\\n    helper(root)\\n    return self.s\\n```\\nVote up if you find this helpful, thanks!\\n\\n**Edit**: an issue suggested by [jesus805](https://leetcode.com/jesus805) in the original solution has been fixed.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef maxSumBST(self, root: TreeNode) -> int:\\n    if not root:\\n        return 0\\n    self.s = 0\\n    def helper(cur):\\n        a, amin, amax = helper(cur.left) if cur.left else (0, float(\\'inf\\'), float(\\'-inf\\'))\\n        b, bmin, bmax = helper(cur.right) if cur.right else (0, float(\\'inf\\'), float(\\'-inf\\'))\\n        if a is not None and b is not None:\\n            if cur.val > amax and cur.val < bmin:\\n                s = cur.val + a + b\\n                self.s = max(self.s, s)\\n                return s, min(cur.val, amin), max(cur.val, bmax)\\n        return (None, None, None)\\n    helper(root)\\n    return self.s\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1467928,
                "title": "recursion-c-post-order-traversal",
                "content": "```\\nclass DataNode{          // To keep track of min max value, sum of subtree below it and if subtree rooted at current node is BST or not.\\npublic:\\n    int minVal = INT_MAX;\\n    int maxVal = INT_MIN;\\n    int sum = 0;\\n    bool isBST = false;\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    int maxSum = 0;\\n    \\n    DataNode solve(TreeNode* root)\\n    {\\n        if(!root) return {INT_MAX, INT_MIN, 0, true};\\n        \\n        if(!root->left && !root->right)                  // If leaf node then return it as a BST\\n        {\\n            maxSum = max(maxSum, root->val);\\n            return {root->val, root->val, root->val, true};\\n        }\\n        \\n        DataNode left = solve(root->left);                 // Left node Data\\n        DataNode right = solve(root->right);           // Right node Data\\n      \\n        int sum = left.sum + right.sum + root->val;    // Sum of subtree rooted at current node\\n        bool isBST = false;\\n        \\n        if(left.maxVal < root->val && right.minVal > root->val && left.isBST && right.isBST)   // Check if current node is BST or not\\n        {   \\n            isBST = true;                // Mark it as true, i.e BST\\n            maxSum = max(maxSum, sum);       // Also find the maximum sum of subtree\\n        }\\n        \\n        return {min(root->val, left.minVal), max(root->val, right.maxVal), sum, isBST};\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        \\n        solve(root);\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass DataNode{          // To keep track of min max value, sum of subtree below it and if subtree rooted at current node is BST or not.\\npublic:\\n    int minVal = INT_MAX;\\n    int maxVal = INT_MIN;\\n    int sum = 0;\\n    bool isBST = false;\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    int maxSum = 0;\\n    \\n    DataNode solve(TreeNode* root)\\n    {\\n        if(!root) return {INT_MAX, INT_MIN, 0, true};\\n        \\n        if(!root->left && !root->right)                  // If leaf node then return it as a BST\\n        {\\n            maxSum = max(maxSum, root->val);\\n            return {root->val, root->val, root->val, true};\\n        }\\n        \\n        DataNode left = solve(root->left);                 // Left node Data\\n        DataNode right = solve(root->right);           // Right node Data\\n      \\n        int sum = left.sum + right.sum + root->val;    // Sum of subtree rooted at current node\\n        bool isBST = false;\\n        \\n        if(left.maxVal < root->val && right.minVal > root->val && left.isBST && right.isBST)   // Check if current node is BST or not\\n        {   \\n            isBST = true;                // Mark it as true, i.e BST\\n            maxSum = max(maxSum, sum);       // Also find the maximum sum of subtree\\n        }\\n        \\n        return {min(root->val, left.minVal), max(root->val, right.maxVal), sum, isBST};\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        \\n        solve(root);\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532019,
                "title": "python-post-order-checking-bst-and-sum-up-in-single-round-356-ms",
                "content": "Write an auxiliary function to recursively check if a tree rooted with node `r` is a BST, if it is, return True and the sum of the tree at the same time. Every time you get a valid tree sum, append it to the `res`.\\n\\nPlease note that in this problem, null nodes connected to the leaf nodes can also be considered as a valid node/subtree with sum 0. So example 3 returns 0 instead of any negative node.\\n\\n```py\\nclass Solution:\\n    def isBST(self, r):\\n        if not r:\\n            return True, 0\\n        is_left, left_sum = self.isBST(r.left)\\n        is_right, right_sum = self.isBST(r.right)\\n        if (r.left and r.left.val >= r.val) or (r.right and r.right.val <= r.val):\\n            return False, 0\\n        if is_left and is_right:\\n            s = left_sum + right_sum + r.val\\n            self.res.append(s)\\n            return True, s\\n        return False, 0\\n\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        self.res = []\\n        self.isBST(root)\\n        if self.res:\\n            return max(max(self.res), 0)\\n        else:\\n            return 0\\n```\\n\\n",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def isBST(self, r):\\n        if not r:\\n            return True, 0\\n        is_left, left_sum = self.isBST(r.left)\\n        is_right, right_sum = self.isBST(r.right)\\n        if (r.left and r.left.val >= r.val) or (r.right and r.right.val <= r.val):\\n            return False, 0\\n        if is_left and is_right:\\n            s = left_sum + right_sum + r.val\\n            self.res.append(s)\\n            return True, s\\n        return False, 0\\n\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        self.res = []\\n        self.isBST(root)\\n        if self.res:\\n            return max(max(self.res), 0)\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906030,
                "title": "c-recursive-post-order-traversal-using-object-oriented-programming-o-n",
                "content": "Hi all, \\nI solved this question using post order traversal which took TC- O(n). For mainitaining BST data, I have made a NodeData class which stores cumulative sum and cumulative maxSum for the valid BSTs. I tried applying OOP principles here. \\n\\nHave a look and do let me know in comments your thoughts.\\n```\\nclass NodeData{\\nprivate:\\n    int mini;\\n    int maxi;\\n    int sum;\\n    int maxSum;\\npublic:\\n    NodeData(int mini, int maxi, int sum, int maxSum){\\n        this->mini=mini;\\n        this->maxi=maxi;\\n        this->sum=sum;\\n        this->maxSum=maxSum;\\n    }\\n    int getsum(){\\n        return sum;\\n    }\\n    int getmaxi(){\\n        return maxi;\\n    }\\n    int getmini(){\\n        return mini;\\n    }\\n    int getmaxSum(){\\n        return maxSum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    NodeData maxBST(TreeNode* root){\\n        if(!root) return NodeData(INT_MAX,INT_MIN,0,INT_MIN);\\n        \\n        NodeData left = maxBST(root->left);\\n        NodeData right = maxBST(root->right);\\n        \\n        if(left.getmaxi() < root->val && right.getmini() > root->val){\\n            \\n            return NodeData(min(left.getmini(), root->val), max(right.getmaxi(), root->val), root->val + left.getsum() + right.getsum(), max(max(left.getmaxSum(), right.getmaxSum()), root->val + left.getsum() + right.getsum()));\\n            \\n        }\\n        return NodeData(INT_MIN, INT_MAX, max(left.getsum(), right.getsum()), max(left.getmaxSum(),right.getmaxSum()));\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans = maxBST(root).getmaxSum();\\n        return ans>=0?ans:0;\\n    }\\n};\\n```\\nCheers!",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass NodeData{\\nprivate:\\n    int mini;\\n    int maxi;\\n    int sum;\\n    int maxSum;\\npublic:\\n    NodeData(int mini, int maxi, int sum, int maxSum){\\n        this->mini=mini;\\n        this->maxi=maxi;\\n        this->sum=sum;\\n        this->maxSum=maxSum;\\n    }\\n    int getsum(){\\n        return sum;\\n    }\\n    int getmaxi(){\\n        return maxi;\\n    }\\n    int getmini(){\\n        return mini;\\n    }\\n    int getmaxSum(){\\n        return maxSum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    NodeData maxBST(TreeNode* root){\\n        if(!root) return NodeData(INT_MAX,INT_MIN,0,INT_MIN);\\n        \\n        NodeData left = maxBST(root->left);\\n        NodeData right = maxBST(root->right);\\n        \\n        if(left.getmaxi() < root->val && right.getmini() > root->val){\\n            \\n            return NodeData(min(left.getmini(), root->val), max(right.getmaxi(), root->val), root->val + left.getsum() + right.getsum(), max(max(left.getmaxSum(), right.getmaxSum()), root->val + left.getsum() + right.getsum()));\\n            \\n        }\\n        return NodeData(INT_MIN, INT_MAX, max(left.getsum(), right.getsum()), max(left.getmaxSum(),right.getmaxSum()));\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans = maxBST(root).getmaxSum();\\n        return ans>=0?ans:0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205564,
                "title": "python-intuitive-easy-to-understand-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/a830b6a4-b525-4ad0-b0a7-6c614f40f822_1656340808.9508603.jpeg)\\nread more : https://www.theconfusedtechie.com/post/maximum-sum-bst-in-binary-tree\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        # declaire a variable maxSum to hold the max path sum\\n        self.maxSum=0\\n        def getMax(root):\\n            # return max,min,val - if root is null, valid BST\\n            if not root : return (float(\"-inf\"),float(\"inf\"),0)\\n            # traverse left and right part\\n            leftMax,leftMin,leftMaxSum=getMax(root.left)\\n            rightMax,rightMin,rightMaxSum=getMax(root.right)\\n            # if a valid BST\\n            if root.val>leftMax and root.val<rightMin:\\n                # update maxSum\\n                self.maxSum=max(self.maxSum,root.val+leftMaxSum+rightMaxSum)\\n                # return maximum and minimum node values starting from that node and pathSum\\n                return max(root.val,rightMax),min(root.val,leftMin),root.val+leftMaxSum+rightMaxSum\\n            # if not a BST - set an impossible condition such than the root is also returned as non-BST\\n            return  (float(\"inf\"),float(\"-inf\"),0)\\n        getMax(root)    \\n        return self.maxSum\\n        \\n            \\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        # declaire a variable maxSum to hold the max path sum\\n        self.maxSum=0\\n        def getMax(root):\\n            # return max,min,val - if root is null, valid BST\\n            if not root : return (float(\"-inf\"),float(\"inf\"),0)\\n            # traverse left and right part\\n            leftMax,leftMin,leftMaxSum=getMax(root.left)\\n            rightMax,rightMin,rightMaxSum=getMax(root.right)\\n            # if a valid BST\\n            if root.val>leftMax and root.val<rightMin:\\n                # update maxSum\\n                self.maxSum=max(self.maxSum,root.val+leftMaxSum+rightMaxSum)\\n                # return maximum and minimum node values starting from that node and pathSum\\n                return max(root.val,rightMax),min(root.val,leftMin),root.val+leftMaxSum+rightMaxSum\\n            # if not a BST - set an impossible condition such than the root is also returned as non-BST\\n            return  (float(\"inf\"),float(\"-inf\"),0)\\n        getMax(root)    \\n        return self.maxSum\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520684,
                "title": "c-o-n",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\n\\n1.For tree rooted at particular node to be BST: \\n* Left Child is BST\\n* Right Child is BST\\n\\n2.Current node has to be BST itself:\\n* node value > max value in Left Child \\n* node value < min value in Right Child\\n\\t\\n```\\nclass Solution {\\npublic:\\n    \\n    struct pair{\\n        bool bst;\\n        int maxsum; // max sum possible till current root\\n        int sum,  minVal, maxVal; // current subtree info\\n        pair(bool check, int ms, int s, int min, int max){\\n            bst=check;\\n            maxsum=ms;\\n            sum=s;\\n            minVal=min;\\n            maxVal=max;\\n        }\\n    };\\n    \\n    struct pair solve(TreeNode* root){\\n        struct pair p={true,INT_MIN,0,INT_MAX,INT_MIN};\\n        if(root==NULL) return p;\\n        \\n        struct pair lp=solve(root->left);\\n        struct pair rp=solve(root->right);\\n        \\n        int val=root->val;\\n        \\n        bool isBST = (val > lp.maxVal && val < rp.minVal && lp.bst && rp.bst); // check if current node form BST\\n        \\n        int curMaxSum, curSum, curMin, curMax;\\n        if(isBST){\\n            curSum = lp.sum+rp.sum+val;\\n            curMaxSum = max(curSum,max(lp.maxsum,rp.maxsum));\\n            curMin = min(val,lp.minVal);\\n            curMax = max(val,rp.maxVal);\\n        }else{\\n            curSum=0;\\n            curMaxSum=max(lp.maxsum,rp.maxsum);\\n            curMin=INT_MIN;\\n            curMax=INT_MAX;\\n        }\\n        struct pair cur={isBST,curMaxSum,curSum,curMin,curMax};\\n        return cur;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        return max(0,solve(root).maxsum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct pair{\\n        bool bst;\\n        int maxsum; // max sum possible till current root\\n        int sum,  minVal, maxVal; // current subtree info\\n        pair(bool check, int ms, int s, int min, int max){\\n            bst=check;\\n            maxsum=ms;\\n            sum=s;\\n            minVal=min;\\n            maxVal=max;\\n        }\\n    };\\n    \\n    struct pair solve(TreeNode* root){\\n        struct pair p={true,INT_MIN,0,INT_MAX,INT_MIN};\\n        if(root==NULL) return p;\\n        \\n        struct pair lp=solve(root->left);\\n        struct pair rp=solve(root->right);\\n        \\n        int val=root->val;\\n        \\n        bool isBST = (val > lp.maxVal && val < rp.minVal && lp.bst && rp.bst); // check if current node form BST\\n        \\n        int curMaxSum, curSum, curMin, curMax;\\n        if(isBST){\\n            curSum = lp.sum+rp.sum+val;\\n            curMaxSum = max(curSum,max(lp.maxsum,rp.maxsum));\\n            curMin = min(val,lp.minVal);\\n            curMax = max(val,rp.maxVal);\\n        }else{\\n            curSum=0;\\n            curMaxSum=max(lp.maxsum,rp.maxsum);\\n            curMin=INT_MIN;\\n            curMax=INT_MAX;\\n        }\\n        struct pair cur={isBST,curMaxSum,curSum,curMin,curMax};\\n        return cur;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        return max(0,solve(root).maxsum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487927,
                "title": "python-dfs-the-most-standard-template-for-bottom-up",
                "content": "Please also use the same method (almost the same code with a little change) to solve Problem 333. Largest BST Subtree to test yourself whether you seize this methd.\\n\\n```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        \\n        def dfs(root):\\n\\t\\t\\n            if not root:\\n                return True, 0, float(\"inf\"), float(\"-inf\")\\n            \\n            lres, lsum, lmin, lmax = dfs(root.left)\\n            rres, rsum, rmin, rmax = dfs(root.right)\\n            \\n            if lres and rres and lmax < root.val < rmin:\\n                self.result = max(self.result, root.val+lsum+rsum)\\n                return True, root.val+lsum+rsum, min(root.val, lmin), max(root.val, rmax)\\n            else:\\n\\t\\t\\t\\t# it doesn\\'t matter which value here returns after False, \\n\\t\\t\\t\\t# since the code above \"if lres and rres...\" will assure that \\n\\t\\t\\t\\t# it will not run the FALSE subtree to affect the final result.\\n                return False, 0, 0, 0 \\n               \\n        self.result = 0\\n        dfs(root)\\n        return self.result\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        \\n        def dfs(root):\\n\\t\\t\\n            if not root:\\n                return True, 0, float(\"inf\"), float(\"-inf\")\\n            \\n            lres, lsum, lmin, lmax = dfs(root.left)\\n            rres, rsum, rmin, rmax = dfs(root.right)\\n            \\n            if lres and rres and lmax < root.val < rmin:\\n                self.result = max(self.result, root.val+lsum+rsum)\\n                return True, root.val+lsum+rsum, min(root.val, lmin), max(root.val, rmax)\\n            else:\\n\\t\\t\\t\\t# it doesn\\'t matter which value here returns after False, \\n\\t\\t\\t\\t# since the code above \"if lres and rres...\" will assure that \\n\\t\\t\\t\\t# it will not run the FALSE subtree to affect the final result.\\n                return False, 0, 0, 0 \\n               \\n        self.result = 0\\n        dfs(root)\\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117229,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<int> dfs(TreeNode* root){\\n        if(root==NULL){\\n            return {true,0,0,0}; //isBST-true, sum-0, minimum-0, maximum-0\\n        }\\n        vector<int> l(dfs(root->left));\\n        vector<int> r(dfs(root->right));\\n        if((l[0]==true && (root->left==NULL || root->val>l[3])) && (r[0]==true && (root->right==NULL || root->val<r[2]))){\\n            int s=root->val+l[1]+r[1];\\n            ans=max(ans,s);\\n            int mini=0,maxi=0;\\n            if(root->left==NULL)\\n                mini=root->val;\\n            else\\n                mini=l[2];\\n            if(root->right==NULL)\\n                maxi=root->val;\\n            else\\n                maxi=r[3];\\n            return {true,s,mini,maxi};\\n        }\\n        return {false,0,0,0};  \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<int> dfs(TreeNode* root){\\n        if(root==NULL){\\n            return {true,0,0,0}; //isBST-true, sum-0, minimum-0, maximum-0\\n        }\\n        vector<int> l(dfs(root->left));\\n        vector<int> r(dfs(root->right));\\n        if((l[0]==true && (root->left==NULL || root->val>l[3])) && (r[0]==true && (root->right==NULL || root->val<r[2]))){\\n            int s=root->val+l[1]+r[1];\\n            ans=max(ans,s);\\n            int mini=0,maxi=0;\\n            if(root->left==NULL)\\n                mini=root->val;\\n            else\\n                mini=l[2];\\n            if(root->right==NULL)\\n                maxi=root->val;\\n            else\\n                maxi=r[3];\\n            return {true,s,mini,maxi};\\n        }\\n        return {false,0,0,0};  \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839262,
                "title": "python-3-dfs-helper-which-return-bst-flag-sum-min-max-of-all-nodes-under-this-node",
                "content": "```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        self.ans = 0 #empty BST allowed\\n        def help(r):\\n            if not r:\\n                return True,0,math.inf,-math.inf # Note -infinity as upper bound and +infinity as lower bound\\n            \\n            isLeftBST,leftSum,leftMin,leftMax = help(r.left)           \\n            isRightBST,rightSum,rightMin,rightMax = help(r.right)\\n            \\n            if (isLeftBST and r.val>leftMax) and (isRightBST and r.val<rightMin):\\n                self.ans = max(self.ans,r.val+leftSum+rightSum) #update the global max\\n                return True, r.val+leftSum+rightSum, min(leftMin,r.val),max(rightMax,r.val)\\n            else:\\n                return False,-math.inf,0,0 #does not matter\\n        _,_,_,_ = help(root)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        self.ans = 0 #empty BST allowed\\n        def help(r):\\n            if not r:\\n                return True,0,math.inf,-math.inf # Note -infinity as upper bound and +infinity as lower bound\\n            \\n            isLeftBST,leftSum,leftMin,leftMax = help(r.left)           \\n            isRightBST,rightSum,rightMin,rightMax = help(r.right)\\n            \\n            if (isLeftBST and r.val>leftMax) and (isRightBST and r.val<rightMin):\\n                self.ans = max(self.ans,r.val+leftSum+rightSum) #update the global max\\n                return True, r.val+leftSum+rightSum, min(leftMin,r.val),max(rightMax,r.val)\\n            else:\\n                return False,-math.inf,0,0 #does not matter\\n        _,_,_,_ = help(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727311,
                "title": "java-simple-solution-o-n-time-o-1-space-with-explanation-and-comments",
                "content": "For each subtree to be BST, there needs to be min and max limits. \\nMax node in left subtree must be < root value, and root value must be > min node in right subtree. \\nOn a subtree that can\\'t meet the BST property, we need to set min to MIN_VALUE and max to MAX_VALUE to make sure its sum cannot contribute to the sum of its parent node.\\n```\\nclass Solution {\\n    int max = 0;\\n    public int maxSumBST(TreeNode root) {\\n        post(root);\\n        return max;\\n    }\\n    public int[] post(TreeNode root) {\\n        //int[]res = {min, max, sum}\\n        if (root == null) return new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE, 0};\\n        int[] left = post(root.left);\\n        int[] right = post(root.right);\\n        if (root.val > left[1] && root.val < right[0]) {//valid BST\\n            int[] res = new int[3];\\n            res[0] = Math.min(left[0], root.val);//update min\\n            res[1] = Math.max(right[1], root.val);//update max\\n            res[2] = root.val + left[2] + right[2];\\n            max = Math.max(max, res[2]);\\n            return res;\\n        }\\n        //not a valid BST, can\\'t let result be part of greater bst, so apply min/max\\n        return new int[]{Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int max = 0;\\n    public int maxSumBST(TreeNode root) {\\n        post(root);\\n        return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3908722,
                "title": "why-postorder-basic-approach-beginners-s-friendly-0-n-at-leaf-node",
                "content": "# Intuition\\nBasic recursion.\\nWe cant go to every node and and check for binary tree. The constains are very high, hence we need to go in one traversal and check for binary seach tree and calculate sum.\\n\\nNow at a node, we say it is bst only if it is greater than left and less than the right.\\nNow to check for left and right first and then the root.\\nWe can do a postorder traversal.\\nLeft-->Right-->Root\\n\\n# Approach\\nNow for postorder, lets say at leaf node, they are always a bst in themselves \\nwhen we get null, we return min value as INT_MAX and max value as INT_MIN. So when it gets at leaf it satisfiy for bst.\\nnow at evety node we just check for bst \\n\\nif BST-->we take sum of both left , right and root.\\n```\\nint sum=root->val+lt.sum+rt.sum;\\nreturn BST(sum,min(root->val,lt.mini),max(root->val,rt.maxi));\\n```\\n\\nif not BST-->we just take max of left and right as the current root doesnt form the bst.\\nso we just pass on the earlier max value of sub-BST.\\n```\\nreturn BST(max(lt.sum,rt.sum),INT_MIN,INT_MAX);\\n```\\n\\n# Complexity\\n- Time complexity:\\nWe just traverse the tree once and hence TC-> O(N)\\n\\n- Space complexity:\\nWe use another data structure BST\\nwhich take O(1) space but stack space is used\\nHence O(H) where H is height of tree\\n\\n# Code\\n```\\nclass BST {\\npublic:\\n    int sum;\\n    int mini;\\n    int maxi;\\n    BST(int sum=0,int mini=INT_MAX,int maxi=INT_MIN) {\\n        this->sum=sum;\\n        this->mini=mini;\\n        this->maxi=maxi;\\n    }\\n};\\nint ans=0;\\nBST helper(TreeNode *root) {\\n    if(!root)return BST(0,INT_MAX,INT_MIN);\\n    auto lt=helper(root->left);\\n    auto rt=helper(root->right);\\n    if(root->val>lt.maxi && root->val<rt.mini){\\n        int sum=root->val+lt.sum+rt.sum;\\n        ans=max(ans,sum);\\n        return BST(sum,min(root->val,lt.mini),max(root->val,rt.maxi));\\n    }\\n    return BST(max(lt.sum,rt.sum),INT_MIN,INT_MAX);\\n}\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nint sum=root->val+lt.sum+rt.sum;\\nreturn BST(sum,min(root->val,lt.mini),max(root->val,rt.maxi));\\n```\n```\\nreturn BST(max(lt.sum,rt.sum),INT_MIN,INT_MAX);\\n```\n```\\nclass BST {\\npublic:\\n    int sum;\\n    int mini;\\n    int maxi;\\n    BST(int sum=0,int mini=INT_MAX,int maxi=INT_MIN) {\\n        this->sum=sum;\\n        this->mini=mini;\\n        this->maxi=maxi;\\n    }\\n};\\nint ans=0;\\nBST helper(TreeNode *root) {\\n    if(!root)return BST(0,INT_MAX,INT_MIN);\\n    auto lt=helper(root->left);\\n    auto rt=helper(root->right);\\n    if(root->val>lt.maxi && root->val<rt.mini){\\n        int sum=root->val+lt.sum+rt.sum;\\n        ans=max(ans,sum);\\n        return BST(sum,min(root->val,lt.mini),max(root->val,rt.maxi));\\n    }\\n    return BST(max(lt.sum,rt.sum),INT_MIN,INT_MAX);\\n}\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267195,
                "title": "java-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\n    //Brute Force Approach:-\\n    //1. Validate the tree\\n        //1.a. if it is a BST, then calculate its sum\\n        //1.b. if it is not, then no need to calculate the sum\\n    //Time Complexity:- O(n^2) => O(n) for validity and O(n) for calculating sum\\n    //Therefore, it would give TLE\\n    \\n    //Optimised Approach:-\\n    //here we are trying to calculate the sum while checking the validity of the binary tree as BST\\n    //1. we have to check the left and right subtree before the root for BST check so we would do preorder traversal\\n    //2. for checking BST and to get the sum together, we need to get 4 things:\\n\\t\\t//is the tree BST, sum obtained till now, max value for the root to be BST, min value for the root to be BST\\n    //Time Complexity:- O(n) because we traverse the tree only once\\n    //now read the code carefully, it has been commented for better readibility\\n    \\n    //custom data structure which should be returned\\n    class Pair{\\n        boolean isBST;\\n        int sum;\\n        int max;\\n        int min;\\n        Pair(boolean _isBST,int _sum,int _max,int _min){\\n            isBST=_isBST;\\n            sum=_sum;\\n            max=_max;\\n            min=_min;\\n        }\\n        Pair(){\\n            isBST=false;\\n            sum=0;\\n            max=Integer.MIN_VALUE;\\n            min=Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    //keeps ultimate answer\\n    int res=0;\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        return res;\\n    }\\n    \\n    private Pair helper(TreeNode root){\\n        //an empty tree is a BST with sum 0 and max value=Integer.MIN_VALUE and min value=Integer.MAX_VALUE\\n        if(root==null){\\n            return new Pair(true,0,Integer.MIN_VALUE,Integer.MAX_VALUE);\\n        }\\n        \\n        //getting values from left subtree\\n        Pair l=helper(root.left);\\n        //getting values from right subtree\\n        Pair r=helper(root.right);\\n        \\n        //we would be returning this\\n        Pair ansret=new Pair();\\n        \\n        //checking if the tree is a BST\\n        //check if the root node is within the range \\n        //root.val should be greater than left subtree max value\\n        //root.val should be less than right subtree min value\\n        //and left and right subtrees should be BSTs\\n        if(root.val>l.max && root.val<r.min && l.isBST && r.isBST){\\n            ansret.isBST=true;\\n            ansret.sum=l.sum+r.sum+root.val;\\n            ansret.min=Math.min(root.val,l.min);\\n            ansret.max=Math.max(root.val,r.max);\\n            res=Math.max(res,ansret.sum);\\n        }\\n        //if the tree is not a BST\\n        //then we cannot develop any BST which is connected to this root\\n        //therefore put the value of max to Integer.MAX_VALUE and value of min to Integer.MIN_VALUE\\n        //so that no root value connecting this root satisfies the BST criteria\\n        else{\\n            ansret.isBST=false;\\n            ansret.sum=0;\\n            ansret.max=Integer.MAX_VALUE;\\n            ansret.min=Integer.MIN_VALUE;\\n        }\\n        return ansret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    //Brute Force Approach:-\\n    //1. Validate the tree\\n        //1.a. if it is a BST, then calculate its sum\\n        //1.b. if it is not, then no need to calculate the sum\\n    //Time Complexity:- O(n^2) => O(n) for validity and O(n) for calculating sum\\n    //Therefore, it would give TLE\\n    \\n    //Optimised Approach:-\\n    //here we are trying to calculate the sum while checking the validity of the binary tree as BST\\n    //1. we have to check the left and right subtree before the root for BST check so we would do preorder traversal\\n    //2. for checking BST and to get the sum together, we need to get 4 things:\\n\\t\\t//is the tree BST, sum obtained till now, max value for the root to be BST, min value for the root to be BST\\n    //Time Complexity:- O(n) because we traverse the tree only once\\n    //now read the code carefully, it has been commented for better readibility\\n    \\n    //custom data structure which should be returned\\n    class Pair{\\n        boolean isBST;\\n        int sum;\\n        int max;\\n        int min;\\n        Pair(boolean _isBST,int _sum,int _max,int _min){\\n            isBST=_isBST;\\n            sum=_sum;\\n            max=_max;\\n            min=_min;\\n        }\\n        Pair(){\\n            isBST=false;\\n            sum=0;\\n            max=Integer.MIN_VALUE;\\n            min=Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    //keeps ultimate answer\\n    int res=0;\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        return res;\\n    }\\n    \\n    private Pair helper(TreeNode root){\\n        //an empty tree is a BST with sum 0 and max value=Integer.MIN_VALUE and min value=Integer.MAX_VALUE\\n        if(root==null){\\n            return new Pair(true,0,Integer.MIN_VALUE,Integer.MAX_VALUE);\\n        }\\n        \\n        //getting values from left subtree\\n        Pair l=helper(root.left);\\n        //getting values from right subtree\\n        Pair r=helper(root.right);\\n        \\n        //we would be returning this\\n        Pair ansret=new Pair();\\n        \\n        //checking if the tree is a BST\\n        //check if the root node is within the range \\n        //root.val should be greater than left subtree max value\\n        //root.val should be less than right subtree min value\\n        //and left and right subtrees should be BSTs\\n        if(root.val>l.max && root.val<r.min && l.isBST && r.isBST){\\n            ansret.isBST=true;\\n            ansret.sum=l.sum+r.sum+root.val;\\n            ansret.min=Math.min(root.val,l.min);\\n            ansret.max=Math.max(root.val,r.max);\\n            res=Math.max(res,ansret.sum);\\n        }\\n        //if the tree is not a BST\\n        //then we cannot develop any BST which is connected to this root\\n        //therefore put the value of max to Integer.MAX_VALUE and value of min to Integer.MIN_VALUE\\n        //so that no root value connecting this root satisfies the BST criteria\\n        else{\\n            ansret.isBST=false;\\n            ansret.sum=0;\\n            ansret.max=Integer.MAX_VALUE;\\n            ansret.min=Integer.MIN_VALUE;\\n        }\\n        return ansret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228153,
                "title": "c-simple-recursion-solution",
                "content": "Acutally solution was easy, tough task was to check isBST in same recursion.....\\nHope you all understand the following solution.\\n```\\nclass Solution {\\npublic:\\n\\n    bool get_output(TreeNode * root, int & sum,int & part_sum, int & min_val, int & max_val){\\n        \\n\\n        \\n        if(root->left==NULL and root->right==NULL){\\n            part_sum = root->val;\\n            sum = max(sum,root->val);\\n            min_val = root->val;\\n            max_val = root->val;\\n            return true;\\n        }\\n        \\n        // other condition\\n        bool left_part = true, right_part= true;\\n        \\n        int left_part_sum=0, right_part_sum=0 ;\\n        int min_val1=INT_MAX,max_val1=INT_MIN ,min_val2=INT_MAX,max_val2=INT_MIN ;\\n        \\n        if(root->left)\\n            left_part = get_output(root->left,sum,left_part_sum,min_val1,max_val1);\\n        if(root->right)\\n            right_part = get_output(root->right,sum, right_part_sum,min_val2 ,max_val2);\\n        \\n        if(!left_part or !right_part){\\n            return false;\\n        }\\n        \\n        if(root->val<=max_val1 or root->val>=min_val2){\\n            return false;\\n        }\\n        \\n        min_val = min({root->val,min_val1,min_val2});\\n        max_val = max({root->val,max_val1,max_val2});        \\n        \\n        // update the condition\\n        sum = max(sum,left_part_sum+right_part_sum + root->val);\\n        \\n        part_sum = left_part_sum+ right_part_sum + root->val;\\n        \\n        return true;\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        \\n        // Base Case\\n        if(root==NULL){\\n            return 0;\\n        }\\n                \\n        int sum =INT_MIN;\\n        \\n        bool isValid= false;\\n        \\n\\n        int part_sum =0;\\n        int min_val,max_val;\\n        isValid = get_output(root,sum,part_sum,min_val,max_val);\\n        \\n        if(sum<0){\\n            return 0;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool get_output(TreeNode * root, int & sum,int & part_sum, int & min_val, int & max_val){\\n        \\n\\n        \\n        if(root->left==NULL and root->right==NULL){\\n            part_sum = root->val;\\n            sum = max(sum,root->val);\\n            min_val = root->val;\\n            max_val = root->val;\\n            return true;\\n        }\\n        \\n        // other condition\\n        bool left_part = true, right_part= true;\\n        \\n        int left_part_sum=0, right_part_sum=0 ;\\n        int min_val1=INT_MAX,max_val1=INT_MIN ,min_val2=INT_MAX,max_val2=INT_MIN ;\\n        \\n        if(root->left)\\n            left_part = get_output(root->left,sum,left_part_sum,min_val1,max_val1);\\n        if(root->right)\\n            right_part = get_output(root->right,sum, right_part_sum,min_val2 ,max_val2);\\n        \\n        if(!left_part or !right_part){\\n            return false;\\n        }\\n        \\n        if(root->val<=max_val1 or root->val>=min_val2){\\n            return false;\\n        }\\n        \\n        min_val = min({root->val,min_val1,min_val2});\\n        max_val = max({root->val,max_val1,max_val2});        \\n        \\n        // update the condition\\n        sum = max(sum,left_part_sum+right_part_sum + root->val);\\n        \\n        part_sum = left_part_sum+ right_part_sum + root->val;\\n        \\n        return true;\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        \\n        // Base Case\\n        if(root==NULL){\\n            return 0;\\n        }\\n                \\n        int sum =INT_MIN;\\n        \\n        bool isValid= false;\\n        \\n\\n        int part_sum =0;\\n        int min_val,max_val;\\n        isValid = get_output(root,sum,part_sum,min_val,max_val);\\n        \\n        if(sum<0){\\n            return 0;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619888,
                "title": "python-easy-bottom-up-approach",
                "content": "```\\nclass NodeValue:\\n    def __init__(self, minNode, maxNode, Sum):\\n        self.maxNode = maxNode\\n        self.minNode = minNode\\n        self.Sum = Sum\\n\\nclass Solution:\\n    def largestBstHelper(self, node):\\n        if not node:\\n            return NodeValue(float(\\'inf\\'), float(\\'-inf\\'), 0)\\n\\n        left = self.largestBstHelper(node.left)\\n        right = self.largestBstHelper(node.right)\\n\\n        if left.maxNode < node.val and node.val < right.minNode:\\n            currSum=left.Sum+ right.Sum + node.val\\n            self.maxSum=max(self.maxSum,currSum)\\n            return NodeValue(min(node.val, left.minNode), max(node.val, right.maxNode),currSum)\\n\\n        return NodeValue(float(\\'-inf\\'), float(\\'inf\\'), max(left.Sum, right.Sum))\\n    \\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        self.maxSum=0\\n        ans=self.largestBstHelper(root).Sum \\n        return self.maxSum\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass NodeValue:\\n    def __init__(self, minNode, maxNode, Sum):\\n        self.maxNode = maxNode\\n        self.minNode = minNode\\n        self.Sum = Sum\\n\\nclass Solution:\\n    def largestBstHelper(self, node):\\n        if not node:\\n            return NodeValue(float(\\'inf\\'), float(\\'-inf\\'), 0)\\n\\n        left = self.largestBstHelper(node.left)\\n        right = self.largestBstHelper(node.right)\\n\\n        if left.maxNode < node.val and node.val < right.minNode:\\n            currSum=left.Sum+ right.Sum + node.val\\n            self.maxSum=max(self.maxSum,currSum)\\n            return NodeValue(min(node.val, left.minNode), max(node.val, right.maxNode),currSum)\\n\\n        return NodeValue(float(\\'-inf\\'), float(\\'inf\\'), max(left.Sum, right.Sum))\\n    \\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        self.maxSum=0\\n        ans=self.largestBstHelper(root).Sum \\n        return self.maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351882,
                "title": "striver-s-method-super-easy-to-understand",
                "content": "# Intuition\\nThis question is just a copy of Finding Largest Bst in a Binary Tree.\\nBig Thanks! to Striver :).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n**Step -1**\\n\\nFind a Valid Bst \\n\\n->then get the maximum_Sum \\n\\n->we can get it by currSum = leftSum+ rightSum + root->val\\n\\n->update left and right child of the valid Bst\\n\\n**Step-2**\\n\\n*This Step occurs when the Binary Tree is not a bst.*\\n\\nIn this case:- \\n\\n->mark our isBst as false\\n\\n->update the maximum value of our current Bst\\n\\n**Step-3**\\n\\nonce done with 2 steps\\n\\n->store maximum answer and simply return it.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$  -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass NodeVal{\\n    public:\\n    bool isBst;\\n    int minNode,maxNode,maxSum;\\n    NodeVal(){\\n        isBst = true;\\n        minNode = INT_MAX;\\n        maxNode = INT_MIN;\\n        maxSum= 0;\\n    }\\n};\\nint ans;\\nclass Solution {\\npublic:\\n    NodeVal FindSum(TreeNode* root){\\n    if(root == NULL) return NodeVal();\\n    NodeVal curr;\\n    //Now take 2 pointer for left and right \\n    //-- we are going to perform POSTORDER TRAVERSAL\\n    NodeVal left = FindSum(root->left);\\n    NodeVal right = FindSum(root->right);\\n\\n    /*\\n    Checking main condition of BST:\\n    -----------Left < ROOT < RIGHT-----------\\n    \\n*/\\n    if((left.isBst==true && right.isBst == true) && (left.maxNode<root->val && root->val<right.minNode)){\\n        // make curr bst as bst \\n        curr.isBst = true;\\n        //Below is our answer\\n        curr.maxSum = left.maxSum + right.maxSum+root->val;\\n        // now store minimal node or the left node as it\\'s a BST  \\n        curr.minNode= min(left.minNode,root->val);\\n        // now store maximum node or the right node for bst\\n        curr.maxNode = max(right.maxNode,root->val);\\n    }\\n    /*if the given Binary Tree is Not a BST*/\\n    else{\\n        curr.isBst = false; // else mark it false saying \"No, its NOT BST\"\\n        curr.maxSum = max(left.maxSum,right.maxSum);// keep updating maxSum\\n    }\\n    ans = max(ans,curr.maxSum);// store current answer \\n    return curr;\\n}\\n    int maxSumBST(TreeNode* root) {\\n        ans =0;\\n        NodeVal obj = FindSum(root);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass NodeVal{\\n    public:\\n    bool isBst;\\n    int minNode,maxNode,maxSum;\\n    NodeVal(){\\n        isBst = true;\\n        minNode = INT_MAX;\\n        maxNode = INT_MIN;\\n        maxSum= 0;\\n    }\\n};\\nint ans;\\nclass Solution {\\npublic:\\n    NodeVal FindSum(TreeNode* root){\\n    if(root == NULL) return NodeVal();\\n    NodeVal curr;\\n    //Now take 2 pointer for left and right \\n    //-- we are going to perform POSTORDER TRAVERSAL\\n    NodeVal left = FindSum(root->left);\\n    NodeVal right = FindSum(root->right);\\n\\n    /*\\n    Checking main condition of BST:\\n    -----------Left < ROOT < RIGHT-----------\\n    \\n*/\\n    if((left.isBst==true && right.isBst == true) && (left.maxNode<root->val && root->val<right.minNode)){\\n        // make curr bst as bst \\n        curr.isBst = true;\\n        //Below is our answer\\n        curr.maxSum = left.maxSum + right.maxSum+root->val;\\n        // now store minimal node or the left node as it\\'s a BST  \\n        curr.minNode= min(left.minNode,root->val);\\n        // now store maximum node or the right node for bst\\n        curr.maxNode = max(right.maxNode,root->val);\\n    }\\n    /*if the given Binary Tree is Not a BST*/\\n    else{\\n        curr.isBst = false; // else mark it false saying \"No, its NOT BST\"\\n        curr.maxSum = max(left.maxSum,right.maxSum);// keep updating maxSum\\n    }\\n    ans = max(ans,curr.maxSum);// store current answer \\n    return curr;\\n}\\n    int maxSumBST(TreeNode* root) {\\n        ans =0;\\n        NodeVal obj = FindSum(root);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310253,
                "title": "optimized-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n class NodeValue{\\n    public int maxValue,minValue,maxsum;\\n    NodeValue(int max, int min,int maxsum){\\n        this.maxValue = max;\\n        this.minValue = min;\\n        this.maxsum = maxsum;\\n    }\\n}\\n\\nclass Solution {\\n    int max = 0;\\n    public NodeValue maxSumBSTHelper(TreeNode root){\\n        //An empty tree or bst of size 0;\\n        if(root == null){\\n            return new NodeValue(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        }\\n        NodeValue left = maxSumBSTHelper(root.left);\\n        NodeValue right = maxSumBSTHelper(root.right);\\n        \\n        //Check if it\\'s a valid bst\\n        if(left.maxValue < root.val && root.val < right.minValue){\\n            //It is a BST , calculate maxsum tillnow.\\n             max = Math.max(max,root.val + left.maxsum + right.maxsum);\\n            return new NodeValue(Math.max(root.val,right.maxValue), Math.min(root.val,left.minValue),root.val+left.maxsum + right.maxsum);\\n           \\n        }\\n        return new NodeValue(Integer.MAX_VALUE,Integer.MIN_VALUE,Math.max(left.maxsum,right.maxsum));\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        maxSumBSTHelper(root);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n class NodeValue{\\n    public int maxValue,minValue,maxsum;\\n    NodeValue(int max, int min,int maxsum){\\n        this.maxValue = max;\\n        this.minValue = min;\\n        this.maxsum = maxsum;\\n    }\\n}\\n\\nclass Solution {\\n    int max = 0;\\n    public NodeValue maxSumBSTHelper(TreeNode root){\\n        //An empty tree or bst of size 0;\\n        if(root == null){\\n            return new NodeValue(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        }\\n        NodeValue left = maxSumBSTHelper(root.left);\\n        NodeValue right = maxSumBSTHelper(root.right);\\n        \\n        //Check if it\\'s a valid bst\\n        if(left.maxValue < root.val && root.val < right.minValue){\\n            //It is a BST , calculate maxsum tillnow.\\n             max = Math.max(max,root.val + left.maxsum + right.maxsum);\\n            return new NodeValue(Math.max(root.val,right.maxValue), Math.min(root.val,left.minValue),root.val+left.maxsum + right.maxsum);\\n           \\n        }\\n        return new NodeValue(Integer.MAX_VALUE,Integer.MIN_VALUE,Math.max(left.maxsum,right.maxsum));\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        maxSumBSTHelper(root);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124363,
                "title": "c-o-n-simple-and-easy-solution-validate-bst",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is an extension to the \\'Validate BST\\' Problem.Maintain Ranges for a node and check it for the largest left child and the smallest right child.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(height of tree)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n class nodeValue{\\n     public:\\n     int min;\\n     int max;\\n     int sum;\\n     nodeValue(int min,int max,int sum)\\n     {\\n         this->min=min;\\n         this->max=max;\\n         this->sum=sum;\\n     }\\n };\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int maxSumBST(TreeNode* root) {\\n        fun(root);\\n        return ans;\\n    }\\n    nodeValue fun(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return nodeValue(INT_MAX,INT_MIN,0);\\n        nodeValue l=fun(root->left);\\n        nodeValue r=fun(root->right);\\n        if(root->val>l.max && root->val<r.min)\\n        {\\n            ans=max(ans,root->val+l.sum+r.sum);\\n            return nodeValue(min(root->val,l.min),max(root->val,r.max),l.sum+root->val+r.sum);\\n        }\\n        return nodeValue(INT_MIN,INT_MAX,max(l.sum,r.sum));\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n class nodeValue{\\n     public:\\n     int min;\\n     int max;\\n     int sum;\\n     nodeValue(int min,int max,int sum)\\n     {\\n         this->min=min;\\n         this->max=max;\\n         this->sum=sum;\\n     }\\n };\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int maxSumBST(TreeNode* root) {\\n        fun(root);\\n        return ans;\\n    }\\n    nodeValue fun(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return nodeValue(INT_MAX,INT_MIN,0);\\n        nodeValue l=fun(root->left);\\n        nodeValue r=fun(root->right);\\n        if(root->val>l.max && root->val<r.min)\\n        {\\n            ans=max(ans,root->val+l.sum+r.sum);\\n            return nodeValue(min(root->val,l.min),max(root->val,r.max),l.sum+root->val+r.sum);\\n        }\\n        return nodeValue(INT_MIN,INT_MAX,max(l.sum,r.sum));\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996686,
                "title": "detailed-explanation-easy-code-beats-90",
                "content": "# Intuition\\n- We have to find global maximum sum of any BST present as subtree, so we will have to vist every node\\n- Each node has to calculate if node + subtree forms a BST or not. If yes, then global max Sum needs to be updated.\\n - For processing at each node, we need to know if it forms a BST and if yes, then what is the sum.\\n\\n# Approach\\n- First data point we need is if the node forms a BST, this is only possible if left subtree is a BST, right subtree is a BST and also the max of left subtree is less than node\\'s data and min of right subtree is greater than node\\'s data. We can easily see that we need 3 values from each subtree : isBST, max value and min value. With these value parent nodes can see if they are BST or not.\\n- If current node is not a BST we simply need to return to upper (parent) node only this info since nothing else is needed. However, if current node is a BST we need to pass 3 values talked in the previous point and also the sum of this current subtree. When we calculate sum of current BST subtree, we can also check to see if is max sum seen so far.\\n- This problem is like two easy problems combined: Check BST (check whether a tree is BST or not) and Tree Sum (calculate Sum). We just need to combine these logics and not return any other info if the current node does not form a BST since no other info is desired by parent node in this case.\\n- Since null node is also a BST, we return from it with default values.\\n- Since negative values are not to be taken and even empty BST is better than these, we start from maxSum as zero (rather than min integer possible in language).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ : We just need to traverse once\\n\\n- Space complexity:\\n$$O(n)$$ : If the tree is highly skewed, then recursive calls on stack can take $$O(n)$$ space otherwise in a balnced tree, space complexity is $$O(log n)$$\\n\\n# Code\\n```\\nclass quad{     // 4 values have to be returned so made a quad class\\n    public :\\n    int maxEle;\\n    int minEle;\\n    bool isBST;\\n    int sum;\\n    quad(int maxEle, int minEle, bool isBST, int sum){\\n        this -> maxEle = maxEle;\\n        this -> minEle = minEle;\\n        this -> isBST = isBST;\\n        this -> sum = sum;\\n    }\\n    quad(){\\n        this-> isBST = false;       //when isBST is false, then other values can be garbage\\n    }\\n};\\nclass Solution {\\npublic:\\n    int maxSum = 0;\\n    quad traverse(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return quad(INT_MIN, INT_MAX, true, 0);\\n        \\n        quad leftAns = traverse(root ->left);\\n        quad rightAns = traverse(root -> right);\\n\\n        bool isBST = leftAns.isBST && rightAns.isBST && (leftAns.maxEle < root->val) && (rightAns.minEle > root->val);\\n        \\n        if(!isBST)\\n            return quad();          // default constructor sets isBST to false, rest are garbage values\\n        else\\n            {\\n                int sum = leftAns.sum + rightAns.sum + root->val;\\n                if(sum > maxSum)            // try updating globally maintained sum\\n                    maxSum = sum;\\n                return quad(max(root->val, rightAns.maxEle),\\n                            min(root->val, leftAns.minEle),\\n                            true,\\n                            sum );\\n            }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        traverse(root);\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass quad{     // 4 values have to be returned so made a quad class\\n    public :\\n    int maxEle;\\n    int minEle;\\n    bool isBST;\\n    int sum;\\n    quad(int maxEle, int minEle, bool isBST, int sum){\\n        this -> maxEle = maxEle;\\n        this -> minEle = minEle;\\n        this -> isBST = isBST;\\n        this -> sum = sum;\\n    }\\n    quad(){\\n        this-> isBST = false;       //when isBST is false, then other values can be garbage\\n    }\\n};\\nclass Solution {\\npublic:\\n    int maxSum = 0;\\n    quad traverse(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return quad(INT_MIN, INT_MAX, true, 0);\\n        \\n        quad leftAns = traverse(root ->left);\\n        quad rightAns = traverse(root -> right);\\n\\n        bool isBST = leftAns.isBST && rightAns.isBST && (leftAns.maxEle < root->val) && (rightAns.minEle > root->val);\\n        \\n        if(!isBST)\\n            return quad();          // default constructor sets isBST to false, rest are garbage values\\n        else\\n            {\\n                int sum = leftAns.sum + rightAns.sum + root->val;\\n                if(sum > maxSum)            // try updating globally maintained sum\\n                    maxSum = sum;\\n                return quad(max(root->val, rightAns.maxEle),\\n                            min(root->val, leftAns.minEle),\\n                            true,\\n                            sum );\\n            }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        traverse(root);\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836583,
                "title": "striver-cpp-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// created class container to store maximum,minimum,and maxsum values\\n class cont{\\n     public:\\n        int maxsum;\\n        int maxval;\\n        int minval;\\n    cont(int ms,int mx,int mi){\\n        maxsum=ms;\\n        maxval=mx;\\n        minval=mi;\\n    }\\n };\\nclass Solution {\\npublic:\\n    int res;    // created this variable to keep track on maxsum till now\\n    cont solve(TreeNode* root){\\n        if(root==NULL){\\n            return cont(0,INT_MIN,INT_MAX);\\n        }\\n\\n        auto left = solve(root->left);\\n        auto right=solve(root->right);\\n\\n        if((root->val > left.maxval) && (root->val < right.minval)){\\n            int s=root->val+left.maxsum+right.maxsum;\\n            res=max(res,s);\\n            return cont(s,max(root->val,right.maxval),min(root->val,left.minval));\\n        }\\n\\n        return cont(max(left.maxsum,right.maxsum),INT_MAX,INT_MIN);\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        res=0;\\n        solve(root).maxsum;\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// created class container to store maximum,minimum,and maxsum values\\n class cont{\\n     public:\\n        int maxsum;\\n        int maxval;\\n        int minval;\\n    cont(int ms,int mx,int mi){\\n        maxsum=ms;\\n        maxval=mx;\\n        minval=mi;\\n    }\\n };\\nclass Solution {\\npublic:\\n    int res;    // created this variable to keep track on maxsum till now\\n    cont solve(TreeNode* root){\\n        if(root==NULL){\\n            return cont(0,INT_MIN,INT_MAX);\\n        }\\n\\n        auto left = solve(root->left);\\n        auto right=solve(root->right);\\n\\n        if((root->val > left.maxval) && (root->val < right.minval)){\\n            int s=root->val+left.maxsum+right.maxsum;\\n            res=max(res,s);\\n            return cont(s,max(root->val,right.maxval),min(root->val,left.minval));\\n        }\\n\\n        return cont(max(left.maxsum,right.maxsum),INT_MAX,INT_MIN);\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        res=0;\\n        solve(root).maxsum;\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575531,
                "title": "easy-c-solution-recursive-solution-same-like-maximum-height-of-bst",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    class info{\\n      public:\\n      int maxi;\\n      int mini;\\n      bool isBst;\\n      int sum;\\n      \\n    };\\n    \\n    info solve(TreeNode*root,int &ans){\\n        \\n        if(root==NULL){\\n            return {INT_MIN,INT_MAX,true,0};\\n        }\\n        \\n        \\n        info left = solve(root->left,ans);\\n        info right = solve(root->right,ans);\\n        \\n        info currNode;\\n        currNode.maxi = max(root->val,right.maxi);\\n        currNode.mini = min(root->val,left.mini);\\n        currNode.sum = left.sum + right.sum + root->val; \\n        \\n        if(left.isBst && right.isBst && (root->val> left.maxi && root->val < right.mini)){\\n        currNode.isBst = true;\\n            currNode.sum = left.sum + right.sum + root->val;\\n        }\\n        else {\\n        currNode.isBst  = false;\\n        }\\n        \\n        \\n        if(currNode.isBst)ans = max(ans,currNode.sum);\\n        return currNode;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int sum = 0;\\n        info t = solve(root,sum);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    class info{\\n      public:\\n      int maxi;\\n      int mini;\\n      bool isBst;\\n      int sum;\\n      \\n    };\\n    \\n    info solve(TreeNode*root,int &ans){\\n        \\n        if(root==NULL){\\n            return {INT_MIN,INT_MAX,true,0};\\n        }\\n        \\n        \\n        info left = solve(root->left,ans);\\n        info right = solve(root->right,ans);\\n        \\n        info currNode;\\n        currNode.maxi = max(root->val,right.maxi);\\n        currNode.mini = min(root->val,left.mini);\\n        currNode.sum = left.sum + right.sum + root->val; \\n        \\n        if(left.isBst && right.isBst && (root->val> left.maxi && root->val < right.mini)){\\n        currNode.isBst = true;\\n            currNode.sum = left.sum + right.sum + root->val;\\n        }\\n        else {\\n        currNode.isBst  = false;\\n        }\\n        \\n        \\n        if(currNode.isBst)ans = max(ans,currNode.sum);\\n        return currNode;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int sum = 0;\\n        info t = solve(root,sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396279,
                "title": "c-recursion-post-order-traversal",
                "content": "* At each node we return an `array<int,4>` where\\n1.  `arr[0]` -> if the subtree is BST or not\\n2.  `arr[1]` -> sum of the subtree.\\n3.  `arr[2]`-> Max Value in that subtree.\\n4.  `arr[3]` -> Min Value in that subtree.\\n\\n* A tree will be a BST when its `left and right subtree are both BST\\'s` and the value or root node should be such that it lies between the **max Value from left subtree and min Value from right subtree**\\n\\n* We Keep track of sum in  variable **ans**.\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = 0 ;\\n\\t\\n    array<int,4> solve(TreeNode * root){\\n        if(!root) return {1,0,INT_MIN,INT_MAX} ;\\n        \\n        array<int,4> l = solve(root->left) ;\\n        array<int,4> r = solve(root->right) ;\\n        \\n        if(l[0] and r[0]){\\n            if(root->val > l[2] and root->val < r[3]){\\n                ans = max({ans,l[1],r[1]}) ;\\n                return {1,l[1] + r[1] + root->val,max({root->val,l[2],r[2]}),min({root->val,l[3],r[3]})} ;\\n            }\\n        }\\n        \\n        return {0,max(l[1],r[1]),INT_MIN,INT_MAX} ;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        auto arr = solve(root) ;\\n        return max(ans,arr[1]) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0 ;\\n\\t\\n    array<int,4> solve(TreeNode * root){\\n        if(!root) return {1,0,INT_MIN,INT_MAX} ;\\n        \\n        array<int,4> l = solve(root->left) ;\\n        array<int,4> r = solve(root->right) ;\\n        \\n        if(l[0] and r[0]){\\n            if(root->val > l[2] and root->val < r[3]){\\n                ans = max({ans,l[1],r[1]}) ;\\n                return {1,l[1] + r[1] + root->val,max({root->val,l[2],r[2]}),min({root->val,l[3],r[3]})} ;\\n            }\\n        }\\n        \\n        return {0,max(l[1],r[1]),INT_MIN,INT_MAX} ;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        auto arr = solve(root) ;\\n        return max(ans,arr[1]) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386278,
                "title": "java-o-n-min-max-sum",
                "content": "```\\nclass Solution {\\n    \\n    int ans = 0;\\n    public int maxSumBST(TreeNode root) {\\n        solve(root);\\n        return ans;\\n    }\\n    // int[] = { min, max, sum };\\n    private int[] solve(TreeNode root) {\\n        if(root == null) \\n            return new int[] { Integer.MAX_VALUE, Integer.MIN_VALUE, 0 };\\n        \\n        int[] left = solve(root.left);\\n        int[] right = solve(root.right);\\n        \\n        if(root.val > left[1] && root.val < right[0]) {\\n             int sum = left[2] + right[2] + root.val;\\n             ans = Math.max(ans, sum);\\n             return new int[] { Math.min(left[0], root.val), Math.max(root.val, right[1]), sum };  \\n        }\\n\\t\\t\\n        return new int[] { Integer.MIN_VALUE, Integer.MAX_VALUE, 0 }; \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int ans = 0;\\n    public int maxSumBST(TreeNode root) {\\n        solve(root);\\n        return ans;\\n    }\\n    // int[] = { min, max, sum };\\n    private int[] solve(TreeNode root) {\\n        if(root == null) \\n            return new int[] { Integer.MAX_VALUE, Integer.MIN_VALUE, 0 };\\n        \\n        int[] left = solve(root.left);\\n        int[] right = solve(root.right);\\n        \\n        if(root.val > left[1] && root.val < right[0]) {\\n             int sum = left[2] + right[2] + root.val;\\n             ans = Math.max(ans, sum);\\n             return new int[] { Math.min(left[0], root.val), Math.max(root.val, right[1]), sum };  \\n        }\\n\\t\\t\\n        return new int[] { Integer.MIN_VALUE, Integer.MAX_VALUE, 0 }; \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380070,
                "title": "c-simple-recursive-solution-detailed-explanation",
                "content": "**Logic:**\\nWe know that for any BST:\\n1. Root is greater than the smallest element in its left subtree\\n2. Root is smaller than the largest element in its right subtree\\n\\n```\\nclass Solution {\\npublic:\\n\\t // Stores the ans\\n    int sum = 0;\\n    \\n\\t// Returns {sum of all nodes, {min node, max node}} of the subtree\\n    pair<int,pair<int,int>> helper(TreeNode *root){\\n\\t\\t// For NULL node, sum = 0 and consider min = INT_MAX and max = INT_MIN\\n        if(root == NULL){\\n            return {0, {INT_MAX, INT_MIN}};\\n        }\\n        \\n\\t\\t// Moving into left and right children\\n        pair<int,pair<int,int>> lst = helper(root->left);\\n        pair<int,pair<int,int>> rst = helper(root->right);\\n        \\n        // Valid BST (max in left < root and root < min in right)\\n        if(lst.second.second < root->val && root->val < rst.second.first){\\n            int s = root->val + lst.first + rst.first;\\n            sum = max(sum, s);\\n\\t\\t\\t// Updating the min and max of the subtree\\n            int mi = min({root->val, lst.second.first, rst.second.first});\\n            int ma = max({root->val, lst.second.second, rst.second.second});\\n            return {s, {mi, ma}};\\n        }\\n        \\n\\t\\t// Not a valid BST, then make min = INT_MIN and max = INT_MAX\\n\\t\\t// so that any subsequent parent nodes cannot consider the current subtree in BST\\n        return {0, {INT_MIN, INT_MAX}};\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```\\n\\n**References:** https://www.youtube.com/watch?v=X0oXMdtUDwo (Took insipiration from this video)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t // Stores the ans\\n    int sum = 0;\\n    \\n\\t// Returns {sum of all nodes, {min node, max node}} of the subtree\\n    pair<int,pair<int,int>> helper(TreeNode *root){\\n\\t\\t// For NULL node, sum = 0 and consider min = INT_MAX and max = INT_MIN\\n        if(root == NULL){\\n            return {0, {INT_MAX, INT_MIN}};\\n        }\\n        \\n\\t\\t// Moving into left and right children\\n        pair<int,pair<int,int>> lst = helper(root->left);\\n        pair<int,pair<int,int>> rst = helper(root->right);\\n        \\n        // Valid BST (max in left < root and root < min in right)\\n        if(lst.second.second < root->val && root->val < rst.second.first){\\n            int s = root->val + lst.first + rst.first;\\n            sum = max(sum, s);\\n\\t\\t\\t// Updating the min and max of the subtree\\n            int mi = min({root->val, lst.second.first, rst.second.first});\\n            int ma = max({root->val, lst.second.second, rst.second.second});\\n            return {s, {mi, ma}};\\n        }\\n        \\n\\t\\t// Not a valid BST, then make min = INT_MIN and max = INT_MAX\\n\\t\\t// so that any subsequent parent nodes cannot consider the current subtree in BST\\n        return {0, {INT_MIN, INT_MAX}};\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2347445,
                "title": "optimal-c-solution-beats-100-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    pair<int, pair<int,int>> solve(TreeNode* root){\\n        if(!root->left && !root->right){\\n            ans = max(ans, root->val);\\n            return {root->val, {root->val, root->val}};\\n        }\\n        pair<int,pair<int,int>> left = {0,{INT_MAX,INT_MIN}}, right = {0,{INT_MAX,INT_MIN}};\\n        if(root->left) left = solve(root->left);\\n        if(root->right) right = solve(root->right);\\n        if(root->val>left.second.second && root->val<right.second.first){\\n            ans = max(ans, left.first+right.first+root->val);\\n            return {left.first+right.first+root->val, {min(left.second.first, root->val), max(right.second.second, root->val)}};\\n        }\\n        else return {0, {INT_MIN,INT_MAX}};\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL); \\n        auto x = solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    pair<int, pair<int,int>> solve(TreeNode* root){\\n        if(!root->left && !root->right){\\n            ans = max(ans, root->val);\\n            return {root->val, {root->val, root->val}};\\n        }\\n        pair<int,pair<int,int>> left = {0,{INT_MAX,INT_MIN}}, right = {0,{INT_MAX,INT_MIN}};\\n        if(root->left) left = solve(root->left);\\n        if(root->right) right = solve(root->right);\\n        if(root->val>left.second.second && root->val<right.second.first){\\n            ans = max(ans, left.first+right.first+root->val);\\n            return {left.first+right.first+root->val, {min(left.second.first, root->val), max(right.second.second, root->val)}};\\n        }\\n        else return {0, {INT_MIN,INT_MAX}};\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL); \\n        auto x = solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206165,
                "title": "cpp-code-o-n-tc-post-order-traversal-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n// the idea here is to find the largest bst subtree , then count sum of each element\\n// and return the sum\\n\\n// creating class to hold values \\nclass NodeValue{\\npublic:\\n    int maxVal , minVal , maxSum , sum , isBst;\\n    NodeValue( int mx , int mn , int ans , int s , int bst){\\n        this -> maxVal = mx ;\\n        this -> minVal = mn ; \\n        this -> maxSum = ans ;\\n        this -> sum = s ;\\n        this -> isBst = bst;\\n    }    \\n};\\n\\nclass Solution {\\nprivate:\\n    NodeValue largeSumBst( TreeNode* root){\\n        if ( !root) return NodeValue(INT_MIN , INT_MAX , 0 , 0 , 1 );\\n        \\n        // postorder traversal\\n        auto left = largeSumBst( root -> left );\\n        auto right = largeSumBst( root -> right );\\n        \\n        // if not bst\\n        if (!left.isBst or !right.isBst ){\\n            return NodeValue ( INT_MIN , INT_MAX , max ({ left.maxSum , right.maxSum , 0 }) , root -> val + right.sum + left.sum , 0 );\\n        }\\n        \\n        // if the tree is a valid bst \\n        if ( left.maxVal < root -> val and right.minVal > root -> val){\\n            return NodeValue ( max ( {root -> val , left.maxVal , right.maxVal }) , \\n                             min ({ root -> val , left.minVal , right.minVal }) ,\\n                             max ({ 0 , (root -> val + left.sum + right.sum ) , right.maxSum , left.maxSum}),\\n                                root -> val + left.sum + right.sum , 1);\\n        }\\n        \\n        // not a bst\\n        return NodeValue ( INT_MIN , INT_MAX , max ({ left.maxSum , right.maxSum , 0}) , root -> val + right.sum + left.sum , 0 );\\n    }\\n    \\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        if (!root) return 0 ;\\n        return largeSumBst( root ).maxSum ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n// the idea here is to find the largest bst subtree , then count sum of each element\\n// and return the sum\\n\\n// creating class to hold values \\nclass NodeValue{\\npublic:\\n    int maxVal , minVal , maxSum , sum , isBst;\\n    NodeValue( int mx , int mn , int ans , int s , int bst){\\n        this -> maxVal = mx ;\\n        this -> minVal = mn ; \\n        this -> maxSum = ans ;\\n        this -> sum = s ;\\n        this -> isBst = bst;\\n    }    \\n};\\n\\nclass Solution {\\nprivate:\\n    NodeValue largeSumBst( TreeNode* root){\\n        if ( !root) return NodeValue(INT_MIN , INT_MAX , 0 , 0 , 1 );\\n        \\n        // postorder traversal\\n        auto left = largeSumBst( root -> left );\\n        auto right = largeSumBst( root -> right );\\n        \\n        // if not bst\\n        if (!left.isBst or !right.isBst ){\\n            return NodeValue ( INT_MIN , INT_MAX , max ({ left.maxSum , right.maxSum , 0 }) , root -> val + right.sum + left.sum , 0 );\\n        }\\n        \\n        // if the tree is a valid bst \\n        if ( left.maxVal < root -> val and right.minVal > root -> val){\\n            return NodeValue ( max ( {root -> val , left.maxVal , right.maxVal }) , \\n                             min ({ root -> val , left.minVal , right.minVal }) ,\\n                             max ({ 0 , (root -> val + left.sum + right.sum ) , right.maxSum , left.maxSum}),\\n                                root -> val + left.sum + right.sum , 1);\\n        }\\n        \\n        // not a bst\\n        return NodeValue ( INT_MIN , INT_MAX , max ({ left.maxSum , right.maxSum , 0}) , root -> val + right.sum + left.sum , 0 );\\n    }\\n    \\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        if (!root) return 0 ;\\n        return largeSumBst( root ).maxSum ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003391,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nstruct Node {\\n    int maximum;\\n    int minimum;\\n    int sum;\\n    bool isBst;\\n    Node() {\\n        maximum = INT_MIN;\\n        minimum = INT_MAX;\\n        sum = 0;\\n        isBst = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    Node getSum(TreeNode * root) {\\n\\t// base condition\\n        if (root == NULL) return Node();\\n\\t\\t\\n        Node node;\\n\\t\\t\\n\\t\\t// never question this step, just write it .This is important in every binary tree question\\n        Node node_left = getSum(root -> left);\\n        Node node_right = getSum(root -> right);\\n\\n// induction step, contains the main logic\\n        if (node_left.isBst == true && node_right.isBst == true && node_left.maximum < root -> val && node_right.minimum > root -> val) {\\n            node.sum = node_left.sum + node_right.sum + root -> val;\\n            node.isBst = true;\\n            node.minimum = min(root -> val, min(node_left.minimum, node_right.minimum));\\n            node.maximum = max(root -> val, max(node_left.maximum, node_right.maximum));\\n        } else {\\n            node.isBst = false;\\n            node.sum = 0;\\n        }\\n        ans = max(ans, node.sum);\\n        return node;\\n    }\\n\\t\\n    int maxSumBST(TreeNode * root) {\\n        ans = INT_MIN;\\n        getSum(root);\\n        if (ans > 0) return ans;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct Node {\\n    int maximum;\\n    int minimum;\\n    int sum;\\n    bool isBst;\\n    Node() {\\n        maximum = INT_MIN;\\n        minimum = INT_MAX;\\n        sum = 0;\\n        isBst = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    Node getSum(TreeNode * root) {\\n\\t// base condition\\n        if (root == NULL) return Node();\\n\\t\\t\\n        Node node;\\n\\t\\t\\n\\t\\t// never question this step, just write it .This is important in every binary tree question\\n        Node node_left = getSum(root -> left);\\n        Node node_right = getSum(root -> right);\\n\\n// induction step, contains the main logic\\n        if (node_left.isBst == true && node_right.isBst == true && node_left.maximum < root -> val && node_right.minimum > root -> val) {\\n            node.sum = node_left.sum + node_right.sum + root -> val;\\n            node.isBst = true;\\n            node.minimum = min(root -> val, min(node_left.minimum, node_right.minimum));\\n            node.maximum = max(root -> val, max(node_left.maximum, node_right.maximum));\\n        } else {\\n            node.isBst = false;\\n            node.sum = 0;\\n        }\\n        ans = max(ans, node.sum);\\n        return node;\\n    }\\n\\t\\n    int maxSumBST(TreeNode * root) {\\n        ans = INT_MIN;\\n        getSum(root);\\n        if (ans > 0) return ans;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638387,
                "title": "java-postorder-o-n-learned-from-labuladong",
                "content": "#### Before Everything\\nThe solution is I learned from **labuladong.** \\nhttps://labuladong.gitee.io/algo/2/18/27/\\n#### Idea\\nFor solving the problem, with the view of <u>the current root</u>, we need to know following things:\\n+  `sum` of left subtree and right subtree\\n+  `min` of right subtree\\n+  `max` of left subtree\\n+  `isBST` of leftSubtree\\n\\nBecause only following conditions, can we update the global variable`maxSum` which stores the possible answer:\\n+ left subtree is BST, right subtree is BST\\n+ current tree is BST\\n\\nSo we use an array to store the result of each tree\\n```java\\n// int[] res = new int[]{sum, min, max, isBST}\\nint[] res = new int[4]; \\n```\\nConvert two conditions into mathematical expression:\\n```java\\n// left subtree is BST, right subtree is BST\\nleft[3] == 1 && right[3] == 1;\\n// current tree is BST\\n// i.e., the value of root should less than min of right subtree and greater than max of left subtree\\nroot.val > left[2] && root.val < right[1];\\n```\\nWhen  the conditions are satisfied, we can update the global variable `maxSum`\\n```java\\n this.maxSum = Math.max(curr[0], this.maxSum);\\n```\\n#### Code\\n```\\n\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        traverse(root);\\n        return this.maxSum;\\n    }\\n    \\n    // int[] sum = {sum, min, max, isBST}\\n    private int[] traverse(TreeNode root){\\n        // base case\\n        if(root == null){\\n            return new int[]{0, Integer.MAX_VALUE, Integer.MIN_VALUE, 1};\\n        }\\n        // left\\n        int[] left = traverse(root.left);\\n        // right\\n        int[] right = traverse(root.right);\\n        // root\\n        // check left and right is BST or not, if so, check if root and min and max okay, then update sum\\n        int[] curr = new int[4];\\n        if(left[3] == 1 && right[3] == 1 && root.val > left[2] && root.val < right[1]){\\n            curr[3] = 1;\\n            curr[0] = left[0] + right[0] + root.val;\\n            curr[1] = Math.min(root.val, left[1]);\\n            curr[2] = Math.max(root.val, right[2]);\\n            this.maxSum = Math.max(curr[0], this.maxSum);\\n        }else{\\n            curr[3] = 0;\\n        }\\n        return curr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```java\\n// int[] res = new int[]{sum, min, max, isBST}\\nint[] res = new int[4]; \\n```\n```java\\n// left subtree is BST, right subtree is BST\\nleft[3] == 1 && right[3] == 1;\\n// current tree is BST\\n// i.e., the value of root should less than min of right subtree and greater than max of left subtree\\nroot.val > left[2] && root.val < right[1];\\n```\n```java\\n this.maxSum = Math.max(curr[0], this.maxSum);\\n```\n```\\n\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        traverse(root);\\n        return this.maxSum;\\n    }\\n    \\n    // int[] sum = {sum, min, max, isBST}\\n    private int[] traverse(TreeNode root){\\n        // base case\\n        if(root == null){\\n            return new int[]{0, Integer.MAX_VALUE, Integer.MIN_VALUE, 1};\\n        }\\n        // left\\n        int[] left = traverse(root.left);\\n        // right\\n        int[] right = traverse(root.right);\\n        // root\\n        // check left and right is BST or not, if so, check if root and min and max okay, then update sum\\n        int[] curr = new int[4];\\n        if(left[3] == 1 && right[3] == 1 && root.val > left[2] && root.val < right[1]){\\n            curr[3] = 1;\\n            curr[0] = left[0] + right[0] + root.val;\\n            curr[1] = Math.min(root.val, left[1]);\\n            curr[2] = Math.max(root.val, right[2]);\\n            this.maxSum = Math.max(curr[0], this.maxSum);\\n        }else{\\n            curr[3] = 0;\\n        }\\n        return curr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281341,
                "title": "similar-to-largest-bst-in-binary-tree-problem",
                "content": "There are two cases: \\n1. If the Current Root be the root of the BST (when its value lies between maximum value in its left BST and minimum in its right BST). In that case, the sum it will store will be simply, left_sum + right_sum + root->val.\\n2.  Otherwise, the sum it will store will be max(left_sum,right_sum) because in this case we have max sum BST in either of its left and right subtree.\\n```\\nclass bst_node{\\n    public:\\n        bool isbst; //if true it means subtree rooted at current bst_node is BST\\n        int max_val; // It stores minimum value of BST nodes rooted at current bst_node.\\n        int min_val; // Smilar to max_val.\\n        int sum; //It stores sum of BST possible in subtree rooted at current bst_node.\\n};\\nclass Solution {\\npublic:\\n    bst_node solve(TreeNode* root, int &max_sum){\\n        if(!root){\\n            return {true,INT_MIN,INT_MAX,0};\\n        }\\n        auto left_info = solve(root->left,max_sum);\\n        auto right_info = solve(root->right,max_sum);\\n        bst_node root_info;\\n        if(left_info.isbst && right_info.isbst && left_info.max_val< root->val && root->val < right_info.min_val){\\n            root_info.isbst = true;\\n            root_info.min_val = min(root->val,left_info.min_val);\\n            root_info.max_val = max(root->val,right_info.max_val);\\n            root_info.sum = left_info.sum + right_info.sum + root->val;\\n        }\\n        else{\\n            root_info.isbst = false;\\n            root_info.min_val = min(root->val,left_info.min_val);\\n            root_info.max_val = max(root->val,right_info.max_val);\\n            root_info.sum = max(left_info.sum,right_info.sum);\\n        }\\n        max_sum  = max(max_sum,root_info.sum);\\n        return root_info;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int max_sum =0;\\n        solve(root,max_sum);\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass bst_node{\\n    public:\\n        bool isbst; //if true it means subtree rooted at current bst_node is BST\\n        int max_val; // It stores minimum value of BST nodes rooted at current bst_node.\\n        int min_val; // Smilar to max_val.\\n        int sum; //It stores sum of BST possible in subtree rooted at current bst_node.\\n};\\nclass Solution {\\npublic:\\n    bst_node solve(TreeNode* root, int &max_sum){\\n        if(!root){\\n            return {true,INT_MIN,INT_MAX,0};\\n        }\\n        auto left_info = solve(root->left,max_sum);\\n        auto right_info = solve(root->right,max_sum);\\n        bst_node root_info;\\n        if(left_info.isbst && right_info.isbst && left_info.max_val< root->val && root->val < right_info.min_val){\\n            root_info.isbst = true;\\n            root_info.min_val = min(root->val,left_info.min_val);\\n            root_info.max_val = max(root->val,right_info.max_val);\\n            root_info.sum = left_info.sum + right_info.sum + root->val;\\n        }\\n        else{\\n            root_info.isbst = false;\\n            root_info.min_val = min(root->val,left_info.min_val);\\n            root_info.max_val = max(root->val,right_info.max_val);\\n            root_info.sum = max(left_info.sum,right_info.sum);\\n        }\\n        max_sum  = max(max_sum,root_info.sum);\\n        return root_info;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int max_sum =0;\\n        solve(root,max_sum);\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043844,
                "title": "javascript-solution",
                "content": "https://leetcode.com/problems/validate-binary-search-tree/\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/\\n\\nThere are two sub problems: how to check if subtree valid BST, and how to get the max sum of a subtree.\\n\\nThe base case is when we get to a leaf node, we return a \"blank\" object up the recursion stack --- we know the sum at a leaf is 0, it must be a valid BST because there are no nodes below it, and it has no upper and lower limit.\\n\\nThen, when we are at a node we need to check: are the left and right subtrees below it valid BSTs? and does this node have a value that is greater than the maximum value in the left subtree, and a value less then the minimum value in the right subtree? Remembering the rules of BSTs.\\n\\nIf so, we can calculate a new sum at that node and check if this is the best sum we have seen so far. In this case we return the current sum upwards and set our low and high values\\n\\n```\\nclass Result {\\n  constructor(sum, isBST, low, high) {\\n    this.sum = sum\\n    this.isBST = isBST\\n    this.low = low\\n    this.high = high\\n  }\\n}\\n\\nconst maxSumBST = function(root) {\\n  let maxSum = 0\\n\\n  const search = root => {\\n    if (!root) {\\n      return new Result(\\n        0,\\n        true,\\n        Number.MAX_SAFE_INTEGER,\\n        Number.MIN_SAFE_INTEGER\\n      )\\n    }\\n\\n    const left = search(root.left)\\n    const right = search(root.right)\\n\\n    if (left.isBST && right.isBST && root.val > left.high && root.val < right.low) {\\n      const sum = root.val + left.sum + right.sum\\n      maxSum = Math.max(maxSum, sum)\\n\\n      return new Result(\\n        sum,\\n        true,\\n        Math.min(root.val, left.low),\\n        Math.max(root.val, right.high)\\n      )\\n    }\\n\\n    return new Result(0, false, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER)\\n  }\\n\\n  search(root)\\n\\n  return maxSum\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Result {\\n  constructor(sum, isBST, low, high) {\\n    this.sum = sum\\n    this.isBST = isBST\\n    this.low = low\\n    this.high = high\\n  }\\n}\\n\\nconst maxSumBST = function(root) {\\n  let maxSum = 0\\n\\n  const search = root => {\\n    if (!root) {\\n      return new Result(\\n        0,\\n        true,\\n        Number.MAX_SAFE_INTEGER,\\n        Number.MIN_SAFE_INTEGER\\n      )\\n    }\\n\\n    const left = search(root.left)\\n    const right = search(root.right)\\n\\n    if (left.isBST && right.isBST && root.val > left.high && root.val < right.low) {\\n      const sum = root.val + left.sum + right.sum\\n      maxSum = Math.max(maxSum, sum)\\n\\n      return new Result(\\n        sum,\\n        true,\\n        Math.min(root.val, left.low),\\n        Math.max(root.val, right.high)\\n      )\\n    }\\n\\n    return new Result(0, false, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER)\\n  }\\n\\n  search(root)\\n\\n  return maxSum\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891024,
                "title": "java-short-solution-do-not-need-post-order-traversal",
                "content": "```\\nclass Output{\\n    boolean bst;\\n    int sum;\\n    int max;\\n    int min;\\n    public Output(boolean bst, int sum, int min, int max) {\\n            this.bst = bst;\\n            this.sum = sum;\\n            this.min = min;\\n            this.max = max;\\n        }\\n}\\nclass Solution {\\n    int res = 0;\\n    public int maxSumBST(TreeNode root) {\\n        //sumBST(x): the sum of valid bst, with the root is x\\n        if(root==null) return 0;\\n        sumBST(root);\\n        return res;        \\n    }\\n    private Output sumBST(TreeNode root) {\\n        if(root==null) {\\n            return new Output(true, 0, Integer.MAX_VALUE, Integer.MIN_VALUE);\\n        }\\n        boolean bst = false;\\n        int max=root.val, min=root.val, sum=root.val;\\n        \\n        Output left = sumBST(root.left);\\n        Output right = sumBST(root.right);\\n            if(left.bst && right.bst && left.max<root.val && right.min>root.val) {\\n                bst = true;\\n                min = Math.min(left.min, root.val);\\n                max = Math.max(right.max, root.val);\\n                sum+=left.sum+right.sum;  \\n                res = Math.max(res, sum);\\n                return new Output(bst, sum, min, max);\\n            }\\n            return new Output(bst, sum, min, max);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Output{\\n    boolean bst;\\n    int sum;\\n    int max;\\n    int min;\\n    public Output(boolean bst, int sum, int min, int max) {\\n            this.bst = bst;\\n            this.sum = sum;\\n            this.min = min;\\n            this.max = max;\\n        }\\n}\\nclass Solution {\\n    int res = 0;\\n    public int maxSumBST(TreeNode root) {\\n        //sumBST(x): the sum of valid bst, with the root is x\\n        if(root==null) return 0;\\n        sumBST(root);\\n        return res;        \\n    }\\n    private Output sumBST(TreeNode root) {\\n        if(root==null) {\\n            return new Output(true, 0, Integer.MAX_VALUE, Integer.MIN_VALUE);\\n        }\\n        boolean bst = false;\\n        int max=root.val, min=root.val, sum=root.val;\\n        \\n        Output left = sumBST(root.left);\\n        Output right = sumBST(root.right);\\n            if(left.bst && right.bst && left.max<root.val && right.min>root.val) {\\n                bst = true;\\n                min = Math.min(left.min, root.val);\\n                max = Math.max(right.max, root.val);\\n                sum+=left.sum+right.sum;  \\n                res = Math.max(res, sum);\\n                return new Output(bst, sum, min, max);\\n            }\\n            return new Output(bst, sum, min, max);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749916,
                "title": "c-easy-traversal-with-comments",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n//check if valid BST for given root.\\n    bool isValid(TreeNode* root, int* left, int* right)\\n    {\\n        if(root == NULL)\\n            return true;\\n        else\\n        {\\n            if(left != NULL && root->val <= *left)\\n                return false;\\n            if(right != NULL && root->val >= *right)\\n                return false;\\n            return isValid(root->left, left, &root->val) && isValid(root->right, &root->val, right);\\n        }\\n    }\\n    \\n    int maxSum(TreeNode* root, int& max)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        else\\n        {\\n            int l = maxSum(root->left, max);\\n            int r = maxSum(root->right, max);\\n            max = std::max(max, std::max(l, std::max(r, l + r + root->val)));\\n            return l + r + root->val;\\n        }\\n    }\\n    //check for valid BST in binary tree\\n    int getMax(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        if(isValid(root, NULL, NULL))\\n        {\\n\\t\\t\\t// true then even the subtree is BST, so just find the max subtree sum.\\n            int max = INT_MIN;\\n            maxSum(root, max);\\n            return max;\\n        }\\n        else\\n\\t\\t\\t// Recursive=ly find for left and right nodes, if the present node is not a valid BST.\\n            return max(getMax(root->left), getMax(root->right));\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n            return getMax(root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n//check if valid BST for given root.\\n    bool isValid(TreeNode* root, int* left, int* right)\\n    {\\n        if(root == NULL)\\n            return true;\\n        else\\n        {\\n            if(left != NULL && root->val <= *left)\\n                return false;\\n            if(right != NULL && root->val >= *right)\\n                return false;\\n            return isValid(root->left, left, &root->val) && isValid(root->right, &root->val, right);\\n        }\\n    }\\n    \\n    int maxSum(TreeNode* root, int& max)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        else\\n        {\\n            int l = maxSum(root->left, max);\\n            int r = maxSum(root->right, max);\\n            max = std::max(max, std::max(l, std::max(r, l + r + root->val)));\\n            return l + r + root->val;\\n        }\\n    }\\n    //check for valid BST in binary tree\\n    int getMax(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        if(isValid(root, NULL, NULL))\\n        {\\n\\t\\t\\t// true then even the subtree is BST, so just find the max subtree sum.\\n            int max = INT_MIN;\\n            maxSum(root, max);\\n            return max;\\n        }\\n        else\\n\\t\\t\\t// Recursive=ly find for left and right nodes, if the present node is not a valid BST.\\n            return max(getMax(root->left), getMax(root->right));\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n            return getMax(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536508,
                "title": "why-post-order-traversal-is-ideal-to-solve-this-one-solution",
                "content": "Most solutions discussed here solve this using Post Order traversal. I tried to solve this using preorder traversal (using the floor and ceiling method to check validity of BST like in [here](https://leetcode.com/problems/validate-binary-search-tree/discuss/32178/Clean-Python-Solution/31031)), and got confused.\\n\\nFor this problem we need to build the solution from the bottom-up i.e., from the leaf nodes towards the root. Only then can we check if the current sub-tree is a valid BST, and then update the maximum sum. This means post order is the ideal way to traverse the tree.\\n\\nHere\\'s a solution using this idea: \\n```python\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = 0\\n        \\n    def maxSumBST(self, root):\\n        def postOrderTraverse(node):\\n            \"\"\" \\n            Perform post order traversal of tree\\n            to determine sub trees which are BSTs\\n            and calculate maximum sum of its elements.\\n            \\n            Returns:\\n            isValidBST: True if valid BST else False\\n            currentSum: sum of current sub tree. None \\n                        if not a valid BST.\\n            currentMin: minimum value of current sub tree\\n            currentMax: maximum value of current sub tree\\n            \"\"\"\\n            if not node:\\n                return True, 0, float(\\'inf\\'), float(\\'-inf\\') # Empty sub tree\\n\\n            lValidBST, lSum, lMin, lMax = postOrderTraverse(node.left)\\n            rValidBST, rSum, rMin, rMax = postOrderTraverse(node.right)\\n\\n            # Check if current subtree is a valid BST\\n            if lValidBST and rValidBST and lMax < node.val < rMin: \\n                currSum = lSum + rSum + node.val\\n                currMin = lMin if lMin != float(\\'inf\\') else node.val\\n                currMax = rMax if rMax != float(\\'-inf\\') else node.val\\n                self.maxSum = max(self.maxSum, currSum)  # update max sum\\n                return True, currSum, currMin, currMax\\n            \\n            return False, None, None, None \\n        \\n        postOrderTraverse(root)\\n        return self.maxSum\\n```\\n\\n(Code is modified from [this post](https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531800/Python-Easy-traversal-with-explanation) for readability)\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = 0\\n        \\n    def maxSumBST(self, root):\\n        def postOrderTraverse(node):\\n            \"\"\" \\n            Perform post order traversal of tree\\n            to determine sub trees which are BSTs\\n            and calculate maximum sum of its elements.\\n            \\n            Returns:\\n            isValidBST: True if valid BST else False\\n            currentSum: sum of current sub tree. None \\n                        if not a valid BST.\\n            currentMin: minimum value of current sub tree\\n            currentMax: maximum value of current sub tree\\n            \"\"\"\\n            if not node:\\n                return True, 0, float(\\'inf\\'), float(\\'-inf\\') # Empty sub tree\\n\\n            lValidBST, lSum, lMin, lMax = postOrderTraverse(node.left)\\n            rValidBST, rSum, rMin, rMax = postOrderTraverse(node.right)\\n\\n            # Check if current subtree is a valid BST\\n            if lValidBST and rValidBST and lMax < node.val < rMin: \\n                currSum = lSum + rSum + node.val\\n                currMin = lMin if lMin != float(\\'inf\\') else node.val\\n                currMax = rMax if rMax != float(\\'-inf\\') else node.val\\n                self.maxSum = max(self.maxSum, currSum)  # update max sum\\n                return True, currSum, currMin, currMax\\n            \\n            return False, None, None, None \\n        \\n        postOrderTraverse(root)\\n        return self.maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533254,
                "title": "python-easy-to-understand-divide-and-conquer",
                "content": "The recursive helper function passes four variables: \\n1. max sum down stream from current root(including all sub tree)\\n2. sum starting from current node: \\n\\t -if current tree is a valid BST, return the sum\\n\\t -otherwise return INT_MIN value\\n3. return the min value of the tree starting from current node\\n4.  return the max value of the tree starting from current node\\n\\n1 and 2 are used for passing sum values, while 3 and 4 are used for BST validation,\\nThere is a trick for empty node case: the min is INT_MAX and max is INT_MIN.\\nBy using this trick, for the following tree:\\n        2\\n    /      \\\\\\\\\\nnull     null\\n\\nroot.val = 2, which is larger than the left sub\\'s max, which is INT_MIN\\nans 2 is smaller than the right sub\\'s min, which is INT_MAX\\n\\nsimilar question: \\nhttps://leetcode.com/problems/validate-binary-search-tree/\\nhttps://leetcode.com/problems/largest-bst-subtree/\\n```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        return self.helper(root)[0]\\n    \\n    def helper(self, root):\\n        if not root:\\n            return 0, 0, float(\"inf\"), float(\"-inf\") # max sum, current sum, min max of sub tree\\n        left_sum, left_cursum, left_min, left_max = self.helper(root.left)\\n        right_sum, right_cursum, right_min, right_max = self.helper(root.right)\\n        if root.val <= left_max or root.val >= right_min: # not a valid BST\\n            return max(left_sum, right_sum), float(\"-inf\"), float(\\'-inf\\'), float(\\'inf\\')\\n        cursum = left_cursum + right_cursum + root.val\\n        return max(left_sum, right_sum, cursum), cursum, min(left_min, root.val), max(right_max, root.val)\\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        return self.helper(root)[0]\\n    \\n    def helper(self, root):\\n        if not root:\\n            return 0, 0, float(\"inf\"), float(\"-inf\") # max sum, current sum, min max of sub tree\\n        left_sum, left_cursum, left_min, left_max = self.helper(root.left)\\n        right_sum, right_cursum, right_min, right_max = self.helper(root.right)\\n        if root.val <= left_max or root.val >= right_min: # not a valid BST\\n            return max(left_sum, right_sum), float(\"-inf\"), float(\\'-inf\\'), float(\\'inf\\')\\n        cursum = left_cursum + right_cursum + root.val\\n        return max(left_sum, right_sum, cursum), cursum, min(left_min, root.val), max(right_max, root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532881,
                "title": "python-o-n-by-dfs-85-w-hint",
                "content": "Python O(n) by DFS. 85%+\\n\\n---\\n\\n**Hint**:\\n\\nThink of **post-order DFS** to develop a algorithm to update maximum value by each summation of valid BST.\\n\\nTake care that **initial value of maximum** should be **0** to **reject negative summation value**.\\n\\n---\\n\\n\\n```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        \\n        maximum_sum = 0\\n        \\n        def sumBST( node: TreeNode):\\n            \\n            if not node:\\n                return True, 0, float(\\'inf\\'), float(\\'-inf\\')\\n            \\n            else:\\n                \\n                is_left_bst, l_sum, l_min, l_max = sumBST( node.left )\\n                is_right_bst, r_sum, r_min, r_max = sumBST( node.right )\\n \\n                nonlocal maximum_sum\\n                cur_sum = l_sum + node.val + r_sum\\n        \\n                # If current subtree is BST, then compare and update maximum_sum\\n                # Otherwise, return (False, 0, None, None) to parent level\\n            \\n                if is_left_bst and is_right_bst and l_max < node.val < r_min:\\n\\n                    cur_min = l_min if l_min != float(\\'inf\\') else node.val\\n                    cur_max = r_max if r_max != float(\\'-inf\\') else node.val\\n                    \\n                    maximum_sum = max(maximum_sum, cur_sum )\\n                    return True, cur_sum, cur_min, cur_max\\n                \\n                else:\\n                    return False, 0, None, None\\n\\n        # ----------------------------------------\\n        sumBST( root )\\n        return maximum_sum\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #98 Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)\\n\\n[Leetcode #938 Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst/)\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Binary Search Tree](https://en.wikipedia.org/wiki/Binary_search_tree)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        \\n        maximum_sum = 0\\n        \\n        def sumBST( node: TreeNode):\\n            \\n            if not node:\\n                return True, 0, float(\\'inf\\'), float(\\'-inf\\')\\n            \\n            else:\\n                \\n                is_left_bst, l_sum, l_min, l_max = sumBST( node.left )\\n                is_right_bst, r_sum, r_min, r_max = sumBST( node.right )\\n \\n                nonlocal maximum_sum\\n                cur_sum = l_sum + node.val + r_sum\\n        \\n                # If current subtree is BST, then compare and update maximum_sum\\n                # Otherwise, return (False, 0, None, None) to parent level\\n            \\n                if is_left_bst and is_right_bst and l_max < node.val < r_min:\\n\\n                    cur_min = l_min if l_min != float(\\'inf\\') else node.val\\n                    cur_max = r_max if r_max != float(\\'-inf\\') else node.val\\n                    \\n                    maximum_sum = max(maximum_sum, cur_sum )\\n                    return True, cur_sum, cur_min, cur_max\\n                \\n                else:\\n                    return False, 0, None, None\\n\\n        # ----------------------------------------\\n        sumBST( root )\\n        return maximum_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531957,
                "title": "c-concise-recursion-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int maxSumBST(TreeNode* root) {\\n        h(root);\\n        return ans;\\n    }\\n    \\n    //return value {isBST, sum_of_tree, min_value_of_tree, max_value_of_tree }\\n    vector<int> h(TreeNode* root) {\\n        if(!root) return {true, 0};\\n        auto res1 = h(root->left);\\n        auto res2 = h(root->right);\\n        if(res1[0] && (!root->left || res1[3] < root->val)) {\\n            if(res2[0] && (!root->right ||  res2[2] > root->val)) {\\n                int sum = res1[1] + res2[1] + root->val;\\n                ans = max(ans, sum);\\n                return {true, sum, root->left ? res1[2] : root->val, root->right ? res2[3] : root->val};\\n            }\\n        }\\n        return {false, 0};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int maxSumBST(TreeNode* root) {\\n        h(root);\\n        return ans;\\n    }\\n    \\n    //return value {isBST, sum_of_tree, min_value_of_tree, max_value_of_tree }\\n    vector<int> h(TreeNode* root) {\\n        if(!root) return {true, 0};\\n        auto res1 = h(root->left);\\n        auto res2 = h(root->right);\\n        if(res1[0] && (!root->left || res1[3] < root->val)) {\\n            if(res2[0] && (!root->right ||  res2[2] > root->val)) {\\n                int sum = res1[1] + res2[1] + root->val;\\n                ans = max(ans, sum);\\n                return {true, sum, root->left ? res1[2] : root->val, root->right ? res2[3] : root->val};\\n            }\\n        }\\n        return {false, 0};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531809,
                "title": "easy-java-solution-clean-code",
                "content": "```\\nprivate class BSTInfo {\\n        boolean isBST;\\n        int sum;\\n        int currentMax;\\n        int max;\\n        int min;\\n        BSTInfo(int max, int min, boolean isBST, int sum, int currentSum) {\\n            this.max = max;\\n            this.min = min;\\n            this.isBST = isBST;\\n            this.sum = sum;\\n            currentMax = currentSum;\\n        }\\n        BSTInfo() {\\n        }\\n    }\\n\\n    private int maxSum;\\n\\n    public int maxSumBST(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        int ans = util(root).currentMax;\\n        return ans<0?0:ans;\\n    }\\n\\n    private BSTInfo util(TreeNode root) {\\n        if (root == null) {\\n            return new BSTInfo( Integer.MIN_VALUE, Integer.MAX_VALUE, true, 0, 0 );\\n        }\\n\\n        if (root.left == null && root.right == null) {\\n            maxSum = Math.max(maxSum, root.val);\\n            return new BSTInfo( root.val, root.val, true, root.val, maxSum);\\n        }\\n\\n        // Store information about the left subtree\\n        BSTInfo leftTree = util(root.left);\\n\\n        // Store information about the right subtree\\n        BSTInfo rightTree = util(root.right);\\n\\n        BSTInfo bstInfo=new BSTInfo();\\n\\n        // Check If the subtree rooted under the current node is a Binary Search Tree\\n        if (leftTree.isBST && rightTree.isBST && leftTree.max < root.val && rightTree.min > root.val) {\\n            bstInfo.max = Math.max(root.val, Math.max(leftTree.max, rightTree.max));\\n            bstInfo.min = Math.min(root.val, Math.min(leftTree.min, rightTree.min));\\n            maxSum = Math.max(maxSum, rightTree.sum + root.val + leftTree.sum);\\n            bstInfo.sum = rightTree.sum + root.val + leftTree.sum;\\n            // Update the current maximum sum\\n            bstInfo.currentMax = maxSum;\\n            bstInfo.isBST = true;\\n            return bstInfo;\\n        }\\n\\n        // If the entire tree is not a Binary Search Tree then simply update the current maximum sum\\n        bstInfo.isBST = false;\\n        bstInfo.currentMax = maxSum;\\n        bstInfo.sum = rightTree.sum + root.val + leftTree.sum;\\n        return bstInfo;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate class BSTInfo {\\n        boolean isBST;\\n        int sum;\\n        int currentMax;\\n        int max;\\n        int min;\\n        BSTInfo(int max, int min, boolean isBST, int sum, int currentSum) {\\n            this.max = max;\\n            this.min = min;\\n            this.isBST = isBST;\\n            this.sum = sum;\\n            currentMax = currentSum;\\n        }\\n        BSTInfo() {\\n        }\\n    }\\n\\n    private int maxSum;\\n\\n    public int maxSumBST(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        int ans = util(root).currentMax;\\n        return ans<0?0:ans;\\n    }\\n\\n    private BSTInfo util(TreeNode root) {\\n        if (root == null) {\\n            return new BSTInfo( Integer.MIN_VALUE, Integer.MAX_VALUE, true, 0, 0 );\\n        }\\n\\n        if (root.left == null && root.right == null) {\\n            maxSum = Math.max(maxSum, root.val);\\n            return new BSTInfo( root.val, root.val, true, root.val, maxSum);\\n        }\\n\\n        // Store information about the left subtree\\n        BSTInfo leftTree = util(root.left);\\n\\n        // Store information about the right subtree\\n        BSTInfo rightTree = util(root.right);\\n\\n        BSTInfo bstInfo=new BSTInfo();\\n\\n        // Check If the subtree rooted under the current node is a Binary Search Tree\\n        if (leftTree.isBST && rightTree.isBST && leftTree.max < root.val && rightTree.min > root.val) {\\n            bstInfo.max = Math.max(root.val, Math.max(leftTree.max, rightTree.max));\\n            bstInfo.min = Math.min(root.val, Math.min(leftTree.min, rightTree.min));\\n            maxSum = Math.max(maxSum, rightTree.sum + root.val + leftTree.sum);\\n            bstInfo.sum = rightTree.sum + root.val + leftTree.sum;\\n            // Update the current maximum sum\\n            bstInfo.currentMax = maxSum;\\n            bstInfo.isBST = true;\\n            return bstInfo;\\n        }\\n\\n        // If the entire tree is not a Binary Search Tree then simply update the current maximum sum\\n        bstInfo.isBST = false;\\n        bstInfo.currentMax = maxSum;\\n        bstInfo.sum = rightTree.sum + root.val + leftTree.sum;\\n        return bstInfo;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531803,
                "title": "c-tree-bottom-up",
                "content": "```\\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    \\n    int isBst(TreeNode* root)\\n    {\\n        if(!root) return 0;\\n        if(!root->left && !root->right)\\n        {\\n            max1=max(max1,root->val);\\n            return root->val;\\n        }\\n        int left = isBst(root->left);\\n        int right = isBst(root->right);\\n        if(left!=INT_MIN && right!=INT_MIN)\\n        {\\n            if(root->left!=NULL && root->left->val>=root->val) return INT_MIN;\\n            if(root->right!=NULL && root->right->val<=root->val) return INT_MIN;\\n            int m = left+right+root->val;     \\n            max1=max(m,max1);\\n            return m;\\n        }\\n        return INT_MIN;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        isBst(root);\\n        return max1;\\n    }\\n};\\n```\\nThe above solution will not work for cases like [6,3,7,1,4,5,10]\\n\\nBelow is the solution which handles these cases too.\\nBasically at each node we need to keep track of max  node in left subtree and min node in right subtree.\\n\\n```\\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    \\n    vector<int> isBst(TreeNode* root)\\n    {\\n        if(!root) return {0, INT_MIN, INT_MIN};\\n        if(!root->left && !root->right)\\n        {\\n            max1 = max(max1, root->val);\\n            return {root->val, root->val, root->val};\\n        }\\n        vector<int> left = isBst(root->left);\\n        vector<int> right = isBst(root->right);\\n        \\n        if(left[0] != INT_MIN && right[0] != INT_MIN)\\n        {\\n            if(root->left != NULL && left[1] >= root->val) return {INT_MIN, INT_MIN, INT_MIN};\\n            \\n            if(root->right != NULL && right[2] <= root->val) return {INT_MIN, INT_MIN, INT_MIN};\\n         \\n            int sum = left[0] + right[0] + root->val;     // current sum\\n            \\n            max1 = max(sum,max1);                           //result till now\\n            \\n            int maxTillNow = 0;\\n            if(left[1]==INT_MIN)     //Dont consider left subtree if it does  not exist eg:{16,null,17}          \\n                maxTillNow = max(root->val, right[2]);  \\n            else      //dont consider right subtree if does not exist eg: {16,15,null}\\n                maxTillNow = max(left[1], max(root->val, right[2]==INT_MIN? root->val:right[2]));\\n            \\n            int minTillNow = 0;\\t\\t\\t\\n            if(right[2]==INT_MIN)    //dont oconsider right subtree if it does not exist eg:{16,15,null}\\n                minTillNow = min(root->val, left[1]);  \\n\\t\\t\\telse    //dont consider left subtree if it does not exist eg:{16,null,17}\\n                minTillNow = min(right[2], min(root->val, left[1]==INT_MIN? root->val:left[1]));       \\n            \\n            return {sum, maxTillNow, minTillNow};\\n        }\\n        return {INT_MIN, INT_MIN, INT_MIN};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        isBst(root);\\n        return max1;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    \\n    int isBst(TreeNode* root)\\n    {\\n        if(!root) return 0;\\n        if(!root->left && !root->right)\\n        {\\n            max1=max(max1,root->val);\\n            return root->val;\\n        }\\n        int left = isBst(root->left);\\n        int right = isBst(root->right);\\n        if(left!=INT_MIN && right!=INT_MIN)\\n        {\\n            if(root->left!=NULL && root->left->val>=root->val) return INT_MIN;\\n            if(root->right!=NULL && root->right->val<=root->val) return INT_MIN;\\n            int m = left+right+root->val;     \\n            max1=max(m,max1);\\n            return m;\\n        }\\n        return INT_MIN;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        isBst(root);\\n        return max1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    \\n    vector<int> isBst(TreeNode* root)\\n    {\\n        if(!root) return {0, INT_MIN, INT_MIN};\\n        if(!root->left && !root->right)\\n        {\\n            max1 = max(max1, root->val);\\n            return {root->val, root->val, root->val};\\n        }\\n        vector<int> left = isBst(root->left);\\n        vector<int> right = isBst(root->right);\\n        \\n        if(left[0] != INT_MIN && right[0] != INT_MIN)\\n        {\\n            if(root->left != NULL && left[1] >= root->val) return {INT_MIN, INT_MIN, INT_MIN};\\n            \\n            if(root->right != NULL && right[2] <= root->val) return {INT_MIN, INT_MIN, INT_MIN};\\n         \\n            int sum = left[0] + right[0] + root->val;     // current sum\\n            \\n            max1 = max(sum,max1);                           //result till now\\n            \\n            int maxTillNow = 0;\\n            if(left[1]==INT_MIN)     //Dont consider left subtree if it does  not exist eg:{16,null,17}          \\n                maxTillNow = max(root->val, right[2]);  \\n            else      //dont consider right subtree if does not exist eg: {16,15,null}\\n                maxTillNow = max(left[1], max(root->val, right[2]==INT_MIN? root->val:right[2]));\\n            \\n            int minTillNow = 0;\\t\\t\\t\\n            if(right[2]==INT_MIN)    //dont oconsider right subtree if it does not exist eg:{16,15,null}\\n                minTillNow = min(root->val, left[1]);  \\n\\t\\t\\telse    //dont consider left subtree if it does not exist eg:{16,null,17}\\n                minTillNow = min(right[2], min(root->val, left[1]==INT_MIN? root->val:left[1]));       \\n            \\n            return {sum, maxTillNow, minTillNow};\\n        }\\n        return {INT_MIN, INT_MIN, INT_MIN};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        isBst(root);\\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995873,
                "title": "simple-cpp-solution-with-aproach-and-comments-92-beats-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n // properties we need to solve this\\n class info{\\n public:\\n   int maxi; \\n   int mini;\\n   bool isBst;\\n   int sum ;\\n };\\ninfo solve(TreeNode*root,int &ans){\\n    // if root== NULL then simply return the maximum and minimum and the currsum =0\\n    if(root==NULL){\\n        return {INT_MIN,INT_MAX,true,0};\\n    }\\n    // left call\\n    info left= solve(root->left,ans);\\n    // right\\n    info right = solve(root->right,ans);\\n    info currNode;\\n    //calculation for the sum of the current Node\\n    currNode.sum = left.sum +right.sum +root->val;\\n    //current node ke maximum value is define as\\n    // maximum of current Nodes val and maximum of right subtree\\n    currNode.maxi = max(root->val,right.maxi);\\n    // currNode ke minimum is defines as minimum of roots val and minimum of left subtree\\n    currNode.mini = min(root->val,left.mini);\\n    // now condition for being the current node is a bst\\n    // 1.left and right subtree are also bst \\n    //2.roots val lies btw maximum of left subtree ans minimum of right subtree\\n    if(left.isBst && right.isBst && \\n    (root->val>left.maxi && root->val<right.mini)){\\n        currNode.isBst= true;\\n    }\\n    else{\\n       currNode.isBst = false;\\n    }\\n    //if the current node is bst and add that node value also\\n    if(currNode.isBst){\\n        ans = max(ans,currNode.sum);\\n    }\\n    return currNode;\\n}\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int maxSum =0;\\n        info temp = solve(root,maxSum);\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n // properties we need to solve this\\n class info{\\n public:\\n   int maxi; \\n   int mini;\\n   bool isBst;\\n   int sum ;\\n };\\ninfo solve(TreeNode*root,int &ans){\\n    // if root== NULL then simply return the maximum and minimum and the currsum =0\\n    if(root==NULL){\\n        return {INT_MIN,INT_MAX,true,0};\\n    }\\n    // left call\\n    info left= solve(root->left,ans);\\n    // right\\n    info right = solve(root->right,ans);\\n    info currNode;\\n    //calculation for the sum of the current Node\\n    currNode.sum = left.sum +right.sum +root->val;\\n    //current node ke maximum value is define as\\n    // maximum of current Nodes val and maximum of right subtree\\n    currNode.maxi = max(root->val,right.maxi);\\n    // currNode ke minimum is defines as minimum of roots val and minimum of left subtree\\n    currNode.mini = min(root->val,left.mini);\\n    // now condition for being the current node is a bst\\n    // 1.left and right subtree are also bst \\n    //2.roots val lies btw maximum of left subtree ans minimum of right subtree\\n    if(left.isBst && right.isBst && \\n    (root->val>left.maxi && root->val<right.mini)){\\n        currNode.isBst= true;\\n    }\\n    else{\\n       currNode.isBst = false;\\n    }\\n    //if the current node is bst and add that node value also\\n    if(currNode.isBst){\\n        ans = max(ans,currNode.sum);\\n    }\\n    return currNode;\\n}\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int maxSum =0;\\n        info temp = solve(root,maxSum);\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994390,
                "title": "c-the-cleanest-solution-thus-far",
                "content": "The approach is simple, track the minimum, maximum, sum, and whether it is a valid BST, for each subtree, in a bottom to top fashion (Postorder).\\n\\nOn first glance, it appears lengthy but just focus on the dfs part - traverse in postorder and now update your 4 variables properly.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct TreeDetails {\\n        bool isBST;\\n        int minm;\\n        int maxm;\\n        int sum;\\n        TreeDetails (bool a, int b, int c, int d) {\\n            isBST = a;\\n            minm = b;\\n            maxm = c;\\n            sum = d;\\n        }\\n    };\\n\\n// core function\\n    TreeDetails* solve (TreeNode* root, int &ans) {\\n        if (!root) return new TreeDetails (true, INT_MAX, INT_MIN, 0);\\n\\n        // traverse in postorder\\n        TreeDetails *left = solve(root->left, ans);\\n        TreeDetails *right = solve(root->right, ans);\\n\\n        // CORE UPDATE logic for the 4 variables\\n        bool isBST = left->isBST && right->isBST && root->val > left->maxm && root->val < right->minm ;\\n\\n        int sum = left->sum + right->sum + root->val;\\n        if (isBST) ans = max(sum, ans);\\n\\n        int minm = min(root->val, min(left->minm, right->minm));\\n        int maxm = max(root->val, max(left->maxm, right->maxm));\\n\\n        //return\\n        return new TreeDetails (isBST, minm, maxm, sum);\\n    }\\n\\n\\n// driver function\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct TreeDetails {\\n        bool isBST;\\n        int minm;\\n        int maxm;\\n        int sum;\\n        TreeDetails (bool a, int b, int c, int d) {\\n            isBST = a;\\n            minm = b;\\n            maxm = c;\\n            sum = d;\\n        }\\n    };\\n\\n// core function\\n    TreeDetails* solve (TreeNode* root, int &ans) {\\n        if (!root) return new TreeDetails (true, INT_MAX, INT_MIN, 0);\\n\\n        // traverse in postorder\\n        TreeDetails *left = solve(root->left, ans);\\n        TreeDetails *right = solve(root->right, ans);\\n\\n        // CORE UPDATE logic for the 4 variables\\n        bool isBST = left->isBST && right->isBST && root->val > left->maxm && root->val < right->minm ;\\n\\n        int sum = left->sum + right->sum + root->val;\\n        if (isBST) ans = max(sum, ans);\\n\\n        int minm = min(root->val, min(left->minm, right->minm));\\n        int maxm = max(root->val, max(left->maxm, right->maxm));\\n\\n        //return\\n        return new TreeDetails (isBST, minm, maxm, sum);\\n    }\\n\\n\\n// driver function\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916346,
                "title": "basic-recursion-easy-approach-post-order-no-oops-concept",
                "content": "# Intuition\\nWe cant go to every node and and check for binary tree. If we check for every node, then it would surely give tle. Hence we need to go in one traversal and check for binary seach tree and calculate sum.\\n\\nWe say tree BST when root is greater than left and less than the right.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFor base case,  when we are at leaf node, they are always a bst in themselves\\nwhen we get null, we return min value as INT_MAX and max value as INT_MIN. So when it gets at leaf it satisfiy for bst.\\nnow at evety node we just check for bst\\n\\nif BST-->we take the sum of left subtree, right subtree and root.\\n\\nif value of left is less then root, and right is less then right, then we update our ans, mx, min variables,\\n\\notherwise we set the mx = INT_MAX, mn = INT_MIN\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n- Time complexity:\\n TC-> O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1) but stack space is used\\nHence O(H) where H is height of tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nint rec(TreeNode *root,int &mx,int &mn,int &a)\\n    {\\n        if(!root) return 0;\\n        \\n\\t// lmn,lmx will find the minimum and maximum node in the left subtree \\n\\t// similarly, rmn,rmx will find minimum and maximum node in the right subtree\\n\\t\\t\\n        int lmn,rmn,rmx,lmx;\\n        \\n        lmn=rmn=INT_MAX;\\n        lmx=rmx=INT_MIN;\\n\\t\\t\\n        int l=rec(root->left,lmx,lmn,a);\\n        int r=rec(root->right,rmx,rmn,a);\\n        \\n        int val=l+r+root->val;\\n    \\n\\t// if the left maximum is less than and right minimum is greater than current node\\n\\t// than the subtree rooted at current node is BST.\\n\\t\\t\\n        if((lmx<(root->val)) and (rmn>(root->val)))\\n        {\\n            a=max(a,val);\\n            mx=max(root->val,rmx);\\n            mn=min(root->val,lmn);\\n        }\\n        else\\n        {\\n            mx=INT_MAX;\\n            mn=INT_MIN;\\n        }\\n        return val;        \\n    }\\n    public:\\n    \\n    int maxSumBST(TreeNode* root) {\\n        int a=0;\\n        int mx=INT_MIN,mn=INT_MAX;\\n        rec(root,mx,mn,a);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nint rec(TreeNode *root,int &mx,int &mn,int &a)\\n    {\\n        if(!root) return 0;\\n        \\n\\t// lmn,lmx will find the minimum and maximum node in the left subtree \\n\\t// similarly, rmn,rmx will find minimum and maximum node in the right subtree\\n\\t\\t\\n        int lmn,rmn,rmx,lmx;\\n        \\n        lmn=rmn=INT_MAX;\\n        lmx=rmx=INT_MIN;\\n\\t\\t\\n        int l=rec(root->left,lmx,lmn,a);\\n        int r=rec(root->right,rmx,rmn,a);\\n        \\n        int val=l+r+root->val;\\n    \\n\\t// if the left maximum is less than and right minimum is greater than current node\\n\\t// than the subtree rooted at current node is BST.\\n\\t\\t\\n        if((lmx<(root->val)) and (rmn>(root->val)))\\n        {\\n            a=max(a,val);\\n            mx=max(root->val,rmx);\\n            mn=min(root->val,lmn);\\n        }\\n        else\\n        {\\n            mx=INT_MAX;\\n            mn=INT_MIN;\\n        }\\n        return val;        \\n    }\\n    public:\\n    \\n    int maxSumBST(TreeNode* root) {\\n        int a=0;\\n        int mx=INT_MIN,mn=INT_MAX;\\n        rec(root,mx,mn,a);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143402,
                "title": "c",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    class info\\n    {\\n        public:\\n        int maxi;\\n        int mini;\\n        bool isBST;\\n        int sum;\\n    };\\n\\n    info solve(TreeNode* root, int &maxsum)\\n    {\\n        if(!root)\\n            return {INT_MIN, INT_MAX, true, 0};\\n        \\n        info left = solve(root->left, maxsum);\\n        info right = solve(root->right, maxsum);\\n\\n        info currNode;\\n\\n        currNode.sum = left.sum+right.sum+root->val;\\n        currNode.maxi = max(root->val, right.maxi);\\n        currNode.mini = min(root->val, left.mini);\\n\\n        if(left.isBST && right.isBST && (root->val > left.maxi && root->val < right.mini))\\n            currNode.isBST = true;\\n        else currNode.isBST = false;\\n        \\n        if(currNode.isBST)\\n            maxsum = max(maxsum, currNode.sum);\\n            \\n        return currNode;\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int maxsum=0;\\n        info temp = solve(root, maxsum);\\n        return maxsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    class info\\n    {\\n        public:\\n        int maxi;\\n        int mini;\\n        bool isBST;\\n        int sum;\\n    };\\n\\n    info solve(TreeNode* root, int &maxsum)\\n    {\\n        if(!root)\\n            return {INT_MIN, INT_MAX, true, 0};\\n        \\n        info left = solve(root->left, maxsum);\\n        info right = solve(root->right, maxsum);\\n\\n        info currNode;\\n\\n        currNode.sum = left.sum+right.sum+root->val;\\n        currNode.maxi = max(root->val, right.maxi);\\n        currNode.mini = min(root->val, left.mini);\\n\\n        if(left.isBST && right.isBST && (root->val > left.maxi && root->val < right.mini))\\n            currNode.isBST = true;\\n        else currNode.isBST = false;\\n        \\n        if(currNode.isBST)\\n            maxsum = max(maxsum, currNode.sum);\\n            \\n        return currNode;\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int maxsum=0;\\n        info temp = solve(root, maxsum);\\n        return maxsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957150,
                "title": "java-readable-recursion",
                "content": "```\\nclass Solution {\\n    class TreeInfo {\\n        boolean isBST;\\n        TreeNode min;\\n        TreeNode max;\\n        int sum;\\n        int globalMax;\\n        \\n        public TreeInfo(boolean isBST, TreeNode min, TreeNode max, int sum, int globalMax) {\\n            this.isBST = isBST;\\n            this.min = min;\\n            this.max = max;\\n            this.sum = sum;\\n            this.globalMax = globalMax;\\n        }\\n    }\\n    \\n    public int maxSumBST(TreeNode root) {\\n        return helper(root).globalMax;\\n    }\\n    \\n    private TreeInfo helper(TreeNode root) {\\n        if (root == null) return new TreeInfo(true, null, null, 0, 0);\\n        if (root.left == null && root.right == null) {\\n            return new TreeInfo(true, root, root, root.val, Math.max(0, root.val));\\n        }\\n        TreeInfo left = helper(root.left);\\n        TreeInfo right = helper(root.right);\\n\\n        if (!left.isBST\\n            || !right.isBST\\n            || root.left != null && root.val <= left.max.val \\n            || root.right != null && root.val >= right.min.val) {\\n            return new TreeInfo(false, null, null, 0, Math.max(left.globalMax, right.globalMax));\\n        } \\n        \\n        int curSum = left.sum + right.sum + root.val;\\n        TreeNode min = root.left == null ? root : left.min;\\n        TreeNode max = root.right == null ? root : right.max;\\n        return new TreeInfo(true, min, max, curSum, Math.max(curSum, Math.max(left.globalMax, right.globalMax)));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class TreeInfo {\\n        boolean isBST;\\n        TreeNode min;\\n        TreeNode max;\\n        int sum;\\n        int globalMax;\\n        \\n        public TreeInfo(boolean isBST, TreeNode min, TreeNode max, int sum, int globalMax) {\\n            this.isBST = isBST;\\n            this.min = min;\\n            this.max = max;\\n            this.sum = sum;\\n            this.globalMax = globalMax;\\n        }\\n    }\\n    \\n    public int maxSumBST(TreeNode root) {\\n        return helper(root).globalMax;\\n    }\\n    \\n    private TreeInfo helper(TreeNode root) {\\n        if (root == null) return new TreeInfo(true, null, null, 0, 0);\\n        if (root.left == null && root.right == null) {\\n            return new TreeInfo(true, root, root, root.val, Math.max(0, root.val));\\n        }\\n        TreeInfo left = helper(root.left);\\n        TreeInfo right = helper(root.right);\\n\\n        if (!left.isBST\\n            || !right.isBST\\n            || root.left != null && root.val <= left.max.val \\n            || root.right != null && root.val >= right.min.val) {\\n            return new TreeInfo(false, null, null, 0, Math.max(left.globalMax, right.globalMax));\\n        } \\n        \\n        int curSum = left.sum + right.sum + root.val;\\n        TreeNode min = root.left == null ? root : left.min;\\n        TreeNode max = root.right == null ? root : right.max;\\n        return new TreeInfo(true, min, max, curSum, Math.max(curSum, Math.max(left.globalMax, right.globalMax)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820159,
                "title": "inorder-traversal-by-striver-method-85-faster",
                "content": "# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(1)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n// created class container to store maximum,minimum,and maxsum values\\n class cont{\\n     public:\\n        int maxsum;\\n        int maxval;\\n        int minval;\\n    cont(int ms,int mx,int mi){\\n        maxsum=ms;\\n        maxval=mx;\\n        minval=mi;\\n    }\\n };\\nclass Solution {\\npublic:\\n    int res;    // created this variable to keep track on maxsum till now\\n    cont solve(TreeNode* root){\\n        if(root==NULL){\\n            return cont(0,INT_MIN,INT_MAX);\\n        }\\n\\n        auto left = solve(root->left);\\n        auto right=solve(root->right);\\n\\n        if((root->val > left.maxval) && (root->val < right.minval)){\\n            int s=root->val+left.maxsum+right.maxsum;\\n            res=max(res,s);\\n            return cont(s,max(root->val,right.maxval),min(root->val,left.minval));\\n        }\\n\\n        return cont(max(left.maxsum,right.maxsum),INT_MAX,INT_MIN);\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        res=0;\\n        solve(root).maxsum;\\n        return res; \\n    }\\n};\\n```rec\\n// ONE PIECE IS REAL //\\n\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n// created class container to store maximum,minimum,and maxsum values\\n class cont{\\n     public:\\n        int maxsum;\\n        int maxval;\\n        int minval;\\n    cont(int ms,int mx,int mi){\\n        maxsum=ms;\\n        maxval=mx;\\n        minval=mi;\\n    }\\n };\\nclass Solution {\\npublic:\\n    int res;    // created this variable to keep track on maxsum till now\\n    cont solve(TreeNode* root){\\n        if(root==NULL){\\n            return cont(0,INT_MIN,INT_MAX);\\n        }\\n\\n        auto left = solve(root->left);\\n        auto right=solve(root->right);\\n\\n        if((root->val > left.maxval) && (root->val < right.minval)){\\n            int s=root->val+left.maxsum+right.maxsum;\\n            res=max(res,s);\\n            return cont(s,max(root->val,right.maxval),min(root->val,left.minval));\\n        }\\n\\n        return cont(max(left.maxsum,right.maxsum),INT_MAX,INT_MIN);\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        res=0;\\n        solve(root).maxsum;\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678525,
                "title": "java-tc-o-n-sc-o-1-post-order-traversal-easy-explaination",
                "content": "**APPROACH**\\nFirst we check if it\\'s a valid BST. IF it is a valid BST , we take the max sum till now ```max = Math.max(max,root.val + left.maxsum + right.maxsum);``` and move in upward direction to look for another valid BST with greater sum .\\n\\n**BST VALIDATION**\\n*Node value must be greater than the largest value of left tree and must be smaller than the smallest value of right tree*\\n\\n**COMPLEXITIES**\\n **  TC :  O(N)\\n   SC : O(1) (except recursive stack)**\\n   \\n   **EXPLAINATION**\\n   We just start doing post order traversal and if it\\'s a valid BST we calculate our maximum till now and compute maxValue on the left , minValue on the right and total sum root.val + leftmaxsum + rightmaxsum\\n   ```\\n   if(left.maxValue < root.val && root.val < right.minValue){\\n             max = Math.max(max,root.val + left.maxsum + right.maxsum);\\n            return new NodeValue(Math.max(root.val,right.maxValue), Math.min(root.val,left.minValue),root.val+left.maxsum + right.maxsum);\\n           \\n        }\\n   ```\\n   We create a class named as NodeValue which consists of 3 things :\\n   ```\\n   class NodeValue{\\n    // maxValue maxValue,minValue for checking Validation of BST and maxsum of that valid BST.\\n    public int maxValue,minValue,maxsum;\\n    NodeValue(int max, int min,int maxsum){\\n        this.maxValue = max;\\n        this.minValue = min;\\n        this.maxsum = maxsum;\\n    }\\n}\\n```\\n**CODE**\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass NodeValue{\\n    // maxValue maxValue,minValue for checking Validation of BST and maxsum of that valid BST.\\n    public int maxValue,minValue,maxsum;\\n    NodeValue(int max, int min,int maxsum){\\n        this.maxValue = max;\\n        this.minValue = min;\\n        this.maxsum = maxsum;\\n    }\\n}\\n\\nclass Solution {\\n    int max = 0;\\n    public NodeValue maxSumBSTHelper(TreeNode root){\\n        //An empty tree or bst of size 0;\\n        if(root == null){\\n            return new NodeValue(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        }\\n        //Get values from left and right subtree\\n        NodeValue left = maxSumBSTHelper(root.left);\\n        NodeValue right = maxSumBSTHelper(root.right);\\n        \\n        //Check if it\\'s a valid bst\\n        if(left.maxValue < root.val && root.val < right.minValue){\\n            //It is a BST , calculate maxsum tillnow.\\n             max = Math.max(max,root.val + left.maxsum + right.maxsum);\\n            return new NodeValue(Math.max(root.val,right.maxValue), Math.min(root.val,left.minValue),root.val+left.maxsum + right.maxsum);\\n           \\n        }\\n        //Otherwise return [INF,-INF] so that parent can\\'t be a bst.\\n        return new NodeValue(Integer.MAX_VALUE,Integer.MIN_VALUE,Math.max(left.maxsum,right.maxsum));\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        maxSumBSTHelper(root);\\n        return max;\\n    }\\n}\\n```\\n***IF YOU LIKE THE SOLUTION MAKE SURE TO UPVOTE IT\\nTHANK YOU.*\\n\\t\\n\\n\\t\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```max = Math.max(max,root.val + left.maxsum + right.maxsum);```\n```\\n   if(left.maxValue < root.val && root.val < right.minValue){\\n             max = Math.max(max,root.val + left.maxsum + right.maxsum);\\n            return new NodeValue(Math.max(root.val,right.maxValue), Math.min(root.val,left.minValue),root.val+left.maxsum + right.maxsum);\\n           \\n        }\\n   ```\n```\\n   class NodeValue{\\n    // maxValue maxValue,minValue for checking Validation of BST and maxsum of that valid BST.\\n    public int maxValue,minValue,maxsum;\\n    NodeValue(int max, int min,int maxsum){\\n        this.maxValue = max;\\n        this.minValue = min;\\n        this.maxsum = maxsum;\\n    }\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass NodeValue{\\n    // maxValue maxValue,minValue for checking Validation of BST and maxsum of that valid BST.\\n    public int maxValue,minValue,maxsum;\\n    NodeValue(int max, int min,int maxsum){\\n        this.maxValue = max;\\n        this.minValue = min;\\n        this.maxsum = maxsum;\\n    }\\n}\\n\\nclass Solution {\\n    int max = 0;\\n    public NodeValue maxSumBSTHelper(TreeNode root){\\n        //An empty tree or bst of size 0;\\n        if(root == null){\\n            return new NodeValue(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        }\\n        //Get values from left and right subtree\\n        NodeValue left = maxSumBSTHelper(root.left);\\n        NodeValue right = maxSumBSTHelper(root.right);\\n        \\n        //Check if it\\'s a valid bst\\n        if(left.maxValue < root.val && root.val < right.minValue){\\n            //It is a BST , calculate maxsum tillnow.\\n             max = Math.max(max,root.val + left.maxsum + right.maxsum);\\n            return new NodeValue(Math.max(root.val,right.maxValue), Math.min(root.val,left.minValue),root.val+left.maxsum + right.maxsum);\\n           \\n        }\\n        //Otherwise return [INF,-INF] so that parent can\\'t be a bst.\\n        return new NodeValue(Integer.MAX_VALUE,Integer.MIN_VALUE,Math.max(left.maxsum,right.maxsum));\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        maxSumBSTHelper(root);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658716,
                "title": "c-efficient-easy-understanding-recursion-solution",
                "content": "```\\n\\nstruct tri\\n{\\n    int min,max,sum;\\n    tri(int a,int b,int c)\\n    {\\n        min = a;\\n        max= b;\\n        sum = c;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    tri solve(TreeNode *root, int& res)\\n    {\\n        if(root == NULL)\\n        {\\n            tri t(INT_MAX,INT_MIN,0);\\n            return t;\\n        }\\n        \\n        \\n        tri a = solve(root->left,res);  //recursion for left sub tree\\n\\t\\ttri b = solve(root->right,res); //recursion for right sub tree\\n        \\n        \\n        if( (a.max < root->val) && (b.min >root->val))  // root is in valid range ang forms BST\\n        {\\n            res = max( { res, a.sum+b.sum+root->val});  // update the result\\n            tri t( min({a.min,b.min,root->val}), max({a.max,b.max,root->val}), a.sum+b.sum+root->val);  // return min ,max , sum of sub tree to parent\\n            return t;\\n        }\\n        else\\n        {\\n            tri t(INT_MIN ,INT_MAX , INT_MIN);     //return min ,max , sum of sub tree to parent\\n            return t;\\n        }\\n            \\n    }\\n    int maxSumBST(TreeNode* root) \\n    {\\n        int res=0;\\n        solve(root,res);\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nstruct tri\\n{\\n    int min,max,sum;\\n    tri(int a,int b,int c)\\n    {\\n        min = a;\\n        max= b;\\n        sum = c;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    tri solve(TreeNode *root, int& res)\\n    {\\n        if(root == NULL)\\n        {\\n            tri t(INT_MAX,INT_MIN,0);\\n            return t;\\n        }\\n        \\n        \\n        tri a = solve(root->left,res);  //recursion for left sub tree\\n\\t\\ttri b = solve(root->right,res); //recursion for right sub tree\\n        \\n        \\n        if( (a.max < root->val) && (b.min >root->val))  // root is in valid range ang forms BST\\n        {\\n            res = max( { res, a.sum+b.sum+root->val});  // update the result\\n            tri t( min({a.min,b.min,root->val}), max({a.max,b.max,root->val}), a.sum+b.sum+root->val);  // return min ,max , sum of sub tree to parent\\n            return t;\\n        }\\n        else\\n        {\\n            tri t(INT_MIN ,INT_MAX , INT_MIN);     //return min ,max , sum of sub tree to parent\\n            return t;\\n        }\\n            \\n    }\\n    int maxSumBST(TreeNode* root) \\n    {\\n        int res=0;\\n        solve(root,res);\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592309,
                "title": "c-most-intuitive-and-self-explanatory-solution",
                "content": "Most intuitive solution: Time: O(N), Space: O(1)\\n\\n```\\nclass Data {\\n    public:\\n    int minVal;\\n    int maxVal;\\n    int sum;\\n    bool isBST;\\n};\\n\\nclass Solution {\\npublic:\\n    Data solve(TreeNode *root, int &ans) {\\n        if (!root) {\\n            return {INT_MAX, INT_MIN, 0, true};\\n        }\\n        \\n        Data left = solve(root -> left, ans);\\n        Data right = solve(root -> right, ans);\\n        \\n        Data curr;\\n        curr.minVal = min(left.minVal, root -> val);\\n        curr.maxVal = max(right.maxVal, root -> val);\\n        curr.isBST = (left.isBST and right.isBST) and \\n            (root -> val > left.maxVal and root -> val < right.minVal);\\n        curr.sum = left.sum + right.sum + root -> val;\\n        \\n        if (curr.isBST) {\\n            ans = max(ans, curr.sum);\\n        }\\n        return curr;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        if (!root) return 0;\\n        int ans = 0;\\n        Data temp = solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Data {\\n    public:\\n    int minVal;\\n    int maxVal;\\n    int sum;\\n    bool isBST;\\n};\\n\\nclass Solution {\\npublic:\\n    Data solve(TreeNode *root, int &ans) {\\n        if (!root) {\\n            return {INT_MAX, INT_MIN, 0, true};\\n        }\\n        \\n        Data left = solve(root -> left, ans);\\n        Data right = solve(root -> right, ans);\\n        \\n        Data curr;\\n        curr.minVal = min(left.minVal, root -> val);\\n        curr.maxVal = max(right.maxVal, root -> val);\\n        curr.isBST = (left.isBST and right.isBST) and \\n            (root -> val > left.maxVal and root -> val < right.minVal);\\n        curr.sum = left.sum + right.sum + root -> val;\\n        \\n        if (curr.isBST) {\\n            ans = max(ans, curr.sum);\\n        }\\n        return curr;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        if (!root) return 0;\\n        int ans = 0;\\n        Data temp = solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296755,
                "title": "c-recursion-using-minimum-and-maximum-logic",
                "content": "logic is simple, recursive function returns 3 values ie.\\n1.total of BST (including left, right, node) (return 0 if it is not valid BST), \\n2. minimum value in that tree, \\n3. maximum value in that tree.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector<int> rec(TreeNode* root,int &ans){          \\n        if(root==NULL){\\n            return {0,INT_MAX,INT_MIN};             //will satisfy every node \\n        }\\n        vector<int> l=rec(root->left,ans);\\n        vector<int> r=rec(root->right,ans);\\n        \\n        if(l[2]<root->val && r[1]>root->val){        // r[1] has minimum value in right sub tree and l[2] has maximum value in left sub tree \\n            ans=max(ans,root->val+l[0]+r[0]);          //update ans when condition true \\n            return {root->val+l[0]+r[0],\\n                    min(root->val,l[1]),               //update new minimum\\n                    max(root->val,r[2])                //update new maximum \\n                   };\\n        }\\n        else{\\n            return {0,INT_MIN,INT_MAX};         //will not satisfy any node above this tree\\n        }\\n    }\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        rec(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector<int> rec(TreeNode* root,int &ans){          \\n        if(root==NULL){\\n            return {0,INT_MAX,INT_MIN};             //will satisfy every node \\n        }\\n        vector<int> l=rec(root->left,ans);\\n        vector<int> r=rec(root->right,ans);\\n        \\n        if(l[2]<root->val && r[1]>root->val){        // r[1] has minimum value in right sub tree and l[2] has maximum value in left sub tree \\n            ans=max(ans,root->val+l[0]+r[0]);          //update ans when condition true \\n            return {root->val+l[0]+r[0],\\n                    min(root->val,l[1]),               //update new minimum\\n                    max(root->val,r[2])                //update new maximum \\n                   };\\n        }\\n        else{\\n            return {0,INT_MIN,INT_MAX};         //will not satisfy any node above this tree\\n        }\\n    }\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        rec(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290433,
                "title": "c-solution-fully-explained-similar-like-largest-bst-in-binary-tree",
                "content": "```\\n\\n// Plz upvote if it help :)\\n\\nclass info{\\n    public:\\n    // Data member\\n    int maxi;\\n    int mini;\\n    bool isBst;\\n    int size;\\n    int key;\\n};\\n\\ninfo solve(TreeNode* root,int &ans){\\n    // base case\\n    if(root == NULL){\\n        // We need to return {maxi,mini,isBst,size,key} \\n        // We treat Null as Bst and size is consider as 0\\n        \\n        return {INT_MIN,INT_MAX,true,0,0};\\n    }\\n    \\n    // Doing postorder traversal\\n    info left = solve(root->left,ans);\\n    info right = solve(root->right,ans);\\n    \\n    info currentNode;\\n    // storing maximum and minimum from left and right and current root\\n    currentNode.maxi = max(right.maxi,root->val);\\n    currentNode.mini = min(left.mini,root->val);\\n    currentNode.size = left.size + right.size + 1;\\n    \\n    currentNode.key = left.key + right.key + root->val;\\n    \\n    // checking if current node is valid BST or not\\n    if(left.isBst && right.isBst && root->val > left.maxi && root->val < right.mini){\\n        currentNode.isBst = true;\\n    }\\n    else{\\n        currentNode.isBst = false;\\n    }\\n    \\n    // updating answer\\n    if(currentNode.isBst){\\n        ans = max(ans,currentNode.key);\\n    }\\n    \\n    return currentNode;\\n}\\n\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        \\n        solve(root,ans);\\n        \\n        return ans;\\n    }\\n};\\n\\n// plz upvote if it help :)\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\n// Plz upvote if it help :)\\n\\nclass info{\\n    public:\\n    // Data member\\n    int maxi;\\n    int mini;\\n    bool isBst;\\n    int size;\\n    int key;\\n};\\n\\ninfo solve(TreeNode* root,int &ans){\\n    // base case\\n    if(root == NULL){\\n        // We need to return {maxi,mini,isBst,size,key} \\n        // We treat Null as Bst and size is consider as 0\\n        \\n        return {INT_MIN,INT_MAX,true,0,0};\\n    }\\n    \\n    // Doing postorder traversal\\n    info left = solve(root->left,ans);\\n    info right = solve(root->right,ans);\\n    \\n    info currentNode;\\n    // storing maximum and minimum from left and right and current root\\n    currentNode.maxi = max(right.maxi,root->val);\\n    currentNode.mini = min(left.mini,root->val);\\n    currentNode.size = left.size + right.size + 1;\\n    \\n    currentNode.key = left.key + right.key + root->val;\\n    \\n    // checking if current node is valid BST or not\\n    if(left.isBst && right.isBst && root->val > left.maxi && root->val < right.mini){\\n        currentNode.isBst = true;\\n    }\\n    else{\\n        currentNode.isBst = false;\\n    }\\n    \\n    // updating answer\\n    if(currentNode.isBst){\\n        ans = max(ans,currentNode.key);\\n    }\\n    \\n    return currentNode;\\n}\\n\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        \\n        solve(root,ans);\\n        \\n        return ans;\\n    }\\n};\\n\\n// plz upvote if it help :)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199669,
                "title": "c-clean-code-with-explanations",
                "content": "**Approach**\\nThrough instance of helper class, we will expect to get the maximum and minimum values in right and left subtrees. Also the sum of nodes in left and rigth subtrees and a variable isBst which will tell that the subtree is BST or not.\\n\\nFor a particualar node, if either of the left or right subtree is not BST, then the subtree through the current node will also not be a BST. If both of the subtrees are BST, then we will check if the subtree through the current node is a BST or not i.e., \\n`root->val > left subtree\\'s max value && root->val < right subtree\\'s min value`\\n\\n**CODE**\\n```\\nclass Solution {\\npublic:\\n    // Helper Class\\n    class Helper {\\n        public: \\n        int maxi, mini, sum, isBST;\\n        Helper() {\\n            maxi = -40000; mini = 40000; sum = 0; isBST = 1;\\n        }\\n    };\\n    // Default object for base case\\n    Helper hh;\\n    // This will store the max sum for a BST\\n    int maxSum = 0;\\n    Helper dfs(TreeNode *root) {\\n        if(!root) {\\n            return hh;\\n        }\\n        Helper l = dfs(root->left);\\n        Helper r = dfs(root->right);\\n        Helper h;\\n        // If either of the subtrees is not BST, subtree through current node cannot be BST\\n\\t    // Also if current node is less than the maximum node of left subtree or greater than\\n\\t    // the minimum node of right subtree, it can\\'t be a bst\\n        if(!l.isBST || !r.isBST || root->val <= l.maxi || root->val >= r.mini) {\\n            h.isBST = 0;\\n            return h;\\n        }\\n        // If a BST is formed through current node\\n        h.sum = l.sum + r.sum + root->val;\\n        maxSum = max(maxSum, h.sum);\\n        h.mini = min(l.mini, root->val);\\n        h.maxi = max(r.maxi, root->val);\\n        return h;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        Helper h = dfs(root);\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper Class\\n    class Helper {\\n        public: \\n        int maxi, mini, sum, isBST;\\n        Helper() {\\n            maxi = -40000; mini = 40000; sum = 0; isBST = 1;\\n        }\\n    };\\n    // Default object for base case\\n    Helper hh;\\n    // This will store the max sum for a BST\\n    int maxSum = 0;\\n    Helper dfs(TreeNode *root) {\\n        if(!root) {\\n            return hh;\\n        }\\n        Helper l = dfs(root->left);\\n        Helper r = dfs(root->right);\\n        Helper h;\\n        // If either of the subtrees is not BST, subtree through current node cannot be BST\\n\\t    // Also if current node is less than the maximum node of left subtree or greater than\\n\\t    // the minimum node of right subtree, it can\\'t be a bst\\n        if(!l.isBST || !r.isBST || root->val <= l.maxi || root->val >= r.mini) {\\n            h.isBST = 0;\\n            return h;\\n        }\\n        // If a BST is formed through current node\\n        h.sum = l.sum + r.sum + root->val;\\n        maxSum = max(maxSum, h.sum);\\n        h.mini = min(l.mini, root->val);\\n        h.maxi = max(r.maxi, root->val);\\n        return h;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        Helper h = dfs(root);\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195648,
                "title": "python-solution-with-explanation",
                "content": "* If upperbound == -inf, it means there is no upper bound. Any number can be bigger than -inf.\\n* Similarly if the lowerbound is inf, there is no lower bound. Any number can be smaller than infinity.\\n\\nThe tree is traversed in **post order,** that is, first verify if the left subtree and the right subtrees are BSTs, then try to include the root.\\n\\nIf the node is empty, there\\'s no upperbound or lowerbound to that empty bst, and the bst sum is 0.\\n\\nFor a node to be in BST form, its left and right subtrees must be BSTs, and **value of the node must be higher than the highest value(upper bound) of left subtree and lower than the lowest value(lower bound) of the right subtree**.\\n\\nUpperBound of the BST thus formed would be max(max in right subtree, node\\'s value) and lower bound would min(min value in left subtree, node\\'s value).\\n\\n\\n**If the node violates BST property, make it\\'s subtree sum have a rippling negating effect by making it -inf so that no branch containing it can be considered for BST subtree sum.**\\n\\nNegative sums are considered 0\\n\\n```\\n\\nclass Solution:\\n  \\n  def maxSumBST(self, root: TreeNode) -> int:\\n    sum_ = 0\\n    def recurse(root):\\n      nonlocal sum_\\n      \\n      if root:\\n        \\n        left,left_lb,left_ub = recurse(root.left)\\n        right,right_lb,right_ub = recurse(root.right) \\n        \\n        if root.val>left_ub and root.val<right_lb:\\n          s = left+right+root.val\\n          sum_ = max(s,sum_)\\n          return s,min(root.val,left_lb),max(root.val,right_ub)\\n        else:\\n          return (float(\\'-inf\\'),float(\\'inf\\'),float(\\'-inf\\'))\\n      \\n      \\n      else:\\n        return (0,float(\\'inf\\'),float(\\'-inf\\'))\\n      \\n    recurse(root)\\n    return sum_\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "* If upperbound == -inf, it means there is no upper bound. Any number can be bigger than -inf.\\n* Similarly if the lowerbound is inf, there is no lower bound. Any number can be smaller than infinity.\\n\\nThe tree is traversed in **post order,** that is, first verify if the left subtree and the right subtrees are BSTs, then try to include the root.\\n\\nIf the node is empty, there\\'s no upperbound or lowerbound to that empty bst, and the bst sum is 0.\\n\\nFor a node to be in BST form, its left and right subtrees must be BSTs, and **value of the node must be higher than the highest value(upper bound) of left subtree and lower than the lowest value(lower bound) of the right subtree**.\\n\\nUpperBound of the BST thus formed would be max(max in right subtree, node\\'s value) and lower bound would min(min value in left subtree, node\\'s value).\\n\\n\\n**If the node violates BST property, make it\\'s subtree sum have a rippling negating effect by making it -inf so that no branch containing it can be considered for BST subtree sum.**\\n\\nNegative sums are considered 0\\n\\n```\\n\\nclass Solution:\\n  \\n  def maxSumBST(self, root: TreeNode) -> int:\\n    sum_ = 0\\n    def recurse(root):\\n      nonlocal sum_\\n      \\n      if root:\\n        \\n        left,left_lb,left_ub = recurse(root.left)\\n        right,right_lb,right_ub = recurse(root.right) \\n        \\n        if root.val>left_ub and root.val<right_lb:\\n          s = left+right+root.val\\n          sum_ = max(s,sum_)\\n          return s,min(root.val,left_lb),max(root.val,right_ub)\\n        else:\\n          return (float(\\'-inf\\'),float(\\'inf\\'),float(\\'-inf\\'))\\n      \\n      \\n      else:\\n        return (0,float(\\'inf\\'),float(\\'-inf\\'))\\n      \\n    recurse(root)\\n    return sum_\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2004782,
                "title": "c-solution-90-fast-with-o-n-time-complexity",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // return func\\n    struct s{\\n        bool isBST;\\n        int mini,maxi,sum;\\n    };\\n    \\n    // logic func/solution func\\n    s solve(TreeNode* root,int &res){\\n        if(!root){\\n            return {true,INT_MAX,INT_MIN,0};\\n        }\\n        \\n        s left=solve(root->left,res);\\n        s right=solve(root->right,res);\\n        \\n        if(left.isBST && right.isBST && left.maxi<root->val && right.mini>root->val){\\n            int cur=left.sum+right.sum+root->val;\\n            res=max(res,cur);\\n            return {true,min(left.mini,root->val),max(right.maxi,root->val),cur};\\n        }\\n        else return {false,0,0,0};\\n    }\\n    \\n    // main/starting func\\n    int maxSumBST(TreeNode* root) {\\n        int res=0;\\n        solve(root,res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // return func\\n    struct s{\\n        bool isBST;\\n        int mini,maxi,sum;\\n    };\\n    \\n    // logic func/solution func\\n    s solve(TreeNode* root,int &res){\\n        if(!root){\\n            return {true,INT_MAX,INT_MIN,0};\\n        }\\n        \\n        s left=solve(root->left,res);\\n        s right=solve(root->right,res);\\n        \\n        if(left.isBST && right.isBST && left.maxi<root->val && right.mini>root->val){\\n            int cur=left.sum+right.sum+root->val;\\n            res=max(res,cur);\\n            return {true,min(left.mini,root->val),max(right.maxi,root->val),cur};\\n        }\\n        else return {false,0,0,0};\\n    }\\n    \\n    // main/starting func\\n    int maxSumBST(TreeNode* root) {\\n        int res=0;\\n        solve(root,res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908553,
                "title": "useful-template-to-approach-bst-problem",
                "content": "When the problem has the pattern to find the BST from a binary tree, it means we need to find every possible BST under the root node.\\nThe bigget hint is from the definition of BST\\n\\n1. The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n2. The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n3. Both the left and right subtrees must also be binary search trees.\\n\\nSo for every node we will need the following information:\\n1. If its left subtree is a BST and its min/max boundry and the sum of nodes under this tree.\\n2. If its right subtree is a BST and its min/max boundry and the sum of nodes under this tree.\\n3. If left subtree max boundry <=  current node value <= right subtree min boundry\\n\\nFor 1 and 2, we can combine BST validality with its boundry. \\nIf a node has a valid min/max boundry, it makes sense to be a valid BST. \\n\\nBase case:\\nWhen the node is null, we want to make it a valid BST so for a leaf node it is natual to check if the boundry is valid. How can we achieve that?\\nThe **key point** is for null node to return **a minimum boundry that is very large and a maximum boundry that is very small**.\\n\\nSo when a leaf node gets the left subtree boundry and compare the node\\'s value with the max boundry, it will always be valid because a null node will return a very samll maximum bondray.\\n\\nSimilarily, when a leaf node compares its value with the min boundry from right subtree, it will be valid because a null node returns a very large minimum boundry.\\n\\n![image](https://assets.leetcode.com/users/images/eded1b5a-ca00-4490-9503-64480cdecdc3_1648953902.8246553.png)\\n\\n\\nSo now we have the BST information, we are ready to get the largest sum of a valid BST. \\nThe idea is simple: just return a extra integer for the sum. We only add up the sum to current node if `left subtree max boundry <=  current node value <= right subtree min boundry`, meaning current node is a valid BST as well.\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    // left, right, sum\\n    tuple<int,int,int> getSumBST(TreeNode* node) {\\n        if(!node)\\n            return {INT_MAX, INT_MIN, 0};\\n        \\n        auto [left_l, left_r, left_sum] = getSumBST(node->left);\\n        auto [right_l, right_r, right_sum] = getSumBST(node->right);\\n        \\n        // initialize with invalid bst node\\n        tuple<int,int,int> ret(INT_MIN, INT_MAX, 0);\\n        \\n        // valid bst under node\\n        if(node->val > left_r && node->val < right_l) {\\n            ret = { min(left_l, node->val), max(right_r, node->val), left_sum+right_sum+node->val };\\n            ans = max(ans, left_sum+right_sum+node->val);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    \\n    int maxSumBST(TreeNode* root) {\\n        getSumBST(root);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    // left, right, sum\\n    tuple<int,int,int> getSumBST(TreeNode* node) {\\n        if(!node)\\n            return {INT_MAX, INT_MIN, 0};\\n        \\n        auto [left_l, left_r, left_sum] = getSumBST(node->left);\\n        auto [right_l, right_r, right_sum] = getSumBST(node->right);\\n        \\n        // initialize with invalid bst node\\n        tuple<int,int,int> ret(INT_MIN, INT_MAX, 0);\\n        \\n        // valid bst under node\\n        if(node->val > left_r && node->val < right_l) {\\n            ret = { min(left_l, node->val), max(right_r, node->val), left_sum+right_sum+node->val };\\n            ans = max(ans, left_sum+right_sum+node->val);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    \\n    int maxSumBST(TreeNode* root) {\\n        getSumBST(root);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858241,
                "title": "c-finding-all-the-bsts-along-with-its-sum",
                "content": "```\\n//Approach - Finding a bst and calculating its sum (In Bottom Up Manner or In PostOrder)\\n//At each node i will maintain a minimum value and a maximum value from that node to bottom of tree\\n//At each node i will check\\n//  1 - If its left subtree is a BST\\n//  2 - If its right sub tree is a BST\\n//  3 - If its value is greater than max of its left (b/c if it is greater than max of its left means it is greater than all the nodes of its left subtree)\\n//  4 - If its value is less than min of its right b/c if it is less than minimum of its right subtree means it is less than all the nodes of its right subtree\\n//  5 - if all the above condition satisfies means it is a BST then sum of this BST will be left.sum + right.sum + node.val\\n\\nclass NodeVal{      \\n    public:\\n    int minVal, maxVal,sum;\\n    bool isBST;\\n    \\n    NodeVal(int a, int b, int c, bool e)\\n    {\\n        minVal = a;\\n        maxVal = b;\\n        sum = c;\\n        isBST = e;\\n    }\\n    NodeVal(){}\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    NodeVal findSum(TreeNode* node)\\n    {\\n        if(node == NULL) return NodeVal(INT_MAX, INT_MIN, 0, true);\\n        \\n        auto left = findSum(node->left);\\n        auto right = findSum(node->right);\\n        \\n        NodeVal nv;\\n        \\n        nv.isBST = (left.isBST && right.isBST && node->val < right.minVal && node->val > left.maxVal);\\n        nv.minVal = min(node->val, left.minVal);\\n        nv.maxVal = max(node->val, right.maxVal);\\n        \\n        \\n        if(nv.isBST)\\n        {\\n            nv.sum = left.sum + right.sum + node->val;\\n            ans = max(ans, nv.sum);\\n        }\\n        \\n        return nv;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        auto a = findSum(root);\\n        return ans > 0 ? ans : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n//Approach - Finding a bst and calculating its sum (In Bottom Up Manner or In PostOrder)\\n//At each node i will maintain a minimum value and a maximum value from that node to bottom of tree\\n//At each node i will check\\n//  1 - If its left subtree is a BST\\n//  2 - If its right sub tree is a BST\\n//  3 - If its value is greater than max of its left (b/c if it is greater than max of its left means it is greater than all the nodes of its left subtree)\\n//  4 - If its value is less than min of its right b/c if it is less than minimum of its right subtree means it is less than all the nodes of its right subtree\\n//  5 - if all the above condition satisfies means it is a BST then sum of this BST will be left.sum + right.sum + node.val\\n\\nclass NodeVal{      \\n    public:\\n    int minVal, maxVal,sum;\\n    bool isBST;\\n    \\n    NodeVal(int a, int b, int c, bool e)\\n    {\\n        minVal = a;\\n        maxVal = b;\\n        sum = c;\\n        isBST = e;\\n    }\\n    NodeVal(){}\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    NodeVal findSum(TreeNode* node)\\n    {\\n        if(node == NULL) return NodeVal(INT_MAX, INT_MIN, 0, true);\\n        \\n        auto left = findSum(node->left);\\n        auto right = findSum(node->right);\\n        \\n        NodeVal nv;\\n        \\n        nv.isBST = (left.isBST && right.isBST && node->val < right.minVal && node->val > left.maxVal);\\n        nv.minVal = min(node->val, left.minVal);\\n        nv.maxVal = max(node->val, right.maxVal);\\n        \\n        \\n        if(nv.isBST)\\n        {\\n            nv.sum = left.sum + right.sum + node->val;\\n            ans = max(ans, nv.sum);\\n        }\\n        \\n        return nv;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        auto a = findSum(root);\\n        return ans > 0 ? ans : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833032,
                "title": "simple-solution-in-java-elegant-and-concise-o-n-time",
                "content": "```\\nclass Solution {\\n    private int ans = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n        \\n        Info info = find(root);\\n        return ans;\\n    }\\n    \\n    private Info find(TreeNode root){\\n        if(root == null){\\n            return new Info();\\n        }\\n        \\n        Info lTree = find(root.left);\\n        Info rTree = find(root.right);\\n        \\n        Info info = new Info();\\n        if(lTree.isBST == true && rTree.isBST == true){\\n            if(lTree.max < root.val && rTree.min > root.val){\\n                info.maxBSTsum = root.val + lTree.maxBSTsum + rTree.maxBSTsum;\\n                info.max = rTree.max == Integer.MIN_VALUE ? root.val : rTree.max;\\n                info.min = lTree.min == Integer.MAX_VALUE ? root.val : lTree.min;\\n            }else{\\n                info.isBST = false;\\n            }\\n        }else{\\n            info.isBST = false;\\n        }\\n        \\n        if(info.isBST){\\n            ans = Math.max(ans, info.maxBSTsum);\\n        }\\n        return info;\\n    }\\n    \\n    private class Info{\\n        public int max;\\n        public int min;\\n        public int maxBSTsum;\\n        public boolean isBST;\\n        \\n        public Info(){\\n            this.max = Integer.MIN_VALUE;\\n            this.min = Integer.MAX_VALUE;\\n            this.isBST = true;\\n            this.maxBSTsum = 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int ans = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n        \\n        Info info = find(root);\\n        return ans;\\n    }\\n    \\n    private Info find(TreeNode root){\\n        if(root == null){\\n            return new Info();\\n        }\\n        \\n        Info lTree = find(root.left);\\n        Info rTree = find(root.right);\\n        \\n        Info info = new Info();\\n        if(lTree.isBST == true && rTree.isBST == true){\\n            if(lTree.max < root.val && rTree.min > root.val){\\n                info.maxBSTsum = root.val + lTree.maxBSTsum + rTree.maxBSTsum;\\n                info.max = rTree.max == Integer.MIN_VALUE ? root.val : rTree.max;\\n                info.min = lTree.min == Integer.MAX_VALUE ? root.val : lTree.min;\\n            }else{\\n                info.isBST = false;\\n            }\\n        }else{\\n            info.isBST = false;\\n        }\\n        \\n        if(info.isBST){\\n            ans = Math.max(ans, info.maxBSTsum);\\n        }\\n        return info;\\n    }\\n    \\n    private class Info{\\n        public int max;\\n        public int min;\\n        public int maxBSTsum;\\n        public boolean isBST;\\n        \\n        public Info(){\\n            this.max = Integer.MIN_VALUE;\\n            this.min = Integer.MAX_VALUE;\\n            this.isBST = true;\\n            this.maxBSTsum = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718688,
                "title": "o-n-java-solution-for-maximun-sum-bst",
                "content": "```\\n// Stores the maximum ans minimum node in this subStree ans the max sum of the valid\\n// Bst in this subtree\\npublic class Data{\\n    int largest;``\\n    int smallest;\\n    int sum;\\n    public Data(int l, int s, int sz){\\n        this.largest = l;\\n        this.smallest = s;\\n        this.sum = sz;\\n    }\\n}\\n\\n\\n\\n// For a Bst this value of the current node must be greater than the largest value in the left part &&\\n// it should be smaller than the smallest value ofthe right part.\\n// left.largest < curr.value < right.smallest\\n\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n        Data ans = new Data(0, 0, 0);\\n        findSum(root, ans);\\n        return ans.sum < 0 ? 0 : ans.sum;\\n    }\\n    \\n    \\n    public Data findSum(TreeNode node, Data ans){\\n        // If left node then return largest as the smallest & smallest as the the max to satisfy the bst\\n        if(node == null) return new Data(Integer.MIN_VALUE, Integer.MAX_VALUE, 0);\\n        \\n        // Inorder traversal\\n        Data left = findSum(node.left, ans);\\n        Data right = findSum(node.right, ans);\\n        \\n        // Valid BST Check: left.largest < curr.value < right.smallest\\n        if(node.val > left.largest && node.val < right.smallest){\\n            // compare the max sum \\n            ans.sum = Math.max(ans.sum, node.val + left.sum + right.sum);\\n            \\n            // Get (the max,min,sum) for the curr node and return it\\n            int max = Math.max(node.val, right.largest);\\n            int min = Math.min(node.val,left.smallest);\\n            int sum = node.val + left.sum + right.sum;\\n            return new Data(max, min, sum);\\n        }\\n        \\n        // If the curr node is not a valid bst then return the value such that no node above this node\\n        // can be a bst\\n        return new Data(Integer.MAX_VALUE, Integer.MIN_VALUE, Math.max(left.sum, right.sum));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Stores the maximum ans minimum node in this subStree ans the max sum of the valid\\n// Bst in this subtree\\npublic class Data{\\n    int largest;``\\n    int smallest;\\n    int sum;\\n    public Data(int l, int s, int sz){\\n        this.largest = l;\\n        this.smallest = s;\\n        this.sum = sz;\\n    }\\n}\\n\\n\\n\\n// For a Bst this value of the current node must be greater than the largest value in the left part &&\\n// it should be smaller than the smallest value ofthe right part.\\n// left.largest < curr.value < right.smallest\\n\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n        Data ans = new Data(0, 0, 0);\\n        findSum(root, ans);\\n        return ans.sum < 0 ? 0 : ans.sum;\\n    }\\n    \\n    \\n    public Data findSum(TreeNode node, Data ans){\\n        // If left node then return largest as the smallest & smallest as the the max to satisfy the bst\\n        if(node == null) return new Data(Integer.MIN_VALUE, Integer.MAX_VALUE, 0);\\n        \\n        // Inorder traversal\\n        Data left = findSum(node.left, ans);\\n        Data right = findSum(node.right, ans);\\n        \\n        // Valid BST Check: left.largest < curr.value < right.smallest\\n        if(node.val > left.largest && node.val < right.smallest){\\n            // compare the max sum \\n            ans.sum = Math.max(ans.sum, node.val + left.sum + right.sum);\\n            \\n            // Get (the max,min,sum) for the curr node and return it\\n            int max = Math.max(node.val, right.largest);\\n            int min = Math.min(node.val,left.smallest);\\n            int sum = node.val + left.sum + right.sum;\\n            return new Data(max, min, sum);\\n        }\\n        \\n        // If the curr node is not a valid bst then return the value such that no node above this node\\n        // can be a bst\\n        return new Data(Integer.MAX_VALUE, Integer.MIN_VALUE, Math.max(left.sum, right.sum));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532937,
                "title": "java-easy-approach-with-explanation-100-faster-new-approach-no-dp",
                "content": "```\\nclass Solution \\n{\\n    int  maxSum= 0;//Global Sum \\n    class pair\\n    {\\n        boolean isBST;//Wheater the node is BST or not \\n        int max;//BST Upperlimit\\n        int min;//BST Lower Limit \\n        int sum;//Cumulative node sum in BST \\n        pair()\\n        {\\n            this.isBST= true;\\n            this.max= Integer.MIN_VALUE;\\n            this.min= Integer.MAX_VALUE;\\n            this.sum= 0;\\n        }\\n    }\\n   \\n    public  pair isBST( TreeNode root )\\n    {//Post Order Bottom Up Approach \\n        if ( root == null ){//base case when we hit the null node, we consider it as BST \\n            pair p= new pair();\\n            return p;\\n        }\\n        \\n        pair left= isBST( root.left );//Recursing down the left subtree \\n        pair right= isBST(  root.right );//Recursing down the right subtree \\n        \\n        pair p= new pair();//Current node, after having its child information \\n        \\n        if (  left.isBST == false || right.isBST == false ){//if the child is not BST the the node is also not a BST \\n            p.isBST= false;\\n            return p;\\n        }\\n        \\n        //calculating the maximum and minimum value of the node, to serve it to the current node\\'s parent //Sice child is BST Confirmed, we are calculating this way \\n        p.max= Math.max( root.val, right.max );\\n        p.min= Math.min( root.val, left.min  );\\n        \\n        \\n        if ( root.val > left.max && root.val < right.min ){//checking that the current node is a Tree BST ( node BST is a Subset of TreeBST, hence its covered using Tree BST) or not\\n            p.sum= left.sum+ right.sum+ root.val;//calculating the sum, on the basis of sum received from the children//Cumulative BST Sum\\n            maxSum= Math.max( maxSum, p.sum );//if maximum sum found updating \\n            return p;//returning the current node with information to the parent, to decide whether parent is BST or Not and including it will maximize the cumulating BST Sum or Not //current Node is BST  \\n        }\\n        \\n        //Not a Tree BST Case \\n        p.isBST= false;//If the current node is not a BST \\n        return p;//returning the current node ( not a BST ) with all the information to its parent\\n    }\\n    public int maxSumBST( TreeNode root ) {\\n        isBST( root );\\n        return maxSum;//Maximum BST Nodes Sum \\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution \\n{\\n    int  maxSum= 0;//Global Sum \\n    class pair\\n    {\\n        boolean isBST;//Wheater the node is BST or not \\n        int max;//BST Upperlimit\\n        int min;//BST Lower Limit \\n        int sum;//Cumulative node sum in BST \\n        pair()\\n        {\\n            this.isBST= true;\\n            this.max= Integer.MIN_VALUE;\\n            this.min= Integer.MAX_VALUE;\\n            this.sum= 0;\\n        }\\n    }\\n   \\n    public  pair isBST( TreeNode root )\\n    {//Post Order Bottom Up Approach \\n        if ( root == null ){//base case when we hit the null node, we consider it as BST \\n            pair p= new pair();\\n            return p;\\n        }\\n        \\n        pair left= isBST( root.left );//Recursing down the left subtree \\n        pair right= isBST(  root.right );//Recursing down the right subtree \\n        \\n        pair p= new pair();//Current node, after having its child information \\n        \\n        if (  left.isBST == false || right.isBST == false ){//if the child is not BST the the node is also not a BST \\n            p.isBST= false;\\n            return p;\\n        }\\n        \\n        //calculating the maximum and minimum value of the node, to serve it to the current node\\'s parent //Sice child is BST Confirmed, we are calculating this way \\n        p.max= Math.max( root.val, right.max );\\n        p.min= Math.min( root.val, left.min  );\\n        \\n        \\n        if ( root.val > left.max && root.val < right.min ){//checking that the current node is a Tree BST ( node BST is a Subset of TreeBST, hence its covered using Tree BST) or not\\n            p.sum= left.sum+ right.sum+ root.val;//calculating the sum, on the basis of sum received from the children//Cumulative BST Sum\\n            maxSum= Math.max( maxSum, p.sum );//if maximum sum found updating \\n            return p;//returning the current node with information to the parent, to decide whether parent is BST or Not and including it will maximize the cumulating BST Sum or Not //current Node is BST  \\n        }\\n        \\n        //Not a Tree BST Case \\n        p.isBST= false;//If the current node is not a BST \\n        return p;//returning the current node ( not a BST ) with all the information to its parent\\n    }\\n    public int maxSumBST( TreeNode root ) {\\n        isBST( root );\\n        return maxSum;//Maximum BST Nodes Sum \\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499664,
                "title": "c-o-n-basic-understanding-intuition-algorithm-clean-code",
                "content": "## **Basic** **Understanding**\\nThe question tells us that we have a binary tree given. In this binary tree, we can have a subtree as BST, but the whole subtree should follow BST rules. eg\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t7\\n\\t\\t\\t\\t\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\t\\t\\t\\t     6     9\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t11    10\\n```\\nIn the above binary tree, we cannot choose 7 as root node of BST tree, because the subtree of 9 is not a BST. Hence only 6, 11 and 10 can be called BST as they have no sub-tree which is not BST. Hence, any node whose all subtree are BST and the node itself follow BST rule can be called as BST. What we have to do next is to tell which BST has the maximum sum. In this case, its 11.\\n\\n## **Intuition**\\nSince now we have the prerequisite to solve it mentally, we can start thinking it programmatically. If at any node we can have the following information : \\n1. Is the left subtree BST?\\n2. Is the right subtree BST?\\n3. Max and Min value of left and right BST?\\n4. Sum of left and right subtree.\\n\\nWe can tell that if this node is a BST or not.\\nIf any of the left or right subtree is not BST, we can say that this node is not BST. If the \\n```\\nnode->val > max(left-subtree) && node->val < min(right-subtree)\\n```\\nthen, the node is a BST and we can have the total sum for the node and compare with a global maximum variable.\\n\\nNote:\\n1. Why do we need both max and min value for subtree?\\nBecause the node can be either right subtree or left subtree of the parent node, in which case its min or max value will be needed respectively.\\n2. What should be the approach of adding the the node value, \"top to bottom\" or \"bottom to top\"?\\nFrom the above discussion it can be said, it is optimal to take the sum from bottom to top.\\n\\n## **Algorithm**\\n1. We can do a post order traversal, because we need to traverse both left and right subtree for the information needed at a node.\\n2. Each node will return an array of size 4, with the following information : \\n\\t```\\n\\tarr[0]  = sum of the BST at the node\\n\\tarr[1] = bool value to indicate if the subtree formed by the node is BST.\\n\\tarr[2] = min value of the subtree\\n\\tarr[3] = max value of the subtree\\n\\t```\\n3. If the node is BST, take sum of left-subtree + right-subtree + node->val and campare against the global max.\\n4. Return the global max after the post order traversal is finished.\\n\\n## **Code**\\n```\\nclass Solution {\\npublic:\\n    int maxs = 0;\\n    vector<int> traverse(TreeNode* root){\\n        vector<int> t(4,0);\\n        if(!root){\\n            t[1] = 1;\\n            t[2] = INT_MAX;\\n            t[3] = INT_MIN;\\n            return t;\\n        }\\n\\n        vector<int> l = traverse(root->left);\\n\\n        vector<int> r = traverse(root->right);        \\n\\n        if(l[1] && r[1] && (root->val > l[3]) && (root->val < r[2])){\\n            int sum = l[0] + r[0] + root->val;\\n            maxs = max(maxs,sum);\\n            t[0] = sum;\\n            t[1] = 1;\\n            t[2] = !root->left ? root->val : l[2];\\n            t[3] = !root->right ? root->val : r[3];\\n            return t;\\n        }\\n        return t;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        traverse(root);\\n        return maxs;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t7\\n\\t\\t\\t\\t\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\t\\t\\t\\t     6     9\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t11    10\\n```\n```\\nnode->val > max(left-subtree) && node->val < min(right-subtree)\\n```\n```\\n\\tarr[0]  = sum of the BST at the node\\n\\tarr[1] = bool value to indicate if the subtree formed by the node is BST.\\n\\tarr[2] = min value of the subtree\\n\\tarr[3] = max value of the subtree\\n\\t```\n```\\nclass Solution {\\npublic:\\n    int maxs = 0;\\n    vector<int> traverse(TreeNode* root){\\n        vector<int> t(4,0);\\n        if(!root){\\n            t[1] = 1;\\n            t[2] = INT_MAX;\\n            t[3] = INT_MIN;\\n            return t;\\n        }\\n\\n        vector<int> l = traverse(root->left);\\n\\n        vector<int> r = traverse(root->right);        \\n\\n        if(l[1] && r[1] && (root->val > l[3]) && (root->val < r[2])){\\n            int sum = l[0] + r[0] + root->val;\\n            maxs = max(maxs,sum);\\n            t[0] = sum;\\n            t[1] = 1;\\n            t[2] = !root->left ? root->val : l[2];\\n            t[3] = !root->right ? root->val : r[3];\\n            return t;\\n        }\\n        return t;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        traverse(root);\\n        return maxs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304683,
                "title": "java-recursive-time-efficient",
                "content": "```\\nclass Solution {\\n    int max=Integer.MIN_VALUE;\\n    \\n    public int[] helper(TreeNode root){\\n        //return pattern is { max_sum , 0 if not bst and 1 if bst , maximum on left of subtree , minimum on right of subtree}\\n        if(root==null) return new int[]{0,1,-99999,99999};\\n        \\n        //solve for left and right\\n        int[] l=helper(root.left);\\n        int[] r=helper(root.right);\\n        \\n        //maxLeft\\n        int maxL=Math.max(root.val,Math.max(l[2],r[2]));\\n        \\n        //minRight\\n        int minR=Math.min(root.val,Math.min(l[3],r[3]));\\n        \\n        // if the subtree is a BST\\n        if(root.val>l[2]&&root.val<r[3]&&l[1]==1&&r[1]==1){\\n            max=Math.max(max,l[0]+r[0]+root.val);\\n            return new int[]{l[0]+r[0]+root.val,1,maxL,minR};\\n        }\\n        \\n        //if subtree is not BST\\n        else return new int[]{0,0,maxL,minR};\\n        \\n    }\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        if(max<0) return 0;\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int max=Integer.MIN_VALUE;\\n    \\n    public int[] helper(TreeNode root){\\n        //return pattern is { max_sum , 0 if not bst and 1 if bst , maximum on left of subtree , minimum on right of subtree}\\n        if(root==null) return new int[]{0,1,-99999,99999};\\n        \\n        //solve for left and right\\n        int[] l=helper(root.left);\\n        int[] r=helper(root.right);\\n        \\n        //maxLeft\\n        int maxL=Math.max(root.val,Math.max(l[2],r[2]));\\n        \\n        //minRight\\n        int minR=Math.min(root.val,Math.min(l[3],r[3]));\\n        \\n        // if the subtree is a BST\\n        if(root.val>l[2]&&root.val<r[3]&&l[1]==1&&r[1]==1){\\n            max=Math.max(max,l[0]+r[0]+root.val);\\n            return new int[]{l[0]+r[0]+root.val,1,maxL,minR};\\n        }\\n        \\n        //if subtree is not BST\\n        else return new int[]{0,0,maxL,minR};\\n        \\n    }\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        if(max<0) return 0;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234514,
                "title": "easy-to-grasp-c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // define a struct with parameters that keep check of whether BST exists\\n    // watch Tushar roy video on YT for explanation\\n    struct BSTNode {\\n        bool isBST;\\n        int min;\\n        int max;\\n        int sum; \\n    };\\n    BSTNode helper(TreeNode* curr, int &ans){\\n        if(curr){\\n            BSTNode left = helper(curr->left, ans);\\n            BSTNode right = helper(curr->right, ans);\\n            // for a node\\'s isBST to be true, its left and right subT should\\n            // also be BSTs, and node\\'s val > left\\'s max and <right\\'s min\\n            bool isBST = left.isBST && right.isBST && curr->val > left.max && curr->val < right.min;\\n            // sum param of this particular node\\n            int sum = left.sum + right.sum + curr->val;\\n            // only if a BST can be formed at this curr will we modify ans\\n            if(isBST) ans = max(ans, sum);\\n            // return status to higher levels\\n            return {isBST, min(curr->val, left.min), max(curr->val, right.max), sum };               \\n        } else return {true, INT_MAX, INT_MIN, 0};\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        helper(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // define a struct with parameters that keep check of whether BST exists\\n    // watch Tushar roy video on YT for explanation\\n    struct BSTNode {\\n        bool isBST;\\n        int min;\\n        int max;\\n        int sum; \\n    };\\n    BSTNode helper(TreeNode* curr, int &ans){\\n        if(curr){\\n            BSTNode left = helper(curr->left, ans);\\n            BSTNode right = helper(curr->right, ans);\\n            // for a node\\'s isBST to be true, its left and right subT should\\n            // also be BSTs, and node\\'s val > left\\'s max and <right\\'s min\\n            bool isBST = left.isBST && right.isBST && curr->val > left.max && curr->val < right.min;\\n            // sum param of this particular node\\n            int sum = left.sum + right.sum + curr->val;\\n            // only if a BST can be formed at this curr will we modify ans\\n            if(isBST) ans = max(ans, sum);\\n            // return status to higher levels\\n            return {isBST, min(curr->val, left.min), max(curr->val, right.max), sum };               \\n        } else return {true, INT_MAX, INT_MIN, 0};\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        helper(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153185,
                "title": "java-recursive-clean-code-with-explanation-6ms-faster-than-81-97",
                "content": "```\\nclass Solution {\\n    //6ms,81.97%; 52MB,69.60%\\n    int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    //int[]:\\n    // int[0]: 0: is not bst, 1: is bst;\\n    // int[1]: next leftMax, meaningly now max\\n    // int[2]: next rightMin, meaningly now min\\n    // int[4]: int[0] == 1 ? sum : 0;\\n    private int[] helper(TreeNode node) {\\n        if (node == null) {\\n            return new int[]{1, Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\\n        }\\n        int[] left = helper(node.left);\\n        int[] right = helper(node.right);\\n        if (left[0] == 1 && right[0] == 1 && left[1] < node.val && node.val < right[2]) {\\n            int sum = left[3]+right[3]+node.val;\\n            maxSum = Math.max(maxSum, sum);\\n\\t\\t\\t// compare to node.val dealing with NULL topwards\\n            return new int[]{1, Math.max(right[1], node.val), Math.min(left[2], node.val), sum}; \\n        }\\n        return new int[]{0, Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //6ms,81.97%; 52MB,69.60%\\n    int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    //int[]:\\n    // int[0]: 0: is not bst, 1: is bst;\\n    // int[1]: next leftMax, meaningly now max\\n    // int[2]: next rightMin, meaningly now min\\n    // int[4]: int[0] == 1 ? sum : 0;\\n    private int[] helper(TreeNode node) {\\n        if (node == null) {\\n            return new int[]{1, Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\\n        }\\n        int[] left = helper(node.left);\\n        int[] right = helper(node.right);\\n        if (left[0] == 1 && right[0] == 1 && left[1] < node.val && node.val < right[2]) {\\n            int sum = left[3]+right[3]+node.val;\\n            maxSum = Math.max(maxSum, sum);\\n\\t\\t\\t// compare to node.val dealing with NULL topwards\\n            return new int[]{1, Math.max(right[1], node.val), Math.min(left[2], node.val), sum}; \\n        }\\n        return new int[]{0, Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101779,
                "title": "c-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    struct subtreeInfo\\n    {\\n        bool isBST;\\n        int mini;\\n        int maxi;\\n        int sum;\\n        subtreeInfo(bool b,int mini,int maxi,int sum)\\n        {\\n            this->isBST=b;\\n            this->mini=mini;\\n            this->maxi=maxi;\\n            this->sum=sum;\\n        }\\n    };\\n    \\n    subtreeInfo* maxSumBST(TreeNode* root,int &max_sum)\\n    {\\n        if (!root)\\n        {\\n            return new subtreeInfo(true,INT_MAX,INT_MIN,0);\\n        }\\n        subtreeInfo* lt = maxSumBST(root->left,max_sum);\\n        subtreeInfo* rt = maxSumBST(root->right,max_sum);\\n        if (lt->isBST && rt->isBST && root->val>lt->maxi && root->val<rt->mini)\\n        {\\n            max_sum=max(max_sum,lt->sum+rt->sum+root->val);\\n            return new subtreeInfo(true,min(root->val,min(lt->mini,rt->mini)),max(root->val,max(lt->maxi,rt->maxi)),lt->sum+rt->sum+root->val);\\n        }\\n        else\\n        {\\n            return new subtreeInfo(false,0,INT_MAX,INT_MIN);\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        if (!root) return 0;\\n        int max_sum=0;\\n        maxSumBST(root,max_sum);\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct subtreeInfo\\n    {\\n        bool isBST;\\n        int mini;\\n        int maxi;\\n        int sum;\\n        subtreeInfo(bool b,int mini,int maxi,int sum)\\n        {\\n            this->isBST=b;\\n            this->mini=mini;\\n            this->maxi=maxi;\\n            this->sum=sum;\\n        }\\n    };\\n    \\n    subtreeInfo* maxSumBST(TreeNode* root,int &max_sum)\\n    {\\n        if (!root)\\n        {\\n            return new subtreeInfo(true,INT_MAX,INT_MIN,0);\\n        }\\n        subtreeInfo* lt = maxSumBST(root->left,max_sum);\\n        subtreeInfo* rt = maxSumBST(root->right,max_sum);\\n        if (lt->isBST && rt->isBST && root->val>lt->maxi && root->val<rt->mini)\\n        {\\n            max_sum=max(max_sum,lt->sum+rt->sum+root->val);\\n            return new subtreeInfo(true,min(root->val,min(lt->mini,rt->mini)),max(root->val,max(lt->maxi,rt->maxi)),lt->sum+rt->sum+root->val);\\n        }\\n        else\\n        {\\n            return new subtreeInfo(false,0,INT_MAX,INT_MIN);\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        if (!root) return 0;\\n        int max_sum=0;\\n        maxSumBST(root,max_sum);\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055846,
                "title": "short-easy-to-understand-c-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    \\n    pair<int,pair<int,int>> func(TreeNode* node, int & ans){\\n        if(!node) return {0,{INT_MAX,INT_MIN}};\\n        auto l= func(node->left,ans);\\n        auto r= func(node->right,ans);\\n        if(r.second.first<=node->val || l.second.second>= node->val) return {0,{INT_MIN,INT_MAX}};\\n        int num= l.first+ r.first + node->val;\\n        ans=max(ans,num);\\n        return {num,{min(node->val,l.second.first),max(node->val,r.second.second)}};\\n}\\n    \\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        func(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n    pair<int,pair<int,int>> func(TreeNode* node, int & ans){\\n        if(!node) return {0,{INT_MAX,INT_MIN}};\\n        auto l= func(node->left,ans);\\n        auto r= func(node->right,ans);\\n        if(r.second.first<=node->val || l.second.second>= node->val) return {0,{INT_MIN,INT_MAX}};\\n        int num= l.first+ r.first + node->val;\\n        ans=max(ans,num);\\n        return {num,{min(node->val,l.second.first),max(node->val,r.second.second)}};\\n}\\n    \\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        func(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053026,
                "title": "java-code-with-comments-6ms",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        find(root);\\n        return max;\\n    }\\n    \\n    private ValidateBST find(TreeNode node) {\\n        if (node == null) return new ValidateBST(true);\\n        \\n        ValidateBST left = find(node.left);\\n        ValidateBST right = find(node.right);\\n        ValidateBST cur = new ValidateBST();\\n        \\n        int curValue = node.val;\\n        \\n        //getting lower bound -> min(cur, left.lower, right.lower)\\n        cur.lower = Math.min(curValue, Math.min(left.lower, right.lower));\\n        \\n        //getting upper bound -> max(cur, left.upper, right.upper)\\n        cur.upper = Math.max(curValue, Math.max(left.upper, right.upper));\\n        \\n        //isBST -> left.upper < curValue < right.lower\\n        cur.isBST = left.isBST && right.isBST && curValue>left.upper && curValue<right.lower;\\n        \\n        if (cur.isBST) {\\n            cur.sum = curValue + left.sum + right.sum;\\n            max = Math.max(max, cur.sum);\\n        }\\n        \\n        return cur;\\n    }\\n    \\n    private class ValidateBST {\\n        int sum;\\n        boolean isBST;\\n        \\n        //we will be doing post order traversal, \\n        //so the leaf nodes left.upper should be min and right.lower should be max\\n        int lower = Integer.MAX_VALUE;\\n        int upper = Integer.MIN_VALUE;\\n        \\n        public ValidateBST(){\\n        }\\n        \\n        public ValidateBST(boolean isBST) {\\n           this.isBST = isBST;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        find(root);\\n        return max;\\n    }\\n    \\n    private ValidateBST find(TreeNode node) {\\n        if (node == null) return new ValidateBST(true);\\n        \\n        ValidateBST left = find(node.left);\\n        ValidateBST right = find(node.right);\\n        ValidateBST cur = new ValidateBST();\\n        \\n        int curValue = node.val;\\n        \\n        //getting lower bound -> min(cur, left.lower, right.lower)\\n        cur.lower = Math.min(curValue, Math.min(left.lower, right.lower));\\n        \\n        //getting upper bound -> max(cur, left.upper, right.upper)\\n        cur.upper = Math.max(curValue, Math.max(left.upper, right.upper));\\n        \\n        //isBST -> left.upper < curValue < right.lower\\n        cur.isBST = left.isBST && right.isBST && curValue>left.upper && curValue<right.lower;\\n        \\n        if (cur.isBST) {\\n            cur.sum = curValue + left.sum + right.sum;\\n            max = Math.max(max, cur.sum);\\n        }\\n        \\n        return cur;\\n    }\\n    \\n    private class ValidateBST {\\n        int sum;\\n        boolean isBST;\\n        \\n        //we will be doing post order traversal, \\n        //so the leaf nodes left.upper should be min and right.lower should be max\\n        int lower = Integer.MAX_VALUE;\\n        int upper = Integer.MIN_VALUE;\\n        \\n        public ValidateBST(){\\n        }\\n        \\n        public ValidateBST(boolean isBST) {\\n           this.isBST = isBST;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029483,
                "title": "c-postorder-short-solution-faster-than-98",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Info {\\n        bool isBST;\\n        int mn;\\n        int mx;\\n        int sum;\\n    };\\n    Info findMaxBST(TreeNode* node, int& res) {\\n        if (node != nullptr) {\\n            Info left = findMaxBST(node -> left, res);\\n            Info right = findMaxBST(node -> right, res);\\n            bool isBST = (left.isBST and right.isBST and left.mx < node -> val and node -> val < right.mn);\\n            int sum = node -> val + left.sum + right.sum;\\n            if (isBST) res = max(res, sum);\\n            return { isBST, min(node -> val, left.mn), max(node -> val, right.mx) , sum};\\n        } else {\\n            return { true, INT_MAX, INT_MIN, 0};\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int res = 0;\\n        findMaxBST(root, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Info {\\n        bool isBST;\\n        int mn;\\n        int mx;\\n        int sum;\\n    };\\n    Info findMaxBST(TreeNode* node, int& res) {\\n        if (node != nullptr) {\\n            Info left = findMaxBST(node -> left, res);\\n            Info right = findMaxBST(node -> right, res);\\n            bool isBST = (left.isBST and right.isBST and left.mx < node -> val and node -> val < right.mn);\\n            int sum = node -> val + left.sum + right.sum;\\n            if (isBST) res = max(res, sum);\\n            return { isBST, min(node -> val, left.mn), max(node -> val, right.mx) , sum};\\n        } else {\\n            return { true, INT_MAX, INT_MIN, 0};\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int res = 0;\\n        findMaxBST(root, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019178,
                "title": "java-easy-to-understand-code-postorder-traversal-o-n",
                "content": "At every node level, keep capturing detail whether BST or not and update the sum accordingly.\\n\\n**Postorder traversal.**\\n\\nTime complexity - **O(n)** , because at every node we are doing constant operation in setting min, max, isBst and sum fields.\\n```\\nclass Solution {\\n    int ans;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        Val v = helper(root);\\n        return ans;\\n    }\\n    \\n    public Val helper(TreeNode root){\\n        //base case\\n        if(root == null){\\n            Val v = new Val();\\n            v.min = Integer.MAX_VALUE;\\n            v.max = Integer.MIN_VALUE;\\n            v.isBst = true;\\n            return v;\\n        }\\n        \\n        Val left = helper(root.left);\\n        Val right = helper(root.right);\\n        \\n        Val curr = new Val();\\n        curr.isBst = left.isBst && right.isBst && root.val > left.max && root.val < right.min;\\n        \\n        curr.min = Math.min(Math.min(left.min, right.min), root.val);\\n        curr.max = Math.max(Math.max(right.max, left.max), root.val);\\n        \\n        if(curr.isBst){\\n            curr.sum = root.val + left.sum + right.sum;\\n            ans = Math.max(ans, curr.sum);\\n        }\\n        \\n        return curr;\\n    }\\n}\\n\\nclass Val{\\n    boolean isBst;\\n    int min;\\n    int max;\\n    int sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        Val v = helper(root);\\n        return ans;\\n    }\\n    \\n    public Val helper(TreeNode root){\\n        //base case\\n        if(root == null){\\n            Val v = new Val();\\n            v.min = Integer.MAX_VALUE;\\n            v.max = Integer.MIN_VALUE;\\n            v.isBst = true;\\n            return v;\\n        }\\n        \\n        Val left = helper(root.left);\\n        Val right = helper(root.right);\\n        \\n        Val curr = new Val();\\n        curr.isBst = left.isBst && right.isBst && root.val > left.max && root.val < right.min;\\n        \\n        curr.min = Math.min(Math.min(left.min, right.min), root.val);\\n        curr.max = Math.max(Math.max(right.max, left.max), root.val);\\n        \\n        if(curr.isBst){\\n            curr.sum = root.val + left.sum + right.sum;\\n            ans = Math.max(ans, curr.sum);\\n        }\\n        \\n        return curr;\\n    }\\n}\\n\\nclass Val{\\n    boolean isBst;\\n    int min;\\n    int max;\\n    int sum;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982820,
                "title": "c-one-pass-simple-easy-to-understand-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    tuple<bool,int,int,int> _maxSumBST(TreeNode* root,int &ans){\\n        if(NULL == root)\\n            return make_tuple(true,INT_MAX,INT_MIN,0);\\n        \\n        auto left=_maxSumBST(root->left,ans);\\n        auto right=_maxSumBST(root->right,ans);\\n        \\n        //Handling cases when subtree or current tree is not BST, return false.\\n        if(get<0>(left)==false || get<0>(right)==false || get<2>(left)>=root->val \\n           || get<1>(right)<=root->val)\\n            return make_tuple(false,INT_MAX,INT_MIN,ans);\\n        \\n        int min_val=min(root->val,min(get<1>(left),get<1>(right)));\\n \\xA0 \\xA0 \\xA0 \\xA0int max_val=max(root->val,max(get<2>(left),get<2>(right)));\\n        int curr_sum=get<3>(left)+root->val+get<3>(right);\\n        \\n        ans=max(ans,curr_sum);\\n        return make_tuple(true,min_val,max_val,curr_sum);\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        tuple<bool,int,int,int> val; //bool,min,max,sum\\n        _maxSumBST(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    tuple<bool,int,int,int> _maxSumBST(TreeNode* root,int &ans){\\n        if(NULL == root)\\n            return make_tuple(true,INT_MAX,INT_MIN,0);\\n        \\n        auto left=_maxSumBST(root->left,ans);\\n        auto right=_maxSumBST(root->right,ans);\\n        \\n        //Handling cases when subtree or current tree is not BST, return false.\\n        if(get<0>(left)==false || get<0>(right)==false || get<2>(left)>=root->val \\n           || get<1>(right)<=root->val)\\n            return make_tuple(false,INT_MAX,INT_MIN,ans);\\n        \\n        int min_val=min(root->val,min(get<1>(left),get<1>(right)));\\n \\xA0 \\xA0 \\xA0 \\xA0int max_val=max(root->val,max(get<2>(left),get<2>(right)));\\n        int curr_sum=get<3>(left)+root->val+get<3>(right);\\n        \\n        ans=max(ans,curr_sum);\\n        return make_tuple(true,min_val,max_val,curr_sum);\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        tuple<bool,int,int,int> val; //bool,min,max,sum\\n        _maxSumBST(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933794,
                "title": "python-recursion-postorder-traversal-without-global-vars",
                "content": "```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        MIN, MAX = -40001, 40001\\n        def traversal(root: TreeNode):\\n            if root:                    \\n                # l, r - indicators of left and right subtrees are BST trees\\n                # lmin, lmax - minimun and maximum elements seen in the left subtree\\n                # rmin, rmax - minimun and maximum elements seen in the right subtree\\n                # ls, rs - sum of elements in the left/right subtree\\n                # lcs, rcs -  current  maximum sum in the left/right subtree\\n\\n                l, lmin, lmax, ls, lcs = traversal(root.left)\\n                r, rmin, rmax, rs, rcs = traversal(root.right)\\n\\n                # always compare against maximum element seen in the left subtree and minimum in the right subtree \\n                if l and r and lmax < root.val < rmin:\\n                    s = ls + rs + root.val\\n                    return True, min(lmin, root.val), max(rmax, root.val), s, max(s, lcs, rcs)\\n\\n                # does not matter what to return except of indicator of BST tree and current max sum in between subtrees\\n                return False, MAX, MIN, None, max(lcs, rcs)\\n            return True, MAX, MIN, 0, 0\\n        \\n        return traversal(root)[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        MIN, MAX = -40001, 40001\\n        def traversal(root: TreeNode):\\n            if root:                    \\n                # l, r - indicators of left and right subtrees are BST trees\\n                # lmin, lmax - minimun and maximum elements seen in the left subtree\\n                # rmin, rmax - minimun and maximum elements seen in the right subtree\\n                # ls, rs - sum of elements in the left/right subtree\\n                # lcs, rcs -  current  maximum sum in the left/right subtree\\n\\n                l, lmin, lmax, ls, lcs = traversal(root.left)\\n                r, rmin, rmax, rs, rcs = traversal(root.right)\\n\\n                # always compare against maximum element seen in the left subtree and minimum in the right subtree \\n                if l and r and lmax < root.val < rmin:\\n                    s = ls + rs + root.val\\n                    return True, min(lmin, root.val), max(rmax, root.val), s, max(s, lcs, rcs)\\n\\n                # does not matter what to return except of indicator of BST tree and current max sum in between subtrees\\n                return False, MAX, MIN, None, max(lcs, rcs)\\n            return True, MAX, MIN, 0, 0\\n        \\n        return traversal(root)[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813759,
                "title": "python-easy-to-read-postordertraversal-time-99",
                "content": "```\\n\"\"\"\\nRuntime: 368 ms, faster than 99.77% of Python3 online submissions for Maximum Sum BST in Binary Tree.\\nMemory Usage: 67.5 MB, less than 61.65% of Python3 online submissions for Maximum Sum BST in Binary Tree.\\n\\nmax sum of any BST subtree\\n- pretty much the same solution as problem 333 except you would return max sum\\n\\nHigh Level Approach:\\n- traverse tree in postOrder fashion\\n- if leaf node return (True,nodeval,nodeval,nodeval) --> (isBST,currSum,leftMin,leftMax)\\n- if left or right is not BST: return False\\n- if both are BST (one subtree could be Null), then just check if current value still maintains BST property\\n   - if so, add its value and see if sum > globalMaxSum\\n- return globalMaxSum\\n\\nBST Post Order Traversal:\\n- keep a globalSumVariable (will handle rolling sums that have negative values but are still valid BST)\\n- will do a postOrderTraversal recursion:\\n   - if variable is leaf node return (True,val,val,val) --> (isBST,currSum,leftNodeMin,leftNodeMax)\\n   - if node has left, recurse node.left\\n   - if node has right, recurse node.right\\n- if either left or right subtree is NOT BST: return False, max of the values\\n- ELSE:\\n   - if node.left and right and leftMaxVal < currVal < rightMinVal, add sum and check with globalSum\\n   - if node.left and not node.right: check if currVal > leftNodeMax: add sum and check globalSum\\n   - if node right and not left: check if currVal < rightMinVal: add sum and check globalSum\\n   - ELSE: \\n      if currVal is not valid BST return False\\n\\n\"\"\"\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        if not root: return 0\\n        \\n        globalMaxSum = 0\\n        def postOrderTraversal(node):\\n            nonlocal globalMaxSum\\n            \\n            # handle leaf nodes\\n            if not node.left and not node.right:\\n                if node.val > globalMaxSum: globalMaxSum = node.val\\n                return True, node.val,node.val,node.val\\n            \\n        \\n            currSum = node.val\\n            \\n            # recurse into leftNode\\n            isLeftBST,leftMaxSum = True, 0\\n            if node.left:\\n                isLeftBST,leftMaxSum,leftMinVal,leftMaxVal = postOrderTraversal(node.left)\\n            \\n            # recurse into rightNode\\n            isRightBST,rightMaxSum = True, 0\\n            if node.right:\\n                isRightBST,rightMaxSum,rightMinVal,rightMaxVal = postOrderTraversal(node.right)\\n            \\n            # first check if either is not BST, then just return False\\n            if not isLeftBST or not isRightBST:\\n                return False, 0,0,0\\n            \\n            # check if node maintains BST property, if so then add to currSum for subtree maxSum and compare to globalMaxSum\\n            if node.left and node.right and node.val > leftMaxVal and node.val < rightMinVal:\\n                currSum += leftMaxSum + rightMaxSum\\n                if currSum > globalMaxSum: globalMaxSum = currSum\\n                return True,currSum,leftMinVal,rightMaxVal\\n            elif node.left and not node.right and node.val > leftMaxVal:\\n                currSum += leftMaxSum\\n                if currSum > globalMaxSum: globalMaxSum = currSum\\n                return True,currSum,leftMinVal,node.val\\n            elif node.right and not node.left and node.val < rightMinVal:\\n                currSum += rightMaxSum\\n                if currSum > globalMaxSum: globalMaxSum = currSum\\n                return True,currSum,node.val,rightMaxVal\\n            else:   # does not maintain BST property :/\\n                return False, 0,0,0\\n            \\n        postOrderTraversal(root)\\n        return globalMaxSum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\n\"\"\"\\nRuntime: 368 ms, faster than 99.77% of Python3 online submissions for Maximum Sum BST in Binary Tree.\\nMemory Usage: 67.5 MB, less than 61.65% of Python3 online submissions for Maximum Sum BST in Binary Tree.\\n\\nmax sum of any BST subtree\\n- pretty much the same solution as problem 333 except you would return max sum\\n\\nHigh Level Approach:\\n- traverse tree in postOrder fashion\\n- if leaf node return (True,nodeval,nodeval,nodeval) --> (isBST,currSum,leftMin,leftMax)\\n- if left or right is not BST: return False\\n- if both are BST (one subtree could be Null), then just check if current value still maintains BST property\\n   - if so, add its value and see if sum > globalMaxSum\\n- return globalMaxSum\\n\\nBST Post Order Traversal:\\n- keep a globalSumVariable (will handle rolling sums that have negative values but are still valid BST)\\n- will do a postOrderTraversal recursion:\\n   - if variable is leaf node return (True,val,val,val) --> (isBST,currSum,leftNodeMin,leftNodeMax)\\n   - if node has left, recurse node.left\\n   - if node has right, recurse node.right\\n- if either left or right subtree is NOT BST: return False, max of the values\\n- ELSE:\\n   - if node.left and right and leftMaxVal < currVal < rightMinVal, add sum and check with globalSum\\n   - if node.left and not node.right: check if currVal > leftNodeMax: add sum and check globalSum\\n   - if node right and not left: check if currVal < rightMinVal: add sum and check globalSum\\n   - ELSE: \\n      if currVal is not valid BST return False\\n\\n\"\"\"\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        if not root: return 0\\n        \\n        globalMaxSum = 0\\n        def postOrderTraversal(node):\\n            nonlocal globalMaxSum\\n            \\n            # handle leaf nodes\\n            if not node.left and not node.right:\\n                if node.val > globalMaxSum: globalMaxSum = node.val\\n                return True, node.val,node.val,node.val\\n            \\n        \\n            currSum = node.val\\n            \\n            # recurse into leftNode\\n            isLeftBST,leftMaxSum = True, 0\\n            if node.left:\\n                isLeftBST,leftMaxSum,leftMinVal,leftMaxVal = postOrderTraversal(node.left)\\n            \\n            # recurse into rightNode\\n            isRightBST,rightMaxSum = True, 0\\n            if node.right:\\n                isRightBST,rightMaxSum,rightMinVal,rightMaxVal = postOrderTraversal(node.right)\\n            \\n            # first check if either is not BST, then just return False\\n            if not isLeftBST or not isRightBST:\\n                return False, 0,0,0\\n            \\n            # check if node maintains BST property, if so then add to currSum for subtree maxSum and compare to globalMaxSum\\n            if node.left and node.right and node.val > leftMaxVal and node.val < rightMinVal:\\n                currSum += leftMaxSum + rightMaxSum\\n                if currSum > globalMaxSum: globalMaxSum = currSum\\n                return True,currSum,leftMinVal,rightMaxVal\\n            elif node.left and not node.right and node.val > leftMaxVal:\\n                currSum += leftMaxSum\\n                if currSum > globalMaxSum: globalMaxSum = currSum\\n                return True,currSum,leftMinVal,node.val\\n            elif node.right and not node.left and node.val < rightMinVal:\\n                currSum += rightMaxSum\\n                if currSum > globalMaxSum: globalMaxSum = currSum\\n                return True,currSum,node.val,rightMaxVal\\n            else:   # does not maintain BST property :/\\n                return False, 0,0,0\\n            \\n        postOrderTraversal(root)\\n        return globalMaxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572066,
                "title": "c-solution-o-n-using-tuples",
                "content": "```\\nclass Solution {\\npublic:\\n    tuple<int, int, int>findBst(TreeNode *root, int &ans){\\n        if(root==nullptr)return make_tuple(INT_MAX, INT_MIN, 0);\\n        tuple<int, int, int>l = findBst(root->left, ans);\\n        tuple<int, int, int>r = findBst(root->right, ans);\\n        if(root->val > get<1>(l) && root->val< get<0>(r)){\\n            ans = max(ans, get<2>(l)+get<2>(r)+root->val);\\n            return make_tuple(min(get<0>(l), root->val), max(root->val, get<1>(r)), get<2>(l)+get<2>(r)+root->val);\\n        }\\n        else{\\n            return make_tuple(INT_MIN, INT_MAX, 0);\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        tuple<int, int, int>pp = findBst(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    tuple<int, int, int>findBst(TreeNode *root, int &ans){\\n        if(root==nullptr)return make_tuple(INT_MAX, INT_MIN, 0);\\n        tuple<int, int, int>l = findBst(root->left, ans);\\n        tuple<int, int, int>r = findBst(root->right, ans);\\n        if(root->val > get<1>(l) && root->val< get<0>(r)){\\n            ans = max(ans, get<2>(l)+get<2>(r)+root->val);\\n            return make_tuple(min(get<0>(l), root->val), max(root->val, get<1>(r)), get<2>(l)+get<2>(r)+root->val);\\n        }\\n        else{\\n            return make_tuple(INT_MIN, INT_MAX, 0);\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        tuple<int, int, int>pp = findBst(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 571936,
                "title": "simple-c-code-easy-to-decipher",
                "content": "```\\nint ans=0;\\nclass pairp\\n{\\n    public:\\n    bool  is;\\n    int s;\\n    int mi;\\n    int ma;\\n    \\n};\\npairp  solve(TreeNode *root)\\n{   \\n    pairp  p;\\n    if(root->left==NULL && root->right==NULL)\\n    {\\n       p.is=true;\\n       p.s=root->val;\\n        ans=max(ans,root->val);\\n       p.mi=root->val; \\n       p.ma=root->val; \\n       return p; \\n    }\\n    \\n    pairp  x;\\n    pairp  y;\\n   \\n    if(root->left!=NULL &&  root->right!=NULL   )\\n    {\\n       x=solve(root->left);\\n       y=solve(root->right); \\n       if(x.is==false ||  y.is==false ||  root->val <=x.ma  ||  root->val >= y.mi)\\n       {\\n           p.is=false;\\n           p.s=0;\\n           p.mi=0;\\n           p.ma=0;\\n           return  p;\\n       }\\n       p.s=x.s+y.s+root->val;\\n        ans=max(ans,p.s);\\n       p.is=true;\\n        p.mi=x.mi;\\n        p.ma=y.ma;\\n        return  p;\\n    }\\n    if(root->left==NULL && root->right!=NULL)\\n    {\\n        y=solve(root->right);\\n        if(y.is==false || (root->val  >= y.mi))\\n        {\\n            p.is=false;\\n            p.s=0;\\n            p.mi=0;\\n            p.ma=0;\\n            return p;\\n        }\\n        p.is=true;\\n        p.s=y.s+root->val;\\n        ans=max(ans,p.s);\\n        p.mi=root->val;\\n        p.ma=y.ma;\\n        return  p;\\n    }\\n    if(root->left!=NULL && root->right==NULL)\\n    {\\n        x=solve(root->left);\\n        if(x.is==false ||  ( x.ma >= root->val))\\n        {\\n            p.is=false;\\n            p.s=0;\\n            p.mi=0;\\n            p.ma=0;\\n            return  p;\\n        }\\n        p.is=true;\\n        p.s=x.s+root->val;\\n        ans=max(ans,p.s); \\n        p.mi=x.mi;\\n        p.ma=root->val;    \\n        \\n        return  p;\\n    }\\n    cout<<\"xx\";\\n    \\n    return p;\\n}\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        pairp p=solve(root);\\n        if(p.s<0)\\n        {\\n            return  0;\\n        }\\n        return  ans;\\n        \\n    }```",
                "solutionTags": [],
                "code": "```\\nint ans=0;\\nclass pairp\\n{\\n    public:\\n    bool  is;\\n    int s;\\n    int mi;\\n    int ma;\\n    \\n};\\npairp  solve(TreeNode *root)\\n{   \\n    pairp  p;\\n    if(root->left==NULL && root->right==NULL)\\n    {\\n       p.is=true;\\n       p.s=root->val;\\n        ans=max(ans,root->val);\\n       p.mi=root->val; \\n       p.ma=root->val; \\n       return p; \\n    }\\n    \\n    pairp  x;\\n    pairp  y;\\n   \\n    if(root->left!=NULL &&  root->right!=NULL   )\\n    {\\n       x=solve(root->left);\\n       y=solve(root->right); \\n       if(x.is==false ||  y.is==false ||  root->val <=x.ma  ||  root->val >= y.mi)\\n       {\\n           p.is=false;\\n           p.s=0;\\n           p.mi=0;\\n           p.ma=0;\\n           return  p;\\n       }\\n       p.s=x.s+y.s+root->val;\\n        ans=max(ans,p.s);\\n       p.is=true;\\n        p.mi=x.mi;\\n        p.ma=y.ma;\\n        return  p;\\n    }\\n    if(root->left==NULL && root->right!=NULL)\\n    {\\n        y=solve(root->right);\\n        if(y.is==false || (root->val  >= y.mi))\\n        {\\n            p.is=false;\\n            p.s=0;\\n            p.mi=0;\\n            p.ma=0;\\n            return p;\\n        }\\n        p.is=true;\\n        p.s=y.s+root->val;\\n        ans=max(ans,p.s);\\n        p.mi=root->val;\\n        p.ma=y.ma;\\n        return  p;\\n    }\\n    if(root->left!=NULL && root->right==NULL)\\n    {\\n        x=solve(root->left);\\n        if(x.is==false ||  ( x.ma >= root->val))\\n        {\\n            p.is=false;\\n            p.s=0;\\n            p.mi=0;\\n            p.ma=0;\\n            return  p;\\n        }\\n        p.is=true;\\n        p.s=x.s+root->val;\\n        ans=max(ans,p.s); \\n        p.mi=x.mi;\\n        p.ma=root->val;    \\n        \\n        return  p;\\n    }\\n    cout<<\"xx\";\\n    \\n    return p;\\n}\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        pairp p=solve(root);\\n        if(p.s<0)\\n        {\\n            return  0;\\n        }\\n        return  ans;\\n        \\n    }```",
                "codeTag": "C++"
            },
            {
                "id": 569913,
                "title": "java-solution-uses-post-order-traverse",
                "content": "I use post-order traverse. For each node return an array of 3 elements.\\n- 1st element: minimum value in the tree\\n- 2nd element: maximum value in the tree\\n- 3rd element: sum of all elements in the tree\\n\\nSpecial case:\\n- leaf node: return {null, null, 0}\\n- node that is not a binary search tree: return null\\n\\n\\n```\\nclass Solution {\\n    private int res = 0;\\n\\n    public int maxSumBST(TreeNode root) {\\n        postorder(root);\\n        return res;\\n    }\\n\\n    private Integer[] postorder(TreeNode root) {\\n        if (root == null) return new Integer[]{null, null, 0}; // min, max, sum\\n\\n        Integer[] left = postorder(root.left);\\n        Integer[] right = postorder(root.right);\\n\\n        boolean isLeftBST = left != null && (left[1] == null || (left[1] != null && root.val > left[1]));\\n        boolean isRightBST = right != null && (right[0] == null || (right[0] != null && root.val < right[0]));\\n\\n        if (!isLeftBST || !isRightBST) return null; // not BST\\n\\n        int sum = root.val + left[2] + right[2];\\n        res = Math.max(res, sum);\\n\\n        int min = left[0] == null ? root.val : Math.min(root.val, left[0]);\\n        int max = right[1] == null ? root.val : Math.max(root.val, right[1]);\\n\\n        return new Integer[]{min, max, sum};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int res = 0;\\n\\n    public int maxSumBST(TreeNode root) {\\n        postorder(root);\\n        return res;\\n    }\\n\\n    private Integer[] postorder(TreeNode root) {\\n        if (root == null) return new Integer[]{null, null, 0}; // min, max, sum\\n\\n        Integer[] left = postorder(root.left);\\n        Integer[] right = postorder(root.right);\\n\\n        boolean isLeftBST = left != null && (left[1] == null || (left[1] != null && root.val > left[1]));\\n        boolean isRightBST = right != null && (right[0] == null || (right[0] != null && root.val < right[0]));\\n\\n        if (!isLeftBST || !isRightBST) return null; // not BST\\n\\n        int sum = root.val + left[2] + right[2];\\n        res = Math.max(res, sum);\\n\\n        int min = left[0] == null ? root.val : Math.min(root.val, left[0]);\\n        int max = right[1] == null ? root.val : Math.max(root.val, right[1]);\\n\\n        return new Integer[]{min, max, sum};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548438,
                "title": "python-o-n",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        \\n        def isBSTNode(node):\\n            if node.left and node.right:\\n                if not (node.left.val < node.val < node.right.val):\\n                    return False\\n                \\n            if not node.left and node.right:\\n                if not (node.right.val > node.val):\\n                    return False\\n            \\n            if not node.right and node.left:\\n                if not (node.left.val < node.val):\\n                    return False\\n            \\n            return True\\n        \\n        \\n        self.cost = 0\\n        \\n        def process(node):\\n            if not node:\\n                return 0\\n            \\n            lval = process(node.left)\\n            rval = process(node.right)\\n            \\n            if isBSTNode(node):\\n                result = node.val + lval + rval\\n                self.cost = max(self.cost, result)\\n                return result\\n            else:\\n                return float(\\'-inf\\') # We return -inf to ensure that, only BST node\\'s sum gets calculated\\n            \\n            \\n        process(root)\\n        return self.cost\\n",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        \\n        def isBSTNode(node):\\n            if node.left and node.right:\\n                if not (node.left.val < node.val < node.right.val):\\n                    return False\\n                \\n            if not node.left and node.right:\\n                if not (node.right.val > node.val):\\n                    return False\\n            \\n            if not node.right and node.left:\\n                if not (node.left.val < node.val):\\n                    return False\\n            \\n            return True\\n        \\n        \\n        self.cost = 0\\n        \\n        def process(node):\\n            if not node:\\n                return 0\\n            \\n            lval = process(node.left)\\n            rval = process(node.right)\\n            \\n            if isBSTNode(node):\\n                result = node.val + lval + rval\\n                self.cost = max(self.cost, result)\\n                return result\\n            else:\\n                return float(\\'-inf\\') # We return -inf to ensure that, only BST node\\'s sum gets calculated\\n            \\n            \\n        process(root)\\n        return self.cost\\n",
                "codeTag": "Java"
            },
            {
                "id": 534568,
                "title": "java-using-an-extra-node-to-store-the-information",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    \\n    class Node {\\n        int min;\\n        int max;\\n        int sum;\\n        boolean isBST;\\n    }\\n    \\n    int max = 0;\\n    public int maxSumBST(TreeNode root) {\\n        visit(root);\\n        return max;\\n    }\\n    private Node visit(TreeNode root) {\\n        if (root == null) {\\n            Node node = new Node();\\n            node.min = Integer.MAX_VALUE;\\n            node.max = Integer.MIN_VALUE;\\n            node.isBST = true;\\n            return node;\\n        }\\n        Node left = visit(root.left);\\n        Node right = visit(root.right);\\n        if (!left.isBST || !right.isBST || left.max >= root.val || right.min <= root.val) {\\n            Node node = new Node();\\n            node.min = Math.min(root.val,left.min);\\n            node.max = Math.max(root.val, right.max);\\n            node.isBST = false;\\n          return node;   \\n        }\\n        Node node = new Node();\\n        node.min = Math.min(root.val,left.min);\\n        node.max = Math.max(root.val, right.max);\\n        node.sum = root.val + left.sum + right.sum;\\n        max = Math.max(node.sum,max);\\n        node.isBST = true;\\n        return node;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    \\n    class Node {\\n        int min;\\n        int max;\\n        int sum;\\n        boolean isBST;\\n    }\\n    \\n    int max = 0;\\n    public int maxSumBST(TreeNode root) {\\n        visit(root);\\n        return max;\\n    }\\n    private Node visit(TreeNode root) {\\n        if (root == null) {\\n            Node node = new Node();\\n            node.min = Integer.MAX_VALUE;\\n            node.max = Integer.MIN_VALUE;\\n            node.isBST = true;\\n            return node;\\n        }\\n        Node left = visit(root.left);\\n        Node right = visit(root.right);\\n        if (!left.isBST || !right.isBST || left.max >= root.val || right.min <= root.val) {\\n            Node node = new Node();\\n            node.min = Math.min(root.val,left.min);\\n            node.max = Math.max(root.val, right.max);\\n            node.isBST = false;\\n          return node;   \\n        }\\n        Node node = new Node();\\n        node.min = Math.min(root.val,left.min);\\n        node.max = Math.max(root.val, right.max);\\n        node.sum = root.val + left.sum + right.sum;\\n        max = Math.max(node.sum,max);\\n        node.isBST = true;\\n        return node;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532021,
                "title": "java-post-order",
                "content": "* the returned array contains 5 elements:\\n\\t* int[0] - a boolean value, 1 means the current tree is a BST, 0 means it\\'s not\\n\\t* int[1] - the sum of the tree\\n\\t* int[2] - BST left boundary\\n\\t* int[3] - BST right boundary\\n\\t* int[4] - track global maximum sum\\n```\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        return postorder(root)[4];\\n    }\\n    \\n    private int[] postorder(TreeNode node) {\\n        if (node == null) {\\n            return new int[]{1, 0, Integer.MAX_VALUE, Integer.MIN_VALUE, 0};\\n        }\\n        int[] ll = postorder(node.left);\\n        int[] rr = postorder(node.right);\\n        int local_max = Math.max(ll[4], rr[4]);\\n        \\n        if (ll[0] == 1 && rr[0] == 1 && node.val > ll[3] && node.val < rr[2]) { // it is a BST\\n            int sum = node.val + ll[1] + rr[1];\\n            return new int[]{1, sum, ll[2] == Integer.MAX_VALUE ? node.val : ll[2], rr[3] == Integer.MIN_VALUE ? node.val : rr[3], Math.max(sum, local_max)};\\n        } else {\\n            return new int[]{0, 0, 0, 0, local_max};\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        return postorder(root)[4];\\n    }\\n    \\n    private int[] postorder(TreeNode node) {\\n        if (node == null) {\\n            return new int[]{1, 0, Integer.MAX_VALUE, Integer.MIN_VALUE, 0};\\n        }\\n        int[] ll = postorder(node.left);\\n        int[] rr = postorder(node.right);\\n        int local_max = Math.max(ll[4], rr[4]);\\n        \\n        if (ll[0] == 1 && rr[0] == 1 && node.val > ll[3] && node.val < rr[2]) { // it is a BST\\n            int sum = node.val + ll[1] + rr[1];\\n            return new int[]{1, sum, ll[2] == Integer.MAX_VALUE ? node.val : ll[2], rr[3] == Integer.MIN_VALUE ? node.val : rr[3], Math.max(sum, local_max)};\\n        } else {\\n            return new int[]{0, 0, 0, 0, local_max};\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531955,
                "title": "c-recursion",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    int maxSum = 0;\\n    public int MaxSumBST(TreeNode root) {\\n        Helper(root);\\n        return maxSum;\\n    }\\n    \\n    private (bool IsBST, int Sum, TreeNode Min, TreeNode Max) Helper(TreeNode node)\\n    {\\n        if(node == null) return (true,0,null,null);\\n        var left = Helper(node.left);\\n        var right = Helper(node.right);\\n        bool isValid = false;\\n        int sum = node.val + left.Sum + right.Sum;\\n        if(left.IsBST && right.IsBST && (left.Max == null || node.val > left.Max.val) && (right.Min == null || node.val < right.Min.val))\\n        {\\n            isValid = true;\\n            maxSum = Math.Max(maxSum, sum);\\n        }\\n        \\n        return (isValid, sum, left.Min??node, right.Max??node);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    int maxSum = 0;\\n    public int MaxSumBST(TreeNode root) {\\n        Helper(root);\\n        return maxSum;\\n    }\\n    \\n    private (bool IsBST, int Sum, TreeNode Min, TreeNode Max) Helper(TreeNode node)\\n    {\\n        if(node == null) return (true,0,null,null);\\n        var left = Helper(node.left);\\n        var right = Helper(node.right);\\n        bool isValid = false;\\n        int sum = node.val + left.Sum + right.Sum;\\n        if(left.IsBST && right.IsBST && (left.Max == null || node.val > left.Max.val) && (right.Min == null || node.val < right.Min.val))\\n        {\\n            isValid = true;\\n            maxSum = Math.Max(maxSum, sum);\\n        }\\n        \\n        return (isValid, sum, left.Min??node, right.Max??node);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531879,
                "title": "simple-c-dfs-returning-multiple-states",
                "content": "```csharp\\npublic class Solution {\\n    int max = 0;\\n    public int MaxSumBST(TreeNode root) {\\n        Evaluate(root);\\n        return max;\\n    }\\n    \\n    public (bool isBST, int min, int max, int sum) Evaluate(TreeNode root){\\n        \\n        if(root is null) return (true, int.MaxValue, int.MinValue, 0);\\n        if(root.left is null && root.right is null){\\n            max = Math.Max(root.val, max);\\n            return (true, root.val, root.val, root.val);\\n        }\\n        var left = Evaluate(root.left);\\n        var right = Evaluate(root.right);\\n        bool isBSTree = left.isBST && right.isBST && left.max<root.val && right.min>root.val;\\n        if(isBSTree){\\n            (bool isBST, int min, int max, int sum) result = (\\n                left.isBST && right.isBST && left.max<root.val && right.min>root.val,\\n                Math.Min(left.min, root.val),\\n                Math.Max(right.max, root.val),\\n                left.sum+right.sum+root.val\\n            );\\n            \\n            max = Math.Max(result.sum, max);\\n            return result;\\n        }\\n        else{\\n            (bool isBST, int min, int max, int sum) result = (false, 0, 0,0);\\n            return result;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution {\\n    int max = 0;\\n    public int MaxSumBST(TreeNode root) {\\n        Evaluate(root);\\n        return max;\\n    }\\n    \\n    public (bool isBST, int min, int max, int sum) Evaluate(TreeNode root){\\n        \\n        if(root is null) return (true, int.MaxValue, int.MinValue, 0);\\n        if(root.left is null && root.right is null){\\n            max = Math.Max(root.val, max);\\n            return (true, root.val, root.val, root.val);\\n        }\\n        var left = Evaluate(root.left);\\n        var right = Evaluate(root.right);\\n        bool isBSTree = left.isBST && right.isBST && left.max<root.val && right.min>root.val;\\n        if(isBSTree){\\n            (bool isBST, int min, int max, int sum) result = (\\n                left.isBST && right.isBST && left.max<root.val && right.min>root.val,\\n                Math.Min(left.min, root.val),\\n                Math.Max(right.max, root.val),\\n                left.sum+right.sum+root.val\\n            );\\n            \\n            max = Math.Max(result.sum, max);\\n            return result;\\n        }\\n        else{\\n            (bool isBST, int min, int max, int sum) result = (false, 0, 0,0);\\n            return result;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531801,
                "title": "java-recursion",
                "content": "```\\nclass Solution {\\n    class Triplet{\\n        int min;\\n        int max;\\n        int sum;\\n        Triplet(int min, int max, int sum){\\n            this.min = min;\\n            this.max = max;\\n            this.sum = sum;\\n        }\\n    }\\n    int ans ;\\n    public int maxSumBST(TreeNode root) {\\n        ans = 0;\\n        rec(root);\\n        return ans;\\n    }\\n    \\n    Triplet rec(TreeNode root){\\n        if(root == null){\\n            return new Triplet(0, 0, 0);\\n        }\\n        Triplet left = rec(root.left);\\n        Triplet right = rec(root.right);\\n        if(root.left == null && root.right == null){\\n            ans = Math.max(ans, root.val);\\n            return new Triplet(root.val, root.val , root.val);\\n        }\\n        if(root.left == null && root.val < right.min){\\n            ans = Math.max(ans, right.sum + root.val);\\n            return new Triplet(root.val, right.max , right.sum + root.val);\\n        }\\n        if(root.right == null && root.val > left.max){\\n            ans = Math.max(ans, left.sum + root.val);\\n            return new Triplet(left.min, root.val , left.sum + root.val);\\n        }\\n        if(root.val > left.max && root.val < right.min){\\n            ans = Math.max(ans, left.sum + right.sum + root.val);\\n            return new Triplet(left.min, right.max, left.sum + right.sum + root.val);\\n        }\\n        return new Triplet(Integer.MIN_VALUE, Integer.MAX_VALUE, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Triplet{\\n        int min;\\n        int max;\\n        int sum;\\n        Triplet(int min, int max, int sum){\\n            this.min = min;\\n            this.max = max;\\n            this.sum = sum;\\n        }\\n    }\\n    int ans ;\\n    public int maxSumBST(TreeNode root) {\\n        ans = 0;\\n        rec(root);\\n        return ans;\\n    }\\n    \\n    Triplet rec(TreeNode root){\\n        if(root == null){\\n            return new Triplet(0, 0, 0);\\n        }\\n        Triplet left = rec(root.left);\\n        Triplet right = rec(root.right);\\n        if(root.left == null && root.right == null){\\n            ans = Math.max(ans, root.val);\\n            return new Triplet(root.val, root.val , root.val);\\n        }\\n        if(root.left == null && root.val < right.min){\\n            ans = Math.max(ans, right.sum + root.val);\\n            return new Triplet(root.val, right.max , right.sum + root.val);\\n        }\\n        if(root.right == null && root.val > left.max){\\n            ans = Math.max(ans, left.sum + root.val);\\n            return new Triplet(left.min, root.val , left.sum + root.val);\\n        }\\n        if(root.val > left.max && root.val < right.min){\\n            ans = Math.max(ans, left.sum + right.sum + root.val);\\n            return new Triplet(left.min, right.max, left.sum + right.sum + root.val);\\n        }\\n        return new Triplet(Integer.MIN_VALUE, Integer.MAX_VALUE, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008914,
                "title": "easy-solution-solved-by-using-class-with-o-n-space-complexity-ans-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(N);\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nclass info{\\n public:\\n    int maxi;\\n    int mini;\\n    bool isbst;\\n    int sum;\\n };\\n    info solve(TreeNode* root , int &ans){\\n           if( root ==NULL){\\n                 return {INT_MIN , INT_MAX   , 1 , 0}; }\\n           if( root->left ==NULL && root->right ==NULL){\\n                ans = max(ans , root->val);\\n                 return {root->val , root->val , true , root->val};\\n            }\\n\\n           info leftans = solve(root->left  , ans);\\n           info rightans = solve( root->right , ans);\\n\\n             info currentnode;\\n             currentnode.maxi = max(root->val , rightans.maxi);\\n             currentnode.mini  = min(root->val  , leftans.mini);\\n             currentnode.sum = root->val + rightans.sum + leftans.sum;\\n\\n             if( leftans.isbst && rightans.isbst && ( root->val > leftans.maxi &&              root->val<rightans.mini)){\\n                   currentnode.isbst = true;}\\n             else{\\n                   currentnode.isbst = false;\\n             }\\n             if(currentnode.isbst){\\n                   ans = max(ans, currentnode.sum);\\n             }\\n             return currentnode;\\n    }\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n               int ans = 0;\\n           solve( root , ans );\\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nclass info{\\n public:\\n    int maxi;\\n    int mini;\\n    bool isbst;\\n    int sum;\\n };\\n    info solve(TreeNode* root , int &ans){\\n           if( root ==NULL){\\n                 return {INT_MIN , INT_MAX   , 1 , 0}; }\\n           if( root->left ==NULL && root->right ==NULL){\\n                ans = max(ans , root->val);\\n                 return {root->val , root->val , true , root->val};\\n            }\\n\\n           info leftans = solve(root->left  , ans);\\n           info rightans = solve( root->right , ans);\\n\\n             info currentnode;\\n             currentnode.maxi = max(root->val , rightans.maxi);\\n             currentnode.mini  = min(root->val  , leftans.mini);\\n             currentnode.sum = root->val + rightans.sum + leftans.sum;\\n\\n             if( leftans.isbst && rightans.isbst && ( root->val > leftans.maxi &&              root->val<rightans.mini)){\\n                   currentnode.isbst = true;}\\n             else{\\n                   currentnode.isbst = false;\\n             }\\n             if(currentnode.isbst){\\n                   ans = max(ans, currentnode.sum);\\n             }\\n             return currentnode;\\n    }\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n               int ans = 0;\\n           solve( root , ans );\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977843,
                "title": "c-cleanest-solution-using-custom-structure-detailed-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursion returns bottom to top\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(H)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    //create struct to store info about left and right subtree\\n    struct subtree{\\n        bool isBST; //check if subtree is a BST\\n        int minn; //minimum value in subtree\\n        int maxx; //maximum value in subtree\\n        int sum; //sum of all values in subtree\\n    };\\n\\n    struct subtree traverse(TreeNode* root, int &ans){\\n        if(!root) return {true, INT_MAX, INT_MIN, 0};\\n        //empty tree is a valid BST with sum 0 hence true\\n        //initialise min and max to +inf and -inf respectively\\n\\n        subtree lst = traverse(root->left, ans); //recurse left\\n        subtree rst = traverse(root->right, ans); //recurse right\\n\\n        //get information about current node\\n        bool flag = true; \\n        int minval = min({root->val, lst.minn, rst.minn});\\n        int maxval = max({root->val, lst.maxx, rst.maxx});\\n        int subtreeSum = root->val + lst.sum + rst.sum;\\n\\n    //for BST root is greater than all elements in left subtree\\n                //and smaller than all elements in right subtree\\n        if(root->val <= lst.maxx || root->val >= rst.minn)\\n            flag = false;\\n        \\n        //if we are at valid subtree then update ans\\n        if(flag && lst.isBST && rst.isBST)\\n            ans = max(ans, subtreeSum);\\n\\n        return {flag, minval, maxval, subtreeSum};\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        traverse(root, ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    //create struct to store info about left and right subtree\\n    struct subtree{\\n        bool isBST; //check if subtree is a BST\\n        int minn; //minimum value in subtree\\n        int maxx; //maximum value in subtree\\n        int sum; //sum of all values in subtree\\n    };\\n\\n    struct subtree traverse(TreeNode* root, int &ans){\\n        if(!root) return {true, INT_MAX, INT_MIN, 0};\\n        //empty tree is a valid BST with sum 0 hence true\\n        //initialise min and max to +inf and -inf respectively\\n\\n        subtree lst = traverse(root->left, ans); //recurse left\\n        subtree rst = traverse(root->right, ans); //recurse right\\n\\n        //get information about current node\\n        bool flag = true; \\n        int minval = min({root->val, lst.minn, rst.minn});\\n        int maxval = max({root->val, lst.maxx, rst.maxx});\\n        int subtreeSum = root->val + lst.sum + rst.sum;\\n\\n    //for BST root is greater than all elements in left subtree\\n                //and smaller than all elements in right subtree\\n        if(root->val <= lst.maxx || root->val >= rst.minn)\\n            flag = false;\\n        \\n        //if we are at valid subtree then update ans\\n        if(flag && lst.isBST && rst.isBST)\\n            ans = max(ans, subtreeSum);\\n\\n        return {flag, minval, maxval, subtreeSum};\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        traverse(root, ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818001,
                "title": "c-easy-to-understand-solution-with-explanation",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass f{\\n  public:\\n    int maxi,mini,maxv,s;\\n    f(int maxi,int mini,int s)\\n    {\\n        this->maxi=maxi;// used for storing maximum value\\n        this->mini=mini;//usd for storing minimum value\\n       // this->maxv=maxv;\\n        this->s=s;// used for running valid bst sum\\n    }\\n};\\nint maxi=INT_MIN;// used for calculating maximum sum\\n\\nclass Solution {\\npublic:\\n    f f1(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return f(INT_MIN,INT_MAX,0);// if root is null then we send sum as 0\\n        f l=f1(root->left);\\n        f r=f1(root->right);\\n        if(root->val>l.maxi and root->val<r.mini)// for valid bst we take maximum from left subtree and minimum fom right subtree and check if current node value lies in the range\\n        {\\n             maxi=max({maxi,l.s+r.s+root->val});//if condition is valid then \\n            //only check for maximum sum which is left sum +right sum +current value of root\\n            return f(max(r.maxi,root->val),min(l.mini,root->val),root->val+l.s+r.s);\\n        }\\n        return f(INT_MAX,INT_MIN,0);// if not bst then we send maximum value as maximum as possible and minimum as minimum as possible so it would never be bst \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        maxi=INT_MIN;\\n        f a=f1(root);\\n        return (maxi<0)?0:maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass f{\\n  public:\\n    int maxi,mini,maxv,s;\\n    f(int maxi,int mini,int s)\\n    {\\n        this->maxi=maxi;// used for storing maximum value\\n        this->mini=mini;//usd for storing minimum value\\n       // this->maxv=maxv;\\n        this->s=s;// used for running valid bst sum\\n    }\\n};\\nint maxi=INT_MIN;// used for calculating maximum sum\\n\\nclass Solution {\\npublic:\\n    f f1(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return f(INT_MIN,INT_MAX,0);// if root is null then we send sum as 0\\n        f l=f1(root->left);\\n        f r=f1(root->right);\\n        if(root->val>l.maxi and root->val<r.mini)// for valid bst we take maximum from left subtree and minimum fom right subtree and check if current node value lies in the range\\n        {\\n             maxi=max({maxi,l.s+r.s+root->val});//if condition is valid then \\n            //only check for maximum sum which is left sum +right sum +current value of root\\n            return f(max(r.maxi,root->val),min(l.mini,root->val),root->val+l.s+r.s);\\n        }\\n        return f(INT_MAX,INT_MIN,0);// if not bst then we send maximum value as maximum as possible and minimum as minimum as possible so it would never be bst \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        maxi=INT_MIN;\\n        f a=f1(root);\\n        return (maxi<0)?0:maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672062,
                "title": "very-easy-and-full-explained-c-solution",
                "content": "# Intuition\\nThe code recursively checks each subtree to determine if it is a valid BST and calculates the sum of its values. It keeps track of the maximum sum encountered and returns the overall maximum sum of a BST within the binary tree.\\n\\n# Approach\\n\\nThe provided code is a solution for finding the maximum sum of a binary search tree (BST) in a given binary tree. Here\\'s the intuition behind the code:\\n\\nThe code defines a struct/class called node, which represents information about a subtree in the binary tree. It contains the maximum value (maxi) and minimum value (mini) within the subtree, a boolean flag (isbst) indicating whether the subtree is a valid BST, and the sum of values within the subtree (sum).\\n\\nThe solve function is a recursive function that takes a TreeNode* representing the root of a subtree and a reference to an integer sum variable. It returns a node object representing the information about the subtree.\\n\\nThe base case of the solve function is when the current node is NULL, indicating an empty subtree. In this case, it returns a node object with INT_MIN as the maximum value, INT_MAX as the minimum value, 1 for the isbst flag (an empty subtree is considered a valid BST), and 0 as the sum.\\n\\nFor a non-empty subtree, the solve function recursively calls itself on the left and right subtrees to obtain the node objects representing the information about those subtrees.\\n\\nThe code then checks if the current subtree, rooted at root, is a valid BST. It verifies that both the left and right subtrees are valid BSTs (lf.isbst and rt.isbst are true) and that the value of the root node is greater than the maximum value in the left subtree and less than the minimum value in the right subtree.\\n\\nIf the subtree is a valid BST, the code updates the sum variable by adding the sum of values in the left subtree, right subtree, and the value of the current root node. It also returns a node object with the maximum value as the greater of the maximum values in the right subtree and the current root value, the minimum value as the lesser of the minimum values in the left subtree and the current root value, 1 for the isbst flag (indicating a valid BST), and the sum of values as calculated.\\n\\nIf the subtree is not a valid BST, the code returns a node object with INT_MAX as the maximum value, INT_MIN as the minimum value, 0 for the isbst flag (indicating an invalid BST), and 0 as the sum.\\n\\nFinally, the maxSumBST function initializes the ans variable to 0 and calls the solve function on the root of the entire tree, passing ans as a reference. It then returns the updated value of ans, which represents the maximum sum of a BST within the binary tree.\\n\\n# Complexity\\n- Time complexity:\\nO(N) where N is number of nodes.\\n\\n- Space complexity:\\nO(H) Auxilary space were H is hight of Binary Tree. In worst Case O(N).\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass node{\\n    public:\\n    int maxi;\\n    int mini;\\n    bool isbst;\\n    int sum;\\n};\\n\\nclass Solution {\\npublic:\\n    node solve(TreeNode* root,int &sum)\\n    {\\n        if(root==NULL)\\n        {\\n            return {INT_MIN,INT_MAX,1,0};\\n        }\\n        node lf = solve(root->left,sum);\\n        node rt = solve(root->right,sum);\\n        if(lf.isbst && rt.isbst && (root->val > lf.maxi) && (root->val <rt.mini))\\n        {\\n            sum = max(sum,lf.sum+rt.sum+root->val);\\n            return {max(rt.maxi,root->val),min(lf.mini,root->val),1,lf.sum+rt.sum+root->val};\\n        }\\n            return {INT_MAX,INT_MIN,0,0};\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        node val = solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass node{\\n    public:\\n    int maxi;\\n    int mini;\\n    bool isbst;\\n    int sum;\\n};\\n\\nclass Solution {\\npublic:\\n    node solve(TreeNode* root,int &sum)\\n    {\\n        if(root==NULL)\\n        {\\n            return {INT_MIN,INT_MAX,1,0};\\n        }\\n        node lf = solve(root->left,sum);\\n        node rt = solve(root->right,sum);\\n        if(lf.isbst && rt.isbst && (root->val > lf.maxi) && (root->val <rt.mini))\\n        {\\n            sum = max(sum,lf.sum+rt.sum+root->val);\\n            return {max(rt.maxi,root->val),min(lf.mini,root->val),1,lf.sum+rt.sum+root->val};\\n        }\\n            return {INT_MAX,INT_MIN,0,0};\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        node val = solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465913,
                "title": "easy-java-solution-using-recursion-dp-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ **(Ignoring recursive stack Space)** \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    class pair{\\n        int min;\\n        int max;\\n        boolean isBST;\\n        int treeSum;\\n\\n        pair(int min, int max, boolean isBST, int treeSum){\\n            this.min = min;\\n            this.max= max;\\n            this.isBST= isBST;\\n            this.treeSum= treeSum;\\n        }\\n    }\\n\\n    int maxSum;\\n    public int maxSumBST(TreeNode root) {\\n        maxSum= 0;\\n        check(root);\\n        return maxSum;\\n    }\\n\\n    public pair check(TreeNode root){\\n        if(root == null){\\n            return new pair(Integer.MAX_VALUE, Integer.MIN_VALUE, true, 0);\\n        }\\n\\n        pair left= check(root.left);\\n        pair right= check(root.right);\\n\\n        int newMin= Math.min(left.min, Math.min(root.val, right.min));\\n        int newMax= Math.max(left.max, Math.max(root.val, right.max));\\n        int newTreeSum= left.treeSum+ right.treeSum+ root.val;\\n\\n        if(left.isBST && right.isBST && left.max < root.val && root.val < right.min){\\n            maxSum= Math.max(maxSum, newTreeSum);\\n            return new pair(newMin, newMax, true, newTreeSum);\\n        }\\n        else{\\n            return new pair(newMin, newMax, false, newTreeSum);\\n        }\\n    }\\n}\\n```\\n![please-upvote.jpg](https://assets.leetcode.com/users/images/d3ffc9eb-9ce8-4e84-91db-43a47f58c337_1682764299.4043663.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    class pair{\\n        int min;\\n        int max;\\n        boolean isBST;\\n        int treeSum;\\n\\n        pair(int min, int max, boolean isBST, int treeSum){\\n            this.min = min;\\n            this.max= max;\\n            this.isBST= isBST;\\n            this.treeSum= treeSum;\\n        }\\n    }\\n\\n    int maxSum;\\n    public int maxSumBST(TreeNode root) {\\n        maxSum= 0;\\n        check(root);\\n        return maxSum;\\n    }\\n\\n    public pair check(TreeNode root){\\n        if(root == null){\\n            return new pair(Integer.MAX_VALUE, Integer.MIN_VALUE, true, 0);\\n        }\\n\\n        pair left= check(root.left);\\n        pair right= check(root.right);\\n\\n        int newMin= Math.min(left.min, Math.min(root.val, right.min));\\n        int newMax= Math.max(left.max, Math.max(root.val, right.max));\\n        int newTreeSum= left.treeSum+ right.treeSum+ root.val;\\n\\n        if(left.isBST && right.isBST && left.max < root.val && root.val < right.min){\\n            maxSum= Math.max(maxSum, newTreeSum);\\n            return new pair(newMin, newMax, true, newTreeSum);\\n        }\\n        else{\\n            return new pair(newMin, newMax, false, newTreeSum);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214829,
                "title": "1373-maximum-sum-bst-in-binary-tree-java",
                "content": "```\\nclass Solution {\\n    int max=0;\\n    public int maxSumBST(TreeNode root) {\\n          max=0;\\n        ans(root);\\n        return max;\\n    }\\n    class Pair {\\n        int sum,max,min;\\n        boolean bst;\\n        Pair (int s)\\n        {\\n            sum=s;\\n        }\\n        Pair(int s,int lmax,int rmin,boolean t)\\n        {\\n            sum=s;\\n            max= lmax;\\n            min=rmin;\\n            bst=t;\\n        }\\n    }\\n    public Pair ans(TreeNode root)\\n    {\\n        if(root==null)\\n            return new Pair (0,Integer.MIN_VALUE,Integer.MAX_VALUE,true);\\n        if(root.left==null&&root.right==null)\\n        {\\n            max=Math.max(root.val,max);\\n            return  new Pair(root.val,root.val,root.val,true);\\n        }\\n        Pair lp=ans(root.left),rp=ans(root.right);\\n        Pair np=new Pair(lp.sum+root.val+rp.sum);\\n        \\n        if(root.val>lp.max&&root.val<rp.min&&lp.bst&&rp.bst)\\n        {\\n            max=Math.max(max,np.sum);\\n            np.bst=true;\\n        }\\n        else\\n            np.bst=false;\\n        np.min=Math.min(root.val,lp.min);\\n        np.max=Math.max(root.val,rp.max);\\n        return np;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max=0;\\n    public int maxSumBST(TreeNode root) {\\n          max=0;\\n        ans(root);\\n        return max;\\n    }\\n    class Pair {\\n        int sum,max,min;\\n        boolean bst;\\n        Pair (int s)\\n        {\\n            sum=s;\\n        }\\n        Pair(int s,int lmax,int rmin,boolean t)\\n        {\\n            sum=s;\\n            max= lmax;\\n            min=rmin;\\n            bst=t;\\n        }\\n    }\\n    public Pair ans(TreeNode root)\\n    {\\n        if(root==null)\\n            return new Pair (0,Integer.MIN_VALUE,Integer.MAX_VALUE,true);\\n        if(root.left==null&&root.right==null)\\n        {\\n            max=Math.max(root.val,max);\\n            return  new Pair(root.val,root.val,root.val,true);\\n        }\\n        Pair lp=ans(root.left),rp=ans(root.right);\\n        Pair np=new Pair(lp.sum+root.val+rp.sum);\\n        \\n        if(root.val>lp.max&&root.val<rp.min&&lp.bst&&rp.bst)\\n        {\\n            max=Math.max(max,np.sum);\\n            np.bst=true;\\n        }\\n        else\\n            np.bst=false;\\n        np.min=Math.min(root.val,lp.min);\\n        np.max=Math.max(root.val,rp.max);\\n        return np;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101222,
                "title": "c-easiest-approach-using-reccursion",
                "content": "\\t   class info{\\n\\t\\tpublic:\\n\\t\\tint mini;\\n\\t\\tint maxi;\\n\\t\\tbool isBST;\\n\\t\\tint sum;\\n\\t};\\n\\tclass Solution {\\n\\tpublic:\\n\\n    info solve(TreeNode* root,int &sum){\\n        //base case\\n        if(root==NULL){\\n            return {INT_MAX,INT_MIN,true,0 };\\n        }\\n        \\n        info leftAns=solve(root->left,sum);\\n        info rightAns=solve(root->right,sum);\\n        \\n        info currNode;\\n        \\n        currNode.mini = min(root->val,leftAns.mini);\\n        currNode.maxi = max(root->val,rightAns.maxi);\\n        currNode.sum  = leftAns.sum + rightAns.sum + root->val;\\n        \\n        if(leftAns.isBST && rightAns.isBST && ( root->val > leftAns.maxi && root->val < rightAns.mini) ){\\n            currNode.isBST=true;\\n        }\\n        else{\\n            currNode.isBST=false;}\\n        \\n        if(currNode.isBST)\\n        sum=max(sum,currNode.sum);\\n        \\n        return currNode; \\n        \\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        int sum=0;\\n        info temp=solve(root,sum);\\n        return sum;\\n    }\\n};\\nPlease UPVOTE if It Helps!!",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n    info solve(TreeNode* root,int &sum){\\n        //base case\\n        if(root==NULL){\\n            return {INT_MAX,INT_MIN,true,0 }",
                "codeTag": "Java"
            },
            {
                "id": 3096897,
                "title": "little-bit-hard-as-level-suggested-postorder-traversal-tc-o-n",
                "content": "Striver\\'s Tree Series Solution\\n\\n# Complexity\\n- Time complexity: O(n) (n=number of nodes)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1) (except recursion stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass nodeValue{\\n    public int maxValue, minValue, maxSum;\\n    public nodeValue(int maxValue, int minValue, int maxSum){\\n        this.maxValue=maxValue;\\n        this.minValue=minValue;\\n        this.maxSum=maxSum;\\n    }\\n}\\nclass Solution {\\n    int max=0;\\n    public nodeValue helper(TreeNode root){\\n        if(root==null)\\n            return new nodeValue(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        nodeValue left=helper(root.left);\\n        nodeValue right=helper(root.right);\\n        if(left.maxValue<root.val && root.val<right.minValue){\\n            max=Math.max(max,root.val+left.maxSum+right.maxSum);\\n            return new nodeValue(Math.max(root.val,right.maxValue),Math.min(root.val,left.minValue),root.val+left.maxSum+right.maxSum);\\n        }\\n        return new nodeValue(Integer.MAX_VALUE,Integer.MIN_VALUE,Math.max(left.maxSum,right.maxSum));\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass nodeValue{\\n    public int maxValue, minValue, maxSum;\\n    public nodeValue(int maxValue, int minValue, int maxSum){\\n        this.maxValue=maxValue;\\n        this.minValue=minValue;\\n        this.maxSum=maxSum;\\n    }\\n}\\nclass Solution {\\n    int max=0;\\n    public nodeValue helper(TreeNode root){\\n        if(root==null)\\n            return new nodeValue(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        nodeValue left=helper(root.left);\\n        nodeValue right=helper(root.right);\\n        if(left.maxValue<root.val && root.val<right.minValue){\\n            max=Math.max(max,root.val+left.maxSum+right.maxSum);\\n            return new nodeValue(Math.max(root.val,right.maxValue),Math.min(root.val,left.minValue),root.val+left.maxSum+right.maxSum);\\n        }\\n        return new nodeValue(Integer.MAX_VALUE,Integer.MIN_VALUE,Math.max(left.maxSum,right.maxSum));\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889690,
                "title": "c-post-order-traversal-with-intuition-and-approach-clean-and-easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf I have a node, then to be part of a BST it must be greater than the larget node on it\\'s left and smaller than the smallest value on it\\'s right.\\n\\n> **largest of all nodes(from left) < curr Node < smallest of all nodes(from right)**\\n\\nWe will use bottom up approach. Starting from the leaf node, if it follows the above condition, we will add it to BST.\\n\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\nWe will take a container to store (maxNode from left, minNode from right, and BST sum). In my code I have used class NodeValue(minNode, maxNode, BSTSum) for the same. This we will return each time recursively.\\nThe traversal used is POST order traversal. First we will take sum from left then from right and will add it to current node.\\n> **currSum = currNode + left tree sum + right tree sum**\\nMeanwhile we will store the max sum in a variable, which will we final answer at end of traversal.\\nIn case node is not a BST then we will return INT_MAX from left and INT_MIN from right so that parent cannot be a BST.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass NodeValue {\\npublic:\\n    int minNode, maxNode, BSTSum;\\n    NodeValue() {\\n        this->maxNode = INT_MIN;\\n        this->minNode = INT_MAX;\\n        this->BSTSum = 0;\\n    }\\n    NodeValue(int maxNode, int minNode, int BSTSum) {\\n        this->maxNode = maxNode;\\n        this->minNode = minNode;\\n        this->BSTSum = BSTSum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    NodeValue maxSumBSTHelper(TreeNode* root) {\\n        // An empty tree is a BST of size 0.\\n        if(!root) return NodeValue();\\n\\n        // Get values from left and right subtree of current tree.\\n        auto left = maxSumBSTHelper(root->left);\\n        auto right = maxSumBSTHelper(root->right);\\n\\n        // Current node is greater than max in left AND smaller than min in right, it is a BST.\\n        if(root->val > left.maxNode && root->val < right.minNode) {\\n            // Calculate sum of current node value, left subtree sum and right subtree sum in case of BST.\\n            int currSum = root->val + left.BSTSum + right.BSTSum;\\n            ans = max(ans, currSum);\\n            return NodeValue(max(right.maxNode, root->val), min(left.minNode, root->val), currSum);\\n        }\\n\\n        // Otherwise return [-inf, inf] so that parent can\\'t be valid BST.\\n        return NodeValue(INT_MAX, INT_MIN, max(left.BSTSum, right.BSTSum));\\n\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        maxSumBSTHelper(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass NodeValue {\\npublic:\\n    int minNode, maxNode, BSTSum;\\n    NodeValue() {\\n        this->maxNode = INT_MIN;\\n        this->minNode = INT_MAX;\\n        this->BSTSum = 0;\\n    }\\n    NodeValue(int maxNode, int minNode, int BSTSum) {\\n        this->maxNode = maxNode;\\n        this->minNode = minNode;\\n        this->BSTSum = BSTSum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    NodeValue maxSumBSTHelper(TreeNode* root) {\\n        // An empty tree is a BST of size 0.\\n        if(!root) return NodeValue();\\n\\n        // Get values from left and right subtree of current tree.\\n        auto left = maxSumBSTHelper(root->left);\\n        auto right = maxSumBSTHelper(root->right);\\n\\n        // Current node is greater than max in left AND smaller than min in right, it is a BST.\\n        if(root->val > left.maxNode && root->val < right.minNode) {\\n            // Calculate sum of current node value, left subtree sum and right subtree sum in case of BST.\\n            int currSum = root->val + left.BSTSum + right.BSTSum;\\n            ans = max(ans, currSum);\\n            return NodeValue(max(right.maxNode, root->val), min(left.minNode, root->val), currSum);\\n        }\\n\\n        // Otherwise return [-inf, inf] so that parent can\\'t be valid BST.\\n        return NodeValue(INT_MAX, INT_MIN, max(left.BSTSum, right.BSTSum));\\n\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        maxSumBSTHelper(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842783,
                "title": "cpp-dfs-solution-explained-every-step",
                "content": "**IF YOU FOUND THIS SOLUTION HELPFUL THEN PLEASE LIKE IT**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t// return type store in vector<int>{check that child is binary search tree (-1 if tree is not bst and 1 if tree is bst),total sum below root,maximum value node till now,minimum value till now};\\n\\t\\tvector<int> func(TreeNode*root,int &ans)\\n\\t\\t{\\n\\t\\t\\t//if we reach leaf node then we return it.\\n\\t\\t\\tif(root->left==NULL and root->right==NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans=max(ans,root->val);\\n\\t\\t\\t\\treturn {1,root->val,root->val,root->val};\\n\\t\\t\\t}\\n\\t\\t\\t// a vector store information of left subtree.\\n\\t\\t\\tvector<int>a{1,0,INT_MIN,INT_MAX};\\n\\t\\t\\t// b node stores information of right subtree.\\n\\t\\t\\tvector<int>b{1,0,INT_MIN,INT_MAX};\\n\\t\\t\\tif(root->left)\\n\\t\\t\\t{\\n\\t\\t\\t\\ta=func(root->left,ans);\\n\\t\\t\\t}\\n\\t\\t\\tif(root->right)\\n\\t\\t\\t{\\n\\t\\t\\t\\tb=func(root->right,ans);\\n\\t\\t\\t}\\n\\t\\t\\tint g=-1,h=-1;\\n\\t\\t\\t// g and h are variables to check left and right child make it bst or not.\\n\\t\\t\\tif(root->left and root->left->val>=root->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tg=1;\\n\\t\\t\\t}\\n\\t\\t\\tif(root->right and root->right->val<=root->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\th=1;\\n\\t\\t\\t}\\n\\t\\t\\t// check that right and left subtree are bst or not and also comparing maximum value of left subtree and minimum value of right subtree with root value.\\n\\t\\t\\tif(a[0]==1 and b[0]==1 and g==-1 and h==-1 and a[2]<root->val and b[3]>root->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// ans variable stores the maximum sum of bst subtree.\\n\\t\\t\\t\\tans=max(ans,root->val+a[1]+b[1]);\\n\\t\\t\\t\\treturn {1,root->val+a[1]+b[1],max(b[2],root->val),min(a[3],root->val)};\\n\\t\\t\\t}\\n\\t\\t\\treturn {-1,-1,-1,-1};\\n\\t\\t}\\n\\t\\tint maxSumBST(TreeNode* root) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfunc(root,ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t// return type store in vector<int>{check that child is binary search tree (-1 if tree is not bst and 1 if tree is bst),total sum below root,maximum value node till now,minimum value till now}",
                "codeTag": "Java"
            },
            {
                "id": 2662707,
                "title": "o-n-easy-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1- Try to think bottom-up approach\\n1a- Firsty we need to check for BST.\\n1b- leaf node is always BST \\n1c- If the current substree is not BST we will not get further BST(bottom-up approach). ie\\n\\n  \\n![New-Text-Document.jpg](https://assets.leetcode.com/users/images/74785c1a-1332-4287-943d-a1f808ed9b32_1664948351.0630493.jpeg)\\n\\n2- How to check for BST optimally(ie O(1) ) \\n2a- since in BST root value is greater than its left child value and less than its right child value so we need 2 parameter, store min value so far and store max value so far.\\n\\n3- If the current subtree is BST we will update our ans to max subtree sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint ans=0;\\n \\n    vector<int>solve(TreeNode *root)\\n    {\\n        if(!root) return {INT_MAX,INT_MIN,0};\\n        if(!root->left && !root->right)\\n        {\\n            ans=max(ans,root->val);\\n           return {root->val,root->val,root->val}; \\n        }\\n        vector<int>l=solve(root->left);\\n        vector<int>r=solve(root->right);\\n        if( root->val>l[1] && root->val<r[0]){\\n                ans=max(ans,root->val+l[2]+r[2]);\\n                return {min(root->val,l[0]),max(root->val,r[1]),root->val+l[2]+r[2]};\\n            }\\n        else return {INT_MIN,INT_MAX,0};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        solve(root);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint ans=0;\\n \\n    vector<int>solve(TreeNode *root)\\n    {\\n        if(!root) return {INT_MAX,INT_MIN,0};\\n        if(!root->left && !root->right)\\n        {\\n            ans=max(ans,root->val);\\n           return {root->val,root->val,root->val}; \\n        }\\n        vector<int>l=solve(root->left);\\n        vector<int>r=solve(root->right);\\n        if( root->val>l[1] && root->val<r[0]){\\n                ans=max(ans,root->val+l[2]+r[2]);\\n                return {min(root->val,l[0]),max(root->val,r[1]),root->val+l[2]+r[2]};\\n            }\\n        else return {INT_MIN,INT_MAX,0};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        solve(root);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592030,
                "title": "c-easy-solution-commented-easy-to-understand",
                "content": "```\\n\\n///\\nCreating a structure for each node :\\n1. Sum of subtree of this node\\n2. Maximum element in the subtree\\n3. Minimum element in the subtree\\n4. if the curr subtree is BST or not -> isBST\\n///\\n\\nstruct tree_node{\\n    int sum;\\n    int max_;\\n    int min_;\\n    bool isBST;\\n};\\n\\nclass Solution {\\npublic:\\n    \\n\\t// Final maximum result \\n    int res = INT_MIN;\\n    \\n    \\n    tree_node solve(TreeNode * root){\\n        \\n// If the root is null then we have to return the structured node with max value -> \\n// INT_MIN , min value -> INT_MAX, isBST -> true , and sum -> 0 \\n\\t\\t\\n        if(root == NULL)\\n            return {0 , INT_MIN , INT_MAX , true};\\n        \\n        tree_node left = solve(root -> left);\\n        tree_node right = solve(root -> right);\\n        \\n\\t\\t// sum of the subtree \\n        int curr_sum = left.sum + right.sum + root->val;\\n\\t\\t\\n\\t\\t// max element is max of left , right and curr node\\n\\t\\tint max_ele = max(root->val , max(left.max_ , right.max_));\\n\\t\\t\\n\\t\\t// min element is min of left , right ans curr node\\n        int min_ele = min(root -> val, min(right.min_ , left.min_));\\n\\t\\t\\n\\t\\t// updating the max res value if the curr subtree is bst \\n        bool flag = false;\\n        if(root->val > left.max_ && root->val < right.min_ && left.isBST && right.isBST){\\n            res = max(curr_sum , res);\\n            flag = true; // if curr subtree is bst \\n        }\\n        \\n        return {curr_sum , max_ele, min_ele, flag}; return the tree node with all details \\n        \\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        solve(root);   \\n\\t\\t// if res is less than 0 then return 0 else return the positive res value\\n        return res < 0?0 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\n///\\nCreating a structure for each node :\\n1. Sum of subtree of this node\\n2. Maximum element in the subtree\\n3. Minimum element in the subtree\\n4. if the curr subtree is BST or not -> isBST\\n///\\n\\nstruct tree_node{\\n    int sum;\\n    int max_;\\n    int min_;\\n    bool isBST;\\n};\\n\\nclass Solution {\\npublic:\\n    \\n\\t// Final maximum result \\n    int res = INT_MIN;\\n    \\n    \\n    tree_node solve(TreeNode * root){\\n        \\n// If the root is null then we have to return the structured node with max value -> \\n// INT_MIN , min value -> INT_MAX, isBST -> true , and sum -> 0 \\n\\t\\t\\n        if(root == NULL)\\n            return {0 , INT_MIN , INT_MAX , true};\\n        \\n        tree_node left = solve(root -> left);\\n        tree_node right = solve(root -> right);\\n        \\n\\t\\t// sum of the subtree \\n        int curr_sum = left.sum + right.sum + root->val;\\n\\t\\t\\n\\t\\t// max element is max of left , right and curr node\\n\\t\\tint max_ele = max(root->val , max(left.max_ , right.max_));\\n\\t\\t\\n\\t\\t// min element is min of left , right ans curr node\\n        int min_ele = min(root -> val, min(right.min_ , left.min_));\\n\\t\\t\\n\\t\\t// updating the max res value if the curr subtree is bst \\n        bool flag = false;\\n        if(root->val > left.max_ && root->val < right.min_ && left.isBST && right.isBST){\\n            res = max(curr_sum , res);\\n            flag = true; // if curr subtree is bst \\n        }\\n        \\n        return {curr_sum , max_ele, min_ele, flag}; return the tree node with all details \\n        \\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        solve(root);   \\n\\t\\t// if res is less than 0 then return 0 else return the positive res value\\n        return res < 0?0 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515965,
                "title": "80-tc-and-67-sc-easy-python-solution",
                "content": "```\\ndef maxSumBST(self, root: Optional[TreeNode]) -> int:\\n\\tans = [0]\\n\\tdp = dict()\\n\\tdef summ(node):\\n\\t\\tif(not node):\\n\\t\\t\\treturn 0\\n\\t\\tif(node in dp):\\n\\t\\t\\treturn dp[node]\\n\\t\\tdp[node] = node.val + summ(node.left) + summ(node.right)\\n\\t\\treturn dp[node]\\n\\t\\t\\n\\tdef dfs(node):\\n\\t\\tif(node.left):\\n\\t\\t\\tl_min, l_max, isB_l = dfs(node.left)\\n\\t\\t\\tl = isB_l and l_max < node.val\\n\\t\\telse:\\n\\t\\t\\tl_min = node.val\\n\\t\\t\\tl = 1\\n\\t\\tif(node.right):\\n\\t\\t\\tr_min, r_max, isB_r = dfs(node.right)\\n\\t\\t\\tr = isB_r and r_min > node.val\\n\\t\\telse:\\n\\t\\t\\tr_max = node.val\\n\\t\\t\\tr = 1\\n\\t\\tif(l and r):\\n\\t\\t\\tans[0] = max(ans[0], summ(node))\\n\\t\\t\\treturn l_min, r_max, 1\\n\\t\\treturn -1, -1, 0\\n\\n\\t_, _, f = dfs(root)\\n\\tif(f): ans[0] = max(ans[0], summ(root))\\n\\treturn ans[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\ndef maxSumBST(self, root: Optional[TreeNode]) -> int:\\n\\tans = [0]\\n\\tdp = dict()\\n\\tdef summ(node):\\n\\t\\tif(not node):\\n\\t\\t\\treturn 0\\n\\t\\tif(node in dp):\\n\\t\\t\\treturn dp[node]\\n\\t\\tdp[node] = node.val + summ(node.left) + summ(node.right)\\n\\t\\treturn dp[node]\\n\\t\\t\\n\\tdef dfs(node):\\n\\t\\tif(node.left):\\n\\t\\t\\tl_min, l_max, isB_l = dfs(node.left)\\n\\t\\t\\tl = isB_l and l_max < node.val\\n\\t\\telse:\\n\\t\\t\\tl_min = node.val\\n\\t\\t\\tl = 1\\n\\t\\tif(node.right):\\n\\t\\t\\tr_min, r_max, isB_r = dfs(node.right)\\n\\t\\t\\tr = isB_r and r_min > node.val\\n\\t\\telse:\\n\\t\\t\\tr_max = node.val\\n\\t\\t\\tr = 1\\n\\t\\tif(l and r):\\n\\t\\t\\tans[0] = max(ans[0], summ(node))\\n\\t\\t\\treturn l_min, r_max, 1\\n\\t\\treturn -1, -1, 0\\n\\n\\t_, _, f = dfs(root)\\n\\tif(f): ans[0] = max(ans[0], summ(root))\\n\\treturn ans[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2469084,
                "title": "c-defining-structures-and-recursion",
                "content": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n    struct prop{\\n        bool bst=true;\\n        int mini=INT_MAX;\\n        int maxi=INT_MIN;\\n        int sum=0;\\n    };\\n    int ans=0;\\n    prop solve(TreeNode* root)\\n    {\\n        prop p;\\n        if(root==NULL)\\n            return p;\\n        \\n        prop pl=solve(root->left);\\n        prop pr=solve(root->right);\\n        \\n        if(pl.bst && pr.bst && root->val>pl.maxi && root->val<pr.mini)\\n        {\\n            p.bst=true;\\n            p.sum=pl.sum+pr.sum+root->val;\\n            p.maxi=max(root->val,pr.maxi);\\n            p.mini=min(root->val,pl.mini);\\n        }\\n        else\\n        {\\n            p.bst=false;\\n            p.sum=max(pl.sum,pr.sum);\\n        }\\n        \\n        ans = max(ans,p.sum);\\n        return p;\\n    }\\n    int maxSumBST(TreeNode* root) \\n    {\\n        solve(root);\\n        \\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    struct prop{\\n        bool bst=true;\\n        int mini=INT_MAX;\\n        int maxi=INT_MIN;\\n        int sum=0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2425005,
                "title": "c-code-linear-time-complexity-o-n-easy-approach-with-comments",
                "content": "```\\nclass Solution {\\npublic:int max_s = 0; // initialise a variable outside for finding max_sum; \\n    \\n    struct info{\\n        \\n        bool isbst;\\n        int sum;\\n        int min_d;\\n        int max_d;\\n    };\\n    \\n    info find_max_sum_bst(TreeNode * root){\\n        \\n        if(root==NULL)\\n            return{1,0,INT_MAX,INT_MIN};\\n        \\n        info left = find_max_sum_bst(root->left);\\n        info right = find_max_sum_bst(root->right);\\n        \\n        bool isrootbst ;\\n        if(left.isbst && right.isbst && left.max_d < root->val && right.min_d > root->val) \\n            isrootbst = true;\\n        else\\n            isrootbst = false;\\n        \\n       \\n        int sumtillnow = root->val + left.sum + right.sum;//sum formed till this node;\\n        \\n        if(isrootbst)\\n            max_s = max(max_s,sumtillnow);//find max sum \\n        \\n         info bst;\\n        bst.isbst = isrootbst;\\n        bst.sum = sumtillnow;\\n        bst.min_d = min(root->val , min(left.min_d , right.min_d));// return min value down as it is going up;\\n        bst.max_d = max(root->val ,max(left.max_d, right.max_d));//return max value down as it is going up;\\n        \\n        return bst;\\n        \\n    }\\n    \\n    \\n    int maxSumBST(TreeNode* root) {\\n        \\n        find_max_sum_bst(root);\\n        \\n        return  max_s;\\n    }\\n};\\n\\n**UPVOTE IF YOU LIKE**\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:int max_s = 0; // initialise a variable outside for finding max_sum; \\n    \\n    struct info{\\n        \\n        bool isbst;\\n        int sum;\\n        int min_d;\\n        int max_d;\\n    };\\n    \\n    info find_max_sum_bst(TreeNode * root){\\n        \\n        if(root==NULL)\\n            return{1,0,INT_MAX,INT_MIN};\\n        \\n        info left = find_max_sum_bst(root->left);\\n        info right = find_max_sum_bst(root->right);\\n        \\n        bool isrootbst ;\\n        if(left.isbst && right.isbst && left.max_d < root->val && right.min_d > root->val) \\n            isrootbst = true;\\n        else\\n            isrootbst = false;\\n        \\n       \\n        int sumtillnow = root->val + left.sum + right.sum;//sum formed till this node;\\n        \\n        if(isrootbst)\\n            max_s = max(max_s,sumtillnow);//find max sum \\n        \\n         info bst;\\n        bst.isbst = isrootbst;\\n        bst.sum = sumtillnow;\\n        bst.min_d = min(root->val , min(left.min_d , right.min_d));// return min value down as it is going up;\\n        bst.max_d = max(root->val ,max(left.max_d, right.max_d));//return max value down as it is going up;\\n        \\n        return bst;\\n        \\n    }\\n    \\n    \\n    int maxSumBST(TreeNode* root) {\\n        \\n        find_max_sum_bst(root);\\n        \\n        return  max_s;\\n    }\\n};\\n\\n**UPVOTE IF YOU LIKE**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396036,
                "title": "c-solution-using-oops",
                "content": "```\\n\\nclass NodeValue {\\n    public:\\n        int maxSum, maxVal, minVal;\\n        NodeValue(int maxSum, int maxVal, int minVal){\\n            this->maxSum = maxSum;\\n            this->maxVal = maxVal;\\n            this->minVal = minVal;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    NodeValue solve(TreeNode *root, vector <int> &sums){\\n        if(!root) return {0, INT_MIN, INT_MAX};\\n        \\n        NodeValue valuesLeft = solve(root->left, sums);\\n        NodeValue valuesRight = solve(root->right, sums);\\n        \\n        if(root->val < valuesRight.minVal && root->val > valuesLeft.maxVal){\\n            sums.push_back(root->val + valuesRight.maxSum + valuesLeft.maxSum);\\n            return {root->val + valuesRight.maxSum + valuesLeft.maxSum, max(root->val, valuesRight.maxVal), min(root->val, valuesLeft.minVal)};\\n        }\\n        \\n        sums.push_back(max(valuesRight.maxSum, valuesLeft.maxSum));\\n        return {max(valuesRight.maxSum, valuesLeft.maxSum), INT_MAX, INT_MIN};\\n    }\\n        \\n    int maxSumBST(TreeNode* root) {\\n        vector <int> sums;\\n        sums.push_back(0);\\n\\t\\t\\n        int temp = max(0, solve(root, sums).maxSum);\\n        \\n        int ans = INT_MIN;\\n        for(int i = 0; i < sums.size(); i++){\\n            ans = max(ans, sums[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nReference: https://youtu.be/X0oXMdtUDwo",
                "solutionTags": [],
                "code": "```\\n\\nclass NodeValue {\\n    public:\\n        int maxSum, maxVal, minVal;\\n        NodeValue(int maxSum, int maxVal, int minVal){\\n            this->maxSum = maxSum;\\n            this->maxVal = maxVal;\\n            this->minVal = minVal;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    NodeValue solve(TreeNode *root, vector <int> &sums){\\n        if(!root) return {0, INT_MIN, INT_MAX};\\n        \\n        NodeValue valuesLeft = solve(root->left, sums);\\n        NodeValue valuesRight = solve(root->right, sums);\\n        \\n        if(root->val < valuesRight.minVal && root->val > valuesLeft.maxVal){\\n            sums.push_back(root->val + valuesRight.maxSum + valuesLeft.maxSum);\\n            return {root->val + valuesRight.maxSum + valuesLeft.maxSum, max(root->val, valuesRight.maxVal), min(root->val, valuesLeft.minVal)};\\n        }\\n        \\n        sums.push_back(max(valuesRight.maxSum, valuesLeft.maxSum));\\n        return {max(valuesRight.maxSum, valuesLeft.maxSum), INT_MAX, INT_MIN};\\n    }\\n        \\n    int maxSumBST(TreeNode* root) {\\n        vector <int> sums;\\n        sums.push_back(0);\\n\\t\\t\\n        int temp = max(0, solve(root, sums).maxSum);\\n        \\n        int ans = INT_MIN;\\n        for(int i = 0; i < sums.size(); i++){\\n            ans = max(ans, sums[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387558,
                "title": "c-solution-post-order-validate-bst-inspired-solution",
                "content": "**Upvote If it helped**\\n```\\nclass Solution {\\npublic:\\n    bool valid(TreeNode* root,  int &smax, int &smin, int &ans, int &sum){\\n        if(!root) return true;\\n        int lans = -40001, rans =-40001, lmax = INT_MIN, lmin = INT_MAX, rmin = INT_MAX, rmax = INT_MIN, lsum = 0, rsum = 0;\\n        bool l = valid(root->left, lmax, lmin, lans, lsum);\\n        bool r = valid(root->right, rmax, rmin, rans, rsum);\\n        smax = max(max(lmax,max(rmax,root->val)), smax);\\n        smin = min(min(lmin,min(rmin,root->val)), smin);\\n        sum += root->val +lsum + rsum;\\n\\t\\t\\n        ans = max(ans, max(lans, rans));\\n        if(l&&r){\\n            if(root->val > lmax && root->val < rmin){\\n                ans = max(ans, lsum + rsum + root->val);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        if(!root) return 0;\\n        int ans = 0;\\n        int sum  = 0;\\n        int mx = INT_MIN, mn = INT_MAX;\\n        valid(root, mx, mn, ans, sum);\\n        return ans;\\n    }\\n};\\n```\\nSimilar Problem : - https://bit.ly/3fn6h5V",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(TreeNode* root,  int &smax, int &smin, int &ans, int &sum){\\n        if(!root) return true;\\n        int lans = -40001, rans =-40001, lmax = INT_MIN, lmin = INT_MAX, rmin = INT_MAX, rmax = INT_MIN, lsum = 0, rsum = 0;\\n        bool l = valid(root->left, lmax, lmin, lans, lsum);\\n        bool r = valid(root->right, rmax, rmin, rans, rsum);\\n        smax = max(max(lmax,max(rmax,root->val)), smax);\\n        smin = min(min(lmin,min(rmin,root->val)), smin);\\n        sum += root->val +lsum + rsum;\\n\\t\\t\\n        ans = max(ans, max(lans, rans));\\n        if(l&&r){\\n            if(root->val > lmax && root->val < rmin){\\n                ans = max(ans, lsum + rsum + root->val);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        if(!root) return 0;\\n        int ans = 0;\\n        int sum  = 0;\\n        int mx = INT_MIN, mn = INT_MAX;\\n        valid(root, mx, mn, ans, sum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377908,
                "title": "c-simple-recursion-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    //returns {sumOfBST,minElementOfBST,maxElementOfBST,isBST}\\n    vector<int> dfs(TreeNode* root){\\n        if(!root) // if nullptr\\n            return {0,INT_MAX,INT_MIN,true}; \\n        vector<int>left=dfs(root->left); \\n        vector<int>right=dfs(root->right);\\n        \\n        // conditions for the current subtree to be BST\\n        // 1. if left and right are both BST\\n        // 2. the maximum value of left subtree is less than node value\\n        // 3. the minimum value of right subtree is greater than the node value\\n        if(left[3] && right[3] && left[2]<root->val && right[1]>root->val){\\n            int sum=left[0]+right[0]+root->val;\\n            ans=max(sum,ans);\\n            // if left or right subtree is nullptr, then use current node\\'s value\\n            return {sum,left[1]==INT_MAX?root->val:left[1],right[2]==INT_MIN?root->val:right[2],true};\\n        }\\n        return {0,INT_MIN,INT_MAX,false};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    //returns {sumOfBST,minElementOfBST,maxElementOfBST,isBST}\\n    vector<int> dfs(TreeNode* root){\\n        if(!root) // if nullptr\\n            return {0,INT_MAX,INT_MIN,true}; \\n        vector<int>left=dfs(root->left); \\n        vector<int>right=dfs(root->right);\\n        \\n        // conditions for the current subtree to be BST\\n        // 1. if left and right are both BST\\n        // 2. the maximum value of left subtree is less than node value\\n        // 3. the minimum value of right subtree is greater than the node value\\n        if(left[3] && right[3] && left[2]<root->val && right[1]>root->val){\\n            int sum=left[0]+right[0]+root->val;\\n            ans=max(sum,ans);\\n            // if left or right subtree is nullptr, then use current node\\'s value\\n            return {sum,left[1]==INT_MAX?root->val:left[1],right[2]==INT_MIN?root->val:right[2],true};\\n        }\\n        return {0,INT_MIN,INT_MAX,false};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337301,
                "title": "explained-with-comments-recursive-simple-time-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    class info{\\n      public:  //declare it public so won\\'t need constructor\\n      int maxi; //max element in that tree\\n      int mini; //min element in that tree\\n      bool isBST; // is it a BST\\n      int sum; //sum of that tree\\n    };\\n    \\n    info fun(TreeNode* root , int &ans)\\n    {\\n        if(root==NULL) return {INT_MIN,INT_MAX,true,0}; //if we reached null will return max=INT_MIN min =INT_MAX isBST =true and sum=0 so it wont cause problem with isBST condition in upper level nodes\\n        info left = fun(root->left,ans);\\n        info right = fun(root->right,ans);\\n        info cur;\\n        cur.maxi= max(left.maxi,max(right.maxi,root->val)); //max off node will be max of left,right and root\\n        cur.mini= min(left.mini,min(right.mini,root->val)); //min off node will be min of left,right and root\\n        cur.isBST=(left.isBST && right.isBST &&(root->val<right.mini && root->val>left.maxi)); // tree including root will be bst only when left,right is BST and root >left.max and  root<right.min\\n        if(cur.isBST) // if it is BST if can calculate sum of this bst\\n        {\\n            cur.sum = left.sum+right.sum+root->val; // sum of new bst\\n            if(cur.sum>ans) // if it is greater than previous ans will update answer \\n                ans=cur.sum;\\n            return {cur.maxi,cur.mini,true,cur.sum}; //return cur node \\n        }\\n        else\\n            return{cur.maxi,cur.mini,false,cur.sum}; // return cur node and false\\n            \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        fun(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class info{\\n      public:  //declare it public so won\\'t need constructor\\n      int maxi; //max element in that tree\\n      int mini; //min element in that tree\\n      bool isBST; // is it a BST\\n      int sum; //sum of that tree\\n    };\\n    \\n    info fun(TreeNode* root , int &ans)\\n    {\\n        if(root==NULL) return {INT_MIN,INT_MAX,true,0}; //if we reached null will return max=INT_MIN min =INT_MAX isBST =true and sum=0 so it wont cause problem with isBST condition in upper level nodes\\n        info left = fun(root->left,ans);\\n        info right = fun(root->right,ans);\\n        info cur;\\n        cur.maxi= max(left.maxi,max(right.maxi,root->val)); //max off node will be max of left,right and root\\n        cur.mini= min(left.mini,min(right.mini,root->val)); //min off node will be min of left,right and root\\n        cur.isBST=(left.isBST && right.isBST &&(root->val<right.mini && root->val>left.maxi)); // tree including root will be bst only when left,right is BST and root >left.max and  root<right.min\\n        if(cur.isBST) // if it is BST if can calculate sum of this bst\\n        {\\n            cur.sum = left.sum+right.sum+root->val; // sum of new bst\\n            if(cur.sum>ans) // if it is greater than previous ans will update answer \\n                ans=cur.sum;\\n            return {cur.maxi,cur.mini,true,cur.sum}; //return cur node \\n        }\\n        else\\n            return{cur.maxi,cur.mini,false,cur.sum}; // return cur node and false\\n            \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        fun(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328031,
                "title": "bruteforce-optimal-app",
                "content": "**BruteForce Approach**\\n\\nTraverse the tree using recursion. For each node first check if it is a BST, if it is a BST then calculate the sum of node values of the subtree rooted at the current node. Use variable max to store the maximum BST sum calculated till now, and finally return the value of max.\\n\\n ```\\n class Solution {\\n    int max = 0;\\n    public int maxSumBST(TreeNode root) {\\n        maxSumBstUtil(root);\\n        return max;\\n    }\\n    public void maxSumBstUtil(TreeNode root){\\n        if(isBst(root)){\\n            int sum = subtreeSum(root);\\n            max  = Math.max(sum , max);\\n        }\\n        \\n        if(root.left != null){\\n            maxSumBstUtil(root.left);\\n            \\n        }\\n        \\n        if(root.right != null){\\n            maxSumBstUtil(root.right);\\n        }\\n       \\n    }\\n    \\n    public int subtreeSum(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        int currSum = root.val;\\n        currSum += subtreeSum(root.left);\\n        currSum += subtreeSum(root.right);\\n        \\n        return currSum;\\n    }\\n    \\n    \\n    \\n    public boolean isBst(TreeNode root){\\n        return isBstUtil(root , Integer.MIN_VALUE , Integer.MAX_VALUE);\\n    }\\n    \\n    public boolean isBstUtil(TreeNode root , int min , int max){\\n        if(root == null){\\n            return true;\\n        }\\n        \\n        if(root.val < min || root.val  > max){\\n            return false;\\n        }\\n        \\n        return (isBstUtil(root.left , min , root.val-1)  && isBstUtil(root.right , root.val+1 , max));\\n    }\\n}\\n ```\\n \\n \\n Note :- **TLE**\\n \\n \\n **Optimal APproach**\\n \\n \\n ```\\n class Solution {\\n    int maxSum = 0;\\n    class Pair{\\n        int min;\\n        int max; \\n        int sum;\\n    }\\n    \\n    public int maxSumBST(TreeNode root) {\\n       Pair sol =  utilFunction(root);\\n        return maxSum;\\n    }\\n    \\n    public Pair utilFunction(TreeNode root){\\n        if(root == null){\\n           Pair bp = new Pair();\\n            bp.min = Integer.MAX_VALUE;\\n            bp.max = Integer.MIN_VALUE;\\n            bp.sum = 0;\\n            \\n           return bp;\\n            \\n        }\\n        \\n        Pair lp = utilFunction(root.left);\\n        Pair rp = utilFunction(root.right);\\n        Pair mp = new Pair();\\n        if(root.val > lp.max && root.val < rp.min){ //valid bst\\n            mp.min = Math.min(lp.min , root.val);\\n            mp.max = Math.max(rp.max , root.val);\\n            mp.sum = lp.sum + rp.sum + root.val;\\n            maxSum = Math.max(maxSum , mp.sum);\\n        }\\n        else{ //not a valid bst\\n            mp.min = Integer.MIN_VALUE;\\n            mp.max = Integer.MAX_VALUE;\\n            mp.sum = Math.max(lp.sum , rp.sum);\\n        }\\n        return mp;\\n    }\\n    \\n    \\n}\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n class Solution {\\n    int max = 0;\\n    public int maxSumBST(TreeNode root) {\\n        maxSumBstUtil(root);\\n        return max;\\n    }\\n    public void maxSumBstUtil(TreeNode root){\\n        if(isBst(root)){\\n            int sum = subtreeSum(root);\\n            max  = Math.max(sum , max);\\n        }\\n        \\n        if(root.left != null){\\n            maxSumBstUtil(root.left);\\n            \\n        }\\n        \\n        if(root.right != null){\\n            maxSumBstUtil(root.right);\\n        }\\n       \\n    }\\n    \\n    public int subtreeSum(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        int currSum = root.val;\\n        currSum += subtreeSum(root.left);\\n        currSum += subtreeSum(root.right);\\n        \\n        return currSum;\\n    }\\n    \\n    \\n    \\n    public boolean isBst(TreeNode root){\\n        return isBstUtil(root , Integer.MIN_VALUE , Integer.MAX_VALUE);\\n    }\\n    \\n    public boolean isBstUtil(TreeNode root , int min , int max){\\n        if(root == null){\\n            return true;\\n        }\\n        \\n        if(root.val < min || root.val  > max){\\n            return false;\\n        }\\n        \\n        return (isBstUtil(root.left , min , root.val-1)  && isBstUtil(root.right , root.val+1 , max));\\n    }\\n}\\n ```\n```\\n class Solution {\\n    int maxSum = 0;\\n    class Pair{\\n        int min;\\n        int max; \\n        int sum;\\n    }\\n    \\n    public int maxSumBST(TreeNode root) {\\n       Pair sol =  utilFunction(root);\\n        return maxSum;\\n    }\\n    \\n    public Pair utilFunction(TreeNode root){\\n        if(root == null){\\n           Pair bp = new Pair();\\n            bp.min = Integer.MAX_VALUE;\\n            bp.max = Integer.MIN_VALUE;\\n            bp.sum = 0;\\n            \\n           return bp;\\n            \\n        }\\n        \\n        Pair lp = utilFunction(root.left);\\n        Pair rp = utilFunction(root.right);\\n        Pair mp = new Pair();\\n        if(root.val > lp.max && root.val < rp.min){ //valid bst\\n            mp.min = Math.min(lp.min , root.val);\\n            mp.max = Math.max(rp.max , root.val);\\n            mp.sum = lp.sum + rp.sum + root.val;\\n            maxSum = Math.max(maxSum , mp.sum);\\n        }\\n        else{ //not a valid bst\\n            mp.min = Integer.MIN_VALUE;\\n            mp.max = Integer.MAX_VALUE;\\n            mp.sum = Math.max(lp.sum , rp.sum);\\n        }\\n        return mp;\\n    }\\n    \\n    \\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2311578,
                "title": "c-easy-solution-using-class-with-video-solution",
                "content": "```\\nclass info{\\npublic:\\n    int mini;\\n    int maxi;\\n    bool isBST;\\n    int sum;\\n};\\nclass Solution {\\npublic:\\n    info solve(TreeNode* root, int &ans){\\n        // base case\\n        if (root==NULL){\\n            return {INT_MAX,INT_MIN,true,0};\\n        }\\n        \\n        info left=solve(root->left,ans);\\n        info right = solve(root->right,ans);\\n        \\n        info curr;\\n        \\n        curr.sum = left.sum + right.sum + root->val;\\n        curr.mini = min(root->val,left.mini);\\n        curr.maxi = max(root->val,right.maxi);\\n        if(left.isBST and right.isBST and (left.maxi < root->val) and (right.mini > root->val)){\\n            curr.isBST = true;\\n        }\\n        else{\\n            curr.isBST = false;\\n        }\\n        \\n        if(curr.isBST){\\n            ans = max(ans,curr.sum);\\n        }\\n        return curr;\\n          \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int  maxSum=0;\\n        solve(root,maxSum);\\n        return maxSum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    info solve(TreeNode* root, int &ans){\\n        // base case\\n        if (root==NULL){\\n            return {INT_MAX,INT_MIN,true,0}",
                "codeTag": "Java"
            },
            {
                "id": 2308982,
                "title": "c-readable-class-of-required-params-dfs-recursion",
                "content": "```\\nclass info{\\n    public:\\n    int mn;\\n    int mx;\\n    bool isBST;\\n    int sum;\\n};\\nclass Solution {\\npublic:\\n    info Fn(TreeNode* root,int& ans){\\n        if(!root){\\n            return {INT_MAX,INT_MIN,true,0};\\n        }\\n        info left = Fn(root->left,ans);\\n        info right = Fn(root->right,ans);\\n        \\n        info curr;\\n        curr.mn = min(root->val,left.mn);\\n        curr.mx = max(root->val,right.mx);\\n        if(left.isBST and right.isBST and (left.mx < root->val) and (right.mn > root->val)){\\n            curr.isBST = true;\\n        }\\n        else{\\n            curr.isBST = false;\\n        }\\n        curr.sum = left.sum + right.sum + root->val;\\n        if(curr.isBST){\\n            ans = max(ans,curr.sum);\\n        }\\n        return curr;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        Fn(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass info{\\n    public:\\n    int mn;\\n    int mx;\\n    bool isBST;\\n    int sum;\\n};\\nclass Solution {\\npublic:\\n    info Fn(TreeNode* root,int& ans){\\n        if(!root){\\n            return {INT_MAX,INT_MIN,true,0};\\n        }\\n        info left = Fn(root->left,ans);\\n        info right = Fn(root->right,ans);\\n        \\n        info curr;\\n        curr.mn = min(root->val,left.mn);\\n        curr.mx = max(root->val,right.mx);\\n        if(left.isBST and right.isBST and (left.mx < root->val) and (right.mn > root->val)){\\n            curr.isBST = true;\\n        }\\n        else{\\n            curr.isBST = false;\\n        }\\n        curr.sum = left.sum + right.sum + root->val;\\n        if(curr.isBST){\\n            ans = max(ans,curr.sum);\\n        }\\n        return curr;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        Fn(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296293,
                "title": "c-solution-easy-explanation",
                "content": "```\\nclass BSTNode{      // new node class to store extra information with respect to BST\\npublic:\\n    int maxNode, minNode, maxSum;\\n    \\n    BSTNode(int maxNode, int minNode, int maxSum){      // parameterized constructor\\n        this->maxNode = maxNode;    // maximum value among nodes seen till BSTNode\\n        this->minNode = minNode;    // minimum value among nodes seen till BSTNode\\n        this->maxSum = maxSum;      // sum of all the nodes forming BST considering BSTNode as root\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    BSTNode helper(TreeNode* root){\\n        // an empty tree is a BST with maxSum 0\\n        if(!root){\\n            return BSTNode(INT_MIN, INT_MAX, 0);\\n        }\\n        \\n        // get values from the left and right subtree of current tree i.e. post-order traversal\\n        auto left = helper(root->left);\\n        auto right = helper(root->right);\\n        \\n        // if current node is greater than max in left and is smaller than min in right, then it is a BST\\n        if(left.maxNode < root->val && root->val < right.minNode){\\n            // it is a BST, so the parent\\'s maxNode, minNode, maxSum will get updated with max in right, min in left and currSum including root respectively\\n            int currSum = left.maxSum + right.maxSum + root->val;\\n            ans = max(ans, currSum);     // keeping track of the maximum currSum\\n            return BSTNode(max(root->val, right.maxNode), min(root->val, left.minNode), currSum);\\n        }\\n        \\n        // otherwise return [-INF, INF] so that parent can\\'t be a valid BST. Here we still keep maxSum = max(left.maxSum, right.maxSum) to keep track of previous valid BST that found before current invalid BST\\n        return BSTNode(INT_MAX, INT_MIN, max(left.maxSum, right.maxSum));\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        helper(root);  // The final maxSum value will be our answer\\n        \\n        return (ans>0) ? ans : 0;   // handling the case when all the nodes are negative, then we have to return empty BST\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass BSTNode{      // new node class to store extra information with respect to BST\\npublic:\\n    int maxNode, minNode, maxSum;\\n    \\n    BSTNode(int maxNode, int minNode, int maxSum){      // parameterized constructor\\n        this->maxNode = maxNode;    // maximum value among nodes seen till BSTNode\\n        this->minNode = minNode;    // minimum value among nodes seen till BSTNode\\n        this->maxSum = maxSum;      // sum of all the nodes forming BST considering BSTNode as root\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    BSTNode helper(TreeNode* root){\\n        // an empty tree is a BST with maxSum 0\\n        if(!root){\\n            return BSTNode(INT_MIN, INT_MAX, 0);\\n        }\\n        \\n        // get values from the left and right subtree of current tree i.e. post-order traversal\\n        auto left = helper(root->left);\\n        auto right = helper(root->right);\\n        \\n        // if current node is greater than max in left and is smaller than min in right, then it is a BST\\n        if(left.maxNode < root->val && root->val < right.minNode){\\n            // it is a BST, so the parent\\'s maxNode, minNode, maxSum will get updated with max in right, min in left and currSum including root respectively\\n            int currSum = left.maxSum + right.maxSum + root->val;\\n            ans = max(ans, currSum);     // keeping track of the maximum currSum\\n            return BSTNode(max(root->val, right.maxNode), min(root->val, left.minNode), currSum);\\n        }\\n        \\n        // otherwise return [-INF, INF] so that parent can\\'t be a valid BST. Here we still keep maxSum = max(left.maxSum, right.maxSum) to keep track of previous valid BST that found before current invalid BST\\n        return BSTNode(INT_MAX, INT_MIN, max(left.maxSum, right.maxSum));\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        helper(root);  // The final maxSum value will be our answer\\n        \\n        return (ans>0) ? ans : 0;   // handling the case when all the nodes are negative, then we have to return empty BST\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285453,
                "title": "c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Info {\\npublic:\\n    int minimum;\\n    int maximum;\\n    bool isBST;\\n    int runningSum;\\n    int maxSum;\\n};\\n\\nclass Solution {\\npublic:\\n    Info helper(TreeNode* root) {\\n        Info inf;\\n        if (!root) {\\n            inf.minimum = INT_MAX;\\n            inf.maximum = INT_MIN;\\n            inf.isBST = true;\\n            inf.runningSum = 0;\\n            inf.maxSum = 0;\\n            return inf;\\n        }\\n        \\n        Info left = helper(root->left);\\n        Info right = helper(root->right);\\n        \\n        inf.minimum = min(root->val, min(left.minimum, right.minimum));\\n        inf.maximum = max(root->val, max(left.maximum, right.maximum));\\n        inf.isBST = left.isBST && right.isBST && (root->val > left.maximum) && (root->val < right.minimum);\\n        inf.runningSum = left.runningSum + right.runningSum + root->val;\\n        \\n        if (inf.isBST) {\\n            inf.maxSum = max(inf.runningSum, max(left.maxSum, right.maxSum));\\n        }\\n        else\\n            inf.maxSum = max(left.maxSum, right.maxSum);\\n        \\n        return inf;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        return helper(root).maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Info {\\npublic:\\n    int minimum;\\n    int maximum;\\n    bool isBST;\\n    int runningSum;\\n    int maxSum;\\n};\\n\\nclass Solution {\\npublic:\\n    Info helper(TreeNode* root) {\\n        Info inf;\\n        if (!root) {\\n            inf.minimum = INT_MAX;\\n            inf.maximum = INT_MIN;\\n            inf.isBST = true;\\n            inf.runningSum = 0;\\n            inf.maxSum = 0;\\n            return inf;\\n        }\\n        \\n        Info left = helper(root->left);\\n        Info right = helper(root->right);\\n        \\n        inf.minimum = min(root->val, min(left.minimum, right.minimum));\\n        inf.maximum = max(root->val, max(left.maximum, right.maximum));\\n        inf.isBST = left.isBST && right.isBST && (root->val > left.maximum) && (root->val < right.minimum);\\n        inf.runningSum = left.runningSum + right.runningSum + root->val;\\n        \\n        if (inf.isBST) {\\n            inf.maxSum = max(inf.runningSum, max(left.maxSum, right.maxSum));\\n        }\\n        else\\n            inf.maxSum = max(left.maxSum, right.maxSum);\\n        \\n        return inf;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        return helper(root).maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269544,
                "title": "java-easy-to-understand-code",
                "content": "```\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        int ans = helper(root).currmax;\\n        return ans > 0 ? ans : 0;\\n    }\\n    public Val helper(TreeNode root)\\n    {\\n        if(root==null)\\n            return new Val(Integer.MAX_VALUE,Integer.MIN_VALUE,0,true,0);\\n        \\n        if(root.left==null && root.right==null)\\n            return new Val(root.val,root.val,root.val,true,root.val);\\n        \\n        Val l = helper(root.left);\\n        Val r = helper(root.right);\\n        \\n        Val curr = new Val();\\n        \\n        if(l.isBST && r.isBST && l.max < root.val && r.min > root.val)\\n        {\\n            curr.min = Math.min(l.min,root.val);\\n            curr.max = Math.max(r.max,root.val);\\n            curr.sum = root.val + l.sum + r.sum;\\n            curr.isBST = true;\\n            curr.currmax = Math.max(Math.max(l.currmax,r.currmax),curr.sum);\\n            return curr;\\n        }\\n        \\n        curr.min = Math.min(root.val,Math.min(l.min,r.min));\\n        curr.max = Math.max(root.val,Math.max(l.max,r.max));\\n        curr.sum = Integer.MIN_VALUE;\\n        curr.isBST = false;\\n        curr.currmax = Math.max(l.currmax,r.currmax);\\n        \\n        return curr;\\n    }\\n}\\nclass Val{\\n    int min;\\n    int max;\\n    int sum;\\n    boolean isBST;\\n    int currmax;\\n    public Val(int mi,int ma,int s,boolean ibt,int curr)\\n    {\\n        min = mi;\\n        max = ma;\\n        sum = s;\\n        isBST = ibt;\\n        currmax = curr;\\n    }\\n    public Val()\\n    {\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        int ans = helper(root).currmax;\\n        return ans > 0 ? ans : 0;\\n    }\\n    public Val helper(TreeNode root)\\n    {\\n        if(root==null)\\n            return new Val(Integer.MAX_VALUE,Integer.MIN_VALUE,0,true,0);\\n        \\n        if(root.left==null && root.right==null)\\n            return new Val(root.val,root.val,root.val,true,root.val);\\n        \\n        Val l = helper(root.left);\\n        Val r = helper(root.right);\\n        \\n        Val curr = new Val();\\n        \\n        if(l.isBST && r.isBST && l.max < root.val && r.min > root.val)\\n        {\\n            curr.min = Math.min(l.min,root.val);\\n            curr.max = Math.max(r.max,root.val);\\n            curr.sum = root.val + l.sum + r.sum;\\n            curr.isBST = true;\\n            curr.currmax = Math.max(Math.max(l.currmax,r.currmax),curr.sum);\\n            return curr;\\n        }\\n        \\n        curr.min = Math.min(root.val,Math.min(l.min,r.min));\\n        curr.max = Math.max(root.val,Math.max(l.max,r.max));\\n        curr.sum = Integer.MIN_VALUE;\\n        curr.isBST = false;\\n        curr.currmax = Math.max(l.currmax,r.currmax);\\n        \\n        return curr;\\n    }\\n}\\nclass Val{\\n    int min;\\n    int max;\\n    int sum;\\n    boolean isBST;\\n    int currmax;\\n    public Val(int mi,int ma,int s,boolean ibt,int curr)\\n    {\\n        min = mi;\\n        max = ma;\\n        sum = s;\\n        isBST = ibt;\\n        currmax = curr;\\n    }\\n    public Val()\\n    {\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250264,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nstruct Info{\\n    int maxSum;\\n    int totSum;\\n    bool isBst;\\n    int minVal;\\n    int maxVal;\\n};\\n\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        \\n        int ans=helper(root).maxSum;\\n        return ans<0?0:ans;\\n    }\\n    \\n    Info helper(TreeNode* root){\\n        \\n        if(root==NULL){\\n            return {0,0,true,INT_MAX,INT_MIN};\\n        }\\n        if(root->right==NULL && root->left==NULL){\\n            return {root->val,root->val,true,root->val,root->val};\\n        }\\n        \\n        Info left=helper(root->left);\\n        Info right=helper(root->right);\\n        Info curr;\\n        if(left.isBst && right.isBst && root->val>left.maxVal && root->val<right.minVal){\\n            curr.totSum=left.totSum+right.totSum+root->val;\\n            curr.maxSum=max({curr.totSum,left.maxSum,right.maxSum});\\n            curr.isBst=true;\\n            curr.minVal=min({root->val,left.minVal,right.minVal});\\n            curr.maxVal=max({root->val,left.maxVal,right.maxVal});\\n            return curr;\\n        }else{\\n            curr.isBst=false;\\n            curr.maxSum=max(left.maxSum,right.maxSum);\\n            curr.totSum=root->val+left.totSum+right.totSum;\\n            curr.minVal=min({root->val,left.minVal,right.minVal});\\n            curr.maxVal=max({root->val,left.maxVal,right.maxVal});\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Info{\\n    int maxSum;\\n    int totSum;\\n    bool isBst;\\n    int minVal;\\n    int maxVal;\\n};\\n\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        \\n        int ans=helper(root).maxSum;\\n        return ans<0?0:ans;\\n    }\\n    \\n    Info helper(TreeNode* root){\\n        \\n        if(root==NULL){\\n            return {0,0,true,INT_MAX,INT_MIN};\\n        }\\n        if(root->right==NULL && root->left==NULL){\\n            return {root->val,root->val,true,root->val,root->val};\\n        }\\n        \\n        Info left=helper(root->left);\\n        Info right=helper(root->right);\\n        Info curr;\\n        if(left.isBst && right.isBst && root->val>left.maxVal && root->val<right.minVal){\\n            curr.totSum=left.totSum+right.totSum+root->val;\\n            curr.maxSum=max({curr.totSum,left.maxSum,right.maxSum});\\n            curr.isBst=true;\\n            curr.minVal=min({root->val,left.minVal,right.minVal});\\n            curr.maxVal=max({root->val,left.maxVal,right.maxVal});\\n            return curr;\\n        }else{\\n            curr.isBst=false;\\n            curr.maxSum=max(left.maxSum,right.maxSum);\\n            curr.totSum=root->val+left.totSum+right.totSum;\\n            curr.minVal=min({root->val,left.minVal,right.minVal});\\n            curr.maxVal=max({root->val,left.maxVal,right.maxVal});\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239264,
                "title": "java-easy-solution-time-complexity-o-n-and-space-o-1",
                "content": "```\\nclass Solution {\\n    static class Pair{\\n        int max;\\n        int min;\\n        int sum;\\n        boolean isBst;\\n        Pair(int l,int r,int m,boolean b){\\n            this.max=l;\\n            this.min=r;\\n            this.sum=m;\\n            this.isBst=b;\\n           \\n        }\\n\\t\\t//1 Every Node will return the above parameters above .\\n\\t\\t//2 If the root value is  larger than max left value the it will be larger than all left values .\\n\\t//\\t3 If the root value is less than min value of right that it will be less than all other values hence will form a bst and we are also tracking sum.\\n    }\\n   \\n    static Pair recur(TreeNode r,int a[]){\\n        if(r==null){\\n            return new Pair(Integer.MIN_VALUE,Integer.MAX_VALUE,0,true);\\n        }\\n        Pair lobj=recur(r.left,a);\\n        Pair robj=recur(r.right,a);\\n        if(r.val<=lobj.max||r.val>=robj.min)\\n        return new Pair(Integer.MIN_VALUE,Integer.MAX_VALUE,0,false);\\n         int maxLeft=Math.max(r.val,Math.max(lobj.max,robj.max));\\n         int minRight=Math.min(r.val,Math.min(lobj.min,robj.min));\\n        boolean chk=false;\\n         if(lobj.isBst&&robj.isBst){\\n             a[0]=Math.max(a[0],lobj.sum+robj.sum+r.val);\\n             chk=true;   \\n         }\\n        else if(lobj.isBst){\\n            a[0]=Math.max(a[0],lobj.sum);\\n            chk=false;\\n        }\\n        else if(robj.isBst){\\n            a[0]=Math.max(a[0],robj.sum);\\n            chk=false;\\n        }\\n        return new Pair(maxLeft,minRight,lobj.sum+robj.sum+r.val,chk);\\n        \\n    }\\n     public int maxSumBST(TreeNode root) {\\n         int a[]=new int[1];\\n          recur(root,a);\\n        return a[0];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    static class Pair{\\n        int max;\\n        int min;\\n        int sum;\\n        boolean isBst;\\n        Pair(int l,int r,int m,boolean b){\\n            this.max=l;\\n            this.min=r;\\n            this.sum=m;\\n            this.isBst=b;\\n           \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2217830,
                "title": "c-solution-o-n-bst-100-faster-easy-to-understand",
                "content": "\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    ll sum=0;\\n    //ll currsum=0;\\n   vector<pair<ll,TreeNode*>> v;\\n    int tsum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int l=tsum(root->left);\\n        int r=tsum(root->right);\\n       v.push_back({root->val+l+r,root});\\n        return root->val+l+r;\\n    }\\n    bool check(TreeNode* root,int high,int low)\\n    {\\n        if(root==NULL)\\n            return true;\\n        if(root->val>low && root->val<high)\\n            return check(root->left,root->val,low) && check(root->right,high,root->val);\\n        return false;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        tsum(root);\\n        sort(v.begin(),v.end(),greater<pair<ll,TreeNode*>>());\\n        for(int i=0;i<v.size();i++)\\n        {\\n           int high=INT_MAX;\\n           int low=INT_MIN;\\n            if(v[i].first<0)\\n                break;\\n           if(check(v[i].second,high,low))\\n               return v[i].first;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    ll sum=0;\\n    //ll currsum=0;\\n   vector<pair<ll,TreeNode*>> v;\\n    int tsum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int l=tsum(root->left);\\n        int r=tsum(root->right);\\n       v.push_back({root->val+l+r,root});\\n        return root->val+l+r;\\n    }\\n    bool check(TreeNode* root,int high,int low)\\n    {\\n        if(root==NULL)\\n            return true;\\n        if(root->val>low && root->val<high)\\n            return check(root->left,root->val,low) && check(root->right,high,root->val);\\n        return false;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        tsum(root);\\n        sort(v.begin(),v.end(),greater<pair<ll,TreeNode*>>());\\n        for(int i=0;i<v.size();i++)\\n        {\\n           int high=INT_MAX;\\n           int low=INT_MIN;\\n            if(v[i].first<0)\\n                break;\\n           if(check(v[i].second,high,low))\\n               return v[i].first;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217829,
                "title": "c-100-faster-easy-and-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    map<TreeNode * ,int> mp;\\n    vector<pair<int ,TreeNode *>> v;\\n    int maxSumBST(TreeNode* root) {\\n        cal(root);\\n        int max=0;\\n        sort(v.rbegin(),v.rend());\\n         for(int i=0;i<v.size();i++){\\n             if(v[i].first<0)\\n                 break;\\n             if(isBST(v[i].second))\\n                 return v[i].first;\\n         }\\n        return 0;\\n    }\\n    \\n    int cal(TreeNode * root){\\n        if(root==NULL)\\n            return 0;\\n        int l=cal(root->left); \\n        int r=cal(root->right);\\n        mp[root]=l+r+root->val;\\n        v.push_back({mp[root],root});\\n        return mp[root];\\n        \\n    }\\nint isBST(TreeNode* node)\\n{\\n    return(isBSTUtil(node, INT_MIN, INT_MAX));\\n}\\nint isBSTUtil(TreeNode* node, int min, int max){\\n\\n    if (node==NULL)\\n        return 1;\\n             \\n    if (node->val < min || node->val > max)\\n        return 0;\\n     return\\n        isBSTUtil(node->left, min, node->val-1) &&\\n        isBSTUtil(node->right, node->val+1, max); \\n}\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<TreeNode * ,int> mp;\\n    vector<pair<int ,TreeNode *>> v;\\n    int maxSumBST(TreeNode* root) {\\n        cal(root);\\n        int max=0;\\n        sort(v.rbegin(),v.rend());\\n         for(int i=0;i<v.size();i++){\\n             if(v[i].first<0)\\n                 break;\\n             if(isBST(v[i].second))\\n                 return v[i].first;\\n         }\\n        return 0;\\n    }\\n    \\n    int cal(TreeNode * root){\\n        if(root==NULL)\\n            return 0;\\n        int l=cal(root->left); \\n        int r=cal(root->right);\\n        mp[root]=l+r+root->val;\\n        v.push_back({mp[root],root});\\n        return mp[root];\\n        \\n    }\\nint isBST(TreeNode* node)\\n{\\n    return(isBSTUtil(node, INT_MIN, INT_MAX));\\n}\\nint isBSTUtil(TreeNode* node, int min, int max){\\n\\n    if (node==NULL)\\n        return 1;\\n             \\n    if (node->val < min || node->val > max)\\n        return 0;\\n     return\\n        isBSTUtil(node->left, min, node->val-1) &&\\n        isBSTUtil(node->right, node->val+1, max); \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212754,
                "title": "java-post-order-dfs-save-4-states-bst-sum-max-min",
                "content": "If we can verify \\n1. The left subtree and right subtree are both BSTs\\n2. The smallest value in the right subtree is > the current root value.\\n3. The largest value in the left subtree is < the current root value.\\n\\nThen, we are able to conclude the current subtree rooted at the current node is a BST.\\n```Java\\nclass Solution {\\n    int res;\\n    int VALID = 0;\\n    public int maxSumBST(TreeNode root) {\\n        dfs(root);\\n        return res;\\n    }\\n\\n    // valid, sum, min, max;\\n    private int[] dfs(TreeNode root){\\n        if (root == null){\\n            return new int[]{VALID, 0, Integer.MAX_VALUE, Integer.MIN_VALUE};\\n        }\\n        int[] r = dfs(root.right);\\n        int[] l = dfs(root.left);\\n        int[] ans = new int[4];\\n        ans[0] = r[0]==VALID&&l[0]==VALID&&root.val < r[2] && root.val > l[3]? VALID : 1;\\n        ans[1] = r[1]+l[1]+root.val;\\n        ans[2] = Math.min(root.val, l[2]);\\n        ans[3] = Math.max(root.val, r[3]);\\n        if (ans[0]==VALID){\\n            res = Math.max(ans[1], res);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```Java\\nclass Solution {\\n    int res;\\n    int VALID = 0;\\n    public int maxSumBST(TreeNode root) {\\n        dfs(root);\\n        return res;\\n    }\\n\\n    // valid, sum, min, max;\\n    private int[] dfs(TreeNode root){\\n        if (root == null){\\n            return new int[]{VALID, 0, Integer.MAX_VALUE, Integer.MIN_VALUE};\\n        }\\n        int[] r = dfs(root.right);\\n        int[] l = dfs(root.left);\\n        int[] ans = new int[4];\\n        ans[0] = r[0]==VALID&&l[0]==VALID&&root.val < r[2] && root.val > l[3]? VALID : 1;\\n        ans[1] = r[1]+l[1]+root.val;\\n        ans[2] = Math.min(root.val, l[2]);\\n        ans[3] = Math.max(root.val, r[3]);\\n        if (ans[0]==VALID){\\n            res = Math.max(ans[1], res);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208521,
                "title": "shortest-and-easy-code-c",
                "content": "```\\n\\nstruct dat{\\n    int sum = 0;\\n    int check = true;\\n    int mi = INT_MAX;\\n    int ma = INT_MIN;\\n};\\n\\nint value = INT_MIN;\\ndat func(TreeNode *root)\\n{\\n    dat ans,ll,rr;\\n    \\n    if (root == nullptr)\\n        return ans;\\n\\n    ll = func(root->left);\\n    rr = func(root->right);\\n    \\n    ans.sum = ll.sum + rr.sum + root->val;\\n    ans.check = ((root->val) > ll.ma ) && ((root->val) < rr.mi) && ll.check && rr.check;\\n    ans.mi = min(root->val,ll.mi);\\n    ans.ma = max(root->val,rr.ma);\\n    \\n    if (ans.check)\\n        value = max(value, ans.sum);\\n\\n    return ans;\\n\\n}\\nclass Solution\\n{\\n    public:\\n        int maxSumBST(TreeNode *root)\\n        {\\n            value = INT_MIN;\\n            func(root);\\n            return ((value<0)?0:value);\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nstruct dat{\\n    int sum = 0;\\n    int check = true;\\n    int mi = INT_MAX;\\n    int ma = INT_MIN;\\n};\\n\\nint value = INT_MIN;\\ndat func(TreeNode *root)\\n{\\n    dat ans,ll,rr;\\n    \\n    if (root == nullptr)\\n        return ans;\\n\\n    ll = func(root->left);\\n    rr = func(root->right);\\n    \\n    ans.sum = ll.sum + rr.sum + root->val;\\n    ans.check = ((root->val) > ll.ma ) && ((root->val) < rr.mi) && ll.check && rr.check;\\n    ans.mi = min(root->val,ll.mi);\\n    ans.ma = max(root->val,rr.ma);\\n    \\n    if (ans.check)\\n        value = max(value, ans.sum);\\n\\n    return ans;\\n\\n}\\nclass Solution\\n{\\n    public:\\n        int maxSumBST(TreeNode *root)\\n        {\\n            value = INT_MIN;\\n            func(root);\\n            return ((value<0)?0:value);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206751,
                "title": "post-order-dfs-recursion-hindi-explanation",
                "content": "Given,\\nHume ek binary tree ka root node diya hua hai\\nTask,\\nEk aise subtree ko find krna jo ek binary search tree hai aur jiske nodes ka sum maximum hai\\n\\n**Task ko ache se samajhne ke liye aap example test cases ko refer kr sakte hai**\\n\\n\\n**Solution,**\\nHum pure tree ko traverse karenge using post order traversal kyu ki agar humare pass left aur right ka information nahi aayega tab tk hum apne current node ke value ko undono se compare nahi kr payenge\\nMaan lo ki humara current node apne subtree ka root node hai\\nHum is node ke liye kuch chize pata krni hogi\\n\\n**1. Iss subtree Ka Sum \\n2. Kya humara current node BST ka part hai (0 mean NO , 1 mean Yes)\\n3. Iss subtree ka maximum value\\n4. Iss subtree ka minimum value**\\n\\nye sari information ko hum ek vector ke through return karenge harr ek node ke liye.\\n\\nHum recursion ke through hrr ek node ke left subtree aur right subtree ke liye ye sari 4 information nikalnege\\n\\n1. Aur uske baad hum ye check karenge ki kya iska left subtree ya right subtree BST hai ya nahi.\\n2. Agar dono subtree bst hue tab hi humare current node ke bst mai add hone ke chances hai agar koi ek subtree bhi BST nahi hua then ye confirm hai ki humare current node ke liye BST ke conditions true nahi honge (I hope you know the conditions for BST).\\n3. Agar Dono BST hue then hum ye check karenge ki \\n\\t\\t\\t\\t\\t* humara current node ka value, left subtree ke maximum value se jyada hai ki nahi and \\n\\t\\t\\t\\t\\t* humara current node ka value, right subtree ke minimum value se kam hai ki nahi \\n**Agar ye dono cases true hote hai then hum ye kah sakte hai humara current BST ka part hai aur hum iss subtree ke sum ko apne ans variable se compare krke answer store kr lenge aur agar BST ka part nahi hua to hum iss case mai answer ko compare nahi karenge .** \\n\\n\\n**Aur iss subtree ke liye return karenge,**\\n**1. Subtree sum**\\n**2. Current node BST ka part hai ya nahi**\\n**3. subtree ka maximum value\\n4. subtree ka minimum value**\\n\\nOtherwise\\nHumara current node BST ka part nahi \\n\\n\\n\\n```\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    vector<int> solve(TreeNode *root,int &ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return {0,1,INT_MIN,INT_MAX};\\n        }\\n        \\n        \\n        vector<int> left=solve(root->left,ans);\\n        vector<int> right=solve(root->right,ans);\\n        \\n        \\n        if(left[1]==1 && right[1]==1 && root->val>left[2] && root->val<right[3])\\n        {\\n            ans=max(ans,left[0]+right[0]+root->val);\\n             return {left[0]+right[0]+root->val,1,max(root->val,right[2]),min(left[3],root->val)};\\n        }\\n        else\\n        {\\n            return {left[0]+right[0]+root->val,0,max(root->val,right[2]),min(left[3],root->val)};\\n        }\\n            \\n        \\n    }\\n    int maxSumBST(TreeNode* root) \\n    {\\n        int ans=0;\\n        solve(root,ans);\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    vector<int> solve(TreeNode *root,int &ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return {0,1,INT_MIN,INT_MAX};\\n        }\\n        \\n        \\n        vector<int> left=solve(root->left,ans);\\n        vector<int> right=solve(root->right,ans);\\n        \\n        \\n        if(left[1]==1 && right[1]==1 && root->val>left[2] && root->val<right[3])\\n        {\\n            ans=max(ans,left[0]+right[0]+root->val);\\n             return {left[0]+right[0]+root->val,1,max(root->val,right[2]),min(left[3],root->val)};\\n        }\\n        else\\n        {\\n            return {left[0]+right[0]+root->val,0,max(root->val,right[2]),min(left[3],root->val)};\\n        }\\n            \\n        \\n    }\\n    int maxSumBST(TreeNode* root) \\n    {\\n        int ans=0;\\n        solve(root,ans);\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177322,
                "title": "post-order-traverse-basic-bst-property-is-used-cpp",
                "content": "**Hello Guys,**\\n\\nthis is a very simple solution for `Maximum Sum BST in Binary Tree` problem.\\n\\nwe are using a tuple of `<mn, mx, sum>`\\n**Let** currently we are on a `node`\\n`mn`=minimum value of a node in this subtree\\n`mx`=maximum value of a node in this subtree\\n`sum`=sum of all the nodes of this subtree\\n\\n* `if` current node\\'s value is between max node from left to min node from right, then it is a valid BST \\n\\t* then we add this current node\\'s value in `left_sum+right_sum` and return tuple for current node, which have min node till this tree, max node till this tree and sum of this tree\\n* `else` it is not a valid BST\\n\\t* then return min node as INT_MIN, max node as INT_MAX and sum as 0\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    \\n    // tuple <min, max, sum>\\n    int ans=0;\\n    tuple<int,int,int> fun(TreeNode* cr)\\n    {\\n        tuple<int,int,int>t;\\n        \\n        if(!cr)\\n        {\\n            t=make_tuple(1e7,-1e7,0);\\n            return t;\\n        }\\n        \\n        if(!cr->left && !cr->right) ans=max(ans, cr->val);\\n        tuple<int,int,int>l_tp,r_tp;\\n        \\n        // max from left\\n        l_tp=fun(cr->left);\\n        int mx=get<1>(l_tp);\\n        \\n        // min from right\\n        r_tp=fun(cr->right);\\n        int mn=get<0>(r_tp);\\n        \\n        int mid=cr->val;\\n        int sum=get<2>(l_tp)+get<2>(r_tp);\\n        \\n        // check if this is valid bst and will return valid min, max and sum of nodes\\n        if(mx<mid && mid<mn)\\n        {\\n            ans=max(ans, sum+mid);\\n            mn=get<0>(l_tp), mx=get<1>(r_tp);\\n            t=make_tuple(min(mn,mid), max(mx, mid), sum+mid);\\n            return t;\\n        }\\n        \\n\\t\\t// BST is not valid so return corner value so it will not be included as a valid BST in above nodes\\n        t=make_tuple(-1e7, 1e7, 0);\\n        return t;\\n        \\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        \\n        ans=0;\\n        tuple<int,int,int>tt=fun(root);\\n        return ans;\\n    }\\n};\\n```\\nThanks...",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // tuple <min, max, sum>\\n    int ans=0;\\n    tuple<int,int,int> fun(TreeNode* cr)\\n    {\\n        tuple<int,int,int>t;\\n        \\n        if(!cr)\\n        {\\n            t=make_tuple(1e7,-1e7,0);\\n            return t;\\n        }\\n        \\n        if(!cr->left && !cr->right) ans=max(ans, cr->val);\\n        tuple<int,int,int>l_tp,r_tp;\\n        \\n        // max from left\\n        l_tp=fun(cr->left);\\n        int mx=get<1>(l_tp);\\n        \\n        // min from right\\n        r_tp=fun(cr->right);\\n        int mn=get<0>(r_tp);\\n        \\n        int mid=cr->val;\\n        int sum=get<2>(l_tp)+get<2>(r_tp);\\n        \\n        // check if this is valid bst and will return valid min, max and sum of nodes\\n        if(mx<mid && mid<mn)\\n        {\\n            ans=max(ans, sum+mid);\\n            mn=get<0>(l_tp), mx=get<1>(r_tp);\\n            t=make_tuple(min(mn,mid), max(mx, mid), sum+mid);\\n            return t;\\n        }\\n        \\n\\t\\t// BST is not valid so return corner value so it will not be included as a valid BST in above nodes\\n        t=make_tuple(-1e7, 1e7, 0);\\n        return t;\\n        \\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        \\n        ans=0;\\n        tuple<int,int,int>tt=fun(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177295,
                "title": "faster-than-93-66-easy-c-recursive-explained-solution",
                "content": "```\\nint helper(TreeNode* root,int &min,int &max,bool &is_bst,int &max_sum)\\n    {\\n        if(!root){  // for empty Binary Tree\\n            is_bst=1;\\n            return 0;\\n        }\\n        int tmp=INT_MAX; \\n        bool left_bst=false,right_bst=false; //initialize for left and right subtree bst check \\n         max=INT_MIN; // for maximum element in left subtree\\n        int left_sum=0;\\n            left_sum+=helper(root->left,min,max,is_bst,max_sum);\\n     \\n     if(is_bst && root->val > max)  //condition for left subtree as bst or not\\n      left_bst=true;\\n      // update the min for right subtree\\n      tmp=min;\\n\\t  // same intution for right subtree\\n      min=INT_MAX;\\n      int right_sum=0;\\n        right_sum+=helper(root->right,min,max,is_bst,max_sum);\\n      \\n      if(is_bst && root->val < min)\\n       right_bst=true;\\n           \\n        if(tmp<min)\\n          min=tmp;\\n    //   for leaf nodes\\n        if(root->val <min)\\n         min=root->val;\\n        if(root->val > max)\\n        max = root->val;\\n    \\n\\t// return max_sum \\n    if(left_bst && right_bst)\\n        {\\n            if(left_sum + right_sum + root->val > max_sum)\\n             max_sum=left_sum + right_sum + root->val ;\\n           return left_sum + right_sum + root->val ; \\n        }\\n        else{\\n            is_bst=0;\\n            return 0;\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int min=INT_MAX;\\n        int max=INT_MIN;\\n        bool is_bst=0;\\n        int max_sum=0;\\n        helper(root,min,max,is_bst,max_sum);\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nint helper(TreeNode* root,int &min,int &max,bool &is_bst,int &max_sum)\\n    {\\n        if(!root){  // for empty Binary Tree\\n            is_bst=1;\\n            return 0;\\n        }\\n        int tmp=INT_MAX; \\n        bool left_bst=false,right_bst=false; //initialize for left and right subtree bst check \\n         max=INT_MIN; // for maximum element in left subtree\\n        int left_sum=0;\\n            left_sum+=helper(root->left,min,max,is_bst,max_sum);\\n     \\n     if(is_bst && root->val > max)  //condition for left subtree as bst or not\\n      left_bst=true;\\n      // update the min for right subtree\\n      tmp=min;\\n\\t  // same intution for right subtree\\n      min=INT_MAX;\\n      int right_sum=0;\\n        right_sum+=helper(root->right,min,max,is_bst,max_sum);\\n      \\n      if(is_bst && root->val < min)\\n       right_bst=true;\\n           \\n        if(tmp<min)\\n          min=tmp;\\n    //   for leaf nodes\\n        if(root->val <min)\\n         min=root->val;\\n        if(root->val > max)\\n        max = root->val;\\n    \\n\\t// return max_sum \\n    if(left_bst && right_bst)\\n        {\\n            if(left_sum + right_sum + root->val > max_sum)\\n             max_sum=left_sum + right_sum + root->val ;\\n           return left_sum + right_sum + root->val ; \\n        }\\n        else{\\n            is_bst=0;\\n            return 0;\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int min=INT_MAX;\\n        int max=INT_MIN;\\n        bool is_bst=0;\\n        int max_sum=0;\\n        helper(root,min,max,is_bst,max_sum);\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171517,
                "title": "c-dfs-pairs-beginner-friendly-superfast-no-class-object",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    pair<int,pair<int,int>>solve(TreeNode*root,int mini,int maxi,int sum)\\n    {\\n\\t\\t//if root is null then it must be bst as it is a single node\\n        if(!root)\\n        {\\n            pair<int,pair<int,int>>curr;\\n            curr.first=0;\\n            curr.second.first=INT_MAX;\\n            curr.second.second=INT_MIN;\\n            return curr;\\n        }\\n        auto l=solve(root->left,mini,maxi,sum);\\n        auto r=solve(root->right,mini,maxi,sum);\\n        \\n        pair<int,pair<int,int>>curr;\\n\\t\\t//if left and right are bst\\n        if(root->val>l.second.second && root->val<r.second.first)\\n        {\\n\\t\\t//sum will be root->val+left +right\\n            curr.first=l.first+r.first+root->val;\\n\\t\\t//min will be root,left,right\\n            curr.second.first=min(r.second.first,min(root->val,l.second.first));\\n\\t\\t//max will be root,left,right\\n            curr.second.second=max(l.second.second,max(root->val,r.second.second));\\n\\t\\t//store max ans;\\n            ans=max(ans,curr.first);\\n            return curr;\\n        }\\n\\t\\t//if left and right are not bst\\n        curr.first=0;\\n\\t\\t//initialise with int min and int max so that it will always false when comparing\\n        curr.second.first=INT_MIN;\\n        curr.second.second=INT_MAX;\\n        return curr;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        solve(root,INT_MIN,INT_MAX,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    pair<int,pair<int,int>>solve(TreeNode*root,int mini,int maxi,int sum)\\n    {\\n\\t\\t//if root is null then it must be bst as it is a single node\\n        if(!root)\\n        {\\n            pair<int,pair<int,int>>curr;\\n            curr.first=0;\\n            curr.second.first=INT_MAX;\\n            curr.second.second=INT_MIN;\\n            return curr;\\n        }\\n        auto l=solve(root->left,mini,maxi,sum);\\n        auto r=solve(root->right,mini,maxi,sum);\\n        \\n        pair<int,pair<int,int>>curr;\\n\\t\\t//if left and right are bst\\n        if(root->val>l.second.second && root->val<r.second.first)\\n        {\\n\\t\\t//sum will be root->val+left +right\\n            curr.first=l.first+r.first+root->val;\\n\\t\\t//min will be root,left,right\\n            curr.second.first=min(r.second.first,min(root->val,l.second.first));\\n\\t\\t//max will be root,left,right\\n            curr.second.second=max(l.second.second,max(root->val,r.second.second));\\n\\t\\t//store max ans;\\n            ans=max(ans,curr.first);\\n            return curr;\\n        }\\n\\t\\t//if left and right are not bst\\n        curr.first=0;\\n\\t\\t//initialise with int min and int max so that it will always false when comparing\\n        curr.second.first=INT_MIN;\\n        curr.second.second=INT_MAX;\\n        return curr;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        solve(root,INT_MIN,INT_MAX,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109013,
                "title": "c-postorder-traversal-with-comments-clean-code",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    struct bst{\\n         bool isbst;\\n      int max;\\n      int min;\\n      int sum;\\n    };\\n    \\n    bst Bst(TreeNode* root)\\n    {\\n        //we are at end of tree where node->left or node->right==nullprt\\n        //if we find a nullptr, we initialize a newbst to compare it with nodes above\\n       if(root==nullptr)\\n       {\\n        bst newbst;           \\n        newbst.isbst = true;\\n        newbst.max = INT_MIN;\\n        newbst.min = INT_MAX;\\n        newbst.sum = 0;\\n        return newbst;\\n       }\\n        \\n       //postorder traversal\\n      bst l = Bst(root->left); // left sub-tree\\n      bst r = Bst(root->right); // right sub-tree\\n        \\n        //our current node to check\\n        bst currnode;\\n        \\n        //check if its a bst\\n        \\n        //conditions->its left and right subrees must be a BST\\n        //->current node value > than max value of left subtree and <min value in right subtree\\n        currnode.isbst= l.isbst && r.isbst && (l.max < root->val && r.min > root->val);\\n        \\n        //find the max value of the subtree -> max of(max of left subtree,max of right subtree,root)\\n      currnode.max = max(root->val, max(l.max, r.max));\\n        \\n        //find the min value of the subtree -> min of(min of left subtree,min of right subtree,root)\\n      currnode.min = min(root->val, min(l.min, r.min));\\n        \\n        //we are keeping track of min and max value to finally check if currnode is bst or not from whole of its left and right subtree max and min respectively and for finding max and min value of whole subtree to use it for its parent.\\n        \\n        //if currnode is BST, we need to store its sum along with its min and max value from left and right subtree\\n        if(currnode.isbst){\\n          currnode.sum = l.sum + r.sum + root->val;\\n          currnode.min = min(root->val, min(l.min, r.min));\\n          currnode.max = max(root->val, max(l.max, r.max));\\n      }\\n        \\n        //if not a BST , then see in left subtree which stores max sum of BST in l.sum and right subtree which stores max sum of BST in r.sum and update current sum with that.\\n      else\\n          currnode.sum = max(l.sum, r.sum);\\n        \\n     //now my currnode , whether or not its a BST, contains the sum of BST ,either be it from its left subtree or its right subtree\\n      \\n        //check if its greater than max sum and store the ans\\n      res = max(res, currnode.sum);\\n        \\n      return currnode;\\n        \\n    }\\n    int res = INT_MIN;\\n    int maxSumBST(TreeNode* root) {\\n        Bst(root);\\n        return res > 0 ? res : 0;\\n    }\\n};\\n```\\n\\nIf you like the solution do give it an upvote! Thanks",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    struct bst{\\n         bool isbst;\\n      int max;\\n      int min;\\n      int sum;\\n    };\\n    \\n    bst Bst(TreeNode* root)\\n    {\\n        //we are at end of tree where node->left or node->right==nullprt\\n        //if we find a nullptr, we initialize a newbst to compare it with nodes above\\n       if(root==nullptr)\\n       {\\n        bst newbst;           \\n        newbst.isbst = true;\\n        newbst.max = INT_MIN;\\n        newbst.min = INT_MAX;\\n        newbst.sum = 0;\\n        return newbst;\\n       }\\n        \\n       //postorder traversal\\n      bst l = Bst(root->left); // left sub-tree\\n      bst r = Bst(root->right); // right sub-tree\\n        \\n        //our current node to check\\n        bst currnode;\\n        \\n        //check if its a bst\\n        \\n        //conditions->its left and right subrees must be a BST\\n        //->current node value > than max value of left subtree and <min value in right subtree\\n        currnode.isbst= l.isbst && r.isbst && (l.max < root->val && r.min > root->val);\\n        \\n        //find the max value of the subtree -> max of(max of left subtree,max of right subtree,root)\\n      currnode.max = max(root->val, max(l.max, r.max));\\n        \\n        //find the min value of the subtree -> min of(min of left subtree,min of right subtree,root)\\n      currnode.min = min(root->val, min(l.min, r.min));\\n        \\n        //we are keeping track of min and max value to finally check if currnode is bst or not from whole of its left and right subtree max and min respectively and for finding max and min value of whole subtree to use it for its parent.\\n        \\n        //if currnode is BST, we need to store its sum along with its min and max value from left and right subtree\\n        if(currnode.isbst){\\n          currnode.sum = l.sum + r.sum + root->val;\\n          currnode.min = min(root->val, min(l.min, r.min));\\n          currnode.max = max(root->val, max(l.max, r.max));\\n      }\\n        \\n        //if not a BST , then see in left subtree which stores max sum of BST in l.sum and right subtree which stores max sum of BST in r.sum and update current sum with that.\\n      else\\n          currnode.sum = max(l.sum, r.sum);\\n        \\n     //now my currnode , whether or not its a BST, contains the sum of BST ,either be it from its left subtree or its right subtree\\n      \\n        //check if its greater than max sum and store the ans\\n      res = max(res, currnode.sum);\\n        \\n      return currnode;\\n        \\n    }\\n    int res = INT_MIN;\\n    int maxSumBST(TreeNode* root) {\\n        Bst(root);\\n        return res > 0 ? res : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095948,
                "title": "java-solution",
                "content": "class Solution {\\n    class BSTtriplet{\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        boolean isBST = true;\\n        TreeNode lbstNode = null;\\n        int lbstSum =0;\\n    }\\n    \\n    int maxSum = Integer.MIN_VALUE;\\n    \\n    public BSTtriplet isBST(TreeNode node){\\n        if(node == null){\\n            return new BSTtriplet();\\n        }\\n        \\n        BSTtriplet lt = isBST(node.left);\\n        BSTtriplet rt = isBST(node.right);\\n        \\n        BSTtriplet mt = new BSTtriplet();\\n        mt.min = Math.min(node.val, Math.min(lt.min, rt.min));\\n        mt.max = Math.max(node.val, Math.max(lt.max, rt.max));\\n        \\n        boolean nodeIsBST = node.val>lt.max && node.val<rt.min;\\n        mt.isBST = (lt.isBST == true) && (rt.isBST == true) && (nodeIsBST == true);\\n        \\n        if(mt.isBST == true){\\n            mt.lbstNode = node;\\n            mt.lbstSum = lt.lbstSum + rt.lbstSum + node.val;\\n            if(mt.lbstSum > maxSum){\\n                maxSum = mt.lbstSum;\\n            }\\n        }else if(lt.lbstSum > rt.lbstSum){\\n            mt.lbstNode = lt.lbstNode;\\n            mt.lbstSum = lt.lbstSum;\\n        }else{\\n            mt.lbstNode = rt.lbstNode;\\n            mt.lbstSum = rt.lbstSum;\\n        }\\n        \\n        \\n        return mt;\\n        \\n    }\\n\\n    \\n    public int maxSumBST(TreeNode root) {\\n        \\n        \\n        \\n        BSTtriplet ans = new BSTtriplet();\\n        ans = isBST(root);\\n        \\n        return maxSum > 0 ? maxSum : 0 ;\\n        \\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    class BSTtriplet{\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        boolean isBST = true;\\n        TreeNode lbstNode = null;\\n        int lbstSum =0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2080814,
                "title": "java-wrapper-class",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        boolean isBst;\\n        int min, max, sum;\\n        Pair() {}\\n        Pair (boolean isBst, int min, int max, int sum) {\\n            this.isBst = isBst;\\n            this.min = min;\\n            this.max = max;\\n            this.sum = sum;\\n        }\\n    }\\n    \\n    int answer = Integer.MIN_VALUE;\\n    public int maxSumBST(TreeNode root) {\\n        findMax(root);\\n        return answer < 0 ? 0 : answer;\\n    }\\n    \\n    public Pair findMax(TreeNode root) {\\n        if (root == null) {\\n            return new Pair(true, Integer.MAX_VALUE, Integer.MIN_VALUE, 0);\\n        }\\n        Pair myPair = new Pair();\\n        Pair l = findMax(root.left);\\n        Pair r = findMax(root.right);\\n\\t\\t//  checking if the subtree with this root is BST or NOT\\n        myPair.isBst = l.isBst && r.isBst && (root.val > l.max && root.val < r.min);\\n        //  updating the max ans min\\n\\t\\tmyPair.min = Math.min(l.min, Math.min(root.val, r.min));\\n        myPair.max = Math.max(l.max, Math.max(root.val, r.max));\\n        myPair.sum = l.sum + r.sum + root.val;\\n        //  if isBst update the answer\\n\\t\\tif (myPair.isBst) {\\n            answer = Math.max(answer, myPair.sum);\\n        }\\n        return myPair;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    class Pair {\\n        boolean isBst;\\n        int min, max, sum;\\n        Pair() {}",
                "codeTag": "Java"
            },
            {
                "id": 2078677,
                "title": "most-simplest-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// We need to track three variables\\n\\t//1. Max value on the left aka lmax\\n\\t//2. Min value on the right aka rmin\\n\\t//3. Is left and right subtree a BST\\n\\t\\n    int ans = 0;\\n    int solve(TreeNode *root,int &minv,int &maxv,int &isbst)\\n    {\\n        if(!root)\\n        {\\n            maxv = INT_MIN,minv = INT_MAX,isbst=1;\\n            return 0;\\n        }\\n        \\n        int lmin,lmax,rmin,rmax,lbst,rbst;\\n        \\n        int lsum = solve(root->left,lmin,lmax,lbst);\\n        int rsum = solve(root->right,rmin,rmax,rbst);\\n        \\n        if(lmax<root->val and rmin>root->val and lbst and rbst)\\n        {\\n            isbst = 1;\\n            ans = max(ans,lsum + rsum + root->val);\\n        }\\n        else\\n            isbst = 0;\\n        minv = min(lmin,root->val);\\n        maxv = max(rmax,root->val);\\n        \\n        return lsum+rsum+root->val;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int min=INT_MIN,max=INT_MAX,isbst=1;\\n        solve(root,min,max,isbst);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// We need to track three variables\\n\\t//1. Max value on the left aka lmax\\n\\t//2. Min value on the right aka rmin\\n\\t//3. Is left and right subtree a BST\\n\\t\\n    int ans = 0;\\n    int solve(TreeNode *root,int &minv,int &maxv,int &isbst)\\n    {\\n        if(!root)\\n        {\\n            maxv = INT_MIN,minv = INT_MAX,isbst=1;\\n            return 0;\\n        }\\n        \\n        int lmin,lmax,rmin,rmax,lbst,rbst;\\n        \\n        int lsum = solve(root->left,lmin,lmax,lbst);\\n        int rsum = solve(root->right,rmin,rmax,rbst);\\n        \\n        if(lmax<root->val and rmin>root->val and lbst and rbst)\\n        {\\n            isbst = 1;\\n            ans = max(ans,lsum + rsum + root->val);\\n        }\\n        else\\n            isbst = 0;\\n        minv = min(lmin,root->val);\\n        maxv = max(rmax,root->val);\\n        \\n        return lsum+rsum+root->val;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int min=INT_MIN,max=INT_MAX,isbst=1;\\n        solve(root,min,max,isbst);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078243,
                "title": "simple-and-easy-solution",
                "content": "```\\nclass NodeValue {\\n    public int maxNode, minNode, sum;\\n    \\n    public NodeValue(int minNode, int maxNode, int sum) {\\n        this.minNode = minNode;\\n        this.maxNode = maxNode;\\n        this.sum = sum;\\n    }\\n}\\n    \\nclass Solution {\\n    int maxSum = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        NodeValue obj = largestBSTSubtreeSum(root);\\n        return maxSum > 0 ? maxSum : 0;\\n    }\\n    \\n    private NodeValue largestBSTSubtreeSum(TreeNode root) {\\n        if (root == null) {\\n            return new NodeValue(Integer.MAX_VALUE, Integer.MIN_VALUE, 0);\\n        }\\n        \\n        // Get values from left & right subtree of current tree\\n        NodeValue left = largestBSTSubtreeSum(root.left);\\n        NodeValue right = largestBSTSubtreeSum(root.right);\\n        \\n        // Current node is greater than max in left & smaller than\\n        // min in right, it is a BST\\n        if (left.maxNode < root.val && root.val < right.minNode) {\\n            maxSum = Math.max(maxSum, root.val + left.sum + right.sum);\\n            return new NodeValue(Math.min(root.val, left.minNode), Math.max(root.val, right.maxNode), root.val + left.sum + right.sum);\\n        }\\n        \\n        // Otherwise return [-int, int] so that parent can\\'t be\\n        // valid BST\\n        return new NodeValue (Integer.MIN_VALUE, Integer.MAX_VALUE, Math.max(left.sum, right.sum));\\n    }    \\n}\\n// Please upvote if you  find this usefull.\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass NodeValue {\\n    public int maxNode, minNode, sum;\\n    \\n    public NodeValue(int minNode, int maxNode, int sum) {\\n        this.minNode = minNode;\\n        this.maxNode = maxNode;\\n        this.sum = sum;\\n    }\\n}\\n    \\nclass Solution {\\n    int maxSum = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        NodeValue obj = largestBSTSubtreeSum(root);\\n        return maxSum > 0 ? maxSum : 0;\\n    }\\n    \\n    private NodeValue largestBSTSubtreeSum(TreeNode root) {\\n        if (root == null) {\\n            return new NodeValue(Integer.MAX_VALUE, Integer.MIN_VALUE, 0);\\n        }\\n        \\n        // Get values from left & right subtree of current tree\\n        NodeValue left = largestBSTSubtreeSum(root.left);\\n        NodeValue right = largestBSTSubtreeSum(root.right);\\n        \\n        // Current node is greater than max in left & smaller than\\n        // min in right, it is a BST\\n        if (left.maxNode < root.val && root.val < right.minNode) {\\n            maxSum = Math.max(maxSum, root.val + left.sum + right.sum);\\n            return new NodeValue(Math.min(root.val, left.minNode), Math.max(root.val, right.maxNode), root.val + left.sum + right.sum);\\n        }\\n        \\n        // Otherwise return [-int, int] so that parent can\\'t be\\n        // valid BST\\n        return new NodeValue (Integer.MIN_VALUE, Integer.MAX_VALUE, Math.max(left.sum, right.sum));\\n    }    \\n}\\n// Please upvote if you  find this usefull.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075167,
                "title": "python-postorder-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        self.val=0\\n        self.bst(root)\\n        return self.val\\n    def bst(self,root):\\n        if not root: return 0, inf ,-inf\\n        \\n        si1,minl1,maxl1=self.bst(root.left)\\n        si2,minl2,maxl2=self.bst(root.right)\\n        \\n        if maxl1<root.val<minl2:\\n            si=root.val+si1+si2\\n            self.val=max(self.val,si)\\n            return si,min(root.val,minl1),max(root.val,maxl2)\\n        return 0,-inf,inf\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        self.val=0\\n        self.bst(root)\\n        return self.val\\n    def bst(self,root):\\n        if not root: return 0, inf ,-inf\\n        \\n        si1,minl1,maxl1=self.bst(root.left)\\n        si2,minl2,maxl2=self.bst(root.right)\\n        \\n        if maxl1<root.val<minl2:\\n            si=root.val+si1+si2\\n            self.val=max(self.val,si)\\n            return si,min(root.val,minl1),max(root.val,maxl2)\\n        return 0,-inf,inf\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067322,
                "title": "c-solution-using-struct-inside-a-class",
                "content": "```\\n//will be using struct inside class to solve this question\\nclass Solution {\\npublic:\\n    //this struct will contain subtree\\'s min and max value , sum of left and right subtrees ,\\n\\t//ans that conatins sum of nodes of largest bst formed yet \\n\\t//and isBst conatins boolean value that whether the subtree is bst or not\\n    struct Info{\\n        int min;\\n        int max;\\n        int sum;\\n        int ans;\\n        bool isBst;\\n    };\\n    \\n    Info sol(TreeNode* root){\\n        if(!root)return {INT_MAX, INT_MIN,0,INT_MIN,true};//if root==NULL\\n        if(!root->left&&!root->right){\\n            return {root->val,root->val,root->val,root->val,true};//if leaf node\\n        }\\n        //recursive calls for left and right subtree\\n        Info left= sol(root->left);\\n        Info right= sol(root->right);\\n        \\n        \\n        Info cur; //for current info\\n        //checks condition whether cur node forms bst or not\\n        if(left.isBst && right.isBst && root->val>left.max&&root->val < right.min){\\n            cur.min= min(left.min,min(right.min,root->val));//for bst validation purpose\\n            cur.max= max(left.max, max(right.max,root->val));//for bst validation purpose\\n            \\n            cur.sum=left.sum+right.sum+root->val;//left part + right part+root value\\n            \\n            //either ans will be left.ans or right.ans or cur.sum\\n            if(left.sum==INT_MIN){//if left subtree is NULL\\n                cur.ans = max(left.ans,max(right.ans,right.sum+root->val));    \\n            }\\n            else if(right.sum==INT_MIN){//ifright subtree is NULL\\n                cur.ans = max(left.ans,max(right.ans,left.sum+root->val));    \\n            }\\n            else{\\n                cur.ans = max(left.ans,max(right.ans,cur.sum));    \\n            }\\n            \\n            cur.isBst=true;\\n            return cur;\\n        }\\n        cur.sum=left.sum+right.sum+root->val;//cur.sum is of no use now\\n        cur.ans= max(left.ans, right.ans);//only check max from left.ans and right.ans\\n        cur.isBst= false;//set bst to false\\n        return cur;\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        Info a= sol(root);\\n        if(a.ans<0)return 0;\\n        return a.ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//will be using struct inside class to solve this question\\nclass Solution {\\npublic:\\n    //this struct will contain subtree\\'s min and max value , sum of left and right subtrees ,\\n\\t//ans that conatins sum of nodes of largest bst formed yet \\n\\t//and isBst conatins boolean value that whether the subtree is bst or not\\n    struct Info{\\n        int min;\\n        int max;\\n        int sum;\\n        int ans;\\n        bool isBst;\\n    };\\n    \\n    Info sol(TreeNode* root){\\n        if(!root)return {INT_MAX, INT_MIN,0,INT_MIN,true};//if root==NULL\\n        if(!root->left&&!root->right){\\n            return {root->val,root->val,root->val,root->val,true};//if leaf node\\n        }\\n        //recursive calls for left and right subtree\\n        Info left= sol(root->left);\\n        Info right= sol(root->right);\\n        \\n        \\n        Info cur; //for current info\\n        //checks condition whether cur node forms bst or not\\n        if(left.isBst && right.isBst && root->val>left.max&&root->val < right.min){\\n            cur.min= min(left.min,min(right.min,root->val));//for bst validation purpose\\n            cur.max= max(left.max, max(right.max,root->val));//for bst validation purpose\\n            \\n            cur.sum=left.sum+right.sum+root->val;//left part + right part+root value\\n            \\n            //either ans will be left.ans or right.ans or cur.sum\\n            if(left.sum==INT_MIN){//if left subtree is NULL\\n                cur.ans = max(left.ans,max(right.ans,right.sum+root->val));    \\n            }\\n            else if(right.sum==INT_MIN){//ifright subtree is NULL\\n                cur.ans = max(left.ans,max(right.ans,left.sum+root->val));    \\n            }\\n            else{\\n                cur.ans = max(left.ans,max(right.ans,cur.sum));    \\n            }\\n            \\n            cur.isBst=true;\\n            return cur;\\n        }\\n        cur.sum=left.sum+right.sum+root->val;//cur.sum is of no use now\\n        cur.ans= max(left.ans, right.ans);//only check max from left.ans and right.ans\\n        cur.isBst= false;//set bst to false\\n        return cur;\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        Info a= sol(root);\\n        if(a.ans<0)return 0;\\n        return a.ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063925,
                "title": "c-recursive-o-n-no-custom-class",
                "content": "```\\n//Refernce and recursion overloaded\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maximumBSTSum = 0;\\n    \\n    bool isBST(TreeNode* root, int &minVal, int &maxVal, int &currentSum) {\\n        if(!root)return true;\\n        \\n        int leftSum = 0;\\n        int rightSum = 0;\\n        int minLeft = INT_MIN;\\n        int maxLeft = INT_MAX;\\n        int minRight = INT_MIN;\\n        int maxRight = INT_MAX;\\n        auto leftHalf = isBST(root->left, minLeft, maxLeft, leftSum);\\n        auto rightHalf = isBST(root->right, minRight, maxRight, rightSum);\\n        \\n        //cout<<minLeft<<\" \"<<maxLeft<<\" maxLR \"<<minRight<<\" \"<<maxRight<<endl;\\n        if(!root->left && !root->right){\\n            minVal = root->val;\\n            maxVal = root->val;\\n        }else if(!root->left) {\\n            if(minRight <= root->val)return false;\\n            minVal = root->val;\\n            maxVal = maxRight;\\n        }else if(!root->right){\\n            if(maxLeft >= root->val)return false;\\n            minVal = minLeft;\\n            maxVal = root->val;\\n        }else {\\n            if(minRight <= root->val || maxLeft >= root->val)return false;\\n            minVal = minLeft;\\n            maxVal = maxRight;\\n        }\\n        \\n        if(leftHalf&&rightHalf){\\n            currentSum += root->val+leftSum+rightSum;\\n        } else currentSum = 0;\\n        \\n        maximumBSTSum = max(maximumBSTSum, currentSum);\\n        \\n        return leftHalf && rightHalf;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        int currentSum = 0;\\n        int minVal = INT_MIN;\\n        int maxVal = INT_MAX;\\n        isBST(root, minVal, maxVal, currentSum);\\n        return maximumBSTSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n//Refernce and recursion overloaded\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maximumBSTSum = 0;\\n    \\n    bool isBST(TreeNode* root, int &minVal, int &maxVal, int &currentSum) {\\n        if(!root)return true;\\n        \\n        int leftSum = 0;\\n        int rightSum = 0;\\n        int minLeft = INT_MIN;\\n        int maxLeft = INT_MAX;\\n        int minRight = INT_MIN;\\n        int maxRight = INT_MAX;\\n        auto leftHalf = isBST(root->left, minLeft, maxLeft, leftSum);\\n        auto rightHalf = isBST(root->right, minRight, maxRight, rightSum);\\n        \\n        //cout<<minLeft<<\" \"<<maxLeft<<\" maxLR \"<<minRight<<\" \"<<maxRight<<endl;\\n        if(!root->left && !root->right){\\n            minVal = root->val;\\n            maxVal = root->val;\\n        }else if(!root->left) {\\n            if(minRight <= root->val)return false;\\n            minVal = root->val;\\n            maxVal = maxRight;\\n        }else if(!root->right){\\n            if(maxLeft >= root->val)return false;\\n            minVal = minLeft;\\n            maxVal = root->val;\\n        }else {\\n            if(minRight <= root->val || maxLeft >= root->val)return false;\\n            minVal = minLeft;\\n            maxVal = maxRight;\\n        }\\n        \\n        if(leftHalf&&rightHalf){\\n            currentSum += root->val+leftSum+rightSum;\\n        } else currentSum = 0;\\n        \\n        maximumBSTSum = max(maximumBSTSum, currentSum);\\n        \\n        return leftHalf && rightHalf;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        int currentSum = 0;\\n        int minVal = INT_MIN;\\n        int maxVal = INT_MAX;\\n        isBST(root, minVal, maxVal, currentSum);\\n        return maximumBSTSum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1974777,
                "title": "java-beats-71-recursive-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        Sum sum = new Sum();\\n        findLargestBST(root,sum);\\n       \\treturn sum.max;\\n\\t}\\n\\t\\n\\tpublic static Tuple findLargestBST(TreeNode root,Sum sum){\\n\\t\\tif(root==null) return new Tuple(0,Integer.MAX_VALUE,Integer.MIN_VALUE);\\n\\t\\tTuple left = findLargestBST(root.left,sum);\\n\\t\\tTuple right = findLargestBST(root.right,sum);\\n\\t\\tif(left.max<root.val&&right.min>root.val){\\n            sum.max = Math.max(sum.max,left.sum+right.sum+root.val);\\n\\t\\t\\treturn new Tuple(left.sum+right.sum+root.val,Math.min(left.min,root.val),Math.max(root.val,right.max));\\n\\t\\t}\\n\\t\\treturn new Tuple(0,Integer.MIN_VALUE,Integer.MAX_VALUE);\\n\\t}\\n}\\n\\n\\n\\nclass Tuple{\\n    int sum;\\n\\tint min;\\n\\tint max;\\n\\tpublic Tuple(int sum,int min,int max){\\n\\t\\tthis.sum = sum;\\n\\t\\tthis.min = min;\\n\\t\\tthis.max = max;\\n\\t}\\n}\\n\\nclass Sum{\\n    int max;\\n    public Sum(){}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        Sum sum = new Sum();\\n        findLargestBST(root,sum);\\n       \\treturn sum.max;\\n\\t}\\n\\t\\n\\tpublic static Tuple findLargestBST(TreeNode root,Sum sum){\\n\\t\\tif(root==null) return new Tuple(0,Integer.MAX_VALUE,Integer.MIN_VALUE);\\n\\t\\tTuple left = findLargestBST(root.left,sum);\\n\\t\\tTuple right = findLargestBST(root.right,sum);\\n\\t\\tif(left.max<root.val&&right.min>root.val){\\n            sum.max = Math.max(sum.max,left.sum+right.sum+root.val);\\n\\t\\t\\treturn new Tuple(left.sum+right.sum+root.val,Math.min(left.min,root.val),Math.max(root.val,right.max));\\n\\t\\t}\\n\\t\\treturn new Tuple(0,Integer.MIN_VALUE,Integer.MAX_VALUE);\\n\\t}\\n}\\n\\n\\n\\nclass Tuple{\\n    int sum;\\n\\tint min;\\n\\tint max;\\n\\tpublic Tuple(int sum,int min,int max){\\n\\t\\tthis.sum = sum;\\n\\t\\tthis.min = min;\\n\\t\\tthis.max = max;\\n\\t}\\n}\\n\\nclass Sum{\\n    int max;\\n    public Sum(){}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960238,
                "title": "python-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        \\n        def check(root):\\n            def validate(root,low=-math.inf,high=math.inf):\\n                if not root:\\n                    return\\n                if not low<root.val<high:\\n                    self.bst=False\\n                self.sm+=root.val\\n                validate(root.left,low,root.val)\\n                validate(root.right,root.val,high)\\n            \\n            self.bst=True\\n            self.sm=0\\n            validate(root)\\n            if self.bst==True:\\n                return self.sm\\n            return 0\\n        \\n        def dfs(root):\\n            if not root:\\n                return\\n            self.ans=max(self.ans,check(root))\\n            dfs(root.left)\\n            dfs(root.right)\\n        \\n        self.ans=0\\n        dfs(root)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        \\n        def check(root):\\n            def validate(root,low=-math.inf,high=math.inf):\\n                if not root:\\n                    return\\n                if not low<root.val<high:\\n                    self.bst=False\\n                self.sm+=root.val\\n                validate(root.left,low,root.val)\\n                validate(root.right,root.val,high)\\n            \\n            self.bst=True\\n            self.sm=0\\n            validate(root)\\n            if self.bst==True:\\n                return self.sm\\n            return 0\\n        \\n        def dfs(root):\\n            if not root:\\n                return\\n            self.ans=max(self.ans,check(root))\\n            dfs(root.left)\\n            dfs(root.right)\\n        \\n        self.ans=0\\n        dfs(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957290,
                "title": "c-using-struct-dfs-clean-code-short-solution",
                "content": "```\\n */\\nclass Solution {\\npublic:\\n    \\n     struct s\\n     {\\n         bool isBST;\\n         int minv , maxv , sum;\\n     };\\n    // storing the maxe , mine for each node \\n    \\n    s func(TreeNode* root , int& res)\\n    {\\n        if(root==NULL)\\n        {\\n            return { true , INT_MAX , INT_MIN , 0};\\n        }\\n        \\n        \\n        s left_subtree=func(root->left , res);\\n        s right_subtree=func(root->right , res);\\n        \\n        if( left_subtree.isBST && right_subtree.isBST && root->val>left_subtree.maxv && root->val < right_subtree.minv)\\n        {\\n            int curr_sum= left_subtree.sum + right_subtree.sum + root->val;\\n            \\n            res=max(res , curr_sum);\\n            return {true , min(left_subtree.minv , root->val) , max(right_subtree.maxv , root->val) , curr_sum};\\n        }\\n        else\\n        {\\n            return {false , 0 , 0 , 0};\\n        }\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int res=0;\\n        func(root , res);\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n */\\nclass Solution {\\npublic:\\n    \\n     struct s\\n     {\\n         bool isBST;\\n         int minv , maxv , sum;\\n     };\\n    // storing the maxe , mine for each node \\n    \\n    s func(TreeNode* root , int& res)\\n    {\\n        if(root==NULL)\\n        {\\n            return { true , INT_MAX , INT_MIN , 0};\\n        }\\n        \\n        \\n        s left_subtree=func(root->left , res);\\n        s right_subtree=func(root->right , res);\\n        \\n        if( left_subtree.isBST && right_subtree.isBST && root->val>left_subtree.maxv && root->val < right_subtree.minv)\\n        {\\n            int curr_sum= left_subtree.sum + right_subtree.sum + root->val;\\n            \\n            res=max(res , curr_sum);\\n            return {true , min(left_subtree.minv , root->val) , max(right_subtree.maxv , root->val) , curr_sum};\\n        }\\n        else\\n        {\\n            return {false , 0 , 0 , 0};\\n        }\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int res=0;\\n        func(root , res);\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929601,
                "title": "java-post-order-traversal",
                "content": "```\\n\\tclass BSTInfo {\\n        int max;\\n        int min;\\n        int sum;\\n        \\n        public BSTInfo(int max, int min, int sum){\\n            this.max = max;\\n            this.min = min;\\n            this.sum = sum;\\n        }\\n    }\\n    \\n    int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n        maxSum = 0;\\n        getSum(root);\\n        return maxSum;\\n    }\\n    \\n    private BSTInfo getSum(TreeNode root){\\n        if(root == null) return new BSTInfo(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        \\n        BSTInfo left = getSum(root.left);\\n        BSTInfo right = getSum(root.right);\\n        \\n        // Check if tree from current node is BST or not (If BST only then we can use sum else its 0)\\n        boolean isBST = left != null && right != null && root.val > left.max && root.val < right.min;\\n        if(!isBST) return null;\\n        \\n        int maxCurrent = Math.max(root.val,right.max);\\n        int minCurrent = Math.min(root.val,left.min);\\n        int currSum = root.val + left.sum + right.sum;\\n        maxSum = Math.max(maxSum, currSum);\\n        \\n        return new BSTInfo(maxCurrent, minCurrent, currSum);\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n\\tclass BSTInfo {\\n        int max;\\n        int min;\\n        int sum;\\n        \\n        public BSTInfo(int max, int min, int sum){\\n            this.max = max;\\n            this.min = min;\\n            this.sum = sum;\\n        }\\n    }\\n    \\n    int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n        maxSum = 0;\\n        getSum(root);\\n        return maxSum;\\n    }\\n    \\n    private BSTInfo getSum(TreeNode root){\\n        if(root == null) return new BSTInfo(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        \\n        BSTInfo left = getSum(root.left);\\n        BSTInfo right = getSum(root.right);\\n        \\n        // Check if tree from current node is BST or not (If BST only then we can use sum else its 0)\\n        boolean isBST = left != null && right != null && root.val > left.max && root.val < right.min;\\n        if(!isBST) return null;\\n        \\n        int maxCurrent = Math.max(root.val,right.max);\\n        int minCurrent = Math.min(root.val,left.min);\\n        int currSum = root.val + left.sum + right.sum;\\n        maxSum = Math.max(maxSum, currSum);\\n        \\n        return new BSTInfo(maxCurrent, minCurrent, currSum);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809776,
                "title": "dp-on-trees",
                "content": "**Short Code often takes BIG BRAINS!!**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int ans;\\npublic:\\n    vector<int> isBST(TreeNode* root){\\n        if(!root)return {INT_MAX, INT_MIN, 1, 0};   //{minval, maxval, isBST, sumOfNodesInBST}\\n        vector<int> l = isBST(root->left);\\n        vector<int> r = isBST(root->right);\\n        vector<int> rt = {min({root->val,l[0],r[0]}),max({root->val,l[1],r[1]}),(root->val>l[1] and root->val<r[0] and l[2] and r[2])?1:0,root->val+l[3]+r[3]};\\n        if(rt[2])ans=max(ans,rt[3]);\\n        return rt;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        isBST(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int ans;\\npublic:\\n    vector<int> isBST(TreeNode* root){\\n        if(!root)return {INT_MAX, INT_MIN, 1, 0};   //{minval, maxval, isBST, sumOfNodesInBST}\\n        vector<int> l = isBST(root->left);\\n        vector<int> r = isBST(root->right);\\n        vector<int> rt = {min({root->val,l[0],r[0]}),max({root->val,l[1],r[1]}),(root->val>l[1] and root->val<r[0] and l[2] and r[2])?1:0,root->val+l[3]+r[3]};\\n        if(rt[2])ans=max(ans,rt[3]);\\n        return rt;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        isBST(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798932,
                "title": "java-post-order-traversal-clean-code",
                "content": "Please upvote, if you find it useful :)\\n\\n```\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        isBST temp = checkBST(root);\\n        \\n        return temp.maxSum < 0 ? 0 : temp.maxSum;\\n    }\\n    \\n    public class isBST {\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        boolean isBST = true;\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n    }\\n    \\n    public isBST checkBST(TreeNode root) {\\n        if(root == null) {\\n            return new isBST();\\n        }\\n        \\n        isBST lp = checkBST(root.left);\\n        isBST rp = checkBST(root.right);\\n        \\n        isBST mp = new isBST();\\n        mp.max = Math.max(root.val, Math.max(lp.max, rp.max));\\n        mp.min = Math.min(root.val, Math.min(lp.min, rp.min));\\n        mp.sum = lp.sum + rp.sum + root.val;\\n        \\n        boolean check = root.val > lp.max && root.val < rp.min;\\n        if(lp.isBST && rp.isBST && check) {\\n            mp.isBST = true;\\n            \\n            int tempMax = Math.max(mp.sum, Math.max(lp.sum, rp.sum));\\n            mp.maxSum = Math.max(tempMax, Math.max(lp.maxSum, rp.maxSum));\\n            \\n        } else {\\n            mp.isBST = false;\\n            mp.maxSum = Math.max(lp.maxSum, rp.maxSum);\\n        }\\n        return mp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        isBST temp = checkBST(root);\\n        \\n        return temp.maxSum < 0 ? 0 : temp.maxSum;\\n    }\\n    \\n    public class isBST {\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        boolean isBST = true;\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n    }\\n    \\n    public isBST checkBST(TreeNode root) {\\n        if(root == null) {\\n            return new isBST();\\n        }\\n        \\n        isBST lp = checkBST(root.left);\\n        isBST rp = checkBST(root.right);\\n        \\n        isBST mp = new isBST();\\n        mp.max = Math.max(root.val, Math.max(lp.max, rp.max));\\n        mp.min = Math.min(root.val, Math.min(lp.min, rp.min));\\n        mp.sum = lp.sum + rp.sum + root.val;\\n        \\n        boolean check = root.val > lp.max && root.val < rp.min;\\n        if(lp.isBST && rp.isBST && check) {\\n            mp.isBST = true;\\n            \\n            int tempMax = Math.max(mp.sum, Math.max(lp.sum, rp.sum));\\n            mp.maxSum = Math.max(tempMax, Math.max(lp.maxSum, rp.maxSum));\\n            \\n        } else {\\n            mp.isBST = false;\\n            mp.maxSum = Math.max(lp.maxSum, rp.maxSum);\\n        }\\n        return mp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783868,
                "title": "dfs-o-n-recursion-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Sol{\\n        \\n   public:\\n    int mn, mx, sum;\\n    Sol(int mn_, int mx_, int sum_){\\n        mn = mn_;\\n        mx = mx_;\\n        sum = sum_;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    \\n    Sol findAns(TreeNode * root){\\n       if(root==NULL) {\\n           return Sol(INT_MAX, INT_MIN, 0);\\n       }\\n       int x = root->val;\\n       Sol l = findAns(root->left);\\n        Sol r = findAns(root->right);\\n        if(l.mx < x and x< r.mn){\\n            if(root->left!=NULL and root->right!=NULL){ // has both children\\n                ans = max(ans, l.sum+r.sum+x);\\n                return Sol(l.mn, r.mx, l.sum+r.sum+x);\\n            }\\n            else if(root->left!=NULL){ // has only left child\\n               ans = max(ans, l.sum+x);\\n                return Sol(l.mn, x, l.sum+x);\\n            }\\n            else if(root->right!=NULL){ // has only right child\\n               ans = max(ans, r.sum+x) ;\\n                return Sol(x, r.mx, r.sum+x);\\n            }\\n            else{ // no children present\\n                ans = max(ans, x);\\n                return Sol(x, x, x);\\n            }\\n        }\\n        else{\\n            return Sol(INT_MIN, INT_MAX, 0);\\n        }\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        findAns(root);\\n        return max(0, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Sol{\\n        \\n   public:\\n    int mn, mx, sum;\\n    Sol(int mn_, int mx_, int sum_){\\n        mn = mn_;\\n        mx = mx_;\\n        sum = sum_;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    \\n    Sol findAns(TreeNode * root){\\n       if(root==NULL) {\\n           return Sol(INT_MAX, INT_MIN, 0);\\n       }\\n       int x = root->val;\\n       Sol l = findAns(root->left);\\n        Sol r = findAns(root->right);\\n        if(l.mx < x and x< r.mn){\\n            if(root->left!=NULL and root->right!=NULL){ // has both children\\n                ans = max(ans, l.sum+r.sum+x);\\n                return Sol(l.mn, r.mx, l.sum+r.sum+x);\\n            }\\n            else if(root->left!=NULL){ // has only left child\\n               ans = max(ans, l.sum+x);\\n                return Sol(l.mn, x, l.sum+x);\\n            }\\n            else if(root->right!=NULL){ // has only right child\\n               ans = max(ans, r.sum+x) ;\\n                return Sol(x, r.mx, r.sum+x);\\n            }\\n            else{ // no children present\\n                ans = max(ans, x);\\n                return Sol(x, x, x);\\n            }\\n        }\\n        else{\\n            return Sol(INT_MIN, INT_MAX, 0);\\n        }\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        findAns(root);\\n        return max(0, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704712,
                "title": "java-solution-o-n-easy",
                "content": "```\\nclass Solution {\\n    \\n    public class pair {  \\n        int max, min;   //max and min value of that TreeNode\\n        boolean isBST;   // whetherthe root is a bst or not\\n        int sum;   // here sum is the sum of  whole tre nodes\\n    }\\n    \\n    public pair BSTHelper(TreeNode root) {\\n        pair p = new pair();\\n        if(root == null) {\\n            p.max = Integer.MIN_VALUE;\\n            p.min = Integer.MAX_VALUE;\\n            p.isBST = true;\\n            p.sum = 0;\\n            return p;\\n        }\\n        \\n        pair left = BSTHelper(root.left);\\n        pair right = BSTHelper(root.right);\\n        p.max = Math.max(root.val, Math.max(left.max, right.max));\\n        p.min = Math.min(root.val, Math.min(left.min, right.min));\\n p.isBST = left.isBST && right.isBST && left.max < root.val && root.val < right.min;\\n        p.sum = root.val + left.sum + right.sum;\\n        \\n        if(p.isBST) {\\n          maxSum = Math.max(maxSum, p.sum);\\n        }\\n        return p;\\n    }\\n     \\n    int maxSum = 0;      // Final Answer\\n    public int maxSumBST(TreeNode root) {\\n        pair p = BSTHelper(root);\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public class pair {  \\n        int max, min;   //max and min value of that TreeNode\\n        boolean isBST;   // whetherthe root is a bst or not\\n        int sum;   // here sum is the sum of  whole tre nodes\\n    }\\n    \\n    public pair BSTHelper(TreeNode root) {\\n        pair p = new pair();\\n        if(root == null) {\\n            p.max = Integer.MIN_VALUE;\\n            p.min = Integer.MAX_VALUE;\\n            p.isBST = true;\\n            p.sum = 0;\\n            return p;\\n        }\\n        \\n        pair left = BSTHelper(root.left);\\n        pair right = BSTHelper(root.right);\\n        p.max = Math.max(root.val, Math.max(left.max, right.max));\\n        p.min = Math.min(root.val, Math.min(left.min, right.min));\\n p.isBST = left.isBST && right.isBST && left.max < root.val && root.val < right.min;\\n        p.sum = root.val + left.sum + right.sum;\\n        \\n        if(p.isBST) {\\n          maxSum = Math.max(maxSum, p.sum);\\n        }\\n        return p;\\n    }\\n     \\n    int maxSum = 0;      // Final Answer\\n    public int maxSumBST(TreeNode root) {\\n        pair p = BSTHelper(root);\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679699,
                "title": "python-very-easy-understand-postorder-solution-o-n",
                "content": "```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        maxSum = 0\\n        def traverse(root):\\n            nonlocal maxSum\\n            if not root:\\n                return float(\\'inf\\'), float(\\'-inf\\'), 0\\n            # \\n            left = traverse(root.left)\\n            right = traverse(root.right)\\n            if not left or not right:\\n                return \\n            leftMin, leftMax, leftSum = left[0], left[1], left[2]\\n            rightMin, rightMax, rightSum = right[0], right[1], right[2]\\n            if root.val > leftMax and root.val < rightMin:\\n                rootMax = max(rightMax, root.val)\\n                rootMin = min(leftMin, root.val)\\n                rootSum = leftSum + rightSum + root.val\\n                maxSum = max(maxSum, rootSum)\\n                return rootMin, rootMax, rootSum\\n        traverse(root)\\n        return maxSum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        maxSum = 0\\n        def traverse(root):\\n            nonlocal maxSum\\n            if not root:\\n                return float(\\'inf\\'), float(\\'-inf\\'), 0\\n            # \\n            left = traverse(root.left)\\n            right = traverse(root.right)\\n            if not left or not right:\\n                return \\n            leftMin, leftMax, leftSum = left[0], left[1], left[2]\\n            rightMin, rightMax, rightSum = right[0], right[1], right[2]\\n            if root.val > leftMax and root.val < rightMin:\\n                rootMax = max(rightMax, root.val)\\n                rootMin = min(leftMin, root.val)\\n                rootSum = leftSum + rightSum + root.val\\n                maxSum = max(maxSum, rootSum)\\n                return rootMin, rootMax, rootSum\\n        traverse(root)\\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676003,
                "title": "postorder-one-pass",
                "content": "```\\nclass res{\\npublic:\\n    bool isbst;\\n    int mx;\\n    int mn;\\n    int sum;\\n    res(){\\n        isbst=true;\\n        mx=INT_MIN;\\n        mn=INT_MAX;\\n        sum = 0;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    res help(TreeNode* root){\\n        res r;\\n        if(!root) return r;\\n        res rl = help(root->left);\\n        res rr = help(root->right);\\n        if(rl.isbst && rr.isbst && root->val>rl.mx && root->val<rr.mn){\\n            r.mx = max(root->val,rr.mx);\\n            r.mn = min(rl.mn,root->val);\\n            r.sum = rl.sum+rr.sum+root->val;\\n            ans = max(ans,r.sum);\\n        }else{\\n            r.isbst = false;\\n        }\\n        return r;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        help(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass res{\\npublic:\\n    bool isbst;\\n    int mx;\\n    int mn;\\n    int sum;\\n    res(){\\n        isbst=true;\\n        mx=INT_MIN;\\n        mn=INT_MAX;\\n        sum = 0;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    res help(TreeNode* root){\\n        res r;\\n        if(!root) return r;\\n        res rl = help(root->left);\\n        res rr = help(root->right);\\n        if(rl.isbst && rr.isbst && root->val>rl.mx && root->val<rr.mn){\\n            r.mx = max(root->val,rr.mx);\\n            r.mn = min(rl.mn,root->val);\\n            r.sum = rl.sum+rr.sum+root->val;\\n            ans = max(ans,r.sum);\\n        }else{\\n            r.isbst = false;\\n        }\\n        return r;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        help(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652344,
                "title": "my-short-solution",
                "content": "```\\n\\n\\n// {bst, leftMax, rightMin, sum}\\n\\nclass Solution {\\n    const int min_val = -(40000+1);\\n    const int max_val = (40000+1);\\n    vector<int> process(TreeNode* root,int& ans){\\n        if(root==NULL){\\n            return {1, min_val, max_val, 0};\\n        }\\n        \\n        vector<int> left = process(root->left, ans);\\n        vector<int> right = process(root->right, ans);\\n        \\n        \\n        int leftMax = max({left[1], right[1], root->val});\\n        int rightMin = min({left[2], right[2], root->val});\\n        int sum = left[3] + right[3] + root->val;\\n        \\n        vector<int> cur = {0, leftMax, rightMin, sum};\\n                \\n        if(left[1]<root->val && right[2] > root->val && left[0] && right[0]){\\n            cur[0] = 1;\\n            ans = max(ans, sum);\\n        }\\n        \\n        return cur;\\n    }\\n    \\n    \\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        \\n        process(root, ans);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\n\\n// {bst, leftMax, rightMin, sum}\\n\\nclass Solution {\\n    const int min_val = -(40000+1);\\n    const int max_val = (40000+1);\\n    vector<int> process(TreeNode* root,int& ans){\\n        if(root==NULL){\\n            return {1, min_val, max_val, 0};\\n        }\\n        \\n        vector<int> left = process(root->left, ans);\\n        vector<int> right = process(root->right, ans);\\n        \\n        \\n        int leftMax = max({left[1], right[1], root->val});\\n        int rightMin = min({left[2], right[2], root->val});\\n        int sum = left[3] + right[3] + root->val;\\n        \\n        vector<int> cur = {0, leftMax, rightMin, sum};\\n                \\n        if(left[1]<root->val && right[2] > root->val && left[0] && right[0]){\\n            cur[0] = 1;\\n            ans = max(ans, sum);\\n        }\\n        \\n        return cur;\\n    }\\n    \\n    \\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        \\n        process(root, ans);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565055,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1574666,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1567548,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1576031,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1575892,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1575216,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1573657,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1567457,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1969753,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1576542,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1565055,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1574666,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1567548,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1576031,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1575892,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1575216,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1573657,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1567457,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1969753,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1576542,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the node’s key.\n> The right SUBTREE of a node contains only nodes with keys greater than the node’s key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1573937,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1573509,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1569850,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 2051987,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1985465,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1953347,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1947743,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1903855,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1882435,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1846339,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            }
        ]
    },
    {
        "title": "Generate a String With Characters That Have Odd Counts",
        "question_content": "<p>Given an&nbsp;integer <code>n</code>, <em>return a string with <code>n</code>&nbsp;characters such that each character in such string occurs <strong>an odd number of times</strong></em>.</p>\n\n<p>The returned string must contain only lowercase English letters. If there are multiples valid strings, return <strong>any</strong> of them. &nbsp;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> &quot;pppz&quot;\n<strong>Explanation:</strong> &quot;pppz&quot; is a valid string since the character &#39;p&#39; occurs three times and the character &#39;z&#39; occurs once. Note that there are many other valid strings such as &quot;ohhh&quot; and &quot;love&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> &quot;xy&quot;\n<strong>Explanation:</strong> &quot;xy&quot; is a valid string since the characters &#39;x&#39; and &#39;y&#39; occur once. Note that there are many other valid strings such as &quot;ag&quot; and &quot;ur&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 7\n<strong>Output:</strong> &quot;holasss&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 532520,
                "title": "java-c-python-one-lines",
                "content": "## **Explanation**\\nIf `n` is odd, we return `\"bbbb....b\"`.\\nIf `n` is even, we return `\"baaa...a\"`.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Java:**\\n```java\\n    public String generateTheString(int n) {\\n        return \"b\" + \"ab\".substring(n % 2, 1 + n % 2).repeat(n - 1);\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    string generateTheString(int n) {\\n        return \"b\" + string(n - 1, \\'a\\' + n % 2);\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def generateTheString(self, n):\\n        return \\'b\\' + \\'ab\\'[n & 1] * (n - 1)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public String generateTheString(int n) {\\n        return \"b\" + \"ab\".substring(n % 2, 1 + n % 2).repeat(n - 1);\\n    }\\n```\n```cpp\\n    string generateTheString(int n) {\\n        return \"b\" + string(n - 1, \\'a\\' + n % 2);\\n    }\\n```\n```py\\n    def generateTheString(self, n):\\n        return \\'b\\' + \\'ab\\'[n & 1] * (n - 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 538947,
                "title": "java-100-speed-and-100-memory",
                "content": "Use a character array\\n\\n```\\npublic String generateTheString(int n) {\\n    char[] str = new char[n];\\n    Arrays.fill(str, \\'a\\');\\n    if(n%2==0) {\\n        str[0] = \\'b\\';\\n    }\\n    return new String(str);\\n}\\n\\n```\\n\\nI have created a video explaining the solution \\nhttps://www.youtube.com/watch?v=x61_G5le9jM",
                "solutionTags": [],
                "code": "```\\npublic String generateTheString(int n) {\\n    char[] str = new char[n];\\n    Arrays.fill(str, \\'a\\');\\n    if(n%2==0) {\\n        str[0] = \\'b\\';\\n    }\\n    return new String(str);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532907,
                "title": "python-easy",
                "content": "ALGORITHM: \\n1. If n is odd, return return a string of a.....a of length n\\n2. If b is even, return a string on (n-1) a and b (a.....ab)\\nRUNTIME COMPLEXITY: O(N)\\nSPACE COMPLEXITY: O(N)\\n\\n```\\nclass Solution(object):\\n    def generateTheString(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        if n % 2 == 1:\\n            return \\'a\\' * n\\n        else:\\n            return \\'a\\' * (n-1) + \\'b\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def generateTheString(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        if n % 2 == 1:\\n            return \\'a\\' * n\\n        else:\\n            return \\'a\\' * (n-1) + \\'b\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543710,
                "title": "javascript-o-n-96-100",
                "content": "```\\nvar generateTheString = function(n) {\\n  return n % 2 === 0 ? `${\\'a\\'.repeat(n - 1)}b` : \\'a\\'.repeat(n);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateTheString = function(n) {\\n  return n % 2 === 0 ? `${\\'a\\'.repeat(n - 1)}b` : \\'a\\'.repeat(n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532474,
                "title": "c-simple-construction-one-line",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        return n % 2 ? string(n, \\'a\\') : string(n - 1, \\'a\\') + \\'b\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        return n % 2 ? string(n, \\'a\\') : string(n - 1, \\'a\\') + \\'b\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752772,
                "title": "c-easy-100-faster-simple-short",
                "content": "# 1374. Generate a String With Characters That Have Odd Counts\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Begginer Friendly Approach.\\n3. PLease Upvote if it Helps.\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\\n\\n[https://github.com/knockcat/Leetcode](http://)\\n\\n**0 ms || 100 % Solution**\\n![image](https://assets.leetcode.com/users/images/c3d451b6-b091-49d8-ad74-3bcc1a041a8d_1644239245.310297.png)\\n\\n**CODE**\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s;\\n\\n            if(n% 2 == 0)\\n            {\\n                for(int i = 0; i<n-1; ++i)\\n                    s.push_back(\\'a\\');\\n                s.push_back(\\'b\\');\\n            }\\n            else\\n            {\\n                for(int i = 0; i<n; ++i)\\n                    s.push_back(\\'a\\');\\n            }\\n           \\n            return s;\\n        // \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1. Easy C++\\n2. Begginer Friendly Approach.\\n3. PLease Upvote if it Helps.\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s;\\n\\n            if(n% 2 == 0)\\n            {\\n                for(int i = 0; i<n-1; ++i)\\n                    s.push_back(\\'a\\');\\n                s.push_back(\\'b\\');\\n            }\\n            else\\n            {\\n                for(int i = 0; i<n; ++i)\\n                    s.push_back(\\'a\\');\\n            }\\n           \\n            return s;\\n        // \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560986,
                "title": "python-one-line-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef generateTheString(self, n: int) -> str:\\n\\treturn \"a\" * n if n % 2 else \"a\" * (n - 1) + \"b\"\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef generateTheString(self, n: int) -> str:\\n\\treturn \"a\" * n if n % 2 else \"a\" * (n - 1) + \"b\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 836918,
                "title": "java-0-ms-100-faster",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        int count = (n % 2 == 0) ? n - 1 : n;\\n        StringBuilder result  = new StringBuilder();\\n        \\n        for (int i = 0; i < count; i++){\\n            result.append(\\'a\\');\\n        }\\n        \\n        if( n % 2 == 0){\\n            result.append(\\'b\\');\\n        }\\n        return result.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n        int count = (n % 2 == 0) ? n - 1 : n;\\n        StringBuilder result  = new StringBuilder();\\n        \\n        for (int i = 0; i < count; i++){\\n            result.append(\\'a\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3459992,
                "title": "c-c-easy-and-fast-solution-beats-100-explained",
                "content": "# Intuition:First of all,we have to determine that the given number is odd or even.If the given number is odd,then we return a new string which contains only \\'a\\' n times.Otherwise we create a string with \\'a\\' n-1 times and one \\'b\\'.\\n![photo_2023-04-27_12-57-53.jpg](https://assets.leetcode.com/users/images/00387a28-78ff-4618-adf3-9064a3025da3_1682582431.708815.jpeg)\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```C++ []\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s(n-1, \\'a\\');\\n        s += n%2==0? \\'b\\':\\'a\\';\\n        return s;\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public string GenerateTheString(int n) {\\n       string s=s=new string(\\'a\\',n-1);\\n      s+=n%2==0? \\'b\\':\\'a\\';\\n      return s;\\n    }\\n}\\n```\\n![Vote.png](https://assets.leetcode.com/users/images/bac3988f-3b05-4f33-8058-c08600af7b9f_1682582443.352482.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s(n-1, \\'a\\');\\n        s += n%2==0? \\'b\\':\\'a\\';\\n        return s;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public string GenerateTheString(int n) {\\n       string s=s=new string(\\'a\\',n-1);\\n      s+=n%2==0? \\'b\\':\\'a\\';\\n      return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068473,
                "title": "java-clean-solution-100-speed-and-memory",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        var result = new char[n];\\n        Arrays.fill(result, \\'a\\');       \\n        if (n % 2 == 0) result[0] = \\'b\\';\\n        return new String(result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        var result = new char[n];\\n        Arrays.fill(result, \\'a\\');       \\n        if (n % 2 == 0) result[0] = \\'b\\';\\n        return new String(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782613,
                "title": "c-simplest-shortest-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res = \"\";\\n        if (n%2 == 0)\\n        {\\n            res += \\'b\\';\\n            n-=1;\\n        }\\n        for (int i=0;i < n;i++)\\n            res += \\'a\\';\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res = \"\";\\n        if (n%2 == 0)\\n        {\\n            res += \\'b\\';\\n            n-=1;\\n        }\\n        for (int i=0;i < n;i++)\\n            res += \\'a\\';\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532633,
                "title": "simple-javascript-o-n",
                "content": "if n is odd, every letter has to be an \\'a\\', else the last one is \\'b\\'\\n```\\nvar generateTheString = function(n) {\\n    let res=Array(n).fill(\\'a\\')\\n    if(!(n&1))\\n        res[n-1]=\\'b\\'\\n    return res.join(\\'\\')\\n};\\n```\\n**Complexity**\\nTime: O(n),  Space: O(n)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateTheString = function(n) {\\n    let res=Array(n).fill(\\'a\\')\\n    if(!(n&1))\\n        res[n-1]=\\'b\\'\\n    return res.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3069560,
                "title": "c-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n         string ans=\"\";\\n         if(n%2==0)\\n         {\\n             for(int i=0;i<n-1;i++)\\n             {\\n                   ans=ans+\\'x\\';\\n             }\\n             ans=ans+\\'y\\';\\n         }\\n         else\\n         {\\n             for(int i=0;i<n;i++)\\n             {\\n                 ans=ans+\\'x\\';\\n             }\\n         }\\n         return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n         string ans=\"\";\\n         if(n%2==0)\\n         {\\n             for(int i=0;i<n-1;i++)\\n             {\\n                   ans=ans+\\'x\\';\\n             }\\n             ans=ans+\\'y\\';\\n         }\\n         else\\n         {\\n             for(int i=0;i<n;i++)\\n             {\\n                 ans=ans+\\'x\\';\\n             }\\n         }\\n         return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945878,
                "title": "java-one-liner",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return \"baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\".substring(n%2,n+n%2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return \"baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\".substring(n%2,n+n%2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841084,
                "title": "3approaches-runtime-0ms-faster-than-100-00-eay-understanding-c",
                "content": "```\\n//1.\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string str=\"\";\\n        if(n%2==0){\\n            str.append(1,\\'a\\');\\n            str.append(n-1,\\'b\\');\\n        }\\n        else{\\n            str.append(n,\\'a\\');\\n        }\\n        return str;\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        int count = (n % 2 == 0) ? n - 1 : n;\\n        string result=\"\";\\n        \\n        for (int i = 0; i < count; i++){\\n            result+=\\'a\\';\\n        }\\n        \\n        if( n % 2 == 0){\\n            result+=\\'b\\';\\n        }\\n        return result;\\n    }\\n};\\n//3.\\nclass Solution {\\npublic:\\n        string generateTheString(int n) {\\n        return (n & 1) ? string(n, \\'a\\') : string(n - 1, \\'a\\') + string(1, \\'b\\');\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//1.\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string str=\"\";\\n        if(n%2==0){\\n            str.append(1,\\'a\\');\\n            str.append(n-1,\\'b\\');\\n        }\\n        else{\\n            str.append(n,\\'a\\');\\n        }\\n        return str;\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        int count = (n % 2 == 0) ? n - 1 : n;\\n        string result=\"\";\\n        \\n        for (int i = 0; i < count; i++){\\n            result+=\\'a\\';\\n        }\\n        \\n        if( n % 2 == 0){\\n            result+=\\'b\\';\\n        }\\n        return result;\\n    }\\n};\\n//3.\\nclass Solution {\\npublic:\\n        string generateTheString(int n) {\\n        return (n & 1) ? string(n, \\'a\\') : string(n - 1, \\'a\\') + string(1, \\'b\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533785,
                "title": "javascript-solution",
                "content": "```\\nlet generateTheString = function(n) {\\n    return n % 2 === 0 ? \\'a\\'.repeat(n - 1) + \\'b\\' : \\'a\\'.repeat(n)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet generateTheString = function(n) {\\n    return n % 2 === 0 ? \\'a\\'.repeat(n - 1) + \\'b\\' : \\'a\\'.repeat(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532477,
                "title": "java-straightforward",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        if(n % 2 == 0) {\\n            for(int i = 0; i < n - 1; i++) sb.append(\\'a\\');\\n            sb.append(\\'b\\');\\n        } else {\\n            for(int i = 0; i < n; i++) sb.append(\\'a\\');\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        if(n % 2 == 0) {\\n            for(int i = 0; i < n - 1; i++) sb.append(\\'a\\');\\n            sb.append(\\'b\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1127849,
                "title": "simple-python-solution-faster-than-99-83",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 != 0:\\n            return \\'x\\'*n\\n        return (\\'x\\'*(n-1)) + \\'y\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 != 0:\\n            return \\'x\\'*n\\n        return (\\'x\\'*(n-1)) + \\'y\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620263,
                "title": "js-simple-solution-one-liner",
                "content": "Runtime: 48 ms, faster than 94.64%\\n\\n```\\nvar generateTheString = function(n) {\\n     \\n  return  n & 1  ? Array(n).fill(\\'a\\').join(\\'\\') : Array(n-1).fill(\\'a\\').join(\\'\\')  + \\'b\\';\\n   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateTheString = function(n) {\\n     \\n  return  n & 1  ? Array(n).fill(\\'a\\').join(\\'\\') : Array(n-1).fill(\\'a\\').join(\\'\\')  + \\'b\\';\\n   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 549921,
                "title": "100-100-super-easy-python3",
                "content": "```\\n        if n%2!=0: return \\'a\\'*n \\n        else: return \"a\"*(n-1)+\\'b\\'\\n```\\n\\nHaha, don\\'t facepalm :P",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        if n%2!=0: return \\'a\\'*n \\n        else: return \"a\"*(n-1)+\\'b\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2739948,
                "title": "c-easy-explained",
                "content": "#### 1. If n is Odd\\n#####          simply add a charecter n times in ans String\\n#### 2. If n is even\\n#####            add a charecter n-1 times and add another charecter 1 time in ans string\\n#### 3. Return ans String\\n\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";\\n        if(n%2==1)\\n        {\\n            for(int i=0;i<n;i++)\\n                ans+=\\'t\\';\\n        }\\n        else\\n        {\\n            for(int i=0;i<n-1;i++)\\n                ans+=\\'p\\';\\n            ans+=\\'t\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";\\n        if(n%2==1)\\n        {\\n            for(int i=0;i<n;i++)\\n                ans+=\\'t\\';\\n        }\\n        else\\n        {\\n            for(int i=0;i<n-1;i++)\\n                ans+=\\'p\\';\\n            ans+=\\'t\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685407,
                "title": "js-one-line-solution",
                "content": "```\\nvar generateTheString = function(n) {\\n    return n%2 ? new Array(n).fill(\\'a\\').join(\\'\\') : new Array(n - 1).fill(\\'a\\').join(\\'\\') + \\'b\\';\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateTheString = function(n) {\\n    return n%2 ? new Array(n).fill(\\'a\\').join(\\'\\') : new Array(n - 1).fill(\\'a\\').join(\\'\\') + \\'b\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1463808,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        if (n%2 == 0){\\n            sb.append(\"a\".repeat(Math.max(0,n-1)));\\n            sb.append(\"b\");\\n        }\\n        else{\\n            sb.append(\"a\".repeat(Math.max(0, n)));\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        if (n%2 == 0){\\n            sb.append(\"a\".repeat(Math.max(0,n-1)));\\n            sb.append(\"b\");\\n        }\\n        else{\\n            sb.append(\"a\".repeat(Math.max(0, n)));\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336105,
                "title": "java-solution-in-2-lines",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        String s = \"a\".repeat(n-1);\\n        return n % 2 == 0 ? s + \"b\" : s + \"a\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        String s = \"a\".repeat(n-1);\\n        return n % 2 == 0 ? s + \"b\" : s + \"a\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250676,
                "title": "simplest-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n)\\n    {\\n        string ans;\\n        if(n%2 == 0)\\n        {\\n            ans = \"a\";\\n            n--;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans += \"b\";\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If you like the solution? Please upvote.....**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n)\\n    {\\n        string ans;\\n        if(n%2 == 0)\\n        {\\n            ans = \"a\";\\n            n--;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans += \"b\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808501,
                "title": "cpp-faster-than-100-easy",
                "content": "A very simple approach, we check first if the number is either odd or even. If the number is odd, we simply loop n times and add \\'a\\' to the result string, else if the number n is even we subtract 1 to convert it into odd number and add a single character \\'b\\', and run the same loop to make the length of the result even.\\n\\n```\\n\\tConsider the following test case :-\\n\\t\\tn = 28;\\n\\t\\t\\t\\n\\t\\t\\t1. n%2 == 0, n = 27, s = \"b\";\\n\\t\\t\\t2. n = 27, s = \"ba\"\\n\\t\\t\\t3. n = 26, s = \"baa\"\\n\\t\\t\\t4. n = 25, s = \"baaa\".............\\n\\n\\t\\t\\ts = \"baaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\t\\t\\t\\n\\t\\t\\ts is returned.\\n\\t\\n```\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s {};\\n        if(n%2 == 0){\\n            n -= 1;\\n            s += \\'b\\';\\n        }\\n\\t\\twhile(n--){\\n                s += \\'a\\';\\n            }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tConsider the following test case :-\\n\\t\\tn = 28;\\n\\t\\t\\t\\n\\t\\t\\t1. n%2 == 0, n = 27, s = \"b\";\\n\\t\\t\\t2. n = 27, s = \"ba\"\\n\\t\\t\\t3. n = 26, s = \"baa\"\\n\\t\\t\\t4. n = 25, s = \"baaa\".............\\n\\n\\t\\t\\ts = \"baaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\t\\t\\t\\n\\t\\t\\ts is returned.\\n\\t\\n```\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s {};\\n        if(n%2 == 0){\\n            n -= 1;\\n            s += \\'b\\';\\n        }\\n\\t\\twhile(n--){\\n                s += \\'a\\';\\n            }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740108,
                "title": "python3-one-liner",
                "content": "The code is self-explanatory. \\n```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return (\"a\" * (n-1) + \"b\" if n%2 == 0 else \"b\" * n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return (\"a\" * (n-1) + \"b\" if n%2 == 0 else \"b\" * n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695361,
                "title": "faster-than-100-in-c-3-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n     string s(n,\\'a\\');\\n\\n        if(n%2==0)s[n-1]=\\'b\\';\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n     string s(n,\\'a\\');\\n\\n        if(n%2==0)s[n-1]=\\'b\\';\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532654,
                "title": "c-python3-construct-the-solution",
                "content": "Given an integer `n`, return a string of length `n` so that each character in the string occurs odd number of times.\\n\\n# Explanation\\n\\nJust consider two cases: `n % 2 = 0` and `n % 2 = 1`.\\n\\nIf `n % 2 = 0`, return 1 \"a\" and `n-1` \"b\"s.\\n\\nIf `n % 2 = 1`, return `n` \"a\"s.\\n\\n# C++ Solution\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans;\\n        if (n % 2 == 1) {\\n            for (int i = 0; i < n; i++)\\n                ans += \"a\";\\n        }\\n        else {\\n            ans += \"a\";\\n            for (int i = 1; i < n; i++)\\n                ans += \"b\";\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python3 Solution\\n\\n```python\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 == 1:\\n            return \"a\" * n\\n        else:\\n            return \"a\" + \"b\" * (n - 1)\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans;\\n        if (n % 2 == 1) {\\n            for (int i = 0; i < n; i++)\\n                ans += \"a\";\\n        }\\n        else {\\n            ans += \"a\";\\n            for (int i = 1; i < n; i++)\\n                ans += \"b\";\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 == 1:\\n            return \"a\" * n\\n        else:\\n            return \"a\" + \"b\" * (n - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678044,
                "title": "1374-generate-a-string-with-characters-that-have-odd-counts-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        String str = \"\";\\n     if(n%2==0){\\n         for(int i=1; i<=n;i++){\\n             if(i<=n-1){\\n                 str+=\"p\";\\n             }\\n             else{\\n                 str+=\"d\";\\n             }\\n         }\\n     }\\n     else{\\n         for(int i=1; i<=n;i++){\\n             if(i==n){\\n                 str+=\"u\";\\n             }\\n             else if(i==1){\\n                 str+=\"o\";\\n             }\\n             else{\\n                 str+=\"y\";\\n             }\\n         }\\n     }\\n     return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        String str = \"\";\\n     if(n%2==0){\\n         for(int i=1; i<=n;i++){\\n             if(i<=n-1){\\n                 str+=\"p\";\\n             }\\n             else{\\n                 str+=\"d\";\\n             }\\n         }\\n     }\\n     else{\\n         for(int i=1; i<=n;i++){\\n             if(i==n){\\n                 str+=\"u\";\\n             }\\n             else if(i==1){\\n                 str+=\"o\";\\n             }\\n             else{\\n                 str+=\"y\";\\n             }\\n         }\\n     }\\n     return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241465,
                "title": "one-liner-python3",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        \\n        return \\'a\\' * n if n % 2 != 0 else \\'a\\' * (n-1) + \\'b\\'\\n\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        \\n        return \\'a\\' * n if n % 2 != 0 else \\'a\\' * (n-1) + \\'b\\'\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857987,
                "title": "python-easy-94-60-faster-one-line-solution",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \\'a\\'*(n-1)+\\'b\\' if n%2==0 else \\'a\\'*n\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \\'a\\'*(n-1)+\\'b\\' if n%2==0 else \\'a\\'*n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857829,
                "title": "beats-99-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 == 0:\\n            return \"x\" * (n - 1) + \"y\"\\n        else:\\n            return \"x\" * n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 == 0:\\n            return \"x\" * (n - 1) + \"y\"\\n        else:\\n            return \"x\" * n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622490,
                "title": "python-o-1",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n == 1:\\n            return \\'a\\'\\n        elif n%2==0:\\n            return(\\'a\\' + \\'b\\'*(n-1))\\n        else:\\n            return(\\'ab\\' + \\'c\\'*(n-2))\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n == 1:\\n            return \\'a\\'\\n        elif n%2==0:\\n            return(\\'a\\' + \\'b\\'*(n-1))\\n        else:\\n            return(\\'ab\\' + \\'c\\'*(n-2))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839523,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans;\\n        if(n&1){\\n            ans.append(n,\\'a\\');\\n        }\\n        else{\\n            ans.append(1,\\'a\\');\\n            ans.append(n-1,\\'b\\');\\n           \\n        }\\n        return ans;\\n    }\\n};\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans;\\n        if(n&1){\\n            ans.append(n,\\'a\\');\\n        }\\n        else{\\n            ans.append(1,\\'a\\');\\n            ans.append(n-1,\\'b\\');\\n           \\n        }\\n        return ans;\\n    }\\n};\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759755,
                "title": "java-1-liner-explained",
                "content": "**Idea:** If n is odd return any letter repeated n times, else return any letter repeated n - 1 (odd) times and append a different letter 1 time (odd)\\n>**T/S:** O(n)/O(n)\\n```\\npublic String generateTheString(int n) {\\n\\treturn \"a\".repeat(n - 1) + (char) (\\'b\\' - (n & 1));\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String generateTheString(int n) {\\n\\treturn \"a\".repeat(n - 1) + (char) (\\'b\\' - (n & 1));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1548114,
                "title": "go-time-o-n-0-ms-100-space-o-1-2-2-mb-100",
                "content": "```\\nfunc generateTheString(n int) string {\\n    return \"b\" + strings.Repeat(string(\\'a\\' + n % 2), n - 1)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc generateTheString(n int) string {\\n    return \"b\" + strings.Repeat(string(\\'a\\' + n % 2), n - 1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1442777,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar generateTheString = function (n) {\\n  const letterA = \"a\";\\n  const letterB = \"b\";\\n\\n  if (n % 2 !== 0) {\\n    return letterA.repeat(n);\\n  }\\n\\n  return letterA.repeat(n - 1) + letterB;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar generateTheString = function (n) {\\n  const letterA = \"a\";\\n  const letterB = \"b\";\\n\\n  if (n % 2 !== 0) {\\n    return letterA.repeat(n);\\n  }\\n\\n  return letterA.repeat(n - 1) + letterB;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1383113,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public String generateTheString(int n) {\\n        if(n%2==1)\\n        {\\n            String a=\"\";\\n            int i;\\n            for(i=1,a=\"\";i<=n;i++,a=a+\"a\");\\n            return a;\\n        }\\n        else\\n        {\\n            String a=\"\";\\n            int i;\\n            for(i=1,a=\"\";i<n;i++,a=a+\"a\");\\n            a=a+\"b\";\\n            return a;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public String generateTheString(int n) {\\n        if(n%2==1)\\n        {\\n            String a=\"\";\\n            int i;\\n            for(i=1,a=\"\";i<=n;i++,a=a+\"a\");\\n            return a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1232027,
                "title": "easy-code-in-python-with-explanation",
                "content": "* here if n%2==0 i.e. if n is even we return a string with n-1 number of a and 1 b\\n* else we return n that is odd number of a.\\n* if you like it please vote so it can reach other pepoles too\\n\\n```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        a=\"a\"\\n        b=\"b\"\\n        if n%2==0:\\n            return (((n-1)*a)+b)\\n        return (n*a)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        a=\"a\"\\n        b=\"b\"\\n        if n%2==0:\\n            return (((n-1)*a)+b)\\n        return (n*a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070127,
                "title": "java-stringbuilder-beats-100-0ms-o-n",
                "content": "\\n    public String generateTheString(int n) {\\n       StringBuilder sb = new StringBuilder();\\n\\t\\tif (n % 2 != 0) {\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tsb.append(\\'a\\');\\n\\t\\t} else {\\n\\t\\t\\tfor (int i = 0; i < n - 1; i++)\\n\\t\\t\\t\\tsb.append(\\'a\\');\\n\\t\\t\\tsb.append(\\'b\\');\\n\\t\\t}\\n\\t\\treturn sb.toString(); \\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public String generateTheString(int n) {\\n       StringBuilder sb = new StringBuilder();\\n\\t\\tif (n % 2 != 0) {\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tsb.append(\\'a\\');\\n\\t\\t} else {\\n\\t\\t\\tfor (int i = 0; i < n - 1; i++)\\n\\t\\t\\t\\tsb.append(\\'a\\');\\n\\t\\t\\tsb.append(\\'b\\');\\n\\t\\t}\\n\\t\\treturn sb.toString(); \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 985739,
                "title": "0-ms-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        if(n%2!=0)\\n        {\\n            string res(n,\\'a\\');\\n            return res;\\n        }\\n        string res(n-1,\\'a\\');\\n        res+=\\'r\\';\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        if(n%2!=0)\\n        {\\n            string res(n,\\'a\\');\\n            return res;\\n        }\\n        string res(n-1,\\'a\\');\\n        res+=\\'r\\';\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923659,
                "title": "javascript-one-liner-solution",
                "content": "```js\\nvar generateTheString = function(n) {\\n    return (n%2 == 0)? \\'a\\'.repeat(n-1)+\\'b\\' : \\'a\\'.repeat(n)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar generateTheString = function(n) {\\n    return (n%2 == 0)? \\'a\\'.repeat(n-1)+\\'b\\' : \\'a\\'.repeat(n)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 915849,
                "title": "python-one-liner-lol",
                "content": "\\n        \\n        return \"a\"*(n-1)+\"b\" if n % 2 == 0 else \"a\"*n \\n",
                "solutionTags": [],
                "code": "\\n        \\n        return \"a\"*(n-1)+\"b\" if n % 2 == 0 else \"a\"*n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 859713,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public String generateTheString(int n) {\\n        \\n       StringBuilder res = new StringBuilder();\\n        \\n        for(int i=0; i<n-1; i++)\\n            res.append(\"a\");\\n        if(n%2 == 0)\\n            res.append(\"b\");\\n        else\\n            res.append(\"a\");\\n        \\n        return res.toString();\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n        \\n       StringBuilder res = new StringBuilder();\\n        \\n        for(int i=0; i<n-1; i++)\\n            res.append(\"a\");\\n        if(n%2 == 0)\\n            res.append(\"b\");\\n        else\\n            res.append(\"a\");\\n        \\n        return res.toString();\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 546878,
                "title": "javascript-easy-solution",
                "content": "```\\nvar generateTheString = function(n) {\\n    let result = \\'a\\'.repeat(n-1); // push \\'a\\' n-1 times\\n    return (n % 2 === 0) ? result + \\'b\\'  : result + \\'a\\';\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateTheString = function(n) {\\n    let result = \\'a\\'.repeat(n-1); // push \\'a\\' n-1 times\\n    return (n % 2 === 0) ? result + \\'b\\'  : result + \\'a\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 534890,
                "title": "with-explaination-c-greedy-solution-easiest-solution-beats-100-in-both-memory-and-time",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string generateTheString(int n) \\n    {\\n         string s=\"abcdefghijklmnopqrstuvwxyz\";\\n        if(n<26)\\n          return s.substr(0,n);\\n   \\n         string res=\"\";\\n        if(n%2!=0)\\n        {\\n           for(int i=0;i<n;i++)\\n                  res+=\\'a\\';  \\n        }\\n        else\\n        {\\n            for(int i=0;i<(n-1);i++)\\n                  res+=\\'a\\';\\n            res+=\\'b\\';\\n        }\\n        return res;\\n    }\\n};\\n```\\nsimply see if n is odd then return string with only character a\\nif n is even then n-1 times a and 1 time b\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string generateTheString(int n) \\n    {\\n         string s=\"abcdefghijklmnopqrstuvwxyz\";\\n        if(n<26)\\n          return s.substr(0,n);\\n   \\n         string res=\"\";\\n        if(n%2!=0)\\n        {\\n           for(int i=0;i<n;i++)\\n                  res+=\\'a\\';  \\n        }\\n        else\\n        {\\n            for(int i=0;i<(n-1);i++)\\n                  res+=\\'a\\';\\n            res+=\\'b\\';\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532525,
                "title": "c-simple-strings",
                "content": "Straight forward approach\\nIf `n` is odd, we can directly return a string of all `a`. Otherwise just create `n` length string containing `n-1` `a`\\'s and one `b`.\\n\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        \\n        if(n % 2 == 1)\\n            return string(n, \\'a\\');\\n        string s = string(n - 1, \\'a\\');\\n        s.push_back(\\'b\\');\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        \\n        if(n % 2 == 1)\\n            return string(n, \\'a\\');\\n        string s = string(n - 1, \\'a\\');\\n        s.push_back(\\'b\\');\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874901,
                "title": "simple-code-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        res = \"\"\\n        if n%2 != 0:\\n            return \"a\"*n\\n        res = \"a\"*(n-1)\\n        return res+\"b\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        res = \"\"\\n        if n%2 != 0:\\n            return \"a\"*n\\n        res = \"a\"*(n-1)\\n        return res+\"b\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745207,
                "title": "easy-and-simple-solution-in-c-beats-100-runtime",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";\\n        if (n%2!=0)\\n        {\\n            for (int i=0; i<n; i++) ans+=\\'a\\';\\n        }\\n        else\\n        {\\n            for (int i=0; i<n-1; i++) ans+=\\'a\\';\\n            ans+=\\'b\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";\\n        if (n%2!=0)\\n        {\\n            for (int i=0; i<n; i++) ans+=\\'a\\';\\n        }\\n        else\\n        {\\n            for (int i=0; i<n-1; i++) ans+=\\'a\\';\\n            ans+=\\'b\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745191,
                "title": "easy-solution-in-c-0ms-runtime",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";\\n        if (n%2!=0)\\n        {\\n            for (int i=0; i<n; i++) ans+=\\'a\\';\\n        }\\n        else\\n        {\\n            for (int i=0; i<n-1; i++) ans+=\\'a\\';\\n            ans+=\\'b\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";\\n        if (n%2!=0)\\n        {\\n            for (int i=0; i<n; i++) ans+=\\'a\\';\\n        }\\n        else\\n        {\\n            for (int i=0; i<n-1; i++) ans+=\\'a\\';\\n            ans+=\\'b\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460316,
                "title": "go-and-javasctipt-one-line-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Go\\n```\\nfunc generateTheString(n int) string {\\n    s := strings.Repeat(\"a\", n-1)\\n    if n%2 == 0 {\\n        s += \"b\"\\n    } else {\\n        s += \"a\"\\n    }\\n    return s\\n}\\n\\n```\\n## Javascript\\n```\\nfunction generateTheString(n) {\\n  return \\'a\\'.repeat(n - 1) + (n % 2 ? \\'a\\' : \\'b\\');\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nfunc generateTheString(n int) string {\\n    s := strings.Repeat(\"a\", n-1)\\n    if n%2 == 0 {\\n        s += \"b\"\\n    } else {\\n        s += \"a\"\\n    }\\n    return s\\n}\\n\\n```\n```\\nfunction generateTheString(n) {\\n  return \\'a\\'.repeat(n - 1) + (n % 2 ? \\'a\\' : \\'b\\');\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3295968,
                "title": "beats-100",
                "content": "\\n# Code\\n```\\n\\nclass Solution\\n{\\n    public String generateTheString(int n)\\n    {\\n        StringBuilder s=new StringBuilder();\\n        if(n%2==0)\\n        {\\n            s.append(\"a\".repeat(n-1));\\n            s.append(\"d\");\\n        }\\n        else\\n        {\\n            s.append(\"a\".repeat(n));\\n        }\\n        return s.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution\\n{\\n    public String generateTheString(int n)\\n    {\\n        StringBuilder s=new StringBuilder();\\n        if(n%2==0)\\n        {\\n            s.append(\"a\".repeat(n-1));\\n            s.append(\"d\");\\n        }\\n        else\\n        {\\n            s.append(\"a\".repeat(n));\\n        }\\n        return s.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153642,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string result(n, \\'a\\');\\n        if (n % 2 == 0) result[0] = \\'b\\';\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string result(n, \\'a\\');\\n        if (n % 2 == 0) result[0] = \\'b\\';\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929560,
                "title": "fastest-c-solution",
                "content": "# Approach\\n**If n is odd, return a string of size n formed only by \\'a\\', else return string formed with (n-1) \\'a\\' and 1 \\'b\\'.**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n\\n       //declared an empty string ans \\n       string ans = \"\";\\n\\n       //FOR ODD LENGTH STRING\\n       if(n%2!=0) {\\n           while(n--){\\n               //return a string of size n formed only by \\'a\\'\\n               ans+=\\'a\\';\\n           }\\n       } \\n       //FOR EVEN LENGTH STRING\\n       else{\\n           int m=n-1;\\n           while(m--){\\n               //string formed with (n-1) \\'a\\'\\n               ans+=\\'a\\';\\n           }\\n           // string formed with  1 \\'b\\'\\n           ans+=\\'b\\';\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n\\n       //declared an empty string ans \\n       string ans = \"\";\\n\\n       //FOR ODD LENGTH STRING\\n       if(n%2!=0) {\\n           while(n--){\\n               //return a string of size n formed only by \\'a\\'\\n               ans+=\\'a\\';\\n           }\\n       } \\n       //FOR EVEN LENGTH STRING\\n       else{\\n           int m=n-1;\\n           while(m--){\\n               //string formed with (n-1) \\'a\\'\\n               ans+=\\'a\\';\\n           }\\n           // string formed with  1 \\'b\\'\\n           ans+=\\'b\\';\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924572,
                "title": "generate-a-string-with-characters-that-have-odd-counts-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuffer sb = new StringBuffer();\\n        if (n % 2 == 0) {\\n            sb.append(\\'a\\');\\n            for (int i = 1; i < n; i++)\\n                sb.append(\\'b\\');\\n        } else {\\n            for (int i = 0; i < n; i++)\\n                sb.append(\\'a\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuffer sb = new StringBuffer();\\n        if (n % 2 == 0) {\\n            sb.append(\\'a\\');\\n            for (int i = 1; i < n; i++)\\n                sb.append(\\'b\\');\\n        } else {\\n            for (int i = 0; i < n; i++)\\n                sb.append(\\'a\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919295,
                "title": "0ms-fastest-solution-for-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        \\nStringBuilder s = new StringBuilder();\\n\\n    if(n%2==0){\\n        s.append(\"t\".repeat(n-1));\\n        s.append(\"e\");\\n}else{\\n        s.append(\"t\".repeat(n));\\n}\\n\\nreturn s.toString();\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        \\nStringBuilder s = new StringBuilder();\\n\\n    if(n%2==0){\\n        s.append(\"t\".repeat(n-1));\\n        s.append(\"e\");\\n}else{\\n        s.append(\"t\".repeat(n));\\n}\\n\\nreturn s.toString();\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919294,
                "title": "beats-100-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder res=new StringBuilder();\\n        if(n%2==1) {\\n            res.append(\"a\".repeat(n));\\n        }\\n        else {\\n            res.append(\"a\".repeat(n-1));\\n            res.append(\\'b\\');\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder res=new StringBuilder();\\n        if(n%2==1) {\\n            res.append(\"a\".repeat(n));\\n        }\\n        else {\\n            res.append(\"a\".repeat(n-1));\\n            res.append(\\'b\\');\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867224,
                "title": "q1374-accepted-c-sol-o-n-100-fastest-easy-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2==1){\\n            while(n--){\\n                s+=\\'a\\';\\n            }\\n        }\\n        else{\\n            while(n--){\\n                if(n==0){\\n                    s+=\\'b\\';\\n                    break;\\n                }\\n                s+=\\'a\\';\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2==1){\\n            while(n--){\\n                s+=\\'a\\';\\n            }\\n        }\\n        else{\\n            while(n--){\\n                if(n==0){\\n                    s+=\\'b\\';\\n                    break;\\n                }\\n                s+=\\'a\\';\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792594,
                "title": "java-understandable-solution",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        String s=\"\";\\n        if(n%2!=0){\\n            for(int i=0;i<n;i++){\\n                s=s+\\'a\\';\\n            }\\n            return s;\\n        }\\n        \\n        for(int i=0;i<n-1;i++){\\n            s=s+\\'x\\';\\n        }\\n        int x=n-s.length();\\n        for(int i=0;i<x;i++){\\n            s=s+\\'y\\';\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        String s=\"\";\\n        if(n%2!=0){\\n            for(int i=0;i<n;i++){\\n                s=s+\\'a\\';\\n            }\\n            return s;\\n        }\\n        \\n        for(int i=0;i<n-1;i++){\\n            s=s+\\'x\\';\\n        }\\n        int x=n-s.length();\\n        for(int i=0;i<x;i++){\\n            s=s+\\'y\\';\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685448,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] arr = new char[n];\\n        Arrays.fill(arr, \\'a\\');\\n        if(n % 2 == 1) return String.valueOf(arr);\\n        \\n        int oddN = n - 1;\\n        for(int i = 0; i < oddN; i++){\\n            arr[i] = \\'b\\';\\n        }\\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] arr = new char[n];\\n        Arrays.fill(arr, \\'a\\');\\n        if(n % 2 == 1) return String.valueOf(arr);\\n        \\n        int oddN = n - 1;\\n        for(int i = 0; i < oddN; i++){\\n            arr[i] = \\'b\\';\\n        }\\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654837,
                "title": "java-simple-easy-solution",
                "content": "class Solution {\\n    public String generateTheString(int n) {\\n     String str=\"\";\\n      if(n%2==0){\\n          for(int i=0;i<n-1;i++)\\n            str+=\\'a\\';\\n          str+=\\'b\\';\\n      }\\n    else{\\n        for(int i=0;i<n;i++)\\n            str+=\\'a\\';\\n    }\\n        return str;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n     String str=\"\";\\n      if(n%2==0){\\n          for(int i=0;i<n-1;i++)\\n            str+=\\'a\\';\\n          str+=\\'b\\';\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2654828,
                "title": "java-simple-fast-easy-solution",
                "content": "class Solution {\\n    public String generateTheString(int n) {\\n    if(n%2==0)\\n    {\\n        String str=\"\";\\n        for(int i=0;i<n-1;i++){\\n            str=str+\\'a\\';\\n        }\\n        str=str+\\'b\\';\\n        return str;\\n    }\\n        else\\n        {\\n            \\n            String str=\"\";\\n        for(int i=0;i<n;i++){\\n            str=str+\\'a\\';\\n        }\\n       \\n        return str;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n    if(n%2==0)\\n    {\\n        String str=\"\";\\n        for(int i=0;i<n-1;i++){\\n            str=str+\\'a\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2608250,
                "title": "c-beginner-friendly-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string k=\"\";\\n        if(n%2==0)\\n        {\\n            for(int i=0;i<n-1;i++)\\n               k+=\\'p\\';\\n            k+=\\'z\\';\\n        }\\n        else{\\n            for(int i=0;i<n;i++)\\n                k+=\\'p\\';\\n        }\\n        return k;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string k=\"\";\\n        if(n%2==0)\\n        {\\n            for(int i=0;i<n-1;i++)\\n               k+=\\'p\\';\\n            k+=\\'z\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2570913,
                "title": "java-simple-fast-easy-solution-with-explanation",
                "content": "Only 2 possiblities are there, i.e n can be odd or even. \\nIf n is Odd, then we can return odd number of same characters ex:- aaa .\\nIf n is even, then we can send odd numbers of two characters, ex:-  aaa + b\\n\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n       \\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(n%2==0){\\n            for(int i=1;i<=n-1;i++){\\n                sb.append(\"a\");\\n            }\\n            sb.append(\"b\");\\n        }else{\\n            for(int i=1;i<=n;i++){\\n                sb.append(\"a\");\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n       \\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(n%2==0){\\n            for(int i=1;i<=n-1;i++){\\n                sb.append(\"a\");\\n            }\\n            sb.append(\"b\");\\n        }else{\\n            for(int i=1;i<=n;i++){\\n                sb.append(\"a\");\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453638,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n\\n    string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2!=0){\\n            for(int i=0;i<n;i++)\\n                s+=\"a\";\\n        }\\n        else{\\n            for(int i=0;i<n-1;i++)\\n                s+=\"a\";\\n               s+=\"b\";\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2!=0){\\n            for(int i=0;i<n;i++)\\n                s+=\"a\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2410683,
                "title": "100-fast-simple-o-n-optimal-solution",
                "content": "Algorithm:\\n1. Checked if n is odd or even.\\n2. If n is odd, pushed same character to string n times. if it is even, push same character to string (n-1) times and another character 1 time.\\n3. Returned the final string as result. \\n\\nTime Complexity: O(n)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s;\\n        int i=0;\\n        if (n%2==0) {\\n            while(i<n-1) {\\n                s.push_back(\\'h\\');\\n                i++;\\n            }\\n            s.push_back(\\'d\\');\\n        } else {\\n            while(i<n) {\\n                s.push_back(\\'h\\');\\n                i++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s;\\n        int i=0;\\n        if (n%2==0) {\\n            while(i<n-1) {\\n                s.push_back(\\'h\\');\\n                i++;\\n            }\\n            s.push_back(\\'d\\');\\n        } else {\\n            while(i<n) {\\n                s.push_back(\\'h\\');\\n                i++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359198,
                "title": "typescript-javascript-returning-one-or-two-character-based-string",
                "content": "When `n` is odd you can just return a string of length `n` filled with any one specific character (e.g. `aaa`, `aaaaa`, `aaaaaaa` etc.). When `n` is even you can return `n - 1` of `a`s and add another arbitrary letter, say, `b`.\\n`97` is the code of `a`, `98` is the code of `b`.\\n`new Array(10).fill(11)` creates a 10-element array all filled with `11`s.\\n```\\nfunction generateTheString(n: number): string {\\n  if (n % 2 === 1) {\\n    return String.fromCharCode(...new Array(n).fill(97));\\n  }\\n  \\n  return String.fromCharCode(...new Array(n - 1).fill(97), 98);\\n}\\n```\\nLet me know if you have any questions. Please hit upvote if you find it useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nfunction generateTheString(n: number): string {\\n  if (n % 2 === 1) {\\n    return String.fromCharCode(...new Array(n).fill(97));\\n  }\\n  \\n  return String.fromCharCode(...new Array(n - 1).fill(97), 98);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2336834,
                "title": "generate-a-string-with-characters-that-have-odd-counts",
                "content": "var generateTheString = function(n) {\\n    let str=\"\";\\n    for(let i=0;i<n-1;i++)\\n        str+=\"k\";\\n    return str+=(n%2==0)?\"n\":\"k\";    \\n};",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "var generateTheString = function(n) {\\n    let str=\"\";\\n    for(let i=0;i<n-1;i++)\\n        str+=\"k\";\\n    return str+=(n%2==0)?\"n\":\"k\";    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2327093,
                "title": "another-simple-solution-in-python",
                "content": "```\\ndef generateTheString(self, n: int) -> str:\\n\\ts = [\\'a\\'] * n      # generate a list of \\'a\\'s of length n\\n    if n % 2 == 0:     # if n is even\\n\\t\\ts[-1] = \\'b\\'    # replace the last element (\\'a\\') with \\'b\\', so count of \\'a\\' becomes odd and count of \\'b\\' is also odd\\n\\treturn \\'\\'.join(s)  # join chars and return\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\ndef generateTheString(self, n: int) -> str:\\n\\ts = [\\'a\\'] * n      # generate a list of \\'a\\'s of length n\\n    if n % 2 == 0:     # if n is even\\n\\t\\ts[-1] = \\'b\\'    # replace the last element (\\'a\\') with \\'b\\', so count of \\'a\\' becomes odd and count of \\'b\\' is also odd\\n\\treturn \\'\\'.join(s)  # join chars and return\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2278428,
                "title": "java-runtime-0-ms-faster-than-100-00",
                "content": "```\\n    public String generateTheString(int n) {\\n        if(n == 0) return \"\";\\n        if(n == 1) return \"a\";\\n        char[] charArray = new char[n];\\n        for(int i = 0; i < n; i++) charArray[i] = \\'a\\';\\n        if(n % 2 == 0) charArray[n-1] = \\'b\\';\\n        return new String(charArray);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n    public String generateTheString(int n) {\\n        if(n == 0) return \"\";\\n        if(n == 1) return \"a\";\\n        char[] charArray = new char[n];\\n        for(int i = 0; i < n; i++) charArray[i] = \\'a\\';\\n        if(n % 2 == 0) charArray[n-1] = \\'b\\';\\n        return new String(charArray);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2177099,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        _str = \"\"\\n        random_num = random.randrange(98,123)\\n        print(random_num)\\n        if n > 0:\\n            if n % 2 == 0:\\n                _str += (str(chr(97)) * (n -1)) + chr(random_num)\\n            else:\\n                _str += chr(random_num) * n\\n        return _str\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        _str = \"\"\\n        random_num = random.randrange(98,123)\\n        print(random_num)\\n        if n > 0:\\n            if n % 2 == 0:\\n                _str += (str(chr(97)) * (n -1)) + chr(random_num)\\n            else:\\n                _str += chr(random_num) * n\\n        return _str\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147125,
                "title": "easy-java-solution-beginner-friendly-o-n",
                "content": "***Please Upvote if You Liked The Solution.***\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb=new StringBuilder(\"\");\\n        if (n%2==0)\\n        {\\n            for (int i=0;i<n-1;i++){sb.append(\"p\");}\\n            sb.append(\\'z\\');\\n        }\\n        else{for (int i=0;i<n;i++){sb.append(\"p\");}}\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb=new StringBuilder(\"\");\\n        if (n%2==0)\\n        {\\n            for (int i=0;i<n-1;i++){sb.append(\"p\");}\\n            sb.append(\\'z\\');\\n        }\\n        else{for (int i=0;i<n;i++){sb.append(\"p\");}}\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136175,
                "title": "java-easy-apporach",
                "content": "This is the best solution\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder str=new StringBuilder(\"\");\\n        if(n%2==0)\\n        {\\n            for(int i=0;i<n-1;i++)\\n            {\\n                str.append(\"p\");\\n            }\\n            str.append(\"z\");\\n        }\\n        else\\n        {\\n           \\n            for(int i=0;i<n;i++)\\n            {\\n                str.append(\"a\");\\n            }\\n\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder str=new StringBuilder(\"\");\\n        if(n%2==0)\\n        {\\n            for(int i=0;i<n-1;i++)\\n            {\\n                str.append(\"p\");\\n            }\\n            str.append(\"z\");\\n        }\\n        else\\n        {\\n           \\n            for(int i=0;i<n;i++)\\n            {\\n                str.append(\"a\");\\n            }\\n\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088402,
                "title": "0ms-run-time-easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res = \"\";\\n        if(n%2 != 0) {while(n--) {res.push_back(\\'z\\');} return res;}\\n        while(n > 1) {res.push_back(\\'z\\');n--;}\\n        res.push_back(\\'y\\');\\n        return res;\\n        /*  here i select char z and y . apart from this you can select any random char */\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/a1e9da1c-37fc-4ffe-82eb-3d08cb314b02_1653845251.2235584.png)\\n\\n**Please Upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res = \"\";\\n        if(n%2 != 0) {while(n--) {res.push_back(\\'z\\');} return res;}\\n        while(n > 1) {res.push_back(\\'z\\');n--;}\\n        res.push_back(\\'y\\');\\n        return res;\\n        /*  here i select char z and y . apart from this you can select any random char */\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073384,
                "title": "java-solution-2-line",
                "content": "```java \\nclass Solution {\\n    public String generateTheString(int n) {\\n        String s=\"a\".repeat(n-1);\\n        return n%2==0? s+\\'b\\':s+\\'a\\';\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n        String s=\"a\".repeat(n-1);\\n        return n%2==0? s+\\'b\\':s+\\'a\\';\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2063004,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        int count = (n % 2 == 0) ? n - 1 : n;\\n        StringBuilder result  = new StringBuilder();\\n        \\n        for (int i = 0; i < count; i++) result.append(\\'a\\');\\n        \\n        if( n % 2 == 0) result.append(\\'b\\');\\n        \\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        int count = (n % 2 == 0) ? n - 1 : n;\\n        StringBuilder result  = new StringBuilder();\\n        \\n        for (int i = 0; i < count; i++) result.append(\\'a\\');\\n        \\n        if( n % 2 == 0) result.append(\\'b\\');\\n        \\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030162,
                "title": "python-solution",
                "content": "**Upvote** if you like solution and feel **free to ask** If you have any question.\\n```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 == 0:\\n            return (\\'a\\' * (n-1) + \\'b\\')\\n        else:\\n            return (\\'a\\' * n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 == 0:\\n            return (\\'a\\' * (n-1) + \\'b\\')\\n        else:\\n            return (\\'a\\' * n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959906,
                "title": "94-faster-easy-code",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2:\\n            return \\'a\\'*n\\n        else:\\n            return \\'a\\'*(n-1)+\\'b\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2:\\n            return \\'a\\'*n\\n        else:\\n            return \\'a\\'*(n-1)+\\'b\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945616,
                "title": "cpp-easy-to-understand",
                "content": "Feel Free To UpVote\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans = \"\";\\n        if(n&1){\\n            while(n){\\n                ans+=\\'a\\';\\n                n--;\\n            }\\n        }\\n        else{\\n            while(n>1){\\n                ans+=\\'a\\';\\n                n--;\\n            }\\n            ans+=\\'b\\';\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans = \"\";\\n        if(n&1){\\n            while(n){\\n                ans+=\\'a\\';\\n                n--;\\n            }\\n        }\\n        else{\\n            while(n>1){\\n                ans+=\\'a\\';\\n                n--;\\n            }\\n            ans+=\\'b\\';\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845157,
                "title": "easy-java",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder s=new StringBuilder();\\n        if(n%2==0){\\n            for(int i=0;i<n-1;i++){\\n                s.append(\"x\");\\n            }\\n            s.append(\"y\");\\n        }\\n        else{\\n            for(int i=0;i<=n-1;i++){\\n                s.append(\"x\");\\n            }\\n        }\\n        return s.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder s=new StringBuilder();\\n        if(n%2==0){\\n            for(int i=0;i<n-1;i++){\\n                s.append(\"x\");\\n            }\\n            s.append(\"y\");\\n        }\\n        else{\\n            for(int i=0;i<=n-1;i++){\\n                s.append(\"x\");\\n            }\\n        }\\n        return s.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833276,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n         if (n == 1) {\\n            return \"o\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        if (n % 2 == 0) {\\n            for (int i = 0; i < n - 1; i++) {\\n                sb.append(\"o\");\\n            }\\n            sb.append(\"h\");\\n        } else {\\n            for (int i = 0; i < n - 2; i++) {\\n                sb.append(\"o\");\\n            }\\n            sb.append(\"hc\");\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n         if (n == 1) {\\n            return \"o\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        if (n % 2 == 0) {\\n            for (int i = 0; i < n - 1; i++) {\\n                sb.append(\"o\");\\n            }\\n            sb.append(\"h\");\\n        } else {\\n            for (int i = 0; i < n - 2; i++) {\\n                sb.append(\"o\");\\n            }\\n            sb.append(\"hc\");\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819348,
                "title": "easy-one-liner-solution-with-comments",
                "content": "```\\n\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return n % 2 == 0 ? \"a\".repeat(n-1) + \"b\" : \"a\".repeat(n);\\n    }\\n}\\n//If \\'n\\' is even print \\'a\\' odd number of times i.e. (n-1) and print \\'b\\' once i.e. odd\\n//If \\'n\\' is odd just print any letter n times",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n        return n % 2 == 0 ? \"a\".repeat(n-1) + \"b\" : \"a\".repeat(n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1797988,
                "title": "python-3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\"*n if n%2 == 1 else \"a\"*(n-1)+\"b\"     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\"*n if n%2 == 1 else \"a\"*(n-1)+\"b\"     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765942,
                "title": "c-100-faster-beginner-friendly-easy-to-understand",
                "content": "**Please Upvote if you found this useful.**\\n\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) \\n    {\\n        string ans= \"\";\\n        if(n%2!= 0)\\n        {\\n            while(n--)\\n            {\\n                ans+= \\'a\\';\\n            }\\n        }\\n        else\\n        {\\n            while(n!=1)\\n            {\\n                ans+= \\'a\\';\\n                n--;\\n            }\\n            ans+= \\'b\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) \\n    {\\n        string ans= \"\";\\n        if(n%2!= 0)\\n        {\\n            while(n--)\\n            {\\n                ans+= \\'a\\';\\n            }\\n        }\\n        else\\n        {\\n            while(n!=1)\\n            {\\n                ans+= \\'a\\';\\n                n--;\\n            }\\n            ans+= \\'b\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655816,
                "title": "100-faster-0ms-simple-c-solution",
                "content": "Making use of string initialization \\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans(n, \\'a\\');\\n        if(!(n & 1)) ans[0] = \\'b\\';\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans(n, \\'a\\');\\n        if(!(n & 1)) ans[0] = \\'b\\';\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639207,
                "title": "python-simple-and-fast-95",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2==1:\\n            return \\'p\\'*n\\n        else:\\n            return \\'p\\'*(n-1)+\\'z\\'\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2==1:\\n            return \\'p\\'*n\\n        else:\\n            return \\'p\\'*(n-1)+\\'z\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567384,
                "title": "c-100-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string str=\"\";\\n        if(n%2==0){\\n            for(int i=0;i<n;i++){\\n                if(i==n-1)\\n                    str+=\\'b\\';\\n                else\\n                    str+=\\'a\\';\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n;i++){\\n                str+=\\'a\\';\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string str=\"\";\\n        if(n%2==0){\\n            for(int i=0;i<n;i++){\\n                if(i==n-1)\\n                    str+=\\'b\\';\\n                else\\n                    str+=\\'a\\';\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n;i++){\\n                str+=\\'a\\';\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563219,
                "title": "java-1ms-one-liner",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return n % 2 == 0 ? \"a\".repeat(n-1) + \"b\" : \"a\".repeat(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return n % 2 == 0 ? \"a\".repeat(n-1) + \"b\" : \"a\".repeat(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532538,
                "title": "python-easy-to-understand-code",
                "content": "```\\n    def generateTheString(self, n: int) -> str:\\n        if n==1:\\n            return \\'x\\'\\n        elif n%2==0:\\n            return \\'x\\'*(n-1)+\\'y\\'\\n        else:\\n            return \\'x\\'*(n-2)+\\'y\\'+\\'z\\'\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def generateTheString(self, n: int) -> str:\\n        if n==1:\\n            return \\'x\\'\\n        elif n%2==0:\\n            return \\'x\\'*(n-1)+\\'y\\'\\n        else:\\n            return \\'x\\'*(n-2)+\\'y\\'+\\'z\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1529546,
                "title": "java-easy-solution",
                "content": "# ******class Solution {\\n    public String generateTheString(int n) {\\n        if((n&1)==0){\\n            String temp=\"\";\\n            for(int i=0;i<n-1;i++)\\n                temp+=\\'a\\';\\n            temp+=\\'b\\';\\n            return temp;\\n        }\\n        else{\\n            String temp=\"\";\\n            for(int i=0;i<n;i++)\\n                temp+=\\'a\\';\\n            return temp;\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n        if((n&1)==0){\\n            String temp=\"\";\\n            for(int i=0;i<n-1;i++)\\n                temp+=\\'a\\';\\n            temp+=\\'b\\';\\n            return temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1366624,
                "title": "0-ms-faster-than-100-00-of-c-6-1-mb-less-than-68-33-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans;\\n        if(n % 2 == 0){\\n            for(int i=0;i<n-1;i++)\\n                ans+=\"a\";\\n            ans+=\"b\";\\n        }\\n        if(n % 2 != 0){\\n            for(int i=0;i<n;i++)\\n                ans+=\"a\";\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans;\\n        if(n % 2 == 0){\\n            for(int i=0;i<n-1;i++)\\n                ans+=\"a\";\\n            ans+=\"b\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1335545,
                "title": "simple-c-solution",
                "content": "```\\n    string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2==0){\\n            \\n            for(int i=0;i<n-1;i++){\\n                s+=\\'a\\';\\n            }\\n            s+=\\'b\\';\\n            \\n        }\\n        else{\\n            for(int i=0;i<=n-1;i++){\\n                s+=\\'a\\';\\n            } \\n        }\\n        \\n        return s;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2==0){\\n            \\n            for(int i=0;i<n-1;i++){\\n                s+=\\'a\\';\\n            }\\n            s+=\\'b\\';\\n            \\n        }\\n        else{\\n            for(int i=0;i<=n-1;i++){\\n                s+=\\'a\\';\\n            } \\n        }\\n        \\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332416,
                "title": "c-solution-100-faster-easy-to-read",
                "content": "```\\nchar * generateTheString(int n){\\n    char *result = (char *)malloc((n+1) * sizeof(char));\\n    if(n % 2 == 1)\\n        for(int i = 0; i < n; i++)\\n            result[i] = \\'a\\';\\n    else{\\n        for(int i = 0; i < n-1; i++)\\n            result[i] = \\'a\\';\\n        result[n-1] = \\'b\\';\\n    }\\n    \\n    result[n] = \\'\\\\0\\';\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * generateTheString(int n){\\n    char *result = (char *)malloc((n+1) * sizeof(char));\\n    if(n % 2 == 1)\\n        for(int i = 0; i < n; i++)\\n            result[i] = \\'a\\';\\n    else{\\n        for(int i = 0; i < n-1; i++)\\n            result[i] = \\'a\\';\\n        result[n-1] = \\'b\\';\\n    }\\n    \\n    result[n] = \\'\\\\0\\';\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1311738,
                "title": "python3-faster-than-88-one-liner",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\" * (n-1) + \"b\" if n % 2 == 0 else \"a\" * n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\" * (n-1) + \"b\" if n % 2 == 0 else \"a\" * n",
                "codeTag": "Java"
            },
            {
                "id": 1303409,
                "title": "java-simple-solution-runtime-0-ms",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions for Generate a String With Characters That Have Odd Counts.\\nMemory Usage: 36.3 MB, less than 71.11% of Java online submissions for Generate a String With Characters That Have Odd Counts.**\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] result = new char[n];\\n        Arrays.fill(result,\\'a\\');\\n        if(n%2 == 0)result[0] = \\'b\\';\\n        return new String(result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] result = new char[n];\\n        Arrays.fill(result,\\'a\\');\\n        if(n%2 == 0)result[0] = \\'b\\';\\n        return new String(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265288,
                "title": "python-solution-generate-a-string-with-characters-that-have-odd-counts",
                "content": "class Solution(object):\\n    \\n\\tdef generateTheString(self, n):\\n        if n%2==0:\\n            return \"a\"*(n-1)+\"b\"\\n        elif n%2!=0:\\n            return \"a\"*n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    \\n\\tdef generateTheString(self, n):\\n        if n%2==0:\\n            return \"a\"*(n-1)+\"b\"\\n        elif n%2!=0:\\n            return \"a\"*n",
                "codeTag": "Java"
            },
            {
                "id": 1219248,
                "title": "python3-one-liner-string",
                "content": "```\\nclass Solution:\\n     def generateTheString(self, n: int) -> str:\\n\\t\\t# we can use any of the 2 alphabets of our choice\\n        return \"v\" * n if n % 2 else \"v\" * (n-1) + \"m\"\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n     def generateTheString(self, n: int) -> str:\\n\\t\\t# we can use any of the 2 alphabets of our choice\\n        return \"v\" * n if n % 2 else \"v\" * (n-1) + \"m\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218745,
                "title": "elixir-solution",
                "content": "```\\ndef generate_the_string(n) do\\n  last_char = if rem(n, 2) === 0, do: \"b\", else: \"a\"\\n  String.duplicate(\"a\", n - 1) <> last_char\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef generate_the_string(n) do\\n  last_char = if rem(n, 2) === 0, do: \"b\", else: \"a\"\\n  String.duplicate(\"a\", n - 1) <> last_char\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1204839,
                "title": "easy-understanding-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";    \\n        if(n%2==0)\\n        {\\n       for(int i=0;i<n-1;i++)\\n       {\\n           ans.push_back(\\'a\\');\\n       }\\n            ans.push_back(\\'b\\');\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                ans.push_back(\\'a\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nupvote if u like",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";    \\n        if(n%2==0)\\n        {\\n       for(int i=0;i<n-1;i++)\\n       {\\n           ans.push_back(\\'a\\');\\n       }\\n            ans.push_back(\\'b\\');\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                ans.push_back(\\'a\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166022,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if(n % 2 == 0): return \\'a\\' + \\'b\\' * (n - 1)\\n        \\n        return \\'a\\' * n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if(n % 2 == 0): return \\'a\\' + \\'b\\' * (n - 1)\\n        \\n        return \\'a\\' * n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162729,
                "title": "one-line-java-soltion-100",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return n % 2 == 0? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n); \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n        return n % 2 == 0? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1138438,
                "title": "js-no-inbuilt-methods-only-while-loop",
                "content": "```\\nvar generateTheString = function(n) {\\n\\n    let str=\\'\\', a = n%2===0 ? n-1 : n;\\n    \\n    while(a--){\\n        str+=\\'a\\'\\n    }\\n\\n    return n%2===0? str+=\\'b\\' : str;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateTheString = function(n) {\\n\\n    let str=\\'\\', a = n%2===0 ? n-1 : n;\\n    \\n    while(a--){\\n        str+=\\'a\\'\\n    }\\n\\n    return n%2===0? str+=\\'b\\' : str;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1137520,
                "title": "java-easy",
                "content": "```\\n\\n\\npublic String generateTheString(int n) {\\n\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\\'a\\');\\n        \\n        for(int i = 1; i < n; i++ ) {\\n            if(n % 2 == 0) {\\n                sb.append(\\'b\\');\\n            } else {\\n                sb.append(\\'a\\');\\n            }   \\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\npublic String generateTheString(int n) {\\n\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\\'a\\');\\n        \\n        for(int i = 1; i < n; i++ ) {\\n            if(n % 2 == 0) {\\n                sb.append(\\'b\\');\\n            } else {\\n                sb.append(\\'a\\');\\n            }   \\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1127516,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n<=26:\\n            return string.ascii_lowercase[:n]\\n        else:\\n            if n%2 == 0:\\n                return \"a\"*(n-1) + \"b\"   \\n            else:\\n                return \"a\"*(n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n<=26:\\n            return string.ascii_lowercase[:n]\\n        else:\\n            if n%2 == 0:\\n                return \"a\"*(n-1) + \"b\"   \\n            else:\\n                return \"a\"*(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124693,
                "title": "100-c-4-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string answer(n, \\'a\\');\\n\\n        if(n % 2) \\n            return answer;\\n\\n        answer[n - 1] = \\'b\\';\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string answer(n, \\'a\\');\\n\\n        if(n % 2) \\n            return answer;\\n\\n        answer[n - 1] = \\'b\\';\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122719,
                "title": "python-3-beats-99-83-runtime",
                "content": "I don\\'t see any catch in this problem, since it does not ask for a particular pattern of return string.\\nSolution is pretty simple, return a string that has:\\n* (n-1) times the letter \"a\" (or any letter)\\n* for the last letter:\\n\\t* if the number \"n\" is odd then the final letter would be also \"a\" (or the same letter),\\n\\t* otherwise (\"n\" is even) it would be the letter \"b\" (or any other letter except the one used for the first (n-1) places).\\n```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\"*(n-1) + \"a\"*(n%2) + \"b\"*((n+1)%2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\"*(n-1) + \"a\"*(n%2) + \"b\"*((n+1)%2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116940,
                "title": "one-line-100-100-javascript",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar generateTheString = function(n) {\\n    return n % 2 === 0 ? \\'a\\'.repeat(n-1)+\\'b\\' : \\'a\\'.repeat(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar generateTheString = function(n) {\\n    return n % 2 === 0 ? \\'a\\'.repeat(n-1)+\\'b\\' : \\'a\\'.repeat(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113822,
                "title": "rust-0m",
                "content": "```\\nimpl Solution {\\n    pub fn generate_the_string(n: i32) -> String {\\n         let n = n as usize;\\n    if n % 2 != 0 {\\n        return \"a\".repeat(n);\\n    } else {\\n        return \"a\".repeat(n-1) + \"b\";\\n    }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn generate_the_string(n: i32) -> String {\\n         let n = n as usize;\\n    if n % 2 != 0 {\\n        return \"a\".repeat(n);\\n    } else {\\n        return \"a\".repeat(n-1) + \"b\";\\n    }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1101595,
                "title": "simple-code",
                "content": "class Solution\\n{\\n public String generateTheString(int n)\\n {\\n   var result = new char[n];\\n   Arrays.fill(result, \\'a\\');\\n   if (n % 2 == 0) result[0] = \\'b\\';\\n   return new String(result);\\n }\\n}",
                "solutionTags": [],
                "code": "class Solution\\n{\\n public String generateTheString(int n)\\n {\\n   var result = new char[n];\\n   Arrays.fill(result, \\'a\\');\\n   if (n % 2 == 0) result[0] = \\'b\\';\\n   return new String(result);\\n }",
                "codeTag": "Java"
            },
            {
                "id": 1073652,
                "title": "very-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) \\n    {\\n        String res=\"\";\\n        if(n%2==0)\\n        {\\n            for(int i=1;i<n;i++)\\n                res+=\\'a\\';\\n            res+=\\'b\\';\\n        }\\n        else\\n        {\\n            for(int i=1;i<=n;i++)\\n                res+=\\'a\\';\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n//By Arindam Ghosh\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) \\n    {\\n        String res=\"\";\\n        if(n%2==0)\\n        {\\n            for(int i=1;i<n;i++)\\n                res+=\\'a\\';\\n            res+=\\'b\\';\\n        }\\n        else\\n        {\\n            for(int i=1;i<=n;i++)\\n                res+=\\'a\\';\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n//By Arindam Ghosh\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069832,
                "title": "easy-c-generate-a-string",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        return n&1 ? string(n,\\'a\\') : string(n-1,\\'a\\')+\\'b\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        return n&1 ? string(n,\\'a\\') : string(n-1,\\'a\\')+\\'b\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066965,
                "title": "runtime-0ms-faster-than-100-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string p;\\n        if(n%2==0){\\n            for(int i=0;i<n-1;i++){\\n                p+=\\'a\\';\\n            }\\n            p+=\\'b\\';\\n        }\\n        else{\\n            for(int i=0;i<n;i++){\\n                p+=\\'a\\';\\n            }\\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string p;\\n        if(n%2==0){\\n            for(int i=0;i<n-1;i++){\\n                p+=\\'a\\';\\n            }\\n            p+=\\'b\\';\\n        }\\n        else{\\n            for(int i=0;i<n;i++){\\n                p+=\\'a\\';\\n            }\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066461,
                "title": "c-3lines-beats-100-by-the-way-this-is-the-borest-problem-ever",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res(n,\\'a\\');\\n        if(n%2 == 0) res[0] =\\'b\\';\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res(n,\\'a\\');\\n        if(n%2 == 0) res[0] =\\'b\\';\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063388,
                "title": "java-easy-solution-comment-explained",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder result = new StringBuilder();\\n        if ((n & 1) != 1){                    // if its even\\n            result.append(\"a\");               // add \\'a\\' character\\n            n = n-1;                          // reduce n by 1\\n        }\\n        while (n-- > 0) result.append(\"b\");   //loop and add character \\'b\\' until n becomes 0\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder result = new StringBuilder();\\n        if ((n & 1) != 1){                    // if its even\\n            result.append(\"a\");               // add \\'a\\' character\\n            n = n-1;                          // reduce n by 1\\n        }\\n        while (n-- > 0) result.append(\"b\");   //loop and add character \\'b\\' until n becomes 0\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038583,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] characters = new char[n];\\n        Arrays.fill(characters, \\'a\\');\\n        if (n % 2 == 0) characters[0] = \\'b\\';\\n        return new String(characters);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] characters = new char[n];\\n        Arrays.fill(characters, \\'a\\');\\n        if (n % 2 == 0) characters[0] = \\'b\\';\\n        return new String(characters);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035083,
                "title": "python3-beautiful-clean-number-magic",
                "content": "Several important points:\\n* We only need one type of character (e.g. `\\'a\\'`) for an odd-length string, and two (e.g. `\\'a\\'`, `\\'b\\'`) for an even-length string.\\n* In Python, you can use the `*` operator to repeat strings and lists.\\n* `n & 1` is 1 if odd, 0 if even\\n\\n```python\\nclass Solution:\\n  def generateTheString(self, n: int) -> str:\\n    e = 1 - n & 1                     # e is 1 if even, 0 if odd\\n    return \\'a\\' * (n - e) + \\'b\\' * e\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n  def generateTheString(self, n: int) -> str:\\n    e = 1 - n & 1                     # e is 1 if even, 0 if odd\\n    return \\'a\\' * (n - e) + \\'b\\' * e\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008038,
                "title": "kotlin-minimalistic-no-if",
                "content": "```\\nclass Solution {\\n    fun generateTheString(n: Int): String {\\n        val p = n + n % 2 - 1\\n        return \"p\".repeat(p) + \"q\".repeat(n - p)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun generateTheString(n: Int): String {\\n        val p = n + n % 2 - 1\\n        return \"p\".repeat(p) + \"q\".repeat(n - p)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998720,
                "title": "ruby-very-short-1-liner",
                "content": "```\\ndef generate_the_string(n)\\n    ?a*~-n+[?b,?a][n&1]\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef generate_the_string(n)\\n    ?a*~-n+[?b,?a][n&1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 998045,
                "title": "simple-one-liner-in-pytohon",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\" * n if n % 2 else \"a\" * (n - 1) + \"b\" \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\" * n if n % 2 else \"a\" * (n - 1) + \"b\" \\n```",
                "codeTag": "Java"
            },
            {
                "id": 988107,
                "title": "java-0ms",
                "content": "```\\n public String generateTheString(int n) {\\n        if(n%2==0){\\n            return \"e\".repeat(n-1)+\"i\";\\n        }\\n        else{\\n            return \"e\".repeat(n);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public String generateTheString(int n) {\\n        if(n%2==0){\\n            return \"e\".repeat(n-1)+\"i\";\\n        }\\n        else{\\n            return \"e\".repeat(n);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 975567,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res = \"\";\\n        \\n        if ((n % 2) == 0)\\n        {\\n            res += \\'a\\';\\n            for (size_t i = 1; i < n; i++)\\n            {\\n                res += \\'b\\';\\n            }\\n        }\\n        \\n        else\\n        {\\n            for (size_t i = 0; i < n; i++)\\n            {\\n                res += \\'b\\';\\n            }            \\n        }\\n   \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res = \"\";\\n        \\n        if ((n % 2) == 0)\\n        {\\n            res += \\'a\\';\\n            for (size_t i = 1; i < n; i++)\\n            {\\n                res += \\'b\\';\\n            }\\n        }\\n        \\n        else\\n        {\\n            for (size_t i = 0; i < n; i++)\\n            {\\n                res += \\'b\\';\\n            }            \\n        }\\n   \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958810,
                "title": "scala-simple-solution",
                "content": "```\\ndef generateTheString(n: Int): String = n match {\\n\\tcase 0 => \"\"\\n\\tcase odd if odd % 2 == 1 => \"a\" * odd\\n\\tcase even => \"a\" * (even - 1) + \"b\"\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndef generateTheString(n: Int): String = n match {\\n\\tcase 0 => \"\"\\n\\tcase odd if odd % 2 == 1 => \"a\" * odd\\n\\tcase even => \"a\" * (even - 1) + \"b\"\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 954134,
                "title": "simple-python",
                "content": "```\\n    def generateTheString(self, n):\\n        return \\'a\\'*n if n%2==1 else \\'a\\'*(n-1)+\\'b\\'        \\n```",
                "solutionTags": [],
                "code": "```\\n    def generateTheString(self, n):\\n        return \\'a\\'*n if n%2==1 else \\'a\\'*(n-1)+\\'b\\'        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 949957,
                "title": "c-cpp-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n)\\n    {\\n        string str(n,\\'a\\');\\n        if(!(n&1))//even\\n        {\\n            str.back()=\\'b\\';\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n)\\n    {\\n        string str(n,\\'a\\');\\n        if(!(n&1))//even\\n        {\\n            str.back()=\\'b\\';\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947066,
                "title": "javascript-solution",
                "content": "```\\nvar generateTheString = function(n) {\\n    if (n % 2 === 0) {\\n        return \"a\".repeat(n - 1) + \"b\";\\n    }\\n    \\n    return \"a\".repeat(n);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateTheString = function(n) {\\n    if (n % 2 === 0) {\\n        return \"a\".repeat(n - 1) + \"b\";\\n    }\\n    \\n    return \"a\".repeat(n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935469,
                "title": "java-2-simple-solutions-with-stringbuilder-and-arrays-fill",
                "content": "\\n**V1**\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder str = new StringBuilder();\\n\\t\\t\\n        if (n % 2 == 0) {\\n            str.append(\"x\");\\n            n--;\\n        }\\n\\n        while (n > 0) {\\n            str.append(\"a\");\\n            n--;\\n        }\\n\\n        return str.toString();\\n    }\\n}\\n```\\n\\n**V2**\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] arr = new char[n];\\n        \\n\\t\\tArrays.fill(arr, \\'a\\'); \\n        if (n % 2 == 0) arr[0] = \\'x\\';\\n\\t\\t\\n        return String.valueOf(arr);       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder str = new StringBuilder();\\n\\t\\t\\n        if (n % 2 == 0) {\\n            str.append(\"x\");\\n            n--;\\n        }\\n\\n        while (n > 0) {\\n            str.append(\"a\");\\n            n--;\\n        }\\n\\n        return str.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] arr = new char[n];\\n        \\n\\t\\tArrays.fill(arr, \\'a\\'); \\n        if (n % 2 == 0) arr[0] = \\'x\\';\\n\\t\\t\\n        return String.valueOf(arr);       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923632,
                "title": "python-one-liner",
                "content": "``` \\n        return \\'a\\' * n if n % 2 else \\'a\\' * 1 + \\'b\\' * (n - 1)\\n```",
                "solutionTags": [],
                "code": "``` \\n        return \\'a\\' * n if n % 2 else \\'a\\' * 1 + \\'b\\' * (n - 1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 922944,
                "title": "cpp-very-simple-and-efficient-i-think",
                "content": "very simple and efficient, I think\\n\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s = \"\";\\n        \\n        if( n%2 == 1){\\n            for(int i =0 ;i<n;i++)\\n                s+=\\'a\\';\\n        } else{\\n            for(int i=0 ;i<n-1;i++)\\n                s+=\\'a\\';\\n            s+=\\'b\\';\\n        }\\n        \\n        return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s = \"\";\\n        \\n        if( n%2 == 1){\\n            for(int i =0 ;i<n;i++)\\n                s+=\\'a\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 913858,
                "title": "c-easy-and-force",
                "content": "if n = even add \\'z\\'\\n```\\npublic class Solution {\\n    public string GenerateTheString(int n) {\\n        if(n%2==0)\\n            return new string(new char[n-1]).Replace(\"\\\\u0000\",\"a\")+\\'z\\';\\n        else\\n            return new string(new char[n]).Replace(\"\\\\u0000\",\"a\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string GenerateTheString(int n) {\\n        if(n%2==0)\\n            return new string(new char[n-1]).Replace(\"\\\\u0000\",\"a\")+\\'z\\';\\n        else\\n            return new string(new char[n]).Replace(\"\\\\u0000\",\"a\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911730,
                "title": "java-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb = new StringBuilder(n);\\n        while (sb.length() < n - 1) {\\n            sb.append(\\'a\\');\\n        }\\n        if (n % 2 == 0) {\\n            sb.append(\\'b\\');\\n        } else {\\n            sb.append(\\'a\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb = new StringBuilder(n);\\n        while (sb.length() < n - 1) {\\n            sb.append(\\'a\\');\\n        }\\n        if (n % 2 == 0) {\\n            sb.append(\\'b\\');\\n        } else {\\n            sb.append(\\'a\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 904694,
                "title": "python-if-else-easy-solution",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n == 1: return \"x\"\\n        if n % 2 == 0:\\n            return \"x\" * (n-1) + \"z\"\\n        else:\\n            return \"z\" * (n-2) + \"x\" + \"y\"\\n```\\nFor more solutions: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n == 1: return \"x\"\\n        if n % 2 == 0:\\n            return \"x\" * (n-1) + \"z\"\\n        else:\\n            return \"z\" * (n-2) + \"x\" + \"y\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886035,
                "title": "very-concise-and-very-easy-best-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string S(n,\\'a\\');\\n        if(n % 2 == 0)\\n            S[S.size() - 1] = \\'b\\';\\n        return S;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string S(n,\\'a\\');\\n        if(n % 2 == 0)\\n            S[S.size() - 1] = \\'b\\';\\n        return S;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881252,
                "title": "only-a-and-b-are-used-0ms-100-faster-c",
                "content": "[https://github.com/sarimurrab](https://github.com/sarimurrab)\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        \\n        string res =\"\";\\n        char abc[27]= {\\'a\\',\\'b\\'};\\n        \\n        \\n        if(n&1)                 // if ODD- simple add \\'a\\' character n times\\n            for(int i=0;i<n;i++)             //       aaa\\n            {\\n                res += abc[0];          \\n            }\\n        else                    // if even, \\'a\\' add one time and \\'b\\' n-1 times\\n        {                                     //      abbb\\n            for(int i=0;i<1;i++)\\n            {\\n                res += abc[0];          \\n            }\\n            for(int i=1;i<n;i++)\\n            {\\n                res += abc[1];          \\n            }\\n            \\n        }\\n        return res;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        \\n        string res =\"\";\\n        char abc[27]= {\\'a\\',\\'b\\'};\\n        \\n        \\n        if(n&1)                 // if ODD- simple add \\'a\\' character n times\\n            for(int i=0;i<n;i++)             //       aaa\\n            {\\n                res += abc[0];          \\n            }\\n        else                    // if even, \\'a\\' add one time and \\'b\\' n-1 times\\n        {                                     //      abbb\\n            for(int i=0;i<1;i++)\\n            {\\n                res += abc[0];          \\n            }\\n            for(int i=1;i<n;i++)\\n            {\\n                res += abc[1];          \\n            }\\n            \\n        }\\n        return res;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876900,
                "title": "1ms-java-solution-no-loops",
                "content": "```class Solution {\\n    public String generateTheString(int n) {\\n        \\n        //if n is even, create a string of n-1 \"a\"\\'s and append a \"b\".\\n        if(n%2 == 0){\\n            //create an array of chars of length n-1 and replace all chars with an \"a\" before converting to String.\\n            String a = new String(new char[n-1]).replace(\"\\\\0\", \"a\");\\n            return (a + \"b\");\\n        }\\n        //otherwise return a String of n \"a\"\\'s.\\n        return new String(new char[n]).replace(\"\\\\0\", \"a\");\\n    }\\n}```\\n",
                "solutionTags": [],
                "code": "```class Solution {\\n    public String generateTheString(int n) {\\n        \\n        //if n is even, create a string of n-1 \"a\"\\'s and append a \"b\".\\n        if(n%2 == 0){\\n            //create an array of chars of length n-1 and replace all chars with an \"a\" before converting to String.\\n            String a = new String(new char[n-1]).replace(\"\\\\0\", \"a\");\\n            return (a + \"b\");\\n        }\\n        //otherwise return a String of n \"a\"\\'s.\\n        return new String(new char[n]).replace(\"\\\\0\", \"a\");\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 871843,
                "title": "simple-c-code-self-explanatory-beats-100",
                "content": "```\\nchar * generateTheString(int n){\\n    char *res = (char *)malloc(sizeof(char)*(n+1));\\n    res[n]= \\'\\\\0\\';\\n    if(n%2 == 0){\\n        for(int i=0; i<=n-2; i++){\\n            res[i] = \\'a\\';\\n        }\\n        res[n-1]= \\'b\\';\\n    }\\n    else{\\n        for(int i=0; i<n ;i++){\\n            res[i]= \\'a\\';\\n        }\\n    }\\n    return res;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * generateTheString(int n){\\n    char *res = (char *)malloc(sizeof(char)*(n+1));\\n    res[n]= \\'\\\\0\\';\\n    if(n%2 == 0){\\n        for(int i=0; i<=n-2; i++){\\n            res[i] = \\'a\\';\\n        }\\n        res[n-1]= \\'b\\';\\n    }\\n    else{\\n        for(int i=0; i<n ;i++){\\n            res[i]= \\'a\\';\\n        }\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 866994,
                "title": "100-faster-than-other-c-solutions",
                "content": "string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2!=0)\\n        {\\n            for(int i=0;i<n;i++)\\n                s+=\"a\";\\n        }\\n        else\\n        {\\n            if((n/2)%2!=0)\\n            {\\n                for(int i=0;i<n/2;i++)\\n                    s+=\"a\";\\n                for(int i=0;i<n/2;i++)\\n                    s+=\"b\";\\n            }\\n            else\\n            {\\n                for(int i=0;i<n/2+1;i++)\\n                    s+=\"a\";\\n                for(int i=0;i<n/2-1;i++)\\n                    s+=\"b\";\\n            }\\n        }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2!=0)\\n        {\\n            for(int i=0;i<n;i++)\\n                s+=\"a\";\\n        }\\n        else\\n        {\\n            if((n/2)%2!=0)\\n            {\\n                for(int i=0;i<n/2;i++)\\n                    s+=\"a\";\\n                for(int i=0;i<n/2;i++)\\n                    s+=\"b\";\\n            }\\n            else\\n            {\\n                for(int i=0;i<n/2+1;i++)\\n                    s+=\"a\";\\n                for(int i=0;i<n/2-1;i++)\\n                    s+=\"b\";\\n            }\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 801292,
                "title": "java-one-line-solution",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return n%2 == 0 ? \\n            new String(new char[n-1]).replace(\"\\\\0\", \"x\") + \"y\" : \\n            new String(new char[n]).replace(\"\\\\0\", \"x\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return n%2 == 0 ? \\n            new String(new char[n-1]).replace(\"\\\\0\", \"x\") + \"y\" : \\n            new String(new char[n]).replace(\"\\\\0\", \"x\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796344,
                "title": "two-lines-golang-solution-faster-than-100-2-1mb-beats-97",
                "content": "```\\nfunc generateTheString(n int) string {\\n    if n % 2 == 0 { return strings.Repeat(\"a\", n-1) + \"b\" }\\n    return strings.Repeat(\"a\", n)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc generateTheString(n int) string {\\n    if n % 2 == 0 { return strings.Repeat(\"a\", n-1) + \"b\" }\\n    return strings.Repeat(\"a\", n)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 795765,
                "title": "java-faster-than-100-less-mem-than-97",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] str = new char[n];\\n        Arrays.fill(str, \\'b\\');\\n        \\n        if(n%2==0) str[0] = \\'a\\';\\n        \\n        return new String(str);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] str = new char[n];\\n        Arrays.fill(str, \\'b\\');\\n        \\n        if(n%2==0) str[0] = \\'a\\';\\n        \\n        return new String(str);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790000,
                "title": "java-solution-using-string-builder-and-arrays-fill",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] string = new char[n];\\n        Arrays.fill(string, \\'a\\');\\n        if(n%2 == 0) string[n-1] = \\'b\\';\\n        \\n        return new String(string);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] string = new char[n];\\n        Arrays.fill(string, \\'a\\');\\n        if(n%2 == 0) string[n-1] = \\'b\\';\\n        \\n        return new String(string);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782644,
                "title": "python-3-faster-than-99-less-memory-than-78",
                "content": "\\n\"\"\"\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2 == 0:\\n            return \\'a\\'*(n-1) + \\'b\\'\\n        return \\'a\\'*n\\n\"\"\"",
                "solutionTags": [],
                "code": "\\n\"\"\"\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2 == 0:\\n            return \\'a\\'*(n-1) + \\'b\\'\\n        return \\'a\\'*n\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 732603,
                "title": "c-solution-o-1-100-speed-and-memory",
                "content": "```\\n\\nchar * generateTheString(int n){\\n    char *string = (char*)malloc((n+1)*sizeof(char));\\n    memset(string, \\'a\\', n);\\n    if(n%2==0)\\n        string[n-1]=\\'b\\';\\n    string[n]=\\'\\\\0\\';\\n    return string;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nchar * generateTheString(int n){\\n    char *string = (char*)malloc((n+1)*sizeof(char));\\n    memset(string, \\'a\\', n);\\n    if(n%2==0)\\n        string[n-1]=\\'b\\';\\n    string[n]=\\'\\\\0\\';\\n    return string;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 728811,
                "title": "very-easy-5-line-solution-100-fast",
                "content": "string generateTheString(int n) {\\n        string s=\"\";\\n        s.insert(0,n,\\'a\\');\\n        if(n%2==0)\\n            s[n-1]=\\'b\\';\\n        return s;  \\n    }",
                "solutionTags": [],
                "code": "string generateTheString(int n) {\\n        string s=\"\";\\n        s.insert(0,n,\\'a\\');\\n        if(n%2==0)\\n            s[n-1]=\\'b\\';\\n        return s;  \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 726426,
                "title": "go",
                "content": "How is this problem on LeetCode. I bet a 6th-grader could solve this problem on Minecraft Java Edition using red stones.\\n\\n```\\nfunc generateTheString(n int) string {\\n    res := make([]byte, n, n)\\n    \\n    idx := 0\\n    if n % 2 == 0 {\\n        res[idx] = \\'a\\';\\n        idx++\\n    }\\n    \\n    for ; idx < n; idx++ {\\n        res[idx] = \\'b\\'\\n    }\\n    return string(res)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc generateTheString(n int) string {\\n    res := make([]byte, n, n)\\n    \\n    idx := 0\\n    if n % 2 == 0 {\\n        res[idx] = \\'a\\';\\n        idx++\\n    }\\n    \\n    for ; idx < n; idx++ {\\n        res[idx] = \\'b\\'\\n    }\\n    return string(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 715364,
                "title": "python-one-line-solution-faster-than-95",
                "content": "```\\ndef generateTheString(self, n: int) -> str:\\n        return \"a\"*n if n&1 else \"a\"*(n-1)+\"b\"\\n```",
                "solutionTags": [],
                "code": "```\\ndef generateTheString(self, n: int) -> str:\\n        return \"a\"*n if n&1 else \"a\"*(n-1)+\"b\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 686728,
                "title": "o-logn-solution-implementing-string-repeat-method-in-a-readable-way",
                "content": "```\\nclass Solution {\\n    func generateTheString(_ n: Int) -> String {\\n        var outputString = String()\\n        if n % 2 == 0 {\\n            outputString = repeatCharacter(char: \"c\", count: n - 1)\\n            outputString.append(\"x\")\\n            return outputString\\n        }\\n        outputString = repeatCharacter(char: \"c\", count: n)\\n        return outputString\\n    }\\n    \\n    // Time complexity O(logn)\\n    func repeatCharacter(char: Character, count targetCount: Int) -> String {\\n        var outputString = String(char)\\n        \\n        // This is a computed property which gives you the \\n        // up to date value everytime its accessed\\n        var count: Int {\\n            return outputString.count\\n        }\\n        \\n        while count < targetCount {\\n            // If appending the string to itself will cause the count to exceed the desired count,\\n            // we find the num of char required to complete the output by finding the difference\\n            // and take a substring and append to itself\\n            if (count * 2) > targetCount {\\n                let startIndex = outputString.startIndex\\n                let endIndex = outputString.index(outputString.startIndex, offsetBy: targetCount - count)\\n                outputString.append(String(outputString[startIndex..<endIndex]))\\n            } else {\\n                // Append the string to itself\\n                outputString.append(outputString)\\n            }\\n        }\\n        return outputString\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func generateTheString(_ n: Int) -> String {\\n        var outputString = String()\\n        if n % 2 == 0 {\\n            outputString = repeatCharacter(char: \"c\", count: n - 1)\\n            outputString.append(\"x\")\\n            return outputString\\n        }\\n        outputString = repeatCharacter(char: \"c\", count: n)\\n        return outputString\\n    }\\n    \\n    // Time complexity O(logn)\\n    func repeatCharacter(char: Character, count targetCount: Int) -> String {\\n        var outputString = String(char)\\n        \\n        // This is a computed property which gives you the \\n        // up to date value everytime its accessed\\n        var count: Int {\\n            return outputString.count\\n        }\\n        \\n        while count < targetCount {\\n            // If appending the string to itself will cause the count to exceed the desired count,\\n            // we find the num of char required to complete the output by finding the difference\\n            // and take a substring and append to itself\\n            if (count * 2) > targetCount {\\n                let startIndex = outputString.startIndex\\n                let endIndex = outputString.index(outputString.startIndex, offsetBy: targetCount - count)\\n                outputString.append(String(outputString[startIndex..<endIndex]))\\n            } else {\\n                // Append the string to itself\\n                outputString.append(outputString)\\n            }\\n        }\\n        return outputString\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676111,
                "title": "java-solution-0-ms-100-simple",
                "content": "public String generateTheString(int n) {\\n        //string of length n\\n        //if string is odd length just return a string with the same char\\n        //if it is even: just add a different char to the last potision \\n    \\n        char[] ch = new char[n];\\n           \\n        for(int i = 0; i < n - 1; i++){\\n               ch[i] = \\'a\\';\\n            }\\n        \\n        if(n % 2 != 0){\\n            ch[n-1] = \\'a\\';\\n        }else{\\n            ch[n-1] = \\'b\\';\\n        }\\n\\n        return String.valueOf(ch);\\n    }",
                "solutionTags": [],
                "code": "public String generateTheString(int n) {\\n        //string of length n\\n        //if string is odd length just return a string with the same char\\n        //if it is even: just add a different char to the last potision \\n    \\n        char[] ch = new char[n];\\n           \\n        for(int i = 0; i < n - 1; i++){\\n               ch[i] = \\'a\\';\\n            }\\n        \\n        if(n % 2 != 0){\\n            ch[n-1] = \\'a\\';\\n        }else{\\n            ch[n-1] = \\'b\\';\\n        }\\n\\n        return String.valueOf(ch);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 675579,
                "title": "0ms-simple-c-code",
                "content": "```\\nchar * generateTheString(int n){\\n    if (n==0) return NULL;\\n    \\n    char *c = (char*)malloc((n+1)*sizeof(char));\\n    memset(c, \\'a\\', (n-1)*sizeof(char));\\n\\n    c[n-1] = n%2?\\'a\\':\\'b\\';\\n    c[n] = \\'\\\\0\\';\\n\\t\\n    return c;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar * generateTheString(int n){\\n    if (n==0) return NULL;\\n    \\n    char *c = (char*)malloc((n+1)*sizeof(char));\\n    memset(c, \\'a\\', (n-1)*sizeof(char));\\n\\n    c[n-1] = n%2?\\'a\\':\\'b\\';\\n    c[n] = \\'\\\\0\\';\\n\\t\\n    return c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 669204,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2 == 0 and (n//2)%2 != 0:\\n            return \\'a\\'*(n//2)+\\'b\\'*(n//2)\\n        elif n%2 == 0 and (n//2)%2 == 0:\\n            return \\'a\\'*((n//2)+1)+\\'b\\'*((n//2)-1)\\n        else:\\n            return \\'a\\'*n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2 == 0 and (n//2)%2 != 0:\\n            return \\'a\\'*(n//2)+\\'b\\'*(n//2)\\n        elif n%2 == 0 and (n//2)%2 == 0:\\n            return \\'a\\'*((n//2)+1)+\\'b\\'*((n//2)-1)\\n        else:\\n            return \\'a\\'*n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565787,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1575506,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1863251,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1835880,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1569803,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1938351,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1749928,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1966778,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1845042,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1826989,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1565787,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1575506,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1863251,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1835880,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1569803,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1938351,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1749928,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1966778,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1845042,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1826989,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            }
        ]
    }
]