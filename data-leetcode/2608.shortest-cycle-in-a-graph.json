[
    {
        "title": "Minimum Time to Eat All Grains",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Form Smallest Number From Two Digit Arrays",
        "question_content": "Given two arrays of <strong>unique</strong> digits <code>nums1</code> and <code>nums2</code>, return <em>the <strong>smallest</strong> number that contains <strong>at least</strong> one digit from each array</em>.\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,1,3], nums2 = [5,7]\n<strong>Output:</strong> 15\n<strong>Explanation:</strong> The number 15 contains the digit 1 from nums1 and the digit 5 from nums2. It can be proven that 15 is the smallest number we can have.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [3,5,2,6], nums2 = [3,1,7]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The number 3 contains the digit 3 which exists in both arrays.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 9</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 9</code></li>\n\t<li>All digits in each array are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3366601,
                "title": "c-easiest-solution-ever-for-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are making a frequency array of values that are present in `nums1` and `nums2`. If the frequency of any element in this means it is present in both the array. So we will return the smallest number with frequecy 2. \\nOtherwise, we will fetch the smallest numbers from `nums1` andn `nums2` and will return the smallest number from their combination.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple. Read the intuition and see the code, you will understand the solution easily\\n\\n# Complexity\\n- Time complexity: O(1) : Size of both arrays is less than 10.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> freq(10);\\n        for(int i=0; i<nums1.size(); i++) freq[nums1[i]]++;\\n        for(int i=0; i<nums2.size(); i++) freq[nums2[i]]++;\\n            \\n        int k=2;\\n        int ans =0;\\n        int mn1 = *min_element(nums1.begin(), nums1.end());\\n        int mn2 = *min_element(nums2.begin(), nums2.end());\\n        for(int i=1; i<=9; i++)\\n            if(freq[i]==2) return i;\\n        \\n        if(mn2<mn1) swap(mn2, mn1);\\n        return mn1*10+mn2;\\n    }\\n};\\n// PLEASE UPVOTE THE SOLUTION IF IT HELPED YOU SOMEHOW\\n\\n```\\n![0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg](https://assets.leetcode.com/users/images/8832d8f0-1407-45e1-95c6-eba200006155_1680365505.4458308.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> freq(10);\\n        for(int i=0; i<nums1.size(); i++) freq[nums1[i]]++;\\n        for(int i=0; i<nums2.size(); i++) freq[nums2[i]]++;\\n            \\n        int k=2;\\n        int ans =0;\\n        int mn1 = *min_element(nums1.begin(), nums1.end());\\n        int mn2 = *min_element(nums2.begin(), nums2.end());\\n        for(int i=1; i<=9; i++)\\n            if(freq[i]==2) return i;\\n        \\n        if(mn2<mn1) swap(mn2, mn1);\\n        return mn1*10+mn2;\\n    }\\n};\\n// PLEASE UPVOTE THE SOLUTION IF IT HELPED YOU SOMEHOW\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366413,
                "title": "intersection",
                "content": "\\n**Python 3**\\n```python\\nclass Solution:\\n    def minNumber(self, n1: List[int], n2: List[int]) -> int:\\n        common, m1, m2 = set(n1).intersection(n2), min(n1), min(n2)\\n        return min(common) if common else min(m1, m2) * 10 + max(m1, m2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minNumber(self, n1: List[int], n2: List[int]) -> int:\\n        common, m1, m2 = set(n1).intersection(n2), min(n1), min(n2)\\n        return min(common) if common else min(m1, m2) * 10 + max(m1, m2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366407,
                "title": "java-python-3-using-set",
                "content": "\\n\\n```java\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> s1 = getHashSet(nums1), s2 = getHashSet(nums2);\\n        s1.retainAll(s2);\\n        if (!s1.isEmpty()) {\\n            return s1.stream().mapToInt(i -> i).min().getAsInt();\\n        }\\n        int a = IntStream.of(nums1).min().getAsInt();\\n        int b = IntStream.of(nums2).min().getAsInt();\\n        return Math.min(a, b) * 10 + Math.max(a, b);\\n    }\\n    private HashSet<Integer> getHashSet(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            set.add(num);\\n        }\\n        return set;\\n    }\\n```\\n```python\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = set(nums1), set(nums2)\\n        if s1 & s2:\\n            return min(s1 & s2)\\n        a, b = min(nums1), min(nums2)\\n        return min(a, b) * 10 + max(a, b)\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(m + n)`, where `m = nums1.length, n = nums2.length`.",
                "solutionTags": [],
                "code": "```java\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> s1 = getHashSet(nums1), s2 = getHashSet(nums2);\\n        s1.retainAll(s2);\\n        if (!s1.isEmpty()) {\\n            return s1.stream().mapToInt(i -> i).min().getAsInt();\\n        }\\n        int a = IntStream.of(nums1).min().getAsInt();\\n        int b = IntStream.of(nums2).min().getAsInt();\\n        return Math.min(a, b) * 10 + Math.max(a, b);\\n    }\\n    private HashSet<Integer> getHashSet(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            set.add(num);\\n        }\\n        return set;\\n    }\\n```\n```python\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = set(nums1), set(nums2)\\n        if s1 & s2:\\n            return min(s1 & s2)\\n        a, b = min(nums1), min(nums2)\\n        return min(a, b) * 10 + max(a, b)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3366482,
                "title": "easiest-solution-in-n-2-no-fancy-solution-4-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int n=0,ans=INT_MAX;\\n        \\n        for(auto i:nums1){\\n            for(auto j:nums2){\\n                if(i==j) n=i;\\n                else n=min(i*10+j,j*10+i);\\n                ans=min(ans,n);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int n=0,ans=INT_MAX;\\n        \\n        for(auto i:nums1){\\n            for(auto j:nums2){\\n                if(i==j) n=i;\\n                else n=min(i*10+j,j*10+i);\\n                ans=min(ans,n);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366406,
                "title": "easy-short-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int val = Integer.MAX_VALUE;\\n        for(int i=0; i<nums1.length; i++){\\n            for(int j=0; j<nums2.length; j++){\\n                if(nums1[i] == nums2[j])  val = Math.min(val,nums1[i]);\\n                val = Math.min(val,Math.min(nums1[i]*10+nums2[j],nums2[j]*10+nums1[i]));\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int val = Integer.MAX_VALUE;\\n        for(int i=0; i<nums1.length; i++){\\n            for(int j=0; j<nums2.length; j++){\\n                if(nums1[i] == nums2[j])  val = Math.min(val,nums1[i]);\\n                val = Math.min(val,Math.min(nums1[i]*10+nums2[j],nums2[j]*10+nums1[i]));\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366838,
                "title": "100-faster-and-easy-map-solution-with-explanation-using-c-my-approach-during-contest",
                "content": "**Step 1** : Sort both the Vectors.\\n\\n**Step 2** : Store the elements of nums1 into a map.\\n\\n**Step 3** : Now Traverse The map for each element in nums2 , if same element is found in both vectors return that element directly. \\n\\n**Step 4** : Simply return the nums1[0]*10 + nums2[0]   **if(nums1[0] < nums2[0])**\\nand nums2[0]*10 + nums1[0] **if(nums1[0] > nums2[0])**\\n\\n```\\nclass Solution {\\npublic:\\nint minNumber(vector<int> &nums1, vector<int> &nums2) {\\n\\n\\n    int n1 = nums1.size();\\n    int n2 = nums2.size();\\n    \\n    sort(nums1.begin(), nums1.end());\\n    sort(nums2.begin(), nums2.end());\\n    \\n    \\n    map<int,int>map;   //Store the element of nums1 into a map.\\n    \\n    \\n    for(int i=0;i<n1;i++){\\n        map[nums1[i]]++;\\n    }\\n    \\n    // Now Traverse The map for each element in nums2 , if same element is found in both array return that element directly. \\n    for(int i=0;i<n2;i++){\\n        if(map.find(nums2[i])!=map.end()){\\n            return nums2[i];\\n        }\\n    }\\n\\n\\n \\n    if(nums1[0] < nums2[0]){\\n        return nums1[0]*10 + nums2[0];\\n    }\\n    else{\\n        return nums2[0]*10 + nums1[0];\\n    }\\n\\n\\n\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint minNumber(vector<int> &nums1, vector<int> &nums2) {\\n\\n\\n    int n1 = nums1.size();\\n    int n2 = nums2.size();\\n    \\n    sort(nums1.begin(), nums1.end());\\n    sort(nums2.begin(), nums2.end());\\n    \\n    \\n    map<int,int>map;   //Store the element of nums1 into a map.\\n    \\n    \\n    for(int i=0;i<n1;i++){\\n        map[nums1[i]]++;\\n    }\\n    \\n    // Now Traverse The map for each element in nums2 , if same element is found in both array return that element directly. \\n    for(int i=0;i<n2;i++){\\n        if(map.find(nums2[i])!=map.end()){\\n            return nums2[i];\\n        }\\n    }\\n\\n\\n \\n    if(nums1[0] < nums2[0]){\\n        return nums1[0]*10 + nums2[0];\\n    }\\n    else{\\n        return nums2[0]*10 + nums1[0];\\n    }\\n\\n\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366789,
                "title": "simple-solution-with-1-won-extra-tip-to-remember-for-life-which-i-bet-no-won-will-provide",
                "content": "# Intuition\\nTHODA GYAN THODI BAKCHODI THODA CODE\\n\\n# Approach\\nSS\\nJUST SMILE AND SOLVE\\n\\n# Complexity\\nNOTHING COMPLEX\\n\\n# EXTRA TIP(GYAN)\\n![Bakchodi 1.jpg](https://assets.leetcode.com/users/images/68ea9a42-bce9-4ed3-85f3-843bd9e31ab6_1680367347.3906567.jpeg)\\n\\n\\n# POORA JAVA Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int sm=10,sm2=10,p=Integer.MAX_VALUE;\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            if(sm>nums1[i])\\n                sm=nums1[i];\\n        }\\n         for(int i=0;i<nums2.length;i++)\\n        {\\n            if(sm2>nums2[i])\\n                sm2=nums2[i];\\n        }\\n        int x=Math.max(sm,sm2);\\n        int y=Math.min(sm,sm2);\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            for(int j=0;j<nums2.length;j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    if(p>nums1[i])\\n                        p=nums1[i];\\n                }\\n            }\\n        }\\n        return  Math.min(y*10+x,p);\\n        \\n        \\n    }\\n}\\n```\\n# THODI VINATI\\n![Bakchodi 2.jpeg](https://assets.leetcode.com/users/images/91bbdfde-02da-4b55-a3d1-669c0813fa29_1680367384.861429.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int sm=10,sm2=10,p=Integer.MAX_VALUE;\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            if(sm>nums1[i])\\n                sm=nums1[i];\\n        }\\n         for(int i=0;i<nums2.length;i++)\\n        {\\n            if(sm2>nums2[i])\\n                sm2=nums2[i];\\n        }\\n        int x=Math.max(sm,sm2);\\n        int y=Math.min(sm,sm2);\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            for(int j=0;j<nums2.length;j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    if(p>nums1[i])\\n                        p=nums1[i];\\n                }\\n            }\\n        }\\n        return  Math.min(y*10+x,p);\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385343,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        small1, small2, common = min(nums1), min(nums2), set(nums1) & set(nums2)\\n        output1, output2 = int(f\"{small1}{small2}\"), int(f\"{small2}{small1}\")\\n        if common:\\n            common = min(common)\\n            if common < output1 and common < output2:\\n                return common\\n        if small1 < small2:\\n            return output1\\n        return output2\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        small1, small2, common = min(nums1), min(nums2), set(nums1) & set(nums2)\\n        output1, output2 = int(f\"{small1}{small2}\"), int(f\"{small2}{small1}\")\\n        if common:\\n            common = min(common)\\n            if common < output1 and common < output2:\\n                return common\\n        if small1 < small2:\\n            return output1\\n        return output2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367793,
                "title": "python-3-3-lines-set-t-m-100-100",
                "content": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        if mn := min(set(nums1)&set(nums2),\\n                    default = None): return mn      #  <-- one-digit case\\n\\n        d1, d2 = min(nums1), min(nums2)             #  <-- two-digit case\\n        return 10*d1+d2 if d1 < d2 else 10*d2+d1    #\\n```\\n[https://leetcode.com/problems/form-smallest-number-from-two-digit-arrays/submissions/926220757/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N1+N2*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        if mn := min(set(nums1)&set(nums2),\\n                    default = None): return mn      #  <-- one-digit case\\n\\n        d1, d2 = min(nums1), min(nums2)             #  <-- two-digit case\\n        return 10*d1+d2 if d1 < d2 else 10*d2+d1    #\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366805,
                "title": "easiest-java-solution",
                "content": "![b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png](https://assets.leetcode.com/users/images/f2ae0a30-985d-4475-b60d-cf2cb9354b0a_1680367496.4392107.png)\\nFastest Java code. Please like and comment.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        int min1=Integer.MAX_VALUE,min2=Integer.MAX_VALUE,min=Integer.MAX_VALUE;\\n        boolean temp = false;\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            min1 = Math.min(min1,nums1[i]);\\n            set.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            min2 = Math.min(min2,nums2[i]);\\n            if(set.contains(nums2[i])) \\n            {\\n                min = Math.min(min,nums2[i]);\\n                temp = true;\\n            }\\n        }\\n        if(temp) return min;\\n        if(min1<min2)\\n        {\\n            return min1*10+min2;\\n        }\\n        else\\n            return min2*10+min1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        int min1=Integer.MAX_VALUE,min2=Integer.MAX_VALUE,min=Integer.MAX_VALUE;\\n        boolean temp = false;\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            min1 = Math.min(min1,nums1[i]);\\n            set.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            min2 = Math.min(min2,nums2[i]);\\n            if(set.contains(nums2[i])) \\n            {\\n                min = Math.min(min,nums2[i]);\\n                temp = true;\\n            }\\n        }\\n        if(temp) return min;\\n        if(min1<min2)\\n        {\\n            return min1*10+min2;\\n        }\\n        else\\n            return min2*10+min1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503533,
                "title": "optimized-c-easy-to-understand",
                "content": "check if a no present in both array if present than return minimum.\\nelse make smallest possible no using nums1[i] && nums2[j];\\n\\n# Complexity\\n- Time complexity:\\nO(n+m+81);\\n\\n- Space complexity:\\nO(10+10);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v1(10,0),v2(10,0);\\n        for(auto &i: nums1)v1[i]++;\\n        for(auto &i: nums2)v2[i]++;\\n        int i,j;\\n        for(i = 1; i <= 9; i++){\\n            if(v1[i]&&v2[i])return i;\\n        }\\n        int ans = 100;\\n        for(i =1; i <= 9; i++){\\n            if(v1[i]){\\n                for(j = 1; j <= 9; j++){\\n                    if(v2[j]){\\n                        ans = min({i*10+j,j*10+i,ans});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v1(10,0),v2(10,0);\\n        for(auto &i: nums1)v1[i]++;\\n        for(auto &i: nums2)v2[i]++;\\n        int i,j;\\n        for(i = 1; i <= 9; i++){\\n            if(v1[i]&&v2[i])return i;\\n        }\\n        int ans = 100;\\n        for(i =1; i <= 9; i++){\\n            if(v1[i]){\\n                for(j = 1; j <= 9; j++){\\n                    if(v2[j]){\\n                        ans = min({i*10+j,j*10+i,ans});\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391461,
                "title": "java-solution",
                "content": "**JAVA SOLUTION**\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int ans=Integer.MAX_VALUE;\\n        for(int i = 0; i<nums1.length; i++){\\n            for(int j = 0; j<nums2.length; j++){\\n                if(nums1[i]==nums2[j])\\n                 ans = Math.min(ans,nums2[j]);\\n                else{\\n                    ans = Math.min(nums1[i]*10+nums2[j], ans);\\n                    ans = Math.min(nums2[j]*10 + nums1[i], ans);\\n                }\\n            }\\n        }\\n         return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int ans=Integer.MAX_VALUE;\\n        for(int i = 0; i<nums1.length; i++){\\n            for(int j = 0; j<nums2.length; j++){\\n                if(nums1[i]==nums2[j])\\n                 ans = Math.min(ans,nums2[j]);\\n                else{\\n                    ans = Math.min(nums1[i]*10+nums2[j], ans);\\n                    ans = Math.min(nums2[j]*10 + nums1[i], ans);\\n                }\\n            }\\n        }\\n         return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368216,
                "title": "python-o-n-very-easy-with-explanation-100-faster",
                "content": "# Intuition\\nDescribed the thought process and solution approach in the comments of the code.\\n\\n- Time complexity: o(n)\\n\\n- Space complexity: o(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        # Create a list of common numbers using \\'set\\' and \\'&\\'\\n        common = list(set(nums1) & set(nums2))\\n        # Check if there is any common element\\n        # Since it is given that the 1 <= nums1[i], nums2[i] <= 9, \\n        # we can confirm that the common element will be smaller\\n        # than creating a smalll number using two elements\\n        if common:\\n            # Ensure that we return the smallest common element\\n            # I have seen solutions where sort is used instead of using min\\n            # Time complexity when using sort: O(nlogn)\\n            # Time complexity when using min: O(n)\\n            return min(common)\\n\\n        # If there is no common element, we will have to create a \\n        # new 2-digit element such that we get the smallest value\\n        min1 = min(nums1)\\n        min2 = min(nums2)\\n        \\n        if min1 > min2:\\n            res = min2*10 + min1\\n        else:\\n            res = min1* 10 + min2\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        # Create a list of common numbers using \\'set\\' and \\'&\\'\\n        common = list(set(nums1) & set(nums2))\\n        # Check if there is any common element\\n        # Since it is given that the 1 <= nums1[i], nums2[i] <= 9, \\n        # we can confirm that the common element will be smaller\\n        # than creating a smalll number using two elements\\n        if common:\\n            # Ensure that we return the smallest common element\\n            # I have seen solutions where sort is used instead of using min\\n            # Time complexity when using sort: O(nlogn)\\n            # Time complexity when using min: O(n)\\n            return min(common)\\n\\n        # If there is no common element, we will have to create a \\n        # new 2-digit element such that we get the smallest value\\n        min1 = min(nums1)\\n        min2 = min(nums2)\\n        \\n        if min1 > min2:\\n            res = min2*10 + min1\\n        else:\\n            res = min1* 10 + min2\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367115,
                "title": "python3-check-intersection",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/1dc118daa80cfe1161dcee412e7c3536970ca60d) for solutions of biweely 101. \\n\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        inter = set(nums1) & set(nums2)\\n        if inter: return min(inter)\\n        d1 = min(nums1)\\n        d2 = min(nums2)\\n        return 10*d1+d2 if d1 < d2 else 10*d2+d1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        inter = set(nums1) & set(nums2)\\n        if inter: return min(inter)\\n        d1 = min(nums1)\\n        d2 = min(nums2)\\n        return 10*d1+d2 if d1 < d2 else 10*d2+d1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366512,
                "title": "python3-solution-well-explained-easy-clear",
                "content": "# Intuition:\\nThe problem asks us to find the smallest number that can be formed by concatenating two numbers, one from each of the given lists, nums1 and nums2. If there are common elements in both the lists, the smallest such element can be used to form the smallest number. If there are no common elements, then we need to choose the minimum elements from each list to form the smallest number.\\n\\n# Approach:\\nThe given solution has two parts. The first part checks if there are any common elements in the two lists. If there are, it selects the smallest common element as the starting digit of the smallest number. If there are no common elements, the second part selects the minimum element from each list to form the smallest number.\\n\\nThe code first initializes n as 10, a value that is higher than any possible element in the given lists. It then iterates through each element of nums1 and checks if it is present in nums2. If it is, n is updated to the minimum of its current value and the common element. If there is a common element, the method returns the value of n as the starting digit of the smallest number.\\n\\nIf there are no common elements, the method constructs two possible numbers by concatenating the minimum elements from nums1 and nums2 in different orders. It then returns the minimum of these two numbers as the smallest number.\\n\\n# Complexity:\\n# Time complexity \\nThe time complexity of this solution is O(mn), where m and n are the lengths of nums1 and nums2, respectively. This is because the code iterates through each element of nums1 and checks if it is present in nums2, resulting in an inner loop that runs m*n times in the worst case.\\n\\n# Space complexity\\nThe space complexity of this solution is O(1), because it only uses a fixed amount of additional space to store the variable n.\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        n=10\\n        for i in nums1:\\n            if i in nums2:\\n                n=min(n,i)\\n        if n!=10:\\n            return n\\n        \\n        x=min(nums1)\\n        y=min(nums2)\\n        a=x*10+y\\n        b=y*10+x\\n        return min(a,b)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        n=10\\n        for i in nums1:\\n            if i in nums2:\\n                n=min(n,i)\\n        if n!=10:\\n            return n\\n        \\n        x=min(nums1)\\n        y=min(nums2)\\n        a=x*10+y\\n        b=y*10+x\\n        return min(a,b)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366508,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int a=nums1[0];\\n        int b=nums2[0];\\n        HashSet<Integer> hs1=new HashSet<>();\\n        HashSet<Integer> hs2=new HashSet<>();\\n        for(int i=0;i<nums1.length;i++){\\n            hs1.add(nums1[i]);\\n        }\\n         for(int i=0;i<nums2.length;i++){\\n            hs2.add(nums2[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            if(hs1.contains(nums2[i]))\\n                return nums2[i];\\n        }\\n        if(a==b)\\n            return a;\\n        \\n        if(a<b)\\n        return (a*10)+b;\\n        \\n        return (b*10)+a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int a=nums1[0];\\n        int b=nums2[0];\\n        HashSet<Integer> hs1=new HashSet<>();\\n        HashSet<Integer> hs2=new HashSet<>();\\n        for(int i=0;i<nums1.length;i++){\\n            hs1.add(nums1[i]);\\n        }\\n         for(int i=0;i<nums2.length;i++){\\n            hs2.add(nums2[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            if(hs1.contains(nums2[i]))\\n                return nums2[i];\\n        }\\n        if(a==b)\\n            return a;\\n        \\n        if(a<b)\\n        return (a*10)+b;\\n        \\n        return (b*10)+a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366473,
                "title": "c-easy-and-concise-binary-search-and-sorting-o-n-log-n-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\nO(n log(n)) \\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            int s = 0;\\n            int e = m-1;\\n            while(s <= e) {\\n                int mid = s+(e-s)/2;\\n                if(nums1[i] == nums2[mid]) return nums1[i];\\n                else if(nums1[i] > nums2[mid]) s = mid+1;\\n                else e = mid-1;\\n            }\\n        }\\n        \\n        int min1 = nums1[0];\\n        int min2 = nums2[0];\\n        \\n        if(min1 > min2) return min2*10 + min1;\\n        return min1*10 + min2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            int s = 0;\\n            int e = m-1;\\n            while(s <= e) {\\n                int mid = s+(e-s)/2;\\n                if(nums1[i] == nums2[mid]) return nums1[i];\\n                else if(nums1[i] > nums2[mid]) s = mid+1;\\n                else e = mid-1;\\n            }\\n        }\\n        \\n        int min1 = nums1[0];\\n        int min2 = nums2[0];\\n        \\n        if(min1 > min2) return min2*10 + min1;\\n        return min1*10 + min2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656099,
                "title": "simple-solution-in-python",
                "content": "\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n        for i in nums1:\\n            if i in nums2:\\n                return i\\n                break\\n        else:\\n            return min(nums1[0]*10+nums2[0],nums2[0]*10+nums1[0])\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n        for i in nums1:\\n            if i in nums2:\\n                return i\\n                break\\n        else:\\n            return min(nums1[0]*10+nums2[0],nums2[0]*10+nums1[0])\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472051,
                "title": "form-smallest-number-from-two-digit-arrays-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0, j=0;\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        while(i<nums1.size() && j<nums2.size())\\n        {\\n            if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            else if(nums1[i]>nums2[j])\\n                j++;\\n            else\\n                i++;\\n        }\\n        if(nums1[0]<nums2[0])\\n            return nums1[0]*10+nums2[0];\\n        return nums2[0]*10+nums1[0];\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/1db5be82-d91f-4d49-9e59-72c2d1404cfa_1682917669.6928067.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int i=0, j=0;\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        while(i<nums1.size() && j<nums2.size())\\n        {\\n            if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            else if(nums1[i]>nums2[j])\\n                j++;\\n            else\\n                i++;\\n        }\\n        if(nums1[0]<nums2[0])\\n            return nums1[0]*10+nums2[0];\\n        return nums2[0]*10+nums1[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404618,
                "title": "c-easy-to-understand-math-short-sweet",
                "content": "````\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& v1, vector<int>& v2) {\\n        vector<int> v(10,0);\\n        for(auto &i: v1)v[i]++;\\n        for(auto &i: v2)v[i]++;\\n        for(int i = 1; i < 10; i++)if(v[i]>1)return i;\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        return min({v1[0]*10+v2[0],v1[0]+v2[0]*10});\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& v1, vector<int>& v2) {\\n        vector<int> v(10,0);\\n        for(auto &i: v1)v[i]++;\\n        for(auto &i: v2)v[i]++;\\n        for(int i = 1; i < 10; i++)if(v[i]>1)return i;\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        return min({v1[0]*10+v2[0],v1[0]+v2[0]*10});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382326,
                "title": "simple-approch-with-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int s1 = Integer.MAX_VALUE,s2=Integer.MAX_VALUE,ans=0;\\n\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i:nums2)\\n        {\\n            set.add(i);\\n        }\\n\\n        for(int i:nums1)\\n        {\\n            if(set.contains(i)) return i;\\n        }\\n\\n        ans = nums1[0]*10 + nums2[0];\\n        int ans2 = nums2[0]*10 + nums1[0];\\n\\n        return Math.min(ans,ans2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int s1 = Integer.MAX_VALUE,s2=Integer.MAX_VALUE,ans=0;\\n\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i:nums2)\\n        {\\n            set.add(i);\\n        }\\n\\n        for(int i:nums1)\\n        {\\n            if(set.contains(i)) return i;\\n        }\\n\\n        ans = nums1[0]*10 + nums2[0];\\n        int ans2 = nums2[0]*10 + nums1[0];\\n\\n        return Math.min(ans,ans2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370231,
                "title": "python-elegant-short-set-intersection",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, first: List[int], second: List[int]) -> int:\\n        a, b = sorted((min(first), min(second)))\\n        c = min(set(first) & set(second), default=maxsize)\\n        return min(c, a * 10 + b)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, first: List[int], second: List[int]) -> int:\\n        a, b = sorted((min(first), min(second)))\\n        c = min(set(first) & set(second), default=maxsize)\\n        return min(c, a * 10 + b)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367140,
                "title": "easy-c-solution-beats-100-using-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEasy map solution...\\n1. check for the the number which is present in both array and it must be smallest number for that sort the array in starting and then map the anyone array.\\n2. while checking for the presence in both if it\\'s find true return at that point.\\n3. final case when the array does not have any common number then two cases are possible  i.e nums1 = [1,2,4] nums2= [5,6,7] nums1[0]*10 + nums[0] = 15 or nums2[0]*10 + nums1[0]= 51 since we have to return the minimum so return the minimum of both\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(nlogn)  -> for sortting the array O(n) for liner mapping \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int> mp1;\\n         sort(nums1.begin(),nums1.end());\\n         sort(nums2.begin(),nums2.end());\\n        for(auto it : nums1)\\n        {\\n            mp1[it]++;\\n        }\\n        for(auto it : nums2)\\n        {\\n            if(mp1[it] != 0)\\n            return it;\\n        }\\n     return min(nums1[0]*10 + nums2[0],nums2[0]*10 + nums1[0]);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int> mp1;\\n         sort(nums1.begin(),nums1.end());\\n         sort(nums2.begin(),nums2.end());\\n        for(auto it : nums1)\\n        {\\n            mp1[it]++;\\n        }\\n        for(auto it : nums2)\\n        {\\n            if(mp1[it] != 0)\\n            return it;\\n        }\\n     return min(nums1[0]*10 + nums2[0],nums2[0]*10 + nums1[0]);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366785,
                "title": "javascript-direct-way-61ms",
                "content": "if have intersection, find the smallest intersected digit, otherwise, pick smallest from both array\\n```\\nconst minNumber = (a, b) => {\\n    let both = [];\\n    for (const x of a) {\\n        if (b.includes(x)) both.push(x);\\n    }\\n    if (both.length > 0) return Math.min(...both);\\n    let pa = Math.min(...a), pb = Math.min(...b);\\n    return pa < pb ? pa + \"\" + pb : pb + \"\" + pa; \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nconst minNumber = (a, b) => {\\n    let both = [];\\n    for (const x of a) {\\n        if (b.includes(x)) both.push(x);\\n    }\\n    if (both.length > 0) return Math.min(...both);\\n    let pa = Math.min(...a), pb = Math.min(...b);\\n    return pa < pb ? pa + \"\" + pb : pb + \"\" + pa; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366706,
                "title": "java-hashset-explained",
                "content": "## Approach explained using comments:\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        // Create two sets to record the digits from nums1 and nums2\\n        Set<Integer> n1 = new HashSet<>();\\n        Set<Integer> n2 = new HashSet<>();\\n        for (int i : nums1) n1.add(i);\\n        for (int i : nums2) n2.add(i);\\n\\n        // Time to get common minimum digit\\n        int min = 10;\\n        for (int i : n1) {  // iterate on set n1\\n            // if that digit is present in set n2\\n            if (n2.contains(i)) {\\n                // update the common minimum\\n                min = Math.min(min, i);\\n            }\\n        }\\n        // if the common minimum was updated, \\n        // it won\\'t remain as the default initialized value\\n        // so return it\\n        if (min != 10) {\\n            return min;\\n        }\\n        \\n        // Otherwise sort both the arrays\\n        Arrays.sort(nums1); \\n        Arrays.sort(nums2);\\n        // and form the minimum number using the two numbers\\n        // at the 0-th index of both the sorted arrays\\n        int ans = Math.min(nums1[0], nums2[0]) * 10 + Math.max(nums1[0], nums2[0]);\\n        return ans;     // return the number\\n    }\\n}\\n\\n// This can be done without sorting as well, \\n// by iterating over both the arrays and\\n// recording the minimum digit from both arrays\\n```\\n---\\n\\n### Clean solution:\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> n1 = new HashSet<>();\\n        Set<Integer> n2 = new HashSet<>();\\n        for (int i : nums1) n1.add(i);\\n        for (int i : nums2) n2.add(i);\\n\\n        int min = 10;\\n        for (int i : n1) { \\n            if (n2.contains(i)) \\n                min = Math.min(min, i);\\n            \\n        if (min != 10) \\n            return min;\\n        \\n        Arrays.sort(nums1); \\n        Arrays.sort(nums2);\\n        int a = Math.min(nums1[0], nums2[0]);\\n        int b = Math.max(nums1[0], nums2[0]);\\n        return a * 10 + b;     \\n    }\\n}\\n```\\n##### Time complexity: $$O(2*9) + O(9) + O(2*9.log(9)) => O(n)$$\\n##### Space complexity: $$O(2*9) => O(n)$$\\n> $$n = 9$$ at worst case.",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        // Create two sets to record the digits from nums1 and nums2\\n        Set<Integer> n1 = new HashSet<>();\\n        Set<Integer> n2 = new HashSet<>();\\n        for (int i : nums1) n1.add(i);\\n        for (int i : nums2) n2.add(i);\\n\\n        // Time to get common minimum digit\\n        int min = 10;\\n        for (int i : n1) {  // iterate on set n1\\n            // if that digit is present in set n2\\n            if (n2.contains(i)) {\\n                // update the common minimum\\n                min = Math.min(min, i);\\n            }\\n        }\\n        // if the common minimum was updated, \\n        // it won\\'t remain as the default initialized value\\n        // so return it\\n        if (min != 10) {\\n            return min;\\n        }\\n        \\n        // Otherwise sort both the arrays\\n        Arrays.sort(nums1); \\n        Arrays.sort(nums2);\\n        // and form the minimum number using the two numbers\\n        // at the 0-th index of both the sorted arrays\\n        int ans = Math.min(nums1[0], nums2[0]) * 10 + Math.max(nums1[0], nums2[0]);\\n        return ans;     // return the number\\n    }\\n}\\n\\n// This can be done without sorting as well, \\n// by iterating over both the arrays and\\n// recording the minimum digit from both arrays\\n```\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> n1 = new HashSet<>();\\n        Set<Integer> n2 = new HashSet<>();\\n        for (int i : nums1) n1.add(i);\\n        for (int i : nums2) n2.add(i);\\n\\n        int min = 10;\\n        for (int i : n1) { \\n            if (n2.contains(i)) \\n                min = Math.min(min, i);\\n            \\n        if (min != 10) \\n            return min;\\n        \\n        Arrays.sort(nums1); \\n        Arrays.sort(nums2);\\n        int a = Math.min(nums1[0], nums2[0]);\\n        int b = Math.max(nums1[0], nums2[0]);\\n        return a * 10 + b;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366679,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        for(int i=0; i<nums1.size(); i++) {\\n            for(int j=0; j<nums2.size(); j++) {\\n                if(nums1[i] == nums2[j]) return nums1[i];\\n            }\\n        }\\n        int first = *min_element(nums1.begin(), nums1.end());\\n        int second = *min_element(nums2.begin(), nums2.end());\\n        int ans = min(first * 10 + second, second * 10 + first);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        for(int i=0; i<nums1.size(); i++) {\\n            for(int j=0; j<nums2.size(); j++) {\\n                if(nums1[i] == nums2[j]) return nums1[i];\\n            }\\n        }\\n        int first = *min_element(nums1.begin(), nums1.end());\\n        int second = *min_element(nums2.begin(), nums2.end());\\n        int ans = min(first * 10 + second, second * 10 + first);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366658,
                "title": "easy-c",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> x(10,0),y(10,0);\\n        int mn1=10,mn2=10;\\n        for(int i=0;i<nums1.size();i++){\\n            x[nums1[i]]=1;\\n            mn1=min(mn1,nums1[i]);\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            y[nums2[i]]=1;\\n            mn2=min(mn2,nums2[i]);\\n        }\\n        for(int i=0;i<10;i++){\\n            if(x[i]&&y[i]) return i;\\n        }\\n        return min(mn1,mn2)*10+max(mn1,mn2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> x(10,0),y(10,0);\\n        int mn1=10,mn2=10;\\n        for(int i=0;i<nums1.size();i++){\\n            x[nums1[i]]=1;\\n            mn1=min(mn1,nums1[i]);\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            y[nums2[i]]=1;\\n            mn2=min(mn2,nums2[i]);\\n        }\\n        for(int i=0;i<10;i++){\\n            if(x[i]&&y[i]) return i;\\n        }\\n        return min(mn1,mn2)*10+max(mn1,mn2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366558,
                "title": "java-take-intersection-self-explanatory",
                "content": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n\\t   //Sorted to find smallest element which has elements in both arrays\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        Set<Integer> set = new HashSet<>(); //To avoid duplicate values\\n\\t\\t\\n        for(int i : nums1) set.add(i);\\n        for(int n : nums2) if(set.contains(n)) return n; //If any common value found from both arrays, return it\\n        \\n       \\n       if(nums1[0] < nums2[0]) return nums1[0] * 10 + nums2[0];\\n       return nums2[0] * 10 + nums1[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n\\t   //Sorted to find smallest element which has elements in both arrays\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        Set<Integer> set = new HashSet<>(); //To avoid duplicate values\\n\\t\\t\\n        for(int i : nums1) set.add(i);\\n        for(int n : nums2) if(set.contains(n)) return n; //If any common value found from both arrays, return it\\n        \\n       \\n       if(nums1[0] < nums2[0]) return nums1[0] * 10 + nums2[0];\\n       return nums2[0] * 10 + nums1[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366511,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>mp;\\n        for(auto x: nums1) mp[x]++;\\n        for(auto x: nums2) mp[x]++;\\n        int mn1=*min_element(nums1.begin(),nums1.end());\\n        int mn2=*min_element(nums2.begin(),nums2.end());\\n        for(auto x: mp){\\n            if(x.second>1) return x.first;\\n        }\\n        string s;\\n        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);\\n        else s=to_string(mn2)+ to_string(mn1);\\n        return stoi(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>mp;\\n        for(auto x: nums1) mp[x]++;\\n        for(auto x: nums2) mp[x]++;\\n        int mn1=*min_element(nums1.begin(),nums1.end());\\n        int mn2=*min_element(nums2.begin(),nums2.end());\\n        for(auto x: mp){\\n            if(x.second>1) return x.first;\\n        }\\n        string s;\\n        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);\\n        else s=to_string(mn2)+ to_string(mn1);\\n        return stoi(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796688,
                "title": "beats-98-in-java",
                "content": "# Intuition\\nSort both the arrays, if there is a similar element return it or return min*10 +max elements\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\nPls upvote...!\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n   int ans=0;\\n   Arrays.sort(nums1);Arrays.sort(nums2);\\n        for(int i=0;i<nums1.length;i++){\\n            for(int j=0;j<nums2.length;j++){\\n                if(nums1[i]==nums2[j]) return nums1[i];\\n        }\\n    }\\n    int min=Math.min(nums1[0],nums2[0]);\\n    int max=Math.max(nums1[0],nums2[0]);\\n    return (min*10 +max);\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n   int ans=0;\\n   Arrays.sort(nums1);Arrays.sort(nums2);\\n        for(int i=0;i<nums1.length;i++){\\n            for(int j=0;j<nums2.length;j++){\\n                if(nums1[i]==nums2[j]) return nums1[i];\\n        }\\n    }\\n    int min=Math.min(nums1[0],nums2[0]);\\n    int max=Math.max(nums1[0],nums2[0]);\\n    return (min*10 +max);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793989,
                "title": "beginner-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        int min1=nums1[0];\\n        Arrays.sort(nums2);\\n        int min2=nums2[0];\\n        HashSet<Integer> set= new HashSet<>();\\n        for(int n1: nums1) set.add(n1);\\n        for(int n2: nums2) {\\n            if(set.contains(n2))\\n                 return n2;\\n        }\\n  \\n       return min1<min2? min1*10+min2:min2*10+min1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        int min1=nums1[0];\\n        Arrays.sort(nums2);\\n        int min2=nums2[0];\\n        HashSet<Integer> set= new HashSet<>();\\n        for(int n1: nums1) set.add(n1);\\n        for(int n2: nums2) {\\n            if(set.contains(n2))\\n                 return n2;\\n        }\\n  \\n       return min1<min2? min1*10+min2:min2*10+min1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674880,
                "title": "the-best-memory-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Let\\'s sort the array 1\\n2. Using the for loop, we will find out if there is at least one minimum number of array 1 in array 2\\n3. If array 2 contains at least one minimum number from array 1, we will return it\\n4. Otherwise, we will find the minimum number of the second array\\n5. Finally we find the minimum number composed of the first element of the sorted array 1 and the minimum number of the array 2\\n\\n\\n# Code\\n```\\nfunction minNumber(nums1: number[], nums2: number[]): number {\\n    nums1.sort((a, b) => a - b);\\n\\n    for (let i = 0; i < nums1.length; i++) {\\n        if (nums2.includes(nums1[i])) {\\n            return nums1[i];\\n        }\\n    }\\n\\n    const firstChar = nums1[0];\\n    const secondChar = Math.min(...nums2);\\n    return Math.min(+`${firstChar}${secondChar}`, +`${secondChar}${firstChar}`)\\n};\\n```\\n\\n![form-smallest-number-from-two-digit-arrays.png](https://assets.leetcode.com/users/images/ffccc7cd-8a74-4834-8b05-ff8f511638ca_1687547843.8634896.png)",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minNumber(nums1: number[], nums2: number[]): number {\\n    nums1.sort((a, b) => a - b);\\n\\n    for (let i = 0; i < nums1.length; i++) {\\n        if (nums2.includes(nums1[i])) {\\n            return nums1[i];\\n        }\\n    }\\n\\n    const firstChar = nums1[0];\\n    const secondChar = Math.min(...nums2);\\n    return Math.min(+`${firstChar}${secondChar}`, +`${secondChar}${firstChar}`)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3438688,
                "title": "very-easy",
                "content": "\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v(10);\\n        for(int i=0;i<nums1.size();i++) v[nums1[i]]++;\\n        for(int i=0;i<nums2.size();i++) v[nums2[i]]++;\\n\\n         for(int i=1;i<v.size();i++){\\n             if(v[i]==2) return i;\\n         }\\n         int ans =0;\\n         int a = *min_element(nums1.begin(), nums1.end());\\n        int b = *min_element(nums2.begin(), nums2.end());\\n        // we have to swap if a is less than b\\n        if(b<a) swap(a,b);\\n        ans = a*10 +b;\\n        return ans;\\n\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Enumeration"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v(10);\\n        for(int i=0;i<nums1.size();i++) v[nums1[i]]++;\\n        for(int i=0;i<nums2.size();i++) v[nums2[i]]++;\\n\\n         for(int i=1;i<v.size();i++){\\n             if(v[i]==2) return i;\\n         }\\n         int ans =0;\\n         int a = *min_element(nums1.begin(), nums1.end());\\n        int b = *min_element(nums2.begin(), nums2.end());\\n        // we have to swap if a is less than b\\n        if(b<a) swap(a,b);\\n        ans = a*10 +b;\\n        return ans;\\n\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422379,
                "title": "simple-approach-c",
                "content": "# Complexity\\n- Time complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2){\\n        int ans=0,first=0,second=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        if(nums1[0]<nums2[0]){\\n            first=nums1[0];\\n            second=nums2[0];\\n        }\\n        else{\\n            first=nums2[0];\\n            second=nums1[0];\\n        }\\n        for(int i=0, j=0; i < nums1.size() && j < nums2.size(); ){\\n    if(nums1[i] == nums2[j]){\\n       first=0;\\n       second=nums1[i];\\n       break;\\n        i++;\\n        j++;\\n    }\\n    else if(nums1[i] < nums2[j]){\\n        i++;\\n    }\\n    else{\\n        j++;\\n    }\\n}\\n       ans=first*10+second;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2){\\n        int ans=0,first=0,second=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        if(nums1[0]<nums2[0]){\\n            first=nums1[0];\\n            second=nums2[0];\\n        }\\n        else{\\n            first=nums2[0];\\n            second=nums1[0];\\n        }\\n        for(int i=0, j=0; i < nums1.size() && j < nums2.size(); ){\\n    if(nums1[i] == nums2[j]){\\n       first=0;\\n       second=nums1[i];\\n       break;\\n        i++;\\n        j++;\\n    }\\n    else if(nums1[i] < nums2[j]){\\n        i++;\\n    }\\n    else{\\n        j++;\\n    }\\n}\\n       ans=first*10+second;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417532,
                "title": "be-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf there is a digit that is in both the lists, then that is the answer.\\nElse, the concatenation of the two smallest numbers from the list will be the answer. See the code for more clarification.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n        for i in nums1:\\n            if i in nums2:\\n                return i\\n        ans = (str(nums1[0]) + str(nums2[0])) if nums1[0] < nums2[0] else str(nums2[0]) + str(nums1[0]) \\n        ans = int(ans)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n        for i in nums1:\\n            if i in nums2:\\n                return i\\n        ans = (str(nums1[0]) + str(nums2[0])) if nums1[0] < nums2[0] else str(nums2[0]) + str(nums1[0]) \\n        ans = int(ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393332,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun minNumber(nums1: IntArray, nums2: IntArray): Int {\\n        val set = HashSet<Int>()\\n        var (min, min1, min2) = arrayOf(10, 10, 10)\\n        for (num in nums1) {\\n            min1 = minOf(min1, num)\\n            set.add(num)\\n        }\\n        for (num in nums2) {\\n            min2 = minOf(min2, num)\\n            if (set.contains(num)) min = minOf(min, num)\\n        }\\n        if (min != 10) return min\\n        return minOf(min1, min2) * 10 + maxOf(min1, min2)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minNumber(nums1: IntArray, nums2: IntArray): Int {\\n        val set = HashSet<Int>()\\n        var (min, min1, min2) = arrayOf(10, 10, 10)\\n        for (num in nums1) {\\n            min1 = minOf(min1, num)\\n            set.add(num)\\n        }\\n        for (num in nums2) {\\n            min2 = minOf(min2, num)\\n            if (set.contains(num)) min = minOf(min, num)\\n        }\\n        if (min != 10) return min\\n        return minOf(min1, min2) * 10 + maxOf(min1, min2)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387450,
                "title": "my-first-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums1\\n     * @param Integer[] $nums2\\n     * @return Integer\\n     */\\n    function minNumber($nums1, $nums2) {\\n        sort($nums1);\\n        sort($nums2);\\n\\n        for ($i=0; $i < count($nums1); $i++){\\n            if(array_search($nums1[$i], $nums2) !== false) return $nums1[$i];\\n        }\\n\\n        $min1 = min($nums1);\\n        $min2 = min($nums2);\\n\\n        return strval(min($min1, $min2)) . strval(max($min1, $min2));\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums1\\n     * @param Integer[] $nums2\\n     * @return Integer\\n     */\\n    function minNumber($nums1, $nums2) {\\n        sort($nums1);\\n        sort($nums2);\\n\\n        for ($i=0; $i < count($nums1); $i++){\\n            if(array_search($nums1[$i], $nums2) !== false) return $nums1[$i];\\n        }\\n\\n        $min1 = min($nums1);\\n        $min2 = min($nums2);\\n\\n        return strval(min($min1, $min2)) . strval(max($min1, $min2));\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371203,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& n1, vector<int>& n2) {\\n        sort(n1.begin(),n1.end());\\n        sort(n2.begin(),n2.end());\\n        set<int>s;\\n        for(int i=0;i<n1.size();i++){\\n            s.insert(n1[i]);\\n        }\\n        for(int i=0;i<n2.size();i++){\\n            if(s.count(n2[i])!=0){\\n                return n2[i];\\n            }\\n        }\\n        if(n1[0]<n2[0])\\n            return n1[0]*10+n2[0];\\n        else\\n            return n2[0]*10+n1[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& n1, vector<int>& n2) {\\n        sort(n1.begin(),n1.end());\\n        sort(n2.begin(),n2.end());\\n        set<int>s;\\n        for(int i=0;i<n1.size();i++){\\n            s.insert(n1[i]);\\n        }\\n        for(int i=0;i<n2.size();i++){\\n            if(s.count(n2[i])!=0){\\n                return n2[i];\\n            }\\n        }\\n        if(n1[0]<n2[0])\\n            return n1[0]*10+n2[0];\\n        else\\n            return n2[0]*10+n1[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371114,
                "title": "form-smallest-number-from-two-digit-arrays-easy-java-sol",
                "content": "# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int temp = getCommon(nums1, nums2);\\n        if(temp > 0) return temp;\\n        int a = getMinimum(nums1);\\n        if(isPresent(nums2, a)){\\n            return a;\\n        }\\n        int b = getMinimum(nums2);\\n        if(a < b){\\n            return a*10+b;\\n        }else{\\n            return b*10+a;\\n        }\\n    }\\n    public int getMinimum(int[] nums){\\n        int min = Integer.MAX_VALUE;\\n        int ans;\\n        for(int i = 0; i < nums.length; i++){\\n            min = Math.min(min, nums[i]);\\n            ans = min;\\n        }\\n        return min;\\n    }\\n    public boolean isPresent(int[] nums, int k){\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == k) return true;\\n        }\\n        return false;\\n    }\\n    public int getCommon(int[] nums1, int[] nums2){\\n        int min = Integer.MAX_VALUE;\\n        List<Integer> list = new ArrayList<Integer>();\\n        int ans=-1;\\n        for(int i = 0; i < nums1.length; i++){\\n            for(int j = 0; j < nums2.length; j++){\\n                if(nums1[i] == nums2[j]){\\n                    list.add(nums1[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<list.size(); i++){\\n            min = Math.min(min, list.get(i));\\n            ans = min;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int temp = getCommon(nums1, nums2);\\n        if(temp > 0) return temp;\\n        int a = getMinimum(nums1);\\n        if(isPresent(nums2, a)){\\n            return a;\\n        }\\n        int b = getMinimum(nums2);\\n        if(a < b){\\n            return a*10+b;\\n        }else{\\n            return b*10+a;\\n        }\\n    }\\n    public int getMinimum(int[] nums){\\n        int min = Integer.MAX_VALUE;\\n        int ans;\\n        for(int i = 0; i < nums.length; i++){\\n            min = Math.min(min, nums[i]);\\n            ans = min;\\n        }\\n        return min;\\n    }\\n    public boolean isPresent(int[] nums, int k){\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == k) return true;\\n        }\\n        return false;\\n    }\\n    public int getCommon(int[] nums1, int[] nums2){\\n        int min = Integer.MAX_VALUE;\\n        List<Integer> list = new ArrayList<Integer>();\\n        int ans=-1;\\n        for(int i = 0; i < nums1.length; i++){\\n            for(int j = 0; j < nums2.length; j++){\\n                if(nums1[i] == nums2[j]){\\n                    list.add(nums1[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<list.size(); i++){\\n            min = Math.min(min, list.get(i));\\n            ans = min;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370184,
                "title": "c-5-lines-faster-100",
                "content": "**Code**\\n```c++\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& l, vector<int>& r) {\\n        vector<int> cntl(10, 0), cntr(10, 0);\\n        auto ml = INT_MAX, mr = INT_MAX;\\n        for (auto i: l) cntl[i]++, ml = min(ml, i);\\n        for (auto i: r) cntr[i]++, mr = min(mr, i);\\n        for (int i = 0; i < 10; i++)  if (cntl[i] && cntr[i]) return i;\\n        return min(ml, mr) * 10 + max(ml, mr);\\n    }\\n};\\n```\\n\\n**Complexity**\\nTime: `O(n)`\\nSpace: `O(1)`\\n\\n\\n**Result**\\n\\n![image](https://assets.leetcode.com/users/images/60f92e63-2b59-4ed1-8d62-f7472cfc0cee_1680429860.541825.png)\\n",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& l, vector<int>& r) {\\n        vector<int> cntl(10, 0), cntr(10, 0);\\n        auto ml = INT_MAX, mr = INT_MAX;\\n        for (auto i: l) cntl[i]++, ml = min(ml, i);\\n        for (auto i: r) cntr[i]++, mr = min(mr, i);\\n        for (int i = 0; i < 10; i++)  if (cntl[i] && cntr[i]) return i;\\n        return min(ml, mr) * 10 + max(ml, mr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369602,
                "title": "python3-straightforward-solution-with-explanation",
                "content": "First we check if there is an intersection of two arrays. If yes, then the answer will be one digit. Otherwise we need to check permutation of the two minimum digits from each array and choose the smallest.\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        intersection = list(set(nums1) & set(nums2))\\n        \\n        if len(intersection):\\n            return min(intersection)\\n        else:\\n            return min(int(str(min(nums1)) + str(min(nums2))), int(str(min(nums2)) + str(min(nums1))))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        intersection = list(set(nums1) & set(nums2))\\n        \\n        if len(intersection):\\n            return min(intersection)\\n        else:\\n            return min(int(str(min(nums1)) + str(min(nums2))), int(str(min(nums2)) + str(min(nums1))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369396,
                "title": "easiest-solution-100-accuracy-loops",
                "content": "\\n# Approach\\nThere can be two possible cases\\n1. the number is formed by taking the smallest numbers from both the arrays\\n2. The number is common to both arrays\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*m)+O(nlogn)+O(mlogm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0; j < m; j++){\\n                 if(nums1[i]==nums2[j])\\n                 return nums1[i];            }\\n        }\\n        return min((nums1[0]*10)+nums2[0],(nums2[0]*10)+nums1[0]);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0; j < m; j++){\\n                 if(nums1[i]==nums2[j])\\n                 return nums1[i];            }\\n        }\\n        return min((nums1[0]*10)+nums2[0],(nums2[0]*10)+nums1[0]);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368065,
                "title": "c-logic-based-conditions-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int mini1=nums1[0],mini2=nums2[0];\\n        \\n        for(auto x:nums1){\\n            mini1=min(mini1,x);\\n        }\\n         for(auto x:nums2){\\n            mini2=min(mini2,x);\\n        }\\n        int commin=99999;\\n        for(auto x:nums1){\\n            for(auto y:nums2){\\n                if(x==y)\\n                   commin=min(x,commin); \\n            }\\n        }\\n        if(mini1==mini2)\\n            return min(mini1,commin);\\n        \\n        if(mini1<mini2)\\n        return min(mini1*10 +mini2,commin); \\n        \\n        return min(mini2*10 +mini1,commin); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int mini1=nums1[0],mini2=nums2[0];\\n        \\n        for(auto x:nums1){\\n            mini1=min(mini1,x);\\n        }\\n         for(auto x:nums2){\\n            mini2=min(mini2,x);\\n        }\\n        int commin=99999;\\n        for(auto x:nums1){\\n            for(auto y:nums2){\\n                if(x==y)\\n                   commin=min(x,commin); \\n            }\\n        }\\n        if(mini1==mini2)\\n            return min(mini1,commin);\\n        \\n        if(mini1<mini2)\\n        return min(mini1*10 +mini2,commin); \\n        \\n        return min(mini2*10 +mini1,commin); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367618,
                "title": "simple-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        map<int,int> m;\\n        for(int i=0;i<nums1.size();i++){\\n            m[nums1[i]]++;\\n        }\\n         for(int i=0;i<nums2.size();i++){\\n            m[nums2[i]]++;\\n        }\\n        for(auto it: m){\\n            if(it.second==2)\\n                return it.first;\\n                \\n        }\\n        int x= *min_element(nums1.begin(),nums1.end());\\n          int y= *min_element(nums2.begin(),nums2.end());\\n        if(x>y)\\n            return y*10+x;\\n        else if(x==y) return x;\\n        else  return x*10 + y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        map<int,int> m;\\n        for(int i=0;i<nums1.size();i++){\\n            m[nums1[i]]++;\\n        }\\n         for(int i=0;i<nums2.size();i++){\\n            m[nums2[i]]++;\\n        }\\n        for(auto it: m){\\n            if(it.second==2)\\n                return it.first;\\n                \\n        }\\n        int x= *min_element(nums1.begin(),nums1.end());\\n          int y= *min_element(nums2.begin(),nums2.end());\\n        if(x>y)\\n            return y*10+x;\\n        else if(x==y) return x;\\n        else  return x*10 + y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367185,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        for i in 1...9{\\n            if nums1.contains(i) && nums2.contains(i){\\n                return i\\n            }\\n        }\\n        \\n        var (nums, ans) = ([Int](), 0)\\n        nums.append(nums1.min()!)\\n        nums.append(nums2.min()!)\\n        nums.sort()\\n        \\n        for x in nums { ans = ans*10 + x }\\n        return ans\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        for i in 1...9{\\n            if nums1.contains(i) && nums2.contains(i){\\n                return i\\n            }\\n        }\\n        \\n        var (nums, ans) = ([Int](), 0)\\n        nums.append(nums1.min()!)\\n        nums.append(nums2.min()!)\\n        nums.sort()\\n        \\n        for x in nums { ans = ans*10 + x }\\n        return ans\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367074,
                "title": "c-easy-and-shorter-solution-100-accepted-intuitive-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n,m;\\n        n = nums1.size();\\n        m =nums2.size();\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        int i,j;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    \\n                }\\n            }\\n        }\\n        \\n        int x=nums1[0];\\n        int y = nums2[0];\\n        \\n        if(x<y)\\n            return 10*x+y;\\n        else\\n            return 10*y+x;\\n        \\n       \\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n,m;\\n        n = nums1.size();\\n        m =nums2.size();\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        int i,j;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    \\n                }\\n            }\\n        }\\n        \\n        int x=nums1[0];\\n        int y = nums2[0];\\n        \\n        if(x<y)\\n            return 10*x+y;\\n        else\\n            return 10*y+x;\\n        \\n       \\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366913,
                "title": "100-fast-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int com= INT_MAX;\\n        for (auto val: nums1){\\n            if (count(nums2.begin(),nums2.end(),val)>0)com= min(com,val);\\n        }\\n        if (com!= INT_MAX)return com;\\n        int a= *min_element(nums1.begin(),nums1.end());\\n        int b= *min_element(nums2.begin(),nums2.end());\\n        int m1= min(a,b);\\n        int m2= max(a,b);\\n        return(m1*10+m2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int com= INT_MAX;\\n        for (auto val: nums1){\\n            if (count(nums2.begin(),nums2.end(),val)>0)com= min(com,val);\\n        }\\n        if (com!= INT_MAX)return com;\\n        int a= *min_element(nums1.begin(),nums1.end());\\n        int b= *min_element(nums2.begin(),nums2.end());\\n        int m1= min(a,b);\\n        int m2= max(a,b);\\n        return(m1*10+m2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366907,
                "title": "sorting-c-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int m=nums1.size(),n=nums2.size();\\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            if(nums1[i]>nums2[j])\\n                j++;\\n            else if(nums1[i]<nums2[j])\\n                i++;\\n            else\\n                return nums1[i];\\n        }\\n        int a=nums1[0],b=nums2[0];\\n        if(a<b)\\n            return a*10+b;\\n        else if(a==b)\\n            return a;\\n        else\\n            return b*10+a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int m=nums1.size(),n=nums2.size();\\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            if(nums1[i]>nums2[j])\\n                j++;\\n            else if(nums1[i]<nums2[j])\\n                i++;\\n            else\\n                return nums1[i];\\n        }\\n        int a=nums1[0],b=nums2[0];\\n        if(a<b)\\n            return a*10+b;\\n        else if(a==b)\\n            return a;\\n        else\\n            return b*10+a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366812,
                "title": "easy-solution-t-c-o-nlogn-s-c-o-1",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the element is present in both the arrays then return that particular element. We have used the helper function that does the same.\\nNow if there is no element that is common in both the arrays, then simply take the minimum element from both the arrays and return the minimum number that can be formed using the two.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&nums1,vector<int>& nums2){\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i = 0, j = 0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]){\\n                return nums1[i];\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n// return -1 if no common element is present\\n        return -1;\\n    }\\n    \\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int result=0;\\n//helper function to check if there is any common element in the given arrays.\\n        int common = helper(nums1, nums2);\\n        if (common != -1) {\\n            return common;\\n        }\\n        else{\\n            int num1=*min_element(nums1.begin(),nums1.end());\\n            int num2=*min_element(nums2.begin(),nums2.end());\\n            result = (num1 < num2) ? num1 * 10 + num2 : num2 * 10 + num1;\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&nums1,vector<int>& nums2){\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i = 0, j = 0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]){\\n                return nums1[i];\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n// return -1 if no common element is present\\n        return -1;\\n    }\\n    \\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int result=0;\\n//helper function to check if there is any common element in the given arrays.\\n        int common = helper(nums1, nums2);\\n        if (common != -1) {\\n            return common;\\n        }\\n        else{\\n            int num1=*min_element(nums1.begin(),nums1.end());\\n            int num2=*min_element(nums2.begin(),nums2.end());\\n            result = (num1 < num2) ? num1 * 10 + num2 : num2 * 10 + num1;\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366778,
                "title": "easiest-c-code-beats-100-clean-and-understandable",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=INT_MAX;\\n        int n1=0;\\n        int n2=0;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j]){\\n                    ans=min(ans,nums1[i]);\\n                }\\n                else{\\n                    n1=nums1[i]*10+nums2[j];\\n                    n2=nums2[j]*10+nums1[i];\\n                    ans=min(ans,min(n1,n2));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=INT_MAX;\\n        int n1=0;\\n        int n2=0;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j]){\\n                    ans=min(ans,nums1[i]);\\n                }\\n                else{\\n                    n1=nums1[i]*10+nums2[j];\\n                    n2=nums2[j]*10+nums1[i];\\n                    ans=min(ans,min(n1,n2));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366738,
                "title": "easy-peasy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j])return nums1[i];\\n            }\\n        }\\n        if(nums1[0]<nums2[0])return nums1[0]*10+nums2[0];\\n        return  nums2[0]*10+nums1[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j])return nums1[i];\\n            }\\n        }\\n        if(nums1[0]<nums2[0])return nums1[0]*10+nums2[0];\\n        return  nums2[0]*10+nums1[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366727,
                "title": "easy-just-read-the-simple-code",
                "content": "\\n```\\n     int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int m = INT_MAX;\\n        int n = INT_MAX;\\n        \\n        map<int,int> map;\\n        for(int i: nums1){\\n            m = min(m,i);\\n            map[i]++;\\n        }\\n        for(int &i: nums2 ){\\n            n = min(n,i);\\n            map[i]--;\\n        }\\n        \\n        for(auto &i:map){\\n            if(i.second == 0){\\n                return i.first;\\n            }\\n        }\\n        \\n        int ans;\\n        if(n>m){\\n            ans = m;\\n            ans *= 10;\\n            ans+= n;\\n            return ans;\\n        }\\n        ans = n;\\n        ans *= 10;\\n        ans+= m;\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n     int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int m = INT_MAX;\\n        int n = INT_MAX;\\n        \\n        map<int,int> map;\\n        for(int i: nums1){\\n            m = min(m,i);\\n            map[i]++;\\n        }\\n        for(int &i: nums2 ){\\n            n = min(n,i);\\n            map[i]--;\\n        }\\n        \\n        for(auto &i:map){\\n            if(i.second == 0){\\n                return i.first;\\n            }\\n        }\\n        \\n        int ans;\\n        if(n>m){\\n            ans = m;\\n            ans *= 10;\\n            ans+= n;\\n            return ans;\\n        }\\n        ans = n;\\n        ans *= 10;\\n        ans+= m;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366655,
                "title": "easy-and-fast-execution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minNumber(int* nums1, int nums1Size, int* nums2, int nums2Size)\\n{\\n    int i,j;\\n    int val=99;\\n    \\n     for(i=0;i<nums1Size;i++)\\n     {     for(j=0;j<nums2Size;j++)\\n         {\\n            if(nums1[i]==nums2[j])\\n            {\\n                    \\n                    if(nums1[i]<val)\\n                        val=nums1[i];\\n            }\\n         }\\n        \\n     }\\n    if(val!=99)\\n        return val;\\n    for(i=0;i<nums1Size;i++)\\n    {\\n            if(nums1[0]>nums1[i])\\n            nums1[0]=nums1[i];\\n    }\\n    for(j=0;j<nums2Size;j++)\\n    {\\n        if(nums2[0]>nums2[j])\\n        nums2[0]=nums2[j];\\n    }\\n    if(nums1[0]<nums2[0])\\n    {val=(nums1[0])*10+nums2[0];\\n    return val;}\\n    else\\n    val=(nums2[0]*10)+nums1[0];\\n    return val;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minNumber(int* nums1, int nums1Size, int* nums2, int nums2Size)\\n{\\n    int i,j;\\n    int val=99;\\n    \\n     for(i=0;i<nums1Size;i++)\\n     {     for(j=0;j<nums2Size;j++)\\n         {\\n            if(nums1[i]==nums2[j])\\n            {\\n                    \\n                    if(nums1[i]<val)\\n                        val=nums1[i];\\n            }\\n         }\\n        \\n     }\\n    if(val!=99)\\n        return val;\\n    for(i=0;i<nums1Size;i++)\\n    {\\n            if(nums1[0]>nums1[i])\\n            nums1[0]=nums1[i];\\n    }\\n    for(j=0;j<nums2Size;j++)\\n    {\\n        if(nums2[0]>nums2[j])\\n        nums2[0]=nums2[j];\\n    }\\n    if(nums1[0]<nums2[0])\\n    {val=(nums1[0])*10+nums2[0];\\n    return val;}\\n    else\\n    val=(nums2[0]*10)+nums1[0];\\n    return val;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366640,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let set1 = Set(nums1)\\n        let set2 = Set(nums2)\\n        let intersection = Array(set1.intersection(set2)).sorted()\\n        if (intersection.count > 0) { return intersection[0] }\\n        else { \\n            let num1 = nums1.sorted()[0]\\n            let num2 = nums2.sorted()[0]\\n            if (num1 < num2) { \\n                return num1 * 10 + num2\\n            } else { \\n                return num2 * 10 + num1\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let set1 = Set(nums1)\\n        let set2 = Set(nums2)\\n        let intersection = Array(set1.intersection(set2)).sorted()\\n        if (intersection.count > 0) { return intersection[0] }\\n        else { \\n            let num1 = nums1.sorted()[0]\\n            let num2 = nums2.sorted()[0]\\n            if (num1 < num2) { \\n                return num1 * 10 + num2\\n            } else { \\n                return num2 * 10 + num1\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366596,
                "title": "ez",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int a= *min_element(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        unordered_map<int,int> mp;\\n        for(auto i: nums1) mp[i]++;\\n        for(auto i: nums2) {\\n            if(mp.find(i)!=mp.end()) return i;\\n        }\\n        if(a<nums2[0]) return (a*10 +nums2[0]);\\n        else return (nums2[0]*10+a);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int a= *min_element(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        unordered_map<int,int> mp;\\n        for(auto i: nums1) mp[i]++;\\n        for(auto i: nums2) {\\n            if(mp.find(i)!=mp.end()) return i;\\n        }\\n        if(a<nums2[0]) return (a*10 +nums2[0]);\\n        else return (nums2[0]*10+a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366566,
                "title": "python3-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        if set(nums1).intersection(set(nums2)):\\n            return sorted(set(nums1).intersection(set(nums2)))[0]\\n\\n        a=sorted(nums1)[0]\\n        b=sorted(nums2)[0]\\n        return min(a*10+b,b*10+a)    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        if set(nums1).intersection(set(nums2)):\\n            return sorted(set(nums1).intersection(set(nums2)))[0]\\n\\n        a=sorted(nums1)[0]\\n        b=sorted(nums2)[0]\\n        return min(a*10+b,b*10+a)    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366527,
                "title": "beats-100-submissions-easy-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        a=nums1[:]\\n        a.extend(nums2)\\n        dic=Counter(a)\\n        m=max(dic.values())\\n        ans=[]\\n        if m>1:\\n            for i,j in dic.items():\\n                if j==m:\\n                    ans.append(i)\\n            return min(ans)\\n        else:\\n            min1=min(nums1)\\n            min2=min(nums2)\\n            if min1>min2:\\n                return int(str(min2)+str(min1))\\n            else:\\n                return int(str(min1)+str(min2))\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        a=nums1[:]\\n        a.extend(nums2)\\n        dic=Counter(a)\\n        m=max(dic.values())\\n        ans=[]\\n        if m>1:\\n            for i,j in dic.items():\\n                if j==m:\\n                    ans.append(i)\\n            return min(ans)\\n        else:\\n            min1=min(nums1)\\n            min2=min(nums2)\\n            if min1>min2:\\n                return int(str(min2)+str(min1))\\n            else:\\n                return int(str(min1)+str(min2))\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366488,
                "title": "min-max-occurence-easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int m1=INT_MAX;\\n        int m2=INT_MAX;\\n        int arr[10]={0};\\n        \\n        for(int i=0;i<nums1.size();i++)\\n           {\\n            m1=min(m1,nums1[i]);\\n            arr[nums1[i]]++;\\n           }\\n         for(int i=0;i<nums2.size();i++)\\n           { \\n             m2=min(m2,nums2[i]);\\n             arr[nums2[i]]++;\\n           }\\n        for(int i=0;i<10;i++)\\n            if(arr[i]==2)\\n                return i;\\n        \\n       \\n        return  m1 > m2 ? m2*10+m1 : m1*10+m2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int m1=INT_MAX;\\n        int m2=INT_MAX;\\n        int arr[10]={0};\\n        \\n        for(int i=0;i<nums1.size();i++)\\n           {\\n            m1=min(m1,nums1[i]);\\n            arr[nums1[i]]++;\\n           }\\n         for(int i=0;i<nums2.size();i++)\\n           { \\n             m2=min(m2,nums2[i]);\\n             arr[nums2[i]]++;\\n           }\\n        for(int i=0;i<10;i++)\\n            if(arr[i]==2)\\n                return i;\\n        \\n       \\n        return  m1 > m2 ? m2*10+m1 : m1*10+m2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366474,
                "title": "most-easy-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int i=0;i<nums1.length;i++){\\n            set.add(nums1[i]);\\n        }\\n        for(int j=0;j<nums2.length;j++){\\n            if(set.contains(nums2[j])){\\n                return nums2[j];\\n            }\\n        }\\n        int min1=Integer.MAX_VALUE;\\n        int min2=Integer.MAX_VALUE;\\n        for(int i=0;i<nums1.length;i++){\\n            min1=Math.min(min1,nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            min2=Math.min(min2,nums2[i]);\\n        }\\n        if(min1<min2){\\n            return min1*10+min2;\\n        }\\n        return min2*10+min1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int i=0;i<nums1.length;i++){\\n            set.add(nums1[i]);\\n        }\\n        for(int j=0;j<nums2.length;j++){\\n            if(set.contains(nums2[j])){\\n                return nums2[j];\\n            }\\n        }\\n        int min1=Integer.MAX_VALUE;\\n        int min2=Integer.MAX_VALUE;\\n        for(int i=0;i<nums1.length;i++){\\n            min1=Math.min(min1,nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            min2=Math.min(min2,nums2[i]);\\n        }\\n        if(min1<min2){\\n            return min1*10+min2;\\n        }\\n        return min2*10+min1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366453,
                "title": "go-sort-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(2nlog(n) + n2)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nfunc minNumber(nums1 []int, nums2 []int) int {\\n\\tsort.Ints(nums1)\\n\\tsort.Ints(nums2)\\n\\n\\tfor i := range nums1 {\\n\\t\\tfor j := range nums2 {\\n\\t\\t\\tif nums1[i] == nums2[j] {\\n\\t\\t\\t\\treturn nums1[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif nums1[0] < nums2[0] {\\n\\t\\treturn nums1[0]*10 + nums2[0]\\n\\t}\\n\\treturn nums2[0]*10 + nums1[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minNumber(nums1 []int, nums2 []int) int {\\n\\tsort.Ints(nums1)\\n\\tsort.Ints(nums2)\\n\\n\\tfor i := range nums1 {\\n\\t\\tfor j := range nums2 {\\n\\t\\t\\tif nums1[i] == nums2[j] {\\n\\t\\t\\t\\treturn nums1[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif nums1[0] < nums2[0] {\\n\\t\\treturn nums1[0]*10 + nums2[0]\\n\\t}\\n\\treturn nums2[0]*10 + nums1[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366443,
                "title": "easy-solution-using-map-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<int,int> mp;\\n        for(int i=0; i<nums1.size(); i++){\\n            mp[nums1[i]]++;\\n        }\\n        int flag =0;\\n        int ans = INT_MAX;\\n        for(int i=0; i<nums2.size(); i++){\\n            if(mp[nums2[i]]>=1){\\n                ans = min(ans,nums2[i]);\\n                flag =1;\\n\\n            }\\n        }\\n        if(flag){\\n            return ans;\\n\\n        }\\n        \\n        \\n        int mn1 = *min_element(nums1.begin(),nums1.end());\\n        // int mx1 = *max_element(nums1.begin(),nums1.end());\\n        int mn2 = *min_element(nums2.begin(),nums2.end());\\n        // int mx2 = *max_element(nums2.begin(),nums2.end());\\n        ans = min(mn1*10+mn2,mn2*10+mn1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<int,int> mp;\\n        for(int i=0; i<nums1.size(); i++){\\n            mp[nums1[i]]++;\\n        }\\n        int flag =0;\\n        int ans = INT_MAX;\\n        for(int i=0; i<nums2.size(); i++){\\n            if(mp[nums2[i]]>=1){\\n                ans = min(ans,nums2[i]);\\n                flag =1;\\n\\n            }\\n        }\\n        if(flag){\\n            return ans;\\n\\n        }\\n        \\n        \\n        int mn1 = *min_element(nums1.begin(),nums1.end());\\n        // int mx1 = *max_element(nums1.begin(),nums1.end());\\n        int mn2 = *min_element(nums2.begin(),nums2.end());\\n        // int mx2 = *max_element(nums2.begin(),nums2.end());\\n        ans = min(mn1*10+mn2,mn2*10+mn1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366398,
                "title": "python-greedy-with-set",
                "content": "```python\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = set(nums1), set(nums2)\\n        for n in range(100):\\n            s = set(map(int, str(n)))\\n            if s1 & s and s2 & s:\\n                return n\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```python\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = set(nums1), set(nums2)\\n        for n in range(100):\\n            s = set(map(int, str(n)))\\n            if s1 & s and s2 & s:\\n                return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366367,
                "title": "form-smallest-number-from-two-digit-arrays",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int> &nums1, vector<int> &nums2) {\\n        vector<int> merged;\\n        merged.reserve(nums1.size() + nums2.size());\\n        merged.insert(merged.end(), nums1.begin(), nums1.end());\\n        merged.insert(merged.end(), nums2.begin(), nums2.end());\\n        sort(merged.begin(), merged.end());\\n\\n        for (int num: merged) {\\n            if (std::find(nums1.begin(), nums1.end(), num) != nums1.end() &&\\n                std::find(nums2.begin(), nums2.end(), num) != nums2.end()) {\\n                return num;\\n            }\\n        }\\n\\n        int mn1 = *min_element(nums1.begin(), nums1.end());\\n        int mn2 = *min_element(nums2.begin(), nums2.end());      \\n        return min(mn1,mn2) * 10 + max(mn1,mn2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int> &nums1, vector<int> &nums2) {\\n        vector<int> merged;\\n        merged.reserve(nums1.size() + nums2.size());\\n        merged.insert(merged.end(), nums1.begin(), nums1.end());\\n        merged.insert(merged.end(), nums2.begin(), nums2.end());\\n        sort(merged.begin(), merged.end());\\n\\n        for (int num: merged) {\\n            if (std::find(nums1.begin(), nums1.end(), num) != nums1.end() &&\\n                std::find(nums2.begin(), nums2.end(), num) != nums2.end()) {\\n                return num;\\n            }\\n        }\\n\\n        int mn1 = *min_element(nums1.begin(), nums1.end());\\n        int mn2 = *min_element(nums2.begin(), nums2.end());      \\n        return min(mn1,mn2) * 10 + max(mn1,mn2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366356,
                "title": "c-set-use",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> s1(nums1.begin(),nums1.end()),s2(nums2.begin(),nums2.end());\\n        for(int i=0;i<=1e4;i++){\\n            bool f1=false,f2=false;\\n            string x = to_string(i);\\n            for(auto a : x){\\n                if(s1.find(a-\\'0\\')!=s1.end()) f1 = true;\\n                if(s2.find(a-\\'0\\')!=s2.end()) f2 = true;\\n            }\\n            if(f1 && f2) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> s1(nums1.begin(),nums1.end()),s2(nums2.begin(),nums2.end());\\n        for(int i=0;i<=1e4;i++){\\n            bool f1=false,f2=false;\\n            string x = to_string(i);\\n            for(auto a : x){\\n                if(s1.find(a-\\'0\\')!=s1.end()) f1 = true;\\n                if(s2.find(a-\\'0\\')!=s2.end()) f2 = true;\\n            }\\n            if(f1 && f2) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089167,
                "title": "beats-100-loops",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        // Sort the input vectors\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        int size1 = nums1.size();\\n        int size2 = nums2.size();\\n\\n        if (size1 == 0 && size2 == 0) {\\n            return 0;\\n        } else if (size1 == 0) {\\n            return nums2[0];\\n        } else if (size2 == 0) {\\n            return nums1[0];\\n        }\\n\\n        int i = 0, j = 0;\\n\\n        while (i < size1 && j < size2) {\\n            if (nums1[i] == nums2[j]) {\\n                return nums1[i];\\n            } else if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else {\\n                j++;\\n            }\\n        }\\n        return (nums1[0] > nums2[0]) ? nums2[0]*10 + nums1[0] : nums1[0]*10 + nums2[0] ;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        // Sort the input vectors\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        int size1 = nums1.size();\\n        int size2 = nums2.size();\\n\\n        if (size1 == 0 && size2 == 0) {\\n            return 0;\\n        } else if (size1 == 0) {\\n            return nums2[0];\\n        } else if (size2 == 0) {\\n            return nums1[0];\\n        }\\n\\n        int i = 0, j = 0;\\n\\n        while (i < size1 && j < size2) {\\n            if (nums1[i] == nums2[j]) {\\n                return nums1[i];\\n            } else if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else {\\n                j++;\\n            }\\n        }\\n        return (nums1[0] > nums2[0]) ? nums2[0]*10 + nums1[0] : nums1[0]*10 + nums2[0] ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079711,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        a = set(nums1) & set(nums2)\\n        return min(a) if a else int(\\'\\'.join(map(str, sorted((sorted(nums1)[0], sorted(nums2)[0])))))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        a = set(nums1) & set(nums2)\\n        return min(a) if a else int(\\'\\'.join(map(str, sorted((sorted(nums1)[0], sorted(nums2)[0])))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078966,
                "title": "easy-c-solution-for-beginners-with-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int i,k;\\n        map<int,int>mp;\\n        for(i=0; i<nums1.size(); i++){\\n          mp[nums1[i]]++;\\n        }\\n        for(i=0; i<nums2.size(); i++){\\n                     mp[nums2[i]]++;\\n\\n        }\\n        int mini=1000;\\n        int flag=0;\\n        for(auto i: mp){\\n            if(i.second==2){\\n                flag=1;\\n                k=i.first;\\n                mini=min(mini,k);\\n            }\\n        }\\n        if(flag==1){\\n            return mini;\\n        }\\n       sort(nums1.begin(),nums1.end());\\n       int val1=nums1[0];\\n        sort(nums2.begin(),nums2.end());\\n            int val2=nums2[0];\\n            int sum1=(val1*10)+val2;\\n            int sum2=(val2*10)+val1;\\n            if(sum1<sum2){\\n                return sum1;\\n            }\\n            return sum2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int i,k;\\n        map<int,int>mp;\\n        for(i=0; i<nums1.size(); i++){\\n          mp[nums1[i]]++;\\n        }\\n        for(i=0; i<nums2.size(); i++){\\n                     mp[nums2[i]]++;\\n\\n        }\\n        int mini=1000;\\n        int flag=0;\\n        for(auto i: mp){\\n            if(i.second==2){\\n                flag=1;\\n                k=i.first;\\n                mini=min(mini,k);\\n            }\\n        }\\n        if(flag==1){\\n            return mini;\\n        }\\n       sort(nums1.begin(),nums1.end());\\n       int val1=nums1[0];\\n        sort(nums2.begin(),nums2.end());\\n            int val2=nums2[0];\\n            int sum1=(val1*10)+val2;\\n            int sum2=(val2*10)+val1;\\n            if(sum1<sum2){\\n                return sum1;\\n            }\\n            return sum2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078666,
                "title": "python-solution-easy-to-understand-for-beginner",
                "content": "\\n\\n# Complexity\\n\\n![image.png](https://assets.leetcode.com/users/images/3a8b577f-b4a5-4cac-b950-25793293ba1e_1695432344.8772168.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        l=[i for i in nums1 if i in nums2 ]\\n        if l!=[]:\\n            return min(l)\\n        else:\\n            l.extend([min(nums1),min(nums2)])\\n            l.sort()\\n            return int(str(l[0])+str(l[1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        l=[i for i in nums1 if i in nums2 ]\\n        if l!=[]:\\n            return min(l)\\n        else:\\n            l.extend([min(nums1),min(nums2)])\\n            l.sort()\\n            return int(str(l[0])+str(l[1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072158,
                "title": "esay-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int small=nums1[0],small1=nums2[0],answer;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(nums1[i]<small)\\n            small=nums1[i];\\n        }\\n        // for(int i=0;i<nums2.size();i++)\\n        // {\\n        //     if(nums2[i]<small)\\n        //     small1=nums2[i];\\n        // }\\nsmall1=*min_element(nums2.begin(), nums2.end());\\n \\n    sort(nums1.begin(), nums1.end());\\n    sort(nums2.begin(), nums2.end());\\n    \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n         for(int j=0;j<nums2.size();j++)\\n        {\\n            if(nums1[i]==nums2[j])\\n            return nums1[i];\\n            //small1=nums2[i];\\n        }\\n        }\\n   if(small1<small) swap(small1, small);\\n         answer=small*10+small1;\\n        \\n  return answer;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int small=nums1[0],small1=nums2[0],answer;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(nums1[i]<small)\\n            small=nums1[i];\\n        }\\n        // for(int i=0;i<nums2.size();i++)\\n        // {\\n        //     if(nums2[i]<small)\\n        //     small1=nums2[i];\\n        // }\\nsmall1=*min_element(nums2.begin(), nums2.end());\\n \\n    sort(nums1.begin(), nums1.end());\\n    sort(nums2.begin(), nums2.end());\\n    \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n         for(int j=0;j<nums2.size();j++)\\n        {\\n            if(nums1[i]==nums2[j])\\n            return nums1[i];\\n            //small1=nums2[i];\\n        }\\n        }\\n   if(small1<small) swap(small1, small);\\n         answer=small*10+small1;\\n        \\n  return answer;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070730,
                "title": "java-o-n-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int res = Integer.MAX_VALUE;\\n        HashSet<Integer> set = new HashSet<>();\\n        int minOne = Integer.MAX_VALUE;\\n        int minTwo = Integer.MAX_VALUE;\\n        for(int num: nums1){\\n            minOne = Math.min(minOne, num);\\n            set.add(num);\\n        }\\n        for(int num: nums2){\\n            minTwo = Math.min(minTwo, num);\\n            if(set.contains(num)){\\n                res = Math.min(res, num);\\n            }\\n        }\\n        if(res != Integer.MAX_VALUE) return res;\\n        return minOne <= minTwo ? minOne * 10 + minTwo : minTwo * 10 + minOne;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int res = Integer.MAX_VALUE;\\n        HashSet<Integer> set = new HashSet<>();\\n        int minOne = Integer.MAX_VALUE;\\n        int minTwo = Integer.MAX_VALUE;\\n        for(int num: nums1){\\n            minOne = Math.min(minOne, num);\\n            set.add(num);\\n        }\\n        for(int num: nums2){\\n            minTwo = Math.min(minTwo, num);\\n            if(set.contains(num)){\\n                res = Math.min(res, num);\\n            }\\n        }\\n        if(res != Integer.MAX_VALUE) return res;\\n        return minOne <= minTwo ? minOne * 10 + minTwo : minTwo * 10 + minOne;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069927,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n    let smallestNumberFirstArray = Number.MAX_VALUE;\\n    let smallestNumberSecondArray = Number.MAX_VALUE;\\n    const nums1Length = nums1.length;\\n    const nums2Length = nums2.length;\\n    let firstArrayMinValue = 0;\\n    let secondArrayMinValue = 0;\\n    let smallMatchedValue = Number.MAX_VALUE;\\n\\n    for (let i = 0; i < nums1Length; i++) {\\n        if (nums1[i] < smallestNumberFirstArray) {\\n            firstArrayMinValue = nums1[i];\\n            smallestNumberFirstArray = firstArrayMinValue;\\n        }\\n\\n        for (let j = 0; j < nums2Length; j++) {\\n            if (nums2[j] < smallestNumberSecondArray) {\\n                secondArrayMinValue = nums2[j];\\n                smallestNumberSecondArray = secondArrayMinValue;\\n            }\\n\\n            if (nums1[i] === nums2[j]) {\\n                if (nums1[i] < smallMatchedValue) {\\n                    smallMatchedValue = nums1[i];\\n                }\\n            }\\n        }\\n    }\\n\\n    if (smallMatchedValue < Number.MAX_VALUE) {\\n        return smallMatchedValue;\\n    }\\n\\n    if (firstArrayMinValue < secondArrayMinValue) {\\n        return parseInt(firstArrayMinValue.toString() + secondArrayMinValue.toString());\\n    } else {\\n        return parseInt(secondArrayMinValue.toString() + firstArrayMinValue.toString());\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n    let smallestNumberFirstArray = Number.MAX_VALUE;\\n    let smallestNumberSecondArray = Number.MAX_VALUE;\\n    const nums1Length = nums1.length;\\n    const nums2Length = nums2.length;\\n    let firstArrayMinValue = 0;\\n    let secondArrayMinValue = 0;\\n    let smallMatchedValue = Number.MAX_VALUE;\\n\\n    for (let i = 0; i < nums1Length; i++) {\\n        if (nums1[i] < smallestNumberFirstArray) {\\n            firstArrayMinValue = nums1[i];\\n            smallestNumberFirstArray = firstArrayMinValue;\\n        }\\n\\n        for (let j = 0; j < nums2Length; j++) {\\n            if (nums2[j] < smallestNumberSecondArray) {\\n                secondArrayMinValue = nums2[j];\\n                smallestNumberSecondArray = secondArrayMinValue;\\n            }\\n\\n            if (nums1[i] === nums2[j]) {\\n                if (nums1[i] < smallMatchedValue) {\\n                    smallMatchedValue = nums1[i];\\n                }\\n            }\\n        }\\n    }\\n\\n    if (smallMatchedValue < Number.MAX_VALUE) {\\n        return smallMatchedValue;\\n    }\\n\\n    if (firstArrayMinValue < secondArrayMinValue) {\\n        return parseInt(firstArrayMinValue.toString() + secondArrayMinValue.toString());\\n    } else {\\n        return parseInt(secondArrayMinValue.toString() + firstArrayMinValue.toString());\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057567,
                "title": "96-runtime-67-memory-beautiful-solution-using-set-and-intersection",
                "content": "![image.png](https://assets.leetcode.com/users/images/3c192b64-f9b6-4451-9343-04ba8d57a932_1694988871.1216412.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = set(nums1), set(nums2)\\n        m1, m2 = min(s1), min(s2); intersect = s1 & s2\\n\\n        if intersect: min_inter = min(intersect)\\n        else:\\n            if m1 < m2: return m1*10 + m2\\n            else: return m2*10 + m1\\n\\n        if m1 < m2: smallest = m1*10 + m2\\n        else: smallest = m2*10 + m1\\n\\n        return min_inter if min_inter < smallest else smallest\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1, s2 = set(nums1), set(nums2)\\n        m1, m2 = min(s1), min(s2); intersect = s1 & s2\\n\\n        if intersect: min_inter = min(intersect)\\n        else:\\n            if m1 < m2: return m1*10 + m2\\n            else: return m2*10 + m1\\n\\n        if m1 < m2: smallest = m1*10 + m2\\n        else: smallest = m2*10 + m1\\n\\n        return min_inter if min_inter < smallest else smallest\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057023,
                "title": "c-easy-set-appraoch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n     set<int>st1(nums1.begin(),nums1.end()),st2(nums2.begin(),nums2.end());\\n       for(auto it:st1)\\n         {\\n           if(st2.find(it)!=st2.end())\\n               return it;\\n               \\n         }\\n         int mi1=*st1.begin();\\n         int mi2=*st2.begin();\\n         string s=to_string(min(mi1,mi2))+to_string(max(mi1,mi2));\\n         return stoi(s);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n     set<int>st1(nums1.begin(),nums1.end()),st2(nums2.begin(),nums2.end());\\n       for(auto it:st1)\\n         {\\n           if(st2.find(it)!=st2.end())\\n               return it;\\n               \\n         }\\n         int mi1=*st1.begin();\\n         int mi2=*st2.begin();\\n         string s=to_string(min(mi1,mi2))+to_string(max(mi1,mi2));\\n         return stoi(s);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056331,
                "title": "c-o-n",
                "content": "# Approach\\nIn single iteration try to find out the common and smallest element in each array.\\n\\n# Complexity\\n- Time complexity: $$O(max(n, m))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> visited(10,0);\\n        int small1 = 1e9, small2 = 1e9;\\n\\n        for(int num: nums1)\\n        {\\n            small1 = min(small1, num);\\n            visited[num] = 1;\\n        }\\n        \\n        for(int num: nums2)\\n        {\\n            small2 = min(small2, num);\\n            if (visited[num] == 1)\\n                visited[num] = 2;\\n        }\\n\\n        for(int i = 1 ; i <10 ; i++)\\n        {\\n            if (visited[i] == 2)\\n                return i;\\n        }\\n         \\n         return (small1 + small2 * 10) > (small2 + small1 * 10) ? (small2 + small1 * 10) : (small1 + small2 * 10);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> visited(10,0);\\n        int small1 = 1e9, small2 = 1e9;\\n\\n        for(int num: nums1)\\n        {\\n            small1 = min(small1, num);\\n            visited[num] = 1;\\n        }\\n        \\n        for(int num: nums2)\\n        {\\n            small2 = min(small2, num);\\n            if (visited[num] == 1)\\n                visited[num] = 2;\\n        }\\n\\n        for(int i = 1 ; i <10 ; i++)\\n        {\\n            if (visited[i] == 2)\\n                return i;\\n        }\\n         \\n         return (small1 + small2 * 10) > (small2 + small1 * 10) ? (small2 + small1 * 10) : (small1 + small2 * 10);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049981,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n  const result=[];\\n        for(let i=0;i<nums1.length;i++){\\n          for(let j=0;j<nums2.length;j++){\\n            if(nums1[i]===nums2[j])\\n            result.push(nums1[i]);\\n            else\\n            result.push(parseInt(nums1[i].toString()+nums2[j].toString()));\\n          }\\n        }\\n        for(let i=0;i<nums1.length;i++){\\n          for(let j=0;j<nums2.length;j++){\\n            if(nums1[i]===nums2[j])\\n            result.push(nums1[i]);\\n            else\\n            result.push(parseInt(nums2[j].toString()+nums1[i].toString()));\\n          }\\n        }\\n        return Math.min(...result);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n  const result=[];\\n        for(let i=0;i<nums1.length;i++){\\n          for(let j=0;j<nums2.length;j++){\\n            if(nums1[i]===nums2[j])\\n            result.push(nums1[i]);\\n            else\\n            result.push(parseInt(nums1[i].toString()+nums2[j].toString()));\\n          }\\n        }\\n        for(let i=0;i<nums1.length;i++){\\n          for(let j=0;j<nums2.length;j++){\\n            if(nums1[i]===nums2[j])\\n            result.push(nums1[i]);\\n            else\\n            result.push(parseInt(nums2[j].toString()+nums1[i].toString()));\\n          }\\n        }\\n        return Math.min(...result);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044716,
                "title": "easy-solution-in-java-with-100-less-run-time-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int arr[] = new int[20];\\n        int a = -1, b = -1;\\n        for(int i : nums1)\\n            arr[i]++;\\n        for(int i : nums2)\\n            arr[i+10]++;\\n        for(int i=0; i<10; i++){\\n            if(arr[i] == 1 && arr[i+10] == 1)\\n                return i;\\n            if(a == -1 && arr[i] == 1)\\n                a = i;\\n            if(b == -1 && arr[i+10] == 1)\\n                b = i;\\n        }\\n        return Math.min(a,b)*10+Math.max(a,b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int arr[] = new int[20];\\n        int a = -1, b = -1;\\n        for(int i : nums1)\\n            arr[i]++;\\n        for(int i : nums2)\\n            arr[i+10]++;\\n        for(int i=0; i<10; i++){\\n            if(arr[i] == 1 && arr[i+10] == 1)\\n                return i;\\n            if(a == -1 && arr[i] == 1)\\n                a = i;\\n            if(b == -1 && arr[i+10] == 1)\\n                b = i;\\n        }\\n        return Math.min(a,b)*10+Math.max(a,b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022113,
                "title": "easiest-ever-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        unordered_map<int,int> h;\\n        for(auto i:nums2)\\n        h[i]++;\\n\\n        \\n        for(auto i:nums1)\\n        {\\n            if(h[i]>0)\\n            return i;\\n        }\\n\\n        int ans=0;\\n        ans=nums1[0];\\n        ans=ans*10+nums2[0];\\n\\n        int ans2=0;\\n        ans2=nums2[0];\\n        ans2=ans2*10+nums1[0];\\n\\n        return min(ans,ans2) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        unordered_map<int,int> h;\\n        for(auto i:nums2)\\n        h[i]++;\\n\\n        \\n        for(auto i:nums1)\\n        {\\n            if(h[i]>0)\\n            return i;\\n        }\\n\\n        int ans=0;\\n        ans=nums1[0];\\n        ans=ans*10+nums2[0];\\n\\n        int ans2=0;\\n        ans2=nums2[0];\\n        ans2=ans2*10+nums1[0];\\n\\n        return min(ans,ans2) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018951,
                "title": "java-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> hs1 =  new HashSet<>();\\n       Set<Integer> hs2 =  new HashSet<>();\\n       for(int i : nums1){hs1.add(i);}\\n       for(int i : nums2){hs2.add(i) ;}\\n       for(int  i =1 ; i<=99 ; i++){\\n           if(i<=9){if(hs1.contains(i) && hs2.contains(i))return  i ; }\\n           else {\\n               int j=i/10 ; \\n               if( hs1.contains(i%10) &&hs2.contains(j) || hs1.contains(j)&&hs2.contains(i%10)){return i ;}\\n           }\\n       }\\n\\n        return 0 ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Set<Integer> hs1 =  new HashSet<>();\\n       Set<Integer> hs2 =  new HashSet<>();\\n       for(int i : nums1){hs1.add(i);}\\n       for(int i : nums2){hs2.add(i) ;}\\n       for(int  i =1 ; i<=99 ; i++){\\n           if(i<=9){if(hs1.contains(i) && hs2.contains(i))return  i ; }\\n           else {\\n               int j=i/10 ; \\n               if( hs1.contains(i%10) &&hs2.contains(j) || hs1.contains(j)&&hs2.contains(i%10)){return i ;}\\n           }\\n       }\\n\\n        return 0 ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015002,
                "title": "python3-solution-using-sets-and-built-in-functions",
                "content": "# Intuition\\nWe need to first check if the answer can be 1-digit. Then we check the minimum value of 2 digit answers.\\n\\n# Approach\\nWe first get the intersection of 2 sets containing values in $$nums$$. If the intersection is not empty, that means we can come up with a 1-digit answer. So we return the minimum value in the intersection. \\n\\nIf the intersection is empty, then we need to create a 2-digit answer. We get the minimum value from each set and use the smaller value as the 10\\'s digit and the other as 1\\'s digit.\\n\\n# Complexity\\n- Time complexity: $$O(n+m)$$\\n    - $$n$$ is the size of $$nums1$$ \\n    - $$m$$ is the size of $$nums2$$\\n    - 1-pass for each list to convert to set => $$O(n+m)$$\\n    - 1-pass of the smaller set to get the intersection => $$O(min(n,m))$$ \\n    - 1-pass to iterate over the intersection => $$O(len(intersect(nums1, nums2)))$$\\n    - 1-pass to find minimum in each list => $$O(n+m)$$\\n    - The dominating term here is => $$O(n+m)$$\\n\\n- Space complexity: $$O(n+m)$$\\n    - We create sets to hold all the data  $$O(n+m)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        single = set(nums1) & set(nums2)\\n        if single: return min(single)\\n        m1, m2 = min(nums1), min(nums2)\\n        return min(m1,m2) * 10 + max(m1, m2)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        single = set(nums1) & set(nums2)\\n        if single: return min(single)\\n        m1, m2 = min(nums1), min(nums2)\\n        return min(m1,m2) * 10 + max(m1, m2)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014843,
                "title": "not-so-much-short-code-lines-but-here-is-my-solution",
                "content": "It is not short code lines. I think it could be more efficient when last 6 lines would change. Anyway, Thanks for reading :)\\nIf this is helpful, Please thumbs up! :)\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        total_num = nums1 + nums2\\n        same_ans = []\\n        hash_ = {}\\n        for i in total_num:\\n            if i in hash_:\\n                hash_[i] += 1\\n            else:\\n                hash_[i] = 1\\n        for i, k in enumerate(hash_):\\n            if hash_[k] == 2:\\n                same_ans.append(k)\\n        if same_ans:\\n            return min(same_ans)\\n        ans = []\\n        ans.append(min(nums1))\\n        ans.append(min(nums2))\\n        ans.sort()\\n        ans = [str(i) for i in ans]\\n        return int(\\'\\'.join(ans))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        total_num = nums1 + nums2\\n        same_ans = []\\n        hash_ = {}\\n        for i in total_num:\\n            if i in hash_:\\n                hash_[i] += 1\\n            else:\\n                hash_[i] = 1\\n        for i, k in enumerate(hash_):\\n            if hash_[k] == 2:\\n                same_ans.append(k)\\n        if same_ans:\\n            return min(same_ans)\\n        ans = []\\n        ans.append(min(nums1))\\n        ans.append(min(nums2))\\n        ans.sort()\\n        ans = [str(i) for i in ans]\\n        return int(\\'\\'.join(ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014816,
                "title": "javascript-sets-min",
                "content": "# Code\\n```\\nvar minNumber = function(nums1, nums2) {\\n    const s1 = new Set(nums1);\\n    const s2 = new Set(nums2);\\n    for (let i = 0; i < 10; i++) {\\n        if (s1.has(i) && s2.has(i)) return i;\\n    }\\n    const m1 = Math.min(...nums1);\\n    const m2 = Math.min(...nums2);\\n    return +`${Math.min(m1, m2)}${Math.max(m1, m2)}`\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minNumber = function(nums1, nums2) {\\n    const s1 = new Set(nums1);\\n    const s2 = new Set(nums2);\\n    for (let i = 0; i < 10; i++) {\\n        if (s1.has(i) && s2.has(i)) return i;\\n    }\\n    const m1 = Math.min(...nums1);\\n    const m2 = Math.min(...nums2);\\n    return +`${Math.min(m1, m2)}${Math.max(m1, m2)}`\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013321,
                "title": "c-hash-concise-understandable",
                "content": "# Intuition\\nAt first sight, we can easily think of using **sort** to solve it, and after thinking for a while, using **hash table** is not a bad way.\\n\\n# Approach\\n1. **using two set(st1/st2) to store nums1 and nums2**;\\n2. **find the element of st2 in st1**, if successfully, then return the element;\\n3. if failingly, just **take the first element from st1 and st2, compare them and caculate the result**. \\n\\n# Complexity\\n- Time complexity:\\n$$O(logN1 + logN2)$$\\uFF1AN1 and N2 represent the length of nums1 and nums2.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> st1, st2;\\n        for (auto &num : nums1) {\\n            st1.insert(num);\\n        }\\n\\n        for (auto &num : nums2) {\\n            st2.insert(num);\\n        }\\n\\n        for (auto it : st1) {\\n            if (st2.find(it) != st2.end()) {\\n                return it;\\n            }\\n        }\\n\\n        return *st1.begin() < *st2.begin() ? *st1.begin() * 10 + *st2.begin() : *st2.begin() * 10 + *st1.begin();        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> st1, st2;\\n        for (auto &num : nums1) {\\n            st1.insert(num);\\n        }\\n\\n        for (auto &num : nums2) {\\n            st2.insert(num);\\n        }\\n\\n        for (auto it : st1) {\\n            if (st2.find(it) != st2.end()) {\\n                return it;\\n            }\\n        }\\n\\n        return *st1.begin() < *st2.begin() ? *st1.begin() * 10 + *st2.begin() : *st2.begin() * 10 + *st1.begin();        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004880,
                "title": "c-hash-map-sort-100-beats",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        std::unordered_map<int, int> cache;\\n        std::size_t i = 0, j = 0;\\n        int oneDigitMin = INT_MAX;\\n\\n        while(i < nums1.size() && j < nums2.size())\\n        {\\n            ++cache[nums1[i++]];\\n            ++cache[nums2[j++]];\\n        }\\n\\n        while(i < nums1.size()) ++cache[nums1[i++]];\\n        while(j < nums2.size()) ++cache[nums2[j++]];\\n\\n        for(const auto &i : cache)\\n        {\\n            if(i.second == 2) oneDigitMin = std::min(oneDigitMin, i.first);\\n        }\\n\\n        if(oneDigitMin != INT_MAX) return oneDigitMin;\\n\\n        std::sort(nums1.begin(), nums1.end());\\n        std::sort(nums2.begin(), nums2.end());\\n\\n        return nums1[0] < nums2[0] ? nums1[0] * 10 + nums2[0] : nums2[0] * 10 + nums1[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        std::unordered_map<int, int> cache;\\n        std::size_t i = 0, j = 0;\\n        int oneDigitMin = INT_MAX;\\n\\n        while(i < nums1.size() && j < nums2.size())\\n        {\\n            ++cache[nums1[i++]];\\n            ++cache[nums2[j++]];\\n        }\\n\\n        while(i < nums1.size()) ++cache[nums1[i++]];\\n        while(j < nums2.size()) ++cache[nums2[j++]];\\n\\n        for(const auto &i : cache)\\n        {\\n            if(i.second == 2) oneDigitMin = std::min(oneDigitMin, i.first);\\n        }\\n\\n        if(oneDigitMin != INT_MAX) return oneDigitMin;\\n\\n        std::sort(nums1.begin(), nums1.end());\\n        std::sort(nums2.begin(), nums2.end());\\n\\n        return nums1[0] < nums2[0] ? nums1[0] * 10 + nums2[0] : nums2[0] * 10 + nums1[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003489,
                "title": "o-n-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> cnt(10,0);\\n        int min_1=nums1[0],min_2=nums2[0],min_common=10;\\n        for(auto num1:nums1){\\n            cnt[num1]++;\\n            min_1=min(min_1,num1);\\n        };\\n        for(auto num2:nums2){\\n            min_2=min(min_2,num2);\\n            if(cnt[num2]>0) min_common=min(min_common,num2);    \\n        }\\n        if(min_common!=10) return min_common;\\n        else return min_1>min_2? min_2*10+min_1: min_1*10+min_2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> cnt(10,0);\\n        int min_1=nums1[0],min_2=nums2[0],min_common=10;\\n        for(auto num1:nums1){\\n            cnt[num1]++;\\n            min_1=min(min_1,num1);\\n        };\\n        for(auto num2:nums2){\\n            min_2=min(min_2,num2);\\n            if(cnt[num2]>0) min_common=min(min_common,num2);    \\n        }\\n        if(min_common!=10) return min_common;\\n        else return min_1>min_2? min_2*10+min_1: min_1*10+min_2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003373,
                "title": "simple-beginner-level-c-solution-runtime-0-ms-beats-100-o-1-time-and-space",
                "content": "\\n# Complexity\\n- Time complexity:  ```O(n^2)``` --> ```O(9^2)``` --> ```O(81)``` --> ```O(1)```\\n- Space complexity: ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp\\n// Runtime 0 ms Beats 100% Memory 5.6 MB Beats 75%\\ninline int max(int a, int b) {\\n    return (a > b) ? a : b;\\n}\\ninline int min(int a, int b) {\\n    return (a < b) ? a : b;\\n}\\nint minNumber(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int result = 89;  // the largest smallest-number allowed is 89\\n    for (int i = 0; i < nums1Size; i++) {\\n        for (int j = 0; j < nums2Size; j++) {\\n            result = min(result, (nums1[i] == nums2[j] ? \\n                         nums1[i] : min(nums1[i], nums2[j]) * 10 + max(nums1[i], nums2[j])));\\n        }\\n    }\\n    return result;\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Enumeration"
                ],
                "code": "```O(n^2)```\n```O(9^2)```\n```O(81)```\n```O(1)```\n```O(1)```\n```cpp\\n// Runtime 0 ms Beats 100% Memory 5.6 MB Beats 75%\\ninline int max(int a, int b) {\\n    return (a > b) ? a : b;\\n}\\ninline int min(int a, int b) {\\n    return (a < b) ? a : b;\\n}\\nint minNumber(int* nums1, int nums1Size, int* nums2, int nums2Size) {\\n    int result = 89;  // the largest smallest-number allowed is 89\\n    for (int i = 0; i < nums1Size; i++) {\\n        for (int j = 0; j < nums2Size; j++) {\\n            result = min(result, (nums1[i] == nums2[j] ? \\n                         nums1[i] : min(nums1[i], nums2[j]) * 10 + max(nums1[i], nums2[j])));\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3987409,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int minNumber(int[] a, int[] b)\\n    {\\n        ArrayList<Integer>s=new ArrayList<Integer>();\\n         ArrayList<Integer>s1=new ArrayList<Integer>();\\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int j=0;j<b.length;j++)\\n            {\\n                int n=(a[i]*10)+b[j];\\n                s.add(n);\\n                int r=reverse(n);\\n                s.add(r);           \\n            }\\n        }\\n        int arr[]=new int[s.size()];int c=0;\\n        for(int i:s)\\n            arr[c++]=i;\\n        Arrays.sort(arr);\\n        int max=arr[0];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]%11==0)\\n            {\\n                s1.add(arr[i]%10);\\n                int a1[]=new int[s1.size()];int x=0;\\n                for(int j:s1)\\n                a1[x++]=j;\\n                Arrays.sort(a1);\\n                max=a1[0];\\n            }\\n        }\\n        return max;\\n        \\n    }\\n    public static int reverse(int n)\\n    {\\n        int r=0;\\n        int d=0;\\n        while(n>0)\\n        {\\n            d=n%10;\\n            r=r*10+d;\\n            n=n/10;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int minNumber(int[] a, int[] b)\\n    {\\n        ArrayList<Integer>s=new ArrayList<Integer>();\\n         ArrayList<Integer>s1=new ArrayList<Integer>();\\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int j=0;j<b.length;j++)\\n            {\\n                int n=(a[i]*10)+b[j];\\n                s.add(n);\\n                int r=reverse(n);\\n                s.add(r);           \\n            }\\n        }\\n        int arr[]=new int[s.size()];int c=0;\\n        for(int i:s)\\n            arr[c++]=i;\\n        Arrays.sort(arr);\\n        int max=arr[0];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]%11==0)\\n            {\\n                s1.add(arr[i]%10);\\n                int a1[]=new int[s1.size()];int x=0;\\n                for(int j:s1)\\n                a1[x++]=j;\\n                Arrays.sort(a1);\\n                max=a1[0];\\n            }\\n        }\\n        return max;\\n        \\n    }\\n    public static int reverse(int n)\\n    {\\n        int r=0;\\n        int d=0;\\n        while(n>0)\\n        {\\n            d=n%10;\\n            r=r*10+d;\\n            n=n/10;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987088,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int smallest1=nums1[0], smallest2=nums2[0], equal=INT_MAX, flag = 1;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i < nums1.size(); i++){\\n            if(smallest1 > nums1[i]) smallest1 = nums1[i];\\n            mp[nums1[i]]=1;\\n        }\\n        for(int i=0; i < nums2.size(); i++){\\n            if(mp.find(nums2[i])!=mp.end()){\\n                if(equal > nums2[i]) equal = nums2[i];\\n                flag = 0;\\n            }\\n            else if(flag and smallest2 > nums2[i]) smallest2 = nums2[i];\\n        }\\n        if(equal!=INT_MAX) return equal;\\n        else if(smallest1 < smallest2) return smallest1*10 + smallest2;\\n        return smallest2*10 + smallest1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int smallest1=nums1[0], smallest2=nums2[0], equal=INT_MAX, flag = 1;\\n        unordered_map<int, int> mp;\\n        for(int i=0; i < nums1.size(); i++){\\n            if(smallest1 > nums1[i]) smallest1 = nums1[i];\\n            mp[nums1[i]]=1;\\n        }\\n        for(int i=0; i < nums2.size(); i++){\\n            if(mp.find(nums2[i])!=mp.end()){\\n                if(equal > nums2[i]) equal = nums2[i];\\n                flag = 0;\\n            }\\n            else if(flag and smallest2 > nums2[i]) smallest2 = nums2[i];\\n        }\\n        if(equal!=INT_MAX) return equal;\\n        else if(smallest1 < smallest2) return smallest1*10 + smallest2;\\n        return smallest2*10 + smallest1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981267,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort(reverse=True)\\n        nums2.sort(reverse=True)\\n\\n        \\n\\n        while nums1[-1] == 0:\\n            nums1.pop()\\n        \\n        while nums2[-1] == 0:\\n            nums2.pop()\\n       \\n        for i in nums1[::-1]:\\n            if i in nums2[::-1]:\\n                return i\\n        \\n        val1 = nums1[-1]\\n        val2 = nums2[-1]\\n\\n        if val1 < val2:\\n            return val1 * 10 + val2\\n        else:\\n            return val2 * 10 + val1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort(reverse=True)\\n        nums2.sort(reverse=True)\\n\\n        \\n\\n        while nums1[-1] == 0:\\n            nums1.pop()\\n        \\n        while nums2[-1] == 0:\\n            nums2.pop()\\n       \\n        for i in nums1[::-1]:\\n            if i in nums2[::-1]:\\n                return i\\n        \\n        val1 = nums1[-1]\\n        val2 = nums2[-1]\\n\\n        if val1 < val2:\\n            return val1 * 10 + val2\\n        else:\\n            return val2 * 10 + val1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977121,
                "title": "1ms-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        List<Integer> list=new ArrayList<>();\\n        for(int j=0;j<nums2.length;j++)\\n        {\\n            list.add(nums2[j]);\\n        }\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            if(list.contains(nums1[i]))\\n            {\\n                return nums1[i];\\n            }\\n        }\\n\\n        int x=nums1[0];\\n        int y=nums2[0];\\n        if(x<y)\\n        {\\n            return (x*10)+y;\\n        }\\n        return (y*10)+x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        List<Integer> list=new ArrayList<>();\\n        for(int j=0;j<nums2.length;j++)\\n        {\\n            list.add(nums2[j]);\\n        }\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            if(list.contains(nums1[i]))\\n            {\\n                return nums1[i];\\n            }\\n        }\\n\\n        int x=nums1[0];\\n        int y=nums2[0];\\n        if(x<y)\\n        {\\n            return (x*10)+y;\\n        }\\n        return (y*10)+x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974311,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int s1=nums1[0],s2=nums2[0];\\n        if(contains(nums1,nums2)!=-1){\\n            return contains(nums1,nums2);\\n        }\\n        else if(s1>s2){\\n            return s2*10+s1;\\n        }\\n        return s1*10+s2;\\n    }\\n    public static int contains(int[]nums1,int[]nums2){\\n        int i=0,j=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]==nums2[j]){\\n                return nums1[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int s1=nums1[0],s2=nums2[0];\\n        if(contains(nums1,nums2)!=-1){\\n            return contains(nums1,nums2);\\n        }\\n        else if(s1>s2){\\n            return s2*10+s1;\\n        }\\n        return s1*10+s2;\\n    }\\n    public static int contains(int[]nums1,int[]nums2){\\n        int i=0,j=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]==nums2[j]){\\n                return nums1[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968441,
                "title": "an-easy-way-to-solve-in-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums = [0]*9\\n        for i in nums1:\\n            nums[i-1] = 2\\n        for i in nums2:\\n            nums[i-1] -= 1\\n        pos = 0\\n        neg = 0\\n        ans = 0\\n        for i in range(9):\\n            if nums[i] == 1:\\n                return i+1\\n            elif nums[i] == 2 and pos == 0 and neg == 0:\\n                ans = 10*(i+1)\\n                pos += 1\\n            elif nums[i] == -1 and pos == 0 and neg == 0:\\n                ans = 10*(i+1)\\n                neg += 1\\n            elif nums[i] == 2 and pos == 0 and neg == 1:\\n                ans += i+1\\n                pos += 1\\n            elif nums[i] == -1 and pos == 1 and neg == 0:\\n                ans += i+1\\n                neg += 1\\n            else:\\n                pass\\n        return ans\\n            \\n             \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums = [0]*9\\n        for i in nums1:\\n            nums[i-1] = 2\\n        for i in nums2:\\n            nums[i-1] -= 1\\n        pos = 0\\n        neg = 0\\n        ans = 0\\n        for i in range(9):\\n            if nums[i] == 1:\\n                return i+1\\n            elif nums[i] == 2 and pos == 0 and neg == 0:\\n                ans = 10*(i+1)\\n                pos += 1\\n            elif nums[i] == -1 and pos == 0 and neg == 0:\\n                ans = 10*(i+1)\\n                neg += 1\\n            elif nums[i] == 2 and pos == 0 and neg == 1:\\n                ans += i+1\\n                pos += 1\\n            elif nums[i] == -1 and pos == 1 and neg == 0:\\n                ans += i+1\\n                neg += 1\\n            else:\\n                pass\\n        return ans\\n            \\n             \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964014,
                "title": "simple-solution-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        \\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] temp=new int[Math.max(nums1[nums1.length-1],nums2[nums2.length-1])+1];\\n\\n        int n1=nums1[0];\\n\\n        int n2=nums2[0];\\n\\n        int k=Math.min(n1*10+n2,n2*10+n1);\\n\\n        for(int i=0;i<nums1.length;i++){\\n            temp[nums1[i]]++;\\n        }\\n\\n        for(int j=0;j<nums2.length;j++){\\n            if(temp[nums2[j]]>0){\\n                k=Math.min(k,nums2[j]);\\n                return k;\\n            }\\n        }\\n\\n        return k;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        \\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] temp=new int[Math.max(nums1[nums1.length-1],nums2[nums2.length-1])+1];\\n\\n        int n1=nums1[0];\\n\\n        int n2=nums2[0];\\n\\n        int k=Math.min(n1*10+n2,n2*10+n1);\\n\\n        for(int i=0;i<nums1.length;i++){\\n            temp[nums1[i]]++;\\n        }\\n\\n        for(int j=0;j<nums2.length;j++){\\n            if(temp[nums2[j]]>0){\\n                k=Math.min(k,nums2[j]);\\n                return k;\\n            }\\n        }\\n\\n        return k;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958326,
                "title": "c-easy-solution-using-basic-sorting-knowledge",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n                    for(int i=0; i<nums1.size(); i++){\\n                            for(int j=0; j<nums2.size(); j++){\\n                                    if(nums1[i]==nums2[j]){\\n                                            return nums1[i];\\n                                    }\\n                            }\\n                    }\\n            if(nums1[0]<nums2[0]){\\n                    return (nums1[0]*10)+nums2[0];\\n            }\\n            \\n             return (nums2[0]*10)+nums1[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n                    for(int i=0; i<nums1.size(); i++){\\n                            for(int j=0; j<nums2.size(); j++){\\n                                    if(nums1[i]==nums2[j]){\\n                                            return nums1[i];\\n                                    }\\n                            }\\n                    }\\n            if(nums1[0]<nums2[0]){\\n                    return (nums1[0]*10)+nums2[0];\\n            }\\n            \\n             return (nums2[0]*10)+nums1[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955282,
                "title": "97-beats-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        boolean flag = false;\\n        int num=0;\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int i=0;int j=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i]>nums2[j]){\\n                j++;\\n            }else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                return nums1[i];\\n            }\\n        }\\n        if(nums1[0]<nums2[0]){\\n           return nums1[0]*10+nums2[0];\\n        }else{\\n           return nums2[0]*10 + nums1[0];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        boolean flag = false;\\n        int num=0;\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int i=0;int j=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i]>nums2[j]){\\n                j++;\\n            }else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                return nums1[i];\\n            }\\n        }\\n        if(nums1[0]<nums2[0]){\\n           return nums1[0]*10+nums2[0];\\n        }else{\\n           return nums2[0]*10 + nums1[0];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950490,
                "title": "one-line-solution-using-intersection-of-sets",
                "content": "# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        return min(set(nums1).intersection(set(nums2))) if len(set(nums1).intersection(set(nums2)))!=0 else min([min(nums1)*10+min(nums2),min(nums2)*10+min(nums1)])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        return min(set(nums1).intersection(set(nums2))) if len(set(nums1).intersection(set(nums2)))!=0 else min([min(nums1)*10+min(nums2),min(nums2)*10+min(nums1)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950242,
                "title": "c-easy-to-understand-solution",
                "content": "# Complexity\\n- Time complexity:\\noverall time complexity is O(n1 * log(n1) + n2 * log(n2) + n1 * n2), which simplifies to O(n1 * n2 + (n1 + n2) * log(n1 + n2)).\\n- Space complexity:\\nspace complexity of this code is O(n1+n2).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    cout<<nums1[i];\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        if(nums1[0]>nums2[0])\\n        {\\n            return (nums2[0]*10)+nums1[0];\\n        }\\n        else\\n        {\\n            return (nums1[0]*10)+nums2[0];\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    cout<<nums1[i];\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        if(nums1[0]>nums2[0])\\n        {\\n            return (nums2[0]*10)+nums1[0];\\n        }\\n        else\\n        {\\n            return (nums1[0]*10)+nums2[0];\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3946331,
                "title": "form-smallest-number-from-two-digit-arrays-with-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n\\tpublic int minNumber(int[] nums1, int[] nums2) {\\n\\t\\tint n = equalnum(nums1, nums2);\\n\\t\\tif(n==0) {\\n\\t\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\t\\tArrays.sort(nums1);\\n\\t\\t\\tArrays.sort(nums2);\\n\\t\\t\\tlist.add(nums1[0]);\\n\\t\\t\\tlist.add(nums2[0]);\\n\\t\\t\\tCollections.sort(list);\\n\\t\\t\\tString s = \"\";\\n\\t\\t\\tfor(int l : list) {\\n\\t\\t\\t\\ts += l;\\n\\t\\t\\t}\\n\\t\\t\\treturn Integer.parseInt(s);\\n\\t\\t}else {\\n\\t\\t\\treturn n;\\n\\t\\t}\\n\\t}\\n\\tpublic int equalnum(int[] num1, int[] num2) {\\n\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\tif((num1.length==num2.length) || (num1.length<num2.length)) {\\n\\t\\t\\tfor(int i : num1) {\\n\\t\\t\\t\\tfor(int j : num2) {\\n\\t\\t\\t\\t\\tif(i==j) {\\n\\t\\t\\t\\t\\t\\tlist.add(i); break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}else if(num1.length>num2.length) {\\n\\t\\t\\tfor(int i : num2) {\\n\\t\\t\\t\\tfor(int j : num1) {\\n\\t\\t\\t\\t\\tif(i==j) {\\n\\t\\t\\t\\t\\t\\tlist.add(i); break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list.size() == 0 ? 0 : Collections.min(list);\\n\\t}\\n\\tpublic static void main(String[] args) {\\n\\t\\tSolution smallestnum = new Solution();\\n\\t\\tint[] nums11 = {4,1,3}, nums12 = {5,7};\\n\\t\\tint[] nums21 = {3,5,2,6}, nums22 = {3,1,7};\\n\\t\\tSystem.out.println(\"Form Smallest Number From Two Digit Arrays : \" + smallestnum.minNumber(nums11, nums12));\\n\\t\\tSystem.out.println(\"Form Smallest Number From Two Digit Arrays : \" + smallestnum.minNumber(nums21, nums22));\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n\\tpublic int minNumber(int[] nums1, int[] nums2) {\\n\\t\\tint n = equalnum(nums1, nums2);\\n\\t\\tif(n==0) {\\n\\t\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\t\\tArrays.sort(nums1);\\n\\t\\t\\tArrays.sort(nums2);\\n\\t\\t\\tlist.add(nums1[0]);\\n\\t\\t\\tlist.add(nums2[0]);\\n\\t\\t\\tCollections.sort(list);\\n\\t\\t\\tString s = \"\";\\n\\t\\t\\tfor(int l : list) {\\n\\t\\t\\t\\ts += l;\\n\\t\\t\\t}\\n\\t\\t\\treturn Integer.parseInt(s);\\n\\t\\t}else {\\n\\t\\t\\treturn n;\\n\\t\\t}\\n\\t}\\n\\tpublic int equalnum(int[] num1, int[] num2) {\\n\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\tif((num1.length==num2.length) || (num1.length<num2.length)) {\\n\\t\\t\\tfor(int i : num1) {\\n\\t\\t\\t\\tfor(int j : num2) {\\n\\t\\t\\t\\t\\tif(i==j) {\\n\\t\\t\\t\\t\\t\\tlist.add(i); break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}else if(num1.length>num2.length) {\\n\\t\\t\\tfor(int i : num2) {\\n\\t\\t\\t\\tfor(int j : num1) {\\n\\t\\t\\t\\t\\tif(i==j) {\\n\\t\\t\\t\\t\\t\\tlist.add(i); break;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn list.size() == 0 ? 0 : Collections.min(list);\\n\\t}\\n\\tpublic static void main(String[] args) {\\n\\t\\tSolution smallestnum = new Solution();\\n\\t\\tint[] nums11 = {4,1,3}, nums12 = {5,7};\\n\\t\\tint[] nums21 = {3,5,2,6}, nums22 = {3,1,7};\\n\\t\\tSystem.out.println(\"Form Smallest Number From Two Digit Arrays : \" + smallestnum.minNumber(nums11, nums12));\\n\\t\\tSystem.out.println(\"Form Smallest Number From Two Digit Arrays : \" + smallestnum.minNumber(nums21, nums22));\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943319,
                "title": "clean-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int min1 = 10;\\n        int min2 = 10;\\n        int common = 10;\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i=0;i<nums1.length;i++){\\n            if(nums1[i] < min1)min1 = nums1[i];\\n            hs.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            if(nums2[i] < min2)min2=nums2[i];\\n            if(hs.contains(nums2[i])){\\n                if(nums2[i] < common){\\n                    common = nums2[i];\\n                }\\n            }\\n        }\\n        if(common<10)return common;\\n        if(min1<min2){\\n            return min1*10+min2;\\n        }else{\\n            return min2*10+min1;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int min1 = 10;\\n        int min2 = 10;\\n        int common = 10;\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i=0;i<nums1.length;i++){\\n            if(nums1[i] < min1)min1 = nums1[i];\\n            hs.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            if(nums2[i] < min2)min2=nums2[i];\\n            if(hs.contains(nums2[i])){\\n                if(nums2[i] < common){\\n                    common = nums2[i];\\n                }\\n            }\\n        }\\n        if(common<10)return common;\\n        if(min1<min2){\\n            return min1*10+min2;\\n        }else{\\n            return min2*10+min1;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939612,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<int,int>m1;map<int,int>m2;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            m1[nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            m2[nums2[i]]++;\\n        }\\n        for(int i=0;i<=9;i++)\\n        {\\n            if(m1[i] and m2[i])\\n            {\\n                return i;\\n            }\\n        }\\n        int mi1=*min_element(nums1.begin(),nums1.end());\\n        int mi2=*min_element(nums2.begin(),nums2.end());\\n        if(mi1<=mi2)\\n        {\\n            return mi1*10+mi2;\\n        }   \\n        else return mi2*10+mi1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<int,int>m1;map<int,int>m2;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            m1[nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            m2[nums2[i]]++;\\n        }\\n        for(int i=0;i<=9;i++)\\n        {\\n            if(m1[i] and m2[i])\\n            {\\n                return i;\\n            }\\n        }\\n        int mi1=*min_element(nums1.begin(),nums1.end());\\n        int mi2=*min_element(nums2.begin(),nums2.end());\\n        if(mi1<=mi2)\\n        {\\n            return mi1*10+mi2;\\n        }   \\n        else return mi2*10+mi1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935741,
                "title": "good-and-dynamic-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        int ans=stoi(to_string(nums1[0])+to_string(nums2[0]));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(nums1[i]==nums2[j]){\\n                    ans=min(ans,nums1[i]);\\n                }\\n                else{\\n                    int x;\\n                    if(nums1[i]<nums2[j]){\\n                        x=stoi(to_string(nums1[i])+to_string(nums2[j]));\\n                    }\\n                    else{\\n                        x=stoi(to_string(nums2[j])+to_string(nums1[i]));\\n                    }\\n                    ans=min(ans,x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        int ans=stoi(to_string(nums1[0])+to_string(nums2[0]));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(nums1[i]==nums2[j]){\\n                    ans=min(ans,nums1[i]);\\n                }\\n                else{\\n                    int x;\\n                    if(nums1[i]<nums2[j]){\\n                        x=stoi(to_string(nums1[i])+to_string(nums2[j]));\\n                    }\\n                    else{\\n                        x=stoi(to_string(nums2[j])+to_string(nums1[i]));\\n                    }\\n                    ans=min(ans,x);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933582,
                "title": "easy-to-understand-c-brute",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { \\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j]){\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        int q=(nums1[0]*10)+nums2[0];\\n        int r=(nums2[0]*10)+nums1[0];\\n        \\n        return min(q,r);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { \\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j]){\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        int q=(nums1[0]*10)+nums2[0];\\n        int r=(nums2[0]*10)+nums1[0];\\n        \\n        return min(q,r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933579,
                "title": "best-time-complexity-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Hashmap\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { // \\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int hash[10]={0};\\n        int min1=INT_MAX;\\n        for(int i=0;i<nums1.size();i++){\\n            hash[nums1[i]]++;\\n            min1=min(min1,nums1[i]);\\n        }\\n        int min2=INT_MAX;\\n        for(int j=0;j<nums2.size();j++){\\n            hash[nums2[j]]++;\\n            min2=min(min2,nums2[j]);\\n        }\\n        for(int i=0;i<10;i++){\\n            if(hash[i]==2){\\n                return i;\\n            }\\n        }\\n        int k=min1*10+min2;\\n        int w=min2*10+min1;\\n        return min(k,w);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { // \\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int hash[10]={0};\\n        int min1=INT_MAX;\\n        for(int i=0;i<nums1.size();i++){\\n            hash[nums1[i]]++;\\n            min1=min(min1,nums1[i]);\\n        }\\n        int min2=INT_MAX;\\n        for(int j=0;j<nums2.size();j++){\\n            hash[nums2[j]]++;\\n            min2=min(min2,nums2[j]);\\n        }\\n        for(int i=0;i<10;i++){\\n            if(hash[i]==2){\\n                return i;\\n            }\\n        }\\n        int k=min1*10+min2;\\n        int w=min2*10+min1;\\n        return min(k,w);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930321,
                "title": "c-using-bool-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n      // if(nums1||nums2==NULL){\\n      //   return;\\n      //   exit;\\n      // }\\n       int min1=*min_element(nums1.begin(),nums1.end());\\n       int min2=*min_element(nums2.begin(),nums2.end());\\n       bool isright= false;\\n       vector<int>store;\\n       int mn;\\n       for(int i=0;i<nums1.size();i++){\\n            for(int k=0;k<nums2.size();k++){\\n                if(nums1[i]==nums2[k]){\\n               store.push_back(nums1[i]);  \\n                  mn= *min_element(store.begin(),store.end());\\n                  isright=true;\\n                }\\n                \\n            }\\n       }      \\n       if(isright){\\n         return mn;\\n         exit;\\n       }\\n\\n        string s1= to_string(min1);\\n        string s2= to_string(min2);\\n        if(min1<min2){\\n        string s3= s1+s2;\\n        int ans= stoi(s3); \\n          return ans;\\n        }else{\\n          string s4= s2+s1;\\n        int ans1= stoi(s4); \\n          return ans1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n      // if(nums1||nums2==NULL){\\n      //   return;\\n      //   exit;\\n      // }\\n       int min1=*min_element(nums1.begin(),nums1.end());\\n       int min2=*min_element(nums2.begin(),nums2.end());\\n       bool isright= false;\\n       vector<int>store;\\n       int mn;\\n       for(int i=0;i<nums1.size();i++){\\n            for(int k=0;k<nums2.size();k++){\\n                if(nums1[i]==nums2[k]){\\n               store.push_back(nums1[i]);  \\n                  mn= *min_element(store.begin(),store.end());\\n                  isright=true;\\n                }\\n                \\n            }\\n       }      \\n       if(isright){\\n         return mn;\\n         exit;\\n       }\\n\\n        string s1= to_string(min1);\\n        string s2= to_string(min2);\\n        if(min1<min2){\\n        string s3= s1+s2;\\n        int ans= stoi(s3); \\n          return ans;\\n        }else{\\n          string s4= s2+s1;\\n        int ans1= stoi(s4); \\n          return ans1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924246,
                "title": "java-one-pass-o-m-n",
                "content": "# Intuition\\nEasy level. must have one pass.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int minBoth = Integer.MAX_VALUE, min1 = nums1[0], min2 = nums2[0];\\n        HashSet<Integer> set = new HashSet();\\n        for(int n : nums1) {\\n            min1 = Math.min(min1, n);\\n            set.add(n);\\n        }\\n\\n        for(int n : nums2) {\\n            min2 = Math.min(min2, n);\\n            if(set.contains(n)) minBoth = Math.min(minBoth, n);\\n        }\\n\\n        if(minBoth != Integer.MAX_VALUE) return minBoth;\\n        return min1 < min2 ? min1 * 10 + min2 : min2 * 10 + min1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int minBoth = Integer.MAX_VALUE, min1 = nums1[0], min2 = nums2[0];\\n        HashSet<Integer> set = new HashSet();\\n        for(int n : nums1) {\\n            min1 = Math.min(min1, n);\\n            set.add(n);\\n        }\\n\\n        for(int n : nums2) {\\n            min2 = Math.min(min2, n);\\n            if(set.contains(n)) minBoth = Math.min(minBoth, n);\\n        }\\n\\n        if(minBoth != Integer.MAX_VALUE) return minBoth;\\n        return min1 < min2 ? min1 * 10 + min2 : min2 * 10 + min1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893847,
                "title": "java-solution-hashmap-o-n-m-not-common-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust want to do this question whithout using 2 For Loops.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing hashMAp to solve this.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N+M)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nVery Much\\n# Code\\n```\\nclass Solution {\\n\\n    HashMap<Integer, Integer> map1 = new HashMap<>();\\n    HashMap<Integer, Integer> map2 = new HashMap<>();\\n    boolean flag  = false;\\n    ArrayList<Integer> common = new ArrayList<>();\\n\\n    public void mapping(int[] arr, HashMap<Integer,Integer> map){\\n\\n        for(int x : arr){\\n            if(map.containsKey(x)){\\n                map.put(x,map.get(x)+1);\\n            }else{\\n                map.put(x,1);\\n            }\\n\\n            if(flag == true){\\n                if(map1.containsKey(x)){\\n                    common.add(x);\\n                }\\n            }\\n        }\\n\\n        flag = true;\\n    }\\n\\n    public String minist(HashMap<Integer,Integer> map){\\n        Integer minValue =  new Integer(Integer.MAX_VALUE);\\n\\n        for(Map.Entry<Integer,Integer> e : map.entrySet()){\\n            if(e.getKey() < minValue){\\n                minValue = e.getKey();\\n            }\\n        }\\n\\n        String res = minValue.toString();\\n\\n        return res;\\n\\n    }\\n\\n\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        mapping(nums1, map1);\\n        mapping(nums2, map2);\\n        flag = false;\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int x : common){\\n            if(min > x){\\n                min = x;\\n                flag = true;\\n            }\\n        }\\n\\n        if(flag == true){\\n            return min;\\n        }\\n\\n        String str1 = minist(map1);\\n        String str2 = minist(map2);\\n        String ans = \"\";\\n\\n        if(Integer.parseInt(str1) <= Integer.parseInt(str2)){\\n            ans = str1 + str2;\\n        }else{\\n            ans = str2 + str1;\\n        }\\n\\n        \\n\\n\\n        return Integer.parseInt(ans);\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    HashMap<Integer, Integer> map1 = new HashMap<>();\\n    HashMap<Integer, Integer> map2 = new HashMap<>();\\n    boolean flag  = false;\\n    ArrayList<Integer> common = new ArrayList<>();\\n\\n    public void mapping(int[] arr, HashMap<Integer,Integer> map){\\n\\n        for(int x : arr){\\n            if(map.containsKey(x)){\\n                map.put(x,map.get(x)+1);\\n            }else{\\n                map.put(x,1);\\n            }\\n\\n            if(flag == true){\\n                if(map1.containsKey(x)){\\n                    common.add(x);\\n                }\\n            }\\n        }\\n\\n        flag = true;\\n    }\\n\\n    public String minist(HashMap<Integer,Integer> map){\\n        Integer minValue =  new Integer(Integer.MAX_VALUE);\\n\\n        for(Map.Entry<Integer,Integer> e : map.entrySet()){\\n            if(e.getKey() < minValue){\\n                minValue = e.getKey();\\n            }\\n        }\\n\\n        String res = minValue.toString();\\n\\n        return res;\\n\\n    }\\n\\n\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        mapping(nums1, map1);\\n        mapping(nums2, map2);\\n        flag = false;\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int x : common){\\n            if(min > x){\\n                min = x;\\n                flag = true;\\n            }\\n        }\\n\\n        if(flag == true){\\n            return min;\\n        }\\n\\n        String str1 = minist(map1);\\n        String str2 = minist(map2);\\n        String ans = \"\";\\n\\n        if(Integer.parseInt(str1) <= Integer.parseInt(str2)){\\n            ans = str1 + str2;\\n        }else{\\n            ans = str2 + str1;\\n        }\\n\\n        \\n\\n\\n        return Integer.parseInt(ans);\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890453,
                "title": "from-the-smallest-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        for i in sorted(nums1):\\n            if i in nums2:\\n                return i\\n        i=str(min(nums1))\\n        j=str(min(nums2))\\n        return int(i+j) if j>i else int(j+i) \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        for i in sorted(nums1):\\n            if i in nums2:\\n                return i\\n        i=str(min(nums1))\\n        j=str(min(nums2))\\n        return int(i+j) if j>i else int(j+i) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887606,
                "title": "array-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nTime Complexity: O(N * M)\\nSpace Complexity: O(N * M)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinNumber(int[] nums1, int[] nums2) \\n    {\\n        int[] duplicatedAndMins = GetDuplicatedNumberAddMinNumbers(nums1, nums2);\\n        if(duplicatedAndMins.Length==2)\\n        {\\n            if(duplicatedAndMins[0] <= duplicatedAndMins[1])\\n            {\\n                return duplicatedAndMins[0] * 10 +  duplicatedAndMins[1];\\n            }\\n            else\\n            {\\n                return duplicatedAndMins[1] * 10 +  duplicatedAndMins[0];\\n            }\\n        }\\n        else\\n        {\\n            int min = duplicatedAndMins[0];\\n            for (int i = 0; i <= duplicatedAndMins.Length - 3; i++)\\n            {\\n                if(min > duplicatedAndMins[i])\\n                {\\n                    min = duplicatedAndMins[i];\\n                }\\n            }\\n            return min;\\n        }\\n    }\\n\\n    private int[] GetDuplicatedNumberAddMinNumbers(int[] nums1, int[] nums2)\\n    {\\n        List<int> result = new List<int>();\\n        int minA = nums1[0];\\n        int minB = nums2[0];\\n\\n        foreach (int a in nums1)\\n        {\\n            if (minA > a)\\n            {\\n                minA = a;\\n            }\\n            foreach (int b in nums2)\\n            {\\n                if(minB > b)\\n                {\\n                    minB = b;\\n                }\\n                if(a==b)\\n                {\\n                    result.Add(a);\\n                }\\n            }\\n        }\\n        result.Add(minA);\\n        result.Add(minB);\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinNumber(int[] nums1, int[] nums2) \\n    {\\n        int[] duplicatedAndMins = GetDuplicatedNumberAddMinNumbers(nums1, nums2);\\n        if(duplicatedAndMins.Length==2)\\n        {\\n            if(duplicatedAndMins[0] <= duplicatedAndMins[1])\\n            {\\n                return duplicatedAndMins[0] * 10 +  duplicatedAndMins[1];\\n            }\\n            else\\n            {\\n                return duplicatedAndMins[1] * 10 +  duplicatedAndMins[0];\\n            }\\n        }\\n        else\\n        {\\n            int min = duplicatedAndMins[0];\\n            for (int i = 0; i <= duplicatedAndMins.Length - 3; i++)\\n            {\\n                if(min > duplicatedAndMins[i])\\n                {\\n                    min = duplicatedAndMins[i];\\n                }\\n            }\\n            return min;\\n        }\\n    }\\n\\n    private int[] GetDuplicatedNumberAddMinNumbers(int[] nums1, int[] nums2)\\n    {\\n        List<int> result = new List<int>();\\n        int minA = nums1[0];\\n        int minB = nums2[0];\\n\\n        foreach (int a in nums1)\\n        {\\n            if (minA > a)\\n            {\\n                minA = a;\\n            }\\n            foreach (int b in nums2)\\n            {\\n                if(minB > b)\\n                {\\n                    minB = b;\\n                }\\n                if(a==b)\\n                {\\n                    result.Add(a);\\n                }\\n            }\\n        }\\n        result.Add(minA);\\n        result.Add(minB);\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887605,
                "title": "array-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nTime Complexity: O(N * M)\\nSpace Complexity: O(N * M)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinNumber(int[] nums1, int[] nums2) \\n    {\\n        int[] duplicatedAndMins = GetDuplicatedNumberAddMinNumbers(nums1, nums2);\\n        if(duplicatedAndMins.Length==2)\\n        {\\n            if(duplicatedAndMins[0] <= duplicatedAndMins[1])\\n            {\\n                return duplicatedAndMins[0] * 10 +  duplicatedAndMins[1];\\n            }\\n            else\\n            {\\n                return duplicatedAndMins[1] * 10 +  duplicatedAndMins[0];\\n            }\\n        }\\n        else\\n        {\\n            int min = duplicatedAndMins[0];\\n            for (int i = 0; i <= duplicatedAndMins.Length - 3; i++)\\n            {\\n                if(min > duplicatedAndMins[i])\\n                {\\n                    min = duplicatedAndMins[i];\\n                }\\n            }\\n            return min;\\n        }\\n    }\\n\\n    private int[] GetDuplicatedNumberAddMinNumbers(int[] nums1, int[] nums2)\\n    {\\n        List<int> result = new List<int>();\\n        int minA = nums1[0];\\n        int minB = nums2[0];\\n\\n        foreach (int a in nums1)\\n        {\\n            if (minA > a)\\n            {\\n                minA = a;\\n            }\\n            foreach (int b in nums2)\\n            {\\n                if(minB > b)\\n                {\\n                    minB = b;\\n                }\\n                if(a==b)\\n                {\\n                    result.Add(a);\\n                }\\n            }\\n        }\\n        result.Add(minA);\\n        result.Add(minB);\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinNumber(int[] nums1, int[] nums2) \\n    {\\n        int[] duplicatedAndMins = GetDuplicatedNumberAddMinNumbers(nums1, nums2);\\n        if(duplicatedAndMins.Length==2)\\n        {\\n            if(duplicatedAndMins[0] <= duplicatedAndMins[1])\\n            {\\n                return duplicatedAndMins[0] * 10 +  duplicatedAndMins[1];\\n            }\\n            else\\n            {\\n                return duplicatedAndMins[1] * 10 +  duplicatedAndMins[0];\\n            }\\n        }\\n        else\\n        {\\n            int min = duplicatedAndMins[0];\\n            for (int i = 0; i <= duplicatedAndMins.Length - 3; i++)\\n            {\\n                if(min > duplicatedAndMins[i])\\n                {\\n                    min = duplicatedAndMins[i];\\n                }\\n            }\\n            return min;\\n        }\\n    }\\n\\n    private int[] GetDuplicatedNumberAddMinNumbers(int[] nums1, int[] nums2)\\n    {\\n        List<int> result = new List<int>();\\n        int minA = nums1[0];\\n        int minB = nums2[0];\\n\\n        foreach (int a in nums1)\\n        {\\n            if (minA > a)\\n            {\\n                minA = a;\\n            }\\n            foreach (int b in nums2)\\n            {\\n                if(minB > b)\\n                {\\n                    minB = b;\\n                }\\n                if(a==b)\\n                {\\n                    result.Add(a);\\n                }\\n            }\\n        }\\n        result.Add(minA);\\n        result.Add(minB);\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886498,
                "title": "java-simple-solution-using-arrays-s-methods",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, sort two arrays\\n\\nThere are two scenarios of the result:\\n- One digit if exist at least one mutual number between two arrays (1)\\n- Two digits if no mutual number between two arrays (2)\\n\\nFor the first case (1), we return the smallest mutual number.\\n\\nFor the second case (2), we select the smallest number for each array, then the greater one will be the unit digit, and the other will be the dozen digit.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        for (int num : nums1) {\\n            if (Arrays.binarySearch(nums2, num) >= 0) return num;\\n        }\\n        if (nums1[0] > nums2[0]) return nums2[0] * 10 + nums1[0];\\n        else return nums1[0] * 10 + nums2[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        for (int num : nums1) {\\n            if (Arrays.binarySearch(nums2, num) >= 0) return num;\\n        }\\n        if (nums1[0] > nums2[0]) return nums2[0] * 10 + nums1[0];\\n        else return nums1[0] * 10 + nums2[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885491,
                "title": "easy-way-with-time-45ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n    let min1 = 0;\\n    for(let a of nums1) {\\n        for (let b of nums2) {\\n            if ((a === b && min1 ===0) || (a === b && min1 > a)) min1 = a;\\n        }\\n    }\\n    if (min1 === 0) {\\n        Math.min(...nums1) >= Math.min(...nums2)? min1 =Math.min(...nums2) * 10 + Math.min(...nums1) : min1 =Math.min(...nums1) * 10 + Math.min(...nums2)\\n    }\\n\\n    return min1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n    let min1 = 0;\\n    for(let a of nums1) {\\n        for (let b of nums2) {\\n            if ((a === b && min1 ===0) || (a === b && min1 > a)) min1 = a;\\n        }\\n    }\\n    if (min1 === 0) {\\n        Math.min(...nums1) >= Math.min(...nums2)? min1 =Math.min(...nums2) * 10 + Math.min(...nums1) : min1 =Math.min(...nums1) * 10 + Math.min(...nums2)\\n    }\\n\\n    return min1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879892,
                "title": "masum-code-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>mp;\\n        for(auto x:nums1)\\n        {\\n            mp[x]++;\\n        }\\n        for(auto x:nums2)\\n        {\\n            mp[x]++;\\n        }\\n\\n        int mn1=*min_element(nums1.begin(),nums1.end());\\n        int mn2=*min_element(nums2.begin(),nums2.end());\\n        for(auto x:mp)\\n        {\\n            if(x.second>1)\\n            {\\n                return x.first;\\n            }\\n        }\\n        string ans;\\n\\n        if(mn1>mn2)\\n        {\\n            ans=to_string(mn2)+to_string(mn1);\\n        }\\n        else\\n        {\\n            ans=ans=to_string(mn1)+to_string(mn2);\\n        }\\n        return stoi(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>mp;\\n        for(auto x:nums1)\\n        {\\n            mp[x]++;\\n        }\\n        for(auto x:nums2)\\n        {\\n            mp[x]++;\\n        }\\n\\n        int mn1=*min_element(nums1.begin(),nums1.end());\\n        int mn2=*min_element(nums2.begin(),nums2.end());\\n        for(auto x:mp)\\n        {\\n            if(x.second>1)\\n            {\\n                return x.first;\\n            }\\n        }\\n        string ans;\\n\\n        if(mn1>mn2)\\n        {\\n            ans=to_string(mn2)+to_string(mn1);\\n        }\\n        else\\n        {\\n            ans=ans=to_string(mn1)+to_string(mn2);\\n        }\\n        return stoi(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867575,
                "title": "c-simplest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>m;\\n        int x=INT_MAX;\\n        for(int i=0;i<nums1.size();i++){\\n            m[nums1[i]]++;\\n        }\\n       for(int i=0;i<nums2.size();i++){\\n            m[nums2[i]]++;\\n           if(m[nums2[i]]>1){\\n               x=min(x,nums2[i]);\\n           }\\n        }\\n        if(x==INT_MAX){\\n            sort(nums2.begin(),nums2.end());\\n            sort(nums1.begin(),nums1.end());\\n                return min(nums1[0]*10+nums2[0],nums2[0]*10+nums1[0]);\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>m;\\n        int x=INT_MAX;\\n        for(int i=0;i<nums1.size();i++){\\n            m[nums1[i]]++;\\n        }\\n       for(int i=0;i<nums2.size();i++){\\n            m[nums2[i]]++;\\n           if(m[nums2[i]]>1){\\n               x=min(x,nums2[i]);\\n           }\\n        }\\n        if(x==INT_MAX){\\n            sort(nums2.begin(),nums2.end());\\n            sort(nums1.begin(),nums1.end());\\n                return min(nums1[0]*10+nums2[0],nums2[0]*10+nums1[0]);\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867384,
                "title": "most-easy-solution-fast-efficient-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<nums1.length; i++){\\n            for(int j=0; j<nums2.length; j++){\\n                if(nums1[i]==nums2[j]){\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n\\n        if(nums1[0]<nums2[0]){\\n            ans += nums1[0];\\n            ans = (ans*10)+nums2[0];\\n        }else{\\n            ans += nums2[0];\\n            ans = (ans*10)+nums1[0];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<nums1.length; i++){\\n            for(int j=0; j<nums2.length; j++){\\n                if(nums1[i]==nums2[j]){\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n\\n        if(nums1[0]<nums2[0]){\\n            ans += nums1[0];\\n            ans = (ans*10)+nums2[0];\\n        }else{\\n            ans += nums2[0];\\n            ans = (ans*10)+nums1[0];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864215,
                "title": "simple-o-n1-n2-solution-beat-100",
                "content": "# Intuition\\n1. Use an array of length 10 to store the frequency of each digit in nums1 and nums2 together. Then if some number has a frequency of 2, it meaning it appears in both nums1 and nums2 (each array contains unique digits).Then we could return this number directly(using the while loop we find this number).\\n2. When we traverse along nums1 and nums2 we also find the minimum value of each array (i.e. min1 and min2), if we could not find any number of frequency 2 we use min1 and min2 to form our final answer. We use the minimum of min1 and min2 to be the 1st digit and the other one to be the 2nd digit of our answer. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n1+n2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int freq[] = new int[10];\\n        int min1=Integer.MAX_VALUE, min2=Integer.MAX_VALUE;\\n        for (int i=0; i<nums1.length; i++){\\n            min1 = Math.min(nums1[i], min1);\\n            freq[nums1[i]]++;\\n        }\\n        for (int i=0; i<nums2.length; i++){\\n            min2 = Math.min(nums2[i], min2);\\n            freq[nums2[i]]++;\\n        }\\n        int i=1;\\n//this while loop find the first/min number that appears in both\\n//arrays. There are 3 cases\\n//case 1) more than one digit that appears in both arrays:\\n//e.g. both 2 and 7 appears in both arrays, i will be 2. \\n//case 2) only one digit appears in both arrays: \\n//if only 3 appears twice, i will be 3.\\n//and case 3)if none of the digit appears twice, i==10.\\n        while (i<10 && freq[i] < 2){\\n            i++;\\n        }\\n//if i<10, case 1 or 2, we return i, else we return the number\\n//formed by min1 and min2.\\n        return i<10? i : Math.min(min1, min2)*10 + Math.max(min1, min2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int freq[] = new int[10];\\n        int min1=Integer.MAX_VALUE, min2=Integer.MAX_VALUE;\\n        for (int i=0; i<nums1.length; i++){\\n            min1 = Math.min(nums1[i], min1);\\n            freq[nums1[i]]++;\\n        }\\n        for (int i=0; i<nums2.length; i++){\\n            min2 = Math.min(nums2[i], min2);\\n            freq[nums2[i]]++;\\n        }\\n        int i=1;\\n//this while loop find the first/min number that appears in both\\n//arrays. There are 3 cases\\n//case 1) more than one digit that appears in both arrays:\\n//e.g. both 2 and 7 appears in both arrays, i will be 2. \\n//case 2) only one digit appears in both arrays: \\n//if only 3 appears twice, i will be 3.\\n//and case 3)if none of the digit appears twice, i==10.\\n        while (i<10 && freq[i] < 2){\\n            i++;\\n        }\\n//if i<10, case 1 or 2, we return i, else we return the number\\n//formed by min1 and min2.\\n        return i<10? i : Math.min(min1, min2)*10 + Math.max(min1, min2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862261,
                "title": "sets-intersect-or-min-max-logic",
                "content": "## Code\\n![image.png](https://assets.leetcode.com/users/images/dcd81341-db36-4c55-960f-a646d2d20ed9_1691144859.8201437.png)\\n\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1 = set(nums1)\\n        nums2 = set(nums2)\\n        intersect = nums1 & nums2\\n        \\n        if intersect:\\n            return min(intersect)\\n        \\n        min_1, min_2 = min(nums1), min(nums2)\\n        return min(min_1, min_2) * 10 + max(min_1, min_2)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1 = set(nums1)\\n        nums2 = set(nums2)\\n        intersect = nums1 & nums2\\n        \\n        if intersect:\\n            return min(intersect)\\n        \\n        min_1, min_2 = min(nums1), min(nums2)\\n        return min(min_1, min_2) * 10 + max(min_1, min_2)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861195,
                "title": "form-smallest-number-from-two-digit-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        String str = new String();\\n        int min = Integer.MAX_VALUE;\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            arr.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            if(arr.contains(nums2[i]))\\n            min = Math.min(min,nums2[i]);\\n        }\\n        if(nums1[0]>nums2[0])\\n        {\\n            str = String.valueOf(nums2[0])+String.valueOf(nums1[0]);\\n        }\\n        else if(nums1[0]<nums2[0])\\n        {\\n            str = String.valueOf(nums1[0])+String.valueOf(nums2[0]);\\n        }\\n        if(str.isEmpty()==false)\\n        min = Math.min(min,Integer.valueOf(str));\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        String str = new String();\\n        int min = Integer.MAX_VALUE;\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            arr.add(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            if(arr.contains(nums2[i]))\\n            min = Math.min(min,nums2[i]);\\n        }\\n        if(nums1[0]>nums2[0])\\n        {\\n            str = String.valueOf(nums2[0])+String.valueOf(nums1[0]);\\n        }\\n        else if(nums1[0]<nums2[0])\\n        {\\n            str = String.valueOf(nums1[0])+String.valueOf(nums2[0]);\\n        }\\n        if(str.isEmpty()==false)\\n        min = Math.min(min,Integer.valueOf(str));\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860532,
                "title": "swift-o-n-time-o-1-space-novel-bit-manipulation-answer",
                "content": "This solution sets bits in the variables `seen1` and `seen2` corresponding to the numbers seen in `nums1` and `nums2` respectively. The minimum integer seen can then be found using `trailingZeroBitCount`.\\n\\nIt then uses a logical AND to determine if a number occurs in both arrays, and if so returns a single digit answer.\\n\\nIf there is no single digit answer it forms the minimum integer from the minimum numbers seen in each input array.\\n\\n# Complexity\\n\\n$$ \\\\text{let}\\\\ N = max(nums_1.length, nums_2.length)$$\\n$$ \\\\text{Time:}\\\\ O(n)$$\\n$$ \\\\text{Space:}\\\\ O(1)$$\\n \\n# Code\\n```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        var seen1 = nums1.reduce(0) { $0 | 1 << $1 }\\n        var seen2 = nums2.reduce(0) { $0 | 1 << $1 }\\n        let both = seen1 & seen2\\n        if  both != 0 {\\n            return both.trailingZeroBitCount\\n        }\\n        let min1 = seen1.trailingZeroBitCount\\n        let min2 = seen2.trailingZeroBitCount\\n        return min1 < min2 ? min1 * 10 + min2 : min2 * 10 + min1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        var seen1 = nums1.reduce(0) { $0 | 1 << $1 }\\n        var seen2 = nums2.reduce(0) { $0 | 1 << $1 }\\n        let both = seen1 & seen2\\n        if  both != 0 {\\n            return both.trailingZeroBitCount\\n        }\\n        let min1 = seen1.trailingZeroBitCount\\n        let min2 = seen2.trailingZeroBitCount\\n        return min1 < min2 ? min1 * 10 + min2 : min2 * 10 + min1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856111,
                "title": "java-fastest-solution",
                "content": "# Complexity\\n- Time complexity: *O(n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(1)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n       boolean[] arr1 = new boolean[10];\\n       boolean[] arr2 = new boolean[10];\\n       int res = 0; \\n\\n       for(int i : nums1)\\n         arr1[i] = true;\\n        \\n       for(int j : nums2)\\n         arr2[j] = true;\\n       \\n       for(int i = 0; i < 10; i++)\\n         if(arr1[i] && arr2[i]) return i;\\n       \\n       for(int i = 0; i < 10; i++)\\n           if(arr1[i]){\\n             res = res * 10 + i;\\n             break;\\n           }\\n       for(int i = 0; i < 10; i++)\\n           if(arr2[i]){\\n             res = res * 10 + i;\\n             break;\\n           }\\n      return Math.min(res, res % 10 * 10 + res/10);    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n       boolean[] arr1 = new boolean[10];\\n       boolean[] arr2 = new boolean[10];\\n       int res = 0; \\n\\n       for(int i : nums1)\\n         arr1[i] = true;\\n        \\n       for(int j : nums2)\\n         arr2[j] = true;\\n       \\n       for(int i = 0; i < 10; i++)\\n         if(arr1[i] && arr2[i]) return i;\\n       \\n       for(int i = 0; i < 10; i++)\\n           if(arr1[i]){\\n             res = res * 10 + i;\\n             break;\\n           }\\n       for(int i = 0; i < 10; i++)\\n           if(arr2[i]){\\n             res = res * 10 + i;\\n             break;\\n           }\\n      return Math.min(res, res % 10 * 10 + res/10);    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849335,
                "title": "hashset-and-math-min-max-solution-code-only",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MinNumber(int[] nums1, int[] nums2) {\\n        HashSet<int> h1 = new HashSet<int>(nums1);\\n        HashSet<int> h2 = new HashSet<int>(nums2);\\n        int m = 10;\\n        foreach (int k in h1)\\n            if (h2.Contains(k))\\n                m = Math.Min(m,k);\\n        if (m<10) return m;\\n\\n        int n1 = nums1.Min(), n2 = nums2.Min();\\n        return Math.Max(n1,n2) + 10*Math.Min(n1,n2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinNumber(int[] nums1, int[] nums2) {\\n        HashSet<int> h1 = new HashSet<int>(nums1);\\n        HashSet<int> h2 = new HashSet<int>(nums2);\\n        int m = 10;\\n        foreach (int k in h1)\\n            if (h2.Contains(k))\\n                m = Math.Min(m,k);\\n        if (m<10) return m;\\n\\n        int n1 = nums1.Min(), n2 = nums2.Min();\\n        return Math.Max(n1,n2) + 10*Math.Min(n1,n2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838199,
                "title": "dart-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int minNumber(List<int> nums1, List<int> nums2) {\\n      nums1.sort();\\n      nums2.sort();\\n      int small = 100;\\n      int output = 0;\\n      if (nums1[0] > nums2[0]){\\n          output = int.parse(nums2[0].toString() + nums1[0].toString());\\n      } else {\\n        output = int.parse(nums1[0].toString() + nums2[0].toString());\\n      }\\n      \\n      for (final nums in nums1){\\n        if (nums2.any((element) => nums == element)){\\n          small = min(small,nums);\\n        }\\n      }\\n\\n      for (final nums in nums2){\\n        if (nums1.any((element) => nums == element)){\\n          small = min(small,nums);\\n        }\\n      }\\n      return min(small,output);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int minNumber(List<int> nums1, List<int> nums2) {\\n      nums1.sort();\\n      nums2.sort();\\n      int small = 100;\\n      int output = 0;\\n      if (nums1[0] > nums2[0]){\\n          output = int.parse(nums2[0].toString() + nums1[0].toString());\\n      } else {\\n        output = int.parse(nums1[0].toString() + nums2[0].toString());\\n      }\\n      \\n      for (final nums in nums1){\\n        if (nums2.any((element) => nums == element)){\\n          small = min(small,nums);\\n        }\\n      }\\n\\n      for (final nums in nums2){\\n        if (nums1.any((element) => nums == element)){\\n          small = min(small,nums);\\n        }\\n      }\\n      return min(small,output);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834113,
                "title": "beats-98-29-runtime-using-min-set-and-for-loop-easy-to-understand",
                "content": "# Intuition\\nthe answer lies in just focusing on finding the min element from both the arrays and make sure if there is a repeated elements, u need to choose minimum from them\\n\\n# Approach\\nused min() fn to get \\'mn1\\' and \\'mn2\\' values\\ncreated \\'res[]\\' empty array to store the final answer if elemtns repeated in both arrays\\nconcatinated both the arrays in single unit using \\'extend()\\' fuction\\nthen used conditional statements to form the minimum possibe number (determining which one is minimum mn1 or mn2)\\nthen for case 2 (common elements) created res[] empty array and stored the value and then the minimum value from it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        mn1 = min(nums1)\\n        mn2 = min(nums2)\\n        res =[]\\n        nums1.extend(nums2)\\n        if len(nums1) == len(set(nums1)):\\n            if mn1 <= mn2:\\n                return mn1*10 + mn2\\n            return mn2*10 + mn1   \\n        for i in nums1:\\n            if nums1.count(i) == 2:\\n                res.append(i)\\n        return min(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        mn1 = min(nums1)\\n        mn2 = min(nums2)\\n        res =[]\\n        nums1.extend(nums2)\\n        if len(nums1) == len(set(nums1)):\\n            if mn1 <= mn2:\\n                return mn1*10 + mn2\\n            return mn2*10 + mn1   \\n        for i in nums1:\\n            if nums1.count(i) == 2:\\n                res.append(i)\\n        return min(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830266,
                "title": "easy-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        int a=nums1[0];\\n        Arrays.sort(nums2);\\n        int b=nums2[0];\\n        for(int i=0;i<nums1.length;i++){\\n            for(int j=0;j<nums2.length;j++){\\n                if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            }\\n        }\\n        return (a>b)?b*10+a:a*10+b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        int a=nums1[0];\\n        Arrays.sort(nums2);\\n        int b=nums2[0];\\n        for(int i=0;i<nums1.length;i++){\\n            for(int j=0;j<nums2.length;j++){\\n                if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            }\\n        }\\n        return (a>b)?b*10+a:a*10+b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828944,
                "title": "begginer-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        int a=nums1[0];\\n        Arrays.sort(nums2);\\n        int b=nums2[0];\\n        for(int i=0;i<nums1.length;i++){\\n            for(int j=0;j<nums2.length;j++){\\n                if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            }\\n        }\\n        return (a>b)?b*10+a:a*10+b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        int a=nums1[0];\\n        Arrays.sort(nums2);\\n        int b=nums2[0];\\n        for(int i=0;i<nums1.length;i++){\\n            for(int j=0;j<nums2.length;j++){\\n                if(nums1[i]==nums2[j])\\n                return nums1[i];\\n            }\\n        }\\n        return (a>b)?b*10+a:a*10+b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828135,
                "title": "typescript-100",
                "content": "Your runtime beats 100 % of typescript submissions\\nYour memory usage beats 20.83 % of typescript submissions (44.8 MB)\\n\\n# Code\\n```\\nfunction minNumber(nums1: number[], nums2: number[]): number {\\n    const same: Array<number> = [];\\n    for (let i: number = 0; i < nums1.length; i++) {\\n        for (let j: number = 0; j < nums2.length; j++) {\\n            if (nums1[i] === nums2[j]) {\\n                same.push(nums1[i]);\\n            }\\n        }\\n    }\\n    same.sort((a, b) => a - b);\\n    if (same.length > 0) {\\n        return same[0];\\n    }\\n    nums1.sort((a, b) => a - b);\\n    nums2.sort((a, b) => a - b);\\n    return Math.min(nums1[0], nums2[0]) * 10 + Math.max(nums1[0], nums2[0]);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minNumber(nums1: number[], nums2: number[]): number {\\n    const same: Array<number> = [];\\n    for (let i: number = 0; i < nums1.length; i++) {\\n        for (let j: number = 0; j < nums2.length; j++) {\\n            if (nums1[i] === nums2[j]) {\\n                same.push(nums1[i]);\\n            }\\n        }\\n    }\\n    same.sort((a, b) => a - b);\\n    if (same.length > 0) {\\n        return same[0];\\n    }\\n    nums1.sort((a, b) => a - b);\\n    nums2.sort((a, b) => a - b);\\n    return Math.min(nums1[0], nums2[0]) * 10 + Math.max(nums1[0], nums2[0]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3827826,
                "title": "simple-java-solution-1ms",
                "content": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        for(int i=0; i<nums1.length; i++) {\\n            for (int j = 0; j < nums2.length; j++) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        int min = Math.min(nums1[0], nums2[0]);\\n        int max = Math.max(nums1[0], nums2[0]);\\n        return min * 10 + max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        for(int i=0; i<nums1.length; i++) {\\n            for (int j = 0; j < nums2.length; j++) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        int min = Math.min(nums1[0], nums2[0]);\\n        int max = Math.max(nums1[0], nums2[0]);\\n        return min * 10 + max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812421,
                "title": "dart",
                "content": "# Code\\n```\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int minNumber(List<int> nums1, List<int> nums2) {\\n    var count = List.filled(10, 0);\\n    var min1 = 1000000000, min2 = min1;\\n    for (int v in nums1) {\\n      count[v]++;\\n      min1 = min(min1, v);\\n    }\\n    for (int v in nums2) {\\n      count[v]++;\\n      min2 = min(min2, v);\\n    }\\n    for (int i = 1; i <= 9; i++)\\n      if (count[i] == 2) return i;\\n    return min(\\n      min1 * 10 + min2, min2 * 10 + min1\\n    );\\n  }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int minNumber(List<int> nums1, List<int> nums2) {\\n    var count = List.filled(10, 0);\\n    var min1 = 1000000000, min2 = min1;\\n    for (int v in nums1) {\\n      count[v]++;\\n      min1 = min(min1, v);\\n    }\\n    for (int v in nums2) {\\n      count[v]++;\\n      min2 = min(min2, v);\\n    }\\n    for (int i = 1; i <= 9; i++)\\n      if (count[i] == 2) return i;\\n    return min(\\n      min1 * 10 + min2, min2 * 10 + min1\\n    );\\n  }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805118,
                "title": "swift-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        \\n        for num in nums1.sorted() {\\n            if nums2.contains(num) { return num }\\n        }\\n\\n        guard let min1 = nums1.min(), let min2 = nums2.min() else { return 0 }\\n\\n        return min1 > min2 ? Int(String(min2) + String(min1))! : Int(String(min1) + String(min2))!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    func minNumber(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        \\n        for num in nums1.sorted() {\\n            if nums2.contains(num) { return num }\\n        }\\n\\n        guard let min1 = nums1.min(), let min2 = nums2.min() else { return 0 }\\n\\n        return min1 > min2 ? Int(String(min2) + String(min1))! : Int(String(min1) + String(min2))!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796895,
                "title": "beat-94ms-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1 = list(set(nums1))\\n        nums1.sort()\\n        for i in nums1:\\n            if i in nums2:\\n                return i\\n\\n        first = min(nums1)\\n        second = min(nums2)\\n        if first < second:\\n\\n            return int(str(first)+str(second))\\n\\n        return int(str(second)+str(first))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1 = list(set(nums1))\\n        nums1.sort()\\n        for i in nums1:\\n            if i in nums2:\\n                return i\\n\\n        first = min(nums1)\\n        second = min(nums2)\\n        if first < second:\\n\\n            return int(str(first)+str(second))\\n\\n        return int(str(second)+str(first))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791969,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n   \\n   Arrays.sort(nums1);\\n   Arrays.sort(nums2);\\n    for(int i:nums1)\\n    {\\n        for(int j:nums2)\\n        {\\n            if(i==j)\\n            {\\n                return i;\\n            }\\n        }\\n    }\\n   int result=nums1[0]*10+nums2[0];\\n   int result1=nums2[0]*10+nums1[0];\\n\\n   return (result<result1)?result:result1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n   \\n   Arrays.sort(nums1);\\n   Arrays.sort(nums2);\\n    for(int i:nums1)\\n    {\\n        for(int j:nums2)\\n        {\\n            if(i==j)\\n            {\\n                return i;\\n            }\\n        }\\n    }\\n   int result=nums1[0]*10+nums2[0];\\n   int result1=nums2[0]*10+nums1[0];\\n\\n   return (result<result1)?result:result1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791710,
                "title": "long-but-simplest-code",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int nu(string s){\\n        int sum = 0;\\n        for(int i=0; i<s.size(); i++){\\n            sum=sum*10+s[i];\\n        }\\n        return sum;\\n    }\\n\\n    int minNumber(vector<int>&n1 , vector<int>&n2){\\n        unordered_map<int,int>mp;\\n        for(auto i:n1){\\n            mp[i]++;\\n        }\\n        for(auto i:n2){\\n            mp[i]++;\\n        }\\n        vector<int>h;\\n        for(auto i:mp){\\n            if(i.second==2){\\n                h.push_back(i.first);\\n            }\\n        }\\n        sort(h.begin(),h.end());\\n        if(h.size()!=0){\\n            return h[0];\\n        }\\n        sort(n1.begin(),n1.end());\\n        sort(n2.begin(),n2.end());\\n        string s1 , s2;\\n        s1+=n1[0];\\n        s1+=n2[0];\\n        s2+=n2[0];\\n        s2+=n1[0];\\n        int x = nu(s1);\\n        int y = nu(s2);\\n        return min(x,y);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int nu(string s){\\n        int sum = 0;\\n        for(int i=0; i<s.size(); i++){\\n            sum=sum*10+s[i];\\n        }\\n        return sum;\\n    }\\n\\n    int minNumber(vector<int>&n1 , vector<int>&n2){\\n        unordered_map<int,int>mp;\\n        for(auto i:n1){\\n            mp[i]++;\\n        }\\n        for(auto i:n2){\\n            mp[i]++;\\n        }\\n        vector<int>h;\\n        for(auto i:mp){\\n            if(i.second==2){\\n                h.push_back(i.first);\\n            }\\n        }\\n        sort(h.begin(),h.end());\\n        if(h.size()!=0){\\n            return h[0];\\n        }\\n        sort(n1.begin(),n1.end());\\n        sort(n2.begin(),n2.end());\\n        string s1 , s2;\\n        s1+=n1[0];\\n        s1+=n2[0];\\n        s2+=n2[0];\\n        s2+=n1[0];\\n        int x = nu(s1);\\n        int y = nu(s2);\\n        return min(x,y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779688,
                "title": "beginner-friendly-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n\\n        int x=nums1[0];\\n        int y=nums2[0];\\n\\n        if(x<y)\\n        {\\n            return x*10+y;\\n        }\\n        else\\n        {\\n           return y*10+x;\\n        }\\n        return 0; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n\\n        int x=nums1[0];\\n        int y=nums2[0];\\n\\n        if(x<y)\\n        {\\n            return x*10+y;\\n        }\\n        else\\n        {\\n           return y*10+x;\\n        }\\n        return 0; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774850,
                "title": "java-easy-to-understand-100-fastest",
                "content": "# Approach\\nsince our sample space is 1-9 digit, we\\'ll mark presence of digit as `True` in each boolean array for each num array\\nNow, if both boolean array has `True` in it, then it\\'s common digit and we\\'ll return that digit\\nOtherwise we\\'ll return min digit from one array * 10 + min digit from another array.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        boolean[] first = new boolean[9];\\n        boolean[] second = new boolean[9];\\n        int smallFirst = 10, smallSecond = 10;\\n        for(short i = 0; i <nums1.length; i++){\\n            first[nums1[i]-1] = true;\\n            if(nums1[i]<smallFirst) smallFirst = nums1[i];\\n        }\\n        for(short i = 0; i <nums2.length; i++){\\n            second[nums2[i]-1] = true;\\n            if(nums2[i]<smallSecond) smallSecond = nums2[i];\\n        }\\n        for(short i = 0; i < 9; i++){\\n            if(first[i] == true && second[i] == true) {\\n                return i+1;\\n            }\\n        }\\n        int ans = 0;\\n\\n        if(smallFirst < smallSecond) {\\n            ans = (smallFirst*10) + smallSecond;\\n        } else {\\n            ans = (smallSecond*10) + smallFirst;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        boolean[] first = new boolean[9];\\n        boolean[] second = new boolean[9];\\n        int smallFirst = 10, smallSecond = 10;\\n        for(short i = 0; i <nums1.length; i++){\\n            first[nums1[i]-1] = true;\\n            if(nums1[i]<smallFirst) smallFirst = nums1[i];\\n        }\\n        for(short i = 0; i <nums2.length; i++){\\n            second[nums2[i]-1] = true;\\n            if(nums2[i]<smallSecond) smallSecond = nums2[i];\\n        }\\n        for(short i = 0; i < 9; i++){\\n            if(first[i] == true && second[i] == true) {\\n                return i+1;\\n            }\\n        }\\n        int ans = 0;\\n\\n        if(smallFirst < smallSecond) {\\n            ans = (smallFirst*10) + smallSecond;\\n        } else {\\n            ans = (smallSecond*10) + smallFirst;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768811,
                "title": "kotlin-one-pass-solution-with-booleanarray-and-without-sorting",
                "content": "# Code\\n```\\nclass Solution {\\n    fun minNumber(nums1: IntArray, nums2: IntArray): Int {\\n        val digitMap = BooleanArray(9)\\n        var minCommonDigit = 10\\n        var minDigit1 = 9\\n        var minDigit2 = 9\\n        var i = 0\\n\\n        while (i < Math.max(nums1.size, nums2.size)) {\\n            if (i < nums1.size) {\\n                minDigit1 = Math.min(minDigit1, nums1[i])\\n                if (digitMap[nums1[i]-1])\\n                    minCommonDigit = Math.min(minCommonDigit, nums1[i])\\n                else\\n                    digitMap[nums1[i]-1] = true\\n            }\\n\\n            if (i < nums2.size) {\\n                minDigit2 = Math.min(minDigit2, nums2[i])\\n                if (digitMap[nums2[i]-1])\\n                    minCommonDigit = Math.min(minCommonDigit, nums2[i])\\n                else\\n                    digitMap[nums2[i]-1] = true\\n            }\\n\\n            i++\\n        }\\n\\n        if (minCommonDigit < 10)\\n            return minCommonDigit\\n\\n        if (minDigit1 < minDigit2)\\n            return \"$minDigit1$minDigit2\".toInt()\\n\\n        return \"$minDigit2$minDigit1\".toInt()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minNumber(nums1: IntArray, nums2: IntArray): Int {\\n        val digitMap = BooleanArray(9)\\n        var minCommonDigit = 10\\n        var minDigit1 = 9\\n        var minDigit2 = 9\\n        var i = 0\\n\\n        while (i < Math.max(nums1.size, nums2.size)) {\\n            if (i < nums1.size) {\\n                minDigit1 = Math.min(minDigit1, nums1[i])\\n                if (digitMap[nums1[i]-1])\\n                    minCommonDigit = Math.min(minCommonDigit, nums1[i])\\n                else\\n                    digitMap[nums1[i]-1] = true\\n            }\\n\\n            if (i < nums2.size) {\\n                minDigit2 = Math.min(minDigit2, nums2[i])\\n                if (digitMap[nums2[i]-1])\\n                    minCommonDigit = Math.min(minCommonDigit, nums2[i])\\n                else\\n                    digitMap[nums2[i]-1] = true\\n            }\\n\\n            i++\\n        }\\n\\n        if (minCommonDigit < 10)\\n            return minCommonDigit\\n\\n        if (minDigit1 < minDigit2)\\n            return \"$minDigit1$minDigit2\".toInt()\\n\\n        return \"$minDigit2$minDigit1\".toInt()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752513,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n    nums1.sort((a,b) => a - b);\\n    nums2.sort((a,b) => a - b);\\n    for(let num of nums1) {\\n        if (nums2.includes(num) ) {\\n            return num;\\n        }\\n    }\\n    if ( nums1[0] > nums2[0]) return Number(String(nums2[0]) + String(nums1[0]));\\n    else return Number(String(nums1[0]) + String(nums2[0]));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar minNumber = function(nums1, nums2) {\\n    nums1.sort((a,b) => a - b);\\n    nums2.sort((a,b) => a - b);\\n    for(let num of nums1) {\\n        if (nums2.includes(num) ) {\\n            return num;\\n        }\\n    }\\n    if ( nums1[0] > nums2[0]) return Number(String(nums2[0]) + String(nums1[0]));\\n    else return Number(String(nums1[0]) + String(nums2[0]));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3748037,
                "title": "java-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n\\n        Set<Integer> s = new HashSet();\\n        for (int i = 0; i < nums1.length; i++) {\\n            s.add(nums1[i]);\\n        }\\n\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums2.length; i++) {\\n            if (s.contains(nums2[i])) {\\n                min = Math.min(min, nums2[i]);\\n            }\\n        }\\n\\n        if (min < Integer.MAX_VALUE) return min;\\n\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        if (nums1[0] < nums2[0]) return nums1[0] * 10 + nums2[0];\\n\\n        return nums2[0] * 10 + nums1[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n\\n        Set<Integer> s = new HashSet();\\n        for (int i = 0; i < nums1.length; i++) {\\n            s.add(nums1[i]);\\n        }\\n\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums2.length; i++) {\\n            if (s.contains(nums2[i])) {\\n                min = Math.min(min, nums2[i]);\\n            }\\n        }\\n\\n        if (min < Integer.MAX_VALUE) return min;\\n\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        if (nums1[0] < nums2[0]) return nums1[0] * 10 + nums2[0];\\n\\n        return nums2[0] * 10 + nums1[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746195,
                "title": "python-simple-bruteforce-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        min_1 = float(\\'inf\\')\\n        min_2 = float(\\'inf\\')\\n        min_3 = float(\\'inf\\')\\n        for i in range(len(nums1)):\\n            min_1 = min(min_1,nums1[i])\\n        for j in range(len(nums2)):\\n            min_2 = min(min_2,nums2[j])\\n        sub_str = \"\"\\n        if min_1 < min_2:\\n            sub_str += str(min_1) + str(min_2)\\n        else:\\n            sub_str += str(min_2) + str(min_1)\\n        for i in range(len(nums1)):\\n            if nums1[i] in nums2:\\n                min_3 = min(min_3,nums1[i]) \\n        return min(min_3,int(sub_str))\\n                \\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        min_1 = float(\\'inf\\')\\n        min_2 = float(\\'inf\\')\\n        min_3 = float(\\'inf\\')\\n        for i in range(len(nums1)):\\n            min_1 = min(min_1,nums1[i])\\n        for j in range(len(nums2)):\\n            min_2 = min(min_2,nums2[j])\\n        sub_str = \"\"\\n        if min_1 < min_2:\\n            sub_str += str(min_1) + str(min_2)\\n        else:\\n            sub_str += str(min_2) + str(min_1)\\n        for i in range(len(nums1)):\\n            if nums1[i] in nums2:\\n                min_3 = min(min_3,nums1[i]) \\n        return min(min_3,int(sub_str))\\n                \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741740,
                "title": "very-very-easy-solution-simple-to-understand-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] a, int[] b) {\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        String p = \"\";\\n        if(a[0]<b[0])\\n            p = a[0]+\"\"+b[0]+\"\";\\n        else\\n            p=b[0]+\"\"+a[0];\\n        boolean flag=false;\\n        int res = Integer.parseInt(p);\\n        for(int i=0;i<a.length;i++){\\n            for(int j=0;j<b.length;j++){\\n                if(a[i]==b[j]){\\n                    res = a[i];\\n                    flag = true;\\n                    break;\\n            }\\n            }\\n            if(flag)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] a, int[] b) {\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        String p = \"\";\\n        if(a[0]<b[0])\\n            p = a[0]+\"\"+b[0]+\"\";\\n        else\\n            p=b[0]+\"\"+a[0];\\n        boolean flag=false;\\n        int res = Integer.parseInt(p);\\n        for(int i=0;i<a.length;i++){\\n            for(int j=0;j<b.length;j++){\\n                if(a[i]==b[j]){\\n                    res = a[i];\\n                    flag = true;\\n                    break;\\n            }\\n            }\\n            if(flag)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741739,
                "title": "very-very-easy-solution-simple-to-understand-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] a, int[] b) {\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        String p = \"\";\\n        if(a[0]<b[0])\\n            p = a[0]+\"\"+b[0]+\"\";\\n        else\\n            p=b[0]+\"\"+a[0];\\n        boolean flag=false;\\n        int res = Integer.parseInt(p);\\n        for(int i=0;i<a.length;i++){\\n            for(int j=0;j<b.length;j++){\\n                if(a[i]==b[j]){\\n                    res = a[i];\\n                    flag = true;\\n                    break;\\n            }\\n            }\\n            if(flag)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] a, int[] b) {\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        String p = \"\";\\n        if(a[0]<b[0])\\n            p = a[0]+\"\"+b[0]+\"\";\\n        else\\n            p=b[0]+\"\"+a[0];\\n        boolean flag=false;\\n        int res = Integer.parseInt(p);\\n        for(int i=0;i<a.length;i++){\\n            for(int j=0;j<b.length;j++){\\n                if(a[i]==b[j]){\\n                    res = a[i];\\n                    flag = true;\\n                    break;\\n            }\\n            }\\n            if(flag)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734991,
                "title": "python-simple-sol-using-min",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def minNumber(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        fn=min(int(str(min(nums1))+str(min(nums2))),int(str(min(nums2))+str(min(nums1))))\\n        for i in nums1:\\n            if i in nums2:\\n                fn=min(fn,i)\\n        return fn\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minNumber(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        fn=min(int(str(min(nums1))+str(min(nums2))),int(str(min(nums2))+str(min(nums1))))\\n        for i in nums1:\\n            if i in nums2:\\n                fn=min(fn,i)\\n        return fn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734281,
                "title": "c-0ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n      int b1 = 0, m1 = 9, b2 = 0, m2 = 9;\\n      tie(b1, m1) = helper(nums1);\\n      tie(b2, m2) = helper(nums2);\\n      if (b1&b2) {\\n        int i = 0;\\n        while ((b1&b2&(1<<i)) == 0)\\n          i++;\\n        return i;\\n      }\\n      return min(m1,m2)*10 + max(m1,m2);\\n    }\\n  private:\\n    pair<int, int> helper(vector<int>& nums) {\\n      int b = 0, m = INT_MAX;\\n      for (auto n : nums) {\\n        b |= 1<<n;\\n        m = min(m, n);\\n      }\\n      return {b, m};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n      int b1 = 0, m1 = 9, b2 = 0, m2 = 9;\\n      tie(b1, m1) = helper(nums1);\\n      tie(b2, m2) = helper(nums2);\\n      if (b1&b2) {\\n        int i = 0;\\n        while ((b1&b2&(1<<i)) == 0)\\n          i++;\\n        return i;\\n      }\\n      return min(m1,m2)*10 + max(m1,m2);\\n    }\\n  private:\\n    pair<int, int> helper(vector<int>& nums) {\\n      int b = 0, m = INT_MAX;\\n      for (auto n : nums) {\\n        b |= 1<<n;\\n        m = min(m, n);\\n      }\\n      return {b, m};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732585,
                "title": "count-using-array-c",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int mn = 10, mn1 = 10, mn2 = 10, n1 = 0, n2 = 0, cnt[10] = {};\\n\\n        for(int i = 0; i < nums1.size(); i++) {\\n            mn1 = min(mn1, nums1[i]);\\n            cnt[nums1[i]] = 1;\\n        }\\n\\n        for(int i = 0; i < nums2.size(); i++) {\\n            mn2 = min(mn2, nums2[i]);\\n            if(cnt[nums2[i]]) \\n                mn = min(mn, nums2[i]);\\n        }\\n\\n        return mn < 10 ? mn : min(mn1, mn2) * 10 + max(mn1, mn2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        int mn = 10, mn1 = 10, mn2 = 10, n1 = 0, n2 = 0, cnt[10] = {};\\n\\n        for(int i = 0; i < nums1.size(); i++) {\\n            mn1 = min(mn1, nums1[i]);\\n            cnt[nums1[i]] = 1;\\n        }\\n\\n        for(int i = 0; i < nums2.size(); i++) {\\n            mn2 = min(mn2, nums2[i]);\\n            if(cnt[nums2[i]]) \\n                mn = min(mn, nums2[i]);\\n        }\\n\\n        return mn < 10 ? mn : min(mn1, mn2) * 10 + max(mn1, mn2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732062,
                "title": "java-easy-solution-o-1-beat-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        boolean arr1[]=new boolean[10];\\n        boolean arr2[]=new boolean[10];\\n        for(int num : nums1) arr1[num]=true;\\n        for(int num : nums2) arr2[num]=true;\\n        \\n        for(int i=1; i<10; i++)\\n            if(arr1[i] && arr2[i])\\n                return i;\\n\\n        int a=1, b=1;\\n        while(!arr1[a]) a++;\\n        while(!arr2[b]) b++;\\n\\n        return Math.min(a,b) * 10 + Math.max(a,b); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        boolean arr1[]=new boolean[10];\\n        boolean arr2[]=new boolean[10];\\n        for(int num : nums1) arr1[num]=true;\\n        for(int num : nums2) arr2[num]=true;\\n        \\n        for(int i=1; i<10; i++)\\n            if(arr1[i] && arr2[i])\\n                return i;\\n\\n        int a=1, b=1;\\n        while(!arr1[a]) a++;\\n        while(!arr2[b]) b++;\\n\\n        return Math.min(a,b) * 10 + Math.max(a,b); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728337,
                "title": "c-set-intersection-solution",
                "content": "# Code\\n```c++\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v;\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        set_intersection(nums1.begin(), nums1.end(), nums2.begin(), nums2.end(), back_inserter(v));\\n        sort(v.begin(), v.end());\\n        if (v.size() > 0) {\\n            return v[0];\\n        }\\n        int v12 = nums1[0] * 10 + nums2[0];\\n        int v21 = nums1[0] + nums2[0] * 10;\\n        return min(v12, v21);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v;\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        set_intersection(nums1.begin(), nums1.end(), nums2.begin(), nums2.end(), back_inserter(v));\\n        sort(v.begin(), v.end());\\n        if (v.size() > 0) {\\n            return v[0];\\n        }\\n        int v12 = nums1[0] * 10 + nums2[0];\\n        int v21 = nums1[0] + nums2[0] * 10;\\n        return min(v12, v21);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723063,
                "title": "short-easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        inters = set(nums1).intersection(nums2)\\n        \\n        fstnum = min(nums1)\\n        secnum = min(nums2)\\n        return min(inters) if inters \\\\\\n            else int(f\\'{min(fstnum, secnum)}{max(fstnum, secnum)}\\')\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        inters = set(nums1).intersection(nums2)\\n        \\n        fstnum = min(nums1)\\n        secnum = min(nums2)\\n        return min(inters) if inters \\\\\\n            else int(f\\'{min(fstnum, secnum)}{max(fstnum, secnum)}\\')\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716927,
                "title": "sexiest-and-easiest-solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n     unordered_map<int,int>m;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++){\\n        \\n             m[nums1[i]]++;\\n        }\\n        vector<int>v;\\n        for(int i=0;i<nums2.size();i++){\\n            if(m.find(nums2[i])!=m.end()){\\n                v.push_back(nums2[i]);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        if(v.size()==0){\\n            return 10*min(nums1[0],nums2[0]) +max(nums1[0],nums2[0]);\\n        }\\n        else return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n     unordered_map<int,int>m;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++){\\n        \\n             m[nums1[i]]++;\\n        }\\n        vector<int>v;\\n        for(int i=0;i<nums2.size();i++){\\n            if(m.find(nums2[i])!=m.end()){\\n                v.push_back(nums2[i]);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        if(v.size()==0){\\n            return 10*min(nums1[0],nums2[0]) +max(nums1[0],nums2[0]);\\n        }\\n        else return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692481,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int[] arr = new int[10];\\n        int min1 = Integer.MAX_VALUE;\\n        int min2 = Integer.MAX_VALUE;\\n        int duplicate = Integer.MAX_VALUE;\\n        int max = Math.max(nums1.length, nums2.length);\\n        for (int i = 0; i < max; i++) {\\n            if (i < nums1.length) {\\n                min1 = Math.min(min1, nums1[i]);\\n                arr[nums1[i]]++;\\n            }\\n            if (i < nums2.length) {\\n                min2 = Math.min(min2, nums2[i]);\\n                arr[nums2[i]]++;\\n            }\\n            if (i == max - 1) {\\n                int j = 1;\\n                while (j < arr.length) {\\n                    if (arr[j] == 2) {\\n                        return j;\\n                    } else {\\n                        j++;\\n                    }\\n                }\\n            }\\n        }\\n        int output = 0;\\n        int firstD = Math.min(min1, min2);\\n        int secondD = Math.max(min2, min1);\\n        String s = String.valueOf(firstD) + secondD;\\n        output = Integer.parseInt(s);\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int[] arr = new int[10];\\n        int min1 = Integer.MAX_VALUE;\\n        int min2 = Integer.MAX_VALUE;\\n        int duplicate = Integer.MAX_VALUE;\\n        int max = Math.max(nums1.length, nums2.length);\\n        for (int i = 0; i < max; i++) {\\n            if (i < nums1.length) {\\n                min1 = Math.min(min1, nums1[i]);\\n                arr[nums1[i]]++;\\n            }\\n            if (i < nums2.length) {\\n                min2 = Math.min(min2, nums2[i]);\\n                arr[nums2[i]]++;\\n            }\\n            if (i == max - 1) {\\n                int j = 1;\\n                while (j < arr.length) {\\n                    if (arr[j] == 2) {\\n                        return j;\\n                    } else {\\n                        j++;\\n                    }\\n                }\\n            }\\n        }\\n        int output = 0;\\n        int firstD = Math.min(min1, min2);\\n        int secondD = Math.max(min2, min1);\\n        String s = String.valueOf(firstD) + secondD;\\n        output = Integer.parseInt(s);\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690991,
                "title": "python3-easy-to-understand",
                "content": "# Intuition\\nUsing an optimized brute force where we first sort both the lists, then take the first two elements from each lists and concatenate.\\nCheck if this is greater than the smallest number common between the two.\\n\\n# Complexity\\n- Time complexity:\\nnlogn + mlogm\\n\\n- Space complexity:\\nn+m for each set\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1 = sorted(nums1)\\n        nums2 = sorted(nums2)\\n        c = set(nums1).intersection(nums2)\\n        min_set = 99999\\n        if len(c) > 0:\\n            min_set = min(c)\\n        a = min(int(str(nums1[0])+str(nums2[0])),int(str(nums2[0])+str(nums1[0])))\\n        if min_set > a:\\n            return a\\n        return min_set\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1 = sorted(nums1)\\n        nums2 = sorted(nums2)\\n        c = set(nums1).intersection(nums2)\\n        min_set = 99999\\n        if len(c) > 0:\\n            min_set = min(c)\\n        a = min(int(str(nums1[0])+str(nums2[0])),int(str(nums2[0])+str(nums1[0])))\\n        if min_set > a:\\n            return a\\n        return min_set\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687791,
                "title": "easy-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int min1=Integer.MAX_VALUE,min2=Integer.MAX_VALUE;\\n        String k=\"\";\\n    for(int i=0;i<nums1.length;i++){\\n        if(nums1[i]<min1)min1=nums1[i];\\n        for(int j=0;j<nums2.length;j++){\\n           if(nums2[j]<min2)min2=nums2[j];\\n           if(nums1[i]==nums2[j])k+=nums1[i];\\n        }\\n    }\\n    if(k.equals(\"\")){\\n        String o=\"\";\\n        if(min1>min2)o+=min2+\"\"+min1;\\n        else o+=min1+\"\"+min2;\\n        return Integer.parseInt(o);\\n    }\\n    String r[]=k.split(\"\");\\n    Arrays.sort(r);\\n    return Integer.parseInt(r[0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumber(int[] nums1, int[] nums2) {\\n        int min1=Integer.MAX_VALUE,min2=Integer.MAX_VALUE;\\n        String k=\"\";\\n    for(int i=0;i<nums1.length;i++){\\n        if(nums1[i]<min1)min1=nums1[i];\\n        for(int j=0;j<nums2.length;j++){\\n           if(nums2[j]<min2)min2=nums2[j];\\n           if(nums1[i]==nums2[j])k+=nums1[i];\\n        }\\n    }\\n    if(k.equals(\"\")){\\n        String o=\"\";\\n        if(min1>min2)o+=min2+\"\"+min1;\\n        else o+=min1+\"\"+min2;\\n        return Integer.parseInt(o);\\n    }\\n    String r[]=k.split(\"\");\\n    Arrays.sort(r);\\n    return Integer.parseInt(r[0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684724,
                "title": "easy-and-simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        x=set(nums1).intersection(set(nums2))\\n\\n        if len(x)>0:\\n            return sorted(list(x))[0]\\n        else:\\n            digit1=min(set(nums1))\\n            digit2=min(set(nums2))\\n\\n            if digit1 > digit2:\\n                return digit2*10 +digit1\\n            else:\\n                return digit1*10 +digit2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\\n        x=set(nums1).intersection(set(nums2))\\n\\n        if len(x)>0:\\n            return sorted(list(x))[0]\\n        else:\\n            digit1=min(set(nums1))\\n            digit2=min(set(nums2))\\n\\n            if digit1 > digit2:\\n                return digit2*10 +digit1\\n            else:\\n                return digit1*10 +digit2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664810,
                "title": "easy-and-clean-solution",
                "content": "\\n\\n# Code\\n```\\nconst minNumber = (nums1, nums2) => {\\n    nums1.sort((a,b) => a - b);\\n    nums2.sort((a,b) => a - b);\\n\\n    for (let i = 0; i < nums1.length; i++) {\\n        if ( nums2.includes(nums1[i]) ) {\\n            return nums1[i];\\n        }\\n    }\\n\\n    if ( nums1[0] > nums2[0] ) {\\n        return Number(String(nums2[0]) + String(nums1[0]));\\n    } else {\\n        return Number(String(nums1[0]) + String(nums2[0]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst minNumber = (nums1, nums2) => {\\n    nums1.sort((a,b) => a - b);\\n    nums2.sort((a,b) => a - b);\\n\\n    for (let i = 0; i < nums1.length; i++) {\\n        if ( nums2.includes(nums1[i]) ) {\\n            return nums1[i];\\n        }\\n    }\\n\\n    if ( nums1[0] > nums2[0] ) {\\n        return Number(String(nums2[0]) + String(nums1[0]));\\n    } else {\\n        return Number(String(nums1[0]) + String(nums2[0]));\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1850323,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Funny constraints"
                    },
                    {
                        "username": "wolverine_1",
                        "content": "Most easy code using stoi() to convert string to int and all become just cake walk. \\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    exit;\\n                }\\n            }\\n        }\\n                string ans1=to_string(nums1[0]);\\n                string ans2=to_string(nums2[0]);\\n                string ans=ans1+ans2;\\n                string ans3=ans2+ans1;\\n                int f1=stoi(ans);\\n                int f2=stoi(ans3);\\n                int final=min(f1,f2);\\n\\n        return final;\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "What\\'s wrong with my code? \\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> myMap;\\n\\n        // for(int i =0; i<nums1.size(); i++)\\n        if(!nums1.empty()){\\n        sort(nums1.begin(), nums1.end());\\n        int smallest1 = nums1[0];\\n        myMap.insert({smallest1, 0});\\n        }\\n\\n    if(!nums2.empty()){\\n        sort(nums2.begin(), nums2.end());\\n        int smallest2 = nums2[0];\\n        myMap.insert({smallest2, 0});\\n\\n\\n    }\\n        return myMap;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code has several issues:\\n\\n1. You are returning a map `myMap` when the function is expected to return an `int`. This will cause a type mismatch error.\\n\\n2. In the problem statement, you\\'re asked to find the smallest number that contains at least one digit from each array. However, in your code, you\\'re simply sorting each array and storing the smallest element in a map, which doesn\\'t serve the purpose of the problem.\\n\\n3. The use of `map` in your code is not necessary. Your problem can be solved by using a simple comparison of elements in both arrays.\\n\\nYou need to restructure your code to find common elements in both arrays and return the smallest common element. If no common elements exist, you should return a two-digit number formed by the smallest numbers from both arrays.\\n\\nHere\\'s a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = 0; j < nums2.size(); ++j) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        return min(nums1[0], nums2[0]) * 10 + max(nums1[0], nums2[0]);\\n    }\\n};\\n```\\n\\nIn this version, we first sort both arrays. Then we compare each element in both arrays to find the smallest common element. If there is no common element, we return a two-digit number composed of the smallest elements from both arrays.\\n"
                    },
                    {
                        "username": "abhi9001",
                        "content": "why unordered_map give wrong answer but map give right answer .\\nbut unordered_map time complaxcity is much greater than than te map\\n"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice relaxing one  !"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[Beats 100% (Easiest Approach)](https://leetcode.com/problems/form-smallest-number-from-two-digit-arrays/solutions/3366549/beats-100-easiest-approach/?orderBy=newest_to_oldest)"
                    }
                ]
            },
            {
                "id": 1959168,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Funny constraints"
                    },
                    {
                        "username": "wolverine_1",
                        "content": "Most easy code using stoi() to convert string to int and all become just cake walk. \\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    exit;\\n                }\\n            }\\n        }\\n                string ans1=to_string(nums1[0]);\\n                string ans2=to_string(nums2[0]);\\n                string ans=ans1+ans2;\\n                string ans3=ans2+ans1;\\n                int f1=stoi(ans);\\n                int f2=stoi(ans3);\\n                int final=min(f1,f2);\\n\\n        return final;\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "What\\'s wrong with my code? \\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> myMap;\\n\\n        // for(int i =0; i<nums1.size(); i++)\\n        if(!nums1.empty()){\\n        sort(nums1.begin(), nums1.end());\\n        int smallest1 = nums1[0];\\n        myMap.insert({smallest1, 0});\\n        }\\n\\n    if(!nums2.empty()){\\n        sort(nums2.begin(), nums2.end());\\n        int smallest2 = nums2[0];\\n        myMap.insert({smallest2, 0});\\n\\n\\n    }\\n        return myMap;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code has several issues:\\n\\n1. You are returning a map `myMap` when the function is expected to return an `int`. This will cause a type mismatch error.\\n\\n2. In the problem statement, you\\'re asked to find the smallest number that contains at least one digit from each array. However, in your code, you\\'re simply sorting each array and storing the smallest element in a map, which doesn\\'t serve the purpose of the problem.\\n\\n3. The use of `map` in your code is not necessary. Your problem can be solved by using a simple comparison of elements in both arrays.\\n\\nYou need to restructure your code to find common elements in both arrays and return the smallest common element. If no common elements exist, you should return a two-digit number formed by the smallest numbers from both arrays.\\n\\nHere\\'s a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = 0; j < nums2.size(); ++j) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        return min(nums1[0], nums2[0]) * 10 + max(nums1[0], nums2[0]);\\n    }\\n};\\n```\\n\\nIn this version, we first sort both arrays. Then we compare each element in both arrays to find the smallest common element. If there is no common element, we return a two-digit number composed of the smallest elements from both arrays.\\n"
                    },
                    {
                        "username": "abhi9001",
                        "content": "why unordered_map give wrong answer but map give right answer .\\nbut unordered_map time complaxcity is much greater than than te map\\n"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice relaxing one  !"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[Beats 100% (Easiest Approach)](https://leetcode.com/problems/form-smallest-number-from-two-digit-arrays/solutions/3366549/beats-100-easiest-approach/?orderBy=newest_to_oldest)"
                    }
                ]
            },
            {
                "id": 1901140,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Funny constraints"
                    },
                    {
                        "username": "wolverine_1",
                        "content": "Most easy code using stoi() to convert string to int and all become just cake walk. \\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    exit;\\n                }\\n            }\\n        }\\n                string ans1=to_string(nums1[0]);\\n                string ans2=to_string(nums2[0]);\\n                string ans=ans1+ans2;\\n                string ans3=ans2+ans1;\\n                int f1=stoi(ans);\\n                int f2=stoi(ans3);\\n                int final=min(f1,f2);\\n\\n        return final;\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "What\\'s wrong with my code? \\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> myMap;\\n\\n        // for(int i =0; i<nums1.size(); i++)\\n        if(!nums1.empty()){\\n        sort(nums1.begin(), nums1.end());\\n        int smallest1 = nums1[0];\\n        myMap.insert({smallest1, 0});\\n        }\\n\\n    if(!nums2.empty()){\\n        sort(nums2.begin(), nums2.end());\\n        int smallest2 = nums2[0];\\n        myMap.insert({smallest2, 0});\\n\\n\\n    }\\n        return myMap;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code has several issues:\\n\\n1. You are returning a map `myMap` when the function is expected to return an `int`. This will cause a type mismatch error.\\n\\n2. In the problem statement, you\\'re asked to find the smallest number that contains at least one digit from each array. However, in your code, you\\'re simply sorting each array and storing the smallest element in a map, which doesn\\'t serve the purpose of the problem.\\n\\n3. The use of `map` in your code is not necessary. Your problem can be solved by using a simple comparison of elements in both arrays.\\n\\nYou need to restructure your code to find common elements in both arrays and return the smallest common element. If no common elements exist, you should return a two-digit number formed by the smallest numbers from both arrays.\\n\\nHere\\'s a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = 0; j < nums2.size(); ++j) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        return min(nums1[0], nums2[0]) * 10 + max(nums1[0], nums2[0]);\\n    }\\n};\\n```\\n\\nIn this version, we first sort both arrays. Then we compare each element in both arrays to find the smallest common element. If there is no common element, we return a two-digit number composed of the smallest elements from both arrays.\\n"
                    },
                    {
                        "username": "abhi9001",
                        "content": "why unordered_map give wrong answer but map give right answer .\\nbut unordered_map time complaxcity is much greater than than te map\\n"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice relaxing one  !"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[Beats 100% (Easiest Approach)](https://leetcode.com/problems/form-smallest-number-from-two-digit-arrays/solutions/3366549/beats-100-easiest-approach/?orderBy=newest_to_oldest)"
                    }
                ]
            },
            {
                "id": 1871611,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Funny constraints"
                    },
                    {
                        "username": "wolverine_1",
                        "content": "Most easy code using stoi() to convert string to int and all become just cake walk. \\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    exit;\\n                }\\n            }\\n        }\\n                string ans1=to_string(nums1[0]);\\n                string ans2=to_string(nums2[0]);\\n                string ans=ans1+ans2;\\n                string ans3=ans2+ans1;\\n                int f1=stoi(ans);\\n                int f2=stoi(ans3);\\n                int final=min(f1,f2);\\n\\n        return final;\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "What\\'s wrong with my code? \\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> myMap;\\n\\n        // for(int i =0; i<nums1.size(); i++)\\n        if(!nums1.empty()){\\n        sort(nums1.begin(), nums1.end());\\n        int smallest1 = nums1[0];\\n        myMap.insert({smallest1, 0});\\n        }\\n\\n    if(!nums2.empty()){\\n        sort(nums2.begin(), nums2.end());\\n        int smallest2 = nums2[0];\\n        myMap.insert({smallest2, 0});\\n\\n\\n    }\\n        return myMap;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code has several issues:\\n\\n1. You are returning a map `myMap` when the function is expected to return an `int`. This will cause a type mismatch error.\\n\\n2. In the problem statement, you\\'re asked to find the smallest number that contains at least one digit from each array. However, in your code, you\\'re simply sorting each array and storing the smallest element in a map, which doesn\\'t serve the purpose of the problem.\\n\\n3. The use of `map` in your code is not necessary. Your problem can be solved by using a simple comparison of elements in both arrays.\\n\\nYou need to restructure your code to find common elements in both arrays and return the smallest common element. If no common elements exist, you should return a two-digit number formed by the smallest numbers from both arrays.\\n\\nHere\\'s a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = 0; j < nums2.size(); ++j) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        return min(nums1[0], nums2[0]) * 10 + max(nums1[0], nums2[0]);\\n    }\\n};\\n```\\n\\nIn this version, we first sort both arrays. Then we compare each element in both arrays to find the smallest common element. If there is no common element, we return a two-digit number composed of the smallest elements from both arrays.\\n"
                    },
                    {
                        "username": "abhi9001",
                        "content": "why unordered_map give wrong answer but map give right answer .\\nbut unordered_map time complaxcity is much greater than than te map\\n"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice relaxing one  !"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[Beats 100% (Easiest Approach)](https://leetcode.com/problems/form-smallest-number-from-two-digit-arrays/solutions/3366549/beats-100-easiest-approach/?orderBy=newest_to_oldest)"
                    }
                ]
            },
            {
                "id": 1850684,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Funny constraints"
                    },
                    {
                        "username": "wolverine_1",
                        "content": "Most easy code using stoi() to convert string to int and all become just cake walk. \\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    exit;\\n                }\\n            }\\n        }\\n                string ans1=to_string(nums1[0]);\\n                string ans2=to_string(nums2[0]);\\n                string ans=ans1+ans2;\\n                string ans3=ans2+ans1;\\n                int f1=stoi(ans);\\n                int f2=stoi(ans3);\\n                int final=min(f1,f2);\\n\\n        return final;\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "What\\'s wrong with my code? \\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> myMap;\\n\\n        // for(int i =0; i<nums1.size(); i++)\\n        if(!nums1.empty()){\\n        sort(nums1.begin(), nums1.end());\\n        int smallest1 = nums1[0];\\n        myMap.insert({smallest1, 0});\\n        }\\n\\n    if(!nums2.empty()){\\n        sort(nums2.begin(), nums2.end());\\n        int smallest2 = nums2[0];\\n        myMap.insert({smallest2, 0});\\n\\n\\n    }\\n        return myMap;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code has several issues:\\n\\n1. You are returning a map `myMap` when the function is expected to return an `int`. This will cause a type mismatch error.\\n\\n2. In the problem statement, you\\'re asked to find the smallest number that contains at least one digit from each array. However, in your code, you\\'re simply sorting each array and storing the smallest element in a map, which doesn\\'t serve the purpose of the problem.\\n\\n3. The use of `map` in your code is not necessary. Your problem can be solved by using a simple comparison of elements in both arrays.\\n\\nYou need to restructure your code to find common elements in both arrays and return the smallest common element. If no common elements exist, you should return a two-digit number formed by the smallest numbers from both arrays.\\n\\nHere\\'s a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = 0; j < nums2.size(); ++j) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        return min(nums1[0], nums2[0]) * 10 + max(nums1[0], nums2[0]);\\n    }\\n};\\n```\\n\\nIn this version, we first sort both arrays. Then we compare each element in both arrays to find the smallest common element. If there is no common element, we return a two-digit number composed of the smallest elements from both arrays.\\n"
                    },
                    {
                        "username": "abhi9001",
                        "content": "why unordered_map give wrong answer but map give right answer .\\nbut unordered_map time complaxcity is much greater than than te map\\n"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice relaxing one  !"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[Beats 100% (Easiest Approach)](https://leetcode.com/problems/form-smallest-number-from-two-digit-arrays/solutions/3366549/beats-100-easiest-approach/?orderBy=newest_to_oldest)"
                    }
                ]
            },
            {
                "id": 1850310,
                "content": [
                    {
                        "username": "15o1",
                        "content": "Funny constraints"
                    },
                    {
                        "username": "wolverine_1",
                        "content": "Most easy code using stoi() to convert string to int and all become just cake walk. \\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=0;j<nums2.size();j++)\\n            {\\n                if(nums1[i]==nums2[j])\\n                {\\n                    return nums1[i];\\n                    exit;\\n                }\\n            }\\n        }\\n                string ans1=to_string(nums1[0]);\\n                string ans2=to_string(nums2[0]);\\n                string ans=ans1+ans2;\\n                string ans3=ans2+ans1;\\n                int f1=stoi(ans);\\n                int f2=stoi(ans3);\\n                int final=min(f1,f2);\\n\\n        return final;\\n        \\n\\n    }\\n};"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "What\\'s wrong with my code? \\n\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> myMap;\\n\\n        // for(int i =0; i<nums1.size(); i++)\\n        if(!nums1.empty()){\\n        sort(nums1.begin(), nums1.end());\\n        int smallest1 = nums1[0];\\n        myMap.insert({smallest1, 0});\\n        }\\n\\n    if(!nums2.empty()){\\n        sort(nums2.begin(), nums2.end());\\n        int smallest2 = nums2[0];\\n        myMap.insert({smallest2, 0});\\n\\n\\n    }\\n        return myMap;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code has several issues:\\n\\n1. You are returning a map `myMap` when the function is expected to return an `int`. This will cause a type mismatch error.\\n\\n2. In the problem statement, you\\'re asked to find the smallest number that contains at least one digit from each array. However, in your code, you\\'re simply sorting each array and storing the smallest element in a map, which doesn\\'t serve the purpose of the problem.\\n\\n3. The use of `map` in your code is not necessary. Your problem can be solved by using a simple comparison of elements in both arrays.\\n\\nYou need to restructure your code to find common elements in both arrays and return the smallest common element. If no common elements exist, you should return a two-digit number formed by the smallest numbers from both arrays.\\n\\nHere\\'s a corrected version of your code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = 0; j < nums2.size(); ++j) {\\n                if (nums1[i] == nums2[j]) {\\n                    return nums1[i];\\n                }\\n            }\\n        }\\n        \\n        return min(nums1[0], nums2[0]) * 10 + max(nums1[0], nums2[0]);\\n    }\\n};\\n```\\n\\nIn this version, we first sort both arrays. Then we compare each element in both arrays to find the smallest common element. If there is no common element, we return a two-digit number composed of the smallest elements from both arrays.\\n"
                    },
                    {
                        "username": "abhi9001",
                        "content": "why unordered_map give wrong answer but map give right answer .\\nbut unordered_map time complaxcity is much greater than than te map\\n"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice relaxing one  !"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[Beats 100% (Easiest Approach)](https://leetcode.com/problems/form-smallest-number-from-two-digit-arrays/solutions/3366549/beats-100-easiest-approach/?orderBy=newest_to_oldest)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Substring With Maximum Cost",
        "question_content": "<p>You are given a string <code>s</code>, a string <code>chars</code> of <strong>distinct</strong> characters and an integer array <code>vals</code> of the same length as <code>chars</code>.</p>\n\n<p>The <strong>cost of the substring </strong>is the sum of the values of each character in the substring. The cost of an empty string is considered <code>0</code>.</p>\n\n<p>The <strong>value of the character </strong>is defined in the following way:</p>\n\n<ul>\n\t<li>If the character is not in the string <code>chars</code>, then its value is its corresponding position <strong>(1-indexed)</strong> in the alphabet.\n\n\t<ul>\n\t\t<li>For example, the value of <code>&#39;a&#39;</code> is <code>1</code>, the value of <code>&#39;b&#39;</code> is <code>2</code>, and so on. The value of <code>&#39;z&#39;</code> is <code>26</code>.</li>\n\t</ul>\n\t</li>\n\t<li>Otherwise, assuming <code>i</code> is the index where the character occurs in the string <code>chars</code>, then its value is <code>vals[i]</code>.</li>\n</ul>\n\n<p>Return <em>the maximum cost among all substrings of the string</em> <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;adaa&quot;, chars = &quot;d&quot;, vals = [-1000]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The value of the characters &quot;a&quot; and &quot;d&quot; is 1 and -1000 respectively.\nThe substring with the maximum cost is &quot;aa&quot; and its cost is 1 + 1 = 2.\nIt can be proven that 2 is the maximum cost.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abc&quot;, chars = &quot;abc&quot;, vals = [-1,-1,-1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The value of the characters &quot;a&quot;, &quot;b&quot; and &quot;c&quot; is -1, -1, and -1 respectively.\nThe substring with the maximum cost is the empty substring &quot;&quot; and its cost is 0.\nIt can be proven that 0 is the maximum cost.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consist of lowercase English letters.</li>\n\t<li><code>1 &lt;= chars.length &lt;= 26</code></li>\n\t<li><code>chars</code> consist of <strong>distinct</strong> lowercase English letters.</li>\n\t<li><code>vals.length == chars.length</code></li>\n\t<li><code>-1000 &lt;= vals[i] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3366677,
                "title": "c-easy-to-understand-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are making a vector `v` in which values of all the alphabets are assigned as default (which is equal to their index number).\\nSecondly, if an aphabet is present in `chars`string the replace the it value as present in `vals` array. Now, read the approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- You need to make a new vector `vt` which is corresponding to the string `s`. It contains the respective value of corresponding alphabets in string `s`.\\n- Now, run a for loop and take two variables `ans` and `temp`.\\n- After every iteration assign ans with `max(ans, temp)` and continuously add the element in temp.\\n- If temp becomes negative then reset it to zero as we wants the maximum possible sum.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        // vector v containing values of all the alphabets.\\n        vector<int> v(26);\\n        for(int i=0; i<26; i++) v[i]=i+1;\\n        for(int i=0; i<chars.size(); i++){\\n            v[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        int n = s.size();\\n        // vector corresponding to string s\\n        vector<int> vt(n);\\n        for(int i=0; i<s.size(); i++){\\n            vt[i] = v[s[i]-\\'a\\'];\\n        }\\n        int ans=0, temp=0;\\n        for(int i=0; i<n; i++){\\n            temp += vt[i];\\n            if(temp<0) temp=0;\\n            // assign maximum value to ans\\n            ans = max(ans, temp);\\n        }\\n        return ans;\\n    }\\n};\\n// PLEASE UPVOTE IF YOU LIKE THE SOLUTION.\\uD83D\\uDE42\\n```\\n![0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg](https://assets.leetcode.com/users/images/a14799d2-ba35-459f-89f0-5014b5daaf73_1680366112.5667481.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        // vector v containing values of all the alphabets.\\n        vector<int> v(26);\\n        for(int i=0; i<26; i++) v[i]=i+1;\\n        for(int i=0; i<chars.size(); i++){\\n            v[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        int n = s.size();\\n        // vector corresponding to string s\\n        vector<int> vt(n);\\n        for(int i=0; i<s.size(); i++){\\n            vt[i] = v[s[i]-\\'a\\'];\\n        }\\n        int ans=0, temp=0;\\n        for(int i=0; i<n; i++){\\n            temp += vt[i];\\n            if(temp<0) temp=0;\\n            // assign maximum value to ans\\n            ans = max(ans, temp);\\n        }\\n        return ans;\\n    }\\n};\\n// PLEASE UPVOTE IF YOU LIKE THE SOLUTION.\\uD83D\\uDE42\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366393,
                "title": "kadane",
                "content": "We use array `v` to store the resulting value of each character:\\n- We initialize it with `1, 2, 3, 4, ...`. This is what `iota` is doing.\\n- Then we override certain values from `vals`.\\n\\nNow, we can represent `s` as a numeric array, and we use Kadane to find the maximum sum subarray.\\n\\n**C++**\\n```cpp\\nint maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n    int v[26] = {}, max_cost = 0, cost = 0;\\n    iota(begin(v), end(v), 1);\\n    for (int i  = 0; i < chars.size(); ++i)\\n        v[chars[i] - \\'a\\'] = vals[i];\\n    for (char ch : s) {\\n        cost = max(0, cost + v[ch - \\'a\\']);\\n        max_cost = max(max_cost, cost);\\n    }\\n    return max_cost;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n    int v[26] = {}, max_cost = 0, cost = 0;\\n    iota(begin(v), end(v), 1);\\n    for (int i  = 0; i < chars.size(); ++i)\\n        v[chars[i] - \\'a\\'] = vals[i];\\n    for (char ch : s) {\\n        cost = max(0, cost + v[ch - \\'a\\']);\\n        max_cost = max(max_cost, cost);\\n    }\\n    return max_cost;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366705,
                "title": "java-c-python-kadane",
                "content": "# **Explanation**\\nTransform `<chars, vals>` into a hashmap `m`, so we can get each characters value in `O(1)`.\\nIf `m[c]` exist, the value is `m[c]`, otherwise is `c - \\'a\\' + 1`.\\n\\nThen we can iterate the string `s` as an array,\\nand apply Kadane\\u2019s algorithm to solve the maximum subarray.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> m = new HashMap<>();\\n        for (int i = 0; i < chars.length(); i++) {\\n            m.put(chars.charAt(i), vals[i]);\\n        }\\n        int res = 0, cur = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            cur = Math.max(cur + m.getOrDefault(s.charAt(i), s.charAt(i) - \\'a\\' + 1), 0);\\n            res = Math.max(res, cur);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> m;\\n        for (int i = 0; i < chars.length(); i++)\\n            m[chars[i]] = vals[i];\\n        int res = 0, cur = 0;\\n        for (char& c : s) {\\n            cur = max(cur + (m.count(c) ? m[c] : c - \\'a\\' + 1), 0);\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        m = dict(zip(chars, vals))\\n        res = cur = 0\\n        for c in s:\\n            cur = max(cur + m.get(c, ord(c) - ord(\\'a\\') + 1), 0)\\n            res = max(res, cur)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> m = new HashMap<>();\\n        for (int i = 0; i < chars.length(); i++) {\\n            m.put(chars.charAt(i), vals[i]);\\n        }\\n        int res = 0, cur = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            cur = Math.max(cur + m.getOrDefault(s.charAt(i), s.charAt(i) - \\'a\\' + 1), 0);\\n            res = Math.max(res, cur);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> m;\\n        for (int i = 0; i < chars.length(); i++)\\n            m[chars[i]] = vals[i];\\n        int res = 0, cur = 0;\\n        for (char& c : s) {\\n            cur = max(cur + (m.count(c) ? m[c] : c - \\'a\\' + 1), 0);\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        m = dict(zip(chars, vals))\\n        res = cur = 0\\n        for c in s:\\n            cur = max(cur + m.get(c, ord(c) - ord(\\'a\\') + 1), 0)\\n            res = max(res, cur)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3366429,
                "title": "100-faster-beginner-friendly-c-kadanes-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int>ch(26);                                  //make a map\\n        for(int i=0;i<26;i++){\\n            ch[i]=i+1;                                           // set default values i.e, \\'a\\':1, \\'b\\':2.....\\n        }\\n        int cnt=0;\\n        for(char &i:chars){                            \\n            ch[i-\\'a\\']=vals[cnt++];                        // update the default values to the given values in vals array\\n        } \\n        int maxxi=0;\\n        int cur=0;\\n        for(char &i:s){\\n            cur+=ch[i-\\'a\\'];                                 // add the value of the current character in the cur sum\\n            if(cur<0){                                        // if current sum <0 then make current sum =0\\n                cur=0;\\n            }\\n            maxxi=max(maxxi,cur);                 // update the maximum sum\\n        }\\n        return maxxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int>ch(26);                                  //make a map\\n        for(int i=0;i<26;i++){\\n            ch[i]=i+1;                                           // set default values i.e, \\'a\\':1, \\'b\\':2.....\\n        }\\n        int cnt=0;\\n        for(char &i:chars){                            \\n            ch[i-\\'a\\']=vals[cnt++];                        // update the default values to the given values in vals array\\n        } \\n        int maxxi=0;\\n        int cur=0;\\n        for(char &i:s){\\n            cur+=ch[i-\\'a\\'];                                 // add the value of the current character in the cur sum\\n            if(cur<0){                                        // if current sum <0 then make current sum =0\\n                cur=0;\\n            }\\n            maxxi=max(maxxi,cur);                 // update the maximum sum\\n        }\\n        return maxxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366449,
                "title": "observation-kadanes-algo-c",
                "content": "we just need to make array of values of string S but checking whether s[i] is present in string char or not \\nif present then take the value from vals array of same index.\\n```\\nclass Solution {\\npublic:\\n    int maxSubArraySum(vector<int> &a){\\n        int mx1 = INT_MIN, mx = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            mx = mx + a[i];\\n            if (mx1 < mx)\\n                mx1 = mx;\\n\\n            if (mx < 0)\\n                mx = 0;\\n        }\\n        return mx1;\\n    }\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> map;\\n        \\n        for(int i=0;i<chars.size();i++){\\n            map[chars[i]] = i;\\n        }\\n        \\n        vector<int> arr(s.size());\\n        \\n        for(int i=0;i<arr.size();i++){\\n            if(map.count(s[i])){\\n                arr[i] = vals[map[s[i]]];\\n            }\\n            else{\\n                arr[i] = s[i] - \\'a\\'+1;\\n            }\\n        }\\n        \\n        int ans  = maxSubArraySum(arr);\\n        if(ans<0){\\n            return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArraySum(vector<int> &a){\\n        int mx1 = INT_MIN, mx = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            mx = mx + a[i];\\n            if (mx1 < mx)\\n                mx1 = mx;\\n\\n            if (mx < 0)\\n                mx = 0;\\n        }\\n        return mx1;\\n    }\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> map;\\n        \\n        for(int i=0;i<chars.size();i++){\\n            map[chars[i]] = i;\\n        }\\n        \\n        vector<int> arr(s.size());\\n        \\n        for(int i=0;i<arr.size();i++){\\n            if(map.count(s[i])){\\n                arr[i] = vals[map[s[i]]];\\n            }\\n            else{\\n                arr[i] = s[i] - \\'a\\'+1;\\n            }\\n        }\\n        \\n        int ans  = maxSubArraySum(arr);\\n        if(ans<0){\\n            return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366767,
                "title": "simple-solution-with-one-extra-tip-to-remember-for-life-which-i-bet-no-won-will-provide",
                "content": "# Intuition\\nTRIPPY\\'S BAKCHOD APPROACH\\nYou may easily convert into c++ and java\\n\\n# Approach\\nSS Smile and solve\\n\\n# Complexity\\nNothing\\n\\n# Extra Tip(Gyan)\\n![Bakchodi 1.jpg](https://assets.leetcode.com/users/images/59b427d8-747b-4b7d-924b-4d023f60f502_1680367075.684763.jpeg)\\n\\n# Code\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        char_dict = {}\\n        for i in range(len(chars)):\\n            char_dict[chars[i]] = vals[i]\\n        \\n        max_cost = 0\\n        curr_cost = 0\\n        for i in range(len(s)):\\n            if s[i] not in char_dict:\\n                curr_cost += ord(s[i]) - 96\\n            else:\\n                curr_cost += char_dict[s[i]]\\n            \\n            if curr_cost < 0:\\n                curr_cost = 0\\n            if curr_cost > max_cost:\\n                max_cost = curr_cost\\n        \\n        return max_cost\\n\\n        \\n```\\n# Humble Request\\n![Bakchodi 2.jpeg](https://assets.leetcode.com/users/images/9bfa152d-8c96-4cf8-a79d-3a083eb58c2e_1680367126.279916.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        char_dict = {}\\n        for i in range(len(chars)):\\n            char_dict[chars[i]] = vals[i]\\n        \\n        max_cost = 0\\n        curr_cost = 0\\n        for i in range(len(s)):\\n            if s[i] not in char_dict:\\n                curr_cost += ord(s[i]) - 96\\n            else:\\n                curr_cost += char_dict[s[i]]\\n            \\n            if curr_cost < 0:\\n                curr_cost = 0\\n            if curr_cost > max_cost:\\n                max_cost = curr_cost\\n        \\n        return max_cost\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366939,
                "title": "maintain-minimum-prefix-sum-dynamically",
                "content": "# Intuition\\nFor each index i, try to find the maximum cost of the substrings ending at index i which equals to the cost of the substring from 0 to i minus the cost of the substring from 0 to j where j <= i.  And this is just the difference of 2 \"prefix-sums\".\\n\\n# Approach\\nCalculate each prefix sum and save the minimum.\\n\\n# Complexity\\n- Time complexity:\\nO(m) where m is the alphabet size (here m = 26).\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26);\\n        for (int i = 0; i < 26; ++i) {\\n            v[i] = i + 1;\\n        }\\n        for (int i = 0; i < chars.length(); ++i) {\\n            v[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        int r = 0;\\n        for (int i = 0, m = 0, t = 0; i < s.length(); ++i) {\\n            t += v[s[i] - \\'a\\'];\\n            m = min(m, t);\\n            r = max(r, t - m);\\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26);\\n        for (int i = 0; i < 26; ++i) {\\n            v[i] = i + 1;\\n        }\\n        for (int i = 0; i < chars.length(); ++i) {\\n            v[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        int r = 0;\\n        for (int i = 0, m = 0, t = 0; i < s.length(); ++i) {\\n            t += v[s[i] - \\'a\\'];\\n            m = min(m, t);\\n            r = max(r, t - m);\\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366864,
                "title": "i-will-open-it-at-my-own-risk-some-ghost-may-appear-in-solution",
                "content": "# Intuition\\nTRIPPY\\'S BAKCHOD APPROACH\\nYou may easily convert into c++ and java\\n\\n# Approach\\nSS Smile and solve\\n\\n# Complexity\\nNothing\\n\\n# WARNING BEFORE MOVING TO SOL\\n![BAKCHODI 3.jpeg](https://assets.leetcode.com/users/images/14e754a5-83b4-4ff1-9b6f-0a5539482388_1680368578.8860812.jpeg)\\n\\n\\n![BAKCHODI 3.jpeg](https://assets.leetcode.com/users/images/14e754a5-83b4-4ff1-9b6f-0a5539482388_1680368578.8860812.jpeg)\\n\\n\\n\\n![BAKCHODI 3.jpeg](https://assets.leetcode.com/users/images/14e754a5-83b4-4ff1-9b6f-0a5539482388_1680368578.8860812.jpeg)\\n\\n\\n\\n# GHOST FREE Code\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        char_dict = {}\\n        for i in range(len(chars)):\\n            char_dict[chars[i]] = vals[i]\\n        \\n        max_cost = 0\\n        curr_cost = 0\\n        for i in range(len(s)):\\n            if s[i] not in char_dict:\\n                curr_cost += ord(s[i]) - 96\\n            else:\\n                curr_cost += char_dict[s[i]]\\n            \\n            if curr_cost < 0:\\n                curr_cost = 0\\n            if curr_cost > max_cost:\\n                max_cost = curr_cost\\n        \\n        return max_cost\\n\\n        \\n```\\n# Humble Request\\n![Bakchodi 2.jpeg](https://assets.leetcode.com/users/images/9bfa152d-8c96-4cf8-a79d-3a083eb58c2e_1680367126.279916.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        char_dict = {}\\n        for i in range(len(chars)):\\n            char_dict[chars[i]] = vals[i]\\n        \\n        max_cost = 0\\n        curr_cost = 0\\n        for i in range(len(s)):\\n            if s[i] not in char_dict:\\n                curr_cost += ord(s[i]) - 96\\n            else:\\n                curr_cost += char_dict[s[i]]\\n            \\n            if curr_cost < 0:\\n                curr_cost = 0\\n            if curr_cost > max_cost:\\n                max_cost = curr_cost\\n        \\n        return max_cost\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366749,
                "title": "c-fully-explained-kadane-s-algorithm-just-simulate-the-process-as-given-in-statement",
                "content": "# Intuition\\nFirstly take a map to store the characters and indexes of string **chars**.\\nNow, traverse string **s** and check if the current character is found in map(ie. if it is present in chars, as map has elements of chars as key), if the character is present in map then store its value(ie. value of the map is index of the element of chars) as index of vals and then add vals[index] to sum.\\nIf the character is not present then simply add the difference between the current character and \\'a\\' + 1 to sum, for eg. if s[i]=x, then sum += \\'z\\'-\\'a\\'+1 => sum += 25+1 => sum += 26.\\nKeep on updating the sum and maxi untill sum becomes negative.\\nWhen sum becomes negative make it 0 and then keep on repeating the process.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int sum = 0, maxi = INT_MIN;\\n        \\n        unordered_map<char,int> m;\\n        for(int i=0;i<chars.size();i++) m[chars[i]]=i;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(m.find(s[i])==m.end()) sum += (s[i]-\\'a\\'+1);\\n            else\\n            {\\n                int index = m[s[i]];\\n                sum += vals[index];\\n            }\\n            \\n            maxi = max(maxi,sum);\\n            if(sum<0) sum=0;\\n        }\\n        if(maxi<0) return 0;\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int sum = 0, maxi = INT_MIN;\\n        \\n        unordered_map<char,int> m;\\n        for(int i=0;i<chars.size();i++) m[chars[i]]=i;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(m.find(s[i])==m.end()) sum += (s[i]-\\'a\\'+1);\\n            else\\n            {\\n                int index = m[s[i]];\\n                sum += vals[index];\\n            }\\n            \\n            maxi = max(maxi,sum);\\n            if(sum<0) sum=0;\\n        }\\n        if(maxi<0) return 0;\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366391,
                "title": "java-python-3-kadane-algorithm",
                "content": "\\n\\n```java\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> charToVal = new HashMap<>();\\n        for (int i = 0; i < vals.length; ++i) {\\n            charToVal.put(chars.charAt(i), vals[i]);\\n        }\\n        int maxCost = 0;\\n        for (int i = 0, maxCostSubstringEndingAtCur = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            int v = charToVal.getOrDefault(c, c - \\'a\\' + 1);\\n            maxCostSubstringEndingAtCur = Math.max(maxCostSubstringEndingAtCur + v, v);\\n            maxCost = Math.max(maxCost, maxCostSubstringEndingAtCur);\\n        }\\n        return maxCost;\\n    }\\n```\\n```python\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        seen, max_cost = {c : v for c, v in zip(chars, vals)}, 0\\n        max_cost_substring_ending_at_cur = 0\\n        for c in s:\\n            v = seen.get(c, ord(c) - ord(\\'a\\') + 1)\\n            max_cost_substring_ending_at_cur = max(max_cost_substring_ending_at_cur + v, v)\\n            max_cost = max(max_cost, max_cost_substring_ending_at_cur)\\n        return max_cost    \\n```\\n\\n**Analysis:**\\n\\nTime: `O(m + n)`, space: `O(m)`, where `m = vals.length, n = s.length()`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> charToVal = new HashMap<>();\\n        for (int i = 0; i < vals.length; ++i) {\\n            charToVal.put(chars.charAt(i), vals[i]);\\n        }\\n        int maxCost = 0;\\n        for (int i = 0, maxCostSubstringEndingAtCur = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            int v = charToVal.getOrDefault(c, c - \\'a\\' + 1);\\n            maxCostSubstringEndingAtCur = Math.max(maxCostSubstringEndingAtCur + v, v);\\n            maxCost = Math.max(maxCost, maxCostSubstringEndingAtCur);\\n        }\\n        return maxCost;\\n    }\\n```\n```python\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        seen, max_cost = {c : v for c, v in zip(chars, vals)}, 0\\n        max_cost_substring_ending_at_cur = 0\\n        for c in s:\\n            v = seen.get(c, ord(c) - ord(\\'a\\') + 1)\\n            max_cost_substring_ending_at_cur = max(max_cost_substring_ending_at_cur + v, v)\\n            max_cost = max(max_cost, max_cost_substring_ending_at_cur)\\n        return max_cost    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3366445,
                "title": "easy-short-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int arr[] = new int[100001];\\n        for(int i=0; i<s.length(); i++){\\n            if(chars.contains(s.charAt(i)+\"\"))  arr[i] = vals[chars.indexOf(s.charAt(i))];\\n            else arr[i] = s.charAt(i)-\\'a\\'+1;\\n        }\\n        int max = Integer.MIN_VALUE, sum = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            sum += arr[i];\\n            max = Math.max(max, sum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return max < 0 ? 0 : max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int arr[] = new int[100001];\\n        for(int i=0; i<s.length(); i++){\\n            if(chars.contains(s.charAt(i)+\"\"))  arr[i] = vals[chars.indexOf(s.charAt(i))];\\n            else arr[i] = s.charAt(i)-\\'a\\'+1;\\n        }\\n        int max = Integer.MIN_VALUE, sum = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            sum += arr[i];\\n            max = Math.max(max, sum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return max < 0 ? 0 : max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366434,
                "title": "kadane-algorithm-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n       vector<int>sc(26,2000);\\n        \\n        for(int i=0;i<chars.size();i++)\\n            sc[chars[i]-\\'a\\']=vals[i];\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            if(sc[i]==2000)\\n                sc[i]=i+1;\\n        }\\n        \\n        int ans=0;\\n        int sum=0;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            sum+=sc[s[i]-\\'a\\'];\\n            ans=max(ans,sum);\\n            \\n            if(sum<0)\\n                sum=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n       vector<int>sc(26,2000);\\n        \\n        for(int i=0;i<chars.size();i++)\\n            sc[chars[i]-\\'a\\']=vals[i];\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            if(sc[i]==2000)\\n                sc[i]=i+1;\\n        }\\n        \\n        int ans=0;\\n        int sum=0;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            sum+=sc[s[i]-\\'a\\'];\\n            ans=max(ans,sum);\\n            \\n            if(sum<0)\\n                sum=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375480,
                "title": "c-simple-use-of-kadane-and-map",
                "content": "# Intuition\\nThe intution behind the logic is finding the subarray with greatest sum.\\n\\n# Approach\\nUse unordered map to map the value of chars to the respective value.\\nAfter this for simplicity the value of the every charcter of the string \\'s\\' is stored in the temp array to find the maximum sum subarray.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> mp;\\n\\n        for(int i = 0;i<chars.size();i++)\\n            mp[chars[i]] = vals[i];\\n\\n        vector<int> temp;\\n\\n        for(char c : s){\\n            if(mp.find(c) != mp.end())\\n                temp.emplace_back(mp[c]); \\n            else\\n                temp.push_back(c - \\'a\\' + 1);\\n        }\\n\\n        int ans = 0;\\n        int curr = 0;\\n        int n = temp.size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            curr = max(temp[i],curr + temp[i]);\\n            ans = max(ans,curr);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> mp;\\n\\n        for(int i = 0;i<chars.size();i++)\\n            mp[chars[i]] = vals[i];\\n\\n        vector<int> temp;\\n\\n        for(char c : s){\\n            if(mp.find(c) != mp.end())\\n                temp.emplace_back(mp[c]); \\n            else\\n                temp.push_back(c - \\'a\\' + 1);\\n        }\\n\\n        int ans = 0;\\n        int curr = 0;\\n        int n = temp.size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            curr = max(temp[i],curr + temp[i]);\\n            ans = max(ans,curr);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371254,
                "title": "python-3-3-lines-w-example-t-m-288-ms-15-7-mb",
                "content": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int])-> int:\\n                                                            # Example: s = \"adcnc\"\\n                                                            #      chars = \"dn\" \\n                                                            #       vals = [-10,-2]\\n        d = {ch:ord(ch)-96 for ch in s} \\n                                                            # d = {\\'a\\':1,\\'d\\':  4,\\'c\\':3,\\'n\\':14} \\n        for ch,val in zip(chars,vals): d[ch] = val          # d = {\\'a\\':1,\\'d\\':-10,\\'c\\':3,\\'n\\':-2}\\n                                                            #       \\n                                                            # [d[ch] for ch in s] = [1,-10,3,-2,3]\\n    \\n        return max(accumulate([d[ch] for ch in s],          # <-- max([0,1,0,3,1,4])\\n                 lambda x, y: max(x+y, 0), initial = 0))    #                    |\\n                                                            #                  return\\n```\\n[https://leetcode.com/problems/find-the-substring-with-maximum-cost/submissions/926247641/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int])-> int:\\n                                                            # Example: s = \"adcnc\"\\n                                                            #      chars = \"dn\" \\n                                                            #       vals = [-10,-2]\\n        d = {ch:ord(ch)-96 for ch in s} \\n                                                            # d = {\\'a\\':1,\\'d\\':  4,\\'c\\':3,\\'n\\':14} \\n        for ch,val in zip(chars,vals): d[ch] = val          # d = {\\'a\\':1,\\'d\\':-10,\\'c\\':3,\\'n\\':-2}\\n                                                            #       \\n                                                            # [d[ch] for ch in s] = [1,-10,3,-2,3]\\n    \\n        return max(accumulate([d[ch] for ch in s],          # <-- max([0,1,0,3,1,4])\\n                 lambda x, y: max(x+y, 0), initial = 0))    #                    |\\n                                                            #                  return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366436,
                "title": "kadane-algorithm-easiest-c-solution-iterative-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int arr[26] = {0};\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            arr[s[i] - 97] = s[i] - 96;\\n        }\\n        \\n        for(int i=0; i<chars.size(); i++) {\\n            arr[chars[i] - 97] = vals[i];\\n        }\\n        \\n        int ans = 0;\\n        int sum = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            sum += arr[s[i] - 97];\\n            if(sum <= 0) {\\n                sum = 0;\\n                continue;\\n            }\\n            if(sum > ans) ans = sum;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int arr[26] = {0};\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            arr[s[i] - 97] = s[i] - 96;\\n        }\\n        \\n        for(int i=0; i<chars.size(); i++) {\\n            arr[chars[i] - 97] = vals[i];\\n        }\\n        \\n        int ans = 0;\\n        int sum = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            sum += arr[s[i] - 97];\\n            if(sum <= 0) {\\n                sum = 0;\\n                continue;\\n            }\\n            if(sum > ans) ans = sum;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503553,
                "title": "kadane-algorithms-c-easy-to-understnad",
                "content": "kadaane algorithms type solution.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(26)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26,0);\\n        int i;\\n        for(i = 0; i < 26; i++){\\n            v[i] = i+1;\\n        }\\n        for(i = 0; i < chars.length(); i++){\\n            v[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        int ans = 0, sum = 0;\\n        for(i = 0; i < s.length(); i++){\\n            sum += v[s[i]-\\'a\\'];\\n            ans = max(ans,sum);\\n            if(sum<0)sum = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26,0);\\n        int i;\\n        for(i = 0; i < 26; i++){\\n            v[i] = i+1;\\n        }\\n        for(i = 0; i < chars.length(); i++){\\n            v[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        int ans = 0, sum = 0;\\n        for(i = 0; i < s.length(); i++){\\n            sum += v[s[i]-\\'a\\'];\\n            ans = max(ans,sum);\\n            if(sum<0)sum = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481990,
                "title": "c-solution-kadane-algo",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < chars.length(); i++) {\\n            char ch = chars[i];\\n            mp[ch] = vals[i];\\n        }\\n        int maxy = 0;\\n        int curr = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (curr < 0) curr = 0;\\n            char ch = s[i];\\n            int val = (ch - \\'a\\' + 1);\\n            if (mp.count(ch) == 1) {\\n                val = mp[ch];\\n            }\\n            curr += val;\\n            maxy = max(maxy, curr);\\n        }\\n\\n        return maxy;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> mp;\\n        for (int i = 0; i < chars.length(); i++) {\\n            char ch = chars[i];\\n            mp[ch] = vals[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3367136,
                "title": "simple-and-easy-solution-kadane-algo-python3",
                "content": "Kadane\\'s algorithm\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        v = {chars[i]:vals[i] for i in range(len(chars))}\\n        arr = [ v.get(c, ord(c) - 96 ) for c in s ]\\n        \\n        curSum = 0\\n        mSum = 0\\n        \\n        for n in arr:\\n            curSum = max(n, curSum+n)\\n            mSum = max(mSum, curSum)\\n        return mSum if mSum > 0 else 0\\n            \\n    \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        v = {chars[i]:vals[i] for i in range(len(chars))}\\n        arr = [ v.get(c, ord(c) - 96 ) for c in s ]\\n        \\n        curSum = 0\\n        mSum = 0\\n        \\n        for n in arr:\\n            curSum = max(n, curSum+n)\\n            mSum = max(mSum, curSum)\\n        return mSum if mSum > 0 else 0\\n            \\n    \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367118,
                "title": "python3-kadane-ish-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/1dc118daa80cfe1161dcee412e7c3536970ca60d) for solutions of biweely 101. \\n\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        mp = dict(zip(chars, vals))\\n        ans = val = 0 \\n        for i, ch in enumerate(s):\\n            val = max(0, val + mp.get(ch, ord(ch)-96))\\n            ans = max(ans, val)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        mp = dict(zip(chars, vals))\\n        ans = val = 0 \\n        for i, ch in enumerate(s):\\n            val = max(0, val + mp.get(ch, ord(ch)-96))\\n            ans = max(ans, val)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366541,
                "title": "python3-solution-well-explained-easy-clear",
                "content": "# Intuition:\\nThe problem requires finding the maximum cost among all substrings of the given string s. We can find the cost of each character by assigning a value to each character based on whether it is present in the given chars string or not. We can then find the cost of each substring using this assigned value for each character and return the maximum cost.\\n\\n# Approach:\\nWe first create a dictionary to map each character to its corresponding value based on whether it is present in the given chars string or not. We then create a list xx where we replace each character of the given string s with its assigned value using the dictionary we created. We then use the Kadane\\'s algorithm to find the maximum sum contiguous subarray of xx, which gives us the maximum cost of a substring. We return this maximum cost if it is greater than 0, else we return 0.\\n\\n# Complexity:\\n# Time Complexity: \\nThe time complexity of creating the dictionary is O(26+L) where L is the length of the chars string. The time complexity of creating the xx list is O(N) where N is the length of the given string s. The time complexity of the Kadane\\'s algorithm is O(N). Hence, the overall time complexity is O(N+L).\\n\\n# Space Complexity: \\nThe space complexity is O(26+L+N) where L is the length of the chars string and N is the length of the given string s. The extra space is used for the dictionary, xx list, and Kadane\\'s algorithm.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        i=1\\n        m=dict()\\n        for c in ascii_lowercase:\\n            if c in chars:\\n                m.update({c:vals[chars.index(c)]})\\n            else:\\n                m.update({c:i})\\n            i+=1\\n        xx=[]\\n        for i in range(len(s)):\\n            xx.append(m[s[i]])\\n        print(xx)\\n        def maxSubArray(nums: List[int]) -> int:\\n            max_sum=nums[0]\\n            temp=0\\n            for i in range(len(nums)):\\n                if temp<0:\\n                    temp=0\\n                temp+=nums[i]\\n                if temp>max_sum:\\n                    max_sum=temp\\n            return max_sum\\n        \\n        \\n        \\n        return max(maxSubArray(xx),0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        i=1\\n        m=dict()\\n        for c in ascii_lowercase:\\n            if c in chars:\\n                m.update({c:vals[chars.index(c)]})\\n            else:\\n                m.update({c:i})\\n            i+=1\\n        xx=[]\\n        for i in range(len(s)):\\n            xx.append(m[s[i]])\\n        print(xx)\\n        def maxSubArray(nums: List[int]) -> int:\\n            max_sum=nums[0]\\n            temp=0\\n            for i in range(len(nums)):\\n                if temp<0:\\n                    temp=0\\n                temp+=nums[i]\\n                if temp>max_sum:\\n                    max_sum=temp\\n            return max_sum\\n        \\n        \\n        \\n        return max(maxSubArray(xx),0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366456,
                "title": "python-kandane-s-algorithm",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = defaultdict(int)\\n        for i,c in enumerate(chars):\\n            d[c] = vals[i]\\n        for i, c in enumerate(\\'abcdefghijklmnopqrstuvwxyz\\'):\\n            if c not in d:\\n                d[c] = i + 1\\n        curmax = 0\\n        res = 0\\n        for c in s:\\n            curmax = max(curmax + d[c], 0)\\n            res = max(res, curmax)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = defaultdict(int)\\n        for i,c in enumerate(chars):\\n            d[c] = vals[i]\\n        for i, c in enumerate(\\'abcdefghijklmnopqrstuvwxyz\\'):\\n            if c not in d:\\n                d[c] = i + 1\\n        curmax = 0\\n        res = 0\\n        for c in s:\\n            curmax = max(curmax + d[c], 0)\\n            res = max(res, curmax)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073330,
                "title": "substring-maximum-cost-o-1-javascript-memory-95-45-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(26) ~= O(1)\\n```\\nvar maximumCostSubstring = function(s, chars, vals) {\\n    const charValues = {};\\n    for (let index = 0; index < chars.length; index++) {\\n        charValues[chars[index]] = vals[index];\\n    }\\n\\n    for (let index = 97; index <= 122; index++) {\\n        if (charValues[String.fromCharCode(index)] === undefined) {\\n            charValues[String.fromCharCode(index)] = index - 96;\\n        }\\n    }\\n    let sum = 0;\\n    let tempSum = 0;\\n    for (let index = 0; index < s.length; index++) {\\n        tempSum += charValues[s[index]];\\n        //Min Sum is 0, so if temp sum has gone below zero then adding prefixed sub string wont benefit\\n        if (tempSum < 0) {\\n            tempSum = 0;\\n        }\\n        if (sum < tempSum) {\\n            sum = tempSum;\\n        }\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumCostSubstring = function(s, chars, vals) {\\n    const charValues = {};\\n    for (let index = 0; index < chars.length; index++) {\\n        charValues[chars[index]] = vals[index];\\n    }\\n\\n    for (let index = 97; index <= 122; index++) {\\n        if (charValues[String.fromCharCode(index)] === undefined) {\\n            charValues[String.fromCharCode(index)] = index - 96;\\n        }\\n    }\\n    let sum = 0;\\n    let tempSum = 0;\\n    for (let index = 0; index < s.length; index++) {\\n        tempSum += charValues[s[index]];\\n        //Min Sum is 0, so if temp sum has gone below zero then adding prefixed sub string wont benefit\\n        if (tempSum < 0) {\\n            tempSum = 0;\\n        }\\n        if (sum < tempSum) {\\n            sum = tempSum;\\n        }\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3404657,
                "title": "kadane-algo-100-beats-easy-to-understand-short-sweet-c-code",
                "content": "````\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26,0);\\n        int i;\\n        for(i = 0; i < 26; i++)v[i] = i+1;//FIRST ASSIGN COST TO IT\\'S INDEX\\n        for(i = 0; i < chars.length(); i++)v[chars[i]-\\'a\\'] = vals[i];//ASSIGN COST ACCORDING TO CHARS AND VALS\\n        int ans = 0;//LET\\'S ANS 0\\n\\t\\tint sum = 0;//CALCULATE ANS\\n        for(auto &i: s){\\n            sum += v[i-\\'a\\'];\\n            if(sum<0)sum = 0;//IF COST < 0 ASSIGN TO 0 BECAUSE HERE WE FIND MAX COST\\n            ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26,0);\\n        int i;\\n        for(i = 0; i < 26; i++)v[i] = i+1;//FIRST ASSIGN COST TO IT\\'S INDEX\\n        for(i = 0; i < chars.length(); i++)v[chars[i]-\\'a\\'] = vals[i];//ASSIGN COST ACCORDING TO CHARS AND VALS\\n        int ans = 0;//LET\\'S ANS 0\\n\\t\\tint sum = 0;//CALCULATE ANS\\n        for(auto &i: s){\\n            sum += v[i-\\'a\\'];\\n            if(sum<0)sum = 0;//IF COST < 0 ASSIGN TO 0 BECAUSE HERE WE FIND MAX COST\\n            ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379140,
                "title": "indirect-kadane",
                "content": "***INTUITION***\\nWe have to find the substring cost(maximized)\\n1. Create a hashmap with all the 26 charactes as key and their value as their positions (ex. Key: \\'a\\' :: Value : 1). Then update the key-value pairs on the basis of `string chars` and `vector vals`.\\n2. Create a vector array and push value corresponding to the `string s`.\\n3. Now Apply Kadanes to find the max contigious subarray sum.\\n4. `return max( 0 , sum )`\\n\\n***CODE***\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) \\n\\t{\\n        unordered_map<char,int>m;\\n        for(int i=0;i<26;i++)\\n        {\\n            char ch=i+\\'a\\';\\n            m[ch]=i+1;\\n        }\\n        for(int i=0;i<chars.length();i++) m[chars[i]]=vals[i];\\n        \\n        vector<int>v;\\n        for(auto ele:s)\\n        {\\n            v.push_back(m[ele]);\\n        }\\n        \\n\\t\\t//KADANES\\n        int max_so_far = INT_MIN, max_ending_here = 0;\\n \\n        for (int i = 0; i < v.size(); i++) \\n\\t\\t{\\n            max_ending_here = max_ending_here + v[i];\\n            if (max_so_far < max_ending_here)\\n                max_so_far = max_ending_here;\\n\\n            if (max_ending_here < 0)\\n                max_ending_here = 0;\\n        }\\n\\t\\t\\n        return max( 0 , max_so_far );\\n    }\\n};\\n```\\n\\n# PLS UPVOTE \\n\\n![image](https://assets.leetcode.com/users/images/caf935a4-dfa6-4fa4-a285-f224af5583dd_1680611410.6690323.jpeg)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) \\n\\t{\\n        unordered_map<char,int>m;\\n        for(int i=0;i<26;i++)\\n        {\\n            char ch=i+\\'a\\';\\n            m[ch]=i+1;\\n        }\\n        for(int i=0;i<chars.length();i++) m[chars[i]]=vals[i];\\n        \\n        vector<int>v;\\n        for(auto ele:s)\\n        {\\n            v.push_back(m[ele]);\\n        }\\n        \\n\\t\\t//KADANES\\n        int max_so_far = INT_MIN, max_ending_here = 0;\\n \\n        for (int i = 0; i < v.size(); i++) \\n\\t\\t{\\n            max_ending_here = max_ending_here + v[i];\\n            if (max_so_far < max_ending_here)\\n                max_so_far = max_ending_here;\\n\\n            if (max_ending_here < 0)\\n                max_ending_here = 0;\\n        }\\n\\t\\t\\n        return max( 0 , max_so_far );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367438,
                "title": "sliding-window-mapping-o-n-time-o-26-space",
                "content": "# Intuition\\nOne shall calculate the sum for every subarray using suitable algorithm and update it whenever there is a negative sum to 0.\\n\\n# Approach\\n Here, we shall keep a look-up table for all the char-value pair in order to be able to calculate their sum quick. And since we are talking about subarrays, we can always think of a possibility to use sliding window or kadane\\'s algorithm.\\n\\n# Complexity\\n- Time complexity\\n    O(max(n,26)) ~ O(n)\\n    - As we are traversing the string once for calculation ans\\n    - Traversing the 26 characters for storing their corresponding values\\n    - Coz in worst case we can have a string of all the 26 chars repeating themselves \\n    \\n- Space complexity:\\n    O(26)\\n    - As we are storing the corresponding values for each char in a map for easy access\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char, int> m;\\n        for (int i=0; i<26; i++){\\n            m[\\'a\\'+i]=i+1;\\n        }\\n        for (int i=0; i<chars.size(); i++){\\n            m[chars[i]]=vals[i];\\n        }\\n        int start =0;\\n        int curr =0;\\n        int ans =0;\\n        for (int i=0; i<s.size(); i++){\\n            curr += m[s[i]];\\n            curr = max (curr, 0);\\n            ans = max (ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char, int> m;\\n        for (int i=0; i<26; i++){\\n            m[\\'a\\'+i]=i+1;\\n        }\\n        for (int i=0; i<chars.size(); i++){\\n            m[chars[i]]=vals[i];\\n        }\\n        int start =0;\\n        int curr =0;\\n        int ans =0;\\n        for (int i=0; i<s.size(); i++){\\n            curr += m[s[i]];\\n            curr = max (curr, 0);\\n            ans = max (ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367030,
                "title": "maximum-sum-subarray-variation-kadane-s-algorithm",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst create a mapping of each lowercase alphabet to its position value. Then, it updates the values for the characters in the chars string based on their corresponding values in the vals vector.\\n\\nNext, the code iterates over all characters in the input string s, and calculates the cost of each substring by summing the values of the characters in the substring. If the cost of a substring is greater than the current maximum, the maximum is updated. If the sum of the cost of the substring is less than zero, the sum is reset to zero since any substring with negative cost cannot be a maximum cost substring.\\n\\nFinally, if the maximum cost is negative, the code returns zero, otherwise, it returns the maximum cost substring.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int>m;\\n        int count = 1;\\n        for(char i = \\'a\\'; i <= \\'z\\'; i++) {\\n            m[i] = count;\\n            count++;\\n        }\\n        for(int i = 0; i < chars.size(); i++) {\\n            m[chars[i]] = vals[i];\\n        }\\n        int sum = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < s.size(); i++) {\\n            sum+=m[s[i]];\\n            if(maxi < sum){\\n                maxi = sum;\\n            }\\n            if(sum < 0) {\\n                sum = 0;\\n            }\\n        }\\n        if(maxi < 0){\\n            return 0;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int>m;\\n        int count = 1;\\n        for(char i = \\'a\\'; i <= \\'z\\'; i++) {\\n            m[i] = count;\\n            count++;\\n        }\\n        for(int i = 0; i < chars.size(); i++) {\\n            m[chars[i]] = vals[i];\\n        }\\n        int sum = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < s.size(); i++) {\\n            sum+=m[s[i]];\\n            if(maxi < sum){\\n                maxi = sum;\\n            }\\n            if(sum < 0) {\\n                sum = 0;\\n            }\\n        }\\n        if(maxi < 0){\\n            return 0;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366959,
                "title": "simplest-java-solution-using-kadane-s-algorithm",
                "content": "# Intuition\\nUse Kadane\\'a algorithm\\n\\n# Approach\\nFirst calculate all values for each character of string s and store it to an array. Then calculate maximum subarray sum using Kadane\\'s algorithm.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(n)\\n\\n![b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png](https://assets.leetcode.com/users/images/274181eb-f698-4c79-9ca2-4b8789eedeae_1680369453.4686017.png)\\n\\n# Code\\n```\\nclass Solution {\\n    //use Kadane\\'s algorithm to find maximum subarray sum\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = Integer.MIN_VALUE, currSum = 0;\\n        int max = Integer.MIN_VALUE;\\n        int count = 0;\\n        for(int i = 0;i<nums.length;i++)\\n        {\\n            if(nums[i]>=0)\\n            count++;\\n            max=Math.max(max,nums[i]);\\n        }\\n        if(count<=0)\\n        return max;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            currSum += nums[i];\\n            if(currSum<0)\\n                currSum = 0;\\n            maxSum = Math.max(maxSum,currSum);\\n        }\\n        return maxSum;\\n    }\\n    \\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashSet<Character> set = new HashSet<>();\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        \\n        //calculate all values for String s and take it to the value array\\n        int[] value = new int[s.length()];\\n        for(int i=0;i<chars.length();i++)\\n        {\\n            set.add(chars.charAt(i));\\n            map.put(chars.charAt(i),vals[i]);\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(set.contains(s.charAt(i)))\\n            {\\n                value[i] = map.get(s.charAt(i));\\n            }\\n            else\\n            {\\n                value[i] = s.charAt(i) - \\'a\\' + 1;\\n            }\\n        }\\n        \\n        //check if there exists at least one positive value\\n        int temp=0;\\n        for(int i=0;i<value.length;i++)\\n        {\\n            if(value[i]>0)\\n                temp = 1;\\n        }\\n        //if all value are negetive return 0\\n        if(temp==0) return 0;\\n            \\n        return maxSubArray(value);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //use Kadane\\'s algorithm to find maximum subarray sum\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = Integer.MIN_VALUE, currSum = 0;\\n        int max = Integer.MIN_VALUE;\\n        int count = 0;\\n        for(int i = 0;i<nums.length;i++)\\n        {\\n            if(nums[i]>=0)\\n            count++;\\n            max=Math.max(max,nums[i]);\\n        }\\n        if(count<=0)\\n        return max;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            currSum += nums[i];\\n            if(currSum<0)\\n                currSum = 0;\\n            maxSum = Math.max(maxSum,currSum);\\n        }\\n        return maxSum;\\n    }\\n    \\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashSet<Character> set = new HashSet<>();\\n        HashMap<Character,Integer> map = new HashMap<>();\\n        \\n        //calculate all values for String s and take it to the value array\\n        int[] value = new int[s.length()];\\n        for(int i=0;i<chars.length();i++)\\n        {\\n            set.add(chars.charAt(i));\\n            map.put(chars.charAt(i),vals[i]);\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(set.contains(s.charAt(i)))\\n            {\\n                value[i] = map.get(s.charAt(i));\\n            }\\n            else\\n            {\\n                value[i] = s.charAt(i) - \\'a\\' + 1;\\n            }\\n        }\\n        \\n        //check if there exists at least one positive value\\n        int temp=0;\\n        for(int i=0;i<value.length;i++)\\n        {\\n            if(value[i]>0)\\n                temp = 1;\\n        }\\n        //if all value are negetive return 0\\n        if(temp==0) return 0;\\n            \\n        return maxSubArray(value);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366686,
                "title": "kadane-s-algorithm-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int m = chars.size(), sum = 0, ans = 0;\\n        vector<int> value(26);\\n        for(int i=0; i<26; i++) value[i] = i + 1;\\n        for(int i=0; i<m; i++) value[chars[i] - \\'a\\'] = vals[i];\\n        \\n        for(char c : s) {\\n            sum += value[c - \\'a\\'];\\n            ans = max(ans, sum);\\n            if(sum < 0) sum = 0; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int m = chars.size(), sum = 0, ans = 0;\\n        vector<int> value(26);\\n        for(int i=0; i<26; i++) value[i] = i + 1;\\n        for(int i=0; i<m; i++) value[chars[i] - \\'a\\'] = vals[i];\\n        \\n        for(char c : s) {\\n            sum += value[c - \\'a\\'];\\n            ans = max(ans, sum);\\n            if(sum < 0) sum = 0; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366675,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Maximum Subarray\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char, int> mp;\\n        int id = 1;\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++) mp[c] = id, id++;\\n        for(int i=0; i<vals.size(); i++) mp[chars[i]] = vals[i];\\n        vector<int> nums;\\n        for(auto x: s) nums.push_back(mp[x]);\\n        int ans = nums[0], sum = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            sum += nums[i];\\n            if(sum > ans) ans = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n        return max(ans, 0); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char, int> mp;\\n        int id = 1;\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++) mp[c] = id, id++;\\n        for(int i=0; i<vals.size(); i++) mp[chars[i]] = vals[i];\\n        vector<int> nums;\\n        for(auto x: s) nums.push_back(mp[x]);\\n        int ans = nums[0], sum = 0;\\n        for(int i=0; i<nums.size(); i++) {\\n            sum += nums[i];\\n            if(sum > ans) ans = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n        return max(ans, 0); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366656,
                "title": "c-kadane-s-algorithm-very-easy-solution",
                "content": "\\tclass Solution\\n\\t{\\n\\tpublic:\\n\\t\\tint maximumCostSubstring(string s, string chars, vector<int> &vals)\\n\\t\\t{\\n\\t\\t\\tint n = s.size();\\n\\n\\t\\t\\t// create an unordered map to store the mapping of characters to values\\n\\t\\t\\tunordered_map<char, int> mp;\\n\\n\\t\\t\\t// initialize the values for all lowercase letters from \\'a\\' to \\'z\\'\\n\\t\\t\\tfor (char i = \\'a\\'; i <= \\'z\\'; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[i] = i - \\'a\\' + 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// update the values for the characters specified in \\'chars\\' using the values provided in \\'vals\\'\\n\\t\\t\\tfor (int i = 0; i < chars.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[chars[i]] = vals[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// create a vector to store the values of each character in the input string\\n\\t\\t\\tvector<int> vec;\\n\\n\\t\\t\\t// iterate through the input string and append the corresponding value for each character to the vector\\n\\t\\t\\tfor (auto a : s)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcout << mp[a] << \\',\\';\\n\\t\\t\\t\\tvec.push_back(mp[a]);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// compute the maximum sum of consecutive elements in the vector using the Kadane\\'s algorithm\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tint max1 = INT_MIN;\\n\\t\\t\\tif (vec.size() == 0)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tfor (int i = 0; i < vec.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum += vec[i];\\n\\t\\t\\t\\tif (sum < 0)\\n\\t\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t\\tmax1 = max(max1, sum);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// return the maximum sum\\n\\t\\t\\treturn max1;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution\\n\\t{\\n\\tpublic:\\n\\t\\tint maximumCostSubstring(string s, string chars, vector<int> &vals)\\n\\t\\t{\\n\\t\\t\\tint n = s.size();\\n\\n\\t\\t\\t// create an unordered map to store the mapping of characters to values\\n\\t\\t\\tunordered_map<char, int> mp;\\n\\n\\t\\t\\t// initialize the values for all lowercase letters from \\'a\\' to \\'z\\'\\n\\t\\t\\tfor (char i = \\'a\\'; i <= \\'z\\'; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmp[i] = i - \\'a\\' + 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3366477,
                "title": "simplest-c-solution-using-kadane-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->o(n)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int arr[26] = {0};\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            arr[s[i] - 97] = s[i] - 96;\\n        }\\n        \\n        for(int i=0; i<chars.size(); i++) {\\n            arr[chars[i] - 97] = vals[i];\\n        }\\n        \\n        int ans = 0;\\n        int sum = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            sum += arr[s[i] - 97];\\n            if(sum < 0) {\\n                sum = 0;\\n            }\\n            else if(sum > ans) ans = sum;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int arr[26] = {0};\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            arr[s[i] - 97] = s[i] - 96;\\n        }\\n        \\n        for(int i=0; i<chars.size(); i++) {\\n            arr[chars[i] - 97] = vals[i];\\n        }\\n        \\n        int ans = 0;\\n        int sum = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            sum += arr[s[i] - 97];\\n            if(sum < 0) {\\n                sum = 0;\\n            }\\n            else if(sum > ans) ans = sum;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366409,
                "title": "c-kadane-s-algorithm-easy-and-concise-o-n-time",
                "content": "# Complexity\\n- Time complexity:\\nO(n) **where n size of s string**\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int arr[26] = {0};\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            arr[s[i] - 97] = s[i] - 96;\\n        }\\n        \\n        for(int i=0; i<chars.size(); i++) {\\n            arr[chars[i] - 97] = vals[i];\\n        }\\n        \\n        int ans = 0;\\n        int sum = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            sum += arr[s[i] - 97];\\n            if(sum <= 0) {\\n                sum = 0;\\n            }\\n            else if(sum > ans) ans = sum;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int arr[26] = {0};\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            arr[s[i] - 97] = s[i] - 96;\\n        }\\n        \\n        for(int i=0; i<chars.size(); i++) {\\n            arr[chars[i] - 97] = vals[i];\\n        }\\n        \\n        int ans = 0;\\n        int sum = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            sum += arr[s[i] - 97];\\n            if(sum <= 0) {\\n                sum = 0;\\n            }\\n            else if(sum > ans) ans = sum;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366370,
                "title": "easy-java-solution-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashMap<Character,Integer> hm=new HashMap<>();\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<chars.length();i++){\\n            hm.put(chars.charAt(i),vals[i]);\\n        }\\n        int k=1;\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            if(!hm.containsKey(ch)){\\n                hm.put(ch,k);\\n            }\\n            k++;\\n        }\\n\\n        int ref=0;\\n        int arr[]=new int[s.length()];\\n\\n<!-- converting into array of values corresponding to letters in string s, to perform Kadanes algo -->\\n\\n        for(int i=0;i<s.length();i++)\\n            arr[i]=hm.get(s.charAt(i));\\n        \\n        for(int i=0;i<s.length();i++){\\n            ref+=arr[i];\\n                if(ref>ans){\\n                    ans=ref;\\n                }\\n            if(ref<0){\\n                ref=0;\\n            }\\n        }\\n        return ans<0?0:ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashMap<Character,Integer> hm=new HashMap<>();\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<chars.length();i++){\\n            hm.put(chars.charAt(i),vals[i]);\\n        }\\n        int k=1;\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            if(!hm.containsKey(ch)){\\n                hm.put(ch,k);\\n            }\\n            k++;\\n        }\\n\\n        int ref=0;\\n        int arr[]=new int[s.length()];\\n\\n<!-- converting into array of values corresponding to letters in string s, to perform Kadanes algo -->\\n\\n        for(int i=0;i<s.length();i++)\\n            arr[i]=hm.get(s.charAt(i));\\n        \\n        for(int i=0;i<s.length();i++){\\n            ref+=arr[i];\\n                if(ref>ans){\\n                    ans=ref;\\n                }\\n            if(ref<0){\\n                ref=0;\\n            }\\n        }\\n        return ans<0?0:ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824152,
                "title": "simple-easy-solution-beats-99-accepted",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, a: str, c: str, x: List[int]) -> int:\\n        y=[]\\n        for i in a:\\n            if i in c: y.append(x[c.index(i)])\\n            else: y.append(ord(i)-96)\\n        s=t=0\\n        for i in y:\\n            t=max(t,0)\\n            s=max(s,t)\\n            t+=i\\n        return max(s,t,0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, a: str, c: str, x: List[int]) -> int:\\n        y=[]\\n        for i in a:\\n            if i in c: y.append(x[c.index(i)])\\n            else: y.append(ord(i)-96)\\n        s=t=0\\n        for i in y:\\n            t=max(t,0)\\n            s=max(s,t)\\n            t+=i\\n        return max(s,t,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603025,
                "title": "kadane-c",
                "content": "\\n# Approach\\nWe use array hsh to store the resulting value of each character:\\n\\nWe initialize it with 1, 2, 3, 4... (key value from a to z)\\nand override certain values that are given in vals.\\nwe use Kadane to find the maximum sum subarray.\\n\\n# Complexity\\n- Time complexity:\\n- O(26)+O(26)+O(100000) ~= O(s.size()) \\n\\n- Space complexity:\\nO(26)\\n\\n# Code\\n```\\n        int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n            // create key-value array\\n            vector<int> hsh(26);\\n            for(char i=\\'a\\'; i<=\\'z\\'; ++i) hsh[i-\\'a\\'] = i-\\'a\\'+1;\\n            for(int i=0; i<chars.size(); ++i) hsh[chars[i]-\\'a\\'] = vals[i];\\n\\n            //Kadane\\'s algo to find max substring sum\\n            int csum=0, maxsum=0;\\n            for(auto c : s){\\n                csum = max(0,csum+hsh[c-\\'a\\']);\\n                maxsum = max(maxsum,csum);\\n            }\\n            return maxsum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\n        int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n            // create key-value array\\n            vector<int> hsh(26);\\n            for(char i=\\'a\\'; i<=\\'z\\'; ++i) hsh[i-\\'a\\'] = i-\\'a\\'+1;\\n            for(int i=0; i<chars.size(); ++i) hsh[chars[i]-\\'a\\'] = vals[i];\\n\\n            //Kadane\\'s algo to find max substring sum\\n            int csum=0, maxsum=0;\\n            for(auto c : s){\\n                csum = max(0,csum+hsh[c-\\'a\\']);\\n                maxsum = max(maxsum,csum);\\n            }\\n            return maxsum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478122,
                "title": "2606-find-the-substring-with-maximum-cost-java",
                "content": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int []ar=new int[26];\\n        for(int i=0;i<26;i++)\\n            ar[i]=i+1;\\n        for(int i=0;i<vals.length;i++ )\\n        {\\n            ar[chars.charAt(i)-\\'a\\']=vals[i];\\n        }\\n        int ans=0,cnt=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            cnt+=ar[s.charAt(i)-\\'a\\'];\\n            ans=Math.max(cnt,ans);\\n            if(cnt<0)\\n                cnt=0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int []ar=new int[26];\\n        for(int i=0;i<26;i++)\\n            ar[i]=i+1;\\n        for(int i=0;i<vals.length;i++ )\\n        {\\n            ar[chars.charAt(i)-\\'a\\']=vals[i];\\n        }\\n        int ans=0,cnt=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            cnt+=ar[s.charAt(i)-\\'a\\'];\\n            ans=Math.max(cnt,ans);\\n            if(cnt<0)\\n                cnt=0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382805,
                "title": "hashmap-kadane-c-solution-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvert characters values with required integers and then apply kadane to find maximum subarray\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. storing characters as 1 based index values in map\\n2. if character present in chars, replace its value with value in vals\\n3. store all characters values in a vector as integers \\n4. Now we Apply Kadane\\'s Algorithm to find maximum subarray \\n        \\n# Complexity\\n- Time complexity: O(chars.size() + s.size()).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(s.size()) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPls Spare 10 Milliseconds to Upvote if this solution helped you  \\uD83D\\uDE4C\\uD83D\\uDE0A\\u2764\\uFE0F\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n        unordered_map<char,int> mp;\\n\\n        int p=1;\\n        for(char c = \\'a\\';c<=\\'z\\';c++){\\n            mp[c] = p++; // storing characters as 1 based index values in map\\n        }\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i]; // if character present in chars, replace its value with value in vals\\n        }\\n        vector<int> temp;\\n        for(auto i:s){\\n            temp.push_back(mp[i]); // store all characters values in a vector as integers \\n        }\\n// Now we Apply Kadane\\'s Algorithm to find maximum subarray \\n        int ans = 0;\\n        int count = 0;\\n        for(auto i:temp){\\n            count+=i;\\n            ans = max(ans,count);\\n            if(count<0){\\n                count=0;\\n            }\\n        }\\n    return ans;   \\n    }\\n};\\n```\\nPls Spare 10 Milliseconds to Upvote if this solution helped you  \\uD83D\\uDE4C\\uD83D\\uDE0A\\u2764\\uFE0F\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n        unordered_map<char,int> mp;\\n\\n        int p=1;\\n        for(char c = \\'a\\';c<=\\'z\\';c++){\\n            mp[c] = p++; // storing characters as 1 based index values in map\\n        }\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i]; // if character present in chars, replace its value with value in vals\\n        }\\n        vector<int> temp;\\n        for(auto i:s){\\n            temp.push_back(mp[i]); // store all characters values in a vector as integers \\n        }\\n// Now we Apply Kadane\\'s Algorithm to find maximum subarray \\n        int ans = 0;\\n        int count = 0;\\n        for(auto i:temp){\\n            count+=i;\\n            ans = max(ans,count);\\n            if(count<0){\\n                count=0;\\n            }\\n        }\\n    return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375626,
                "title": "modifive-subarray-sum-well-explained-approach-inution-tc-sc-gauravthinks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- OOO DARO NA MALLO, YE TO BAS MODIFIVE SUBARRAY SUM HAI :-)\\n\\nwe keep athe record of max sum upto the current index and the moment our sum variable goes below 0, we reset it to 0 as negative values only decrease the max sum and not contribute much to the results.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- make a frequency array/hashset/map to keep the common characters of ```string s``` ans ```string chars```, with their respective values.\\nlike for each common value of ```s``` in ```chars```, we have been given ```vals``` array. so wee keep the common character\\'s as well as non common character\\'s values into the ```freq```\\n\\n-  then the rest is KADANE\\'S algorithm on the freq array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n-O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n-O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int res=0;\\n        // if(s==chars) return res;\\n        int sum=0;\\n        int n= s.size();\\n        int m= chars.size();\\n        vector<int> freq(26, 0);\\n        for(auto i=0;i<26; i++){\\n            freq[i] = i+1;\\n        }\\n        for(auto it=0; it<chars.size(); it++){\\n            freq[chars[it]-\\'a\\']= vals[it];\\n        }\\n        for(auto it: s){\\n            sum+= freq[it-\\'a\\'];\\n            res= max(res, sum);\\n            if(sum<0) sum=0;\\n            \\n        }\\n        return res;\\n    }\\n};\\n```\\nIf you liked the solution and explanation, then do Upvote the solution and subscribe to our YouTube Channel down below.\\n\\n# @GauravThinks <----- youtube channel",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```string s```\n```string chars```\n```s```\n```chars```\n```vals```\n```freq```\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int res=0;\\n        // if(s==chars) return res;\\n        int sum=0;\\n        int n= s.size();\\n        int m= chars.size();\\n        vector<int> freq(26, 0);\\n        for(auto i=0;i<26; i++){\\n            freq[i] = i+1;\\n        }\\n        for(auto it=0; it<chars.size(); it++){\\n            freq[chars[it]-\\'a\\']= vals[it];\\n        }\\n        for(auto it: s){\\n            sum+= freq[it-\\'a\\'];\\n            res= max(res, sum);\\n            if(sum<0) sum=0;\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373142,
                "title": "c-easy-using-kadane",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> m;\\n        for(int i = 0; i< chars.size(); i++)\\n        {\\n            m[chars[i]] = i;\\n        }\\n        int n = s.size();\\n        int sum = 0, maxi = INT_MIN;\\n        for(int i = 0; i< n ; i++)\\n        {\\n            if(m.find(s[i]) != m.end())\\n            {\\n                int index = m[s[i]];\\n                sum+= vals[index];\\n            }\\n            else\\n            {\\n                sum+= s[i]-\\'a\\'+1;\\n            }\\n            if(maxi < sum )\\n            {\\n                maxi = sum;\\n            }\\n            if( sum < 0)\\n            {\\n                sum = 0;\\n            }\\n        }\\n        if(maxi < 0)\\n            return 0;\\n        else\\n            return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> m;\\n        for(int i = 0; i< chars.size(); i++)\\n        {\\n            m[chars[i]] = i;\\n        }\\n        int n = s.size();\\n        int sum = 0, maxi = INT_MIN;\\n        for(int i = 0; i< n ; i++)\\n        {\\n            if(m.find(s[i]) != m.end())\\n            {\\n                int index = m[s[i]];\\n                sum+= vals[index];\\n            }\\n            else\\n            {\\n                sum+= s[i]-\\'a\\'+1;\\n            }\\n            if(maxi < sum )\\n            {\\n                maxi = sum;\\n            }\\n            if( sum < 0)\\n            {\\n                sum = 0;\\n            }\\n        }\\n        if(maxi < 0)\\n            return 0;\\n        else\\n            return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371417,
                "title": "cpp-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> mp;\\n        \\n        for(int i=0 ; i<s.size() ; i++){\\n            for(int j=0 ; j<chars.size() ; j++){\\n                if(s[i] == chars[j]){\\n                    mp[s[i]] = vals[j];\\n                    break;\\n                }\\n            }\\n            if(mp.find(s[i]) == mp.end()){\\n                mp[s[i]] = s[i] - \\'a\\' + 1;\\n            }\\n        }\\n\\n        int sum = 0;\\n        int ans = 0;\\n        int j = 0;\\n\\n        while(j < s.size()){\\n            sum += mp[s[j]];\\n            ans = max(ans,sum);\\n\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> mp;\\n        \\n        for(int i=0 ; i<s.size() ; i++){\\n            for(int j=0 ; j<chars.size() ; j++){\\n                if(s[i] == chars[j]){\\n                    mp[s[i]] = vals[j];\\n                    break;\\n                }\\n            }\\n            if(mp.find(s[i]) == mp.end()){\\n                mp[s[i]] = s[i] - \\'a\\' + 1;\\n            }\\n        }\\n\\n        int sum = 0;\\n        int ans = 0;\\n        int j = 0;\\n\\n        while(j < s.size()){\\n            sum += mp[s[j]];\\n            ans = max(ans,sum);\\n\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371276,
                "title": "java-solution-beats-100-time-beats-100-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nkadane\\'s algorithm\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n      \\n        ArrayList<Integer> ans = new ArrayList();\\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(chars.contains(s.charAt(i)+\"\")){\\n                \\n                ans.add(vals[chars.indexOf(s.charAt(i))]);\\n                \\n            }else{\\n                \\n                ans.add((int)s.charAt(i)- 96);\\n                \\n                \\n            }\\n        }\\n        System.out.println(ans);\\n       \\n        \\n        int msum = ans.get(0);\\n        int sum = 0;\\n        for(int i = 0 ; i < ans.size() ; i++){\\n            sum +=ans.get(i);\\n            msum = Math.max(msum, sum);\\n            if(sum < 0 ){\\n                sum = 0;\\n            }\\n        }\\n        if(msum < 0){\\n            return 0;\\n        }\\n        return msum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n      \\n        ArrayList<Integer> ans = new ArrayList();\\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(chars.contains(s.charAt(i)+\"\")){\\n                \\n                ans.add(vals[chars.indexOf(s.charAt(i))]);\\n                \\n            }else{\\n                \\n                ans.add((int)s.charAt(i)- 96);\\n                \\n                \\n            }\\n        }\\n        System.out.println(ans);\\n       \\n        \\n        int msum = ans.get(0);\\n        int sum = 0;\\n        for(int i = 0 ; i < ans.size() ; i++){\\n            sum +=ans.get(i);\\n            msum = Math.max(msum, sum);\\n            if(sum < 0 ){\\n                sum = 0;\\n            }\\n        }\\n        if(msum < 0){\\n            return 0;\\n        }\\n        return msum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371206,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string c, vector<int>& v) {\\n        int d[26];\\n        for(int i=0;i<26;i++){\\n            d[i]=i+1;\\n        }\\n        for(int i=0;i<c.size();i++){\\n            int x=c[i]-\\'a\\';\\n            // cout<<x;\\n            d[x]=v[i];\\n        }\\n        \\n        vector<int>pre;\\n        long long int sum=0;\\n        // pre.push_back(sum);\\n        for(int i=0;i<s.size();i++){\\n            int x=s[i]-\\'a\\';\\n            \\n            pre.push_back(d[x]);\\n        }\\n        for(int i=0;i<pre.size();i++){\\n            cout<<pre[i]<<\" \";\\n        }\\n        long long int maxi=0;\\n        //int sum=0;\\n        for(int i=0;i<pre.size();i++){\\n            \\n            if(sum+pre[i]<0){\\n                maxi=max(sum,maxi);\\n                sum=0;\\n            }\\n            else{\\n                sum+=pre[i];\\n                 maxi=max(sum,maxi);\\n            }\\n        }\\n        if(sum>0){\\n            maxi=max(sum,maxi);\\n        }\\n        return maxi;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string c, vector<int>& v) {\\n        int d[26];\\n        for(int i=0;i<26;i++){\\n            d[i]=i+1;\\n        }\\n        for(int i=0;i<c.size();i++){\\n            int x=c[i]-\\'a\\';\\n            // cout<<x;\\n            d[x]=v[i];\\n        }\\n        \\n        vector<int>pre;\\n        long long int sum=0;\\n        // pre.push_back(sum);\\n        for(int i=0;i<s.size();i++){\\n            int x=s[i]-\\'a\\';\\n            \\n            pre.push_back(d[x]);\\n        }\\n        for(int i=0;i<pre.size();i++){\\n            cout<<pre[i]<<\" \";\\n        }\\n        long long int maxi=0;\\n        //int sum=0;\\n        for(int i=0;i<pre.size();i++){\\n            \\n            if(sum+pre[i]<0){\\n                maxi=max(sum,maxi);\\n                sum=0;\\n            }\\n            else{\\n                sum+=pre[i];\\n                 maxi=max(sum,maxi);\\n            }\\n        }\\n        if(sum>0){\\n            maxi=max(sum,maxi);\\n        }\\n        return maxi;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3369754,
                "title": "dart-o-n-mapping-to-kadane-s-algorithm",
                "content": "# Code\\n```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int maximumCostSubstring(String s, String chars, List<int> vals) {\\n    HashMap<String, int> map = HashMap();\\n    for (var i = 1; i <= 26; i++) {\\n      map.addAll({String.fromCharCode((96 + i)): i});\\n    }\\n    int n = s.length;\\n    int m = vals.length;\\n    for (var i = 0; i < m; i++) {\\n      map[chars[i]] = vals[i];\\n    }\\n    List<int> nums = List.filled(n, 0);\\n    for (var i = 0; i < n; i++) {\\n      nums[i] = map[s[i]]!;\\n    }\\n    int res = maxSubArraySum(nums);\\n\\n    return res.isNegative ? 0 : res;\\n  }\\n\\n  int maxSubArraySum(List<int> a) {\\n    int size = a.length;\\n    int maxSoFar = -2147483648, maxEndingHere = 0;\\n\\n    for (int i = 0; i < size; i++) {\\n      maxEndingHere = maxEndingHere + a[i];\\n      if (maxSoFar < maxEndingHere) {\\n        maxSoFar = maxEndingHere;\\n      }\\n      if (maxEndingHere < 0) {\\n        maxEndingHere = 0;\\n      }\\n    }\\n    return maxSoFar;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int maximumCostSubstring(String s, String chars, List<int> vals) {\\n    HashMap<String, int> map = HashMap();\\n    for (var i = 1; i <= 26; i++) {\\n      map.addAll({String.fromCharCode((96 + i)): i});\\n    }\\n    int n = s.length;\\n    int m = vals.length;\\n    for (var i = 0; i < m; i++) {\\n      map[chars[i]] = vals[i];\\n    }\\n    List<int> nums = List.filled(n, 0);\\n    for (var i = 0; i < n; i++) {\\n      nums[i] = map[s[i]]!;\\n    }\\n    int res = maxSubArraySum(nums);\\n\\n    return res.isNegative ? 0 : res;\\n  }\\n\\n  int maxSubArraySum(List<int> a) {\\n    int size = a.length;\\n    int maxSoFar = -2147483648, maxEndingHere = 0;\\n\\n    for (int i = 0; i < size; i++) {\\n      maxEndingHere = maxEndingHere + a[i];\\n      if (maxSoFar < maxEndingHere) {\\n        maxSoFar = maxEndingHere;\\n      }\\n      if (maxEndingHere < 0) {\\n        maxEndingHere = 0;\\n      }\\n    }\\n    return maxSoFar;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369494,
                "title": "kadane-s-algorithm-beats-100-time-o-n-time-o-1-space",
                "content": "# Intuition\\nWe can hash the values of characters using chars array and then find the subarray with maximum sum using Kadane\\'s Algorithm. \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(26) = O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> values(26,1);\\n        \\n        for(int i = 0;i<26;i++){\\n            values[i] = i+1;\\n        }\\n        \\n        for(int i = 0;i<chars.size();i++){\\n            values[chars[i]-\\'a\\'] = vals[i];    \\n        }\\n        \\n        int mxsum = 0,curr = 0;\\n        for(int i = 0;i<s.size();i++){\\n            curr += values[s[i]-\\'a\\'];\\n            mxsum = max(mxsum,curr);\\n            \\n            if(curr < 0){\\n                curr = 0;\\n            }\\n        }\\n        \\n        return mxsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> values(26,1);\\n        \\n        for(int i = 0;i<26;i++){\\n            values[i] = i+1;\\n        }\\n        \\n        for(int i = 0;i<chars.size();i++){\\n            values[chars[i]-\\'a\\'] = vals[i];    \\n        }\\n        \\n        int mxsum = 0,curr = 0;\\n        for(int i = 0;i<s.size();i++){\\n            curr += values[s[i]-\\'a\\'];\\n            mxsum = max(mxsum,curr);\\n            \\n            if(curr < 0){\\n                curr = 0;\\n            }\\n        }\\n        \\n        return mxsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368128,
                "title": "java-solution",
                "content": "\\tpublic int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int l = 0;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++)\\n            map.put(c, c - \\'a\\' + 1);\\n        for(int i=0;i<vals.length;i++) \\n            map.put(chars.charAt(i), vals[i]);\\n        int res = 0, max = 0;\\n        for(int i=0;i<s.length();i++) {\\n            max = Math.max(map.get(s.charAt(i)), max + map.get(s.charAt(i)));\\n            res = Math.max(res, max);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tpublic int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int l = 0;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(char c = \\'a\\'; c <= \\'z\\'; c++)\\n            map.put(c, c - \\'a\\' + 1);\\n        for(int i=0;i<vals.length;i++) \\n            map.put(chars.charAt(i), vals[i]);\\n        int res = 0, max = 0;\\n        for(int i=0;i<s.length();i++) {\\n            max = Math.max(map.get(s.charAt(i)), max + map.get(s.charAt(i)));\\n            res = Math.max(res, max);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3368070,
                "title": "c-kadane-s-algorithm-for-char-representatives-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int>st(26,0);\\n         for(int i=0;i<26;i++){\\n            st[i]=i+1;\\n        }\\n        for(int i=0;i<vals.size();i++){\\n            st[chars[i] - \\'a\\']=vals[i];\\n        }\\n        \\n        int maxi=0,sum=0;\\n        for(auto x:s){\\n            sum+=st[x-\\'a\\'];\\n            maxi=max(sum,maxi);\\n            if(sum<=0){\\n                sum=0;\\n            }       \\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int>st(26,0);\\n         for(int i=0;i<26;i++){\\n            st[i]=i+1;\\n        }\\n        for(int i=0;i<vals.size();i++){\\n            st[chars[i] - \\'a\\']=vals[i];\\n        }\\n        \\n        int maxi=0,sum=0;\\n        for(auto x:s){\\n            sum+=st[x-\\'a\\'];\\n            maxi=max(sum,maxi);\\n            if(sum<=0){\\n                sum=0;\\n            }       \\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367983,
                "title": "standard-solution",
                "content": "# Intuition\\nFirst step is to calculate the cost for each position of string \\'s\\' and store it in vector. Then apply kadane algorithm to find maximum cost in subarrays of vector.  \\n\\n# Approach\\n-  First store the \\'chars\\' characters and it\\'s position in a map. \\n-  Calculate cost. 2 Possibilites:\\n-> \\'s\\' character is in \\'chars\\' then cost = vals[chars_map[ s[i] ] - 1]\\n-> \\'s\\' characters is **not** in \\'chars\\' then cost = s[i] - \\'a\\' + 1\\n- To find the maximum cost in subarrays of \\'cost_array\\' we use kadane\\'s algorithm.\\n\\n\\n# Complexity # \\n- Time complexity: **O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char, int> chars_map;\\n        for(int i=0; i<chars.size(); i++){\\n            chars_map[chars[i]] = i+1;\\n        } // Entering chars characters and its index in a map\\n\\n        vector<int> cost(s.size());\\n        for(int i=0; i<s.size(); i++){\\n            if(chars_map[s[i]] > 0){\\n                cost[i] = vals[chars_map[s[i]]-1];\\n            }\\n            else cost[i] = s[i] - \\'a\\' + 1;\\n        } // calculating cost for each poisition in string s and storing it in vector.\\n\\n        int i=0, n=cost.size(), maxi = 0, temp_sum=0;\\n        while(i < n){\\n            temp_sum += cost[i];\\n            if(temp_sum < 0){\\n                temp_sum = 0;\\n            }\\n            else\\n                maxi = max(maxi, temp_sum);\\n            i++;\\n        } // Kadane\\'s Algorithm\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char, int> chars_map;\\n        for(int i=0; i<chars.size(); i++){\\n            chars_map[chars[i]] = i+1;\\n        } // Entering chars characters and its index in a map\\n\\n        vector<int> cost(s.size());\\n        for(int i=0; i<s.size(); i++){\\n            if(chars_map[s[i]] > 0){\\n                cost[i] = vals[chars_map[s[i]]-1];\\n            }\\n            else cost[i] = s[i] - \\'a\\' + 1;\\n        } // calculating cost for each poisition in string s and storing it in vector.\\n\\n        int i=0, n=cost.size(), maxi = 0, temp_sum=0;\\n        while(i < n){\\n            temp_sum += cost[i];\\n            if(temp_sum < 0){\\n                temp_sum = 0;\\n            }\\n            else\\n                maxi = max(maxi, temp_sum);\\n            i++;\\n        } // Kadane\\'s Algorithm\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367666,
                "title": "java-beats-100",
                "content": "# Intuition\\nmap all the alphabets with there values and it become like maximum sub array problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character ,Integer> m=new HashMap<>();\\n        for(int i=0;i<26;i++){\\n            char x=(char) (97+i);\\n          m.put(x,chars.indexOf(x)!=-1 ? vals[chars.indexOf(x)] : i+1) ;\\n        }\\n        //now this is like maximum sub array problem\\n        int best=m.get(s.charAt(0));\\n        int sum=best;\\n        for(int i=1;i<s.length();i++){\\n            sum=Math.max(sum+m.get(s.charAt(i)),m.get(s.charAt(i)));\\n            best=Math.max(best,sum);\\n        }\\n        return best>0 ? best :0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character ,Integer> m=new HashMap<>();\\n        for(int i=0;i<26;i++){\\n            char x=(char) (97+i);\\n          m.put(x,chars.indexOf(x)!=-1 ? vals[chars.indexOf(x)] : i+1) ;\\n        }\\n        //now this is like maximum sub array problem\\n        int best=m.get(s.charAt(0));\\n        int sum=best;\\n        for(int i=1;i<s.length();i++){\\n            sum=Math.max(sum+m.get(s.charAt(i)),m.get(s.charAt(i)));\\n            best=Math.max(best,sum);\\n        }\\n        return best>0 ? best :0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367615,
                "title": "easy-code-simply-just-kaden-s-algo-used",
                "content": "\\n\\n# Approach\\nSimple kaden\\'s algorithm is being used.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n=s.size();\\n       \\n        //sara val store ho gaya maps me:\\n        unordered_map<char,int> m;\\n        for(int i=0;i<26;i++){\\n         m[97+i]=i+1;\\n            \\n       \\n        }\\n        for(int i=0;i<vals.size();i++){\\n          m[chars[i]]=vals[i];\\n           }\\n      // yha tk mee \\n       \\n         int ans=0;\\n      int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=m[s[i]];\\n            if(sum<0)\\n                sum=0;\\n            else if(sum>ans)  ans=sum;\\n        }\\n      \\n      return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n=s.size();\\n       \\n        //sara val store ho gaya maps me:\\n        unordered_map<char,int> m;\\n        for(int i=0;i<26;i++){\\n         m[97+i]=i+1;\\n            \\n       \\n        }\\n        for(int i=0;i<vals.size();i++){\\n          m[chars[i]]=vals[i];\\n           }\\n      // yha tk mee \\n       \\n         int ans=0;\\n      int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=m[s[i]];\\n            if(sum<0)\\n                sum=0;\\n            else if(sum>ans)  ans=sum;\\n        }\\n      \\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367582,
                "title": "using-kadane-algo-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    int maxSum(vector<int> nums) {\\n    int n = nums.size();\\n    int max_so_far = nums[0];\\n    int max_ending_here = nums[0];\\n    \\n    for (int i = 1; i < n; i++) {\\n        max_ending_here = max(max_ending_here + nums[i], nums[i]);\\n        max_so_far = max(max_so_far, max_ending_here);\\n    }\\n    \\n    return max_so_far;\\n}\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<int,int>m;\\n       for(int i=0;i<chars.size();i++){\\n           m[chars[i]]=vals[i];\\n       }\\n        int n=s.size();\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            if(m.count(s[i])==0){\\n            v.push_back(s[i]-96);}\\n            else{\\n                v.push_back(m[s[i]]);\\n            }\\n            \\n        }\\n        int max_sum = maxSum(v);\\n        if(max_sum<0) return 0;\\n        return max_sum;\\n      \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    int maxSum(vector<int> nums) {\\n    int n = nums.size();\\n    int max_so_far = nums[0];\\n    int max_ending_here = nums[0];\\n    \\n    for (int i = 1; i < n; i++) {\\n        max_ending_here = max(max_ending_here + nums[i], nums[i]);\\n        max_so_far = max(max_so_far, max_ending_here);\\n    }\\n    \\n    return max_so_far;\\n}\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<int,int>m;\\n       for(int i=0;i<chars.size();i++){\\n           m[chars[i]]=vals[i];\\n       }\\n        int n=s.size();\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            if(m.count(s[i])==0){\\n            v.push_back(s[i]-96);}\\n            else{\\n                v.push_back(m[s[i]]);\\n            }\\n            \\n        }\\n        int max_sum = maxSum(v);\\n        if(max_sum<0) return 0;\\n        return max_sum;\\n      \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367075,
                "title": "kadane-s-algorithm",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int kadanes(vector<int> &v,int n)\\n    {\\n        int ans = 0,t=0;\\n        for(int i=0; i<n; ++i){\\n            t += v[i];\\n            if(t < 0) t = 0;\\n            ans = max(ans,t);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> mp;\\n        int n=1;\\n        for(char c=\\'a\\'; c<=\\'z\\'; ++c){\\n            mp[c] = n++;\\n        }\\n        n=size(chars);\\n        for(int i=0; i<n; ++i){\\n            mp[chars[i]] = vals[i];\\n        }\\n        n = size(s);\\n        vector<int> v(n);\\n        for(int i=0; i<n; ++i){\\n            v[i] = mp[s[i]];\\n        }\\n        return kadanes(v,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int kadanes(vector<int> &v,int n)\\n    {\\n        int ans = 0,t=0;\\n        for(int i=0; i<n; ++i){\\n            t += v[i];\\n            if(t < 0) t = 0;\\n            ans = max(ans,t);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> mp;\\n        int n=1;\\n        for(char c=\\'a\\'; c<=\\'z\\'; ++c){\\n            mp[c] = n++;\\n        }\\n        n=size(chars);\\n        for(int i=0; i<n; ++i){\\n            mp[chars[i]] = vals[i];\\n        }\\n        n = size(s);\\n        vector<int> v(n);\\n        for(int i=0; i<n; ++i){\\n            v[i] = mp[s[i]];\\n        }\\n        return kadanes(v,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366887,
                "title": "form-an-array-from-given-string-apply-kadane-s-algo-explained",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\nIt is a variation of this question :\\n 53. Maximum Subarray\\n[https://leetcode.com/problems/maximum-subarray/description/]()\\n\\nFirst go through it\\'s solution here : \\n[https://leetcode.com/problems/maximum-subarray/solutions/3045580/kadane-s-algo-optimal-solution-intuition-explained/?orderBy=most_votes]()\\n\\n# Code\\n```\\nclass Solution {\\n//this is standard KADANE\\'s Algo\\n        int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int currSum = 0,maxi = INT_MIN;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n               //step 1\\n               currSum += nums[i]; \\n               //step 2 -> update the max value so far\\n                maxi = max(maxi,currSum); \\n              //step 3 -> no need to carry negative sum in next iteration, because it will only reduce the sum\\n                if(currSum < 0)  \\n                   currSum = 0;  \\n        }\\n        return maxi;\\n    }\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> m;\\n        \\n        for(int i=0; i<chars.size(); i++)\\n            m[chars[i]] = vals[i];\\n        \\n        vector<int> temp;\\n        \\n        for(auto it : s)\\n        {\\n            if(m.find(it) != m.end()) //if chracter is present in map ( i.e. it was present in vals)\\n             temp.push_back(m[it]); //push value given in vector vals\\n            else\\n             temp.push_back(int(it - \\'a\\') + 1); //otherwise push its position relative to a\\n        }\\n\\n        //now, apply Standard KADANE\\'s Algo on vector temp to find max Sum\\n        int ans = maxSubArray(temp); \\n        //since, ans should at least be 0\\n        return (ans > 0) ? ans : 0;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n//this is standard KADANE\\'s Algo\\n        int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int currSum = 0,maxi = INT_MIN;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n               //step 1\\n               currSum += nums[i]; \\n               //step 2 -> update the max value so far\\n                maxi = max(maxi,currSum); \\n              //step 3 -> no need to carry negative sum in next iteration, because it will only reduce the sum\\n                if(currSum < 0)  \\n                   currSum = 0;  \\n        }\\n        return maxi;\\n    }\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> m;\\n        \\n        for(int i=0; i<chars.size(); i++)\\n            m[chars[i]] = vals[i];\\n        \\n        vector<int> temp;\\n        \\n        for(auto it : s)\\n        {\\n            if(m.find(it) != m.end()) //if chracter is present in map ( i.e. it was present in vals)\\n             temp.push_back(m[it]); //push value given in vector vals\\n            else\\n             temp.push_back(int(it - \\'a\\') + 1); //otherwise push its position relative to a\\n        }\\n\\n        //now, apply Standard KADANE\\'s Algo on vector temp to find max Sum\\n        int ans = maxSubArray(temp); \\n        //since, ans should at least be 0\\n        return (ans > 0) ? ans : 0;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366841,
                "title": "easy-sliding-window-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is classical problem of kadane algorithm but I have used sliding window to solve this problem during contest \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Here I have store chars[] array character in map with its value in vals.\\n2.Then I used to sum the element and moved the point till negative sum.\\n3.Once I have found sum to negative, start i pointer from then end till i<=j && sum<=0 .\\n4.Then store the maximum obtained till now.\\n5.At the end if maxi is negative then return 0 else return the maxi.\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity: \\n   O(26)\\n\\nPlease vote me if it is helpful to you.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int i=0,j=0;\\n        map<char,int> mp;\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i];\\n        }\\n        int sum=0;\\n        int maxi=INT_MIN;\\n        while(j<s.size()){\\n            if(mp.find(s[j])!=mp.end()){\\n                sum+=mp[s[j]];\\n            }else{\\n                sum+=(s[j]-\\'a\\' + 1);\\n            }\\n            while(i<=j && sum<=0){\\n                if(mp.find(s[i])!=mp.end()){\\n                sum-=mp[s[i]];\\n            }else{\\n                sum-=(s[i]-\\'a\\' + 1);\\n            }\\n                i++;\\n            }\\n            maxi=max(maxi,sum);\\n            j++;\\n        }\\n        if(maxi<0){\\n            return 0;\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int i=0,j=0;\\n        map<char,int> mp;\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3366813,
                "title": "simple-o-n-time-o-1-space-solution-nice-application-of-kadane-s-algorithm",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> allvals(26,0);\\n        for(int i=0;i<26;i++){\\n            allvals[i]=i+1;\\n        }\\n        for(int i=0;i<chars.size();i++){\\n            allvals[chars[i]-97]=vals[i];\\n        }\\n        int maxans=0;\\n        int sum=0;\\n        for(int i=0;i<s.length();i++){\\n            sum+=allvals[s[i]-97];\\n            maxans=max(maxans,sum);\\n            if(sum<0) sum=0;\\n        }\\n        return maxans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> allvals(26,0);\\n        for(int i=0;i<26;i++){\\n            allvals[i]=i+1;\\n        }\\n        for(int i=0;i<chars.size();i++){\\n            allvals[chars[i]-97]=vals[i];\\n        }\\n        int maxans=0;\\n        int sum=0;\\n        for(int i=0;i<s.length();i++){\\n            sum+=allvals[s[i]-97];\\n            maxans=max(maxans,sum);\\n            if(sum<0) sum=0;\\n        }\\n        return maxans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366730,
                "title": "simple-kadane-s-application",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        int ans=0;\\n        int res=INT_MIN;\\n        for(int i=0;i<chars.size();i++){\\n            m[chars[i]]=vals[i];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            if(m.find(s[i])!=m.end()){\\n               \\n                if(ans+m[s[i]]>=0){\\n                        ans+=m[s[i]];\\n                      res=max(res,ans);\\n                }\\n                else{\\n                    ans=0;\\n                }\\n                    \\n            }\\n            else{\\n                ans+=s[i]-\\'a\\'+1;\\n                res=max(res,ans);\\n            }\\n        }\\n        if(res<0)return 0;\\n        return res;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        int ans=0;\\n        int res=INT_MIN;\\n        for(int i=0;i<chars.size();i++){\\n            m[chars[i]]=vals[i];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            if(m.find(s[i])!=m.end()){\\n               \\n                if(ans+m[s[i]]>=0){\\n                        ans+=m[s[i]];\\n                      res=max(res,ans);\\n                }\\n                else{\\n                    ans=0;\\n                }\\n                    \\n            }\\n            else{\\n                ans+=s[i]-\\'a\\'+1;\\n                res=max(res,ans);\\n            }\\n        }\\n        if(res<0)return 0;\\n        return res;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366683,
                "title": "kadane-s-algorithm-c",
                "content": "\\n\\n# Approach\\nKadane\\'s Algorithm is used here\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        map<char,int> mp;\\n        \\n        for(int i=0; i<chars.size(); i++){\\n            mp[chars[i]]=i;\\n\\n        }\\n        \\n        int sum=0;\\n        int maxe=INT_MIN;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            if(mp.find(s[i])!=mp.end()){\\n                sum+=vals[mp[s[i]]];\\n            }\\n            else{\\n                sum+= s[i]-\\'a\\'+1;\\n            }\\n\\n            \\n            if(sum<0){\\n                sum=0;\\n            }\\n            maxe=max(maxe,sum);\\n        }\\n\\n        return maxe;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        map<char,int> mp;\\n        \\n        for(int i=0; i<chars.size(); i++){\\n            mp[chars[i]]=i;\\n\\n        }\\n        \\n        int sum=0;\\n        int maxe=INT_MIN;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            if(mp.find(s[i])!=mp.end()){\\n                sum+=vals[mp[s[i]]];\\n            }\\n            else{\\n                sum+= s[i]-\\'a\\'+1;\\n            }\\n\\n            \\n            if(sum<0){\\n                sum=0;\\n            }\\n            maxe=max(maxe,sum);\\n        }\\n\\n        return maxe;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366619,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        nums = []\\n        c = {i: idx for idx, i in enumerate(chars)}\\n        \\n        for i in s:\\n            if i in c:\\n                nums.append(vals[c[i]])\\n            else:\\n                nums.append(ord(i) - ord(\\'a\\') + 1)\\n        \\n        res =0\\n        total = 0\\n        \\n        for i in nums:\\n            total += i\\n            res = max(res, total)\\n            \\n            if total < 0:\\n                total = 0\\n                \\n        return res           \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        nums = []\\n        c = {i: idx for idx, i in enumerate(chars)}\\n        \\n        for i in s:\\n            if i in c:\\n                nums.append(vals[c[i]])\\n            else:\\n                nums.append(ord(i) - ord(\\'a\\') + 1)\\n        \\n        res =0\\n        total = 0\\n        \\n        for i in nums:\\n            total += i\\n            res = max(res, total)\\n            \\n            if total < 0:\\n                total = 0\\n                \\n        return res           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366497,
                "title": "java-kadane-s-algo-easy-explanation-with-comments",
                "content": "So, basically the question is telling us to create the `cost` array & find the **maximum possible sum** of any subarray.\\nSo we apply **Kadane\\'s** Algorithm\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int n = s.length();\\n        int[] nums = new int[n]; //Array used for detecting max cost\\n        char[] ch = s.toCharArray();\\n        \\n        //Creating the cost array\\n        for(int i=0;i<n;++i){\\n           int index = chars.indexOf(ch[i]);\\n            \\n           if(index == -1) nums[i] = (ch[i] - \\'a\\') + 1; //If that character is not present in \\'chars\\', use it\\'s order based value. \\n           //Eg: a-1, b-2, c-3....\\n            \\n           else nums[i] = vals[index]; //If that character is present in \\'chars\\', use it\\'s value from \\'vals\\' array\\n        }\\n        \\n        //Kadane\\'s Algorithm\\n        int currsum = 0, maxSum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(currsum < 0) currsum=0; //If an element makes the cumulative sum \\'negative\\', don\\'t consider it\\n            \\n            currsum += nums[i]; //Add the current element into the cumulative sum\\n            maxSum = Math.max(maxSum, currsum); //Update maxSum\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int n = s.length();\\n        int[] nums = new int[n]; //Array used for detecting max cost\\n        char[] ch = s.toCharArray();\\n        \\n        //Creating the cost array\\n        for(int i=0;i<n;++i){\\n           int index = chars.indexOf(ch[i]);\\n            \\n           if(index == -1) nums[i] = (ch[i] - \\'a\\') + 1; //If that character is not present in \\'chars\\', use it\\'s order based value. \\n           //Eg: a-1, b-2, c-3....\\n            \\n           else nums[i] = vals[index]; //If that character is present in \\'chars\\', use it\\'s value from \\'vals\\' array\\n        }\\n        \\n        //Kadane\\'s Algorithm\\n        int currsum = 0, maxSum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(currsum < 0) currsum=0; //If an element makes the cumulative sum \\'negative\\', don\\'t consider it\\n            \\n            currsum += nums[i]; //Add the current element into the cumulative sum\\n            maxSum = Math.max(maxSum, currsum); //Update maxSum\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366493,
                "title": "kadane-algorithm-map-c",
                "content": "```\\n class Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int ans =0;\\n        map<char,pair<int,int>>mp;\\n            for(int i=0; i<chars.size(); i++){\\n                mp[chars[i]].first++;\\n                mp[chars[i]].second = vals[i];\\n                \\n            }\\n        int temp=0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(mp[s[i]].first==1){\\n                if(temp+mp[s[i]].second>0){\\n                    temp+=mp[s[i]].second;\\n                    ans = max(ans,temp);\\n\\n                }\\n                else{\\n                     \\n                    temp=0;\\n                }\\n                \\n            }\\n            else{\\n                if(temp+(s[i]-\\'a\\')+1>0){\\n                    temp+=(s[i]-\\'a\\'+1);\\n                    ans = max(ans,temp);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int ans =0;\\n        map<char,pair<int,int>>mp;\\n            for(int i=0; i<chars.size(); i++){\\n                mp[chars[i]].first++;\\n                mp[chars[i]].second = vals[i];\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3366480,
                "title": "all-approaches-brute-to-optimized-kadane-s-algo",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force - Generate All substring -> O(N^2)\\nKadane Algo - O(N)\\n# Complexity\\n- Time complexity: `O(N)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(26) ~ O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string &s, string &chars, vector<int>& vals) {\\n        \\n        vector<int>hash(26,INT_MAX);\\n        \\n        for(int i = 0; i<chars.size(); i++){\\n            hash[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        \\n        for(int i = 0; i<26; i++){\\n            if(hash[i]==INT_MAX) hash[i]=i+1;\\n        }\\n        \\n        int maxi = INT_MIN;\\n        //for(auto it:hash) cout<<it<<\" \";\\n        \\n        \\n        int temp = 0;\\n        for(int i = 0; i<s.size(); i++){\\n            temp+=hash[s[i]-\\'a\\'];\\n            if(temp>maxi) maxi = temp;\\n            if(temp<0) temp = 0;\\n        }\\n        \\n        // for(int i = 0; i<s.size(); i++){\\n        //     int temp = 0;\\n        //     for(int j = i; j<s.size(); j++){\\n        //         temp+=hash[s[j]-\\'a\\'];\\n        //         if(temp>maxi) maxi = temp;\\n        //     }\\n        // }\\n        return max(0,maxi);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string &s, string &chars, vector<int>& vals) {\\n        \\n        vector<int>hash(26,INT_MAX);\\n        \\n        for(int i = 0; i<chars.size(); i++){\\n            hash[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        \\n        for(int i = 0; i<26; i++){\\n            if(hash[i]==INT_MAX) hash[i]=i+1;\\n        }\\n        \\n        int maxi = INT_MIN;\\n        //for(auto it:hash) cout<<it<<\" \";\\n        \\n        \\n        int temp = 0;\\n        for(int i = 0; i<s.size(); i++){\\n            temp+=hash[s[i]-\\'a\\'];\\n            if(temp>maxi) maxi = temp;\\n            if(temp<0) temp = 0;\\n        }\\n        \\n        // for(int i = 0; i<s.size(); i++){\\n        //     int temp = 0;\\n        //     for(int j = i; j<s.size(); j++){\\n        //         temp+=hash[s[j]-\\'a\\'];\\n        //         if(temp>maxi) maxi = temp;\\n        //     }\\n        // }\\n        return max(0,maxi);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3366466,
                "title": "java-kadane-s-algo-o-n-solution",
                "content": "``` java []\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int[] a = new int[26];\\n        Arrays.fill(a,-1);\\n        int i=0;\\n        for(char ch:chars.toCharArray()){\\n            a[ch-\\'a\\']=i++;\\n        }\\n        int max=0, sum=0;\\n        for(char ch:s.toCharArray()){\\n            if(a[ch-\\'a\\']==-1){\\n                sum+=(ch-\\'a\\')+1;\\n            }\\n            else{\\n                sum+=vals[a[ch-\\'a\\']];\\n            }\\n            max=Math.max(max,sum);\\n            if(sum<0){\\n                sum=0;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int[] a = new int[26];\\n        Arrays.fill(a,-1);\\n        int i=0;\\n        for(char ch:chars.toCharArray()){\\n            a[ch-\\'a\\']=i++;\\n        }\\n        int max=0, sum=0;\\n        for(char ch:s.toCharArray()){\\n            if(a[ch-\\'a\\']==-1){\\n                sum+=(ch-\\'a\\')+1;\\n            }\\n            else{\\n                sum+=vals[a[ch-\\'a\\']];\\n            }\\n            max=Math.max(max,sum);\\n            if(sum<0){\\n                sum=0;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366416,
                "title": "find-the-substring-with-maximum-cost",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = s.length();\\n        unordered_map<char, int> char_values;\\n        for (int i = 0; i < chars.length(); i++) {\\n            char_values[chars[i]] = vals[i];\\n        }\\n        int max_cost = 0;\\n        int curr_cost = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (char_values.find(s[i]) != char_values.end()) {\\n                curr_cost += char_values[s[i]];\\n            } else {\\n                curr_cost += (int)(s[i] - \\'a\\' + 1);\\n            }\\n            max_cost = max(max_cost, curr_cost);\\n            if (curr_cost < 0) {\\n                curr_cost = 0;\\n            }\\n        }\\n        return max_cost;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = s.length();\\n        unordered_map<char, int> char_values;\\n        for (int i = 0; i < chars.length(); i++) {\\n            char_values[chars[i]] = vals[i];\\n        }\\n        int max_cost = 0;\\n        int curr_cost = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (char_values.find(s[i]) != char_values.end()) {\\n                curr_cost += char_values[s[i]];\\n            } else {\\n                curr_cost += (int)(s[i] - \\'a\\' + 1);\\n            }\\n            max_cost = max(max_cost, curr_cost);\\n            if (curr_cost < 0) {\\n                curr_cost = 0;\\n            }\\n        }\\n        return max_cost;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366410,
                "title": "c-dp-kadane-s-algorithms",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> costs(26);\\n        for(int i = 0; i < 26; i++)costs[i] = i+1;\\n        \\n        for(int i = 0; i < size(vals); i++) {\\n            costs[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        \\n        int n = size(s), sum = 0, maxSum = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            sum += costs[s[i] - \\'a\\'];\\n            \\n            if(sum < 0)sum = 0;\\n            maxSum = max(sum,maxSum);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> costs(26);\\n        for(int i = 0; i < 26; i++)costs[i] = i+1;\\n        \\n        for(int i = 0; i < size(vals); i++) {\\n            costs[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        \\n        int n = size(s), sum = 0, maxSum = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            sum += costs[s[i] - \\'a\\'];\\n            \\n            if(sum < 0)sum = 0;\\n            maxSum = max(sum,maxSum);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366385,
                "title": "java-hashmap-kadane-s-algo-explained",
                "content": "### Approach explained using comments:\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        // Record the values of each letter in \\'s\\' \\n        Map<Character, Integer> map = new HashMap<>();\\n        // Go through \\'chars\\' and record values from \\'vals\\' array\\n        for (int i = 0; i < chars.length(); i++) {\\n            map.put(chars.charAt(i), vals[i]);\\n        }\\n        // Then for the characters that might be missing in \\'chars\\'\\n        // go through \\'s\\' and put its value (1-indexed as mentioned in the problem)\\n        // only if it\\'s not present in map (i.e. \\'chars\\')\\n        for (char c : s.toCharArray()) {\\n            if (!map.containsKey(c)) {\\n                map.put(c, c - \\'a\\' + 1);\\n            }\\n        }\\n        \\n        // Now for a new array same length as of \\'s\\'\\n        // and put the values of each letter in \\'s\\' in the corresponding indices\\n        int[] arr = new int[s.length()];\\n        int idx = 0;\\n        for (char c : s.toCharArray()) {\\n            arr[idx++] = map.get(c);\\n        }\\n        \\n        // Maximum substring cost = Maximum subarray sum \\n        // Apply Kadane\\'s algo to get the maximum cost\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < arr.length; i++){\\n            sum += arr[i];\\n            if(sum > max) max = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n\\t\\t\\n        // In case max cost is negative, return 0\\n        return max < 0? 0 : max;\\n    }\\n}\\n```\\nLet $$n$$ be the length of string `s` and $$m$$ be the length of `chars`\\n##### Time complexity: $$O(m + 3.n)$$\\n##### Space complexity: $$O(m + n) + O(n)$$\\n---\\n\\n### We can also do it without creating the extra array, by directly applying Kadane\\'s algo on the string:\\n### Here is the solution:\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (int i = 0; i < chars.length(); i++) {\\n            map.put(chars.charAt(i), vals[i]);\\n        }\\n        for (char c : s.toCharArray()) {\\n            if (!map.containsKey(c)) {\\n                map.put(c, c - \\'a\\' + 1);\\n            }\\n        }\\n        \\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (char c : s.toCharArray()){\\n            sum += map.get(c);\\n            if(sum > max) max = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n\\t\\t\\n        return Math.max(max, 0);\\n    }\\n}\\n```\\nLet $$n$$ be the length of string `s` and $$m$$ be the length of `chars`\\n##### Time complexity: $$O(m + 2.n)$$\\n##### Space complexity: $$O(m + n)$$",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        // Record the values of each letter in \\'s\\' \\n        Map<Character, Integer> map = new HashMap<>();\\n        // Go through \\'chars\\' and record values from \\'vals\\' array\\n        for (int i = 0; i < chars.length(); i++) {\\n            map.put(chars.charAt(i), vals[i]);\\n        }\\n        // Then for the characters that might be missing in \\'chars\\'\\n        // go through \\'s\\' and put its value (1-indexed as mentioned in the problem)\\n        // only if it\\'s not present in map (i.e. \\'chars\\')\\n        for (char c : s.toCharArray()) {\\n            if (!map.containsKey(c)) {\\n                map.put(c, c - \\'a\\' + 1);\\n            }\\n        }\\n        \\n        // Now for a new array same length as of \\'s\\'\\n        // and put the values of each letter in \\'s\\' in the corresponding indices\\n        int[] arr = new int[s.length()];\\n        int idx = 0;\\n        for (char c : s.toCharArray()) {\\n            arr[idx++] = map.get(c);\\n        }\\n        \\n        // Maximum substring cost = Maximum subarray sum \\n        // Apply Kadane\\'s algo to get the maximum cost\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < arr.length; i++){\\n            sum += arr[i];\\n            if(sum > max) max = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n\\t\\t\\n        // In case max cost is negative, return 0\\n        return max < 0? 0 : max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (int i = 0; i < chars.length(); i++) {\\n            map.put(chars.charAt(i), vals[i]);\\n        }\\n        for (char c : s.toCharArray()) {\\n            if (!map.containsKey(c)) {\\n                map.put(c, c - \\'a\\' + 1);\\n            }\\n        }\\n        \\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (char c : s.toCharArray()){\\n            sum += map.get(c);\\n            if(sum > max) max = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n\\t\\t\\n        return Math.max(max, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366375,
                "title": "c-map-use",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> mp;\\n        for(char a=\\'a\\';a<=\\'z\\';a++){\\n            mp[a] = a-\\'a\\'+1;\\n        }\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        long long ans=0,sum=0;\\n        for(int i=0;i<s.size();i++){\\n            sum += mp[s[i]];\\n            if(ans<sum) ans = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> mp;\\n        for(char a=\\'a\\';a<=\\'z\\';a++){\\n            mp[a] = a-\\'a\\'+1;\\n        }\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        long long ans=0,sum=0;\\n        for(int i=0;i<s.size();i++){\\n            sum += mp[s[i]];\\n            if(ans<sum) ans = sum;\\n            if(sum < 0) sum = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366357,
                "title": "python-dp-o-n-beats-100",
                "content": "```python\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        # convert string to array [1, -1000, 1, 1]\\n        cost = {c: v for c, v in zip(chars, vals)}\\n        arr = [cost.get(c, ord(c) - ord(\\'a\\') + 1) for c in s]\\n\\n        # linear search of largest value (DP)\\n        dp = [0]*len(arr)\\n        dp[0] = arr[0]\\n        for i in range(1, len(arr)):\\n            dp[i] = max(0, arr[i], dp[i - 1] + arr[i])\\n\\n        return max(0, max(dp))\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        # convert string to array [1, -1000, 1, 1]\\n        cost = {c: v for c, v in zip(chars, vals)}\\n        arr = [cost.get(c, ord(c) - ord(\\'a\\') + 1) for c in s]\\n\\n        # linear search of largest value (DP)\\n        dp = [0]*len(arr)\\n        dp[0] = arr[0]\\n        for i in range(1, len(arr)):\\n            dp[i] = max(0, arr[i], dp[i - 1] + arr[i])\\n\\n        return max(0, max(dp))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084018,
                "title": "c-unordered-map-kadane-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        //We can use kadanes algo here\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i];\\n        }\\n        int cs=0;\\n        int ms=0;\\n        for(int i=0;i<s.size();i++){\\n            int val;\\n            if(mp.count(s[i])){\\n                val=mp[s[i]];\\n            }\\n            else{\\n                val=((s[i]-\\'a\\')+1);\\n            }\\n\\n            if(cs>0){\\n                cs+=val;\\n            }\\n            else{\\n                cs=val;\\n            }\\n            if(cs>ms){\\n                ms=cs;\\n            }\\n        }\\n        return ms;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        //We can use kadanes algo here\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i];\\n        }\\n        int cs=0;\\n        int ms=0;\\n        for(int i=0;i<s.size();i++){\\n            int val;\\n            if(mp.count(s[i])){\\n                val=mp[s[i]];\\n            }\\n            else{\\n                val=((s[i]-\\'a\\')+1);\\n            }\\n\\n            if(cs>0){\\n                cs+=val;\\n            }\\n            else{\\n                cs=val;\\n            }\\n            if(cs>ms){\\n                ms=cs;\\n            }\\n        }\\n        return ms;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074178,
                "title": "sliding-window-o-n-solution-cpp-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int>mymap;\\n        int cnt=1;\\n        char cur=\\'a\\';\\n        for(char chr:\"abcdefghijklmnopqrstuvwxyz\")\\n        {\\n            mymap[chr]=cnt;\\n            cnt++;\\n        }\\n        for(int i=0;i<chars.length();i++)\\n        {\\n            mymap[chars[i]]=vals[i];\\n        }\\n        int left=0,right=0;\\n        int curmax=0;\\n        int runval=0;\\n        while(right<s.length() && left<s.length())\\n        {\\n            runval+=mymap[s[right]];\\n            if(runval<0)\\n            {\\n                runval=0;\\n                right++;\\n                left=right;\\n            }\\n            else\\n            {\\n                curmax=max(curmax,runval);\\n                right++;\\n            }\\n        }\\n       return curmax;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int>mymap;\\n        int cnt=1;\\n        char cur=\\'a\\';\\n        for(char chr:\"abcdefghijklmnopqrstuvwxyz\")\\n        {\\n            mymap[chr]=cnt;\\n            cnt++;\\n        }\\n        for(int i=0;i<chars.length();i++)\\n        {\\n            mymap[chars[i]]=vals[i];\\n        }\\n        int left=0,right=0;\\n        int curmax=0;\\n        int runval=0;\\n        while(right<s.length() && left<s.length())\\n        {\\n            runval+=mymap[s[right]];\\n            if(runval<0)\\n            {\\n                runval=0;\\n                right++;\\n                left=right;\\n            }\\n            else\\n            {\\n                curmax=max(curmax,runval);\\n                right++;\\n            }\\n        }\\n       return curmax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073854,
                "title": "just-max-subarray-sum-becomes-string-with-a-hashmap-java-solution",
                "content": "*I am a beginner in java, but the code below is just basically kadane + hashmap*\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character,Integer> hmap = new HashMap<>();\\n        \\n        for(int i=0;i<chars.length();i++){\\n            char c = chars.charAt(i);\\n            hmap.put(c,vals[i]);\\n        };\\n        // max subarray sum problem \\n        int prev = 0;\\n        int res = 0;\\n        int val = 0;\\n        for(int i = 0; i<s.length();i++){\\n            char c = s.charAt(i);\\n            val = c-\\'a\\' + 1;\\n            if(hmap.containsKey(c)){\\n                val = hmap.get(c);\\n            }\\n            prev = Math.max(prev+val,val);\\n            res = Math.max(res,prev);\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character,Integer> hmap = new HashMap<>();\\n        \\n        for(int i=0;i<chars.length();i++){\\n            char c = chars.charAt(i);\\n            hmap.put(c,vals[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4044910,
                "title": "short-code-linear-time-constant-time-simple-kadane-s-algorithm",
                "content": "# Intuition\\nKadane\\'s Algorithm - Find maximum subarray sum with both positive and negative numbers. Just replace characters in **string s** with their values from vals or their respective values (\\'a\\' as 1, \\'b\\' as 2 .... and so on).\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int m[26];\\n        for(int i=0;i<26;i++) m[i]=i+1;\\n        for(int i=0;i<chars.length();i++) m[chars[i]-\\'a\\']=vals[i];\\n        int res=0;\\n        int tmp=0;\\n        for(int i=0;i<s.length();i++){\\n            tmp+=m[s[i]-\\'a\\'];\\n            if(tmp>res) res=tmp;\\n            if(tmp<0) tmp=0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int m[26];\\n        for(int i=0;i<26;i++) m[i]=i+1;\\n        for(int i=0;i<chars.length();i++) m[chars[i]-\\'a\\']=vals[i];\\n        int res=0;\\n        int tmp=0;\\n        for(int i=0;i<s.length();i++){\\n            tmp+=m[s[i]-\\'a\\'];\\n            if(tmp>res) res=tmp;\\n            if(tmp<0) tmp=0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042421,
                "title": "java-100-faster",
                "content": "# Intuition\\nWe can discard negative sums because the empty substring has value 0.\\n\\n# Approach\\nBuild a map array with values for all characters. Initialize an array with values for all characters in the input string. Iterate through the array and keep track of the residual sum and the maximum sum. If the reidual sum becomes negative, reset it to 0. Return the maximum sum.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int maximumCostSubstring(String s, String chars, int[] vals)\\n    {\\n        int [] c = new int[26];\\n\\n        for(int i=0; i<26; i++)\\n            c[i] = i + 1;\\n\\n        for(int i=0; i<vals.length; i++)\\n            c[chars.charAt(i)-\\'a\\'] = vals[i];\\n\\n        if(s.length()==1)\\n            return Math.max(0,c[s.charAt(0)-\\'a\\']);\\n\\n        int l = s.length();\\n        int [] h = new int[l];\\n        int m = 0;\\n\\n        for(int i=0; i<l; i++)\\n            h[i] = c[s.charAt(i)-\\'a\\'];\\n\\n        for(int i=0, r=0; i<l; i++)\\n        {\\n            r += h[i];\\n            m = Math.max(m,r);\\n            r = Math.max(0,r);\\n        }\\n\\n        return Math.max(0,m);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int maximumCostSubstring(String s, String chars, int[] vals)\\n    {\\n        int [] c = new int[26];\\n\\n        for(int i=0; i<26; i++)\\n            c[i] = i + 1;\\n\\n        for(int i=0; i<vals.length; i++)\\n            c[chars.charAt(i)-\\'a\\'] = vals[i];\\n\\n        if(s.length()==1)\\n            return Math.max(0,c[s.charAt(0)-\\'a\\']);\\n\\n        int l = s.length();\\n        int [] h = new int[l];\\n        int m = 0;\\n\\n        for(int i=0; i<l; i++)\\n            h[i] = c[s.charAt(i)-\\'a\\'];\\n\\n        for(int i=0, r=0; i<l; i++)\\n        {\\n            r += h[i];\\n            m = Math.max(m,r);\\n            r = Math.max(0,r);\\n        }\\n\\n        return Math.max(0,m);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026664,
                "title": "python-clean-kadane-s-algorithm",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        \\n        character_values = defaultdict(int)\\n        idx = 1\\n\\n        for ch in ascii_lowercase:\\n            if ch in chars:\\n                character_values[ch] = vals[chars.index(ch)]\\n            else:\\n                character_values[ch] = idx\\n            idx += 1\\n        \\n        mx = -inf\\n        running_sum = 0\\n        for ch in s:\\n            if running_sum < 0:\\n                running_sum = 0\\n            running_sum += character_values[ch]\\n            mx = max(mx,running_sum)\\n        \\n        return max(mx,0)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        \\n        character_values = defaultdict(int)\\n        idx = 1\\n\\n        for ch in ascii_lowercase:\\n            if ch in chars:\\n                character_values[ch] = vals[chars.index(ch)]\\n            else:\\n                character_values[ch] = idx\\n            idx += 1\\n        \\n        mx = -inf\\n        running_sum = 0\\n        for ch in s:\\n            if running_sum < 0:\\n                running_sum = 0\\n            running_sum += character_values[ch]\\n            mx = max(mx,running_sum)\\n        \\n        return max(mx,0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010693,
                "title": "find-the-substring-with-maximum-cost",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        p = \"abcdefghijklmnopqrstuvwxyz\"\\n        d = {}\\n        l = []\\n        for i in range(len(p)):\\n            d[p[i]] = i+1\\n        for i,j in zip(chars,vals):\\n            d[i] = j\\n        count = 0\\n        res =0\\n        for i in range(len(s)):\\n            count+= d[s[i]]\\n            if count > 0:\\n                res = max(res,count)\\n            else:\\n                count = 0\\n        return res\\n\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        p = \"abcdefghijklmnopqrstuvwxyz\"\\n        d = {}\\n        l = []\\n        for i in range(len(p)):\\n            d[p[i]] = i+1\\n        for i,j in zip(chars,vals):\\n            d[i] = j\\n        count = 0\\n        res =0\\n        for i in range(len(s)):\\n            count+= d[s[i]]\\n            if count > 0:\\n                res = max(res,count)\\n            else:\\n                count = 0\\n        return res\\n\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981737,
                "title": "ruby-o-n",
                "content": "```ruby\\n# @param {String} s\\n# @param {String} chars\\n# @param {Integer[]} vals\\n# @return {Integer}\\ndef maximum_cost_substring(s, chars, vals)\\n  val_by_char = {}\\n  chars.chars.each_with_index { | char, idx |\\n    val_by_char[char] = vals[idx]\\n  }\\n  res, cur = 0, 0\\n  s.each_char { | char |\\n    cur = [cur + (val_by_char.has_key?(char) ? val_by_char[char] : char.ord - \"a\".ord + 1), 0].max\\n    res = [res, cur].max\\n  }\\n  res\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {String} s\\n# @param {String} chars\\n# @param {Integer[]} vals\\n# @return {Integer}\\ndef maximum_cost_substring(s, chars, vals)\\n  val_by_char = {}\\n  chars.chars.each_with_index { | char, idx |\\n    val_by_char[char] = vals[idx]\\n  }\\n  res, cur = 0, 0\\n  s.each_char { | char |\\n    cur = [cur + (val_by_char.has_key?(char) ? val_by_char[char] : char.ord - \"a\".ord + 1), 0].max\\n    res = [res, cur].max\\n  }\\n  res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3981381,
                "title": "solution-with-comments-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsed a map to store the character and their values given in the vals array.\\n\\nNow Kadane\\'s Algorithm says\\nKeep on adding the continuous value till the time we don\\'t get a negative sum, parallely compare it with max_val.\\nIf sum becomes negative then this couldn\\'t be our ans so make sum=0 again hunt for max sum in remaining part of array.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\no(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// Kadane\\'s Algorithm\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n\\n        unordered_map<char,int> mp;\\n        //Store values of all char present in string chars\\n        for(int i=0;i<chars.size();i++)\\n        {\\n            mp[chars[i]]=vals[i];\\n        }\\n        // For character which are not present in string chars can be computed as \\n        // val=\\'a\\'- 96  since ascii value of \\'a\\' is 97\\n\\n        int sum=0,max_sum=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            // If char is not present in map then calculate val using ascii \\n            if(mp.find(s[i])==mp.end())\\n            {\\n                sum+=(s[i]-96);\\n            }\\n            //IF val is present for char then take that value\\n            if(mp.find(s[i])!=mp.end())\\n            {\\n                sum+=mp[s[i]];\\n            }\\n            if(sum>max_sum) max_sum=sum;\\n            //Whenever we get negative sum for any contagious memory we will \\n            // discard it bcz max value will always be >= 0\\n            if(sum<0) sum=0;\\n\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// Kadane\\'s Algorithm\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n\\n        unordered_map<char,int> mp;\\n        //Store values of all char present in string chars\\n        for(int i=0;i<chars.size();i++)\\n        {\\n            mp[chars[i]]=vals[i];\\n        }\\n        // For character which are not present in string chars can be computed as \\n        // val=\\'a\\'- 96  since ascii value of \\'a\\' is 97\\n\\n        int sum=0,max_sum=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            // If char is not present in map then calculate val using ascii \\n            if(mp.find(s[i])==mp.end())\\n            {\\n                sum+=(s[i]-96);\\n            }\\n            //IF val is present for char then take that value\\n            if(mp.find(s[i])!=mp.end())\\n            {\\n                sum+=mp[s[i]];\\n            }\\n            if(sum>max_sum) max_sum=sum;\\n            //Whenever we get negative sum for any contagious memory we will \\n            // discard it bcz max value will always be >= 0\\n            if(sum<0) sum=0;\\n\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957260,
                "title": "umap-running-sum",
                "content": "**time: `O(N)`; space: `O(C)`**\\n```\\nint maximumCostSubstring(string s, string c, vector<int>& v)\\n{\\n\\tunordered_map<int,int> um;    \\n\\tfor(int i{}; i<size(c); ++i)\\n\\t\\tum[c[i]] = v[i];\\n\\n\\tint out{};        \\n\\tfor(int i{}, t{}, m{}; i<size(s); ++i)\\n\\t{\\n\\t\\tt += um.count(s[i]) ? um[s[i]] : s[i]-\\'a\\'+1;\\n\\t\\tm = min(m, t);\\n\\t\\tout = max(out, t-m);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maximumCostSubstring(string s, string c, vector<int>& v)\\n{\\n\\tunordered_map<int,int> um;    \\n\\tfor(int i{}; i<size(c); ++i)\\n\\t\\tum[c[i]] = v[i];\\n\\n\\tint out{};        \\n\\tfor(int i{}, t{}, m{}; i<size(s); ++i)\\n\\t{\\n\\t\\tt += um.count(s[i]) ? um[s[i]] : s[i]-\\'a\\'+1;\\n\\t\\tm = min(m, t);\\n\\t\\tout = max(out, t-m);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944558,
                "title": "go-maximum-cost-substring-in-9ms-and-6-4mb-memory-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis approach drew inspiration from Algorithm casts on YouTube, where it was initially solved in Python, resulting in an execution time of 170ms and memory usage of 17MB. Applying the same concept in Go yielded a slightly quicker performance outcome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis code defines a function maximumCostSubstring that calculates the maximum cost substring based on given characters and values. It initializes an array values with indices 1 to 26. Then, it updates these values according to provided characters and corresponding values. The code employs Kandane\\'s Algorithm to find the maximum contiguous sum of values in the string s. It iterates through the string, updating maxSumEndingHere as it adds values corresponding to characters. If maxSumEndingHere becomes negative, it resets to 0. The final result is stored in maxSumSoFar, representing the maximum cost substring. The function returns this maximum cost.\\n\\n# Complexity\\n- Time complexity: O(n + m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nInitializing values array: This takes constant time O(26) or simply O(1), as the array length is constant.\\nLoop to update values array: This loop iterates through the characters in the chars string and updates the values array. Since there are n characters in the chars string, this loop has a time complexity of O(n).\\nKandane\\'s Algorithm loop: This loop iterates through the characters in the s string. Since there are m characters in the s string, this loop has a time complexity of O(m).\\nCombining these complexities, the overall time complexity of the function is O(1) + O(n) + O(m), which simplifies to O(n + m), where n is the length of the chars string and m is the length of the s string.\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nvalues array: This array has a constant length of 26, regardless of the input size. Thus, the space complexity of this array is O(26), which simplifies to O(1).\\n\\nInteger variables: The algorithm uses a few integer variables to store indices, sums, and maximum values. These variables occupy a constant amount of memory, so their space complexity is O(1).\\n\\nOverall, the space complexity of the algorithm is dominated by the values array and the integer variables, both of which have constant space requirements. Therefore, the space complexity of the entire algorithm is O(1).\\n\\n# Code\\n```\\nfunc maximumCostSubstring(s string, chars string, vals []int) int {\\n    //  initializes the values slice and The loop sets values from 1 to 26 for each index\\n    values := make([]int, 26)\\n\\n    // The loop sets values from 1 to 26 for each index\\n    for i := range values {\\n        values[i] = i + 1\\n    }\\n\\n    // This loop updates the values in the values slice based on the characters provided in the chars string and the corresponding values in the vals slice\\n    for i := 0; i < len(chars); i++ {\\n        values[chars[i] - \\'a\\'] = vals[i]\\n    }\\n\\n    // Using Kandane\\'s Algorithm\\n    maxSumEndingHere, maxSumSoFar := 0, 0\\n    for i := 0; i < len(s); i++ {\\n        maxSumEndingHere += values[s[i]-\\'a\\']\\n        if (maxSumEndingHere < 0) {\\n            maxSumEndingHere = 0\\n        }\\n\\n        if (maxSumEndingHere > maxSumSoFar) {\\n            maxSumSoFar = maxSumEndingHere\\n        }\\n    }\\n\\n    return maxSumSoFar\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumCostSubstring(s string, chars string, vals []int) int {\\n    //  initializes the values slice and The loop sets values from 1 to 26 for each index\\n    values := make([]int, 26)\\n\\n    // The loop sets values from 1 to 26 for each index\\n    for i := range values {\\n        values[i] = i + 1\\n    }\\n\\n    // This loop updates the values in the values slice based on the characters provided in the chars string and the corresponding values in the vals slice\\n    for i := 0; i < len(chars); i++ {\\n        values[chars[i] - \\'a\\'] = vals[i]\\n    }\\n\\n    // Using Kandane\\'s Algorithm\\n    maxSumEndingHere, maxSumSoFar := 0, 0\\n    for i := 0; i < len(s); i++ {\\n        maxSumEndingHere += values[s[i]-\\'a\\']\\n        if (maxSumEndingHere < 0) {\\n            maxSumEndingHere = 0\\n        }\\n\\n        if (maxSumEndingHere > maxSumSoFar) {\\n            maxSumSoFar = maxSumEndingHere\\n        }\\n    }\\n\\n    return maxSumSoFar\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925065,
                "title": "python-solution-mapping-and-kadane-s-algorithm",
                "content": "# Intuition\\nThe code essentially aims to find the contiguous substring within the input string s that has the maximum sum of associated values based on the provided character-value associations.\\n\\n# Approach\\nThe approach involves iterating through the input string s, maintaining a running sum of values (current_sum), and updating the maximum sum encountered (max_sum). This dynamic programming-like approach allows the code to consider both extending the current substring and starting a new substring at each character.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this code is O(n), where n is the length of the input string s. This is because the code iterates through the string once and performs constant-time operations (dictionary lookups, comparisons, and arithmetic) at each step.\\n\\n- Space complexity:\\nThe space complexity is O(1) since the additional space used (for variables like mapping, max_sum, and current_sum) remains constant regardless of the input size. The dictionary mapping takes a fixed amount of space, and the other variables used in the algorithm are not related to the input size.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        mapping = dict(zip(string.ascii_lowercase, range(1,27)))\\n        for i in range(len(vals)):\\n            mapping[chars[i]] = vals[i]\\n\\n        max_sum = 0;\\n        current_sum = 0;\\n        for i in range(len(s)):\\n            current_sum = max(mapping[s[i]], current_sum + mapping[s[i]]);\\n            max_sum = max(max_sum, current_sum);\\n        return max_sum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        mapping = dict(zip(string.ascii_lowercase, range(1,27)))\\n        for i in range(len(vals)):\\n            mapping[chars[i]] = vals[i]\\n\\n        max_sum = 0;\\n        current_sum = 0;\\n        for i in range(len(s)):\\n            current_sum = max(mapping[s[i]], current_sum + mapping[s[i]]);\\n            max_sum = max(max_sum, current_sum);\\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912619,
                "title": "c-easy-clean-code-dp",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int t(int i,string &s,map<char,int> &p,vector<int> &dp)\\n    {\\n        if(i>=s.size()) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n\\n        int sum=0;\\n        if(p.count(s[i]))\\n        sum=p[s[i]];\\n        else\\n        sum=s[i]-\\'a\\'+1;\\n\\n        return dp[i]=max(sum,sum+t(i+1,s,p,dp));\\n    }\\n    int maximumCostSubstring(string s, string c, vector<int>& v) {\\n        map<char,int> p;\\n        for(int i=0;i<c.size();i++)\\n        p[c[i]]=v[i];\\n\\n        vector<int> dp(s.size(),-1);\\n        int l=0;\\n        for(int i=0;i<s.size();i++)\\n        l=max(l,t(i,s,p,dp));\\n\\n        return l;\\n    }\\n};\\n```\\n\\n![cat.png](https://assets.leetcode.com/users/images/a1575ec3-e2c0-4e34-af48-6ca6e850cf11_1692091688.0080094.png)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t(int i,string &s,map<char,int> &p,vector<int> &dp)\\n    {\\n        if(i>=s.size()) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n\\n        int sum=0;\\n        if(p.count(s[i]))\\n        sum=p[s[i]];\\n        else\\n        sum=s[i]-\\'a\\'+1;\\n\\n        return dp[i]=max(sum,sum+t(i+1,s,p,dp));\\n    }\\n    int maximumCostSubstring(string s, string c, vector<int>& v) {\\n        map<char,int> p;\\n        for(int i=0;i<c.size();i++)\\n        p[c[i]]=v[i];\\n\\n        vector<int> dp(s.size(),-1);\\n        int l=0;\\n        for(int i=0;i<s.size();i++)\\n        l=max(l,t(i,s,p,dp));\\n\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883110,
                "title": "easy-beats-90-using-kadane-s-algorithm-and-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> mp;\\n        for(int i = 0; i<chars.length(); i++) mp[chars[i]] = vals[i];\\n        int mx = 0;\\n        int sum = 0;\\n        for(int i = 0; i<s.length(); i++){\\n            if(mp.find(s[i])!=mp.end()) sum += mp[s[i]];\\n            else sum+= s[i] - \\'a\\' + 1;\\n            if(sum<0) sum = 0;\\n            mx = max(mx, sum);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int> mp;\\n        for(int i = 0; i<chars.length(); i++) mp[chars[i]] = vals[i];\\n        int mx = 0;\\n        int sum = 0;\\n        for(int i = 0; i<s.length(); i++){\\n            if(mp.find(s[i])!=mp.end()) sum += mp[s[i]];\\n            else sum+= s[i] - \\'a\\' + 1;\\n            if(sum<0) sum = 0;\\n            mx = max(mx, sum);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882529,
                "title": "python-simple-intuitive-solution-with-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = {a:i+1 for i, a in enumerate(\"abcdefghijklmnopqrstuvwxyz\")}\\n        for i, c in enumerate(chars):\\n            d[c] = vals[i]\\n\\n        cur_max = 0\\n        cur_val = 0\\n        for c in s:\\n            x = d[c]\\n            cur_val += x\\n            if cur_val < 0:\\n                cur_val = 0\\n                continue\\n            if cur_val > cur_max:\\n                cur_max = cur_val\\n        return cur_max\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = {a:i+1 for i, a in enumerate(\"abcdefghijklmnopqrstuvwxyz\")}\\n        for i, c in enumerate(chars):\\n            d[c] = vals[i]\\n\\n        cur_max = 0\\n        cur_val = 0\\n        for c in s:\\n            x = d[c]\\n            cur_val += x\\n            if cur_val < 0:\\n                cur_val = 0\\n                continue\\n            if cur_val > cur_max:\\n                cur_max = cur_val\\n        return cur_max\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842022,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int ans=0;\\n        map<char,int>mp;\\n        for (int i=0;i<chars.size();i++)\\n        {\\n            mp[chars[i]]=i;\\n        }\\n        int cur=0;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (mp.count(s[i]))\\n            {\\n                int ind=mp[s[i]];\\n                cur+=vals[ind];\\n            }\\n            else cur+=(s[i]-\\'a\\'+1);\\n            if (cur>ans) ans=cur;\\n            if (cur<0) cur=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int ans=0;\\n        map<char,int>mp;\\n        for (int i=0;i<chars.size();i++)\\n        {\\n            mp[chars[i]]=i;\\n        }\\n        int cur=0;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (mp.count(s[i]))\\n            {\\n                int ind=mp[s[i]];\\n                cur+=vals[ind];\\n            }\\n            else cur+=(s[i]-\\'a\\'+1);\\n            if (cur>ans) ans=cur;\\n            if (cur<0) cur=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822819,
                "title": "easy-kadane-s-cpp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> mp;\\n        for(int i=0; i<chars.size(); i++)\\n            mp[chars[i]]=vals[i];\\n        vector<int> values(s.length(), 0);\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(mp.find(s[i])!=mp.end())\\n                values[i]=mp[s[i]];\\n            else\\n                values[i]=(s[i]-\\'a\\')+1;\\n        }\\n\\n        //finding max cost subarray\\n        int max_sum=0, curr_sum=0;\\n        for(int i=0; i<values.size(); i++)\\n        {\\n            curr_sum+=values[i];\\n            if(curr_sum<0)\\n                curr_sum=0;\\n            max_sum=max(max_sum, curr_sum);\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> mp;\\n        for(int i=0; i<chars.size(); i++)\\n            mp[chars[i]]=vals[i];\\n        vector<int> values(s.length(), 0);\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(mp.find(s[i])!=mp.end())\\n                values[i]=mp[s[i]];\\n            else\\n                values[i]=(s[i]-\\'a\\')+1;\\n        }\\n\\n        //finding max cost subarray\\n        int max_sum=0, curr_sum=0;\\n        for(int i=0; i<values.size(); i++)\\n        {\\n            curr_sum+=values[i];\\n            if(curr_sum<0)\\n                curr_sum=0;\\n            max_sum=max(max_sum, curr_sum);\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822173,
                "title": "simple-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhile reading the question you will get to know that this question is similar to Kadane algo question of Array where we had to return maxSumSoFar.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo as we did in kadanes algo, we will maintain curSum and MaxSum. Apart from that in this Particular case we need to store the value of characters which is predefined i.e if \\n``chars=[a,d,f]`` and `vals=[1,-25,9]` in unordered_map or any other data structure which ever u feel is better. I used map  because lookup was easy and `O(1)`.\\n\\nOnce our unordered map is ready we now have to traverse the string and check `if that particular element is present than add it to current` **or** `if not than we will extract 1 Indexed integeer value of char and add it to cur`.\\n\\nNow for some instance our `cur` would get less than `0` it means that this is not max because an **empty string** has value of `0` so we will cur with `0`.\\n\\nafter these all steps we will update our maxSum and return it.\\n\\n\\n# Complexity\\n- Time complexity:$$O(Max(N,M))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<chars.size();i++){\\n            mp.insert({chars[i],vals[i]});\\n        }\\n\\n        int cur=0,maxSum=0;\\n        for( auto c:s){\\n            if(mp.find(c)!=mp.end()){\\n                cur+=mp[c];\\n            }\\n            else {\\n                cur+=c-\\'a\\'+1;\\n            }\\n\\n            if(cur<0) cur=0;\\n\\n            maxSum=max(maxSum,cur);\\n        }\\n\\n        return maxSum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<chars.size();i++){\\n            mp.insert({chars[i],vals[i]});\\n        }\\n\\n        int cur=0,maxSum=0;\\n        for( auto c:s){\\n            if(mp.find(c)!=mp.end()){\\n                cur+=mp[c];\\n            }\\n            else {\\n                cur+=c-\\'a\\'+1;\\n            }\\n\\n            if(cur<0) cur=0;\\n\\n            maxSum=max(maxSum,cur);\\n        }\\n\\n        return maxSum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814672,
                "title": "solution-in-o-n-time-complexity-using-hashmap-and-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can first think to find all possible substrings which will take around O(N<sup>2</sup>) complexity.\\nBut we know if we have come across in the past that finding the maximum subarray sum there is an algorithm called Kadane\\'s Algorithm.\\nThis algorithm will reduce our time complexity to O(N).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We will take help of hashmap so that we dont have to calculate the value of the previouly calculated character again.\\n2. Once our hash map is ready with the given values of characters, we can iterate across the given string array.\\n3. If the character from the string is missing, than we know that we just have to calculate the value of the missing character by the simple formula (character - \\'a\\' + 1).\\n4. Then we can store that value in the previous hashmap.\\n5. This value can be considered while calculating the maximimum sum with the help of Kadane\\'s Algorithm.\\n6. **Kadane\\'s Algorithm** - We just need to keep summing all the elements unless our sum becomes negative. When our sum becomes negative we just reset our sum to zero.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe need to loop through all the elements in the given string.\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nApproximately 26 hash items are required so it can considered as constant space.\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> umap;\\n        int maxi = 0;\\n        for(int i=0; i<chars.length(); i++) {\\n            umap[chars[i]] = vals[i];\\n        }\\n        int l = s.length();\\n        int sum = 0;\\n        for(int i=0; i<l; i++) {\\n            int x = 0;\\n            if(umap.find(s[i]) != umap.end()) {\\n                x = umap[s[i]];\\n            }\\n            else {\\n                x = s[i] - \\'a\\' + 1;\\n                umap[s[i]] = x;\\n            }\\n            sum = sum + x;\\n            if(sum<0) sum = 0;\\n            maxi = max(maxi, sum);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int> umap;\\n        int maxi = 0;\\n        for(int i=0; i<chars.length(); i++) {\\n            umap[chars[i]] = vals[i];\\n        }\\n        int l = s.length();\\n        int sum = 0;\\n        for(int i=0; i<l; i++) {\\n            int x = 0;\\n            if(umap.find(s[i]) != umap.end()) {\\n                x = umap[s[i]];\\n            }\\n            else {\\n                x = s[i] - \\'a\\' + 1;\\n                umap[s[i]] = x;\\n            }\\n            sum = sum + x;\\n            if(sum<0) sum = 0;\\n            maxi = max(maxi, sum);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798047,
                "title": "python3-1d-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        dp = [0 for x in range(len(s)+1)]\\n        d = {}\\n        for x,y in zip(chars,vals):\\n            d[x] = y\\n        \\n        for idx,e in enumerate(s):\\n            if e in d.keys():\\n                dp[idx+1] = max(dp[idx]+d[e],d[e])\\n            else:\\n                dp[idx+1] = max(dp[idx]+ord(e)-96,ord(e)-96)\\n\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        dp = [0 for x in range(len(s)+1)]\\n        d = {}\\n        for x,y in zip(chars,vals):\\n            d[x] = y\\n        \\n        for idx,e in enumerate(s):\\n            if e in d.keys():\\n                dp[idx+1] = max(dp[idx]+d[e],d[e])\\n            else:\\n                dp[idx+1] = max(dp[idx]+ord(e)-96,ord(e)-96)\\n\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767869,
                "title": "maximum-cost-substring-calculation-with-character-mapping",
                "content": "### \"To the 21st-century adventures \\u2013 may they be epic, well-documented, and spark jealousy on social media!\"\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code aims to find the maximum cost substring in string s based on the values assigned to characters in the pairs vector.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. .-->\\nThe code starts by creating the pairs vector, which maps characters \\'a\\' to \\'z\\' to their respective values. It then creates the use vector, which maps characters from the chars string to their assigned values from the vals vector. The use vector is sorted based on character values.\\n\\nNext, the code updates the values in the pairs vector based on the values in the use vector. It iterates over the pairs vector and matches characters with the corresponding character in the use vector. If a match is found, the value in the pairs vector is updated.\\n\\nFinally, the code iterates over the characters in string s and calculates the maximum cost substring by accumulating the values assigned to the characters. The max_till variable keeps track of the maximum value obtained so far, and the ans variable stores the maximum cost encountered.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe creation of the pairs vector takes O(26) or O(1) since it is of constant size. The sorting of the use vector takes O(m log m), where m is the length of the chars string. The iteration over string s takes O(n), where n is the length of string s. Therefore, the overall time complexity is O(m log m + n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(26) for the pairs vector, O(m) for the use vector, and O(1) for other variables. Hence, the overall space complexity is O(m).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<pair<char, int>> pairs;\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            pairs.emplace_back(c, c - \\'a\\' + 1);\\n        }\\n        vector<pair<char, int>> use;\\n        for(int i =0 ; i < chars.size() ; i++ ){\\n            use.emplace_back(chars[i], vals[i]);\\n        }\\n        sort(use.begin(), use.end());\\n        int index = 0;\\n        for (auto& pair : pairs) {\\n            if(index >= chars.size()) break;\\n            if (pair.first == use[index].first) {\\n                pair.second = use[index].second;\\n                index++;\\n            }\\n        }\\n        int ans = 0;\\n        int max_till = 0;\\n        for(int i = 0 ; i < s.size(); i++){\\n            max_till += pairs[s[i] - \\'a\\'].second;\\n            if(max_till < 0) max_till = 0;\\n\\n            ans = max(ans, max_till);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<pair<char, int>> pairs;\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            pairs.emplace_back(c, c - \\'a\\' + 1);\\n        }\\n        vector<pair<char, int>> use;\\n        for(int i =0 ; i < chars.size() ; i++ ){\\n            use.emplace_back(chars[i], vals[i]);\\n        }\\n        sort(use.begin(), use.end());\\n        int index = 0;\\n        for (auto& pair : pairs) {\\n            if(index >= chars.size()) break;\\n            if (pair.first == use[index].first) {\\n                pair.second = use[index].second;\\n                index++;\\n            }\\n        }\\n        int ans = 0;\\n        int max_till = 0;\\n        for(int i = 0 ; i < s.size(); i++){\\n            max_till += pairs[s[i] - \\'a\\'].second;\\n            if(max_till < 0) max_till = 0;\\n\\n            ans = max(ans, max_till);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765311,
                "title": "python3-simple-solution",
                "content": "# Code\\n```python\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        cost = [x for x in range(1, 27)]\\n        for i, c in enumerate(chars):\\n            cost[ord(c)-ord(\\'a\\')] = vals[i]\\n        maximum = 0\\n        current = 0\\n        for c in s:\\n            current += cost[ord(c)-ord(\\'a\\')]\\n            maximum = max(maximum, current)\\n            current = max(current, 0)\\n        return maximum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        cost = [x for x in range(1, 27)]\\n        for i, c in enumerate(chars):\\n            cost[ord(c)-ord(\\'a\\')] = vals[i]\\n        maximum = 0\\n        current = 0\\n        for c in s:\\n            current += cost[ord(c)-ord(\\'a\\')]\\n            maximum = max(maximum, current)\\n            current = max(current, 0)\\n        return maximum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755502,
                "title": "sliding-window-unordered-map-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        int c=1;\\n        int res=0;\\n        int j=0;\\n        int temp=0;\\n        for(char i=\\'a\\';i<=\\'z\\';i++) m[i]=c++;\\n        for(int i=0;i<chars.size();i++) m[chars[i]]=vals[i];\\n        for(int i=0;i<s.size();i++){\\n            temp+=m[s[i]];\\n            while(temp<=0 and j<=i){\\n                temp-=m[s[j]];\\n                j++;\\n            }\\n            res=max(res,temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        int c=1;\\n        int res=0;\\n        int j=0;\\n        int temp=0;\\n        for(char i=\\'a\\';i<=\\'z\\';i++) m[i]=c++;\\n        for(int i=0;i<chars.size();i++) m[chars[i]]=vals[i];\\n        for(int i=0;i<s.size();i++){\\n            temp+=m[s[i]];\\n            while(temp<=0 and j<=i){\\n                temp-=m[s[j]];\\n                j++;\\n            }\\n            res=max(res,temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737992,
                "title": "dynamic-programming-o-n-solution",
                "content": "# Intuition\\nUse dynamic programming for this\\n# Approach\\nCreate 1D table where t_i represents the max value for substring ending in s_i. Base cases is s_0 and s_1. for i in [2, n] the recurrence uses the maximum of either previous + current string or, simply the current string.\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\nBeats 27%\\n- Space complexity:\\n$$O(n)$$\\nBeats 7%\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumCostSubstring(self, s, chars, vals):\\n        \"\"\"\\n        :type s: str\\n        :type chars: str\\n        :type vals: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        d = {x[1]: x[0] + 1 for x in enumerate(string.ascii_lowercase)}\\n \\n        for i in range(len(chars)):\\n            d[chars[i]] = vals[i]\\n\\n        n = len(s)\\n\\n        # DP - 1D table\\n        t = [0] * (n+1)\\n\\n        # Base cases\\n        t[0] = 0\\n        t[1] = d[s[0]]\\n\\n        # Recurrence\\n        for i in range(2, n+1):\\n            # max of previous and current or, just current\\n            t[i] = max(t[i-1] + d[s[i-1]], d[s[i-1]]) # Computers suck ! 0-indexes\\n\\n        # Return max of table\\n        return max(t)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumCostSubstring(self, s, chars, vals):\\n        \"\"\"\\n        :type s: str\\n        :type chars: str\\n        :type vals: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        d = {x[1]: x[0] + 1 for x in enumerate(string.ascii_lowercase)}\\n \\n        for i in range(len(chars)):\\n            d[chars[i]] = vals[i]\\n\\n        n = len(s)\\n\\n        # DP - 1D table\\n        t = [0] * (n+1)\\n\\n        # Base cases\\n        t[0] = 0\\n        t[1] = d[s[0]]\\n\\n        # Recurrence\\n        for i in range(2, n+1):\\n            # max of previous and current or, just current\\n            t[i] = max(t[i-1] + d[s[i-1]], d[s[i-1]]) # Computers suck ! 0-indexes\\n\\n        # Return max of table\\n        return max(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726228,
                "title": "java-recursive-memoization-kaden-s-algo-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nApproach one using recursive memoization (TLE)\\n\\n```\\nclass Solution {\\n\\n    Map<Character, Integer> charToCost;\\n    Integer[] memo;\\n\\n    int helper(String str, int[] vals, int index){\\n\\n        int n = str.length();\\n\\n        if(index >= n) return 0;\\n\\n        if(memo[index] != null) return memo[index];\\n\\n        int maxScore = 0;\\n        int currSum = 0;\\n\\n        for(int i = index; i < n; i++){\\n\\n            char ch = str.charAt(i);\\n            \\n            currSum += charToCost.getOrDefault(ch, ((ch - \\'a\\') + 1));\\n\\n            maxScore = Math.max(maxScore, Math.max(currSum, helper(str, vals, i + 1)));\\n        }\\n\\n        return memo[index] = maxScore;\\n    }\\n\\n    public int approachRecursiveMemoization(String s, String chars, int[] vals) {\\n        int n = s.length();\\n\\n        memo = new Integer[n + 1];\\n        \\n        charToCost = new HashMap<>();\\n        for(int i = 0; i < chars.length(); i++) charToCost.put(chars.charAt(i), vals[i]);\\n\\n        return helper(s, vals, 0);\\n    }\\n\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n\\n        return approachRecursiveMemoization(s, chars, vals);\\n    }\\n}\\n```\\n\\nApproach two using kaden\\'s algo\\n\\n```\\nclass Solution {\\n\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n\\n        int n = s.length();\\n\\n        int[] alphabetCost = new int[26];\\n\\n        //default cost for each char of alphabet (acc to question)\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n\\n            alphabetCost[ch - \\'a\\'] = ((ch - \\'a\\') + 1);\\n        }\\n\\n        //specific cost of i-th char from \\'chars\\' string is vals[i]\\n        for (int i = 0; i < chars.length(); i++) {\\n\\n            char chr = chars.charAt(i);\\n            int chrCost = vals[i];\\n\\n            alphabetCost[chr - \\'a\\'] = chrCost;\\n        }\\n\\n        //kaden\\'s algo\\n        int currCost = 0;\\n        //subarray cost can be negative, so keep the initial maxCost as\\n        //Int.MIN\\n        int maxCost = Integer.MIN_VALUE;\\n\\n        for(char ch : s.toCharArray()){\\n\\n            int cost = alphabetCost[ch - \\'a\\'];\\n\\n            currCost = Math.max(currCost + cost, cost);\\n            maxCost = Math.max(maxCost, currCost);\\n        }\\n\\n        //final maxCost to choose from the curr maxCost\\n        //or empty substring (\"\")\\n        //The cost of an empty string is considered 0\\n        //for cases like example 2\\n        return Math.max(maxCost, \"\".length());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    Map<Character, Integer> charToCost;\\n    Integer[] memo;\\n\\n    int helper(String str, int[] vals, int index){\\n\\n        int n = str.length();\\n\\n        if(index >= n) return 0;\\n\\n        if(memo[index] != null) return memo[index];\\n\\n        int maxScore = 0;\\n        int currSum = 0;\\n\\n        for(int i = index; i < n; i++){\\n\\n            char ch = str.charAt(i);\\n            \\n            currSum += charToCost.getOrDefault(ch, ((ch - \\'a\\') + 1));\\n\\n            maxScore = Math.max(maxScore, Math.max(currSum, helper(str, vals, i + 1)));\\n        }\\n\\n        return memo[index] = maxScore;\\n    }\\n\\n    public int approachRecursiveMemoization(String s, String chars, int[] vals) {\\n        int n = s.length();\\n\\n        memo = new Integer[n + 1];\\n        \\n        charToCost = new HashMap<>();\\n        for(int i = 0; i < chars.length(); i++) charToCost.put(chars.charAt(i), vals[i]);\\n\\n        return helper(s, vals, 0);\\n    }\\n\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n\\n        return approachRecursiveMemoization(s, chars, vals);\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n\\n        int n = s.length();\\n\\n        int[] alphabetCost = new int[26];\\n\\n        //default cost for each char of alphabet (acc to question)\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n\\n            alphabetCost[ch - \\'a\\'] = ((ch - \\'a\\') + 1);\\n        }\\n\\n        //specific cost of i-th char from \\'chars\\' string is vals[i]\\n        for (int i = 0; i < chars.length(); i++) {\\n\\n            char chr = chars.charAt(i);\\n            int chrCost = vals[i];\\n\\n            alphabetCost[chr - \\'a\\'] = chrCost;\\n        }\\n\\n        //kaden\\'s algo\\n        int currCost = 0;\\n        //subarray cost can be negative, so keep the initial maxCost as\\n        //Int.MIN\\n        int maxCost = Integer.MIN_VALUE;\\n\\n        for(char ch : s.toCharArray()){\\n\\n            int cost = alphabetCost[ch - \\'a\\'];\\n\\n            currCost = Math.max(currCost + cost, cost);\\n            maxCost = Math.max(maxCost, currCost);\\n        }\\n\\n        //final maxCost to choose from the curr maxCost\\n        //or empty substring (\"\")\\n        //The cost of an empty string is considered 0\\n        //for cases like example 2\\n        return Math.max(maxCost, \"\".length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710826,
                "title": "c-easy-solution",
                "content": "# Approach\\nKadane\\'s Algorithm\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumCostSubstring(string s, string chars, int[] vals) {\\n        var map = new int[26];\\n        int local_max = 0, global_max = 0;\\n\\n        for(int idx = 1; idx <= 26; idx++)\\n            map[idx - 1] = idx;\\n\\n        for(int idx = 0; idx < chars.Length; idx++)\\n            map[chars[idx] - \\'a\\'] = vals[idx];\\n\\n        for(int idx = 0; idx < s.Length; idx++) {\\n            local_max += map[s[idx] - \\'a\\'];\\n            global_max = Math.Max(global_max, local_max);\\n            if(local_max < 0)\\n                local_max = 0;\\n        }\\n\\n        return global_max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumCostSubstring(string s, string chars, int[] vals) {\\n        var map = new int[26];\\n        int local_max = 0, global_max = 0;\\n\\n        for(int idx = 1; idx <= 26; idx++)\\n            map[idx - 1] = idx;\\n\\n        for(int idx = 0; idx < chars.Length; idx++)\\n            map[chars[idx] - \\'a\\'] = vals[idx];\\n\\n        for(int idx = 0; idx < s.Length; idx++) {\\n            local_max += map[s[idx] - \\'a\\'];\\n            global_max = Math.Max(global_max, local_max);\\n            if(local_max < 0)\\n                local_max = 0;\\n        }\\n\\n        return global_max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687497,
                "title": "python-dict",
                "content": "# Intuition\\nKadane\\'s algorithm:\\n1. maintains current cost of substr ending at i, cur\\n2. maintains max cost variable, res\\n3. iterate through the string and update above 2 variables\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        m = {k:v for k, v in zip(chars, vals)}\\n        res = cur = 0\\n        for c in s:\\n            cur += m.get(c, ord(c) - 96)\\n            if cur < 0:\\n                cur = 0\\n            res = max(res, cur)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        m = {k:v for k, v in zip(chars, vals)}\\n        res = cur = 0\\n        for c in s:\\n            cur += m.get(c, ord(c) - 96)\\n            if cur < 0:\\n                cur = 0\\n            res = max(res, cur)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685424,
                "title": "java-simple-explanation-with-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAccording to the fact, that we have to find subarray with max sum, it`s obvious that we have to use Kadane\\u2019s Algorithm.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe separate solution to two parts:\\n1)We have build array with cost values of elements from the s string. If val contains the element - we add it`s value, else we calculate the value using char value of the element.\\n2)We have to find a substring with the largest sum and return this sum. We use Kadane\\u2019s Algorithm to resolve thar. If the maximum sum is less than 0, we return 0, else we return the sum.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int [] costs = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int cost=0;\\n            char ch = s.charAt(i);\\n            if(chars.indexOf(ch)==-1) cost=ch-96;\\n            else cost=vals[chars.indexOf(ch)];\\n            costs[i]=cost;\\n        }\\n        \\n        int max_so_far = Integer.MIN_VALUE;\\n        int max_ending_here =0;\\n\\n        for(int i=0;i<costs.length;i++){\\n            max_ending_here=max_ending_here+costs[i];\\n            if(max_so_far<max_ending_here)\\n                max_so_far=max_ending_here;\\n            if(max_ending_here<0)\\n                max_ending_here=0;\\n        }\\n        return Math.max(0,max_so_far);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int [] costs = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int cost=0;\\n            char ch = s.charAt(i);\\n            if(chars.indexOf(ch)==-1) cost=ch-96;\\n            else cost=vals[chars.indexOf(ch)];\\n            costs[i]=cost;\\n        }\\n        \\n        int max_so_far = Integer.MIN_VALUE;\\n        int max_ending_here =0;\\n\\n        for(int i=0;i<costs.length;i++){\\n            max_ending_here=max_ending_here+costs[i];\\n            if(max_so_far<max_ending_here)\\n                max_so_far=max_ending_here;\\n            if(max_ending_here<0)\\n                max_ending_here=0;\\n        }\\n        return Math.max(0,max_so_far);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673492,
                "title": "kadanes-algorithm-o-n-simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>mp;\\n             int sum;\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i];\\n        }\\n        if(mp.find(s[0])!=mp.end()){\\n            sum=mp[s[0]];\\n        }\\n        else{\\n            sum=(s[0]-\\'a\\')+1;\\n        }\\n        int maxsum=sum;\\n        for(int i=1;i<s.size();i++){\\n            int a=0;\\n            if(mp.find(s[i])!=mp.end()){\\n                a=mp[s[i]];\\n            }\\n            else{\\n                a=(s[i]-\\'a\\')+1;\\n            }\\n            sum=max(a,sum+a);\\n            if(sum>maxsum){\\n            maxsum=sum;\\n           }\\n        }\\n        \\n       if(maxsum<0){\\n           return 0;\\n       }\\n  return maxsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>mp;\\n             int sum;\\n        for(int i=0;i<chars.size();i++){\\n            mp[chars[i]]=vals[i];\\n        }\\n        if(mp.find(s[0])!=mp.end()){\\n            sum=mp[s[0]];\\n        }\\n        else{\\n            sum=(s[0]-\\'a\\')+1;\\n        }\\n        int maxsum=sum;\\n        for(int i=1;i<s.size();i++){\\n            int a=0;\\n            if(mp.find(s[i])!=mp.end()){\\n                a=mp[s[i]];\\n            }\\n            else{\\n                a=(s[i]-\\'a\\')+1;\\n            }\\n            sum=max(a,sum+a);\\n            if(sum>maxsum){\\n            maxsum=sum;\\n           }\\n        }\\n        \\n       if(maxsum<0){\\n           return 0;\\n       }\\n  return maxsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657433,
                "title": "kadane-s-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>hash;\\n        for(int i=0;i<chars.length();i++)\\n        hash[chars[i]] = vals[i];\\n        int n = s.length();\\n        vector<int>nums(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(hash.find(s[i]) != hash.end())\\n            {\\n                nums[i] = hash[s[i]];\\n            }\\n            else\\n            nums[i] = s[i] - \\'a\\' + 1;\\n        }\\n        int currsum = 0;\\n        int maxsum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            currsum += nums[i];\\n            if(nums[i] > currsum)\\n            currsum = nums[i];\\n            maxsum = max(maxsum,currsum);\\n        }\\n        return maxsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>hash;\\n        for(int i=0;i<chars.length();i++)\\n        hash[chars[i]] = vals[i];\\n        int n = s.length();\\n        vector<int>nums(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(hash.find(s[i]) != hash.end())\\n            {\\n                nums[i] = hash[s[i]];\\n            }\\n            else\\n            nums[i] = s[i] - \\'a\\' + 1;\\n        }\\n        int currsum = 0;\\n        int maxsum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            currsum += nums[i];\\n            if(nums[i] > currsum)\\n            currsum = nums[i];\\n            maxsum = max(maxsum,currsum);\\n        }\\n        return maxsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627158,
                "title": "easy-o-n-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- tmp memorizes the cost of substring from nums[0] to nums[i]\\n- result memorizes the maximal cost of substring up to now\\n- tmp=max({v[s[i]-\\'a\\'],v[s[i]-\\'a\\']+tmp,0});\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26);\\n        for(int i=0;i<v.size();i++) v[i]=i+1;\\n        for(int i=0;i<chars.size();i++)\\n            v[chars[i]-\\'a\\']=vals[i];\\n        int tmp=0,result=0;\\n        for(int i=0;i<s.size();i++){\\n            tmp=max({v[s[i]-\\'a\\'],v[s[i]-\\'a\\']+tmp,0});\\n            result=max(tmp,result);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26);\\n        for(int i=0;i<v.size();i++) v[i]=i+1;\\n        for(int i=0;i<chars.size();i++)\\n            v[chars[i]-\\'a\\']=vals[i];\\n        int tmp=0,result=0;\\n        for(int i=0;i<s.size();i++){\\n            tmp=max({v[s[i]-\\'a\\'],v[s[i]-\\'a\\']+tmp,0});\\n            result=max(tmp,result);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609956,
                "title": "kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a new Array with mapped values from either vals[] if the current character is in chars or else use its Character Index. \\n\\nPerform Usual Kadane\\'s Algorithm in the next Step.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        int len = s.length();\\n        int idx = 0;\\n        for(char c: chars.toCharArray())\\n            map.put(c, vals[idx++]);\\n\\n        int[] maxArr = new int[len];\\n\\n        for(int i = 0; i < len; i++)\\n        {\\n            int current = s.charAt(i) - 96;\\n            if(map.containsKey(s.charAt(i)))\\n                current = map.get(s.charAt(i));\\n            maxArr[i] = current;\\n        }\\n        \\n        int currentMax = maxArr[0];\\n        int max = maxArr[0];\\n\\n        for(int i = 1; i < len; i++)\\n        {\\n            currentMax = Math.max(maxArr[i], currentMax + maxArr[i]);\\n            max = Math.max(max, currentMax);\\n        }\\n\\n        return Math.max(max, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        int len = s.length();\\n        int idx = 0;\\n        for(char c: chars.toCharArray())\\n            map.put(c, vals[idx++]);\\n\\n        int[] maxArr = new int[len];\\n\\n        for(int i = 0; i < len; i++)\\n        {\\n            int current = s.charAt(i) - 96;\\n            if(map.containsKey(s.charAt(i)))\\n                current = map.get(s.charAt(i));\\n            maxArr[i] = current;\\n        }\\n        \\n        int currentMax = maxArr[0];\\n        int max = maxArr[0];\\n\\n        for(int i = 1; i < len; i++)\\n        {\\n            currentMax = Math.max(maxArr[i], currentMax + maxArr[i]);\\n            max = Math.max(max, currentMax);\\n        }\\n\\n        return Math.max(max, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598084,
                "title": "easy-understanding-simple-logic-kadane-s-algo-clean-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string &s, string &chars, vector<int>& vals) {\\n        int n = s.size();\\n        \\n        int values[26] = {0};\\n        for(int i = 0; i < 26; ++i) {\\n            values[i] = i + 1;\\n        }\\n        \\n        int chsize = vals.size();\\n        for(int i = 0; i < chsize; ++i) {\\n            values[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        \\n        int cost = 0, curr_cost = 0;\\n        for(int i = 0; i < n; ++i) {\\n            curr_cost += values[s[i] - \\'a\\'];\\n            \\n            if(curr_cost < 0)\\n                curr_cost = 0;\\n            \\n            cost = max(cost, curr_cost);\\n        }\\n        \\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string &s, string &chars, vector<int>& vals) {\\n        int n = s.size();\\n        \\n        int values[26] = {0};\\n        for(int i = 0; i < 26; ++i) {\\n            values[i] = i + 1;\\n        }\\n        \\n        int chsize = vals.size();\\n        for(int i = 0; i < chsize; ++i) {\\n            values[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        \\n        int cost = 0, curr_cost = 0;\\n        for(int i = 0; i < n; ++i) {\\n            curr_cost += values[s[i] - \\'a\\'];\\n            \\n            if(curr_cost < 0)\\n                curr_cost = 0;\\n            \\n            cost = max(cost, curr_cost);\\n        }\\n        \\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584978,
                "title": "easy-kadane-s-algorithm-c-solution",
                "content": "\\n# Approach\\nKadane\\'s Algorithm\\n\\n# Complexity\\n- Time complexity:\\nO(N) where N is the size of String s.\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26);\\n        for(int i = 0;i<26;i++){\\n            v[i] = i+1;\\n        }\\n        for(int i = 0;i<chars.size();i++){\\n            v[chars[i]-\\'a\\'] =vals[i]; \\n        }\\n        vector<int> sd(s.size());\\n        for(int i = 0;i<s.size();i++){\\n            sd[i] = v[s[i]-\\'a\\'];\\n        }\\n        int ans = 0;\\n        int sum = 0;\\n        for(int i = 0;i<sd.size();i++){\\n            sum+=sd[i];\\n            if(sum<0){\\n                sum = 0;\\n            }\\n            ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> v(26);\\n        for(int i = 0;i<26;i++){\\n            v[i] = i+1;\\n        }\\n        for(int i = 0;i<chars.size();i++){\\n            v[chars[i]-\\'a\\'] =vals[i]; \\n        }\\n        vector<int> sd(s.size());\\n        for(int i = 0;i<s.size();i++){\\n            sd[i] = v[s[i]-\\'a\\'];\\n        }\\n        int ans = 0;\\n        int sum = 0;\\n        for(int i = 0;i<sd.size();i++){\\n            sum+=sd[i];\\n            if(sum<0){\\n                sum = 0;\\n            }\\n            ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581173,
                "title": "java-simple-solution-hashmap-sum-90-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> lettersCost = new HashMap<>();\\n        for (int i = 0; i < 26; i++) {\\n            char letter = (char) (97 + i);\\n            int indexOfLetter = chars.indexOf(letter);\\n            if (indexOfLetter != -1) {\\n                lettersCost.put(letter, vals[indexOfLetter]);\\n            } else {\\n                lettersCost.put(letter, i + 1);\\n            }\\n        }\\n\\n        int maxCost = lettersCost.get(s.charAt(0));\\n        int currentSum = maxCost;\\n        for (int i = 1; i < s.length(); i++) {\\n            int currentCost = lettersCost.get(s.charAt(i));\\n            currentSum = Math.max(currentCost, currentSum + currentCost);\\n            maxCost = Math.max(maxCost, currentSum);\\n        }\\n        \\n        return Math.max(0, maxCost);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> lettersCost = new HashMap<>();\\n        for (int i = 0; i < 26; i++) {\\n            char letter = (char) (97 + i);\\n            int indexOfLetter = chars.indexOf(letter);\\n            if (indexOfLetter != -1) {\\n                lettersCost.put(letter, vals[indexOfLetter]);\\n            } else {\\n                lettersCost.put(letter, i + 1);\\n            }\\n        }\\n\\n        int maxCost = lettersCost.get(s.charAt(0));\\n        int currentSum = maxCost;\\n        for (int i = 1; i < s.length(); i++) {\\n            int currentCost = lettersCost.get(s.charAt(i));\\n            currentSum = Math.max(currentCost, currentSum + currentCost);\\n            maxCost = Math.max(maxCost, currentSum);\\n        }\\n        \\n        return Math.max(0, maxCost);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537906,
                "title": "kadane-s-algorithm-python-easy-solution-9-lines",
                "content": "# Intuition\\nThis is basically Kadane\\'s algorithm (subarray with the gratest value), but we have letters instead of numbers. We need to map those letters to their values.\\n\\n# Approach\\n- We create a dictionary with the letters and their values.\\n- Inside Kadane\\'s loop we need to calculate the value of the letter:\\n    - If the letter is in the dictionary, get the value from it.\\n    - Otherwise, get the position of the letter in the alphabet(`ord(c) - ord(\\'a\\') + 1`).\\n- Return the greatest value found.\\n\\n# Complexity\\n- Time complexity: $$O(s.length)$$\\n\\n- Space complexity: $$O(chars.length)$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = {}\\n        for c, v in zip(chars, vals):\\n            d[c] = v\\n\\n        # KADANES\\n        maxSum = currSum = 0\\n\\n        for c in s:\\n            val = d[c] if c in d else ord(c) - ord(\\'a\\') + 1\\n            currSum = max(currSum + val, 0)\\n            maxSum = max(maxSum, currSum)\\n\\n        return maxSum\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = {}\\n        for c, v in zip(chars, vals):\\n            d[c] = v\\n\\n        # KADANES\\n        maxSum = currSum = 0\\n\\n        for c in s:\\n            val = d[c] if c in d else ord(c) - ord(\\'a\\') + 1\\n            currSum = max(currSum + val, 0)\\n            maxSum = max(maxSum, currSum)\\n\\n        return maxSum\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521386,
                "title": "elixir-solution-use-enum-reduce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 428ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 82.3MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec maximum_cost_substring(s :: String.t, chars :: String.t, vals :: [integer]) :: integer\\n  def maximum_cost_substring(s, chars, vals) do\\n    char_dict = Enum.reduce(String.to_charlist(chars), {0, %{}}, fn ch, {i, dic} ->\\n      {i + 1, Map.put(dic, ch, Enum.at(vals, i))}\\n    end) |> elem(1)\\n\\n    String.to_charlist(s) |>\\n    Enum.reduce({0, 0}, fn ch, {max_cost, curr_cost} ->\\n      curr_cost = curr_cost + Map.get(char_dict, ch, ch - ?a + 1)\\n      curr_cost =\\n        if curr_cost < 0 do\\n          0\\n        else\\n          curr_cost\\n        end\\n      {max(curr_cost, max_cost), curr_cost}\\n      end) |> elem(0)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec maximum_cost_substring(s :: String.t, chars :: String.t, vals :: [integer]) :: integer\\n  def maximum_cost_substring(s, chars, vals) do\\n    char_dict = Enum.reduce(String.to_charlist(chars), {0, %{}}, fn ch, {i, dic} ->\\n      {i + 1, Map.put(dic, ch, Enum.at(vals, i))}\\n    end) |> elem(1)\\n\\n    String.to_charlist(s) |>\\n    Enum.reduce({0, 0}, fn ch, {max_cost, curr_cost} ->\\n      curr_cost = curr_cost + Map.get(char_dict, ch, ch - ?a + 1)\\n      curr_cost =\\n        if curr_cost < 0 do\\n          0\\n        else\\n          curr_cost\\n        end\\n      {max(curr_cost, max_cost), curr_cost}\\n      end) |> elem(0)\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3519584,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i = 0; i < chars.length(); i++)\\n        {\\n            map.put(chars.charAt(i), vals[i]);\\n        }\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            char c = s.charAt(i);\\n            if(!map.containsKey(c))\\n            {\\n                map.put(c, c - \\'a\\' + 1);\\n            }\\n        }\\n        int maxi = Integer.MIN_VALUE;\\n        int val = -(int)1e9;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            char r = s.charAt(i);\\n            val = val + map.get(r);\\n            maxi = Math.max(maxi, Math.max(val, map.get(r)));\\n            if(map.get(r) > val)\\n            {\\n                val = map.get(r);\\n            }\\n        }\\n        \\n        return maxi < 0 ? 0 : maxi;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i = 0; i < chars.length(); i++)\\n        {\\n            map.put(chars.charAt(i), vals[i]);\\n        }\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            char c = s.charAt(i);\\n            if(!map.containsKey(c))\\n            {\\n                map.put(c, c - \\'a\\' + 1);\\n            }\\n        }\\n        int maxi = Integer.MIN_VALUE;\\n        int val = -(int)1e9;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            char r = s.charAt(i);\\n            val = val + map.get(r);\\n            maxi = Math.max(maxi, Math.max(val, map.get(r)));\\n            if(map.get(r) > val)\\n            {\\n                val = map.get(r);\\n            }\\n        }\\n        \\n        return maxi < 0 ? 0 : maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515026,
                "title": "java-kadane-s-algo-variation-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private int getVal(char c, Map<Character, Integer> map) {\\n        if(map.containsKey(c)){\\n            return map.get(c);\\n        }\\n        else {\\n            return c - \\'a\\' + 1;\\n        }\\n    }\\n   public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int n = s.length();\\n        for(int i=0;i<chars.length();i++) {\\n            char c = chars.charAt(i);\\n            map.put(c, vals[i]);\\n        }\\n        int maxcosttillhere = 0, maxcosttillnow = 0;\\n        for(int i=0;i<n;i++) {\\n            char c = s.charAt(i);\\n            int val = getVal(c, map);\\n            maxcosttillhere += val;\\n            if( maxcosttillhere <= 0) {\\n                maxcosttillhere = 0;\\n            }\\n            else if(maxcosttillhere > maxcosttillnow) {\\n                maxcosttillnow = maxcosttillhere;\\n            }\\n        }\\n        return maxcosttillnow;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private int getVal(char c, Map<Character, Integer> map) {\\n        if(map.containsKey(c)){\\n            return map.get(c);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3511799,
                "title": "kadane-algo-java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        \\n        HashMap<Character,Integer> map = new HashMap<>();\\n        int score=0;\\n        int max=0;\\n        for(int i=0;i<chars.length();i++)\\n            map.put(chars.charAt(i),vals[i]);\\n        for(int i=0;i<s.length();i++)\\n        {\\n           \\n            if(map.containsKey(s.charAt(i)))\\n            {\\n                score=score+ map.get(s.charAt(i));\\n                \\n                if(score<0){\\n               \\n                score=0;\\n                }\\n            }\\n            else \\n            score=score + s.charAt(i)-\\'a\\'+1; \\n              max= Math.max(score,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        \\n        HashMap<Character,Integer> map = new HashMap<>();\\n        int score=0;\\n        int max=0;\\n        for(int i=0;i<chars.length();i++)\\n            map.put(chars.charAt(i),vals[i]);\\n        for(int i=0;i<s.length();i++)\\n        {\\n           \\n            if(map.containsKey(s.charAt(i)))\\n            {\\n                score=score+ map.get(s.charAt(i));\\n                \\n                if(score<0){\\n               \\n                score=0;\\n                }\\n            }\\n            else \\n            score=score + s.charAt(i)-\\'a\\'+1; \\n              max= Math.max(score,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505187,
                "title": "best-java-sollution-kadane-s-hashmap",
                "content": "\\n```\\nclass Solution {\\n    //static int k =0;\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int n = s.length();\\n        int ansarr[] = new int[n];\\n        \\n        HashMap<Character, Integer> hm  = new HashMap<>();\\n        for(int i =0; i<chars.length();i++)\\n        {\\n            hm.put(chars.charAt(i), vals[i]);\\n        }\\n        \\n        for(int j =0;j<n;j++)\\n        {\\n            if(hm.containsKey(s.charAt(j)))\\n            {\\n                ansarr[j] = hm.get(s.charAt(j));\\n            }\\n            \\n            else\\n            {\\n                ansarr[j] = s.charAt(j)-96;\\n            }\\n        }\\n       int locMax =0;\\n       int glbMax = Integer.MIN_VALUE;\\n        \\n        for(int k=0;k<n;k++)\\n        {\\n            locMax = Math.max(ansarr[k], locMax+ansarr[k]);\\n            glbMax = Math.max(locMax, glbMax);\\n        }\\n        \\n        return glbMax <0 ? 0:glbMax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //static int k =0;\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int n = s.length();\\n        int ansarr[] = new int[n];\\n        \\n        HashMap<Character, Integer> hm  = new HashMap<>();\\n        for(int i =0; i<chars.length();i++)\\n        {\\n            hm.put(chars.charAt(i), vals[i]);\\n        }\\n        \\n        for(int j =0;j<n;j++)\\n        {\\n            if(hm.containsKey(s.charAt(j)))\\n            {\\n                ansarr[j] = hm.get(s.charAt(j));\\n            }\\n            \\n            else\\n            {\\n                ansarr[j] = s.charAt(j)-96;\\n            }\\n        }\\n       int locMax =0;\\n       int glbMax = Integer.MIN_VALUE;\\n        \\n        for(int k=0;k<n;k++)\\n        {\\n            locMax = Math.max(ansarr[k], locMax+ansarr[k]);\\n            glbMax = Math.max(locMax, glbMax);\\n        }\\n        \\n        return glbMax <0 ? 0:glbMax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504275,
                "title": "python3-o-n-presum",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        costs = list(range(1, 27))\\n        for c, v in zip(chars, vals): costs[ord(c) - ord(\\'a\\')] = v\\n        presum = [0] * (len(s) + 1)\\n        for i in range(len(s)): presum[i + 1] = presum[i] + costs[ord(s[i]) - ord(\\'a\\')]\\n        ans, curmax = max(presum), float(\\'-inf\\')\\n        for i in range(len(s) - 1, -1, -1):\\n            ans = max(ans, curmax - presum[i + 1])\\n            curmax = max(curmax, presum[i + 1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        costs = list(range(1, 27))\\n        for c, v in zip(chars, vals): costs[ord(c) - ord(\\'a\\')] = v\\n        presum = [0] * (len(s) + 1)\\n        for i in range(len(s)): presum[i + 1] = presum[i] + costs[ord(s[i]) - ord(\\'a\\')]\\n        ans, curmax = max(presum), float(\\'-inf\\')\\n        for i in range(len(s) - 1, -1, -1):\\n            ans = max(ans, curmax - presum[i + 1])\\n            curmax = max(curmax, presum[i + 1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503644,
                "title": "easy-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        s=list(s)\\n        x=list(set(s))\\n        d={}\\n        chars=list(chars)\\n        for i in range(len(x)):\\n            if x[i] in chars:\\n                d[x[i]]=vals[chars.index(x[i])]\\n            else:\\n                d[x[i]]=ord(x[i])-96\\n        for i in range(len(s)):\\n            s[i]=d[s[i]]\\n        def maxSubArraySum(a, size):\\n            max_so_far = 0\\n            max_ending_here = 0\\n        \\n            for i in range(0, size):\\n                max_ending_here = max_ending_here + a[i]\\n                if (max_so_far < max_ending_here):\\n                    max_so_far = max_ending_here\\n        \\n                if max_ending_here < 0:\\n                    max_ending_here = 0\\n            return max_so_far\\n        return maxSubArraySum(s, len(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        s=list(s)\\n        x=list(set(s))\\n        d={}\\n        chars=list(chars)\\n        for i in range(len(x)):\\n            if x[i] in chars:\\n                d[x[i]]=vals[chars.index(x[i])]\\n            else:\\n                d[x[i]]=ord(x[i])-96\\n        for i in range(len(s)):\\n            s[i]=d[s[i]]\\n        def maxSubArraySum(a, size):\\n            max_so_far = 0\\n            max_ending_here = 0\\n        \\n            for i in range(0, size):\\n                max_ending_here = max_ending_here + a[i]\\n                if (max_so_far < max_ending_here):\\n                    max_so_far = max_ending_here\\n        \\n                if max_ending_here < 0:\\n                    max_ending_here = 0\\n            return max_so_far\\n        return maxSubArraySum(s, len(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496291,
                "title": "c-kadane-algorithm-maximum-sum-substring-optimized-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKadane Algorithm \\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<chars.size();i++)\\n        {\\n            mp[chars[i]]=vals[i];\\n        }\\n        \\n        int n=s.length();\\n        int maxc=0,cost=0;\\n\\n        // kadane\\'s algorithm\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            if(mp.find(s[i])!=mp.end())\\n            {\\n                c=mp[s[i]];\\n            }\\n            else\\n            {\\n                c=s[i]-96;\\n            }\\n            cost+=c;\\n            if(cost<0)\\n                cost=0;\\n            maxc=max(maxc,cost);\\n        }\\n        return maxc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<chars.size();i++)\\n        {\\n            mp[chars[i]]=vals[i];\\n        }\\n        \\n        int n=s.length();\\n        int maxc=0,cost=0;\\n\\n        // kadane\\'s algorithm\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            if(mp.find(s[i])!=mp.end())\\n            {\\n                c=mp[s[i]];\\n            }\\n            else\\n            {\\n                c=s[i]-96;\\n            }\\n            cost+=c;\\n            if(cost<0)\\n                cost=0;\\n            maxc=max(maxc,cost);\\n        }\\n        return maxc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490336,
                "title": "creating-dict-from-alphabet-and-update-with-chars-kadane",
                "content": "# Intuition\\nMy solution is not that much different, except in the beginning i make a full dict and only replace values specified in chars/vals arrays. \\n1. create 1..26 array with alphabet\\n2. update the specific chars with vals if present\\n3. this part - kadane algo i did not get myself.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) - run thru the string s once\\n\\n- Space complexity:\\nO(n) - cuz we use dict here to store costs\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n\\n\\n        cost1 = dict(zip(chars, vals))\\n\\n        ind = [i for i in range(1, 27)]\\n        val = string.ascii_lowercase\\n\\n        cost = dict(zip(val, ind))\\n\\n        for k, v in cost1.items():\\n            if k in cost:\\n                cost[k] = v\\n\\n        max_cost = 0\\n        cur_cost = 0\\n        for i in range(len(s)):\\n\\n            cur_cost += cost[s[i]]\\n\\n            if cur_cost < 0:\\n                cur_cost = 0\\n            max_cost = max(cur_cost, max_cost)\\n        print(max_cost)\\n        return max_cost\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n\\n\\n        cost1 = dict(zip(chars, vals))\\n\\n        ind = [i for i in range(1, 27)]\\n        val = string.ascii_lowercase\\n\\n        cost = dict(zip(val, ind))\\n\\n        for k, v in cost1.items():\\n            if k in cost:\\n                cost[k] = v\\n\\n        max_cost = 0\\n        cur_cost = 0\\n        for i in range(len(s)):\\n\\n            cur_cost += cost[s[i]]\\n\\n            if cur_cost < 0:\\n                cur_cost = 0\\n            max_cost = max(cur_cost, max_cost)\\n        print(max_cost)\\n        return max_cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480377,
                "title": "simple-greedy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGreedy Approach\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mc[150];\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int i, j, k, l, m, ans=0, mx=0, x;\\n\\n        for(i=0; i<chars.length(); i++) mc[chars[i]]=i+1;\\n\\n        for(i=0; i<s.length(); i++) {\\n            if(mc[s[i]]) x = vals[mc[s[i]]-1];\\n            else x = s[i]-\\'a\\'+1;\\n\\n            if((ans+x)>0) ans+=x;\\n            else ans=0;\\n\\n            mx = max(mx, ans);\\n        }\\n\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mc[150];\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int i, j, k, l, m, ans=0, mx=0, x;\\n\\n        for(i=0; i<chars.length(); i++) mc[chars[i]]=i+1;\\n\\n        for(i=0; i<s.length(); i++) {\\n            if(mc[s[i]]) x = vals[mc[s[i]]-1];\\n            else x = s[i]-\\'a\\'+1;\\n\\n            if((ans+x)>0) ans+=x;\\n            else ans=0;\\n\\n            mx = max(mx, ans);\\n        }\\n\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476121,
                "title": "c-solution-easy-80",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int res = 0,temp = 0;\\n        for(char x : s){\\n            if(chars.find(x) == string::npos){\\n                temp += x-96;\\n            }\\n            else{\\n                temp += vals[chars.find(x)];\\n            }\\n            if(temp > 0){\\n                res = max(res,temp);\\n            }\\n            else{\\n                temp = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int res = 0,temp = 0;\\n        for(char x : s){\\n            if(chars.find(x) == string::npos){\\n                temp += x-96;\\n            }\\n            else{\\n                temp += vals[chars.find(x)];\\n            }\\n            if(temp > 0){\\n                res = max(res,temp);\\n            }\\n            else{\\n                temp = 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464415,
                "title": "optimizing-substring-cost-calculations-with-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is like Kadane\\'s Algorithm\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an array values with the default values for each character (1 for \\'a\\', 2 for \\'b\\', etc.).\\n2. Update the values of the characters in chars using the array vals.\\n3. Initialize two variables cur and max to 0. \\n4. Iterate through each character c in the string s.\\n5. Compute the value of c using the array values.\\n6. Update cur using Kadane\\'s algorithm: cur = Math.max(cur + value, value), where value is the value of the current character.\\n7. Update max using max = Math.max(cur, max).\\n8. Return max.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26) or O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int maximumCostSubstring(String s, String chars, int[] vals) \\n    {\\n        int[] values = new int[26];\\n        for(int i=0; i<26; i++)\\n            values[i] = i + 1;\\n        int n = vals.length;\\n        for(int i=0; i<n; i++)\\n            values[chars.charAt(i) - \\'a\\'] = vals[i];\\n        int cur = 0;\\n        int max = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            cur = Math.max(cur + values[c - \\'a\\'], values[c - \\'a\\']);\\n            max = Math.max(cur, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int maximumCostSubstring(String s, String chars, int[] vals) \\n    {\\n        int[] values = new int[26];\\n        for(int i=0; i<26; i++)\\n            values[i] = i + 1;\\n        int n = vals.length;\\n        for(int i=0; i<n; i++)\\n            values[chars.charAt(i) - \\'a\\'] = vals[i];\\n        int cur = 0;\\n        int max = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            cur = Math.max(cur + values[c - \\'a\\'], values[c - \\'a\\']);\\n            max = Math.max(cur, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463346,
                "title": "javascript-kadane-s-algorithm",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(26)$$\\n\\n# Code\\n```\\nvar maximumCostSubstring = function(s, chars, vals) {\\n    let max = 0, ans = 0, values = Array.from({ length: 26 }, (_, i) => i + 1);\\n    for (let i = 0; i < chars.length; i++)\\n        values[chars.charCodeAt(i) - 97] = vals[i];\\n\\n    for (const char of s) {\\n        max = Math.max(0, max + values[char.charCodeAt() - 97]);\\n        ans = Math.max(ans, max)\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\nvar maximumCostSubstring = function(s, chars, vals) {\\n    let max = 0, ans = 0, values = Array.from({ length: 26 }, (_, i) => i + 1);\\n    for (let i = 0; i < chars.length; i++)\\n        values[chars.charCodeAt(i) - 97] = vals[i];\\n\\n    for (const char of s) {\\n        max = Math.max(0, max + values[char.charCodeAt() - 97]);\\n        ans = Math.max(ans, max)\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3454362,
                "title": "c-dp",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int cost[26] = {0};\\n        for (int i = 0; i < 26; i++) {\\n            cost[i] = i + 1;\\n        }\\n        for (int i = 0; i < chars.size(); i++) {\\n            cost[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        // \\u53D8\\u6210\\u6700\\u5927\\u5B50\\u6570\\u7EC4\\u548C\\n        int n = s.length();\\n        vector<int> dp(n, 0);\\n        dp[0] = cost[s[0] - \\'a\\'];\\n        int ans = max(dp[0], 0);\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = max(cost[s[i] - \\'a\\'], cost[s[i] - \\'a\\'] + dp[i - 1]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int cost[26] = {0};\\n        for (int i = 0; i < 26; i++) {\\n            cost[i] = i + 1;\\n        }\\n        for (int i = 0; i < chars.size(); i++) {\\n            cost[chars[i] - \\'a\\'] = vals[i];\\n        }\\n        // \\u53D8\\u6210\\u6700\\u5927\\u5B50\\u6570\\u7EC4\\u548C\\n        int n = s.length();\\n        vector<int> dp(n, 0);\\n        dp[0] = cost[s[0] - \\'a\\'];\\n        int ans = max(dp[0], 0);\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = max(cost[s[i] - \\'a\\'], cost[s[i] - \\'a\\'] + dp[i - 1]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452555,
                "title": "kadaen",
                "content": "```\\nint n=s.length();\\n        HashMap<Character,Integer>map= new HashMap<>();\\n\\t\\t\\n\\t\\t//put all the character and its val in map\\n\\t\\t\\n        for(int i=0;i<c.length();i++)\\n        {\\n            map.put(c.charAt(i),vals[i]);\\n        }\\n        int max=0;\\n        int sum=0;\\n\\t\\t\\n\\t\\t//use kadane algo for finding the maximim cost\\n        for(int i=0;i<n;i++)\\n        {\\n            if(map.containsKey(s.charAt(i)))\\n            {\\n                 sum= sum+map.get(s.charAt(i));\\n            }\\n           if(!map.containsKey(s.charAt(i)))\\n           {\\n               sum=(sum+((s.charAt(i)-\\'a\\')+1));\\n           }\\n            if(max<sum)\\n            {\\n                max=sum;\\n            }\\n            if(sum<0)\\n            {\\n                sum=0;\\n            }\\n        }\\n        return max;    \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint n=s.length();\\n        HashMap<Character,Integer>map= new HashMap<>();\\n\\t\\t\\n\\t\\t//put all the character and its val in map\\n\\t\\t\\n        for(int i=0;i<c.length();i++)\\n        {\\n            map.put(c.charAt(i),vals[i]);\\n        }\\n        int max=0;\\n        int sum=0;\\n\\t\\t\\n\\t\\t//use kadane algo for finding the maximim cost\\n        for(int i=0;i<n;i++)\\n        {\\n            if(map.containsKey(s.charAt(i)))\\n            {\\n                 sum= sum+map.get(s.charAt(i));\\n            }\\n           if(!map.containsKey(s.charAt(i)))\\n           {\\n               sum=(sum+((s.charAt(i)-\\'a\\')+1));\\n           }\\n            if(max<sum)\\n            {\\n                max=sum;\\n            }\\n            if(sum<0)\\n            {\\n                sum=0;\\n            }\\n        }\\n        return max;    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3448448,
                "title": "o-len-s-time-o-1-space-kadane-s-algorithm-easy",
                "content": "# Intuition\\nWe need to find array sub-sequence with the greatest sum, where value at each index is defined as per rules, either char number or value from chars array. We can use Kadane\\'s algorithm to compute that fast. \\n\\n# Approach\\ncompute value for each char, this is O(len(chars)). \\ntransform starting s to the array of in values\\nusing Kadane\\'s algorithm compute greatest sum of sub-sequence in array in a one scan\\n\\n# Complexity\\n- Time complexity:\\nO(1) pre-compute initi values for each char\\nO(len(vals)) update values for chars in vals, upper bound is 26 (max different englidh letters)\\nO(len(s)) compute max sum of char values\\n\\nO(len(s)) - total complexity\\n\\n- Space complexity:\\nO(1) - array of char values \\nO(1) - Kadane\\'s algorithm uses few variables to keep state\\n\\nO(1) - total\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int[] counts = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            counts[i] = i + 1;\\n        }\\n        for (int i = 0; i < chars.length(); i++) {\\n            counts[chars.charAt(i) - \\'a\\'] = vals[i];\\n        }\\n        \\n        int local = 0, global = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            local = Math.max(local + counts[s.charAt(i) - \\'a\\'], counts[s.charAt(i) - \\'a\\']);\\n            global = Math.max(global, local);\\n        }\\n        return global;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int[] counts = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            counts[i] = i + 1;\\n        }\\n        for (int i = 0; i < chars.length(); i++) {\\n            counts[chars.charAt(i) - \\'a\\'] = vals[i];\\n        }\\n        \\n        int local = 0, global = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            local = Math.max(local + counts[s.charAt(i) - \\'a\\'], counts[s.charAt(i) - \\'a\\']);\\n            global = Math.max(global, local);\\n        }\\n        return global;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437638,
                "title": "easiest-solution-in-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        vector<int> values;\\n        \\n        for(auto a : s){\\n            bool flag = false;\\n            for(int j = 0; j <chars.size();j++){\\n                if(a==chars[j]){\\n                    flag = true;\\n                    values.push_back(vals[j]);\\n                }\\n            }\\n            if(flag == false){\\n                \\n                values.push_back(int(a)-96);\\n                \\n            }\\n        }\\n        \\n      \\n        \\n        int maxx = INT_MIN;\\n        int maxx2 = 0;\\n\\n        for(int i = 0; i<values.size();i++){\\n\\n            maxx2 = maxx2+values[i];\\n            if(maxx<maxx2){\\n                maxx = maxx2;\\n            }\\n            if(maxx2<0){\\n                maxx2 = 0;\\n            }\\n\\n\\n        }\\n        if(maxx<0){\\n            return 0;\\n        }\\n        \\n        return maxx;\\n        \\n        \\n        \\n        \\n    \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        vector<int> values;\\n        \\n        for(auto a : s){\\n            bool flag = false;\\n            for(int j = 0; j <chars.size();j++){\\n                if(a==chars[j]){\\n                    flag = true;\\n                    values.push_back(vals[j]);\\n                }\\n            }\\n            if(flag == false){\\n                \\n                values.push_back(int(a)-96);\\n                \\n            }\\n        }\\n        \\n      \\n        \\n        int maxx = INT_MIN;\\n        int maxx2 = 0;\\n\\n        for(int i = 0; i<values.size();i++){\\n\\n            maxx2 = maxx2+values[i];\\n            if(maxx<maxx2){\\n                maxx = maxx2;\\n            }\\n            if(maxx2<0){\\n                maxx2 = 0;\\n            }\\n\\n\\n        }\\n        if(maxx<0){\\n            return 0;\\n        }\\n        \\n        return maxx;\\n        \\n        \\n        \\n        \\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437309,
                "title": "simple-kadanes-algo-implementation",
                "content": "# Intuition\\nKadane Algo \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int>v(26,0);\\n        for(int i=0;i<26;i++)\\n            v[i]=i+1;\\n        for(int i=0;i<vals.size();i++)\\n            v[chars[i]-\\'a\\']=vals[i];\\n        int currsum=0,ans=INT_MIN;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            currsum+=v[s[i]-\\'a\\'];\\n            ans=ans<currsum?currsum:ans;\\n            if(currsum<0)\\n                currsum=0;\\n        }\\n        return ans>0?ans:0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int>v(26,0);\\n        for(int i=0;i<26;i++)\\n            v[i]=i+1;\\n        for(int i=0;i<vals.size();i++)\\n            v[chars[i]-\\'a\\']=vals[i];\\n        int currsum=0,ans=INT_MIN;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            currsum+=v[s[i]-\\'a\\'];\\n            ans=ans<currsum?currsum:ans;\\n            if(currsum<0)\\n                currsum=0;\\n        }\\n        return ans>0?ans:0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435699,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> m;\\n        for(int i=97,j=1;i<=122;i++,j++) m[i]=j;\\n        for(int i=0;i<vals.size();i++) m[chars[i]]=vals[i];\\n        int ans=0;\\n        int curr_sum=0;\\n        for(auto i : s){\\n            curr_sum+=m[i];\\n            if(curr_sum<0) curr_sum=0;\\n            if(curr_sum>0) ans=max(ans,curr_sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        map<char,int> m;\\n        for(int i=97,j=1;i<=122;i++,j++) m[i]=j;\\n        for(int i=0;i<vals.size();i++) m[chars[i]]=vals[i];\\n        int ans=0;\\n        int curr_sum=0;\\n        for(auto i : s){\\n            curr_sum+=m[i];\\n            if(curr_sum<0) curr_sum=0;\\n            if(curr_sum>0) ans=max(ans,curr_sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422930,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func maximumCostSubstring(_ s: String, _ chars: String, _ vals: [Int]) -> Int {\\n        \\n        func i(_ c: Character) -> Int {\\n            Int(c.asciiValue! - Character(\"a\").asciiValue!)\\n        }\\n\\n        var alphaCosts = (i(\"a\")...i(\"z\")).map { $0 + 1 }\\n\\n        for (c, v) in zip(chars, vals) {\\n            alphaCosts[i(c)] = v\\n        }\\n\\n        let costs = s.map { alphaCosts[i($0)] }\\n\\n        var best = 0\\n        var cur = 0\\n\\n        for c in costs {\\n            cur = max(0, cur + c)\\n            best = max(best, cur)\\n        }\\n\\n        return best\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumCostSubstring(_ s: String, _ chars: String, _ vals: [Int]) -> Int {\\n        \\n        func i(_ c: Character) -> Int {\\n            Int(c.asciiValue! - Character(\"a\").asciiValue!)\\n        }\\n\\n        var alphaCosts = (i(\"a\")...i(\"z\")).map { $0 + 1 }\\n\\n        for (c, v) in zip(chars, vals) {\\n            alphaCosts[i(c)] = v\\n        }\\n\\n        let costs = s.map { alphaCosts[i($0)] }\\n\\n        var best = 0\\n        var cur = 0\\n\\n        for c in costs {\\n            cur = max(0, cur + c)\\n            best = max(best, cur)\\n        }\\n\\n        return best\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417359,
                "title": "easy-and-fast-c-solution-with-explanation",
                "content": "# Intuition\\nInitially, we need to calculate the cost of each character in the given string **s**. We can do this by iterating through the string and checking if the character is in the **chars** string. If it is, we use the corresponding value from the **vals** array, otherwise, we use the character\\'s position in the alphabet as its value. Then, we can iterate through the string, maintaining a running sum of the costs and resetting it to 0 if it becomes negative, keeping track of the maximum cost we have seen so far.\\n\\n# Approach\\n1. Create a dictionary **charValues** to store the values of characters in the **chars** string.\\n2. Iterate through the **chars** string and add each character and its corresponding value from the **vals** array to the dictionary.\\n3. Initialize variables **maxCost** and **currentCost** to 0.\\n4. Iterate through the string **s**:\\n- Calculate the value of the current character using the dictionary or its position in the alphabet.\\n- Add the character value to **currentCost**.\\n- If **currentCost** is negative, set it to 0.\\n- Update **maxCost** with the maximum value between **maxCost** and **currentCost**.\\n6. Return **maxCost**.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where $$n$$ is the length of the input string **s**. We need to iterate through the string once to calculate the cost of each character and once more to find the maximum cost among all substrings.\\n\\n- Space complexity: $$O(m)$$, where $$m$$ is the length of the input string **chars**. We need to store the values of characters in the **chars** string using a dictionary.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumCostSubstring(string s, string chars, int[] vals) {\\n        int n = s.Length;\\n        int maxCost = 0;\\n        int currentCost = 0;\\n        \\n        Dictionary<char, int> charValues = new Dictionary<char, int>();\\n        for (int i = 0; i < chars.Length; i++) {\\n            charValues.Add(chars[i], vals[i]);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            char currentChar = s[i];\\n            int charValue;\\n\\n            if (charValues.ContainsKey(currentChar)) {\\n                charValue = charValues[currentChar];\\n            } else {\\n                charValue = currentChar - \\'a\\' + 1;\\n            }\\n\\n            currentCost += charValue;\\n            if (currentCost < 0) {\\n                currentCost = 0;\\n            }\\n            maxCost = Math.Max(maxCost, currentCost);\\n        }\\n\\n        return maxCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumCostSubstring(string s, string chars, int[] vals) {\\n        int n = s.Length;\\n        int maxCost = 0;\\n        int currentCost = 0;\\n        \\n        Dictionary<char, int> charValues = new Dictionary<char, int>();\\n        for (int i = 0; i < chars.Length; i++) {\\n            charValues.Add(chars[i], vals[i]);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            char currentChar = s[i];\\n            int charValue;\\n\\n            if (charValues.ContainsKey(currentChar)) {\\n                charValue = charValues[currentChar];\\n            } else {\\n                charValue = currentChar - \\'a\\' + 1;\\n            }\\n\\n            currentCost += charValue;\\n            if (currentCost < 0) {\\n                currentCost = 0;\\n            }\\n            maxCost = Math.Max(maxCost, currentCost);\\n        }\\n\\n        return maxCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415428,
                "title": "100-fast-c-rolling-sum-if-negative-then-shift-to-new-index-start-sum-0",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> val(26,0);\\n        for(int i =0; i <26; i++)\\n        {\\n            val[i] = i+1;\\n        }\\n        int j = 0;\\n        for(auto i:chars)\\n        {\\n            val[i-\\'a\\'] = vals[j];\\n            j++;\\n        }\\n        int ma = 0;\\n        int sum = 0;\\n        for(int k = 0; k < s.size();k++ )\\n        {\\n            int i,sum = 0;\\n        for(i =k; i < s.size(); i++)\\n        {\\n            sum+=val[s[i]- \\'a\\'];\\n            ma = max(sum,ma);\\n            if(sum < 0)  break;\\n        }\\n        k = i;\\n        }\\n        return ma;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> val(26,0);\\n        for(int i =0; i <26; i++)\\n        {\\n            val[i] = i+1;\\n        }\\n        int j = 0;\\n        for(auto i:chars)\\n        {\\n            val[i-\\'a\\'] = vals[j];\\n            j++;\\n        }\\n        int ma = 0;\\n        int sum = 0;\\n        for(int k = 0; k < s.size();k++ )\\n        {\\n            int i,sum = 0;\\n        for(i =k; i < s.size(); i++)\\n        {\\n            sum+=val[s[i]- \\'a\\'];\\n            ma = max(sum,ma);\\n            if(sum < 0)  break;\\n        }\\n        k = i;\\n        }\\n        return ma;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404227,
                "title": "easy-c-solution-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to find the maximum cost substring in a given string s by using a character-cost mapping defined by two parallel vectors chars and vals.\\n\\nTo achieve this, the code scans through the string s character by character, and for each character, it checks its corresponding cost in the vals vector. If the character is not present in chars, its cost is assumed to be its ASCII value. Otherwise, its cost is obtained from the vals vector.\\n\\nThe code maintains a running sum of the costs encountered so far and updates the maximum cost encountered during the scan. If the running sum ever becomes negative, it is reset to zero, since a substring with negative cost is not considered.\\n\\nAt the end of the scan, the code returns the maximum cost encountered during the scan, which corresponds to the maximum cost substring.\\n\\n# Complexity\\n- Time complexity: O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = s.size();\\n        int m = chars.size();\\n        vector<int> freq(26,1001);\\n        for(int i=0; i<m; i++){\\n            freq[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        int sum = 0;\\n        int i=0;\\n        int maxCost = 0;\\n        while(i < n){\\n            if(freq[s[i]-\\'a\\'] == 1001){\\n                sum += s[i]-\\'a\\'+1;\\n            }\\n            else if(freq[s[i]-\\'a\\'] != 0){\\n                sum += freq[s[i]-\\'a\\'];\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n            maxCost = max(maxCost,sum);\\n            i++;\\n        }\\n        return maxCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = s.size();\\n        int m = chars.size();\\n        vector<int> freq(26,1001);\\n        for(int i=0; i<m; i++){\\n            freq[chars[i]-\\'a\\'] = vals[i];\\n        }\\n        int sum = 0;\\n        int i=0;\\n        int maxCost = 0;\\n        while(i < n){\\n            if(freq[s[i]-\\'a\\'] == 1001){\\n                sum += s[i]-\\'a\\'+1;\\n            }\\n            else if(freq[s[i]-\\'a\\'] != 0){\\n                sum += freq[s[i]-\\'a\\'];\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n            maxCost = max(maxCost,sum);\\n            i++;\\n        }\\n        return maxCost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403076,
                "title": "python-kadane",
                "content": "Transform the input to an array of costs. Then find the maximum subarray.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        n = len(s)\\n        costs = {}\\n        for i, c in enumerate(chars):\\n            costs[c] = vals[i]\\n        \\n        def cost(x):\\n            return costs[x] if x in costs else ord(x) - 96\\n\\n        nums = [cost(c) for c in s]\\n        res = 0\\n        curr = 0\\n        for n in nums:\\n            if curr < 0:\\n                curr = 0\\n            curr += n\\n            res = max(res, curr)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        n = len(s)\\n        costs = {}\\n        for i, c in enumerate(chars):\\n            costs[c] = vals[i]\\n        \\n        def cost(x):\\n            return costs[x] if x in costs else ord(x) - 96\\n\\n        nums = [cost(c) for c in s]\\n        res = 0\\n        curr = 0\\n        for n in nums:\\n            if curr < 0:\\n                curr = 0\\n            curr += n\\n            res = max(res, curr)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397572,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculate the value for each character and then perform max subbarray to calculate the maximum sum. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        arr = [-1002] * 26\\n        maxval = 0\\n        prev = 0\\n        q = {}\\n        for i in range(len(chars)):\\n            q[chars[i]] = i\\n        for i in range(len(s)):\\n            t = ord(s[i]) - ord(\\'a\\')\\n            if arr[t] == -1002:\\n                if s[i] not in q:\\n                    arr[t] = t + 1    \\n                else:\\n                    arr[t] = vals[q[s[i]]]\\n            if i == 0:\\n                maxval = max(maxval, arr[t])\\n                prev = maxval\\n            else:\\n                x = max(prev + arr[t], 0)\\n                maxval = max(maxval, x)\\n                prev = x\\n        return maxval\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        arr = [-1002] * 26\\n        maxval = 0\\n        prev = 0\\n        q = {}\\n        for i in range(len(chars)):\\n            q[chars[i]] = i\\n        for i in range(len(s)):\\n            t = ord(s[i]) - ord(\\'a\\')\\n            if arr[t] == -1002:\\n                if s[i] not in q:\\n                    arr[t] = t + 1    \\n                else:\\n                    arr[t] = vals[q[s[i]]]\\n            if i == 0:\\n                maxval = max(maxval, arr[t])\\n                prev = maxval\\n            else:\\n                x = max(prev + arr[t], 0)\\n                maxval = max(maxval, x)\\n                prev = x\\n        return maxval\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397083,
                "title": "c-dp-solution",
                "content": "Its kaden\\'s algorithm.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> res; \\n        unordered_map<char,int> mpp; \\n        char c = \\'a\\';\\n        int ziz = 1; \\n        while(c <= \\'z\\'){\\n            mpp[c] = ziz++; \\n            ++c; \\n        }\\n        for(int i = 0 ; i < vals.size() ; ++i){\\n            char curr = chars[i]; \\n            mpp[curr] = vals[i]; \\n        }\\n        for(int i = 0 ; i < s.length(); ++i){\\n            char curr = s[i]; \\n            int val = mpp[curr] ; \\n            res.push_back(val); \\n        }\\n        for(auto x : res) cout << x << \" \"; \\n        cout << endl;\\n        int n = int(res.size()); \\n        int dp[n]; \\n        memset(dp , 0 , sizeof dp); \\n        dp[0] = res[0]; \\n        int maxx = dp[0]; \\n        for(int i = 1 ; i < s.length(); ++i){\\n            dp[i] = max(res[i], dp[i-1] + res[i]); \\n            maxx = max(maxx , dp[i]); \\n        }\\n        maxx = max(0 , maxx); \\n        return maxx; \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> res; \\n        unordered_map<char,int> mpp; \\n        char c = \\'a\\';\\n        int ziz = 1; \\n        while(c <= \\'z\\'){\\n            mpp[c] = ziz++; \\n            ++c; \\n        }\\n        for(int i = 0 ; i < vals.size() ; ++i){\\n            char curr = chars[i]; \\n            mpp[curr] = vals[i]; \\n        }\\n        for(int i = 0 ; i < s.length(); ++i){\\n            char curr = s[i]; \\n            int val = mpp[curr] ; \\n            res.push_back(val); \\n        }\\n        for(auto x : res) cout << x << \" \"; \\n        cout << endl;\\n        int n = int(res.size()); \\n        int dp[n]; \\n        memset(dp , 0 , sizeof dp); \\n        dp[0] = res[0]; \\n        int maxx = dp[0]; \\n        for(int i = 1 ; i < s.length(); ++i){\\n            dp[i] = max(res[i], dp[i-1] + res[i]); \\n            maxx = max(maxx , dp[i]); \\n        }\\n        maxx = max(0 , maxx); \\n        return maxx; \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3396539,
                "title": "unique-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(string &s,map<char,int>&mp){\\n\\n    int res = 0;\\n    int sum = 0;\\n\\n    for(int i = 0;i<s.size();i++){\\n\\n        if(mp.find(s[i])!=mp.end()){\\n\\n            sum = sum + mp[s[i]];\\n\\n        }\\n         if(mp.find(s[i])==mp.end()){\\n            int n = s[i]-\\'0\\';\\n            sum = sum + n-48;\\n        }\\n        res = max(res,sum);\\n        if(sum<0)sum = 0;\\n        \\n    }\\n    return res;\\n\\n    \\n}\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n        map<char,int>mp;\\n        for(int i = 0;i<chars.size();i++){\\n\\n            mp[chars[i]] = vals[i];\\n        }\\n\\n        return solve(s,mp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(string &s,map<char,int>&mp){\\n\\n    int res = 0;\\n    int sum = 0;\\n\\n    for(int i = 0;i<s.size();i++){\\n\\n        if(mp.find(s[i])!=mp.end()){\\n\\n            sum = sum + mp[s[i]];\\n\\n        }\\n         if(mp.find(s[i])==mp.end()){\\n            int n = s[i]-\\'0\\';\\n            sum = sum + n-48;\\n        }\\n        res = max(res,sum);\\n        if(sum<0)sum = 0;\\n        \\n    }\\n    return res;\\n\\n    \\n}\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n        map<char,int>mp;\\n        for(int i = 0;i<chars.size();i++){\\n\\n            mp[chars[i]] = vals[i];\\n        }\\n\\n        return solve(s,mp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396413,
                "title": "o-n-with-explanation-simple-java-dp-solution",
                "content": "# Intuition\\nUsing a dp[n + 1] to record the max value among all possible substring valus which ends with s.char(n).\\nTravel from 0 to n-1, record dp[i], and restore the max value with dp[i], then return the maxValue\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// AC: Runtime 24 ms Beats 30.39% \\n// Memory 43.4 MB Beats 47.89%\\n// DP.\\n// T:O(n), S:O(n + 26)\\n// \\nclass Solution {\\n    private HashMap<Character, Integer> charToValue = new HashMap<>();\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n\\n        for (int i = 0; i < chars.length(); i++) {\\n            charToValue.put(chars.charAt(i), i);\\n        }\\n        int len = s.length(), ret = 0;\\n        int[] dp = new int[len + 1];\\n        for (int i = 0; i < len; i++) {\\n            int val = getVal(s.charAt(i), chars, vals);\\n            dp[i + 1] = Math.max(dp[i] + val, val);\\n            ret = Math.max(ret, dp[i + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    private int getVal(char c, String chars, int[] vals) {\\n        \\n        if (charToValue.containsKey(c)) {\\n            return vals[charToValue.get(c)];\\n        }\\n\\n        return c - \\'a\\' + 1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// AC: Runtime 24 ms Beats 30.39% \\n// Memory 43.4 MB Beats 47.89%\\n// DP.\\n// T:O(n), S:O(n + 26)\\n// \\nclass Solution {\\n    private HashMap<Character, Integer> charToValue = new HashMap<>();\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n\\n        for (int i = 0; i < chars.length(); i++) {\\n            charToValue.put(chars.charAt(i), i);\\n        }\\n        int len = s.length(), ret = 0;\\n        int[] dp = new int[len + 1];\\n        for (int i = 0; i < len; i++) {\\n            int val = getVal(s.charAt(i), chars, vals);\\n            dp[i + 1] = Math.max(dp[i] + val, val);\\n            ret = Math.max(ret, dp[i + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    private int getVal(char c, String chars, int[] vals) {\\n        \\n        if (charToValue.containsKey(c)) {\\n            return vals[charToValue.get(c)];\\n        }\\n\\n        return c - \\'a\\' + 1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395471,
                "title": "swift-kadane-s-algorithm",
                "content": "**Kadane\\'s Algorithm (accepted answer)**\\n```\\nclass Solution {\\n    func maximumCostSubstring(_ s: String, _ chars: String, _ vals: [Int]) -> Int {\\n        let LOWER_A_ASCII = 97\\n        \\n        var costs = Array(1...26)\\n        for (ch, val) in zip(chars, vals) {\\n            costs[Int(ch.asciiValue!) - LOWER_A_ASCII] = val\\n        }\\n        \\n        var localMax = 0\\n        var globalMax = 0\\n        \\n        for ch in s {\\n            let cost = costs[Int(ch.asciiValue!) - LOWER_A_ASCII]\\n            localMax = max(cost, cost + localMax)\\n            globalMax = max(localMax, globalMax)\\n        }\\n        \\n        return globalMax\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumCostSubstring(_ s: String, _ chars: String, _ vals: [Int]) -> Int {\\n        let LOWER_A_ASCII = 97\\n        \\n        var costs = Array(1...26)\\n        for (ch, val) in zip(chars, vals) {\\n            costs[Int(ch.asciiValue!) - LOWER_A_ASCII] = val\\n        }\\n        \\n        var localMax = 0\\n        var globalMax = 0\\n        \\n        for ch in s {\\n            let cost = costs[Int(ch.asciiValue!) - LOWER_A_ASCII]\\n            localMax = max(cost, cost + localMax)\\n            globalMax = max(localMax, globalMax)\\n        }\\n        \\n        return globalMax\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393827,
                "title": "intutive-c-solution-kadane-hashmap-heavily-commented",
                "content": "# Intuition\\n1. Calculate the value of each character in the given string according to the given conditions.\\n2. Apply Kadane\\'s Algo to get the maximum sum.\\n\\n# Approach\\n### EXPLAINED IN THE CODE THROUGH COMMENTS.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n        unordered_map<char,int>mp;// map to store the corrosponding value of chars from vals\\n        map<char,int>mp2; // map to store indexed value of a character, yu can also use array.\\n        \\n        //storing the values of character.\\n        char ch=\\'a\\';\\n        for(int i=1;i<=26;i++) mp2[ch++]=i;\\n\\n        // storing the value of characters from the vals array.\\n        for(int i=0;i<chars.size();i++) mp[chars[i]]=vals[i];\\n        \\n        //Now make a temporray array using the values evaluated.\\n        vector<int>tmp;\\n        for(int i=0;i<s.size();i++){\\n            if(mp.find(s[i])!=mp.end()) tmp.push_back(mp[s[i]]);\\n            else tmp.push_back(mp2[s[i]]);\\n        }\\n        \\n        //Now simply apply KADANE\\'s ALGO on temporay array to get the maximum subarray sum.\\n        int sum=0, maxi=INT_MIN;\\n        for(auto it : tmp){\\n            sum+=it;\\n            maxi=max(maxi,sum);\\n            if(sum<0) sum=0;\\n        }\\n        \\n        //if sum is -ve , then empty subarray have maximum sum\\n        if(maxi<0) maxi=0;\\n        return maxi;\\n    }\\n};\\n```\\nPLEASE UPVOTE IF YOU LIKE \\uD83D\\uDE0A\\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n        unordered_map<char,int>mp;// map to store the corrosponding value of chars from vals\\n        map<char,int>mp2; // map to store indexed value of a character, yu can also use array.\\n        \\n        //storing the values of character.\\n        char ch=\\'a\\';\\n        for(int i=1;i<=26;i++) mp2[ch++]=i;\\n\\n        // storing the value of characters from the vals array.\\n        for(int i=0;i<chars.size();i++) mp[chars[i]]=vals[i];\\n        \\n        //Now make a temporray array using the values evaluated.\\n        vector<int>tmp;\\n        for(int i=0;i<s.size();i++){\\n            if(mp.find(s[i])!=mp.end()) tmp.push_back(mp[s[i]]);\\n            else tmp.push_back(mp2[s[i]]);\\n        }\\n        \\n        //Now simply apply KADANE\\'s ALGO on temporay array to get the maximum subarray sum.\\n        int sum=0, maxi=INT_MIN;\\n        for(auto it : tmp){\\n            sum+=it;\\n            maxi=max(maxi,sum);\\n            if(sum<0) sum=0;\\n        }\\n        \\n        //if sum is -ve , then empty subarray have maximum sum\\n        if(maxi<0) maxi=0;\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392912,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.stream.IntStream;\\n\\npublic class Solution {\\n\\n    private static final int ALPHABET_SIZE = 26;\\n\\n    public int maximumCostSubstring(String input, String chars, int[] values) {\\n        int[] costForChar = IntStream.rangeClosed(1, ALPHABET_SIZE).toArray();\\n        for (int i = 0; i < chars.length(); ++i) {\\n            costForChar[chars.charAt(i) - \\'a\\'] = values[i];\\n        }\\n\\n        int maxCost = 0;\\n        int currentCost = 0;\\n        for (int i = 0; i < input.length(); ++i) {\\n            currentCost = Math.max(0, currentCost + costForChar[input.charAt(i) - \\'a\\']);\\n            maxCost = Math.max(maxCost, currentCost);\\n        }\\n        return maxCost;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {string} input\\n * @param {string} chars\\n * @param {number[]} values\\n * @return {number}\\n */\\nvar maximumCostSubstring = function (input, chars, values) {\\n    const ALPHABET_SIZE = 26;\\n    const ASCII_SMALL_CASE_A = 97;\\n    const costForChar = Array.from(Array(ALPHABET_SIZE).keys(), n => n + 1);\\n    for (let i = 0; i < chars.length; ++i) {\\n        costForChar[chars.codePointAt(i) - ASCII_SMALL_CASE_A] = values[i];\\n    }\\n\\n    let maxCost = 0;\\n    let currentCost = 0;\\n    for (let i = 0; i < input.length; ++i) {\\n        currentCost = Math.max(0, currentCost + costForChar[input.codePointAt(i) - ASCII_SMALL_CASE_A]);\\n        maxCost = Math.max(maxCost, currentCost);\\n    }\\n    return maxCost;\\n};\\n```\\n**C++**\\n```\\n#include <array>\\n#include <string>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n    \\n    static const int ALPHABET_SIZE = 26;\\n    \\npublic:\\n    int maximumCostSubstring(const string& input, const string& chars, const vector<int>& values) const {\\n        array<int, ALPHABET_SIZE> costForChar;\\n        iota(costForChar.begin(), costForChar.end(), 1);\\n        for (int i = 0; i < chars.length(); ++i) {\\n            costForChar[chars[i] - \\'a\\'] = values[i];\\n        }\\n\\n        int maxCost = 0;\\n        int currentCost = 0;\\n        for (const auto& letter : input) {\\n            currentCost = max(0, currentCost + costForChar[letter - \\'a\\']);\\n            maxCost = max(maxCost, currentCost);\\n        }\\n        return maxCost;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nimport java.util.stream.IntStream;\\n\\npublic class Solution {\\n\\n    private static final int ALPHABET_SIZE = 26;\\n\\n    public int maximumCostSubstring(String input, String chars, int[] values) {\\n        int[] costForChar = IntStream.rangeClosed(1, ALPHABET_SIZE).toArray();\\n        for (int i = 0; i < chars.length(); ++i) {\\n            costForChar[chars.charAt(i) - \\'a\\'] = values[i];\\n        }\\n\\n        int maxCost = 0;\\n        int currentCost = 0;\\n        for (int i = 0; i < input.length(); ++i) {\\n            currentCost = Math.max(0, currentCost + costForChar[input.charAt(i) - \\'a\\']);\\n            maxCost = Math.max(maxCost, currentCost);\\n        }\\n        return maxCost;\\n    }\\n}\\n```\n```\\n/**\\n * @param {string} input\\n * @param {string} chars\\n * @param {number[]} values\\n * @return {number}\\n */\\nvar maximumCostSubstring = function (input, chars, values) {\\n    const ALPHABET_SIZE = 26;\\n    const ASCII_SMALL_CASE_A = 97;\\n    const costForChar = Array.from(Array(ALPHABET_SIZE).keys(), n => n + 1);\\n    for (let i = 0; i < chars.length; ++i) {\\n        costForChar[chars.codePointAt(i) - ASCII_SMALL_CASE_A] = values[i];\\n    }\\n\\n    let maxCost = 0;\\n    let currentCost = 0;\\n    for (let i = 0; i < input.length; ++i) {\\n        currentCost = Math.max(0, currentCost + costForChar[input.codePointAt(i) - ASCII_SMALL_CASE_A]);\\n        maxCost = Math.max(maxCost, currentCost);\\n    }\\n    return maxCost;\\n};\\n```\n```\\n#include <array>\\n#include <string>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n    \\n    static const int ALPHABET_SIZE = 26;\\n    \\npublic:\\n    int maximumCostSubstring(const string& input, const string& chars, const vector<int>& values) const {\\n        array<int, ALPHABET_SIZE> costForChar;\\n        iota(costForChar.begin(), costForChar.end(), 1);\\n        for (int i = 0; i < chars.length(); ++i) {\\n            costForChar[chars[i] - \\'a\\'] = values[i];\\n        }\\n\\n        int maxCost = 0;\\n        int currentCost = 0;\\n        for (const auto& letter : input) {\\n            currentCost = max(0, currentCost + costForChar[letter - \\'a\\']);\\n            maxCost = max(maxCost, currentCost);\\n        }\\n        return maxCost;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3392748,
                "title": "easy-c-using-unordered-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n\\n        for(int i=0;i<chars.size();i++){\\n            m[chars[i]] = vals[i];\\n        }\\n\\n        int ans = 0;\\n        int temp = 0;\\n        for(int i = 0; i<s.size();i++){\\n            if(m.find(s[i])!=m.end()){\\n                temp+=m[s[i]];\\n            }else{\\n                temp += ((s[i] - \\'0\\') - 48);\\n            }\\n            ans = max(ans,temp);\\n  \\n            //if we have substring with negative value then why we add it to our answer..., so make temp = 0;  0 > (neg)\\n            if(temp < 0){\\n                temp = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n\\n        for(int i=0;i<chars.size();i++){\\n            m[chars[i]] = vals[i];\\n        }\\n\\n        int ans = 0;\\n        int temp = 0;\\n        for(int i = 0; i<s.size();i++){\\n            if(m.find(s[i])!=m.end()){\\n                temp+=m[s[i]];\\n            }else{\\n                temp += ((s[i] - \\'0\\') - 48);\\n            }\\n            ans = max(ans,temp);\\n  \\n            //if we have substring with negative value then why we add it to our answer..., so make temp = 0;  0 > (neg)\\n            if(temp < 0){\\n                temp = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392478,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        t = dict(zip(chars, vals))\\n        values = [t.get(ch, ord(ch)-96) for ch in s]\\n\\n        best, current = -math.inf, 0\\n        for val in values:\\n            current = max(current+val, 0)\\n            best = max(best, current)\\n\\n        return best\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        t = dict(zip(chars, vals))\\n        values = [t.get(ch, ord(ch)-96) for ch in s]\\n\\n        best, current = -math.inf, 0\\n        for val in values:\\n            current = max(current+val, 0)\\n            best = max(best, current)\\n\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392304,
                "title": "java-solution-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashMap<Character, Integer> hm = new HashMap<>();\\n        char x = \\'a\\';\\n\\n        for(int i = 0; i < vals.length; i++)\\n            hm.put(chars.charAt(i), vals[i]);\\n\\n        for(int i = 0; i < 26; i++){\\n            if(!hm.containsKey(x))\\n                hm.put(x, i+1);\\n\\n            x++;\\n        }\\n\\n        int[] values = new int[s.length()];\\n\\n        for(int i = 0; i < s.length(); i++)\\n            values[i] = hm.get(s.charAt(i));\\n        \\n        int max = 0;\\n        int sum = 0;\\n\\n        for(int i = 0; i < values.length; i++){\\n            sum += values[i];\\n            max = Math.max(sum, max);\\n\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// *** UP-VOTE IF HELPFUL ***\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        HashMap<Character, Integer> hm = new HashMap<>();\\n        char x = \\'a\\';\\n\\n        for(int i = 0; i < vals.length; i++)\\n            hm.put(chars.charAt(i), vals[i]);\\n\\n        for(int i = 0; i < 26; i++){\\n            if(!hm.containsKey(x))\\n                hm.put(x, i+1);\\n\\n            x++;\\n        }\\n\\n        int[] values = new int[s.length()];\\n\\n        for(int i = 0; i < s.length(); i++)\\n            values[i] = hm.get(s.charAt(i));\\n        \\n        int max = 0;\\n        int sum = 0;\\n\\n        for(int i = 0; i < values.length; i++){\\n            sum += values[i];\\n            max = Math.max(sum, max);\\n\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// *** UP-VOTE IF HELPFUL ***\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391084,
                "title": "kadane-s-algorithm",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = {}\\n        for i in range(len(chars)):\\n            d[chars[i]] = vals[i]\\n        res = 0 \\n        temp = 0\\n        for i in s:\\n            val = d[i] if i in d else ord(i) - 96\\n            temp = max(val,temp+val)\\n            res = max(res,temp)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        d = {}\\n        for i in range(len(chars)):\\n            d[chars[i]] = vals[i]\\n        res = 0 \\n        temp = 0\\n        for i in s:\\n            val = d[i] if i in d else ord(i) - 96\\n            temp = max(val,temp+val)\\n            res = max(res,temp)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388033,
                "title": "solution-modeled-after-maximum-subarray-lc-53",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGenerate All subarrays and find the maxiumum cost by eithe taking the 1 based index or the value from the vals\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGenerating sub array and taking the maximum sum approach is similar to\\n[LC 53](https://leetcode.com/problems/maximum-subarray/)\\n\\n# Complexity\\n- Time complexity:\\n- O(n) to compute\\n- O(chars) to create the map, which will be same as the chars in alphabet\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(K), if K is the number of chars in the alphabet\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int[] map = new int[26];\\n        Arrays.fill(map, -1001);\\n        for(int i = 0; i < chars.length(); i++) {\\n            map[chars.charAt(i) - \\'a\\'] = vals[i];\\n        }\\n        int gm = 0;\\n        int lm = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            int cost = map[s.charAt(i) - \\'a\\'] == -1001 ? s.charAt(i) - \\'a\\' + 1 : map[s.charAt(i) - \\'a\\'];\\n            lm = Math.max(cost, cost + lm);\\n            gm = Math.max(gm, lm);\\n        }\\n        \\n        return gm;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        int[] map = new int[26];\\n        Arrays.fill(map, -1001);\\n        for(int i = 0; i < chars.length(); i++) {\\n            map[chars.charAt(i) - \\'a\\'] = vals[i];\\n        }\\n        int gm = 0;\\n        int lm = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            int cost = map[s.charAt(i) - \\'a\\'] == -1001 ? s.charAt(i) - \\'a\\' + 1 : map[s.charAt(i) - \\'a\\'];\\n            lm = Math.max(cost, cost + lm);\\n            gm = Math.max(gm, lm);\\n        }\\n        \\n        return gm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387626,
                "title": "linear-python-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n) $$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        cur_cost = 0\\n        max_cost = 0\\n        cost = {\\n            \\'a\\':1,\\n            \\'b\\':2,\\n            \\'c\\':3,\\n            \\'d\\':4,\\n            \\'e\\':5,\\n            \\'f\\':6,\\n            \\'g\\':7,\\n            \\'h\\':8,\\n            \\'i\\':9,\\n            \\'j\\':10,\\n            \\'k\\':11,\\n            \\'l\\':12,\\n            \\'m\\':13,\\n            \\'n\\':14,\\n            \\'o\\':15,\\n            \\'p\\':16,\\n            \\'q\\':17,\\n            \\'r\\':18,\\n            \\'s\\':19,\\n            \\'t\\':20,\\n            \\'u\\':21,\\n            \\'v\\':22,\\n            \\'w\\':23,\\n            \\'x\\':24,\\n            \\'y\\':25,\\n            \\'z\\':26\\n            }\\n        for i in range(len(vals)):\\n            cost[chars[i]] = vals[i]\\n\\n        for c in s:\\n                cur_cost += cost[c]\\n                max_cost = max(max_cost, cur_cost)\\n                if cur_cost < 0:\\n                    cur_cost = 0\\n        return max_cost\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        cur_cost = 0\\n        max_cost = 0\\n        cost = {\\n            \\'a\\':1,\\n            \\'b\\':2,\\n            \\'c\\':3,\\n            \\'d\\':4,\\n            \\'e\\':5,\\n            \\'f\\':6,\\n            \\'g\\':7,\\n            \\'h\\':8,\\n            \\'i\\':9,\\n            \\'j\\':10,\\n            \\'k\\':11,\\n            \\'l\\':12,\\n            \\'m\\':13,\\n            \\'n\\':14,\\n            \\'o\\':15,\\n            \\'p\\':16,\\n            \\'q\\':17,\\n            \\'r\\':18,\\n            \\'s\\':19,\\n            \\'t\\':20,\\n            \\'u\\':21,\\n            \\'v\\':22,\\n            \\'w\\':23,\\n            \\'x\\':24,\\n            \\'y\\':25,\\n            \\'z\\':26\\n            }\\n        for i in range(len(vals)):\\n            cost[chars[i]] = vals[i]\\n\\n        for c in s:\\n                cur_cost += cost[c]\\n                max_cost = max(max_cost, cur_cost)\\n                if cur_cost < 0:\\n                    cur_cost = 0\\n        return max_cost\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387291,
                "title": "kadanes-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        su=0\\n        m=0\\n        a=dict(zip(chars,vals))\\n        for i in range(len(s)):\\n            if s[i] in chars:\\n                su+=a[s[i]]\\n            else:\\n                su+=ord(s[i])-96\\n            if(su<0):\\n                su=0\\n            m=max(m,su)\\n        return m\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        su=0\\n        m=0\\n        a=dict(zip(chars,vals))\\n        for i in range(len(s)):\\n            if s[i] in chars:\\n                su+=a[s[i]]\\n            else:\\n                su+=ord(s[i])-96\\n            if(su<0):\\n                su=0\\n            m=max(m,su)\\n        return m\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386117,
                "title": "c-easy-solution-kedane",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        unordered_map<char  , int> mp;\\n        for(int i=0;i<chars.length();i++)\\n        {\\n            mp[chars[i]] = vals[i];\\n        }\\n        vector<int> v;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(mp.find(s[i])!=mp.end())\\n            v.push_back(mp[s[i]]);\\n            else\\n            {\\n                v.push_back(s[i]-\\'a\\'+1);\\n            }\\n        }\\n       \\n       int run_sum = 0;\\n       int ans_sum = INT_MIN;\\n       for(int i=0;i<v.size();i++)\\n       {\\n\\n\\n           run_sum = run_sum + v[i];\\n           ans_sum = max(ans_sum , run_sum);\\n\\n           if(run_sum<0)\\n           run_sum = 0;\\n       }\\n       if(ans_sum<0)\\n       return 0;\\n       return ans_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        unordered_map<char  , int> mp;\\n        for(int i=0;i<chars.length();i++)\\n        {\\n            mp[chars[i]] = vals[i];\\n        }\\n        vector<int> v;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(mp.find(s[i])!=mp.end())\\n            v.push_back(mp[s[i]]);\\n            else\\n            {\\n                v.push_back(s[i]-\\'a\\'+1);\\n            }\\n        }\\n       \\n       int run_sum = 0;\\n       int ans_sum = INT_MIN;\\n       for(int i=0;i<v.size();i++)\\n       {\\n\\n\\n           run_sum = run_sum + v[i];\\n           ans_sum = max(ans_sum , run_sum);\\n\\n           if(run_sum<0)\\n           run_sum = 0;\\n       }\\n       if(ans_sum<0)\\n       return 0;\\n       return ans_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386017,
                "title": "o-n-kadane-s-algo-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> hashMap = new HashMap<>();\\n\\n        for(int i = 0; i < chars.length(); i++)\\n            hashMap.put(chars.charAt(i), i);\\n\\n        int maxCost = 0;\\n        int cost = 0;\\n        for(int j = 0; j < s.length(); j++){\\n            Character c = s.charAt(j);\\n\\n            if(hashMap.containsKey(c))\\n                cost += vals[hashMap.get(c)];\\n            else \\n                cost += c - \\'a\\' + 1;\\n\\n            maxCost = Math.max(maxCost, cost);\\n            cost = Math.max(cost, 0);\\n        }\\n        \\n        return maxCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character, Integer> hashMap = new HashMap<>();\\n\\n        for(int i = 0; i < chars.length(); i++)\\n            hashMap.put(chars.charAt(i), i);\\n\\n        int maxCost = 0;\\n        int cost = 0;\\n        for(int j = 0; j < s.length(); j++){\\n            Character c = s.charAt(j);\\n\\n            if(hashMap.containsKey(c))\\n                cost += vals[hashMap.get(c)];\\n            else \\n                cost += c - \\'a\\' + 1;\\n\\n            maxCost = Math.max(maxCost, cost);\\n            cost = Math.max(cost, 0);\\n        }\\n        \\n        return maxCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384321,
                "title": "kadane-dp-solution",
                "content": "class Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int dic[26];\\n        \\n        for(int i=0; i<26; i++)\\n            dic[i]=i+1;\\n        \\n        for(int i=0; i<vals.size(); i++)\\n            dic[chars[i]-\\'a\\']=vals[i];\\n        \\n        int n = s.size();\\n        int dp[n];\\n        int sum=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            dp[i]=0;\\n        }\\n        for(int i=0; i<s.size(); i++)\\n        {  \\n            if(i==0)\\n                dp[i] = max(0, dic[s[i]-\\'a\\']);\\n            else\\n                dp[i] = max(dp[i-1]+dic[s[i]-\\'a\\'], dic[s[i]-\\'a\\']);    \\n        }\\n        \\n        int ret=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ret = max(dp[i], ret);\\n        }\\n        return max(0, ret);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        \\n        int dic[26];\\n        \\n        for(int i=0; i<26; i++)\\n            dic[i]=i+1;\\n        \\n        for(int i=0; i<vals.size(); i++)\\n            dic[chars[i]-\\'a\\']=vals[i];\\n        \\n        int n = s.size();\\n        int dp[n];\\n        int sum=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            dp[i]=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3383715,
                "title": "easy-solution-beginners-friendly-solution-kadane-s-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n             unordered_map<char,int> mp;                      \\n             \\n             for(int i = 0; i < chars.size();i++){\\n                   mp[chars[i]] = vals[i];\\n             }\\n\\n             int max_so_far = 0;\\n             int max_val = 0;\\n\\n             for(int i = 0; i < s.size();i++){\\n                   if(mp.find(s[i]) != mp.end()){\\n                        max_so_far += mp[s[i]];\\n                   }else{\\n                       max_so_far += ((s[i]-\\'0\\')-48);                 // (\\'a\\'-\\'0\\')-48 == 1;\\n             }  \\n                   if(max_so_far > max_val){          // (\\'a\\'-\\'0\\')-48 == 1;\\n                         max_val = max_so_far;                                             // if not in chars so, using \\n                                                                                          // corresponding index value.  \\n\\n                                                          // if it is negative then its better to go with 0 \\n                                                         // that is  empty string \"\".\\n                        \\n                   }\\n                   if(max_so_far < 0){\\n                        max_so_far = 0;\\n                   }\\n             }\\n\\n             return max_val;\\n             \\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n\\n             unordered_map<char,int> mp;                      \\n             \\n             for(int i = 0; i < chars.size();i++){\\n                   mp[chars[i]] = vals[i];\\n             }\\n\\n             int max_so_far = 0;\\n             int max_val = 0;\\n\\n             for(int i = 0; i < s.size();i++){\\n                   if(mp.find(s[i]) != mp.end()){\\n                        max_so_far += mp[s[i]];\\n                   }else{\\n                       max_so_far += ((s[i]-\\'0\\')-48);                 // (\\'a\\'-\\'0\\')-48 == 1;\\n             }  \\n                   if(max_so_far > max_val){          // (\\'a\\'-\\'0\\')-48 == 1;\\n                         max_val = max_so_far;                                             // if not in chars so, using \\n                                                                                          // corresponding index value.  \\n\\n                                                          // if it is negative then its better to go with 0 \\n                                                         // that is  empty string \"\".\\n                        \\n                   }\\n                   if(max_so_far < 0){\\n                        max_so_far = 0;\\n                   }\\n             }\\n\\n             return max_val;\\n             \\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383345,
                "title": "very-fast-and-easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<chars.length();++i){\\n            map.put(chars.charAt(i),vals[i]);\\n        }\\n        \\n        \\n        int curr = 0;\\n        int max = 0;\\n        for(int i=0;i<s.length();++i){\\n            if(map.containsKey(s.charAt(i))){\\n                curr += map.get(s.charAt(i));\\n               if(curr<0){\\n                   curr = 0;\\n               }\\n            }else{\\n                curr += (s.charAt(i) - \\'a\\') + 1;\\n            }\\n            max = Math.max(max,curr);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCostSubstring(String s, String chars, int[] vals) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<chars.length();++i){\\n            map.put(chars.charAt(i),vals[i]);\\n        }\\n        \\n        \\n        int curr = 0;\\n        int max = 0;\\n        for(int i=0;i<s.length();++i){\\n            if(map.containsKey(s.charAt(i))){\\n                curr += map.get(s.charAt(i));\\n               if(curr<0){\\n                   curr = 0;\\n               }\\n            }else{\\n                curr += (s.charAt(i) - \\'a\\') + 1;\\n            }\\n            max = Math.max(max,curr);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380234,
                "title": "using-kadane-s-algorithm-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int>m;\\n\\n        int sum = 0;\\n        int ans = 0;\\n\\n        for(int i=0; i<chars.size(); i++)\\n        {\\n            if(m.find(chars[i]) == m.end())\\n            {\\n                m[chars[i]] = vals[i];\\n            }\\n        }\\n            for(int i=0; i<s.size(); i++)\\n            {\\n                if(m.find(s[i]) != m.end())\\n                {\\n                    sum+=m[s[i]];\\n                }\\n                else\\n                {\\n                    sum += (int)(s[i]-\\'a\\')+1;\\n                }\\n                    if(sum<0)\\n                    {\\n                        sum = 0;\\n                    }\\n                    else\\n                    {\\n                        ans = max(ans,sum);\\n                    }\\n                \\n            }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char, int>m;\\n\\n        int sum = 0;\\n        int ans = 0;\\n\\n        for(int i=0; i<chars.size(); i++)\\n        {\\n            if(m.find(chars[i]) == m.end())\\n            {\\n                m[chars[i]] = vals[i];\\n            }\\n        }\\n            for(int i=0; i<s.size(); i++)\\n            {\\n                if(m.find(s[i]) != m.end())\\n                {\\n                    sum+=m[s[i]];\\n                }\\n                else\\n                {\\n                    sum += (int)(s[i]-\\'a\\')+1;\\n                }\\n                    if(sum<0)\\n                    {\\n                        sum = 0;\\n                    }\\n                    else\\n                    {\\n                        ans = max(ans,sum);\\n                    }\\n                \\n            }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380090,
                "title": "c-simple-maximizing-subarray-sum-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> cost(26,0); //freq array to store cost of each characters\\n        for(int i=1;i<=26;i++) cost[i-1]=i; //storing cost of characters which are not in {chars}\\n        for(int i=0;i<chars.size();i++) cost[chars[i]-\\'a\\']=vals[i];//which are there in {chars}\\n        int mx=0,sm=0; //This is similar maximum subarray sum\\n        for(int i=0;i<s.size();i++){\\n            sm+=cost[s[i]-\\'a\\'];\\n            if(sm<0) sm=0;\\n            mx=max(mx,sm);\\n        }\\n        return mx;\\n    }\\n};\\n```\\n**Hey, Upvote if you liked it !!**",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> cost(26,0); //freq array to store cost of each characters\\n        for(int i=1;i<=26;i++) cost[i-1]=i; //storing cost of characters which are not in {chars}\\n        for(int i=0;i<chars.size();i++) cost[chars[i]-\\'a\\']=vals[i];//which are there in {chars}\\n        int mx=0,sm=0; //This is similar maximum subarray sum\\n        for(int i=0;i<s.size();i++){\\n            sm+=cost[s[i]-\\'a\\'];\\n            if(sm<0) sm=0;\\n            mx=max(mx,sm);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379387,
                "title": "intuitive-the-basis-is-maximizing-subarray-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def value(self, ch):\\n        return ord(ch) - ord(\\'a\\') + 1\\n\\n    def cost(self, ch, chars, vals):\\n        idx = 0\\n        for char in chars:\\n            if ch == char:\\n                return vals[idx]\\n            idx += 1\\n        return 0\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        max_value = 0\\n        max_cost = 0\\n        for ch in s:\\n            if ch not in chars:\\n                max_cost += self.value(ch)\\n            else:\\n                max_cost += self.cost(ch, chars, vals)\\n            max_cost = max(0, max_cost)\\n            max_value = max(max_value, max_cost)\\n        return max_value\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def value(self, ch):\\n        return ord(ch) - ord(\\'a\\') + 1\\n\\n    def cost(self, ch, chars, vals):\\n        idx = 0\\n        for char in chars:\\n            if ch == char:\\n                return vals[idx]\\n            idx += 1\\n        return 0\\n    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:\\n        max_value = 0\\n        max_cost = 0\\n        for ch in s:\\n            if ch not in chars:\\n                max_cost += self.value(ch)\\n            else:\\n                max_cost += self.cost(ch, chars, vals)\\n            max_cost = max(0, max_cost)\\n            max_value = max(max_value, max_cost)\\n        return max_value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379081,
                "title": "explained-o-n-time-o-1-memory-c-solution",
                "content": "# Intuition\\nThis is a standard maximum sum subarray problem, the only variation here is we need a char value map.\\n\\n# Approach\\n1. Initialize the char->value map with the given values first.\\n2. Fill in the values of the rest of the characters.\\n\\nMax Subarray problem on string s:\\n\\n3. keep a cumulative sum of the char values in the array using the map\\n4. If at any point the sum drops below zero then it\\'s cheaper to ignore the previous part of the string and start at the current index.\\n5. Keep track of cumulative sum values and return the max.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> mp(26, INT32_MIN);\\n        for (int i = 0; i < chars.size(); ++i) mp[chars[i] - \\'a\\'] = vals[i];\\n        for (int i = 0; i < 26; ++i) if (mp[i] == INT32_MIN) mp[i] = i + 1;\\n\\n        int ans = 0, sum = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            sum = max(0, sum + mp[s[i] - \\'a\\']);\\n            ans = max(ans, sum);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        vector<int> mp(26, INT32_MIN);\\n        for (int i = 0; i < chars.size(); ++i) mp[chars[i] - \\'a\\'] = vals[i];\\n        for (int i = 0; i < 26; ++i) if (mp[i] == INT32_MIN) mp[i] = i + 1;\\n\\n        int ans = 0, sum = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            sum = max(0, sum + mp[s[i] - \\'a\\']);\\n            ans = max(ans, sum);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378840,
                "title": "c-simple-sliding-window-2-pointer-solution-same-old-concepts-of-sliding-window",
                "content": "# Approach\\nAs the sum is positive we will keep on moving forward, because we can add positive sum to the future answer. But as the current sum gets negative we cannot add that sum into the future answer (as the sum has to be maximum i.e. either positive or 0 when no char it taken into consideration).\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int i = 0, j = 0;\\n        int currcost = 0;\\n        int ans = 0;\\n        vector<int>vec(26, INT_MIN);\\n        for(int k = 0; k<chars.size(); k++){\\n            vec[chars[k]-\\'a\\'] = vals[k];\\n        }\\n\\n        // cout<<j<<endl;\\n        while(j<s.size()){\\n            cout<<j<<endl;\\n            if(vec[s[j]-\\'a\\']!=INT_MIN){\\n                currcost+=vec[s[j]-\\'a\\'];\\n            }\\n\\n            else{\\n                currcost+=(s[j]-\\'a\\'+1);\\n            }\\n\\n            while(i<=j and currcost<0){\\n                if(vec[s[i]-\\'a\\']!=INT_MIN){\\n                    currcost-=vec[s[i]-\\'a\\'];\\n                }\\n\\n                else{\\n                    currcost-=(s[i]-\\'a\\'+1);\\n                }\\n                i++;\\n            }\\n\\n            ans = max(ans, currcost);\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int i = 0, j = 0;\\n        int currcost = 0;\\n        int ans = 0;\\n        vector<int>vec(26, INT_MIN);\\n        for(int k = 0; k<chars.size(); k++){\\n            vec[chars[k]-\\'a\\'] = vals[k];\\n        }\\n\\n        // cout<<j<<endl;\\n        while(j<s.size()){\\n            cout<<j<<endl;\\n            if(vec[s[j]-\\'a\\']!=INT_MIN){\\n                currcost+=vec[s[j]-\\'a\\'];\\n            }\\n\\n            else{\\n                currcost+=(s[j]-\\'a\\'+1);\\n            }\\n\\n            while(i<=j and currcost<0){\\n                if(vec[s[i]-\\'a\\']!=INT_MIN){\\n                    currcost-=vec[s[i]-\\'a\\'];\\n                }\\n\\n                else{\\n                    currcost-=(s[i]-\\'a\\'+1);\\n                }\\n                i++;\\n            }\\n\\n            ans = max(ans, currcost);\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1850270,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "If you can\\'t even solve this problem, go and learn Kadane\\'s algorithm first."
                    },
                    {
                        "username": "namandt",
                        "content": "Nice.\\n|you pro bro\\nme nub"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Here how This Problem is related to Kadane's Algo :--\n[1] Instead of finding the maximum cost, find the substring(s) with the minimum cost.\n[2]  Instead of a single string chars, you are given a list of strings chars_list, each containing distinct characters. The cost of a character in a substring is the value in vals corresponding to the index of the string in chars_list where the character is present. If the character is not present in any of the strings in chars_list, its value is its corresponding position in the alphabet.\n[3]  Instead of finding the maximum cost substring, find the length of the longest substring such that the sum of the values of its characters is less than or equal to a given integer k.\n[4]  Instead of a string s, you are given a list of strings s_list. Find the maximum cost substring across all the strings in s_list.\n[5]  Instead of a contiguous substring, find the maximum cost subsequence in the given string s."
                    },
                    {
                        "username": "pratham2712",
                        "content": "how to come up with an idea that I can solve using Kadane at the time of the contest?? "
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Practice of solving variation type questions related to any Algorithm"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can\\'t we solve it in this way?\\n\\nint solve(int ind, string &s, map<char, int>&mp, vector<int>&dp){\\n        if(ind == s.length()){\\n            return 0;\\n        }\\n        if(dp[ind] != -1)return dp[ind];\\n        int val = 0;\\n        if(mp.count(s[ind]) > 0){\\n            val = mp[s[ind]];\\n        }\\n        else{\\n             val = s[ind] - \\'a\\' +1;\\n        }\\n\\n        return dp[ind] = max(val , val + solve(ind+1, s, mp, dp));\\n    }\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = chars.length();\\n        vector<int>dp( s.length() +1, -1);\\n        map<char,int>mp;\\n        for(int i =0; i < n; i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        int ans = 0;  \\n        for(int i =0; i < n; i++){\\n            ans = max(ans, solve(i, s, mp, dp));\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "shubhamrauniyar48",
                        "content": "Can anybody help me to know the difference of this both if conditional check for map \\n=>   if(map[s[i]])\\n=>  if(map.find(s[i]) != map.end())\\n\\nthe second one performs well for this question but the first one fails for\\ntestcase:\\n s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] \\n\\nwhen i try to debug where it is failing ,i found that  map[\\'m\\'] is having value 0 even though i am storing map[\\'m\\'] = 1000.\\n\\ni found this problem specific for char \\'m\\'.\\n```\\n//below is the code , you can test line no 14 and 15, (paste the code in editor)\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        for(int i = 0;i<chars.size();i++)\\n        {\\n            m[chars[i]]= vals[i];\\n        }\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n     // cout<<m[\\'m\\']<<endl;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n         if(m.find(s[i]) != m.end())\\n         // if(m[s[i]])//s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] this of checking  fails for this testcase\\n          {\\n          sum += m[s[i]];\\n            cout<<s[i]<<\" \"<<m[s[i]]<<endl;\\n          }\\n          else{\\n              cout<<s[i]<<endl;\\n          sum += ((int)(s[i])-96); //or s[i]-\\'a\\'+1\\n          }\\n          maxi = max(maxi,sum);\\n          if(sum < 0)\\n          sum = 0;\\n        }\\n        if(maxi < 0)\\n        return 0;\\n        return maxi;\\n    }\\n};\\n```\\n\\n \\n"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[All Approaches from Brute to Optimized ](https://leetcode.com/problems/find-the-substring-with-maximum-cost/solutions/3366480/all-approaches-brute-to-optimized-kadane-s-algo/?orderBy=newest_to_oldest) "
                    }
                ]
            },
            {
                "id": 1850487,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "If you can\\'t even solve this problem, go and learn Kadane\\'s algorithm first."
                    },
                    {
                        "username": "namandt",
                        "content": "Nice.\\n|you pro bro\\nme nub"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Here how This Problem is related to Kadane's Algo :--\n[1] Instead of finding the maximum cost, find the substring(s) with the minimum cost.\n[2]  Instead of a single string chars, you are given a list of strings chars_list, each containing distinct characters. The cost of a character in a substring is the value in vals corresponding to the index of the string in chars_list where the character is present. If the character is not present in any of the strings in chars_list, its value is its corresponding position in the alphabet.\n[3]  Instead of finding the maximum cost substring, find the length of the longest substring such that the sum of the values of its characters is less than or equal to a given integer k.\n[4]  Instead of a string s, you are given a list of strings s_list. Find the maximum cost substring across all the strings in s_list.\n[5]  Instead of a contiguous substring, find the maximum cost subsequence in the given string s."
                    },
                    {
                        "username": "pratham2712",
                        "content": "how to come up with an idea that I can solve using Kadane at the time of the contest?? "
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Practice of solving variation type questions related to any Algorithm"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can\\'t we solve it in this way?\\n\\nint solve(int ind, string &s, map<char, int>&mp, vector<int>&dp){\\n        if(ind == s.length()){\\n            return 0;\\n        }\\n        if(dp[ind] != -1)return dp[ind];\\n        int val = 0;\\n        if(mp.count(s[ind]) > 0){\\n            val = mp[s[ind]];\\n        }\\n        else{\\n             val = s[ind] - \\'a\\' +1;\\n        }\\n\\n        return dp[ind] = max(val , val + solve(ind+1, s, mp, dp));\\n    }\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = chars.length();\\n        vector<int>dp( s.length() +1, -1);\\n        map<char,int>mp;\\n        for(int i =0; i < n; i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        int ans = 0;  \\n        for(int i =0; i < n; i++){\\n            ans = max(ans, solve(i, s, mp, dp));\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "shubhamrauniyar48",
                        "content": "Can anybody help me to know the difference of this both if conditional check for map \\n=>   if(map[s[i]])\\n=>  if(map.find(s[i]) != map.end())\\n\\nthe second one performs well for this question but the first one fails for\\ntestcase:\\n s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] \\n\\nwhen i try to debug where it is failing ,i found that  map[\\'m\\'] is having value 0 even though i am storing map[\\'m\\'] = 1000.\\n\\ni found this problem specific for char \\'m\\'.\\n```\\n//below is the code , you can test line no 14 and 15, (paste the code in editor)\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        for(int i = 0;i<chars.size();i++)\\n        {\\n            m[chars[i]]= vals[i];\\n        }\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n     // cout<<m[\\'m\\']<<endl;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n         if(m.find(s[i]) != m.end())\\n         // if(m[s[i]])//s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] this of checking  fails for this testcase\\n          {\\n          sum += m[s[i]];\\n            cout<<s[i]<<\" \"<<m[s[i]]<<endl;\\n          }\\n          else{\\n              cout<<s[i]<<endl;\\n          sum += ((int)(s[i])-96); //or s[i]-\\'a\\'+1\\n          }\\n          maxi = max(maxi,sum);\\n          if(sum < 0)\\n          sum = 0;\\n        }\\n        if(maxi < 0)\\n        return 0;\\n        return maxi;\\n    }\\n};\\n```\\n\\n \\n"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[All Approaches from Brute to Optimized ](https://leetcode.com/problems/find-the-substring-with-maximum-cost/solutions/3366480/all-approaches-brute-to-optimized-kadane-s-algo/?orderBy=newest_to_oldest) "
                    }
                ]
            },
            {
                "id": 1850416,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "If you can\\'t even solve this problem, go and learn Kadane\\'s algorithm first."
                    },
                    {
                        "username": "namandt",
                        "content": "Nice.\\n|you pro bro\\nme nub"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Here how This Problem is related to Kadane's Algo :--\n[1] Instead of finding the maximum cost, find the substring(s) with the minimum cost.\n[2]  Instead of a single string chars, you are given a list of strings chars_list, each containing distinct characters. The cost of a character in a substring is the value in vals corresponding to the index of the string in chars_list where the character is present. If the character is not present in any of the strings in chars_list, its value is its corresponding position in the alphabet.\n[3]  Instead of finding the maximum cost substring, find the length of the longest substring such that the sum of the values of its characters is less than or equal to a given integer k.\n[4]  Instead of a string s, you are given a list of strings s_list. Find the maximum cost substring across all the strings in s_list.\n[5]  Instead of a contiguous substring, find the maximum cost subsequence in the given string s."
                    },
                    {
                        "username": "pratham2712",
                        "content": "how to come up with an idea that I can solve using Kadane at the time of the contest?? "
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Practice of solving variation type questions related to any Algorithm"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can\\'t we solve it in this way?\\n\\nint solve(int ind, string &s, map<char, int>&mp, vector<int>&dp){\\n        if(ind == s.length()){\\n            return 0;\\n        }\\n        if(dp[ind] != -1)return dp[ind];\\n        int val = 0;\\n        if(mp.count(s[ind]) > 0){\\n            val = mp[s[ind]];\\n        }\\n        else{\\n             val = s[ind] - \\'a\\' +1;\\n        }\\n\\n        return dp[ind] = max(val , val + solve(ind+1, s, mp, dp));\\n    }\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = chars.length();\\n        vector<int>dp( s.length() +1, -1);\\n        map<char,int>mp;\\n        for(int i =0; i < n; i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        int ans = 0;  \\n        for(int i =0; i < n; i++){\\n            ans = max(ans, solve(i, s, mp, dp));\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "shubhamrauniyar48",
                        "content": "Can anybody help me to know the difference of this both if conditional check for map \\n=>   if(map[s[i]])\\n=>  if(map.find(s[i]) != map.end())\\n\\nthe second one performs well for this question but the first one fails for\\ntestcase:\\n s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] \\n\\nwhen i try to debug where it is failing ,i found that  map[\\'m\\'] is having value 0 even though i am storing map[\\'m\\'] = 1000.\\n\\ni found this problem specific for char \\'m\\'.\\n```\\n//below is the code , you can test line no 14 and 15, (paste the code in editor)\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        for(int i = 0;i<chars.size();i++)\\n        {\\n            m[chars[i]]= vals[i];\\n        }\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n     // cout<<m[\\'m\\']<<endl;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n         if(m.find(s[i]) != m.end())\\n         // if(m[s[i]])//s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] this of checking  fails for this testcase\\n          {\\n          sum += m[s[i]];\\n            cout<<s[i]<<\" \"<<m[s[i]]<<endl;\\n          }\\n          else{\\n              cout<<s[i]<<endl;\\n          sum += ((int)(s[i])-96); //or s[i]-\\'a\\'+1\\n          }\\n          maxi = max(maxi,sum);\\n          if(sum < 0)\\n          sum = 0;\\n        }\\n        if(maxi < 0)\\n        return 0;\\n        return maxi;\\n    }\\n};\\n```\\n\\n \\n"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[All Approaches from Brute to Optimized ](https://leetcode.com/problems/find-the-substring-with-maximum-cost/solutions/3366480/all-approaches-brute-to-optimized-kadane-s-algo/?orderBy=newest_to_oldest) "
                    }
                ]
            },
            {
                "id": 1914288,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "If you can\\'t even solve this problem, go and learn Kadane\\'s algorithm first."
                    },
                    {
                        "username": "namandt",
                        "content": "Nice.\\n|you pro bro\\nme nub"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Here how This Problem is related to Kadane's Algo :--\n[1] Instead of finding the maximum cost, find the substring(s) with the minimum cost.\n[2]  Instead of a single string chars, you are given a list of strings chars_list, each containing distinct characters. The cost of a character in a substring is the value in vals corresponding to the index of the string in chars_list where the character is present. If the character is not present in any of the strings in chars_list, its value is its corresponding position in the alphabet.\n[3]  Instead of finding the maximum cost substring, find the length of the longest substring such that the sum of the values of its characters is less than or equal to a given integer k.\n[4]  Instead of a string s, you are given a list of strings s_list. Find the maximum cost substring across all the strings in s_list.\n[5]  Instead of a contiguous substring, find the maximum cost subsequence in the given string s."
                    },
                    {
                        "username": "pratham2712",
                        "content": "how to come up with an idea that I can solve using Kadane at the time of the contest?? "
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Practice of solving variation type questions related to any Algorithm"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can\\'t we solve it in this way?\\n\\nint solve(int ind, string &s, map<char, int>&mp, vector<int>&dp){\\n        if(ind == s.length()){\\n            return 0;\\n        }\\n        if(dp[ind] != -1)return dp[ind];\\n        int val = 0;\\n        if(mp.count(s[ind]) > 0){\\n            val = mp[s[ind]];\\n        }\\n        else{\\n             val = s[ind] - \\'a\\' +1;\\n        }\\n\\n        return dp[ind] = max(val , val + solve(ind+1, s, mp, dp));\\n    }\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = chars.length();\\n        vector<int>dp( s.length() +1, -1);\\n        map<char,int>mp;\\n        for(int i =0; i < n; i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        int ans = 0;  \\n        for(int i =0; i < n; i++){\\n            ans = max(ans, solve(i, s, mp, dp));\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "shubhamrauniyar48",
                        "content": "Can anybody help me to know the difference of this both if conditional check for map \\n=>   if(map[s[i]])\\n=>  if(map.find(s[i]) != map.end())\\n\\nthe second one performs well for this question but the first one fails for\\ntestcase:\\n s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] \\n\\nwhen i try to debug where it is failing ,i found that  map[\\'m\\'] is having value 0 even though i am storing map[\\'m\\'] = 1000.\\n\\ni found this problem specific for char \\'m\\'.\\n```\\n//below is the code , you can test line no 14 and 15, (paste the code in editor)\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        for(int i = 0;i<chars.size();i++)\\n        {\\n            m[chars[i]]= vals[i];\\n        }\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n     // cout<<m[\\'m\\']<<endl;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n         if(m.find(s[i]) != m.end())\\n         // if(m[s[i]])//s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] this of checking  fails for this testcase\\n          {\\n          sum += m[s[i]];\\n            cout<<s[i]<<\" \"<<m[s[i]]<<endl;\\n          }\\n          else{\\n              cout<<s[i]<<endl;\\n          sum += ((int)(s[i])-96); //or s[i]-\\'a\\'+1\\n          }\\n          maxi = max(maxi,sum);\\n          if(sum < 0)\\n          sum = 0;\\n        }\\n        if(maxi < 0)\\n        return 0;\\n        return maxi;\\n    }\\n};\\n```\\n\\n \\n"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[All Approaches from Brute to Optimized ](https://leetcode.com/problems/find-the-substring-with-maximum-cost/solutions/3366480/all-approaches-brute-to-optimized-kadane-s-algo/?orderBy=newest_to_oldest) "
                    }
                ]
            },
            {
                "id": 1850488,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "If you can\\'t even solve this problem, go and learn Kadane\\'s algorithm first."
                    },
                    {
                        "username": "namandt",
                        "content": "Nice.\\n|you pro bro\\nme nub"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Here how This Problem is related to Kadane's Algo :--\n[1] Instead of finding the maximum cost, find the substring(s) with the minimum cost.\n[2]  Instead of a single string chars, you are given a list of strings chars_list, each containing distinct characters. The cost of a character in a substring is the value in vals corresponding to the index of the string in chars_list where the character is present. If the character is not present in any of the strings in chars_list, its value is its corresponding position in the alphabet.\n[3]  Instead of finding the maximum cost substring, find the length of the longest substring such that the sum of the values of its characters is less than or equal to a given integer k.\n[4]  Instead of a string s, you are given a list of strings s_list. Find the maximum cost substring across all the strings in s_list.\n[5]  Instead of a contiguous substring, find the maximum cost subsequence in the given string s."
                    },
                    {
                        "username": "pratham2712",
                        "content": "how to come up with an idea that I can solve using Kadane at the time of the contest?? "
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Practice of solving variation type questions related to any Algorithm"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can\\'t we solve it in this way?\\n\\nint solve(int ind, string &s, map<char, int>&mp, vector<int>&dp){\\n        if(ind == s.length()){\\n            return 0;\\n        }\\n        if(dp[ind] != -1)return dp[ind];\\n        int val = 0;\\n        if(mp.count(s[ind]) > 0){\\n            val = mp[s[ind]];\\n        }\\n        else{\\n             val = s[ind] - \\'a\\' +1;\\n        }\\n\\n        return dp[ind] = max(val , val + solve(ind+1, s, mp, dp));\\n    }\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = chars.length();\\n        vector<int>dp( s.length() +1, -1);\\n        map<char,int>mp;\\n        for(int i =0; i < n; i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        int ans = 0;  \\n        for(int i =0; i < n; i++){\\n            ans = max(ans, solve(i, s, mp, dp));\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "shubhamrauniyar48",
                        "content": "Can anybody help me to know the difference of this both if conditional check for map \\n=>   if(map[s[i]])\\n=>  if(map.find(s[i]) != map.end())\\n\\nthe second one performs well for this question but the first one fails for\\ntestcase:\\n s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] \\n\\nwhen i try to debug where it is failing ,i found that  map[\\'m\\'] is having value 0 even though i am storing map[\\'m\\'] = 1000.\\n\\ni found this problem specific for char \\'m\\'.\\n```\\n//below is the code , you can test line no 14 and 15, (paste the code in editor)\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        for(int i = 0;i<chars.size();i++)\\n        {\\n            m[chars[i]]= vals[i];\\n        }\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n     // cout<<m[\\'m\\']<<endl;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n         if(m.find(s[i]) != m.end())\\n         // if(m[s[i]])//s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] this of checking  fails for this testcase\\n          {\\n          sum += m[s[i]];\\n            cout<<s[i]<<\" \"<<m[s[i]]<<endl;\\n          }\\n          else{\\n              cout<<s[i]<<endl;\\n          sum += ((int)(s[i])-96); //or s[i]-\\'a\\'+1\\n          }\\n          maxi = max(maxi,sum);\\n          if(sum < 0)\\n          sum = 0;\\n        }\\n        if(maxi < 0)\\n        return 0;\\n        return maxi;\\n    }\\n};\\n```\\n\\n \\n"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[All Approaches from Brute to Optimized ](https://leetcode.com/problems/find-the-substring-with-maximum-cost/solutions/3366480/all-approaches-brute-to-optimized-kadane-s-algo/?orderBy=newest_to_oldest) "
                    }
                ]
            },
            {
                "id": 1850305,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "If you can\\'t even solve this problem, go and learn Kadane\\'s algorithm first."
                    },
                    {
                        "username": "namandt",
                        "content": "Nice.\\n|you pro bro\\nme nub"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Here how This Problem is related to Kadane's Algo :--\n[1] Instead of finding the maximum cost, find the substring(s) with the minimum cost.\n[2]  Instead of a single string chars, you are given a list of strings chars_list, each containing distinct characters. The cost of a character in a substring is the value in vals corresponding to the index of the string in chars_list where the character is present. If the character is not present in any of the strings in chars_list, its value is its corresponding position in the alphabet.\n[3]  Instead of finding the maximum cost substring, find the length of the longest substring such that the sum of the values of its characters is less than or equal to a given integer k.\n[4]  Instead of a string s, you are given a list of strings s_list. Find the maximum cost substring across all the strings in s_list.\n[5]  Instead of a contiguous substring, find the maximum cost subsequence in the given string s."
                    },
                    {
                        "username": "pratham2712",
                        "content": "how to come up with an idea that I can solve using Kadane at the time of the contest?? "
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "Practice of solving variation type questions related to any Algorithm"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "can\\'t we solve it in this way?\\n\\nint solve(int ind, string &s, map<char, int>&mp, vector<int>&dp){\\n        if(ind == s.length()){\\n            return 0;\\n        }\\n        if(dp[ind] != -1)return dp[ind];\\n        int val = 0;\\n        if(mp.count(s[ind]) > 0){\\n            val = mp[s[ind]];\\n        }\\n        else{\\n             val = s[ind] - \\'a\\' +1;\\n        }\\n\\n        return dp[ind] = max(val , val + solve(ind+1, s, mp, dp));\\n    }\\n\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        int n = chars.length();\\n        vector<int>dp( s.length() +1, -1);\\n        map<char,int>mp;\\n        for(int i =0; i < n; i++){\\n            mp[chars[i]] = vals[i];\\n        }\\n        int ans = 0;  \\n        for(int i =0; i < n; i++){\\n            ans = max(ans, solve(i, s, mp, dp));\\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "shubhamrauniyar48",
                        "content": "Can anybody help me to know the difference of this both if conditional check for map \\n=>   if(map[s[i]])\\n=>  if(map.find(s[i]) != map.end())\\n\\nthe second one performs well for this question but the first one fails for\\ntestcase:\\n s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] \\n\\nwhen i try to debug where it is failing ,i found that  map[\\'m\\'] is having value 0 even though i am storing map[\\'m\\'] = 1000.\\n\\ni found this problem specific for char \\'m\\'.\\n```\\n//below is the code , you can test line no 14 and 15, (paste the code in editor)\\nclass Solution {\\npublic:\\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\\n        unordered_map<char,int>m;\\n        for(int i = 0;i<chars.size();i++)\\n        {\\n            m[chars[i]]= vals[i];\\n        }\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n     // cout<<m[\\'m\\']<<endl;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n         if(m.find(s[i]) != m.end())\\n         // if(m[s[i]])//s =\"xuusmmums\" chars =\"sxmu\" vals =[-6,5,0,5] this of checking  fails for this testcase\\n          {\\n          sum += m[s[i]];\\n            cout<<s[i]<<\" \"<<m[s[i]]<<endl;\\n          }\\n          else{\\n              cout<<s[i]<<endl;\\n          sum += ((int)(s[i])-96); //or s[i]-\\'a\\'+1\\n          }\\n          maxi = max(maxi,sum);\\n          if(sum < 0)\\n          sum = 0;\\n        }\\n        if(maxi < 0)\\n        return 0;\\n        return maxi;\\n    }\\n};\\n```\\n\\n \\n"
                    },
                    {
                        "username": "guptamanu409",
                        "content": "[All Approaches from Brute to Optimized ](https://leetcode.com/problems/find-the-substring-with-maximum-cost/solutions/3366480/all-approaches-brute-to-optimized-kadane-s-algo/?orderBy=newest_to_oldest) "
                    }
                ]
            }
        ]
    },
    {
        "title": "Make K-Subarray Sums Equal",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>arr</code> and an integer <code>k</code>. The array <code>arr</code> is circular. In other words, the first element of the array is the next element of the last element, and the last element of the array is the previous element of the first element.</p>\n\n<p>You can do the following operation any number of times:</p>\n\n<ul>\n\t<li>Pick any element from <code>arr</code> and increase or decrease it by <code>1</code>.</li>\n</ul>\n\n<p>Return <em>the minimum number of operations such that the sum of each <strong>subarray</strong> of length </em><code>k</code><em> is equal</em>.</p>\n\n<p>A <strong>subarray</strong> is a contiguous part of the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [1,4,1,3], k = 2\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> we can do one operation on index 1 to make its value equal to 3.\nThe array after the operation is [1,3,1,3]\n- Subarray starts at index 0 is [1, 3], and its sum is 4 \n- Subarray starts at index 1 is [3, 1], and its sum is 4 \n- Subarray starts at index 2 is [1, 3], and its sum is 4 \n- Subarray starts at index 3 is [3, 1], and its sum is 4 \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [2,5,5,7], k = 3\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> we can do three operations on index 0 to make its value equal to 5 and two operations on index 3 to make its value equal to 5.\nThe array after the operations is [5,5,5,5]\n- Subarray starts at index 0 is [5, 5, 5], and its sum is 15\n- Subarray starts at index 1 is [5, 5, 5], and its sum is 15\n- Subarray starts at index 2 is [5, 5, 5], and its sum is 15\n- Subarray starts at index 3 is [5, 5, 5], and its sum is 15 \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3366373,
                "title": "k-cycles",
                "content": "The sum of all subarrays of size `k` is equal if:\\n- `arr[i] == arr[i + k]`\\n- `arr[i] == arr[i + 2 * k]`\\n- and so on.\\n    \\nAs we roll a window of size `k`, we remove element `arr[i]` and add element `arr[i + k]`.\\n\\nFor the sum to stay the same, the removed and added element must be the same. This can be also proven by a contradiction. \\n\\nSo, for each position `i`, we collect all elements in the `k`-cycle.\\n    \\nThen, we determine the median and perform operations to make all elements equal to that median. \\n\\n**C++**  \\nWe use `nth_element` instead of sorting to find a median in O(n) in an average case.\\n```cpp\\nlong long makeSubKSumEqual(vector<int>& arr, int k) {\\n    long long sz = arr.size(), res = 0;\\n    for (int i = 0; i < k; ++i) {\\n        vector<int> cycle;\\n        for (int j = i; arr[j] != 0; j = (j + k) % sz) {\\n            cycle.push_back(arr[j]);\\n            arr[j] = 0;\\n        }\\n        nth_element(begin(cycle), begin(cycle) + cycle.size() / 2, end(cycle));\\n        for (int n : cycle)\\n            res += abs(n - cycle[cycle.size() / 2]);\\n    }\\n    return res;\\n}\\n```\\n\\n**Python 3**\\nOne-liner just for fun. Note that here we use `gcd(len(a), k)` to get all elements in the cycle instead of looping over a circular array.\\n```python\\nclass Solution:\\n    def makeSubKSumEqual(self, a: List[int], k: int) -> int:\\n        return sum(\\n            sum(abs(n - c[len(c) // 2]) for n in c)\\n            for c in [sorted(a[i::gcd(len(a), k)]) for i in range(gcd(len(a), k))]\\n        )\\n```\\n\\n**Java**\\nThe complexity is O(sort); we use sort because Java does not provide a standard quickselect implementation.\\n```java\\npublic long makeSubKSumEqual(int[] arr, int k) {\\n    long res = 0;\\n    for (int i = 0; i < k; ++i) {\\n        List<Integer> cycle = new ArrayList<>();\\n        for (int j = i; arr[j] != 0; j = (j + k) % arr.length) {\\n            cycle.add(arr[j]);\\n            arr[j] = 0;\\n        }\\n        Collections.sort(cycle);\\n        for (int n : cycle)\\n            res += Math.abs(n - cycle.get(cycle.size() / 2));\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nlong long makeSubKSumEqual(vector<int>& arr, int k) {\\n    long long sz = arr.size(), res = 0;\\n    for (int i = 0; i < k; ++i) {\\n        vector<int> cycle;\\n        for (int j = i; arr[j] != 0; j = (j + k) % sz) {\\n            cycle.push_back(arr[j]);\\n            arr[j] = 0;\\n        }\\n        nth_element(begin(cycle), begin(cycle) + cycle.size() / 2, end(cycle));\\n        for (int n : cycle)\\n            res += abs(n - cycle[cycle.size() / 2]);\\n    }\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def makeSubKSumEqual(self, a: List[int], k: int) -> int:\\n        return sum(\\n            sum(abs(n - c[len(c) // 2]) for n in c)\\n            for c in [sorted(a[i::gcd(len(a), k)]) for i in range(gcd(len(a), k))]\\n        )\\n```\n```java\\npublic long makeSubKSumEqual(int[] arr, int k) {\\n    long res = 0;\\n    for (int i = 0; i < k; ++i) {\\n        List<Integer> cycle = new ArrayList<>();\\n        for (int j = i; arr[j] != 0; j = (j + k) % arr.length) {\\n            cycle.add(arr[j]);\\n            arr[j] = 0;\\n        }\\n        Collections.sort(cycle);\\n        for (int n : cycle)\\n            res += Math.abs(n - cycle.get(cycle.size() / 2));\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366442,
                "title": "python3-find-median-of-each-gcd-defined-subarray-w-examples",
                "content": "# First Thought\\nAny na\\xEFve checking algorithm would not work here as both `k` and `n (= arr.length)` could be up to $$10^5$$.\\n\\nSo, how can we come up with a better algorithm with improved time complexity?\\n\\n# Key Intuition\\nLet\\u2019s first look at a toy example by assuming `k = 3`. Because the problem requires the sum of each subarray of length `k` to be equal, we then need to have `arr[0] + arr[1] + arr[2] = arr[1] + arr[2] + arr[3]`, which implies that `arr[0] = arr[3]`. Essentially, this is saying that every `k`-th element of `arr` needs to be equal after all operations.\\n\\nThere is one caveat yet to make the argument complete: In this problem `arr` is not only a regular array but also a circular array. Suppose `n = 6` and `k = 4`, we need to have every `gcd(n, k) = gcd(6, 4) = 2`-th element of `arr` to be equal after all operations.\\n\\n# Representative Examples\\n![LC2607_resize.jpeg](https://assets.leetcode.com/users/images/24f7cdb9-ced7-4786-b22d-1735f9acb90f_1680366540.215105.jpeg)\\n\\n# Approach\\nFirst, we compute the greatest common divisor of `n` and `k`, denoted as `gcd`. For every `gcd`-th element of `arr`, we store it in a temporary array `tmp`, such that the problem reduces to finding the minimum number operations to make all elements in each of `tmp` equal.\\n\\nFor this sub-problem, we can sort the subarray `tmp` and find its median, which contributes to the final `ans` after operations.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$, could be improved to $$O(n)$$ on average;\\n\\n- Space complexity: $$O(n)$$.\\n\\n**Please upvote if you find this solution helpful. Thanks!**\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        gcd = math.gcd(n, k)\\n        ans = 0\\n        for i in range(gcd):\\n            tmp = sorted([arr[j] for j in range(i, n, gcd)])\\n            median = tmp[len(tmp) // 2]\\n            ans += sum(abs(num - median) for num in tmp)\\n        return ans\\n```\\n\\n# Follow-up (Bonus)\\nWe can potentially improve the average time complexity by applying quick-select to each of the subarray problem in finding the median.",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        gcd = math.gcd(n, k)\\n        ans = 0\\n        for i in range(gcd):\\n            tmp = sorted([arr[j] for j in range(i, n, gcd)])\\n            median = tmp[len(tmp) // 2]\\n            ans += sum(abs(num - median) for num in tmp)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367765,
                "title": "explaining-like-you-are-five-years-old",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n[1,4,1,3]\\n\\nIt is a Circular Array, What are the possible subarray sums \\n```\\na. 1 + 4 = 5\\nb.     4 + 1 = 5\\nc.         1 + 3 = 4\\nd.             3 + 1 = 4\\n```\\n\\nFrom above you can understand the num which goes in should be equal to number which goes out.\\n\\n1 should be equal to 1\\n3 should be equal to 4\\n\\nIn case b, 1 (index = 2) gets in the window  and 1 (index = 0) gets out which are same.\\nIn case c,  3 (index = 3) gets in the window and 4 (index = 1) gets out which are not same.\\n\\n\\nHence we could have grouped them [1, 1] [3, 4] in these buckets and same they should be same to make subarray equal.\\n\\n**suppose k is 2**\\n\\n\\nWe need to know as array is circular, when we complete run in next run the start index will be different or not if yes what are the element which should be equal - That\\'s where GCD comes in.\\n\\n\\n```\\n        [1, 4, 1, 3]\\nstep 1   ^     ^ \\n\\n```\\n\\n\\n`^` these are pointers now if the array is circular and you take the pointer skipping one element the pointers will end again on 1 and 1, \\n\\ngcd (4, 2) = 2 which means there will be 2 buckets and every number will be put in after skipping one.\\n\\nbucket 1 = [1, 1]\\nbucket 2 = [3, 4]\\n\\n\\n**suppose k is 3**\\n```\\n        [2, 5, 5, 7]\\nstep 1   ^        ^\\nstep 2      ^  ^\\n```\\nThese where we use gcd to find buckets gcd (4, 3) = 1 which means there will be one bucket and every other number will be in it\\n\\nbucket 1 =  [2, 5, 5, 7]\\n\\n\\nNow the simplest task making each bucket equal\\n- The optimal way to do this is use gready approach and use median to find minimum operations to make numbers equal\\n\\n#### For example 1\\n\\n\\nmedian = sorted([4, 3]) = [3, 4] = 4\\nget absolute difference from all numbers in array which will be one (3 - 4) + (4 - 4) = 1\\n\\n**You have to do same operation on all buckets but elements in bucket 1 are same it will just give 0**\\n\\n#### For example 2\\n\\nmedian = sorted([2, 5, 5, 7]) = [2, 5, 5, 7] = 5\\nget absolute difference from all numbers in array which will be one (2 - 5) + (5 - 5) + (5 - 5)  + (7 - 5) = 5\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n`O(N) + O(K * KlogK)`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(N)`\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        n = len(arr)\\n\\n        no_of_buckets = gcd (k, n)\\n        buckets = defaultdict(list)\\n\\n        for ind, num in enumerate(arr):\\n            buckets[ind % no_of_buckets].append(num)\\n\\n        result = 0\\n        for bucket_number, bucket in buckets.items():\\n            sorted_bucket = sorted(bucket)\\n            m = len(sorted_bucket)\\n            median = sorted_bucket[(m)//2]\\n            \\n            for num in bucket:\\n                result += abs(median - num)\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\na. 1 + 4 = 5\\nb.     4 + 1 = 5\\nc.         1 + 3 = 4\\nd.             3 + 1 = 4\\n```\n```\\n        [1, 4, 1, 3]\\nstep 1   ^     ^ \\n\\n```\n```\\n        [2, 5, 5, 7]\\nstep 1   ^        ^\\nstep 2      ^  ^\\n```\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        n = len(arr)\\n\\n        no_of_buckets = gcd (k, n)\\n        buckets = defaultdict(list)\\n\\n        for ind, num in enumerate(arr):\\n            buckets[ind % no_of_buckets].append(num)\\n\\n        result = 0\\n        for bucket_number, bucket in buckets.items():\\n            sorted_bucket = sorted(bucket)\\n            m = len(sorted_bucket)\\n            median = sorted_bucket[(m)//2]\\n            \\n            for num in bucket:\\n                result += abs(median - num)\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372935,
                "title": "explained-gcd-median-very-simple-and-easy-to-understand-solution",
                "content": "# Approach \\nWe have to make equal each ith element and (i+k)th element here,  so that\\nwe awill get same value at eleast once on each window of size k.\\n\\nNo here is a ctach, when the arr.size is not divisible by k, we need to \\ncheck what is the max possible size that can be repeated in the \\narray which confirm presence of same element in each window.\\nTo do this we need to take the most common element that devides both k and \\narr.size => which is equal to their gcd.\\n\\nSo now the steps to the solution will be :\\n1. Take gcd as the new value of k as the gcd of k & arr.size()\\n2. Then iterate from 0 to k, and on each iteration collect the i + k, i +2k and so on ..\\n3. Then sort the elements collected and get the midian values. As to get a min cumulative summ midian can be used to equate with all other elements.\\n4. Make all elements equal to median and evaluate the operation cost for the same.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        k = __gcd(k, (int)arr.size()); //re-evaluate k as the gcd of both k & arr.size\\n        \\n        for(int i = 0; i < k; ++i){\\n            vector<int> v;\\n            for(int j = i; j < arr.size(); j += k) v.push_back(arr[j]);  //collect each ith number\\n            sort(v.begin(), v.end());    //sort the collection to get median\\n            int mn = v[v.size()/2];      //get the median value\\n            for(int j = i; j < arr.size(); j += k) ans += abs(mn - arr[j]); // evaluate the ans by making all values equal to median\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        k = __gcd(k, (int)arr.size()); //re-evaluate k as the gcd of both k & arr.size\\n        \\n        for(int i = 0; i < k; ++i){\\n            vector<int> v;\\n            for(int j = i; j < arr.size(); j += k) v.push_back(arr[j]);  //collect each ith number\\n            sort(v.begin(), v.end());    //sort the collection to get median\\n            int mn = v[v.size()/2];      //get the median value\\n            for(int j = i; j < arr.size(); j += k) ans += abs(mn - arr[j]); // evaluate the ans by making all values equal to median\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367285,
                "title": "easy-video-explanation-hindi-o-n-log-n-c",
                "content": "I would sugget you to watch the video and then read the code for better understanding \\nHindi Video Explanation :- [https://youtu.be/4fvwsGdBdok]()\\n\\n# Complexity\\n- Time complexity:\\n- O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n long long find(int val,vector<int>&arr){\\n     \\n     //findind the cost of making all values equal to val\\n     //in arr\\n     long long ans = 0;\\n     \\n     for(auto&x:arr){\\n         long long cur = abs(x-val);\\n         ans += cur;\\n     }\\n     \\n     return ans;\\n }\\n\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n       \\n        int n = arr.size();\\n        long long ans = 1e18;\\n         \\n             ans = 0;\\n            vector<int>vis(n);\\n             \\n            for(int i = 0;i<n;++i){\\n                if(vis[i])continue;\\n                \\n                \\n                vector<int>temp;\\n                long long tot = 0;\\n                int idx = i;\\n                \\n                //we are starting from index \\'i\\'\\n                //we will run while loop until we reach to some visited node\\n                \\n                while(!vis[idx]){\\n                    long long val = arr[idx];\\n                    vis[idx]++;\\n                    idx += k;\\n                    idx%=n;\\n                    tot += val;\\n                    //adding the values of cycle in temp array\\n                    temp.push_back(val);\\n                }\\n                \\n                long long cur = 0;\\n                \\n                //sorting the temp array because it is optimal to make \\n                //all elements equal to middle element of sorted arry\\n                sort(temp.begin(),temp.end());\\n                int sz = temp.size();\\n                \\n                //if array if of odd size then we have just 1 middle element\\n                if(sz%2){\\n                    int mid = (sz/2);\\n                    cur = find(temp[mid],temp);\\n                }\\n                else{\\n                    //for even size we have two middle values\\n                    int mid = (sz/2);\\n                    cur = find(temp[mid],temp);\\n                    cur = min(cur,find(temp[mid-1],temp));\\n                }\\n                 \\n                ans += cur;\\n            }\\n         \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n long long find(int val,vector<int>&arr){\\n     \\n     //findind the cost of making all values equal to val\\n     //in arr\\n     long long ans = 0;\\n     \\n     for(auto&x:arr){\\n         long long cur = abs(x-val);\\n         ans += cur;\\n     }\\n     \\n     return ans;\\n }\\n\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n       \\n        int n = arr.size();\\n        long long ans = 1e18;\\n         \\n             ans = 0;\\n            vector<int>vis(n);\\n             \\n            for(int i = 0;i<n;++i){\\n                if(vis[i])continue;\\n                \\n                \\n                vector<int>temp;\\n                long long tot = 0;\\n                int idx = i;\\n                \\n                //we are starting from index \\'i\\'\\n                //we will run while loop until we reach to some visited node\\n                \\n                while(!vis[idx]){\\n                    long long val = arr[idx];\\n                    vis[idx]++;\\n                    idx += k;\\n                    idx%=n;\\n                    tot += val;\\n                    //adding the values of cycle in temp array\\n                    temp.push_back(val);\\n                }\\n                \\n                long long cur = 0;\\n                \\n                //sorting the temp array because it is optimal to make \\n                //all elements equal to middle element of sorted arry\\n                sort(temp.begin(),temp.end());\\n                int sz = temp.size();\\n                \\n                //if array if of odd size then we have just 1 middle element\\n                if(sz%2){\\n                    int mid = (sz/2);\\n                    cur = find(temp[mid],temp);\\n                }\\n                else{\\n                    //for even size we have two middle values\\n                    int mid = (sz/2);\\n                    cur = find(temp[mid],temp);\\n                    cur = min(cur,find(temp[mid-1],temp));\\n                }\\n                 \\n                ans += cur;\\n            }\\n         \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366388,
                "title": "best-concise-solution-and-easy-to-understand-c",
                "content": "# Approach\\nIf n is divisible by k then perform the following otherwise update k to gcd of n and k (by observation)\\n\\nNow , for every element at a gap of k make them equal by subtracting all these numbers by their median we can do that by sorting all the elements and taking its middle to get the median\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n    \\n        k = __gcd(k , n);\\n        \\n        //due to circular array the gap k will be converted to gcd of\\n        // k and n by observation (check for n = 15 , k = 6 , and find out)\\n        for(int i=0;i<k;i++) {\\n            vector<int> v;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                v.push_back(arr[j]);\\n            }\\n            \\n            sort(v.begin() , v.end());\\n            //taking the mid value of the sorted array to get the \\n            //median as it will require minimum operation to convert \\n            //all elements to the medain value\\n            long long midv = v[v.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n    \\n        k = __gcd(k , n);\\n        \\n        //due to circular array the gap k will be converted to gcd of\\n        // k and n by observation (check for n = 15 , k = 6 , and find out)\\n        for(int i=0;i<k;i++) {\\n            vector<int> v;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                v.push_back(arr[j]);\\n            }\\n            \\n            sort(v.begin() , v.end());\\n            //taking the mid value of the sorted array to get the \\n            //median as it will require minimum operation to convert \\n            //all elements to the medain value\\n            long long midv = v[v.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366378,
                "title": "java-python-3-divide-into-sequences-such-that-every-two-consecutive-items-s-distance-is-gcd",
                "content": "**Intuition:**\\nAll `k`-size subarrays are equal  => \\n`sum(arr[0,...,k- 1]) == sum(arr[1,...,k])` =>\\n`arr[0] == arr[k]`\\n\\nsimilarly, we can conclude that `arr[i] = arr[i + k]`, further more, `arr` is **circular** array, hence we need stronger condition than `arr[i] = arr[i + k]`: only `gcd(k, arr.length)` to guarantee both **circular** and all `k`-size subarrays are equal.\\n\\n----\\n\\n1. Compute the `gcd` of `arr.length`and `k`;\\n2. The numbers in `arr` must be equal if their indices differenece is the multiple of the aforementioned `gcd`, in order to make all of the k-size subarray sums are equal; Therefore, in `arr` select each item every `gcd` index difference to construct a sequence, and there are totally `arr.length / gcd` such sequences;\\n3. In order to make the sequence equal, we need to get each sequence sorted and compute the needed minimum opertations.\\n\\n```java\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int gcd = gcd(arr.length, k);\\n        long minOps = 0;\\n        for (int i = 0; i < gcd; ++i) {\\n            minOps += getOperationsCount(arr, i, gcd);\\n        }\\n        return minOps;\\n    }\\n    private int gcd(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        return x;\\n    }\\n    private long getOperationsCount(int[] arr, int start, int gap) {\\n        int n = arr.length, m = n / gap;\\n        long min = Long.MAX_VALUE, sum = 0, cur = 0;\\n        int[] a = new int[m];\\n        for (int i = start, k = 0; i < n; i += gap, ++k) {\\n            a[k] = arr[i];\\n            sum += a[k];\\n        }\\n        Arrays.sort(a);\\n        for (int i = 0; i < m; ++i) {\\n            min = Math.min(min, (1L * i * a[i] - cur) + ((sum - cur) - 1L * (m - i) * a[i]));\\n            cur += a[i];\\n        }\\n        return min;\\n    }\\n```\\n```python\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        def getOperationsCount(arr: List[int]) -> int:\\n            sm, n = sum(arr), len(arr)\\n            mi = inf\\n            cur = 0\\n            for i, num in enumerate(sorted(arr)):\\n                mi = min(mi, (i * num - cur) + ((sm - cur) - (n - i) * num))\\n                cur += num\\n            return mi    \\n        \\n        gcd = math.gcd(len(arr), k)\\n        return sum(getOperationsCount(arr[i :: gcd]) for i in range(gcd))\\n```\\n\\nThe above codes can be simplified as follows:\\n\\n```java\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int gcd = gcd(arr.length, k);\\n        long minOps = 0;\\n        for (int i = 0; i < gcd; ++i) {\\n            minOps += getOperationsCount(arr, i, gcd);\\n        }\\n        return minOps;\\n    }\\n    private int gcd(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        return x;\\n    }\\n    private long getOperationsCount(int[] arr, int start, int gap) {\\n        int n = arr.length, m = n / gap;\\n        long sum = 0;\\n        int[] a = new int[m];\\n        for (int i = start, k = 0; i < n; i += gap, ++k) {\\n            a[k] = arr[i];\\n        }\\n        Arrays.sort(a);\\n        for (int i = 0, mid = m / 2; i < m; ++i) {\\n            sum += Math.abs(a[i] - a[mid]);\\n        }\\n        return sum;\\n    }\\n```\\n```python\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        def getOperationsCount(arr: List[int]) -> int:\\n            return sum(abs(a - arr[len(arr) // 2]) for a in arr)    \\n        \\n        gcd = math.gcd(len(arr), k)\\n        return sum(getOperationsCount(sorted(arr[i :: gcd])) for i in range(gcd))\\n```\\n\\n**Analysis:**\\n\\nSorting is the major part of the time cost, therefore\\n\\nTime: `O(nlogn)`, space: `O(n / gcd(n, k))`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int gcd = gcd(arr.length, k);\\n        long minOps = 0;\\n        for (int i = 0; i < gcd; ++i) {\\n            minOps += getOperationsCount(arr, i, gcd);\\n        }\\n        return minOps;\\n    }\\n    private int gcd(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        return x;\\n    }\\n    private long getOperationsCount(int[] arr, int start, int gap) {\\n        int n = arr.length, m = n / gap;\\n        long min = Long.MAX_VALUE, sum = 0, cur = 0;\\n        int[] a = new int[m];\\n        for (int i = start, k = 0; i < n; i += gap, ++k) {\\n            a[k] = arr[i];\\n            sum += a[k];\\n        }\\n        Arrays.sort(a);\\n        for (int i = 0; i < m; ++i) {\\n            min = Math.min(min, (1L * i * a[i] - cur) + ((sum - cur) - 1L * (m - i) * a[i]));\\n            cur += a[i];\\n        }\\n        return min;\\n    }\\n```\n```python\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        def getOperationsCount(arr: List[int]) -> int:\\n            sm, n = sum(arr), len(arr)\\n            mi = inf\\n            cur = 0\\n            for i, num in enumerate(sorted(arr)):\\n                mi = min(mi, (i * num - cur) + ((sm - cur) - (n - i) * num))\\n                cur += num\\n            return mi    \\n        \\n        gcd = math.gcd(len(arr), k)\\n        return sum(getOperationsCount(arr[i :: gcd]) for i in range(gcd))\\n```\n```java\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int gcd = gcd(arr.length, k);\\n        long minOps = 0;\\n        for (int i = 0; i < gcd; ++i) {\\n            minOps += getOperationsCount(arr, i, gcd);\\n        }\\n        return minOps;\\n    }\\n    private int gcd(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        return x;\\n    }\\n    private long getOperationsCount(int[] arr, int start, int gap) {\\n        int n = arr.length, m = n / gap;\\n        long sum = 0;\\n        int[] a = new int[m];\\n        for (int i = start, k = 0; i < n; i += gap, ++k) {\\n            a[k] = arr[i];\\n        }\\n        Arrays.sort(a);\\n        for (int i = 0, mid = m / 2; i < m; ++i) {\\n            sum += Math.abs(a[i] - a[mid]);\\n        }\\n        return sum;\\n    }\\n```\n```python\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        def getOperationsCount(arr: List[int]) -> int:\\n            return sum(abs(a - arr[len(arr) // 2]) for a in arr)    \\n        \\n        gcd = math.gcd(len(arr), k)\\n        return sum(getOperationsCount(sorted(arr[i :: gcd])) for i in range(gcd))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3366408,
                "title": "subarray-gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n = arr.size();\\n        k = gcd(n,k);\\n        ll ans = 0;\\n        for(ll i = 0; i < k; i++)\\n        {\\n            vector <ll> vec;\\n            for(ll j = i; j < n; j+=k)\\n                vec.push_back(arr[j]);\\n            sort(vec.begin(),vec.end());\\n            ll mid = vec.size()/2;\\n            for(ll ind = 0; ind < vec.size(); ind++)\\n                ans+=abs(vec[mid]-vec[ind]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Combinatorics"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n = arr.size();\\n        k = gcd(n,k);\\n        ll ans = 0;\\n        for(ll i = 0; i < k; i++)\\n        {\\n            vector <ll> vec;\\n            for(ll j = i; j < n; j+=k)\\n                vec.push_back(arr[j]);\\n            sort(vec.begin(),vec.end());\\n            ll mid = vec.size()/2;\\n            for(ll ind = 0; ind < vec.size(); ind++)\\n                ans+=abs(vec[mid]-vec[ind]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3366625,
                "title": "day-366-python-java-c-explained-intuition-algorithm-100-beats-o-n-o-1",
                "content": "# Please Upvote as it really motivates me\\n\\n##### \\u2022\\tThe problem statement is to make the sum of all subarrays of length k equal changing the elements of the array. The approach used in this problem is to group the elements of the array into k subarrays based on their remainder when divided by k. Then, for each subarray, the median value is calculated and the absolute difference between each element in the subarray and the median is added to the total answer.\\n\\n##### \\u2022\\tHere is the step-by-step algorithm:\\n##### \\u2022\\tInitialize a list of k subarrays.\\n##### \\u2022\\tCalculate the greatest common divisor of n and k, where n is the length of the input array.\\n##### \\u2022\\tGroup the elements of the input array into k subarrays based on their remainder when divided by k.\\n##### \\u2022\\tFor each subarray, sort the elements and calculate the median value.\\n##### \\u2022\\tFor each element in the subarray, calculate the absolute difference between the element and the median value, and add it to the total answer.\\n##### \\u2022\\tReturn the total answer.\\n\\n##### \\u2022\\tThe intuition behind this problem is that by grouping the elements into subarrays based on their remainder when divided by k, we can ensure that each subarray has the same number of elements. Then, by calculating the median value of each subarray, we can find a representative value that is close to the center of the subarray. By minimizing the absolute difference between each element and the median value, we can make the sum of all subarrays of length k equal.\\n\\n\\n\\n# Code\\n```python []\\nclass Solution:\\n    def makeSubKSumEqual(self,arr, k):\\n        n = len(arr)\\n        v = [[] for i in range(n + 1)]\\n        k = gcd(n, k)\\n        for i in range(n):\\n            v[i % k].append(arr[i])\\n        ans = 0\\n        for i in range(k):\\n            v[i].sort()\\n            x = v[i][len(v[i]) // 2]\\n            for j in v[i]:\\n                ans += abs(x - j)\\n        return ans\\n\\n    def gcd(a, b):\\n        if b == 0:\\n            return a\\n        return gcd(b, a % b)\\n```\\n\\n```java []\\nclass Solution{\\n    public static long makeSubKSumEqual(int[] arr, int k) {\\n    int n = arr.length;\\n    List<Integer>[] v = new ArrayList[n + 1];\\n    for (int i = 0; i <= n; i++) {\\n        v[i] = new ArrayList<>();\\n    }\\n    k = gcd(n, k);\\n    for (int i = 0; i < n; i++) {\\n        v[i % k].add(arr[i]);\\n    }\\n    long ans = 0;\\n    for (int i = 0; i < k; i++) {\\n        Collections.sort(v[i]);\\n        int x = v[i].get(v[i].size() / 2);\\n        for (int j : v[i]) {\\n            ans += Math.abs(x - j);\\n        }\\n    }\\n    return ans;\\n}\\n\\nprivate static int gcd(int a, int b) {\\n    if (b == 0) {\\n        return a;\\n    }\\n    return gcd(b, a % b);\\n}\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size() ;\\n        vector<int>v[n+1] ;\\n        k = __gcd(n , k) ;\\n        for(int i = 0 ; i < n ; ++i)\\n            v[i%k].push_back(arr[i]) ;\\n        long long ans = 0 ;\\n        for(int i = 0 ; i < k ; ++i)\\n        {\\n            sort(v[i].begin() , v[i].end()) ;\\n            int x = v[i][v[i].size() / 2] ;\\n            for(auto &j : v[i])\\n                ans += abs(x-j) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n\\n\\n\\n# Complexity\\n\\n##### \\u2022\\tThe time complexity (TC) of this algorithm is O(n log n), where n is the length of the input array. This is because the algorithm involves sorting each subarray, which takes O(k log k) time, where k is the size of each subarray. Since there are n/k subarrays, the total time complexity is O(n log k). However, since k is the greatest common divisor of n and k, it is at most n/2. Therefore, the time complexity can be simplified to O(n log n).\\n\\n##### \\u2022\\tThe space complexity (SC) of this algorithm is O(n), where n is the length of the input array. This is because the algorithm creates a list of k subarrays, each of which can contain up to n/k elements. Therefore, the total space complexity is O(n).\\n\\n# 2ND WAY\\n```C++ []\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> v[n+1];\\n        k = __gcd(n, k);\\n        for (int i = 0; i < n; ++i) {\\n            v[i%k].push_back(arr[i]);\\n        }\\n        long long ans = 0;\\n        for (int i = 0; i < k; ++i) {\\n            int median = quickselect(v[i], v[i].size() / 2);\\n            for (auto &j : v[i]) {\\n                ans += abs(median - j);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int quickselect(vector<int>& nums, int k) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int pivotIndex = partition(nums, left, right);\\n            if (pivotIndex == k) {\\n                return nums[k];\\n            } else if (pivotIndex < k) {\\n                left = pivotIndex + 1;\\n            } else {\\n                right = pivotIndex - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int partition(vector<int>& nums, int left, int right) {\\n        int pivotIndex = left + (right - left) / 2;\\n        int pivotValue = nums[pivotIndex];\\n        swap(nums[pivotIndex], nums[right]);\\n        int storeIndex = left;\\n        for (int i = left; i < right; i++) {\\n            if (nums[i] < pivotValue) {\\n                swap(nums[i], nums[storeIndex]);\\n                storeIndex++;\\n            }\\n        }\\n        swap(nums[storeIndex], nums[right]);\\n        return storeIndex;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public longSubKSumEqual(int[] arr, int k) {\\n        int n = arr.length;\\n        List<Integer>[] v = new List[n+1];\\n        for (int i = 0; i <= n; i++) {\\n            v[i] = new ArrayList<>();\\n        }\\n        k = gcd(n, k);\\n        for (int i = 0; i < n; i++) {\\n            v[i%k].add(arr[i]);\\n        }\\n        long ans = 0;\\n        for (int i = 0; i < k; i++) {\\n            int median = quickselect(v[i], v[i].size() / 2);\\n            for (int j : v[i]) {\\n                ans += Math.abs(median - j);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int quickselect(List<Integer> nums, int k) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int pivotIndex = partition(nums, left, right);\\n            if (pivotIndex == k) {\\n                return nums.get(k);\\n            } else if (pivotIndex < k) {\\n                left = pivotIndex + 1;\\n            } else {\\n                right = pivotIndex - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int partition(List<Integer> nums, int left, int right) {\\n        int pivotIndex = left + (right - left) / 2;\\n        int pivotValue = nums.get(pivotIndex);\\n        Collections.swap(nums, pivotIndex, right);\\n        int storeIndex = left;\\n        for (int i = left; i < right; i++) {\\n            if (nums.get(i) < pivotValue) {\\n                Collections.swap(nums, i, storeIndex);\\n                storeIndex++;\\n            }\\n        }\\n        Collections.swap(nums, storeIndex, right);\\n        return storeIndex;\\n    }\\n\\n    private int gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        v = [[] for i in range(n + 1)]\\n        k = gcd(n, k)\\n        for i in range(n):\\n            v[i % k].append(arr[i])\\n        ans = 0\\n        for i in range(k):\\n            median = self.quickselect(v[i], len(v[i]) // 2)\\n            for j in v[i]:\\n                ans += abs(median - j)\\n        return ans\\n\\n    def quickselect(self, nums: List[int], k: int) -> int:\\n        left, right = 0, len(nums) - 1\\n        while left <= right:\\n            pivotIndex = self.partition(nums, left, right)\\n            if pivotIndex == k:\\n                return nums[k]\\n            elif pivotIndex < k:\\n                left = pivotIndex + 1\\n            else:\\n                right = pivotIndex - 1\\n        return -1\\n\\n    def partition(self, nums: List[int], left: int, right: int) -> int:\\n        pivotIndex = left + (right - left) // 2\\n        pivotValue = nums[pivotIndex]\\n        nums[pivotIndex], nums[right] = nums[right], nums[pivotIndex]\\n        storeIndex = left\\n        for i in range(left, right):\\n            if nums[i] < pivotValue:\\n                nums[i], nums[storeIndex] = nums[storeIndex], nums[i]\\n                storeIndex += 1\\n        nums[storeIndex], nums[right] = nums[right], nums[storeIndex]\\n        return storeIndex\\n\\n    def gcd(self, a: int, b: int) -> int:\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a % b)\\n```\\nThe time complexity of the optimized makeSubKSumEqual function is O log n), where n is the length of the input array arr . This is because the function performs a quickselect operation on each subarray, which has an average time complexity of O(n), and then iterates through each subarray to calculate the absolute difference between each element and the median. The sorting operation in the original code has been replaced by the quickselect operation, which is more efficient for finding the median.\\n\\nThe space complexity of the function is O(n), which is the space required to store the subarrays in the \\nv\\n vector. The quickselect algorithm has a space complexity of O(1) because it operates on the input array in place.\\n\\nOverall, the optimized solution has a better time complexity than the original solution, but the space complexity remains the same.\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n##### \\u2022 Thanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\n##### \\u2022 Please give my solution an upvote! \\uD83D\\uDC4D\\n##### \\u2022 It\\'s a simple way to show your appreciation and\\n\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n[My post here ](https://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3366625/day-366-python-java-c-explained-intuition-algorithm-100-beats/?orderBy=hot) \\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def makeSubKSumEqual(self,arr, k):\\n        n = len(arr)\\n        v = [[] for i in range(n + 1)]\\n        k = gcd(n, k)\\n        for i in range(n):\\n            v[i % k].append(arr[i])\\n        ans = 0\\n        for i in range(k):\\n            v[i].sort()\\n            x = v[i][len(v[i]) // 2]\\n            for j in v[i]:\\n                ans += abs(x - j)\\n        return ans\\n\\n    def gcd(a, b):\\n        if b == 0:\\n            return a\\n        return gcd(b, a % b)\\n```\n```java []\\nclass Solution{\\n    public static long makeSubKSumEqual(int[] arr, int k) {\\n    int n = arr.length;\\n    List<Integer>[] v = new ArrayList[n + 1];\\n    for (int i = 0; i <= n; i++) {\\n        v[i] = new ArrayList<>();\\n    }\\n    k = gcd(n, k);\\n    for (int i = 0; i < n; i++) {\\n        v[i % k].add(arr[i]);\\n    }\\n    long ans = 0;\\n    for (int i = 0; i < k; i++) {\\n        Collections.sort(v[i]);\\n        int x = v[i].get(v[i].size() / 2);\\n        for (int j : v[i]) {\\n            ans += Math.abs(x - j);\\n        }\\n    }\\n    return ans;\\n}\\n\\nprivate static int gcd(int a, int b) {\\n    if (b == 0) {\\n        return a;\\n    }\\n    return gcd(b, a % b);\\n}\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size() ;\\n        vector<int>v[n+1] ;\\n        k = __gcd(n , k) ;\\n        for(int i = 0 ; i < n ; ++i)\\n            v[i%k].push_back(arr[i]) ;\\n        long long ans = 0 ;\\n        for(int i = 0 ; i < k ; ++i)\\n        {\\n            sort(v[i].begin() , v[i].end()) ;\\n            int x = v[i][v[i].size() / 2] ;\\n            for(auto &j : v[i])\\n                ans += abs(x-j) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int> v[n+1];\\n        k = __gcd(n, k);\\n        for (int i = 0; i < n; ++i) {\\n            v[i%k].push_back(arr[i]);\\n        }\\n        long long ans = 0;\\n        for (int i = 0; i < k; ++i) {\\n            int median = quickselect(v[i], v[i].size() / 2);\\n            for (auto &j : v[i]) {\\n                ans += abs(median - j);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int quickselect(vector<int>& nums, int k) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int pivotIndex = partition(nums, left, right);\\n            if (pivotIndex == k) {\\n                return nums[k];\\n            } else if (pivotIndex < k) {\\n                left = pivotIndex + 1;\\n            } else {\\n                right = pivotIndex - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int partition(vector<int>& nums, int left, int right) {\\n        int pivotIndex = left + (right - left) / 2;\\n        int pivotValue = nums[pivotIndex];\\n        swap(nums[pivotIndex], nums[right]);\\n        int storeIndex = left;\\n        for (int i = left; i < right; i++) {\\n            if (nums[i] < pivotValue) {\\n                swap(nums[i], nums[storeIndex]);\\n                storeIndex++;\\n            }\\n        }\\n        swap(nums[storeIndex], nums[right]);\\n        return storeIndex;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public longSubKSumEqual(int[] arr, int k) {\\n        int n = arr.length;\\n        List<Integer>[] v = new List[n+1];\\n        for (int i = 0; i <= n; i++) {\\n            v[i] = new ArrayList<>();\\n        }\\n        k = gcd(n, k);\\n        for (int i = 0; i < n; i++) {\\n            v[i%k].add(arr[i]);\\n        }\\n        long ans = 0;\\n        for (int i = 0; i < k; i++) {\\n            int median = quickselect(v[i], v[i].size() / 2);\\n            for (int j : v[i]) {\\n                ans += Math.abs(median - j);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int quickselect(List<Integer> nums, int k) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left <= right) {\\n            int pivotIndex = partition(nums, left, right);\\n            if (pivotIndex == k) {\\n                return nums.get(k);\\n            } else if (pivotIndex < k) {\\n                left = pivotIndex + 1;\\n            } else {\\n                right = pivotIndex - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int partition(List<Integer> nums, int left, int right) {\\n        int pivotIndex = left + (right - left) / 2;\\n        int pivotValue = nums.get(pivotIndex);\\n        Collections.swap(nums, pivotIndex, right);\\n        int storeIndex = left;\\n        for (int i = left; i < right; i++) {\\n            if (nums.get(i) < pivotValue) {\\n                Collections.swap(nums, i, storeIndex);\\n                storeIndex++;\\n            }\\n        }\\n        Collections.swap(nums, storeIndex, right);\\n        return storeIndex;\\n    }\\n\\n    private int gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        v = [[] for i in range(n + 1)]\\n        k = gcd(n, k)\\n        for i in range(n):\\n            v[i % k].append(arr[i])\\n        ans = 0\\n        for i in range(k):\\n            median = self.quickselect(v[i], len(v[i]) // 2)\\n            for j in v[i]:\\n                ans += abs(median - j)\\n        return ans\\n\\n    def quickselect(self, nums: List[int], k: int) -> int:\\n        left, right = 0, len(nums) - 1\\n        while left <= right:\\n            pivotIndex = self.partition(nums, left, right)\\n            if pivotIndex == k:\\n                return nums[k]\\n            elif pivotIndex < k:\\n                left = pivotIndex + 1\\n            else:\\n                right = pivotIndex - 1\\n        return -1\\n\\n    def partition(self, nums: List[int], left: int, right: int) -> int:\\n        pivotIndex = left + (right - left) // 2\\n        pivotValue = nums[pivotIndex]\\n        nums[pivotIndex], nums[right] = nums[right], nums[pivotIndex]\\n        storeIndex = left\\n        for i in range(left, right):\\n            if nums[i] < pivotValue:\\n                nums[i], nums[storeIndex] = nums[storeIndex], nums[i]\\n                storeIndex += 1\\n        nums[storeIndex], nums[right] = nums[right], nums[storeIndex]\\n        return storeIndex\\n\\n    def gcd(self, a: int, b: int) -> int:\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a % b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366524,
                "title": "easy-solution-c",
                "content": "# Approach\\nIf n is divisible by k then perform the following otherwise update k to gcd of n and k (by observation)\\n\\nNow , for every element at a gap of k make them equal by subtracting all these numbers by their median we can do that by sorting all the elements and taking its middle to get the median\\n<!-- Describe your approach to solving the problem. -->\\n- Why we are taking GCD of \\'n\\' and \\'k\\'?\\n As we want \\'k\\' to be as big as possible but also it should also divide the \\'n\\', to match our requirement.\\n\\n# Complexity\\n- Time complexity: O(Nlog(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long res = 0;\\n        int n = arr.size();\\n        k = __gcd(k , n);\\n\\n        for(int i=0;i<k;i++) {\\n            vector<int> vec;\\n            for(int j = i;j<n;j+=k)\\n                vec.push_back(arr[j]);\\n\\n            sort(vec.begin() , vec.end());\\n            long long mid = vec[vec.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) \\n                res += abs(midv - arr[j]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long res = 0;\\n        int n = arr.size();\\n        k = __gcd(k , n);\\n\\n        for(int i=0;i<k;i++) {\\n            vector<int> vec;\\n            for(int j = i;j<n;j+=k)\\n                vec.push_back(arr[j]);\\n\\n            sort(vec.begin() , vec.end());\\n            long long mid = vec[vec.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) \\n                res += abs(midv - arr[j]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367171,
                "title": "intuition-approach-c-easy-to-understand",
                "content": "### INTUITION\\n![image](https://assets.leetcode.com/users/images/070abc38-f150-4bf3-8db3-4a9edb3dfd76_1680372514.3126214.jpeg)\\n\\nCODE:\\n```\\n\\nlong long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n = a.size();\\n        long long ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // finding elements in same group as explained in INTUITION\\n            vector<int> group;\\n            for (int j = i; a[j] != 0; j = (j+k)%n) {\\n                group.push_back(a[j]);\\n                a[j] = 0;\\n            }\\n            \\n            // median of that group\\n            if (group.size() > 0) {\\n                sort(group.begin(), group.end());\\n                int median = group[group.size() / 2];\\n\\n                // make all elements equal to median for minimum cost\\n                for (auto &x: group) {\\n                    ans += abs(x - median);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nlong long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n = a.size();\\n        long long ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            // finding elements in same group as explained in INTUITION\\n            vector<int> group;\\n            for (int j = i; a[j] != 0; j = (j+k)%n) {\\n                group.push_back(a[j]);\\n                a[j] = 0;\\n            }\\n            \\n            // median of that group\\n            if (group.size() > 0) {\\n                sort(group.begin(), group.end());\\n                int median = group[group.size() / 2];\\n\\n                // make all elements equal to median for minimum cost\\n                for (auto &x: group) {\\n                    ans += abs(x - median);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366858,
                "title": "best-c-solution-with-100-acuuracy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst observation is that if we want each subarray sum to be the same, it means that the array must have a repeated pattern of size k.\\nTo understand that, let\\'s just say that k is 4 and the array starts with [1 2 3 4...]\\nThen to have sum(1,2,3,4) == sum(2,3,4, x) the next element has to be a 1! Then the next one a 2, etc.\\n\\nSo this means that in the final array, arr[i] == arr[(i + k) %n] for every i.\\n\\nSince arr[i] == arr[(i + k) %n] == arr[(i + 2*k) %n] == arr[(i + 3*k) %n] == .... this gives us a set of indexes for which the values must be the same. First step is to find these sets of indexes.\\n\\nThen for each set must find the minimal number of operations to have all these values the same. This means finding v so that sum_x(|x -v|) is minimal. This is the median of these values.\\n\\nOnce we found the median, we just have to add the difference between each value and the median\\xA0to\\xA0the\\xA0result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n    \\n        k = __gcd(k , n);\\n        \\n        //due to circular array the gap k will be converted to gcd of\\n        // k and n by observation (check for n = 15 , k = 6 , and find out)\\n        for(int i=0;i<k;i++) {\\n            vector<int> v;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                v.push_back(arr[j]);\\n            }\\n            \\n            sort(v.begin() , v.end());\\n            //taking the mid value of the sorted array to get the \\n            //median as it will require minimum operation to convert \\n            //all elements to the medain value\\n            long long midv = v[v.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n    \\n        k = __gcd(k , n);\\n        \\n        //due to circular array the gap k will be converted to gcd of\\n        // k and n by observation (check for n = 15 , k = 6 , and find out)\\n        for(int i=0;i<k;i++) {\\n            vector<int> v;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                v.push_back(arr[j]);\\n            }\\n            \\n            sort(v.begin() , v.end());\\n            //taking the mid value of the sorted array to get the \\n            //median as it will require minimum operation to convert \\n            //all elements to the medain value\\n            long long midv = v[v.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369308,
                "title": "this-is-how-can-average-student-approach-this-question-easiest-solution-with-intuition-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find the minimum cost to make all subarrays of length k equal. One of the ways to approach this problem is to divide the given array into k subarrays such that each subarray has elements at indices i, i+k, i+2k, i+3k, and so on. Then, we can find the median of each subarray, and the sum of medians of all subarrays will give us the minimum cost to make all subarrays of length k equal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First, we find the GCD of n and k. Let\\'s call it gcd.\\n2. We create a vector of vectors, where the outer vector has size gcd and the inner vectors store elements at indices i, i+gcd, i+2gcd, and so on.\\n3. For each inner vector, we find the median using the median function. The median function sorts the vector and then calculates the sum of absolute differences of each element with the median.\\n4. We sum up all the medians calculated in step 3, and this gives us the minimum cost to make all subarrays of length k equal.\\n\\n# Complexity\\n- Time complexity: O(nlog(n)) for Sorting.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for storing.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n> Please upvote \\n\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    \\n    ll median(vector<int>&v){\\n        ll ans=0;\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++) ans+=abs(v[i]-v[v.size()/2]);\\n        return ans;   \\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        ll ans=0;\\n        k=__gcd(n,k);\\n        vector<vector<int>>v(k);\\n        for(int i=0;i<k;i++){\\n            for(int j=i;j<n;j+=k){\\n                v[i].push_back(arr[j]);\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            ans+=median(v[i]);\\n        }\\n       \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    \\n    ll median(vector<int>&v){\\n        ll ans=0;\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++) ans+=abs(v[i]-v[v.size()/2]);\\n        return ans;   \\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        ll ans=0;\\n        k=__gcd(n,k);\\n        vector<vector<int>>v(k);\\n        for(int i=0;i<k;i++){\\n            for(int j=i;j<n;j+=k){\\n                v[i].push_back(arr[j]);\\n            }\\n        }\\n        for(int i=0;i<k;i++){\\n            ans+=median(v[i]);\\n        }\\n       \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366425,
                "title": "c-easy-solution",
                "content": "# Intuition\\nI remembered a similar question where we had to increase or decrease so that all elements are equal.\\n# Approach\\nI realized that all elements spaced with k indices should be equal.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long solve(vector<int> nums){\\n        long long sum = 0;\\n        if(nums.size()==0) return 0;\\n        sort(begin(nums),end(nums));\\n        int k = nums.size();\\n        sum = nums[k/2];\\n        long long ans = 0;\\n        for(auto it:nums)\\n            ans += abs(sum-it);\\n        return ans;\\n    }\\n    \\n    long long makeSubKSumEqual(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        int n = nums.size();\\n        set<int> st;\\n        for(int i=0; i<=min(k,n-1); ++i){\\n            vector<int> arr;\\n            int j = i;\\n            while(st.find(j) == st.end()){\\n                st.insert(j);\\n                arr.push_back(nums[j]);\\n                j = (j+k)%n;\\n            }\\n            ans += solve(arr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long solve(vector<int> nums){\\n        long long sum = 0;\\n        if(nums.size()==0) return 0;\\n        sort(begin(nums),end(nums));\\n        int k = nums.size();\\n        sum = nums[k/2];\\n        long long ans = 0;\\n        for(auto it:nums)\\n            ans += abs(sum-it);\\n        return ans;\\n    }\\n    \\n    long long makeSubKSumEqual(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        int n = nums.size();\\n        set<int> st;\\n        for(int i=0; i<=min(k,n-1); ++i){\\n            vector<int> arr;\\n            int j = i;\\n            while(st.find(j) == st.end()){\\n                st.insert(j);\\n                arr.push_back(nums[j]);\\n                j = (j+k)%n;\\n            }\\n            ans += solve(arr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366422,
                "title": "python-cycle-partition-o-nlogn",
                "content": "# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        visited = set()\\n        n = len(arr)\\n        res = 0\\n        for i in range(len(arr)):\\n            if i in visited: continue\\n            curlist = []\\n            while i not in visited:\\n                visited.add(i)\\n                curlist.append(arr[i])\\n                i = (i+k)%n\\n            curlist.sort()\\n            m = len(curlist)//2\\n            res += sum([abs(num - curlist[m]) for num in curlist])\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        visited = set()\\n        n = len(arr)\\n        res = 0\\n        for i in range(len(arr)):\\n            if i in visited: continue\\n            curlist = []\\n            while i not in visited:\\n                visited.add(i)\\n                curlist.append(arr[i])\\n                i = (i+k)%n\\n            curlist.sort()\\n            m = len(curlist)//2\\n            res += sum([abs(num - curlist[m]) for num in curlist])\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980445,
                "title": "easy-c-solution-what-to-learn-from-the-problem",
                "content": "## Two points to remember:- \\n- gcd(n,k)helps in grouping the circular array of size n into groups of elements having difference of k;\\n- If you have to find the minimum cost to make all elements of array equal:-\\n1)Median is the correct choice if increasing or decreasing the element by 1 both increase the cost.\\n2) Mean is the correct choice if increasing element increases the cost by 1 and decreasing the element decreases the cost by 1 or vice versa.\\n3) Mode is the correct choice if the element can be directly increased or decreased to a certain element and each operations incurs equal cost.\\n4) Median is the correct choice if the element can be directly increased or decreased to a certain element and increasing and decreasing incurs opposite cost i.e one increases and another decreases equally.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N*log(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int x=__gcd(n,k);\\n        vector<vector<int>>v(x);\\n        for(int i=0;i<n;i++){\\n            v[i%x].push_back(arr[i]);\\n        }\\n        long long ans=0;\\n        for(auto y:v){\\n            sort(y.begin(),y.end());\\n            int ind=(y.size()-1)/2;\\n            long long sum=0;\\n            for(auto z:y){\\n                sum+=abs(z-y[ind]);\\n            }\\n            ans+=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        int x=__gcd(n,k);\\n        vector<vector<int>>v(x);\\n        for(int i=0;i<n;i++){\\n            v[i%x].push_back(arr[i]);\\n        }\\n        long long ans=0;\\n        for(auto y:v){\\n            sort(y.begin(),y.end());\\n            int ind=(y.size()-1)/2;\\n            long long sum=0;\\n            for(auto z:y){\\n                sum+=abs(z-y[ind]);\\n            }\\n            ans+=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619857,
                "title": "python-3-4-lines-w-comments-t-m-51-96",
                "content": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n\\n        g, d, ans = gcd(k,len(arr)), defaultdict(list), 0\\n\\n        for i, a in enumerate(arr): d[i%g].append(a)            # <-- construct a dict of sorted lists\\n        for i in d:d[i].sort()                                  #     of`arr`elements that must be equal\\n            \\n        return sum(d[i][-j-1]-d[i][j]                           # <-- determine the number of moves to \\n                   for j in range((len(d[i]))//2) for i in d)   #     make them equal. The sum of moves \\n                                                                #     for a symmetric pair (e.g., d[i][1]\\n                                                                #     and d[i][-2]) is their difference.\\n```\\n[https://leetcode.com/problems/make-k-subarray-sums-equal/submissions/926808484/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n\\n        g, d, ans = gcd(k,len(arr)), defaultdict(list), 0\\n\\n        for i, a in enumerate(arr): d[i%g].append(a)            # <-- construct a dict of sorted lists\\n        for i in d:d[i].sort()                                  #     of`arr`elements that must be equal\\n            \\n        return sum(d[i][-j-1]-d[i][j]                           # <-- determine the number of moves to \\n                   for j in range((len(d[i]))//2) for i in d)   #     make them equal. The sum of moves \\n                                                                #     for a symmetric pair (e.g., d[i][1]\\n                                                                #     and d[i][-2]) is their difference.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371767,
                "title": "thought-process-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s have a brief review on what we are going do then we will understand each step in detail.\\nFirst, we will create a container array of size gcd(n, k). Then we will store n/k elements in each container. After that we will iterate through each container and find their medians. Our ans will be the sum of absolute value of difference of median and each elements of that container.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBefore we proceed further I strongly suggest you go through this question once. [462. Minimum Moves to Equal Array Elements II](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/). Sorry to interrupt you in between but I can make sure that once you have gone through it then this will become crystal clear.\\n\\nFirst we have to create a container size gcd(n, k). Now the question arrises from were the hell this gcd came. Let me explain this in detail.\\nThe idea behind taking gcd(n, k) is to divide the array arr into `box_cnt` container, each having an equal number of elements. The gcd(n, k) ensures that the number of container is as small as possible while still having an equal number of elements in each container. For example, if n is a multiple of k, then `box_cnt` will be equal to k, and each container will have n / k elements. By dividing arr into `box_cnt` buckets, we can compute the median of each bucket efficiently. We will also see this in detail ahead.\\n***Basically if we did not take the gcd, we might end up with container of different sizes, which would complicate the calculation of the medians and the final result.***\\n\\nNow we have understood this part let\\'s move ahead. Now comes the time to store the values in the container. We will store the elements in following manner\\n\\n```\\nLet arr = [1, 4, 1, 3] and k = 2 then the box_cnt = gcd(n, k) = 2;\\ncontainer[0] = {1, 1}\\ncontainer[1] = {4, 3}\\ni.e., will add every next k element in a container\\n```\\n\\nOnce you have stored the elements in the container, now comes the time to calculate our ans. For that we will iterate over each container and find the median value in each. Now the question arrises why **Median**. If you have done the question which I have mentioned above then their will be no doubt. Still let me explain it. The main idea behind taking the median is to make all the elements in that particular container equal(not actually only conceptually). As median has the property that half of the elements in the container are greater than or equal to it, and half are less than or equal to it. So, this is only the best way to make all array equal.\\n\\nNow we calculate the sum of absolute differences between each element in the container and the median of that container. Finally, we can sum up the results for all the containers to get the final answer.\\n\\nSorry for the lengthy post. Hope you enjoyed solving this problem. If I was able to help you, then you thank me with a upvote.\\n# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int box_cnt = __gcd(n, k);\\n\\n        vector<vector<long long>> container(box_cnt);\\n        for(int i = 0; i<n; i++){\\n            container[i%box_cnt].push_back(arr[i]);\\n        }\\n\\n        long long ans = 0;\\n        for(auto items : container){\\n            sort(begin(items), end(items));\\n            int item_size = items.size();\\n            int median;\\n            if(item_size%2 == 1)\\n                median = items[item_size/2];\\n            else\\n                median = (items[(item_size/2)-1]+items[item_size/2])/2;\\n\\n            for(auto ele: items){\\n                ans += abs(median-ele);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nLet arr = [1, 4, 1, 3] and k = 2 then the box_cnt = gcd(n, k) = 2;\\ncontainer[0] = {1, 1}\\ncontainer[1] = {4, 3}\\ni.e., will add every next k element in a container\\n```\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        int box_cnt = __gcd(n, k);\\n\\n        vector<vector<long long>> container(box_cnt);\\n        for(int i = 0; i<n; i++){\\n            container[i%box_cnt].push_back(arr[i]);\\n        }\\n\\n        long long ans = 0;\\n        for(auto items : container){\\n            sort(begin(items), end(items));\\n            int item_size = items.size();\\n            int median;\\n            if(item_size%2 == 1)\\n                median = items[item_size/2];\\n            else\\n                median = (items[(item_size/2)-1]+items[item_size/2])/2;\\n\\n            for(auto ele: items){\\n                ans += abs(median-ele);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367122,
                "title": "python3-grouping-by-gcd",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/1dc118daa80cfe1161dcee412e7c3536970ca60d) for solutions of biweely 101. \\n\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        ans = 0 \\n        g = gcd(len(arr), k)\\n        for i in range(g): \\n            vals = []\\n            for _ in range(len(arr)//g): \\n                vals.append(arr[i])\\n                i = (i+k) % len(arr)\\n            vals.sort()\\n            cand = vals[len(vals)//2]\\n            ans += sum(abs(x-cand) for x in vals)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        ans = 0 \\n        g = gcd(len(arr), k)\\n        for i in range(g): \\n            vals = []\\n            for _ in range(len(arr)//g): \\n                vals.append(arr[i])\\n                i = (i+k) % len(arr)\\n            vals.sort()\\n            cand = vals[len(vals)//2]\\n            ans += sum(abs(x-cand) for x in vals)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366372,
                "title": "c-disjoint-set-and-prefix-sum-o-nlogn-with-explanation",
                "content": "**Intro** :\\nWe need the sum of each subarry of length k to be equal,\\nthus arr[i] should be equal to arr[(i+k)%n] for all i from 0 to n.\\nSo, we make different set of the values which needs to be equal and then solve for each set.\\n\\n**How to solve for each set :**\\nNow, for a set we need to calculate the minimum cost to make all the values equal.\\nFor this,we sort the numbers and then find cost of making all values equal to a given a[i] by using values :\\npref[i]- cost required to make a[0,i-1] equal to a[i].\\nsuff[i]- cost required to make a[i+1,a.size()-1] equal to a[i].\\nand taking minimum of all.\\n\\n**Final answe**r is the sum of minimum values for each set.\\n\\n**CODE-**\\n```\\n\\n\\nclass Solution {\\npublic:\\n    \\nstruct DSU {\\n\\tvector<int> e;\\n\\tDSU(int N) { e = vector<int>(N, -1); }\\n\\n\\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\n\\n\\tbool same(int a, int b) { return get(a) == get(b); }\\n\\n\\tbool unite(int x, int y) {  \\n\\t\\tx = get(x), y = get(y);\\n\\t\\tif (x == y) return false;\\n\\t\\tif (e[x] > e[y]) swap(x, y);\\n\\t\\te[x] += e[y]; e[y] = x;\\n\\t\\treturn true;\\n\\t}\\n};\\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long n1=arr.size();\\n        DSU dsu(n1);\\n        for(int i=0;i<arr.size();i++){\\n            dsu.unite(i,(i+k)%n1);\\n        }\\n        \\n        vector<vector<long long>> v(k);\\n        for(int i=0;i<arr.size();i++){\\n            v[dsu.get(i)].push_back(arr[i]*1ll);\\n        }\\n        long long ans=0;\\n        for(int id=0;id<k;id++){\\n            vector<long long>a=v[id];\\n            sort(a.begin(),a.end());\\n            long long n=a.size();\\n            if(!n) continue;\\n            vector<long long>pref(n),suff(n);\\n            long long sum=a[0]; pref[0]=0;\\n            for(int i=1;i<n;i++){\\n                pref[i]=i*a[i]-sum;\\n                sum+=a[i];\\n            }\\n            sum=a[n-1]; suff[n-1]=0;\\n            for(int i=n-2;i>=0;i--){\\n                suff[i]=sum-(n-i-1)*a[i];\\n                sum+=a[i];\\n            }\\n            long long res=pref[0]+suff[0];\\n            for(int i=1;i<n;i++) res=min(res,pref[i]+suff[i]);\\n            ans=ans+res;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity - O(nlogn)\\nSpace Complexity ~ O(n) (probably)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    \\nstruct DSU {\\n\\tvector<int> e;\\n\\tDSU(int N) { e = vector<int>(N, -1); }\\n\\n\\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\n\\n\\tbool same(int a, int b) { return get(a) == get(b); }\\n\\n\\tbool unite(int x, int y) {  \\n\\t\\tx = get(x), y = get(y);\\n\\t\\tif (x == y) return false;\\n\\t\\tif (e[x] > e[y]) swap(x, y);\\n\\t\\te[x] += e[y]; e[y] = x;\\n\\t\\treturn true;\\n\\t}\\n};\\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long n1=arr.size();\\n        DSU dsu(n1);\\n        for(int i=0;i<arr.size();i++){\\n            dsu.unite(i,(i+k)%n1);\\n        }\\n        \\n        vector<vector<long long>> v(k);\\n        for(int i=0;i<arr.size();i++){\\n            v[dsu.get(i)].push_back(arr[i]*1ll);\\n        }\\n        long long ans=0;\\n        for(int id=0;id<k;id++){\\n            vector<long long>a=v[id];\\n            sort(a.begin(),a.end());\\n            long long n=a.size();\\n            if(!n) continue;\\n            vector<long long>pref(n),suff(n);\\n            long long sum=a[0]; pref[0]=0;\\n            for(int i=1;i<n;i++){\\n                pref[i]=i*a[i]-sum;\\n                sum+=a[i];\\n            }\\n            sum=a[n-1]; suff[n-1]=0;\\n            for(int i=n-2;i>=0;i--){\\n                suff[i]=sum-(n-i-1)*a[i];\\n                sum+=a[i];\\n            }\\n            long long res=pref[0]+suff[0];\\n            for(int i=1;i<n;i++) res=min(res,pref[i]+suff[i]);\\n            ans=ans+res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886366,
                "title": "beats-95-one-of-the-best-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long getans(vector<int> &temp)\\n    {\\n        if(temp.size()==1)\\n        return 0;\\n        else if(temp.size()==2)\\n        {\\n            return abs(temp[0]-temp[1]);\\n        }\\n        else\\n        {\\n            sort(temp.begin(),temp.end());\\n            int n = temp.size();\\n            if(n&1)\\n            {\\n                int mid = (n-1)/2;\\n                long long ans = 0;\\n                for(int i=0;i<n;i++)\\n                ans+=abs(temp[i]-temp[mid]);\\n\\n                return ans;\\n            }\\n            else\\n            {\\n                int mid = (n-1)/2;\\n                int mid2 = mid+1;\\n                long long a1=0,a2=0;\\n                for(int i=0;i<n;i++)\\n                {\\n                    a1+=abs(temp[i]-temp[mid]);\\n                    a2+=abs(temp[i]-temp[mid2]);\\n                }\\n\\n                if(a1<=a2)return a1;\\n                else\\n                return a2;\\n            }\\n        }\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        long long ans = 0;\\n        vector<bool> visited(n,false);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]==true)continue;\\n            else\\n            {\\n                int j = i;\\n                vector<int> temp;\\n                while(true)\\n                {\\n                    if(visited[j]==true)\\n                    {\\n                        break;\\n                    }\\n                    temp.push_back(arr[j]);\\n                    visited[j] = true;\\n                    j =  (j+k)%n;\\n                }\\n\\n                ans+=getans(temp);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long getans(vector<int> &temp)\\n    {\\n        if(temp.size()==1)\\n        return 0;\\n        else if(temp.size()==2)\\n        {\\n            return abs(temp[0]-temp[1]);\\n        }\\n        else\\n        {\\n            sort(temp.begin(),temp.end());\\n            int n = temp.size();\\n            if(n&1)\\n            {\\n                int mid = (n-1)/2;\\n                long long ans = 0;\\n                for(int i=0;i<n;i++)\\n                ans+=abs(temp[i]-temp[mid]);\\n\\n                return ans;\\n            }\\n            else\\n            {\\n                int mid = (n-1)/2;\\n                int mid2 = mid+1;\\n                long long a1=0,a2=0;\\n                for(int i=0;i<n;i++)\\n                {\\n                    a1+=abs(temp[i]-temp[mid]);\\n                    a2+=abs(temp[i]-temp[mid2]);\\n                }\\n\\n                if(a1<=a2)return a1;\\n                else\\n                return a2;\\n            }\\n        }\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        long long ans = 0;\\n        vector<bool> visited(n,false);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]==true)continue;\\n            else\\n            {\\n                int j = i;\\n                vector<int> temp;\\n                while(true)\\n                {\\n                    if(visited[j]==true)\\n                    {\\n                        break;\\n                    }\\n                    temp.push_back(arr[j]);\\n                    visited[j] = true;\\n                    j =  (j+k)%n;\\n                }\\n\\n                ans+=getans(temp);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367768,
                "title": "c-actually-explained-gcd-median-latexed",
                "content": "# Intuition\\nThis problem was too difficult for a medium imo.\\nSo first off, we want to notice that all subarrays of length $\\\\color{pink} k$ must contain the **same** elements. Why is this? Let\\'s start building an optimal solution. Suppose we have $\\\\color{pink} n$ elements and our $\\\\color{pink} k$ is 3.\\n\\nThe first length 3 subarray is $[a_0,a_1,a_2]$. The next one is $[a_1,a_2,a_3]$. Notice that the first subarray\\'s sum is $\\\\color{cyan} a_0 + a_1 + a_2$, and by the constraints, the next one must also equal that. If you do some simplifying, you see that $\\\\color{lime} a_3 = a_0$. You can continue this onwards to see that it must repeat every k (at the very most). It can be less, like test case 2, where the answer repeats every 1, but k is 2.\\n\\nOkay, let\\'s see how our good friend $\\\\color{pink} \\\\gcd$ comes into this. Let\\'s just focus on the *indices* of our array and for the sake of argument: let $\\\\color{pink} k = 4,n=6$.\\n\\nThen, let\\'s again try and build the optimal solution, starting with index 0. We have \\n$\\\\Large[a_0,a_1,a_2,a_3]$\\n$\\\\Large[a_4,a_5,a_0,a_1]$\\n$\\\\Large[a_2,a_3,a_4,a_5]$\\n$\\\\Large[a_0,a_1,a_2,a_3]$\\nNotice that it repeats. Using our idea that each value must repeat, we can say that $\\\\large \\\\color{yellow} a_0 = a_4 = a_2$\\n$\\\\large \\\\color{yellow} a_1 = a_5 = a_3$\\nLet\\'s formalize this. \\nWe can express the \"chain of values\" achieved with $\\\\color{orange} 4m + i \\\\pmod{6}$, where $\\\\color{orange} i$ is the index. For example, notice that when $\\\\color{orange} i =1$ and we iterate over $\\\\color{orange} m$, we get $\\\\color{white} \\\\{1,5,3,1,\\\\dotsc\\\\}$. Look familiar?\\n\\nAn important subtask will be to determine whether two indices $\\\\color{violet} i,j$ are part of the same chain. All that\\'s really saying is that$\\\\color{magenta} j \\\\equiv 4m + i \\\\pmod{6}$\\n\\nWhy? Because if $\\\\color{violet} i,j$ are in the same chain, then $\\\\color{violet} j$ is reachable by $\\\\color{violet} i$ by just adding $\\\\color{pink} k$ over and over mod $\\\\color{orange} n$ until we get there. If we never reach $\\\\color{violet} j$, then it\\'s not possible.\\n\\nSo if we solve the modular equation, we get $\\\\color{magenta} j-i \\\\equiv 4m \\\\pmod{6}$, now this is reducible since 4 and 6 share common factors. Therefore we can reduce it to \\n\\n$\\\\LARGE \\\\color{magenta} \\\\frac{j-i}{\\\\gcd(6,4)} \\\\equiv 2m \\\\pmod{3}$\\n\\nNow since 2 and 3 do not share common factors (**), we know that if this modular equation has a solution, the left side obviously has to be an integer, so $\\\\color{cyan} g \\\\coloneqq \\\\gcd(6,4) | (j-i)$\\n\\nAll this says is that $\\\\color{lime} j \\\\equiv i \\\\pmod{g}$, so now we have our condition!\\n\\nOkay, let\\'s now see the ideal values to set our group to! Let\\'s look at a test case: `[2,5,8,7,4,1,3], k = 3`\\n\\nWe use the approach above to notice that we have one big homogeneous group with all the numbers in it. Applying the operations to make all numbers equal is now equivalent to simply calculating the absolute deviation of the numbers to a central point $\\\\color{orange} x$, so we wish to find $$\\\\Large \\\\color{violet} \\\\min \\\\sum\\\\limits_{s \\\\in S} |s-\\\\color{orange} x \\\\color{violet}|$$\\n\\nIt is well known that the **median** minimizes the absolute deviation and so we let $\\\\color{orange} x$ be the **median**.\\n\\nEvaluating the sum results in 14, which is optimal.\\n\\n# Approach\\nI used an array of vectors where each index $\\\\color{lime} i$ represented a possible value of $\\\\color{lime} i \\\\pmod{\\\\gcd(n,k)}$, and just appended each element to its corresponding group.\\n\\nThe way I calculated the median was the simple way, where you just sort the list and query the middle element (middle two elements if the list size is even).\\n\\n# Complexity\\n- Time complexity: $\\\\color{violet} O(n \\\\log (n))$, since we are placing $\\\\color{violet} n$ elements in lists and worst case sort will be when all elements are in the same list, so that will just be $\\\\color{violet} O(n \\\\log (n))$. Since $\\\\color{violet} \\\\gcd(n,k) < n$, that second loop will not run more than n times.\\n\\n- Space complexity: $\\\\color{violet} O(n)$, as we only fill $\\\\color{violet} n$ elements worth of stuff in the vector array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n = a.size();\\n        int g = gcd(n,k);\\n        vector<int> v[g];\\n        for (int i = 0; i < n; ++i)\\n            v[i % g].emplace_back(a[i]);\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < g; ++i){\\n            if (v[i].empty())\\n                continue;\\n            sort(v[i].begin(),v[i].end());\\n            int med = 0;\\n            if (v[i].size() & 1)\\n                med = v[i][v[i].size()/2];\\n            else\\n                med = (v[i][v[i].size()/2] + v[i][v[i].size()/2 - 1])/2;\\n            for (int j = 0; j < v[i].size(); ++j)\\n                ans += abs(v[i][j] - med);\\n        }\\n        return ans;\\n    }      \\n};\\n```\\n**: When we divide both k and n by the gcd, it\\'s **guaranteed** that the resultants won\\'t share common factors.",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n = a.size();\\n        int g = gcd(n,k);\\n        vector<int> v[g];\\n        for (int i = 0; i < n; ++i)\\n            v[i % g].emplace_back(a[i]);\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < g; ++i){\\n            if (v[i].empty())\\n                continue;\\n            sort(v[i].begin(),v[i].end());\\n            int med = 0;\\n            if (v[i].size() & 1)\\n                med = v[i][v[i].size()/2];\\n            else\\n                med = (v[i][v[i].size()/2] + v[i][v[i].size()/2 - 1])/2;\\n            for (int j = 0; j < v[i].size(); ++j)\\n                ans += abs(v[i][j] - med);\\n        }\\n        return ans;\\n    }      \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367499,
                "title": "gcd-median-c-python-greedy",
                "content": "# Intuition\\nFor a simple problem of k==1, we need to make all elements equal to some number. That number will be median which can be understood with the help of number line and some intuition. For even length array n/2 and n/2+1 position both will give out same answer.\\nSo now coming to this problem where we slide a k subarray window , observe that we can have equal sum in all subarrays only if the number going out and the number coming in the window are the same.\\nFor this we need to get some kind of a pattern like consider the following pattern- x,y,z,x,y,z,x,y,z.... this pattern will be for gcd (n,k)=3 .\\nAnd this is possible only if the length of the pattern is gcd of n and k. This is a necessary condition as we need to wrap the last array in a circular fashion.\\nSo it all boils down to creating such a pattern where x is median(arr[0],arr[0+g],arr[0+2*g],...) , y is median(arr[1],arr[1+g],arr[1+2*g],...) and so on..\\n\\n# Approach\\ncalculate all arrays for each index of gcd pattern and sort them to get the median and form the new result array. Take absolute difference of them and add it to answer.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) in worst case\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans=0;\\n        long long n=arr.size();\\n        long long g=gcd(n,k);\\n        vector <long long> res;\\n        for (int i=0;i<g;i++){\\n            vector<long long> lol;\\n            for (int j=i;j<n;j+=g) lol.push_back(arr[j]);\\n            sort(lol.begin(),lol.end());\\n            res.push_back(lol[lol.size()/2]);\\n        }\\n        for (int i=0;i<n;i++) ans+=abs(res[i%g]-arr[i]);\\n        return ans;\\n    }\\n};\\n```\\n# Python\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        g=gcd(n,k)\\n        ans=0\\n        nums=[]\\n        for i in range(g):\\n            lol=[]\\n            for j in range(i,n,g):\\n                lol.append(arr[j])\\n            lol.sort()\\n            nums.append(lol[len(lol)//2])\\n        for i in range(n):\\n            ans+=abs(nums[i%g]-arr[i])\\n        return ans\\n                \\n        \\n\\n                \\n        \\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans=0;\\n        long long n=arr.size();\\n        long long g=gcd(n,k);\\n        vector <long long> res;\\n        for (int i=0;i<g;i++){\\n            vector<long long> lol;\\n            for (int j=i;j<n;j+=g) lol.push_back(arr[j]);\\n            sort(lol.begin(),lol.end());\\n            res.push_back(lol[lol.size()/2]);\\n        }\\n        for (int i=0;i<n;i++) ans+=abs(res[i%g]-arr[i]);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n=len(arr)\\n        g=gcd(n,k)\\n        ans=0\\n        nums=[]\\n        for i in range(g):\\n            lol=[]\\n            for j in range(i,n,g):\\n                lol.append(arr[j])\\n            lol.sort()\\n            nums.append(lol[len(lol)//2])\\n        for i in range(n):\\n            ans+=abs(nums[i%g]-arr[i])\\n        return ans\\n                \\n        \\n\\n                \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366545,
                "title": "python-3-median-and-mod-gcd",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, A: List[int], K: int) -> int:\\n        lA = len(A)\\n        g = gcd(lA, K)\\n        retV = 0\\n        for i in range(g):\\n            med = int(median(A[i::g]))\\n            retV += sum(abs(a-med) for a in A[i::g])\\n            \\n        return retV            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, A: List[int], K: int) -> int:\\n        lA = len(A)\\n        g = gcd(lA, K)\\n        retV = 0\\n        for i in range(g):\\n            med = int(median(A[i::g]))\\n            retV += sum(abs(a-med) for a in A[i::g])\\n            \\n        return retV            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366534,
                "title": "dsu-prefix-sum-o-n-longn",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nstruct DSU {\\n\\tvector<int> e;\\n\\tDSU(int N) { e = vector<int>(N, -1); }\\n\\n\\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\n\\n\\tbool same(int a, int b) { return get(a) == get(b); }\\n\\n\\tbool unite(int x, int y) {  \\n\\t\\tx = get(x), y = get(y);\\n\\t\\tif (x == y) return false;\\n\\t\\tif (e[x] > e[y]) swap(x, y);\\n\\t\\te[x] += e[y]; e[y] = x;\\n\\t\\treturn true;\\n\\t}\\n};\\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long n1=arr.size();\\n        DSU dsu(n1);\\n        for(int i=0;i<arr.size();i++){\\n            dsu.unite(i,(i+k)%n1);\\n        }\\n        \\n        vector<vector<long long>> v(k);\\n        for(int i=0;i<arr.size();i++){\\n            v[dsu.get(i)].push_back(arr[i]*1ll);\\n        }\\n        long long ans=0;\\n        for(int id=0;id<k;id++){\\n            vector<long long>a=v[id];\\n            sort(a.begin(),a.end());\\n            long long n=a.size();\\n            if(!n) continue;\\n            vector<long long>pref(n),suff(n);\\n            long long sum=a[0]; pref[0]=0;\\n            for(int i=1;i<n;i++){\\n                pref[i]=i*a[i]-sum;\\n                sum+=a[i];\\n            }\\n            sum=a[n-1]; suff[n-1]=0;\\n            for(int i=n-2;i>=0;i--){\\n                suff[i]=sum-(n-i-1)*a[i];\\n                sum+=a[i];\\n            }\\n            long long res=pref[0]+suff[0];\\n            for(int i=1;i<n;i++) res=min(res,pref[i]+suff[i]);\\n            ans=ans+res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nstruct DSU {\\n\\tvector<int> e;\\n\\tDSU(int N) { e = vector<int>(N, -1); }\\n\\n\\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\n\\n\\tbool same(int a, int b) { return get(a) == get(b); }\\n\\n\\tbool unite(int x, int y) {  \\n\\t\\tx = get(x), y = get(y);\\n\\t\\tif (x == y) return false;\\n\\t\\tif (e[x] > e[y]) swap(x, y);\\n\\t\\te[x] += e[y]; e[y] = x;\\n\\t\\treturn true;\\n\\t}\\n};\\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long n1=arr.size();\\n        DSU dsu(n1);\\n        for(int i=0;i<arr.size();i++){\\n            dsu.unite(i,(i+k)%n1);\\n        }\\n        \\n        vector<vector<long long>> v(k);\\n        for(int i=0;i<arr.size();i++){\\n            v[dsu.get(i)].push_back(arr[i]*1ll);\\n        }\\n        long long ans=0;\\n        for(int id=0;id<k;id++){\\n            vector<long long>a=v[id];\\n            sort(a.begin(),a.end());\\n            long long n=a.size();\\n            if(!n) continue;\\n            vector<long long>pref(n),suff(n);\\n            long long sum=a[0]; pref[0]=0;\\n            for(int i=1;i<n;i++){\\n                pref[i]=i*a[i]-sum;\\n                sum+=a[i];\\n            }\\n            sum=a[n-1]; suff[n-1]=0;\\n            for(int i=n-2;i>=0;i--){\\n                suff[i]=sum-(n-i-1)*a[i];\\n                sum+=a[i];\\n            }\\n            long long res=pref[0]+suff[0];\\n            for(int i=1;i<n;i++) res=min(res,pref[i]+suff[i]);\\n            ans=ans+res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366386,
                "title": "best-concise-solution-and-easy-to-understand-c",
                "content": "# Approach\\nIf n is divisible by k then perform the following otherwise update k to gcd of n and k (by observation)\\n\\nNow , for every element at a gap of k make them equal by subtracting all these numbers by their median we can do that by sorting all the elements and taking its middle to get the median\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n        \\n        // if(n%k != 0) {\\n        //     sort(arr.begin() , arr.end());\\n        //     long long mid = arr[n/2];\\n        //     for(int i=0;i<n;i++) ans += abs(mid - arr[i]);\\n        // }\\n        // else {\\n        \\n        k = __gcd(k , n);\\n        for(int i=0;i<k;i++) {\\n            vector<int> v;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                v.push_back(arr[j]);\\n            }\\n            \\n            sort(v.begin() , v.end());\\n            \\n            long long midv = v[v.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n        \\n        // if(n%k != 0) {\\n        //     sort(arr.begin() , arr.end());\\n        //     long long mid = arr[n/2];\\n        //     for(int i=0;i<n;i++) ans += abs(mid - arr[i]);\\n        // }\\n        // else {\\n        \\n        k = __gcd(k , n);\\n        for(int i=0;i<k;i++) {\\n            vector<int> v;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                v.push_back(arr[j]);\\n            }\\n            \\n            sort(v.begin() , v.end());\\n            \\n            long long midv = v[v.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605884,
                "title": "beat-100-o-n-optimal-solution-selection-instead-of-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n## Subarray Equal Sum\\nIf every $k$-subarray has equal sum, then we have:\\n$$\\na_0 + a_1 + \\\\dots + a_{k-1} = a_1 + \\\\dots + a_{k-1} + a_k\\n\\\\Rightarrow a_0 = a_k\\n$$\\nAnd this applies to every other index, we would now have:\\n$a_i = a_{i + k}$ for every valid index $i$.\\nNot only that, our array is defined to be **circular**, which means when $i+k$ goes out of bounds it \"wraps\" back to the beginning. For example, when $n = 6$ and $k = 4$, we got\\n$$\\na_0 = a_4 \\\\\\\\\\na_1 = a_5\\n$$\\nand when the index \"wraps\" we have \\n$$\\na_2 = a_0 \\\\\\\\\\na_3 = a_1 \\\\\\\\\\na_4 = a_2 \\\\\\\\\\na_5 = a_3\\n$$\\nIf you focus on the pattern you can see that we actually got two \"chains\":\\n$$\\na_0 = a_4 = a_2 = a_0 \\\\\\\\\\na_1 = a_5 = a_3 = a_1\\n$$\\n\\nIt is now pretty straightforward to prove that the conditions of\\n> every $k$-subarray has equal sum\\n\\n is equivalent to \\n> $a_i = a_{i+\\\\gcd(k,n)}$ for every valid index $i$ \\n\\n## Min Operations Needed to Make an Array the Same\\nNow we can copy all numbers from the same \"chain\" into a separate array and solve an easier problem: what\\'s the min ops needed to make this array all equal.\\n\\nIt can be proven that if we operate every numbers in the array \"towards\" the median value we will achieve min ops.\\nWhen the size of the array is an even number, we don\\'t have to use the exact median value, but any value between the middle two values can do.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  * Find the `gcd` of `k` and array size, use that as the `k`\\n  * copy Each \"chain\" of number (in total `k` chains) into a new array.\\n  * Apply the median selection algorithm on the new array and then find the ops needed.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$\\n\\n**Caveate**: `std::nth_element()` is practically very fast but theorectically it is only average $\\\\Theta(N)$ and worst case it\\'s $\\\\Theta(N \\\\log N)$. If it\\'s important to keep it strictly $\\\\Theta(N)$ we need to use another selection algorithm (not readily available in `STL`).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N / \\\\gcd(k, N))$$\\nWe used a buffer to store each \"chain\" of numbers and the chain size is $N / k$ where the $k$ is actually the gcd of the original `k` and `N`.\\n\\nIf we are only allowed to use $O(1)$ extra space, it\\'s possible to do the selection algorithm directly on top of the input `arr` without copying. However, currently it\\'s not easy to adapt an C++ iterator and we would need to implement a selection algorithm ourselves (which I do not recommend unless you are asked to do so).\\n\\n# Code\\n```\\n// Returns the min operations needed to make every number in\\n// `nums` equal.\\nint64_t OpsNeeded(vector<int>& nums) {\\n  auto mid = nums.begin() + nums.size() / 2;\\n  std::nth_element(nums.begin(), mid, nums.end());\\n  const int mid_value = *mid;\\n  int64_t ops = 0;\\n  for (auto it = nums.begin(); it != mid; ++it) {\\n    ops += mid_value - *it;\\n  }\\n  for (auto it = mid + 1; it != nums.end(); ++it) {\\n    ops += *it - mid_value;\\n  }\\n  return ops;\\n}\\n\\nclass Solution {\\npublic:\\n  long long makeSubKSumEqual(vector<int>& arr, int k) {\\n    k = std::gcd(k, arr.size());\\n    if (k == 1) {\\n      return OpsNeeded(arr);\\n    }\\n    vector<int> buffer;\\n    int64_t ops = 0;\\n    for (int r = 0; r < k; ++r) {\\n      for (int i = r; i < arr.size(); i += k) {\\n        buffer.push_back(arr[i]);\\n      }\\n      ops += OpsNeeded(buffer);\\n      buffer.clear();\\n    }\\n    return ops;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Returns the min operations needed to make every number in\\n// `nums` equal.\\nint64_t OpsNeeded(vector<int>& nums) {\\n  auto mid = nums.begin() + nums.size() / 2;\\n  std::nth_element(nums.begin(), mid, nums.end());\\n  const int mid_value = *mid;\\n  int64_t ops = 0;\\n  for (auto it = nums.begin(); it != mid; ++it) {\\n    ops += mid_value - *it;\\n  }\\n  for (auto it = mid + 1; it != nums.end(); ++it) {\\n    ops += *it - mid_value;\\n  }\\n  return ops;\\n}\\n\\nclass Solution {\\npublic:\\n  long long makeSubKSumEqual(vector<int>& arr, int k) {\\n    k = std::gcd(k, arr.size());\\n    if (k == 1) {\\n      return OpsNeeded(arr);\\n    }\\n    vector<int> buffer;\\n    int64_t ops = 0;\\n    for (int r = 0; r < k; ++r) {\\n      for (int i = r; i < arr.size(); i += k) {\\n        buffer.push_back(arr[i]);\\n      }\\n      ops += OpsNeeded(buffer);\\n      buffer.clear();\\n    }\\n    return ops;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411353,
                "title": "proof-why-use-gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven ```n = len(arr)``` and ```k```, we prove that every ```gcd(n,k)```-th element in ```arr``` should be the same in order to make k-subarray sums equal.\\n\\n1. Assume ```arr``` is just a regular array. If ```arr[i]+...+arr[i+k-1] = arr[i+1]+...+arr[i+k]```, then ```arr[i] = arr[i+k]```. Then ```arr[i] = arr[i+mk]``` for any ```m``` as long as ```i+mk < n```.\\n2. If ```arr``` is circular, we could extend the conclusion above to: given ```0<= i,j < n```, if there exist integers ```m, p``` such that ```j = i + mk - pn```, then ```arr[i] = arr[j]```.\\n3. The relationship between ```i, j``` is equivalent to ```j - i = mk - pn = (mk0 - pn0)*gcd(n,k)``` where ```k = k0*gcd(n,k)``` and ```n = n0*gcd(n,k)```. Note that ```gcd(n,k)``` is the greatest common divisor of ```n``` and ```k```, which is an integer greater than equal to ```1```. **Since ```mk0 - pn0``` could be any valid integer, then every ```gcd(n,k)```-th element in ```arr``` should be equal.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCollect every ```gcd(n,k)```-th element in a group, compute the median, calculate the number of adds and removes to move other elements to the median. Sum up all numbers for each group to get the answer.\\n\\n\\n# Complexity\\n- Time complexity: ```O(n log n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(n)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        ans, d = 0, math.gcd(n,k)\\n        for i in range(d):\\n            subarr = sorted(arr[i:n:d])\\n            median = subarr[len(subarr)//2]\\n            ans += sum(abs(a - median) for a in subarr)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```n = len(arr)```\n```k```\n```gcd(n,k)```\n```arr```\n```arr```\n```arr[i]+...+arr[i+k-1] = arr[i+1]+...+arr[i+k]```\n```arr[i] = arr[i+k]```\n```arr[i] = arr[i+mk]```\n```m```\n```i+mk < n```\n```arr```\n```0<= i,j < n```\n```m, p```\n```j = i + mk - pn```\n```arr[i] = arr[j]```\n```i, j```\n```j - i = mk - pn = (mk0 - pn0)*gcd(n,k)```\n```k = k0*gcd(n,k)```\n```n = n0*gcd(n,k)```\n```gcd(n,k)```\n```n```\n```k```\n```1```\n```mk0 - pn0```\n```gcd(n,k)```\n```arr```\n```gcd(n,k)```\n```O(n log n)```\n```O(n)```\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        ans, d = 0, math.gcd(n,k)\\n        for i in range(d):\\n            subarr = sorted(arr[i:n:d])\\n            median = subarr[len(subarr)//2]\\n            ans += sum(abs(a - median) for a in subarr)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394943,
                "title": "unionfind-solution-intuitive-but-slow",
                "content": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.rank = [1 for i in range(n)]\\n        self.pr = [i for i in range(n)]\\n    \\n    def union(self, n1, n2):\\n        p1, p2 = self.find(n1), self.find(n2)\\n        if p1 != p2:\\n            if self.rank[p1] >= self.pr[p2]:\\n                self.rank[p1] += self.rank[p2]\\n                self.pr[p2] = p1\\n            else:\\n                self.rank[p2] += self.pr[p1]\\n                self.pr[p1] = p2\\n    \\n    def find(self, n) -> int:\\n        while n != self.pr[n]:\\n            n = self.pr[n]\\n        return n\\n\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        # 2023/04/08 11:02AM -> 11:52AM\\n        # create unionFind object\\n        uf = UnionFind(len(arr))\\n        # connect indices that need to equal\\n        for i in range(len(arr)):\\n            n1, n2 = i, (i + k) % len(arr)\\n            uf.union(n1, n2)\\n        groups = collections.defaultdict(list)\\n        # get groups\\n        for i, a in enumerate(arr):\\n            groups[uf.find(i)].append(a)\\n        # loop thru groups\\n        res = 0\\n        for p, l in groups.items():\\n            target = int(median(l))\\n            for i in l:\\n                res += abs(i - target)\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.rank = [1 for i in range(n)]\\n        self.pr = [i for i in range(n)]\\n    \\n    def union(self, n1, n2):\\n        p1, p2 = self.find(n1), self.find(n2)\\n        if p1 != p2:\\n            if self.rank[p1] >= self.pr[p2]:\\n                self.rank[p1] += self.rank[p2]\\n                self.pr[p2] = p1\\n            else:\\n                self.rank[p2] += self.pr[p1]\\n                self.pr[p1] = p2\\n    \\n    def find(self, n) -> int:\\n        while n != self.pr[n]:\\n            n = self.pr[n]\\n        return n\\n\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        # 2023/04/08 11:02AM -> 11:52AM\\n        # create unionFind object\\n        uf = UnionFind(len(arr))\\n        # connect indices that need to equal\\n        for i in range(len(arr)):\\n            n1, n2 = i, (i + k) % len(arr)\\n            uf.union(n1, n2)\\n        groups = collections.defaultdict(list)\\n        # get groups\\n        for i, a in enumerate(arr):\\n            groups[uf.find(i)].append(a)\\n        # loop thru groups\\n        res = 0\\n        for p, l in groups.items():\\n            target = int(median(l))\\n            for i in l:\\n                res += abs(i - target)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376184,
                "title": "python-explanation-why-gcd",
                "content": "Right from the beginning: I am not that smart to solve this by myself. It took some time to read the solutions given by others. Specifically [this post](https://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3366442/python3-find-median-of-each-gcd-defined-subarray-w-examples/) by [xil899](https://leetcode.com/xil899/) was very helpful\\n\\n# Approach\\nFirst let\\'s deal with the regular array taking, for example, `k = 4` and writing the conditions to be satisfied for subarrays to be equal\\n\\n$$ a_{0} + a_{1} + a_{2} + a_{3} = a_{1} + a_{2}+ a_{3} + a_{4};   \\\\rightarrow a_{0} = a_{4}$$\\n$$ a_{1} + a_{2}+ a_{3} + a_{4} = a_{2} + a_{3}+ a_{4} + a_{5};   \\\\rightarrow a_{1} = a_{5}$$\\n$$ a_{2} + a_{3}+ a_{4} + a_{5} = a_{3}+ a_{4} + a_{5} + a_{6};   \\\\rightarrow a_{2} = a_{6}$$\\n$$ a_{3}+ a_{4} + a_{5} + a_{6} = a_{4} + a_{5} + a_{6} + a_{7} ;   \\\\rightarrow a_{3} = a_{7}$$\\n...\\nYou probably got the point. Now we know that to make all subarrays of length `k` equal we must have\\n$$ a_{0} = a_{4} = a_{8} = ...$$\\n$$ a_{1} = a_{5} = a_{9} = ...$$\\n$$ a_{2} = a_{6} = a_{10} = ...$$\\n...\\n\\nNow for each of a<sub>i</sub> group that needs to be equal we have to solve problem [462 \"Minimum Moves to Equal Array Elemens II\"](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/).\\n\\nThe basic idea is the following. For array of two elements `[a, b]`, `a < b` we can select any number `num` between them `a <= num <= b` and equalize `a` and `b` to `num`. The result will be the same regardless of exact `num` value since `num - a + b - num = b - a`.\\nFor the array of length > `2`, we can follow the same logic: select min and max elements of the array. `num` should be between them. Now, delete these two elements and repeat. Finally we end up either with a single element if array size is odd, or with two remaining elements either of which can be selected. Half of deleted elements will be greater (or equal) than remaining element(s), and another half - smaller (or equal). Thus, basically we need to find a median of an array.\\nThe solution of this part (minimum number of operations to equalize array) from [problem 462](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/) is\\n```python\\ndef minMoves2(nums: List[int]) -> int:\\n    median = sorted(nums)[len(nums)//2]\\n    return sum(abs(num - median) for num in nums)\\n# end minMoves2(...)\\n```\\nNow the tricky part: we have to deal somehow with the fact the array is circular. In brief, all the elements with distance equal to the greatest common divisor of `n` and `k` fall into the same group that needs to be equalized. This is demonstrated on the following picture\\n![2607.jpg](https://assets.leetcode.com/users/images/5fac816b-0e10-489a-bf3f-a801ecd1e206_1680551796.0497987.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        ans = 0\\n        n = len(arr)\\n        step = gcd(n, k)\\n        for i in range(step):\\n            nums = arr[i::step]\\n            nums.sort()\\n            median_idx = len(nums)//2\\n            median = nums[median_idx]\\n            for num in nums[:median_idx]:\\n                ans += median - num\\n            for num in nums[median_idx:]:\\n                ans += num - median\\n        return ans\\n    # end makeSubKSumEqual()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\ndef minMoves2(nums: List[int]) -> int:\\n    median = sorted(nums)[len(nums)//2]\\n    return sum(abs(num - median) for num in nums)\\n# end minMoves2(...)\\n```\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        ans = 0\\n        n = len(arr)\\n        step = gcd(n, k)\\n        for i in range(step):\\n            nums = arr[i::step]\\n            nums.sort()\\n            median_idx = len(nums)//2\\n            median = nums[median_idx]\\n            for num in nums[:median_idx]:\\n                ans += median - num\\n            for num in nums[median_idx:]:\\n                ans += num - median\\n        return ans\\n    # end makeSubKSumEqual()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374945,
                "title": "simple-sorting-c-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity/ -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll res=0;\\n        int n=arr.size();\\n        for(int i=0; i<k; i++){\\n            vector<ll> t;\\n            for(int j=i; arr[j]; j=(j+k)%n){\\n                t.push_back(arr[j]);\\n                arr[j]=0;\\n            }\\n            if(t.size()){\\n                sort(t.begin(), t.end());\\n                ll med=t[t.size()/2];\\n                for(ll no:t)\\n                    res+=abs(no-med);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// [1,4,1,3], 2\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll res=0;\\n        int n=arr.size();\\n        for(int i=0; i<k; i++){\\n            vector<ll> t;\\n            for(int j=i; arr[j]; j=(j+k)%n){\\n                t.push_back(arr[j]);\\n                arr[j]=0;\\n            }\\n            if(t.size()){\\n                sort(t.begin(), t.end());\\n                ll med=t[t.size()/2];\\n                for(ll no:t)\\n                    res+=abs(no-med);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// [1,4,1,3], 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373176,
                "title": "python-greatest-common-divisor-o-n-log-n",
                "content": "1. Consider the example:\\n![image](https://assets.leetcode.com/users/images/26344d41-8ebe-4aa1-91cf-f15912b80fd1_1680499535.2074687.png)\\n`arr[0] + arr[1] + arr[2] + arr[3] = arr[1] + arr[2] + arr[3] + arr[4]`, so `arr[0] = arr[4]`. \\nBy similar calculation we have `arr[0] = arr[4] = arr[2]`, `arr[1] = arr[5] = arr[3]`.\\n2. As above, `arr` can be divided into subarrays of equal length, and the length would be `g := gcd(len(arr), k)`.\\n3. All subarrays would look the same after we finish operations, i.e. `arr[i] = arr[i+g] = arr[i+2*g] = ... for all i`.\\n4. Now the problem becomes: given some integers `i_0, i_1, i_2, ..., i_n`, what `x` would make the sum `abs(i_0 - x) + abs(i_1 - x) + abs(i_2 - x) + ... + abs(i_n - x)` smallest?\\n`x = median(i_0, i_1, i_2, ..., i_n)` would do.\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        gcd = math.gcd(len(arr), k)\\n        \\n        ans = 0\\n        for i in range(gcd):\\n            seq = arr[i::gcd]\\n            m = int(statistics.median(seq))\\n            for n in seq:\\n                ans += abs(n-m)\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. Consider the example:\\n![image](https://assets.leetcode.com/users/images/26344d41-8ebe-4aa1-91cf-f15912b80fd1_1680499535.2074687.png)\\n`arr[0] + arr[1] + arr[2] + arr[3] = arr[1] + arr[2] + arr[3] + arr[4]`, so `arr[0] = arr[4]`. \\nBy similar calculation we have `arr[0] = arr[4] = arr[2]`, `arr[1] = arr[5] = arr[3]`.\\n2. As above, `arr` can be divided into subarrays of equal length, and the length would be `g := gcd(len(arr), k)`.\\n3. All subarrays would look the same after we finish operations, i.e. `arr[i] = arr[i+g] = arr[i+2*g] = ... for all i`.\\n4. Now the problem becomes: given some integers `i_0, i_1, i_2, ..., i_n`, what `x` would make the sum `abs(i_0 - x) + abs(i_1 - x) + abs(i_2 - x) + ... + abs(i_n - x)` smallest?\\n`x = median(i_0, i_1, i_2, ..., i_n)` would do.\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        gcd = math.gcd(len(arr), k)\\n        \\n        ans = 0\\n        for i in range(gcd):\\n            seq = arr[i::gcd]\\n            m = int(statistics.median(seq))\\n            for n in seq:\\n                ans += abs(n-m)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3370030,
                "title": "python-update-index-in-cycles-median-explained",
                "content": "**Intuition:**\\n* In order to have K-subarrays sums be equal, for all `i`, `arr[i] == arr[i+k] == arr[i+2*k] ...`.\\n* So we have to update every all these groups of `i` to be the same.\\n* For a particular `i`, we first find all the numbers belonging to that group. Each `i` can only belong to one group, so we used a `visited` boolean array to mark them.\\n* For each group, we need to find the minimal update, that is, which elements has the smallest difference between all elements in a group? That is the median.\\n* The number of operations in each `i` group is the absolute difference of all the elements and the median.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        N = len(arr)\\n        visited = [False]*N\\n        operations = 0\\n        for i in range(N):\\n            if visited[i]:\\n                continue\\n            visited[i] = True\\n            group = [arr[i]]\\n            j = (i+k)%N\\n            while not visited[j]:\\n                group.append(arr[j])\\n                visited[j] = True\\n                j = (j+k)%N\\n            group.sort()\\n            median = group[len(group)//2]\\n            operations += sum(abs(num-median) for num in group)\\n        return operations\\n```\\n\\n**Complexity Analysis:**\\n- Time Complexity: `O(NlogN)`\\n\\t- In the worst case, the sort will have `N` elements, this happens when `k=1`.\\n- Space Complexity: `O(N)`\\n\\t- For the `visited` boolean array.",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        N = len(arr)\\n        visited = [False]*N\\n        operations = 0\\n        for i in range(N):\\n            if visited[i]:\\n                continue\\n            visited[i] = True\\n            group = [arr[i]]\\n            j = (i+k)%N\\n            while not visited[j]:\\n                group.append(arr[j])\\n                visited[j] = True\\n                j = (j+k)%N\\n            group.sort()\\n            median = group[len(group)//2]\\n            operations += sum(abs(num-median) for num in group)\\n        return operations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367794,
                "title": "golang-time-o-nlogn-gcd-medians",
                "content": "# Approach\\nFind Greatest common divisor of the array length and k.\\nFor example length=16, k=12, then GCD=4.\\n\\n```\\n______k=12_elements____\\n2,3,4,9,8,7,6,5,4,1,2,3,6,4,3,8\\n\\u203EGCD=4\\u203E\\n```\\n\\nWe split the list into chunks of length GCD=4.\\nNow we need to consider only the 0th elements from each chunk and make them equal, with the minimum number of increment/decrement operations. \\n\\n```\\nv       v       v       v\\n2,3,4,9,8,7,6,2,4,1,7,3,6,5,9,1\\n\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\n\\n[2,8,4,6]\\n```\\nThey must be equal to the median element from the list. The sum of absolute differences between the median and each element is the required minimum of operations to make all elements equal (to median).\\n```\\nmedian([2,8,4,6]) = median([2,4,6,8]) = 6  (or 4, doesn\\'t matter)\\nnum_of_operations = abs(2-6)+abs(4-6)+abs(6-6)+abs(8-6) = 8\\n```\\nCalculate `num_of_operations` for the remaining collections of elements with step GCD\\n```\\n  v       v       v       v\\n6,3,4,9,6,7,6,2,6,1,7,3,6,5,9,1\\n\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\n\\nevery 1st [3,7,1,5]\\nevery 2nd [4,6,7,9]\\nevery 3rd [9,2,3,1]\\n```\\nThe total sum of `num_of_operations` is the answer\\n\\n---\\n\\nAfter applying all the operations (we don\\'t need to actually update the list, it\\'s only for the explanation) the list will look like:\\n```\\n______k=12_elements____\\n6,5,7,3,6,5,7,3,6,5,7,3,6,5,7,3\\n\\u203E\\u203E\\u203E\\u203E\\u203E         \\u203E\\u203Ek=12_elements\\u203E\\u203E\\n```\\nEach sublist with k=12 elements will contain exactly the same set of elements: 3 chunks with [6,5,7,3] elements\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\nSorting lists in order to find median elements.\\nI also tried QuickSelect for finding the medians with avg~O(n), but the runtime was much longer (180ms vs 600ms).\\n\\n- Space complexity: $$O(n/gcd(n,k))$$\\n\\n# Code\\n```\\nfunc makeSubKSumEqual(arr []int, k int) int64 {\\n    n := len(arr)\\n    steppedListNum := gcd(n, k)\\n    steppedListLen := n / steppedListNum\\n    steppedList := make([]int, steppedListLen)\\n    result := 0\\n\\n    for shift:=0; shift<steppedListNum; shift++ {\\n        for i:=0; i<steppedListLen; i++ {\\n            steppedList[i] = arr[i*steppedListNum + shift]\\n        }\\n        sort.Ints(steppedList)\\n        median := steppedList[steppedListLen/2]\\n        for _, el := range steppedList {\\n            result += abs(median-el)\\n        }\\n    }\\n    return int64(result)\\n}\\n\\nfunc gcd(a, b int) int {\\n    for b != 0 {\\n        a, b = b, a%b\\n    }\\n    return a\\n}\\n\\nfunc abs(a int) int {\\n    if a >= 0 { return a }\\n    return -a\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array"
                ],
                "code": "```\\n______k=12_elements____\\n2,3,4,9,8,7,6,5,4,1,2,3,6,4,3,8\\n\\u203EGCD=4\\u203E\\n```\n```\\nv       v       v       v\\n2,3,4,9,8,7,6,2,4,1,7,3,6,5,9,1\\n\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\n\\n[2,8,4,6]\\n```\n```\\nmedian([2,8,4,6]) = median([2,4,6,8]) = 6  (or 4, doesn\\'t matter)\\nnum_of_operations = abs(2-6)+abs(4-6)+abs(6-6)+abs(8-6) = 8\\n```\n```\\n  v       v       v       v\\n6,3,4,9,6,7,6,2,6,1,7,3,6,5,9,1\\n\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E|\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\u203E\\n\\nevery 1st [3,7,1,5]\\nevery 2nd [4,6,7,9]\\nevery 3rd [9,2,3,1]\\n```\n```\\n______k=12_elements____\\n6,5,7,3,6,5,7,3,6,5,7,3,6,5,7,3\\n\\u203E\\u203E\\u203E\\u203E\\u203E         \\u203E\\u203Ek=12_elements\\u203E\\u203E\\n```\n```\\nfunc makeSubKSumEqual(arr []int, k int) int64 {\\n    n := len(arr)\\n    steppedListNum := gcd(n, k)\\n    steppedListLen := n / steppedListNum\\n    steppedList := make([]int, steppedListLen)\\n    result := 0\\n\\n    for shift:=0; shift<steppedListNum; shift++ {\\n        for i:=0; i<steppedListLen; i++ {\\n            steppedList[i] = arr[i*steppedListNum + shift]\\n        }\\n        sort.Ints(steppedList)\\n        median := steppedList[steppedListLen/2]\\n        for _, el := range steppedList {\\n            result += abs(median-el)\\n        }\\n    }\\n    return int64(result)\\n}\\n\\nfunc gcd(a, b int) int {\\n    for b != 0 {\\n        a, b = b, a%b\\n    }\\n    return a\\n}\\n\\nfunc abs(a int) int {\\n    if a >= 0 { return a }\\n    return -a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367625,
                "title": "cluster-partition-of-indices-elements-congruence-python",
                "content": "```\\n\"\"\"\\nTreatment: Congruence\\n\\nThe requirment in this problem actually partitions the indices into clusters.\\nWithin each cluster, all the corresponding elements shall be equal. To make all\\nelements within a cluster equal, we make all element equal to the median.\\n\\nE.g. arr = [2,5,5,7] = [a_0, a_1, a_2, a_3], k = 3\\n\\nTo make length-k sum to be equal, we need:\\n\\na_0 + a_1 + a_2 = a_1 + a_2 + a_3 => a_0 = a_3\\na_1 + a_2 + a_3 = a_2 + a_3 + a_0 => a_1 = a_0 \\na_2 + a_3 + a_1 = a_3 + a_1 + a_2 => a_3 = a_1\\na_3 + a_0 + a_1. = a_0 + a_1 + a_2 => a3 = a_2\\n\\nThis induces a single cluster: {0, 1, 2, 3}. So we need to use as less ops as possible\\nto make all the corresponding 4 elements equal.\\n\\nLet us see the same arr with k = 2:\\n\\na_0 + a_1 = a_1 + a_2 => a_0 = a_2\\na_1 + a_2 = a_2 + a_3 => a_1 = a_3\\na_2 + a_3 = a_3 + a_0 => a_2 = a_0\\na_3 + a_0 = a_0 + a_1 => a_3 = a_1\\n\\nThis induces two clusters: {0, 2}, {1, 3}. So we need to use as less ops as possible\\nto make elements in each cluster equal.\\n\\nHow to get the clusters?\\n\\nLet d = gcd(n, k) where n = len(arr). Then starting from an fixed index, say i_0,\\nthen indices of form i_0 + k * d lie in the same group/cluster. In other words,\\ntwo indices i, j lie in the same cluster if and only if i - j = 0 (mod d). Or in plain\\nEnglish, the difference between i, j is a multiple of d.\\n\\nIn the example above, when k = 3, d = gcd(4, 3) = 1; while when k = 2,  d = gcd(4, 2) = 2.\\n\\nFollow up at Youtube Channel \"Code-Yao\"\\n\"\"\"\\n\\n\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        d = math.gcd(n, k)\\n        res = 0\\n        for i in range(d):\\n            tmp = sorted([arr[j] for j in range(i, n, d)])\\n            median = tmp[len(tmp) // 2]\\n            res += sum(abs(num - median) for num in tmp)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nTreatment: Congruence\\n\\nThe requirment in this problem actually partitions the indices into clusters.\\nWithin each cluster, all the corresponding elements shall be equal. To make all\\nelements within a cluster equal, we make all element equal to the median.\\n\\nE.g. arr = [2,5,5,7] = [a_0, a_1, a_2, a_3], k = 3\\n\\nTo make length-k sum to be equal, we need:\\n\\na_0 + a_1 + a_2 = a_1 + a_2 + a_3 => a_0 = a_3\\na_1 + a_2 + a_3 = a_2 + a_3 + a_0 => a_1 = a_0 \\na_2 + a_3 + a_1 = a_3 + a_1 + a_2 => a_3 = a_1\\na_3 + a_0 + a_1. = a_0 + a_1 + a_2 => a3 = a_2\\n\\nThis induces a single cluster: {0, 1, 2, 3}. So we need to use as less ops as possible\\nto make all the corresponding 4 elements equal.\\n\\nLet us see the same arr with k = 2:\\n\\na_0 + a_1 = a_1 + a_2 => a_0 = a_2\\na_1 + a_2 = a_2 + a_3 => a_1 = a_3\\na_2 + a_3 = a_3 + a_0 => a_2 = a_0\\na_3 + a_0 = a_0 + a_1 => a_3 = a_1\\n\\nThis induces two clusters: {0, 2}, {1, 3}. So we need to use as less ops as possible\\nto make elements in each cluster equal.\\n\\nHow to get the clusters?\\n\\nLet d = gcd(n, k) where n = len(arr). Then starting from an fixed index, say i_0,\\nthen indices of form i_0 + k * d lie in the same group/cluster. In other words,\\ntwo indices i, j lie in the same cluster if and only if i - j = 0 (mod d). Or in plain\\nEnglish, the difference between i, j is a multiple of d.\\n\\nIn the example above, when k = 3, d = gcd(4, 3) = 1; while when k = 2,  d = gcd(4, 2) = 2.\\n\\nFollow up at Youtube Channel \"Code-Yao\"\\n\"\"\"\\n\\n\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        d = math.gcd(n, k)\\n        res = 0\\n        for i in range(d):\\n            tmp = sorted([arr[j] for j in range(i, n, d)])\\n            median = tmp[len(tmp) // 2]\\n            res += sum(abs(num - median) for num in tmp)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367330,
                "title": "video-editorial-100-working",
                "content": "Link of the video - https://www.youtube.com/watch?v=86doDvV6Gdc&t=2s\\n\\n\\nHope it helps!\\nPlease like, share and subscribe if it does.",
                "solutionTags": [
                    "C++"
                ],
                "code": "Link of the video - https://www.youtube.com/watch?v=86doDvV6Gdc&t=2s\\n\\n\\nHope it helps!\\nPlease like, share and subscribe if it does.",
                "codeTag": "Unknown"
            },
            {
                "id": 3367155,
                "title": "detailed-explanation-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you observe then you get to know that the condition must be arr[i]==arr[i+k] and arr[i]==arr[i+2*k] and so on.so, lets take the all number from i, i+k, i+2*k ... so on.Then, make all the element equal. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere\\'s a detailed explanation of the code:\\n\\n1.Define a macro for long long (ll), which makes it easier to use long long integers in the code.\\n\\n2.The solve() function takes a vector of integers v as input and returns a long long integer. This function calculates the minimum total cost to make all elements in the vector v equal. The steps are as follows:\\na. Sort the vector v in non-decreasing order.\\nb. Find the median element in the vector v using the nth_element function from the C++ Standard Library.\\nc. Initialize a variable ans to store the total cost, initially set to 0.\\nd. Iterate through each element in the vector v and add the absolute difference between the current element and the median value to ans.\\ne. Return the total cost ans.\\n\\n3.The makeSubKSumEqual() function takes a vector of integers arr and an integer k as input and returns a long long integer. This function calculates the minimum total cost to make the sum of elements in every subsequence of length k equal in the array arr. The steps are as follows:\\na. Initialize a variable ans to store the total cost, initially set to 0.\\nb. Iterate through each element in the array arr using the variable i.\\nc. If the current element arr[i] is not 0, perform the following steps:\\n\\n->Initialize a vector v to store the elements of the subsequence.\\n\\n->Iterate through the array arr starting from the index i, with a step size of k. For each element in this iteration, add the element to the vector v and set the corresponding element in arr to 0.\\n\\n->Call the solve() function with the vector v as input and add the returned cost to ans.\\n\\n4.Return the total cost ans from the makeSubKSumEqual() function.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll solve(vector<int> &v)\\n    {\\n     sort(v.begin(),v.end());\\n     int n;\\n     nth_element(begin(v), begin(v) + v.size() / 2, end(v));\\n      n=v[v.size()/2];\\n     ll ans=0;\\n     for(int i=0;i<v.size();i++)\\n     {\\n       ans+=(abs(n-v[i]));  \\n     }\\n     return ans;\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n    ll ans=0;\\n    int n=arr.size();\\n    for(int i=0;i<n;i++)\\n    {\\n      vector<int> v;  \\n     if(arr[i]!=0)\\n     {\\n      for(int j=i;arr[j%n]!=0;j+=k)\\n      {\\n       j=j%n;\\n       v.push_back(arr[j]);\\n       arr[j]=0;\\n      }\\n       ans+=(solve(v));  \\n     }   \\n    }\\n    return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll solve(vector<int> &v)\\n    {\\n     sort(v.begin(),v.end());\\n     int n;\\n     nth_element(begin(v), begin(v) + v.size() / 2, end(v));\\n      n=v[v.size()/2];\\n     ll ans=0;\\n     for(int i=0;i<v.size();i++)\\n     {\\n       ans+=(abs(n-v[i]));  \\n     }\\n     return ans;\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n    ll ans=0;\\n    int n=arr.size();\\n    for(int i=0;i<n;i++)\\n    {\\n      vector<int> v;  \\n     if(arr[i]!=0)\\n     {\\n      for(int j=i;arr[j%n]!=0;j+=k)\\n      {\\n       j=j%n;\\n       v.push_back(arr[j]);\\n       arr[j]=0;\\n      }\\n       ans+=(solve(v));  \\n     }   \\n    }\\n    return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366846,
                "title": "javascript-median-greedy-254ms",
                "content": "```\\nconst makeSubKSumEqual = (a, k) => medianGreedy(a, k)\\n\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\nconst medianGreedy = (a, k) => {\\n    k = gcd(a.length, k);\\n    let res = 0;\\n    for (let i = 0; i < k; i++) {\\n        let b = [];\\n        for (let j = i; j < a.length; j += k) b.push(a[j]); // collect gcd(n, k) elements based on B\\xE9zout\\'s identity\\n        b.sort((x, y) => x - y);\\n        let mid = b[b.length >> 1];\\n        for (const x of b) res += Math.abs(x - mid); // greedy: reach to median have lowest cost\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nconst makeSubKSumEqual = (a, k) => medianGreedy(a, k)\\n\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\nconst medianGreedy = (a, k) => {\\n    k = gcd(a.length, k);\\n    let res = 0;\\n    for (let i = 0; i < k; i++) {\\n        let b = [];\\n        for (let j = i; j < a.length; j += k) b.push(a[j]); // collect gcd(n, k) elements based on B\\xE9zout\\'s identity\\n        b.sort((x, y) => x - y);\\n        let mid = b[b.length >> 1];\\n        for (const x of b) res += Math.abs(x - mid); // greedy: reach to median have lowest cost\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366676,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        g = gcd(n, k)\\n        ret = 0\\n        for i in range(g):\\n            med = int(median(arr[i::g]))\\n            ret += sum(abs(a-med) for a in arr[i::g])\\n            \\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        g = gcd(n, k)\\n        ret = 0\\n        for i in range(g):\\n            med = int(median(arr[i::g]))\\n            ret += sum(abs(a-med) for a in arr[i::g])\\n            \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366621,
                "title": "python-3-disjoin-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass ufds:\\n    parent_node = {}\\n    rank = {}\\n\\n    def make_set(self, u):\\n        for i in u:\\n            self.parent_node[i] = i\\n            self.rank[i] = 0\\n\\n    def op_find(self, k):\\n        if self.parent_node[k] != k:\\n            self.parent_node[k] = self.op_find(self.parent_node[k])\\n        return self.parent_node[k]\\n\\n    def op_union(self, a, b):\\n        x = self.op_find(a)\\n        y = self.op_find(b)\\n        \\n        if x == y:\\n            return\\n        if self.rank[x] > self.rank[y]:\\n            self.parent_node[y] = x\\n        elif self.rank[x] < self.rank[y]:\\n            self.parent_node[x] = y\\n        else:\\n            self.parent_node[x] = y\\n            self.rank[y] = self.rank[y] + 1\\n\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        def find_min_abs_sum(arr):\\n            n = len(arr)\\n            arr.sort()\\n            middle = arr[n//2]\\n            curr = 0\\n            for i in arr:\\n                curr += abs(i-middle)\\n            return curr\\n    \\n        if k==1:\\n            return find_min_abs_sum(arr)\\n\\n        uds = ufds()\\n        n = len(arr)\\n        uds.make_set(list(range(n)))\\n\\n        for i in range(n):\\n            uds.op_union(i, (i + k) % n)\\n\\n        dd = defaultdict(list)\\n        for i in range(n):\\n            dd[uds.op_find(i)].append(arr[i])\\n            \\n        res = 0\\n        for key in dd:\\n            temarr = dd[key]\\n            res += find_min_abs_sum(temarr)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass ufds:\\n    parent_node = {}\\n    rank = {}\\n\\n    def make_set(self, u):\\n        for i in u:\\n            self.parent_node[i] = i\\n            self.rank[i] = 0\\n\\n    def op_find(self, k):\\n        if self.parent_node[k] != k:\\n            self.parent_node[k] = self.op_find(self.parent_node[k])\\n        return self.parent_node[k]\\n\\n    def op_union(self, a, b):\\n        x = self.op_find(a)\\n        y = self.op_find(b)\\n        \\n        if x == y:\\n            return\\n        if self.rank[x] > self.rank[y]:\\n            self.parent_node[y] = x\\n        elif self.rank[x] < self.rank[y]:\\n            self.parent_node[x] = y\\n        else:\\n            self.parent_node[x] = y\\n            self.rank[y] = self.rank[y] + 1\\n\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        def find_min_abs_sum(arr):\\n            n = len(arr)\\n            arr.sort()\\n            middle = arr[n//2]\\n            curr = 0\\n            for i in arr:\\n                curr += abs(i-middle)\\n            return curr\\n    \\n        if k==1:\\n            return find_min_abs_sum(arr)\\n\\n        uds = ufds()\\n        n = len(arr)\\n        uds.make_set(list(range(n)))\\n\\n        for i in range(n):\\n            uds.op_union(i, (i + k) % n)\\n\\n        dd = defaultdict(list)\\n        for i in range(n):\\n            dd[uds.op_find(i)].append(arr[i])\\n            \\n        res = 0\\n        for key in dd:\\n            temarr = dd[key]\\n            res += find_min_abs_sum(temarr)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057530,
                "title": "simple-solution-with-better-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We have to restructure the array in such a way that it contains a pattern like,  the element going out from the window is similar to the element comming into the window\\n- (x, y, z, x, y, z, x, y, z) for window of size 3\\n- pattern size must be equal to the gcd(n, k)\\n- x_g = median(a[i], a[i + g], a[i + 2g], ....)\\n- So the total number of operation for each element will be equal to abs(x_g - arr[i + g])\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: $$O(n)$$ -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: $$O(n)$$\\nAdd your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        n = len(arr)\\n        g = gcd(n, k)   # pattern_len\\n        ans = 0\\n\\n        for i in range(g):\\n        \\n            # Finding the median of (a[i], a[i + g], a[i + 2g], ....)\\n            x_g = int(median(arr[i::g]))\\n        \\n            # Finding the total number of operation required to transform the current element to median\\n            ans += sum(abs(x_g - a) for a in arr[i::g])\\n        \\n        return ans\\n\\n```\\n\\nThanks\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3367499/gcd-median-c-python-greedy/",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        n = len(arr)\\n        g = gcd(n, k)   # pattern_len\\n        ans = 0\\n\\n        for i in range(g):\\n        \\n            # Finding the median of (a[i], a[i + g], a[i + 2g], ....)\\n            x_g = int(median(arr[i::g]))\\n        \\n            # Finding the total number of operation required to transform the current element to median\\n            ans += sum(abs(x_g - a) for a in arr[i::g])\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047055,
                "title": "detailed-approach-explanation-math-number-theory",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. All k-sized segments (subarrays) have equal sums | xors <=> arr[i] = arr[i+k].\\n2. Arrays allow circular indexing: gcd(n, k) disjoint sets of indexes needed to cover the entire array. All the sets have the same size = n / gcd(n, k).\\n3. Because of disjoint sets, (1) <=> all elements of each set have to be equal, verify each set independently. So the minimum number of operations is the sum of the minimum number of operations of each set. \\n4. For each set, all its elements end up to be equal to a value c. The number of operations needed is f(c) = sum(|element - c|). c yields the minimum number of operations <=> differentiation of f(c): f\\'(c) = 0 <=> c is median. In case set.size is even, choosing any c in [leftMedian, rightMedian] still produce minimum. (leftMedian, rightMedian are elements that contributes to the median).\\n\\n# Complexity\\n- Time complexity: depends on the algorithm Find median is used.\\n    Comparison-based Sort: O(nlogn).\\n    Random partition: O(n), average running time. (used in code)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n / gcd(n/k))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\n\\nfunction gcd(a, b){\\n    if(b == 0){\\n        return a;\\n    }\\n\\n    return gcd(b, a%b);\\n}\\nfunction partition(arr, left, right){\\n    if(left >= right){\\n        return left;\\n    }\\n    let randomPivotIdx = left + Math.floor(Math.random() * (right - left + 1));\\n    [arr[right], arr[randomPivotIdx]] = [arr[randomPivotIdx], arr[right]];\\n\\n\\n    let i = left - 1;\\n    for(let j = left; j < right; j++){\\n        if(arr[j] >= arr[right]){\\n            continue;\\n        }\\n\\n        [arr[j], arr[i+1]] = [arr[i+1], arr[j]];\\n        i++;\\n    }\\n    [arr[right], arr[i+1]] = [arr[i+1], arr[right]];\\n\\n    \\n    return i + 1;\\n}\\n\\nfunction findMedian(arr){\\n    if(arr.length <= 2){\\n        return arr[0];\\n    }\\n    let left = 0;\\n    let right = arr.length - 1;\\n    let medianIdx = Math.floor(arr.length / 2);\\n    let mid;\\n    while((mid = partition(arr, left, right)) != medianIdx){\\n        if(mid < medianIdx){\\n            left = mid + 1;\\n        }else{\\n            right = mid - 1;\\n        }\\n    }\\n\\n    return arr[mid];\\n}\\n\\nvar makeSubKSumEqual = function(arr, k) {\\n    let n = arr.length;\\n    let numbOfSets = gcd(n, k);\\n    let setSize = n / numbOfSets;\\n    let minOps = 0;\\n\\n    // \\n    for(let i = 0; i < numbOfSets; i++){\\n        let set = [];\\n        for(let j = 0; j < setSize; j++){\\n            set.push(arr[(i + j*k) % n]);\\n        }\\n\\n        // let medianSet = set.sort((a,b) => a-b)[Math.floor(set.length/2)];\\n        let medianSet = findMedian(set);\\n        set.forEach(element => minOps += Math.abs(element -medianSet));\\n    }\\n\\n    return minOps;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\n\\nfunction gcd(a, b){\\n    if(b == 0){\\n        return a;\\n    }\\n\\n    return gcd(b, a%b);\\n}\\nfunction partition(arr, left, right){\\n    if(left >= right){\\n        return left;\\n    }\\n    let randomPivotIdx = left + Math.floor(Math.random() * (right - left + 1));\\n    [arr[right], arr[randomPivotIdx]] = [arr[randomPivotIdx], arr[right]];\\n\\n\\n    let i = left - 1;\\n    for(let j = left; j < right; j++){\\n        if(arr[j] >= arr[right]){\\n            continue;\\n        }\\n\\n        [arr[j], arr[i+1]] = [arr[i+1], arr[j]];\\n        i++;\\n    }\\n    [arr[right], arr[i+1]] = [arr[i+1], arr[right]];\\n\\n    \\n    return i + 1;\\n}\\n\\nfunction findMedian(arr){\\n    if(arr.length <= 2){\\n        return arr[0];\\n    }\\n    let left = 0;\\n    let right = arr.length - 1;\\n    let medianIdx = Math.floor(arr.length / 2);\\n    let mid;\\n    while((mid = partition(arr, left, right)) != medianIdx){\\n        if(mid < medianIdx){\\n            left = mid + 1;\\n        }else{\\n            right = mid - 1;\\n        }\\n    }\\n\\n    return arr[mid];\\n}\\n\\nvar makeSubKSumEqual = function(arr, k) {\\n    let n = arr.length;\\n    let numbOfSets = gcd(n, k);\\n    let setSize = n / numbOfSets;\\n    let minOps = 0;\\n\\n    // \\n    for(let i = 0; i < numbOfSets; i++){\\n        let set = [];\\n        for(let j = 0; j < setSize; j++){\\n            set.push(arr[(i + j*k) % n]);\\n        }\\n\\n        // let medianSet = set.sort((a,b) => a-b)[Math.floor(set.length/2)];\\n        let medianSet = findMedian(set);\\n        set.forEach(element => minOps += Math.abs(element -medianSet));\\n    }\\n\\n    return minOps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042027,
                "title": "java-clean-code-gcd-grouping-median-cost",
                "content": "# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int steps = gcd(arr.length,k);\\n        int numberOfGroups = steps;\\n        long result=0;\\n        for(int groupStartIndex=0;groupStartIndex<numberOfGroups;groupStartIndex++)\\n        {\\n            int groupSize = arr.length / steps;\\n            int group[] = new int[groupSize];\\n            int j=0;\\n            for(int i=groupStartIndex;i<arr.length;i+=steps)\\n            {\\n                group[j] = arr[i];\\n                j++;\\n            }\\n           \\n            Arrays.sort(group);\\n            long operationsToEquateNumstoMedian = 0;\\n            int midIndex = group.length/2;\\n            int median = group[midIndex];\\n            for(int el:group)\\n            {\\n                operationsToEquateNumstoMedian += Math.abs(median-el);\\n            }\\n            result += operationsToEquateNumstoMedian;\\n        }\\n        return result;\\n    }\\n    private int gcd(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        return x;\\n    }\\n}\\n/*\\n\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; k=3 ; n=length\\nNumber of groups = gcd(n,k)\\nSize of each group = n/gcd;\\nG1: 1,4,7,10,13\\nG2: 2,5,8,11,14\\nG3: 3,6,9,12,15\\n\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int steps = gcd(arr.length,k);\\n        int numberOfGroups = steps;\\n        long result=0;\\n        for(int groupStartIndex=0;groupStartIndex<numberOfGroups;groupStartIndex++)\\n        {\\n            int groupSize = arr.length / steps;\\n            int group[] = new int[groupSize];\\n            int j=0;\\n            for(int i=groupStartIndex;i<arr.length;i+=steps)\\n            {\\n                group[j] = arr[i];\\n                j++;\\n            }\\n           \\n            Arrays.sort(group);\\n            long operationsToEquateNumstoMedian = 0;\\n            int midIndex = group.length/2;\\n            int median = group[midIndex];\\n            for(int el:group)\\n            {\\n                operationsToEquateNumstoMedian += Math.abs(median-el);\\n            }\\n            result += operationsToEquateNumstoMedian;\\n        }\\n        return result;\\n    }\\n    private int gcd(int x, int y) {\\n        while (y != 0) {\\n            int tmp = x % y;\\n            x = y;\\n            y = tmp;\\n        }\\n        return x;\\n    }\\n}\\n/*\\n\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; k=3 ; n=length\\nNumber of groups = gcd(n,k)\\nSize of each group = n/gcd;\\nG1: 1,4,7,10,13\\nG2: 2,5,8,11,14\\nG3: 3,6,9,12,15\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925046,
                "title": "beats-92-c-check-this-out",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Try in this way!\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  long long makeSubKSumEqual(vector<int>& arr, int k) {\\n    // If the sum of each subarray of length k is equal, `arr` must have\\n    // repeated pattern of size k. E.g. arr = [1, 2, 3, ...] and k = 3, to have\\n    // sum([1, 2, 3)] == sum([2, 3, x]), x must be 1. Therefore, arr[i] ==\\n    // arr[(i + k) % n] for every i.\\n    const int n = arr.size();\\n    long long ans = 0;\\n    vector<bool> seen(n);\\n\\n    for (int i = 0; i < n; ++i) {\\n      vector<int> groups;\\n      int j = i;\\n      while (!seen[j]) {\\n        groups.push_back(arr[j]);\\n        seen[j] = true;\\n        j = (j + k) % n;\\n      }\\n      nth_element(groups.begin(), groups.begin() + groups.size() / 2,\\n                  groups.end());\\n      for (const int num : groups)\\n        ans += abs(num - groups[groups.size() / 2]);\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  long long makeSubKSumEqual(vector<int>& arr, int k) {\\n    // If the sum of each subarray of length k is equal, `arr` must have\\n    // repeated pattern of size k. E.g. arr = [1, 2, 3, ...] and k = 3, to have\\n    // sum([1, 2, 3)] == sum([2, 3, x]), x must be 1. Therefore, arr[i] ==\\n    // arr[(i + k) % n] for every i.\\n    const int n = arr.size();\\n    long long ans = 0;\\n    vector<bool> seen(n);\\n\\n    for (int i = 0; i < n; ++i) {\\n      vector<int> groups;\\n      int j = i;\\n      while (!seen[j]) {\\n        groups.push_back(arr[j]);\\n        seen[j] = true;\\n        j = (j + k) % n;\\n      }\\n      nth_element(groups.begin(), groups.begin() + groups.size() / 2,\\n                  groups.end());\\n      for (const int num : groups)\\n        ans += abs(num - groups[groups.size() / 2]);\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918931,
                "title": "golang-binary-search-solution",
                "content": "# Code\\n```go\\nfunc makeSubKSumEqual(arr []int, k int) int64 {\\n\\tif len(arr) == k {\\n\\t\\treturn 0\\n\\t}\\n\\tg := gcd(len(arr), k)\\n\\tcost := int64(0)\\n\\tfor i := 0; i < g; i++ {\\n\\t\\telem := make([]int, 0, 16)\\n\\t\\tfor j := i; j < len(arr); j += g {\\n\\t\\t\\telem = append(elem, arr[j])\\n\\t\\t}\\n\\t\\tcost += makeAllEqual(elem)\\n\\t}\\n\\treturn cost\\n}\\n\\nfunc makeAllEqual(arr []int) int64 {\\n\\tif len(arr) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tl, r := arr[0], arr[0]\\n\\tfor _, v := range arr {\\n\\t\\tif l > v {\\n\\t\\t\\tl = v\\n\\t\\t}\\n\\t\\tif r < v {\\n\\t\\t\\tr = v\\n\\t\\t}\\n\\t}\\n\\tm := 0\\n\\tfor l <= r {\\n\\t\\tm = (l+r) >> 1\\n\\t\\tif diff(arr, m) <= diff(arr, m+1) {\\n\\t\\t\\tr = m-1\\n\\t\\t} else {\\n\\t\\t\\tl = m+1\\n\\t\\t}\\n\\t}\\n\\tdiff1 := diff(arr, r+1)\\n\\tdiff2 := diff(arr, l)\\n\\tif diff1 < diff2 {\\n\\t\\treturn diff1\\n\\t}\\n\\treturn diff2\\n}\\n\\nfunc diff(arr []int, d int) int64 {\\n\\tdv := 0\\n\\tfor _, v := range arr {\\n\\t\\tif v >= d {\\n\\t\\t\\tdv += v-d\\n\\t\\t} else {\\n\\t\\t\\tdv += d-v\\n\\t\\t}\\n\\t}\\n\\treturn int64(dv)\\n}\\n\\nfunc gcd(x, y int) int {\\n\\tif x < y {\\n\\t\\tx, y = y, x\\n\\t}\\n\\tif x%y == 0 {\\n\\t\\treturn y\\n\\t}\\n\\treturn gcd(y, x%y)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```go\\nfunc makeSubKSumEqual(arr []int, k int) int64 {\\n\\tif len(arr) == k {\\n\\t\\treturn 0\\n\\t}\\n\\tg := gcd(len(arr), k)\\n\\tcost := int64(0)\\n\\tfor i := 0; i < g; i++ {\\n\\t\\telem := make([]int, 0, 16)\\n\\t\\tfor j := i; j < len(arr); j += g {\\n\\t\\t\\telem = append(elem, arr[j])\\n\\t\\t}\\n\\t\\tcost += makeAllEqual(elem)\\n\\t}\\n\\treturn cost\\n}\\n\\nfunc makeAllEqual(arr []int) int64 {\\n\\tif len(arr) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tl, r := arr[0], arr[0]\\n\\tfor _, v := range arr {\\n\\t\\tif l > v {\\n\\t\\t\\tl = v\\n\\t\\t}\\n\\t\\tif r < v {\\n\\t\\t\\tr = v\\n\\t\\t}\\n\\t}\\n\\tm := 0\\n\\tfor l <= r {\\n\\t\\tm = (l+r) >> 1\\n\\t\\tif diff(arr, m) <= diff(arr, m+1) {\\n\\t\\t\\tr = m-1\\n\\t\\t} else {\\n\\t\\t\\tl = m+1\\n\\t\\t}\\n\\t}\\n\\tdiff1 := diff(arr, r+1)\\n\\tdiff2 := diff(arr, l)\\n\\tif diff1 < diff2 {\\n\\t\\treturn diff1\\n\\t}\\n\\treturn diff2\\n}\\n\\nfunc diff(arr []int, d int) int64 {\\n\\tdv := 0\\n\\tfor _, v := range arr {\\n\\t\\tif v >= d {\\n\\t\\t\\tdv += v-d\\n\\t\\t} else {\\n\\t\\t\\tdv += d-v\\n\\t\\t}\\n\\t}\\n\\treturn int64(dv)\\n}\\n\\nfunc gcd(x, y int) int {\\n\\tif x < y {\\n\\t\\tx, y = y, x\\n\\t}\\n\\tif x%y == 0 {\\n\\t\\treturn y\\n\\t}\\n\\treturn gcd(y, x%y)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3893940,
                "title": "easy-solution-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar makeSubKSumEqual = function (arr, k) {\\n    let result = 0;\\n    const n = arr.length;\\n\\n    for (let i = 0; i < n; i++) {\\n        if (arr[i] === 0) continue;\\n        const temp = [];\\n        let j = i;\\n        while (arr[j] !== 0) {\\n            temp.push(arr[j]);\\n            arr[j] = 0;\\n            j = (j + k) % n;\\n        }\\n        temp.sort((a, b) => a - b);\\n        const midVal = temp[Math.floor(temp.length / 2)];\\n        for (const val of temp) {\\n            result += Math.abs(val - midVal);\\n        }\\n    }\\n\\n    return result;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar makeSubKSumEqual = function (arr, k) {\\n    let result = 0;\\n    const n = arr.length;\\n\\n    for (let i = 0; i < n; i++) {\\n        if (arr[i] === 0) continue;\\n        const temp = [];\\n        let j = i;\\n        while (arr[j] !== 0) {\\n            temp.push(arr[j]);\\n            arr[j] = 0;\\n            j = (j + k) % n;\\n        }\\n        temp.sort((a, b) => a - b);\\n        const midVal = temp[Math.floor(temp.length / 2)];\\n        for (const val of temp) {\\n            result += Math.abs(val - midVal);\\n        }\\n    }\\n\\n    return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810208,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        k = gcd(k, len(arr))\\n\\n        lookup = defaultdict(list)\\n\\n        for i in range(len(arr)):\\n            lookup[i % k].append(arr[i])\\n\\n\\n        ans = 0\\n\\n        for key in lookup:\\n            vals = lookup[key]\\n        \\n            vals.sort()\\n\\n            median = len(vals) // 2\\n            medianVal = vals[median] if len(vals) % 2 else (vals[median] + vals[median - 1]) // 2\\n\\n\\n            for val in vals:\\n                ans += abs(val - medianVal)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        k = gcd(k, len(arr))\\n\\n        lookup = defaultdict(list)\\n\\n        for i in range(len(arr)):\\n            lookup[i % k].append(arr[i])\\n\\n\\n        ans = 0\\n\\n        for key in lookup:\\n            vals = lookup[key]\\n        \\n            vals.sort()\\n\\n            median = len(vals) // 2\\n            medianVal = vals[median] if len(vals) % 2 else (vals[median] + vals[median - 1]) // 2\\n\\n\\n            for val in vals:\\n                ans += abs(val - medianVal)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684927,
                "title": "c-solution-why-we-have-to-use-gcd-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery subarray have to be equal (not all the element have to be equal always) to get the optimal solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow here comes a question of what length of a subarray should we keep equal so that all the k- length subarrays equal. As it is a circular array, if k is divisible by the array size(n) then an element will always face the same need of operation. BUT if not, an element may face another number of operations needed after a rotation traversal of the circular array. This is why we have to do gcd of n and k, so that an element always falls in same situation (same number of operations needed) of every rotation. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans=0;\\n        int n=arr.size();\\n        k=__gcd(k,n);\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int>temp;\\n            for(int j=i;j<n;j+=k)\\n            {\\n                temp.push_back(arr[j]);\\n            }\\n            sort(temp.begin(),temp.end());\\n            long long tar=temp[temp.size()/2];\\n            for(int j=i;j<n;j+=k)\\n            {\\n                ans+=abs(arr[j]-tar);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans=0;\\n        int n=arr.size();\\n        k=__gcd(k,n);\\n        for(int i=0;i<k;i++)\\n        {\\n            vector<int>temp;\\n            for(int j=i;j<n;j+=k)\\n            {\\n                temp.push_back(arr[j]);\\n            }\\n            sort(temp.begin(),temp.end());\\n            long long tar=temp[temp.size()/2];\\n            for(int j=i;j<n;j+=k)\\n            {\\n                ans+=abs(arr[j]-tar);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674710,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long calc(int x,vector<int>&arr)\\n    {\\n        long long sum=0;\\n        for(auto &h:arr)\\n        {\\n            sum+=abs(h-x);\\n        }\\n        return sum;\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        using ll=long long;\\n        vector<int>res(arr.size(),0);\\n        \\n        ll ans=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(res[i])\\n            continue;\\n            vector<int>temp;\\n            int ind=i;\\n            while(res[ind]!=1)\\n            {\\n                temp.push_back(arr[ind]);\\n                res[ind]=1;\\n                ind=(ind+k)%arr.size();\\n            }\\n        sort(temp.begin(),temp.end());\\n        int len=temp.size();\\n        ll p=0;\\n        if(len&1)\\n        {\\n            p=calc(temp[len/2],temp);\\n        }\\n        else{\\n            p=min(calc(temp[len/2],temp),calc(temp[(len/2)-1],temp));\\n        }\\n        ans+=p;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long calc(int x,vector<int>&arr)\\n    {\\n        long long sum=0;\\n        for(auto &h:arr)\\n        {\\n            sum+=abs(h-x);\\n        }\\n        return sum;\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        using ll=long long;\\n        vector<int>res(arr.size(),0);\\n        \\n        ll ans=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(res[i])\\n            continue;\\n            vector<int>temp;\\n            int ind=i;\\n            while(res[ind]!=1)\\n            {\\n                temp.push_back(arr[ind]);\\n                res[ind]=1;\\n                ind=(ind+k)%arr.size();\\n            }\\n        sort(temp.begin(),temp.end());\\n        int len=temp.size();\\n        ll p=0;\\n        if(len&1)\\n        {\\n            p=calc(temp[len/2],temp);\\n        }\\n        else{\\n            p=min(calc(temp[len/2],temp),calc(temp[(len/2)-1],temp));\\n        }\\n        ans+=p;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587547,
                "title": "javascript-math-sort",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar makeSubKSumEqual = function (arr, k) {\\n  let ans = 0;\\n  const n = arr.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    let j = i;\\n    const temp = [];\\n    while (arr[j] !== 0) {\\n      temp.push(arr[j]);\\n      arr[j] = 0;\\n      j = (j + k) % n;\\n    }\\n\\n    temp.sort((a, b) => a - b);\\n    const midVal = temp[Math.floor(temp.length / 2)];\\n    for (const val of temp) {\\n      ans += Math.abs(val - midVal);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar makeSubKSumEqual = function (arr, k) {\\n  let ans = 0;\\n  const n = arr.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    let j = i;\\n    const temp = [];\\n    while (arr[j] !== 0) {\\n      temp.push(arr[j]);\\n      arr[j] = 0;\\n      j = (j + k) % n;\\n    }\\n\\n    temp.sort((a, b) => a - b);\\n    const midVal = temp[Math.floor(temp.length / 2)];\\n    for (const val of temp) {\\n      ans += Math.abs(val - midVal);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3563000,
                "title": "verbose-explanation-of-logic",
                "content": "# Intuition\\nSo the trick to understanding this problem is that logically there is only one way these overlapping k-length subarrays can have an equal sum. That only way is if they have the same elements in the sub arrays. For example the following works:\\n```\\n    [1,2,3,1,2,3,1,2,3]  with k == 3\\n```\\nThere are 9 sub arrays:\\n```\\n    1,2,3\\n    2,3,1\\n    3,1,2\\n    1,2,3\\n    2,3,1\\n    3,1,2\\n    1,2,3\\n    2,3,1 // Note \"1\" from circuling back to beginning\\n    3,1,2 // Note \"1,2\" from circuling back to beginning\\n```\\n\\nThese all have the same sum. **Change any number in the array** and the optimal way to bring the k-sums back to equality will be to make the elements match again. \\n\\nNote, it is not enough to have the same \"elements\" they have to appear in the same order in the original array! Why is that? Because of the overlapping nature of k-sum arrays. Changing one element in the original array changes \"k\" of the sub arrays. In order for the sub arrays to get each of the elements needed to sum then they need to each have right elements. \\n\\nConsider how the last k array uses k-1 elements of the first k array. In the above example the first k-array is \"1,2,3\" and the last one us \"1,2\" from the first array as it loops over the end. The only way for it to match in \"sum\" with the first array is to add a \"3\". For every overlapping k array you can say it needs to have the element of the previous one to have the sum be equal.\\n\\nAll that explanation gives a picture of what the final answer will look like, but not how we get there. We still need to understand how to minimally change it to get there and a nuance on the repeating pattern and GCD.\\n\\nIn order to make the \"minimum number of moves\" we really need to compare the \"stripes\" in the pattern. Those are the pieces we need to be make all identical.\\n\\nAgain in our example above our repeating pattern is \"1,2,3\". Say instead the input array looked like this:\\n```\\n[1,2,3,2,3,4,1,2,3] with k== 3\\n```\\n\\nFor now let\\'s consider our pattern needs to repeat every \"k\" elements. Selecting the \"first\" of the k-repeating pattern we get the following values\\n```\\n    [1,_,_,2,_,_,1,_,_]\\n       or\\n    [1,2,1]\\n```\\n \\nThey all need to be equal. Visually we see the easiest way to make them equal is to turn the 2 into 1. However, programitically to make a list of numbers equal it is best to move them all to the \"median\". The \"median\" of \"1,2,1\" is \"1\". Median can be programmatically found by sorting and taking the middle element:\\n```\\n    [1,1,2] // 1 is the middle element of the sorted list\\n            // and thus the median\\n```\\n\\nThen you have to calculate the distance to move each number to that median. You can use \"absolute value\" and a subtraction for find which is bigger before subracting. Either way just make sure you are calculating the distance and not just the difference (keep answers positive).\\n\\nSum all those distances and you now know the minimum \"cost\" to make one stripe in the puzzle have an equal sum. You\\'ll have to do this for \"k\" stripes.\\n\\n**Wait!** There is one problem! If K does not evenly divide into the length of the array it will cause issues for our pattern. For example if k == 3 and our array is \"8\" long then we can\\'t possibly \"k\" repeat. See this example:\\n```\\n[a,b,c,a,b,c,a,b] with k==3 and a length of 8\\n c\\n```\\nNote with the looping end of the array we want the first element to be both \"c\" and \"a\". That means we canot us a k-length repeating pattern as it does not line up with itself as we loop off the end of the tail. \\n\\nThe best we can do in this case is to make everything the same.\\n```\\n[a,a,a,a,a,a,a,a] with k==3 and a length of 8\\n```\\n\\nWhy not have a two repeating pattern? Because k==3 and they wouldn\\'t have an equal sum\\n```\\n[a,b,a,b,a,b,a,b] with k==3 and a length of 8\\n\\n// k-arrays\\n[a,b,a]\\n[b,a,b] // already not equal.\\n\\n```\\n\\nYou can afford to have some repeating pattern when k does not even divide the length of the array. Taking advantage of that option reduces our total cost and is nescessary to get the minimum. The length is essentially something that will evenly work for the repeating part at the end. \\n\\nFor k==6 and an array of size 9:\\n```\\n[a,b,c,d,e,f,a,b,c] // repeating 6 pattern doesn\\'t work\\n[a,b,c,a,b,c,a,b,c] // repeating 3 pattern does fit!\\n```\\n\\nThe repeating pattern is not \"k\" but rather the greatest common divisor between \"k\" and the array length. \\n\\nReally, this problem should help us understand Euclid\\'s Theorem. Whatever is \"left over\" from a multiple of k will be wrapped back over the array and will need to \"match\" that k. We really only care about the remainder and how it matches up with our repeating pattern.\\n\\nThis concludes everything you need to understand for the intution part.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$ where $$g$$ is the $$gcd(n,k)$$\\n\\n- Space complexity:\\n$$O(n/g)$$ where $$g$$ is the $$gcd(n,k)$$. In some case this is n, so $$O(n)$$ is an appropriate description.\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MakeSubKSumEqual(int[] arr, int k) {\\n        //Intuition:\\n        // In order for the sums to be equal the elements in side need to be equal in a striped pattern throughout the array.\\n        // Since we loop at the end of the array back to the beginning that pattern is not as long as \"k\" but gcd(n,k) so that it\\n        // can match the patter when looping back from the end.\\n        // The optimal item to change them too in a striped segment is the median of the segment.\\n\\n        var g = GCD(k, arr.Length);\\n\\n        var ans = 0L;\\n        for(var i=0; i<g; i++) {\\n            var stripe = new List<int>();\\n            for(var j=i; j<arr.Length; j += g) {\\n                stripe.Add(arr[j]);\\n            }\\n\\n            stripe.Sort();\\n            var median = stripe[stripe.Count / 2];\\n\\n            foreach(var val in stripe) {\\n                ans += Math.Abs(median - val);\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n\\n    private int GCD(int a, int b) {\\n        while(a != 0 && b != 0) {\\n            if(a > b) {\\n                a %= b;\\n            } else {\\n                b %= a;\\n            }\\n        }\\n\\n        return  a | b; // short hand for returning the non-zero option of the two variables\\n    }\\n}\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n    [1,2,3,1,2,3,1,2,3]  with k == 3\\n```\n```\\n    1,2,3\\n    2,3,1\\n    3,1,2\\n    1,2,3\\n    2,3,1\\n    3,1,2\\n    1,2,3\\n    2,3,1 // Note \"1\" from circuling back to beginning\\n    3,1,2 // Note \"1,2\" from circuling back to beginning\\n```\n```\\n[1,2,3,2,3,4,1,2,3] with k== 3\\n```\n```\\n    [1,_,_,2,_,_,1,_,_]\\n       or\\n    [1,2,1]\\n```\n```\\n    [1,1,2] // 1 is the middle element of the sorted list\\n            // and thus the median\\n```\n```\\n[a,b,c,a,b,c,a,b] with k==3 and a length of 8\\n c\\n```\n```\\n[a,a,a,a,a,a,a,a] with k==3 and a length of 8\\n```\n```\\n[a,b,a,b,a,b,a,b] with k==3 and a length of 8\\n\\n// k-arrays\\n[a,b,a]\\n[b,a,b] // already not equal.\\n\\n```\n```\\n[a,b,c,d,e,f,a,b,c] // repeating 6 pattern doesn\\'t work\\n[a,b,c,a,b,c,a,b,c] // repeating 3 pattern does fit!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3512476,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int n=arr.length;\\n        long ans=0;\\n        int vis[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            List<Integer>list=new ArrayList<>();\\n            if(vis[i]==1)\\n            continue;\\n            while(vis[i]==0){\\n                vis[i]=1;\\n                list.add(arr[i]);\\n                i=(i+k)%n;\\n            }\\n            Collections.sort(list);\\n            for(int j:list){\\n                ans+=Math.abs(j-list.get(list.size()/2));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        int n=arr.length;\\n        long ans=0;\\n        int vis[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            List<Integer>list=new ArrayList<>();\\n            if(vis[i]==1)\\n            continue;\\n            while(vis[i]==0){\\n                vis[i]=1;\\n                list.add(arr[i]);\\n                i=(i+k)%n;\\n            }\\n            Collections.sort(list);\\n            for(int j:list){\\n                ans+=Math.abs(j-list.get(list.size()/2));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437922,
                "title": "c",
                "content": "```\\nclass Solution {\\n    long long helper(vector<int>&nums){\\n        int n = nums.size() ;\\n        sort(nums.begin(), nums.end()) ;\\n        long long sum = 0 ;\\n        for(int i = 0; i < n; i++)\\n            sum += abs(nums[i] - nums[n/2]) ;\\n        return sum ;\\n    }\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size() ;\\n        vector<bool>visited(n) ;\\n            long long ret = 0 ;\\n        for(int i = 0; i < k; i++){\\n            int j = i ;\\n            vector<int>nums ;\\n            while(visited[j] == false){\\n                visited[j] = true ;\\n                nums.push_back(arr[j]) ;\\n                j = (j + k) % n ;\\n            }\\n            ret += helper(nums) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    long long helper(vector<int>&nums){\\n        int n = nums.size() ;\\n        sort(nums.begin(), nums.end()) ;\\n        long long sum = 0 ;\\n        for(int i = 0; i < n; i++)\\n            sum += abs(nums[i] - nums[n/2]) ;\\n        return sum ;\\n    }\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size() ;\\n        vector<bool>visited(n) ;\\n            long long ret = 0 ;\\n        for(int i = 0; i < k; i++){\\n            int j = i ;\\n            vector<int>nums ;\\n            while(visited[j] == false){\\n                visited[j] = true ;\\n                nums.push_back(arr[j]) ;\\n                j = (j + k) % n ;\\n            }\\n            ret += helper(nums) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412285,
                "title": "python-consider-middle-value-count-the-operation-runtime-beats-96-memory-beats-89",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)  Find the greatest common divisor between len(arr) and k\\n    e.g. length = 6, k = 4, greatest common divisor = 2\\n    --> every substring with length = 2 must be equal.\\n2)  For each substring, take Position n (n = 0 to k - 1) to form a new substring, pass it to **countOperation**.\\n3) In **countOperation**, get the middle value, sum the absolute difference between the middle value and each value. return to output.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countOperation(self, arr):\\n        sub_res = 0\\n        arr.sort()\\n        avg = arr[len(arr)/2]   #####   Find the middle value     #####\\n        for a in arr:\\n            sub_res += abs(avg - a)\\n        return sub_res\\n\\n    def findConvK(self, l, k):\\n        while k > 1:\\n            if l % k == 0:\\n                return k\\n            d = l - k\\n            l, k = max(k, d), min(k, d)\\n        return k\\n\\n    def makeSubKSumEqual(self, arr, k):\\n        output = 0\\n        k = self.findConvK(len(arr), k)\\n        count = 0\\n        while count < k:\\n            sub_arr = arr[count::k]     #####   if subarray = arr, pass the whole arr to countOperation #####\\n            output += self.countOperation(sub_arr)    \\n            count += 1\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countOperation(self, arr):\\n        sub_res = 0\\n        arr.sort()\\n        avg = arr[len(arr)/2]   #####   Find the middle value     #####\\n        for a in arr:\\n            sub_res += abs(avg - a)\\n        return sub_res\\n\\n    def findConvK(self, l, k):\\n        while k > 1:\\n            if l % k == 0:\\n                return k\\n            d = l - k\\n            l, k = max(k, d), min(k, d)\\n        return k\\n\\n    def makeSubKSumEqual(self, arr, k):\\n        output = 0\\n        k = self.findConvK(len(arr), k)\\n        count = 0\\n        while count < k:\\n            sub_arr = arr[count::k]     #####   if subarray = arr, pass the whole arr to countOperation #####\\n            output += self.countOperation(sub_arr)    \\n            count += 1\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408871,
                "title": "efficiently-rearranging-array-elements-to-make-sub-k-sum-equal-a-sorting-based-approach-in-c",
                "content": "# Intuition\\nFirst, we use the gcd function to calculate the greatest common divisor (GCD) of arrLen and k. This gives us the number of columns, colLen, in the rearranged array, where each column will have arrLen / colLen elements.\\nWe then calculate the number of rows, rowLen, in the rearranged array by dividing arrLen by colLen.\\nNext, we iterate through each column of the rearranged array, and for each column, we create a temporary buffer curColBuf of length rowLen to store the elements in that column.\\nWe call the minOperToMakeAllEqual function on curColBuf to calculate the minimum number of operations needed to make all elements in the column equal. This function uses a sorting approach to efficiently find the minimum number of operations.\\nWe add the result of minOperToMakeAllEqual for each column to the total result.\\nFinally, we return the total result as the final answer.\\n# Code\\n```\\nstatic int gcd(int a, int b) {\\n\\twhile (b != 0) {\\n\\t\\tconst int c = a % b;\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t}\\n\\treturn a;\\n}\\n\\nstatic int cmp_int_asc(const void * const p1, const void * const p2) {\\n\\treturn *(const int *)p1 - *(const int *)p2;\\n}\\n\\nstatic int64_t minOperToMakeAllEqual(int * const nums, const int numsLen) {\\n\\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\\n\\tint64_t result = 0;\\n\\tfor (int left = 0, right = numsLen - 1; left < right; left += 1, right -= 1) {\\n\\t\\tresult += (nums[right] - nums[left]);\\n\\t}\\n\\treturn result;\\n}\\n\\nint64_t makeSubKSumEqual(const int * const arr, const int arrLen, const int k) {\\n\\tint64_t result = 0;\\n\\n\\tconst int colLen = gcd(arrLen, k);\\n\\tconst int rowLen = arrLen / colLen;\\n\\n\\tfor (int col = 0; col < colLen; col += 1) {\\n\\t\\tint curColBuf[rowLen];\\n\\t\\tfor (int row = 0; row < rowLen; row += 1) {\\n\\t\\t\\tcurColBuf[row] = arr[colLen * row + col];\\n\\t\\t}\\n\\t\\tresult += minOperToMakeAllEqual(curColBuf, rowLen);\\n\\t}\\n\\n\\treturn result;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstatic int gcd(int a, int b) {\\n\\twhile (b != 0) {\\n\\t\\tconst int c = a % b;\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t}\\n\\treturn a;\\n}\\n\\nstatic int cmp_int_asc(const void * const p1, const void * const p2) {\\n\\treturn *(const int *)p1 - *(const int *)p2;\\n}\\n\\nstatic int64_t minOperToMakeAllEqual(int * const nums, const int numsLen) {\\n\\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\\n\\tint64_t result = 0;\\n\\tfor (int left = 0, right = numsLen - 1; left < right; left += 1, right -= 1) {\\n\\t\\tresult += (nums[right] - nums[left]);\\n\\t}\\n\\treturn result;\\n}\\n\\nint64_t makeSubKSumEqual(const int * const arr, const int arrLen, const int k) {\\n\\tint64_t result = 0;\\n\\n\\tconst int colLen = gcd(arrLen, k);\\n\\tconst int rowLen = arrLen / colLen;\\n\\n\\tfor (int col = 0; col < colLen; col += 1) {\\n\\t\\tint curColBuf[rowLen];\\n\\t\\tfor (int row = 0; row < rowLen; row += 1) {\\n\\t\\t\\tcurColBuf[row] = arr[colLen * row + col];\\n\\t\\t}\\n\\t\\tresult += minOperToMakeAllEqual(curColBuf, rowLen);\\n\\t}\\n\\n\\treturn result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3393246,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def makeSubKSumEqual(arr: Array[Int], k: Int): Long = {\\n        @annotation.tailrec\\n        def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\\n        def help(arr: Array[Int], start: Int, gap: Int):Long = {\\n            val n = arr.length\\n            val m = n / gap\\n            val as = (start until n by gap).foldLeft(List[Int]())((acc, i)=>{arr(i) +: acc}).sorted.toArray\\n            (0 until m).foldLeft(0L)((acc, i) => {acc + Math.abs(as(i) - as(m / 2))})\\n        }\\n\\n        val g = gcd(arr.length, k)\\n        (0 until g).foldLeft(0L)((acc, i) =>{ acc + help(arr, i, g) })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def makeSubKSumEqual(arr: Array[Int], k: Int): Long = {\\n        @annotation.tailrec\\n        def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\\n        def help(arr: Array[Int], start: Int, gap: Int):Long = {\\n            val n = arr.length\\n            val m = n / gap\\n            val as = (start until n by gap).foldLeft(List[Int]())((acc, i)=>{arr(i) +: acc}).sorted.toArray\\n            (0 until m).foldLeft(0L)((acc, i) => {acc + Math.abs(as(i) - as(m / 2))})\\n        }\\n\\n        val g = gcd(arr.length, k)\\n        (0 until g).foldLeft(0L)((acc, i) =>{ acc + help(arr, i, g) })\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3391633,
                "title": "easy-understand-solution-though-not-optimal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif subArray[i, i+k-1] == subArray[i+1, i+k], then a[i] == a[i+k]\\nObviously, this can apply to all subArray, so we can conclud a[i] == a[(i + n * k) % length], n = 0, 1, 2, ...\\n\\nSo the intuition is we have to deal with each group of numbers where the indeces of numbers should match the pattern above. Regarding to the same group, we can just change all numbers to median number.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlgn) since sorting\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        long res = 0;\\n        int n = arr.length;\\n        \\n        int[] visited = new int[n];\\n        for (int i = 0; i < k; i++) {\\n            if (visited[i] == 1) {\\n                continue;\\n            }\\n            int index = i;\\n            List<Integer> tmp = new ArrayList<>();\\n            while (visited[index] == 0) {\\n                visited[index] = 1;\\n                tmp.add(arr[index]);\\n                index = (index + k) % n;\\n            }\\n            Collections.sort(tmp);\\n            int mid = tmp.get((tmp.size() - 1) / 2);\\n            for (int num : tmp) {\\n                res += Math.abs(num - mid);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        long res = 0;\\n        int n = arr.length;\\n        \\n        int[] visited = new int[n];\\n        for (int i = 0; i < k; i++) {\\n            if (visited[i] == 1) {\\n                continue;\\n            }\\n            int index = i;\\n            List<Integer> tmp = new ArrayList<>();\\n            while (visited[index] == 0) {\\n                visited[index] = 1;\\n                tmp.add(arr[index]);\\n                index = (index + k) % n;\\n            }\\n            Collections.sort(tmp);\\n            int mid = tmp.get((tmp.size() - 1) / 2);\\n            for (int num : tmp) {\\n                res += Math.abs(num - mid);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389851,
                "title": "javascript-solution-k-cycles",
                "content": "# Intuition\\nI am way too dumb for this.\\nThis is refer to @votrubac\\'s solution and revise to javascript.\\n\\n# Important\\nHere is an important mathematical proof for this question made by @venkatkri5h.\\nYou can check this out in @votrubac\\'s solution below.\\n\\n```\\nConsider array \\n[x, y, z, a, b, c]\\nLet k be 3. \\n[x, y, z, a, b, c]\\n |     |         - Let this Sum be A (x + y + z)\\nNow slide window\\n[x, y, z, a, b, c]\\n    |     |      - Let this Sum be B (A - x + a)\\nHere Sum of this subarray B can be equal to A only if a is equal to x. \\n```\\nSo we can say:\\n```\\narr[i] == arr[i + k]\\narr[i] == arr[i + 2 * k]\\nand so on.\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) when the k === 1\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar makeSubKSumEqual = function(arr, k) {\\n    let res = 0\\n\\n    for(let i = 0; i < k; i++) {\\n        let list = []\\n\\n        // (j + k) % arr.length can let us circle the array\\n        // and by re-assign the arr[j] to 0, it can make sure we won\\'t go visited element\\n        for(let j = i; arr[j] !== 0; j = (j + k) % arr.length) {\\n            list.push(arr[j])\\n            arr[j] = 0\\n        }\\n\\n        list.sort((a,b)=>a-b)\\n\\n        for(let l of list) {\\n            // Use the middle element as the subtrahend to get the overall minimum difference\\n            // Yes, we need another math genius to prove it!\\n            res += Math.abs(l - list[~~(list.length / 2)])\\n        }\\n    }  \\n\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nConsider array \\n[x, y, z, a, b, c]\\nLet k be 3. \\n[x, y, z, a, b, c]\\n |     |         - Let this Sum be A (x + y + z)\\nNow slide window\\n[x, y, z, a, b, c]\\n    |     |      - Let this Sum be B (A - x + a)\\nHere Sum of this subarray B can be equal to A only if a is equal to x. \\n```\n```\\narr[i] == arr[i + k]\\narr[i] == arr[i + 2 * k]\\nand so on.\\n```\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number}\\n */\\nvar makeSubKSumEqual = function(arr, k) {\\n    let res = 0\\n\\n    for(let i = 0; i < k; i++) {\\n        let list = []\\n\\n        // (j + k) % arr.length can let us circle the array\\n        // and by re-assign the arr[j] to 0, it can make sure we won\\'t go visited element\\n        for(let j = i; arr[j] !== 0; j = (j + k) % arr.length) {\\n            list.push(arr[j])\\n            arr[j] = 0\\n        }\\n\\n        list.sort((a,b)=>a-b)\\n\\n        for(let l of list) {\\n            // Use the middle element as the subtrahend to get the overall minimum difference\\n            // Yes, we need another math genius to prove it!\\n            res += Math.abs(l - list[~~(list.length / 2)])\\n        }\\n    }  \\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3389512,
                "title": "dart-o-nlogn-group-and-sum-the-count-of-makeeverythingequals",
                "content": "# Intuition\\n- Make group of given list by k jump. \\n- Then, make the group of groups to makeEveryThingEqual and sum the count. \\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int makeSubKSumEqual(List<int> arr, int k) {\\n    int n = arr.length;\\n    List<List<int>> gps = [];\\n    HashSet<int> visited = HashSet();\\n\\n    for (var i = 0; i < n; i++) {\\n      int j = i;\\n      List<int> gp = [];\\n      while (visited.add(j % n)) {\\n        gp.add(arr[j % n]);\\n        j += k;\\n      }\\n      if (gp.isNotEmpty) {\\n        gps.add(gp);\\n      }\\n    }\\n\\n    int res = 0;\\n    for (var gp in gps) {\\n      res += minOperationsToMakeEverythingEquals(gp);\\n    }\\n\\n    return res;\\n  }\\n\\n  int minOperationsToMakeEverythingEquals(List<int> nums) {\\n    int n = nums.length;\\n    nums.sort();\\n    int mid = nums[n ~/ 2];\\n    int count = 0;\\n    for (var x in nums) {\\n      count += (mid - x).abs();\\n    }\\n\\n    return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int makeSubKSumEqual(List<int> arr, int k) {\\n    int n = arr.length;\\n    List<List<int>> gps = [];\\n    HashSet<int> visited = HashSet();\\n\\n    for (var i = 0; i < n; i++) {\\n      int j = i;\\n      List<int> gp = [];\\n      while (visited.add(j % n)) {\\n        gp.add(arr[j % n]);\\n        j += k;\\n      }\\n      if (gp.isNotEmpty) {\\n        gps.add(gp);\\n      }\\n    }\\n\\n    int res = 0;\\n    for (var gp in gps) {\\n      res += minOperationsToMakeEverythingEquals(gp);\\n    }\\n\\n    return res;\\n  }\\n\\n  int minOperationsToMakeEverythingEquals(List<int> nums) {\\n    int n = nums.length;\\n    nums.sort();\\n    int mid = nums[n ~/ 2];\\n    int count = 0;\\n    for (var x in nums) {\\n      count += (mid - x).abs();\\n    }\\n\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388195,
                "title": "a-few-solutions",
                "content": "Given the input array `A` with cardinality `N` and subarray length `K`, we derive the formula `A[i] = A[(i + K) % N]` from the equalities below:\\n\\n![image](https://assets.leetcode.com/users/images/dfca501a-b1b2-4117-8a71-5e5a7af9b4e1_1680829152.7669816.jpeg)\\n\\n\\nThus, we partition `A` into `groups` starting at each index `i = 0..K-1` inclusive and update all values per `group` to the `median` value of the `group` to accumulate the `cost` as the sum of absolute differences `diff` between the `median` and each value of the `group`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun makeSubKSumEqual(A: IntArray, K: Int): Long {\\n        var (groups, seen, N) = Triple(mutableListOf<List<Int>>(), mutableSetOf<Int>(), A.size)\\n        for (i_ in 0 until K) {\\n            var (i, group) = Pair(i_, mutableListOf<Int>())\\n            while (!seen.contains(i)) {\\n                group.add(A[i]); seen.add(i); i = (i + K) % N\\n            }\\n            if (0 < group.size)\\n                groups.add(group.sorted().toList())\\n        }\\n        var cost = 0L\\n        for (group in groups) {\\n            var median = group[group.size / 2]\\n            var diff = group.map{ Math.abs(median.toLong() - it.toLong()) }.sum()\\n            cost += diff\\n        }\\n        return cost\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet makeSubKSumEqual = (A, K, cost = 0) => {\\n    let [groups, seen, N] = [[], new Set(), A.length];\\n    for (let i = 0; i < K; ++i) {\\n        let group = [];\\n        while (!seen.has(i))\\n            group.push(A[i]), seen.add(i), i = (i + K) % N;\\n        if (group.length)\\n            groups.push(group.sort((a, b) => a - b));\\n    }\\n    for (let group of groups) {\\n        let median = group[Math.floor(group.length / 2)];\\n        let diff = _.sum(group.map(x => Math.abs(median - x)));\\n        cost += diff;\\n    }\\n    return cost;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, A: List[int], K: int, cost = 0) -> int:\\n        groups, seen, N = [], set(), len(A)\\n        for i in range(K):\\n            group = []\\n            while i not in seen:\\n                group.append(A[i]); seen.add(i); i = (i + K) % N\\n            if len(group):\\n                groups.append(sorted(group))\\n        for group in groups:\\n            median = group[len(group) // 2]\\n            diff = sum(abs(median - x) for x in group)\\n            cost += diff\\n        return cost\\n```\\n\\n*Rust*\\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn make_sub_k_sum_equal(A: Vec<i32>, K: i32) -> i64 {\\n        let (mut groups, mut seen, N) = (vec![], HashSet::new(), A.len());\\n        for i in 0..K as usize {\\n            let (mut i, mut group) = (i, vec![]);\\n            while !seen.contains(&i) {\\n                group.push(A[i]); seen.insert(i); i = (i + K as usize) % N;\\n            }\\n            if 0 < group.len() {\\n                group.sort(); groups.push(group);\\n            }\\n        }\\n        let mut cost = 0i64;\\n        for group in groups {\\n            let median = group[group.len() / 2];\\n            let diff = group.iter().map(|x| (median as i64 - *x as i64).abs()).sum::<i64>();\\n            cost += diff;\\n        }\\n        cost\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<int>;\\n    LL makeSubKSumEqual(VI& A, int K, LL cost = 0) {\\n        auto [groups, seen, N] = make_tuple(VVI{}, Set{}, A.size());\\n        for (auto i{ 0 }; i < K; ++i) {\\n            VI group;\\n            while (seen.insert(i).second)\\n                group.push_back(A[i]), i = (i + K) % N;\\n            if (group.size())\\n                groups.emplace_back(group);\\n        }\\n        for (auto& group: groups) {\\n            sort(group.begin(), group.end());\\n            auto median = group[group.size() / 2];\\n            auto diff = accumulate(group.begin(), group.end(), 0LL, [=](auto t, auto x) { return t + abs(median - x); });\\n            cost += diff;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun makeSubKSumEqual(A: IntArray, K: Int): Long {\\n        var (groups, seen, N) = Triple(mutableListOf<List<Int>>(), mutableSetOf<Int>(), A.size)\\n        for (i_ in 0 until K) {\\n            var (i, group) = Pair(i_, mutableListOf<Int>())\\n            while (!seen.contains(i)) {\\n                group.add(A[i]); seen.add(i); i = (i + K) % N\\n            }\\n            if (0 < group.size)\\n                groups.add(group.sorted().toList())\\n        }\\n        var cost = 0L\\n        for (group in groups) {\\n            var median = group[group.size / 2]\\n            var diff = group.map{ Math.abs(median.toLong() - it.toLong()) }.sum()\\n            cost += diff\\n        }\\n        return cost\\n    }\\n}\\n```\n```\\nlet makeSubKSumEqual = (A, K, cost = 0) => {\\n    let [groups, seen, N] = [[], new Set(), A.length];\\n    for (let i = 0; i < K; ++i) {\\n        let group = [];\\n        while (!seen.has(i))\\n            group.push(A[i]), seen.add(i), i = (i + K) % N;\\n        if (group.length)\\n            groups.push(group.sort((a, b) => a - b));\\n    }\\n    for (let group of groups) {\\n        let median = group[Math.floor(group.length / 2)];\\n        let diff = _.sum(group.map(x => Math.abs(median - x)));\\n        cost += diff;\\n    }\\n    return cost;\\n};\\n```\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, A: List[int], K: int, cost = 0) -> int:\\n        groups, seen, N = [], set(), len(A)\\n        for i in range(K):\\n            group = []\\n            while i not in seen:\\n                group.append(A[i]); seen.add(i); i = (i + K) % N\\n            if len(group):\\n                groups.append(sorted(group))\\n        for group in groups:\\n            median = group[len(group) // 2]\\n            diff = sum(abs(median - x) for x in group)\\n            cost += diff\\n        return cost\\n```\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn make_sub_k_sum_equal(A: Vec<i32>, K: i32) -> i64 {\\n        let (mut groups, mut seen, N) = (vec![], HashSet::new(), A.len());\\n        for i in 0..K as usize {\\n            let (mut i, mut group) = (i, vec![]);\\n            while !seen.contains(&i) {\\n                group.push(A[i]); seen.insert(i); i = (i + K as usize) % N;\\n            }\\n            if 0 < group.len() {\\n                group.sort(); groups.push(group);\\n            }\\n        }\\n        let mut cost = 0i64;\\n        for group in groups {\\n            let median = group[group.len() / 2];\\n            let diff = group.iter().map(|x| (median as i64 - *x as i64).abs()).sum::<i64>();\\n            cost += diff;\\n        }\\n        cost\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<int>;\\n    LL makeSubKSumEqual(VI& A, int K, LL cost = 0) {\\n        auto [groups, seen, N] = make_tuple(VVI{}, Set{}, A.size());\\n        for (auto i{ 0 }; i < K; ++i) {\\n            VI group;\\n            while (seen.insert(i).second)\\n                group.push_back(A[i]), i = (i + K) % N;\\n            if (group.size())\\n                groups.emplace_back(group);\\n        }\\n        for (auto& group: groups) {\\n            sort(group.begin(), group.end());\\n            auto median = group[group.size() / 2];\\n            auto diff = accumulate(group.begin(), group.end(), 0LL, [=](auto t, auto x) { return t + abs(median - x); });\\n            cost += diff;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384336,
                "title": "the-only-thing-you-need-to-realise-gcd-k-len-arr-is-the-length-of-the-repeating-array",
                "content": "\\n# Code\\n```\\ndef makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n    def gcd(a, b):\\n        while a != 0:\\n            a, b = b%a, a\\n        return b\\n            \\n    g = gcd(k, len(arr))\\n    sets = (arr[i::g] for i in range(g))\\n    ret = 0\\n    for s in sets:\\n        mid = int(statistics.median(s))\\n        ret += sum([abs(a-mid) for a in s])\\n    return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n    def gcd(a, b):\\n        while a != 0:\\n            a, b = b%a, a\\n        return b\\n            \\n    g = gcd(k, len(arr))\\n    sets = (arr[i::g] for i in range(g))\\n    ret = 0\\n    for s in sets:\\n        mid = int(statistics.median(s))\\n        ret += sum([abs(a-mid) for a in s])\\n    return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3379718,
                "title": "c-simple-approach",
                "content": "# Description\\nSolved this code with the help of discussion forum.\\n\\n# Intuition\\nSolved using GCD and median technique\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\nRuntime 186 ms\\nBeats 97.91%\\n\\n- Space complexity:\\nMemory 109 MB\\nBeats 54.34%\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        //res is a variable to store the no of operations\\n        long long res = 0;\\n        int n = arr.size();\\n        //taking gcd to get the number of buckets (subarrays)\\n        k = __gcd(k,n);\\n        //outer loop to get values of all buckets\\n        for(int i = 0; i<k; i++){\\n            //creating vector to store the values in each bucket\\n            vector<int>v;\\n            for(int j = i; j<n; j+=k){\\n                v.push_back(arr[j]);\\n            }\\n            sort(v.begin(), v.end());\\n            //finding median to get the no of operations\\n            long long mid = v[v.size()/2];\\n            //finding the absolute difference by subtracting all the elements with median \\n            for(int j = 0; j < v.size(); j++){\\n                res += abs(mid - v[j]);\\n            }\\n        }\\n        return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        //res is a variable to store the no of operations\\n        long long res = 0;\\n        int n = arr.size();\\n        //taking gcd to get the number of buckets (subarrays)\\n        k = __gcd(k,n);\\n        //outer loop to get values of all buckets\\n        for(int i = 0; i<k; i++){\\n            //creating vector to store the values in each bucket\\n            vector<int>v;\\n            for(int j = i; j<n; j+=k){\\n                v.push_back(arr[j]);\\n            }\\n            sort(v.begin(), v.end());\\n            //finding median to get the no of operations\\n            long long mid = v[v.size()/2];\\n            //finding the absolute difference by subtracting all the elements with median \\n            for(int j = 0; j < v.size(); j++){\\n                res += abs(mid - v[j]);\\n            }\\n        }\\n        return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379161,
                "title": "c-gcd",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll helper(vector<int>& arr)\\n    {\\n        ll tot=0;\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        ll mid=arr[n/2];\\n        ll res=0;\\n        for(auto &x:arr)res+=abs(mid-x);\\n        return res;\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        if(n==k)return 0;\\n        int group=gcd(n,k);\\n        vector<vector<int>>record(group);\\n        for(int i=0;i<n;i++)record[i%group].push_back(arr[i]);\\n        ll res=0;\\n        for(auto &x:record)res+=helper(x);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll helper(vector<int>& arr)\\n    {\\n        ll tot=0;\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        ll mid=arr[n/2];\\n        ll res=0;\\n        for(auto &x:arr)res+=abs(mid-x);\\n        return res;\\n    }\\n    long long makeSubKSumEqual(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        if(n==k)return 0;\\n        int group=gcd(n,k);\\n        vector<vector<int>>record(group);\\n        for(int i=0;i<n;i++)record[i%group].push_back(arr[i]);\\n        ll res=0;\\n        for(auto &x:record)res+=helper(x);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378578,
                "title": "easy-best-step-by-step-c-solution",
                "content": "\\n# Approach\\n\\nTo have subarray sum of size K  as equal in  a circular array\\n\\n# **A[i] = A[(i+k)%n]** \\n\\nand then for next A[i+k)%n] = A[(i+2k)%n] .. so on and stop as soon an index which is already marked is reached.\\n\\nNOTE : Mark all the index i , i+k %n , i+2k % n ... \\n\\nContinously store these elements which are in a cycle since we have to make them equal.\\n\\nFor making these elements as equal at min operation/cost we first sort them and make a target value as middle value.\\n\\n# Complexity\\n- Time complexity: TELL ME IN COMMENTS\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: TELL ME IN COMMENTS\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Finding min cost to make array elements as equal\\n\\n    // 1. Sort them\\n    // 2 . Adding , abs(A[i]-midVal) target element to make is midVal\\n\\n    long long solve(vector <int> &temp){\\n\\n        int n = temp.size();\\n\\n        sort(temp.begin(),temp.end());\\n\\n        long long ans = 0;\\n\\n        long long ans1 = 0 , ans2 = 0;\\n\\n        // odd\\n        if(n%2 == 1){\\n\\n            int mid = n/2;\\n\\n            for(int &val : temp){\\n\\n                ans += abs(val-temp[mid]);\\n\\n            }\\n            \\n        }\\n\\n        // even\\n        else{\\n\\n            int mid1 = n/2;\\n            int mid2 = n/2-1;\\n\\n            // in even case there are two mids hence find the min cost amongst the two mid target values\\n\\n            for(auto &val : temp){\\n\\n                ans1 += abs(val-temp[mid1]);\\n                ans2 += abs(val-temp[mid2]);\\n\\n            }\\n\\n            ans = min(ans1,ans2);\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n\\n        // A[i] = A[(i+k)%n] should be equal\\n\\n        // And a acycle will be formed i -> i+k % n -> i+2k % n ----> i\\n\\n        long long ans = 0;\\n\\n        int n = arr.size();\\n\\n        vector <bool> marked(n,0);\\n\\n        for(int i=0 ; i<n ; i++){\\n            \\n            // Already marked index\\n            if(marked[i] == 1) continue;\\n\\n            // temp is used to store all the cycle elements that we need to make equal\\n            vector <int> temp;\\n\\n            // not marked yet\\n            while(marked[i] != 1){\\n                \\n                marked[i] = 1;\\n\\n                temp.push_back(arr[i]);\\n\\n                // moving ahead in cycle\\n                i = (i+k)%n;\\n\\n            }\\n\\n            // solve functions find the minimum cost to make all the elements int temop array as equal\\n            long long ops = solve(temp);\\n\\n            ans += ops;\\n\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n\\nPLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Finding min cost to make array elements as equal\\n\\n    // 1. Sort them\\n    // 2 . Adding , abs(A[i]-midVal) target element to make is midVal\\n\\n    long long solve(vector <int> &temp){\\n\\n        int n = temp.size();\\n\\n        sort(temp.begin(),temp.end());\\n\\n        long long ans = 0;\\n\\n        long long ans1 = 0 , ans2 = 0;\\n\\n        // odd\\n        if(n%2 == 1){\\n\\n            int mid = n/2;\\n\\n            for(int &val : temp){\\n\\n                ans += abs(val-temp[mid]);\\n\\n            }\\n            \\n        }\\n\\n        // even\\n        else{\\n\\n            int mid1 = n/2;\\n            int mid2 = n/2-1;\\n\\n            // in even case there are two mids hence find the min cost amongst the two mid target values\\n\\n            for(auto &val : temp){\\n\\n                ans1 += abs(val-temp[mid1]);\\n                ans2 += abs(val-temp[mid2]);\\n\\n            }\\n\\n            ans = min(ans1,ans2);\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n\\n        // A[i] = A[(i+k)%n] should be equal\\n\\n        // And a acycle will be formed i -> i+k % n -> i+2k % n ----> i\\n\\n        long long ans = 0;\\n\\n        int n = arr.size();\\n\\n        vector <bool> marked(n,0);\\n\\n        for(int i=0 ; i<n ; i++){\\n            \\n            // Already marked index\\n            if(marked[i] == 1) continue;\\n\\n            // temp is used to store all the cycle elements that we need to make equal\\n            vector <int> temp;\\n\\n            // not marked yet\\n            while(marked[i] != 1){\\n                \\n                marked[i] = 1;\\n\\n                temp.push_back(arr[i]);\\n\\n                // moving ahead in cycle\\n                i = (i+k)%n;\\n\\n            }\\n\\n            // solve functions find the minimum cost to make all the elements int temop array as equal\\n            long long ops = solve(temp);\\n\\n            ans += ops;\\n\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n\\nPLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378550,
                "title": "c-solution-using-priority-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n = a.size();\\n        if(n == k) return 0;\\n        long long res = 0;\\n        vector<int> vis(n, 0);\\n        for(int i=0;i<k;i++){\\n            int j = i;\\n            priority_queue<int> pq;\\n            if(vis[j]) break;\\n            while(!vis[j]){\\n                vis[j] = 1;\\n                pq.push(-a[j]);\\n                j = (j+k) % n;\\n            }\\n            vector<int> v;\\n            while(!pq.empty()) {v.push_back(-pq.top()); pq.pop();}\\n            int m = v.size();\\n            int ref = v[m/2]; \\n            for(int ind=0;ind<m;ind++) res += abs(ref-v[ind]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n = a.size();\\n        if(n == k) return 0;\\n        long long res = 0;\\n        vector<int> vis(n, 0);\\n        for(int i=0;i<k;i++){\\n            int j = i;\\n            priority_queue<int> pq;\\n            if(vis[j]) break;\\n            while(!vis[j]){\\n                vis[j] = 1;\\n                pq.push(-a[j]);\\n                j = (j+k) % n;\\n            }\\n            vector<int> v;\\n            while(!pq.empty()) {v.push_back(-pq.top()); pq.pop();}\\n            int m = v.size();\\n            int ref = v[m/2]; \\n            for(int ind=0;ind<m;ind++) res += abs(ref-v[ind]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378106,
                "title": "c-find-connected-component-by-gcd-arr-size-k",
                "content": "# Observation\\n- For making each subarray sum equal of window size k we have to make each index is equal to index+kth value \\n- and we have to take care of one more thing which is the array is circular so we have to take care of this thing also \\n- As given in question array is circular so we can conclude if array length and k does not have any common devisor we have to make all the element of array equal this is for sure becoz when we check connection between idx=> idx+k we found out each element is some how connected to each other element\\n- If there is some common element so idx=>idx+gcd(size,k) going to connected and so on so take them in one group and find answer\\n- So fro finding answer for group it is more optimal to take median \\n\\n# Complexity\\n- Time complexity: $$O(N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int findMedian(vector<int> &temp){\\n        sort(temp.begin(),temp.end());\\n\\n        if(temp.size()%2==1){\\n            return temp[temp.size()/2];\\n        }\\n        return (temp[temp.size()/2]+temp[temp.size()/2-1])/2;\\n    }\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        if(__gcd(n,k)>1){\\n            k=__gcd(n,k);\\n            long long ans=0;\\n            for(int i=0;i<k;i++){\\n                vector<int> temp;\\n                for(int j=i;j<arr.size();j+=k){\\n                    temp.push_back(arr[j]);\\n                }\\n                int val=findMedian(temp);\\n                for(auto x:temp){\\n                    ans+=abs(x-val);\\n                }\\n            }\\n\\n            return ans;\\n        }\\n        else{\\n            int val=findMedian(arr);\\n            long long ans=0;\\n            for(auto x:arr){\\n                ans+=abs(x-val);\\n            }\\n            return ans;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int findMedian(vector<int> &temp){\\n        sort(temp.begin(),temp.end());\\n\\n        if(temp.size()%2==1){\\n            return temp[temp.size()/2];\\n        }\\n        return (temp[temp.size()/2]+temp[temp.size()/2-1])/2;\\n    }\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        if(__gcd(n,k)>1){\\n            k=__gcd(n,k);\\n            long long ans=0;\\n            for(int i=0;i<k;i++){\\n                vector<int> temp;\\n                for(int j=i;j<arr.size();j+=k){\\n                    temp.push_back(arr[j]);\\n                }\\n                int val=findMedian(temp);\\n                for(auto x:temp){\\n                    ans+=abs(x-val);\\n                }\\n            }\\n\\n            return ans;\\n        }\\n        else{\\n            int val=findMedian(arr);\\n            long long ans=0;\\n            for(auto x:arr){\\n                ans+=abs(x-val);\\n            }\\n            return ans;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377254,
                "title": "using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long f(vector<int> &v , int mid){\\n        \\n        long long sum = 0;\\n        for(int i=0 ; i<v.size() ; i++){\\n            sum += abs(v[i]-mid);\\n        }\\n        return sum;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        \\n        long long fin_ans = 0;        \\n        \\n        k = __gcd(k,(int)arr.size());\\n\\n        for(int i=0 ; i<k ; i++){\\n            \\n            int j = i;\\n            vector<int>v;\\n            int mini = INT_MAX;\\n            int maxi = INT_MIN;\\n            while(j<arr.size()){\\n                v.push_back(arr[j]);\\n                mini = min(mini , arr[j]);\\n                maxi = max(maxi , arr[j]);\\n                j += k;\\n            }            \\n            int l = mini;\\n            int r = maxi;\\n            int ans = 0;\\n            while(l<=r){\\n                int mid = l +(r-l)/2 ;\\n                \\n                if(f(v,mid+1)>=f(v,mid) && f(v,mid)<=f(v,mid-1)){\\n                    ans = mid;\\n                    break;\\n                }\\n                \\n                else if(f(v,mid-1)<=f(v,mid)){\\n                    r =  mid - 1;\\n                }\\n                \\n                else if(f(v,mid-1)>=f(v,mid)){\\n                    l = mid + 1;\\n                }\\n                \\n            }\\n        \\n            \\n            \\n            fin_ans += f(v , ans);\\n            \\n            \\n        }\\n        \\n        \\n        return fin_ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long f(vector<int> &v , int mid){\\n        \\n        long long sum = 0;\\n        for(int i=0 ; i<v.size() ; i++){\\n            sum += abs(v[i]-mid);\\n        }\\n        return sum;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        \\n        long long fin_ans = 0;        \\n        \\n        k = __gcd(k,(int)arr.size());\\n\\n        for(int i=0 ; i<k ; i++){\\n            \\n            int j = i;\\n            vector<int>v;\\n            int mini = INT_MAX;\\n            int maxi = INT_MIN;\\n            while(j<arr.size()){\\n                v.push_back(arr[j]);\\n                mini = min(mini , arr[j]);\\n                maxi = max(maxi , arr[j]);\\n                j += k;\\n            }            \\n            int l = mini;\\n            int r = maxi;\\n            int ans = 0;\\n            while(l<=r){\\n                int mid = l +(r-l)/2 ;\\n                \\n                if(f(v,mid+1)>=f(v,mid) && f(v,mid)<=f(v,mid-1)){\\n                    ans = mid;\\n                    break;\\n                }\\n                \\n                else if(f(v,mid-1)<=f(v,mid)){\\n                    r =  mid - 1;\\n                }\\n                \\n                else if(f(v,mid-1)>=f(v,mid)){\\n                    l = mid + 1;\\n                }\\n                \\n            }\\n        \\n            \\n            \\n            fin_ans += f(v , ans);\\n            \\n            \\n        }\\n        \\n        \\n        return fin_ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376663,
                "title": "swift-solution-not-so-well-optimized-but-worked",
                "content": "# Approach\\n1. First, we find the GCD of the array length and k. If the GCD is equal to the length of the array, then it\\'s the same as the case where k=1. If the GCD is 1, then it\\'s the same as the case where k=length of the array. So in both cases, we just return the answer for the cases where k=1 and k=length of the array.\\n2. Otherwise, we divide the array into k groups, each with length of the length of the array divided by the GCD. For each group, we find the median of the group, and then we add the sum of the absolute differences between the median and each number in the group to the answer.\\n3. Then, we return the minimum of the answer above and the answer for the case where k=1.\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func makeSubKSumEqual(_ arr: [Int], _ k: Int) -> Int {\\n        var k = k\\n        k = gcd(arr.count, k)\\n        if k == arr.count { return 0 }\\n        if k == 1 { return getVal(arr) }\\n\\n        var ptd = 0\\n        var arr2 = [Int](repeating: 0, count: arr.count/k)\\n        for i in 0..<k {\\n            for j in stride(from: i, to: arr.count, by: k) {\\n                arr2[j/k] = arr[j]\\n            }\\n            ptd += getVal(arr2)\\n        }\\n        return min(ptd, getVal(arr))\\n    }\\n    private func getVal(_ arrx: [Int]) -> Int {\\n        var arrx = arrx\\n        arrx.sort()\\n        let s = arrx[arrx.count/2]\\n        var r = 0\\n        for t in arrx { r += abs(s-t) }\\n        return r\\n    }\\n\\n    private func gcd(_ a: Int, _ b: Int) -> Int {\\n        if a < b { return gcd(b, a) }\\n        if a % b == 0 { return b }\\n        return gcd(b, a%b)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func makeSubKSumEqual(_ arr: [Int], _ k: Int) -> Int {\\n        var k = k\\n        k = gcd(arr.count, k)\\n        if k == arr.count { return 0 }\\n        if k == 1 { return getVal(arr) }\\n\\n        var ptd = 0\\n        var arr2 = [Int](repeating: 0, count: arr.count/k)\\n        for i in 0..<k {\\n            for j in stride(from: i, to: arr.count, by: k) {\\n                arr2[j/k] = arr[j]\\n            }\\n            ptd += getVal(arr2)\\n        }\\n        return min(ptd, getVal(arr))\\n    }\\n    private func getVal(_ arrx: [Int]) -> Int {\\n        var arrx = arrx\\n        arrx.sort()\\n        let s = arrx[arrx.count/2]\\n        var r = 0\\n        for t in arrx { r += abs(s-t) }\\n        return r\\n    }\\n\\n    private func gcd(_ a: Int, _ b: Int) -> Int {\\n        if a < b { return gcd(b, a) }\\n        if a % b == 0 { return b }\\n        return gcd(b, a%b)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373899,
                "title": "100-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /*  \\n        Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.\\n        In one move, you can increment or decrement an element of the array by 1.\\n    */\\n    long long minMoves2(vector<int>& nums) {\\n\\n        //**************************METHOD 2********************************************************************\\n        /*  \\n            Sum of of absolute deviation is minimum if it is taken w.r.t median:\\n            \\n            Lets take the Sum of absolute deviation w.r.t x: \\n            S = Sum(|a[i] - x|) for i = 1 to n\\n\\n            Now S in minimum if derivative is 0 ==> from this we can get x = median  \\n\\n            Also, if the number of elements is even, then instead of median we cant take any value \\n            betweeen the middle two elements as x for min Sum of absolute deviation.\\n            Here we are taking the n/2-th element as x, when no. of elements is even.\\n        */\\n        \\n        int n = nums.size();\\n        int mid = n / 2;\\n        nth_element(nums.begin(), nums.begin() + mid, nums.end());\\n\\n        int x = nums[mid];\\n        long long res = 0;\\n        for(int ele : nums)\\n            res += abs(ele - x);\\n\\n        return res;         \\n    }\\n\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n\\n        /*\\n            Psuedo intuition :\\n                for each subarray of size k to be equal:\\n                    sum[(i)...(i+k-1)%m] = sum[(i+1)%m....(i+k)%m]\\n                    or, a[i] = a[(i+k)%m] for all i\\n\\n                    that is, we need to make each subsequence {a[i], a[i+k], a[i+2k], .... } equal.\\n                    This is similar to : https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/ \\n        */  \\n\\n        int n = arr.size();\\n\\n        long long res = 0;\\n        vector<bool> visited(n, false);\\n        \\n        for(int i = 0; i< k; i++)\\n        {\\n            vector<int> subseq;\\n            int j = i;\\n            while(!visited[j])\\n            {\\n                subseq.push_back(arr[j]);\\n                visited[j] = true;\\n                j = (j + k) % n;\\n            }\\n\\n            if(subseq.size() > 0)\\n                res += minMoves2(subseq);\\n        }\\n\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*  \\n        Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.\\n        In one move, you can increment or decrement an element of the array by 1.\\n    */\\n    long long minMoves2(vector<int>& nums) {\\n\\n        //**************************METHOD 2********************************************************************\\n        /*  \\n            Sum of of absolute deviation is minimum if it is taken w.r.t median:\\n            \\n            Lets take the Sum of absolute deviation w.r.t x: \\n            S = Sum(|a[i] - x|) for i = 1 to n\\n\\n            Now S in minimum if derivative is 0 ==> from this we can get x = median  \\n\\n            Also, if the number of elements is even, then instead of median we cant take any value \\n            betweeen the middle two elements as x for min Sum of absolute deviation.\\n            Here we are taking the n/2-th element as x, when no. of elements is even.\\n        */\\n        \\n        int n = nums.size();\\n        int mid = n / 2;\\n        nth_element(nums.begin(), nums.begin() + mid, nums.end());\\n\\n        int x = nums[mid];\\n        long long res = 0;\\n        for(int ele : nums)\\n            res += abs(ele - x);\\n\\n        return res;         \\n    }\\n\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n\\n        /*\\n            Psuedo intuition :\\n                for each subarray of size k to be equal:\\n                    sum[(i)...(i+k-1)%m] = sum[(i+1)%m....(i+k)%m]\\n                    or, a[i] = a[(i+k)%m] for all i\\n\\n                    that is, we need to make each subsequence {a[i], a[i+k], a[i+2k], .... } equal.\\n                    This is similar to : https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/ \\n        */  \\n\\n        int n = arr.size();\\n\\n        long long res = 0;\\n        vector<bool> visited(n, false);\\n        \\n        for(int i = 0; i< k; i++)\\n        {\\n            vector<int> subseq;\\n            int j = i;\\n            while(!visited[j])\\n            {\\n                subseq.push_back(arr[j]);\\n                visited[j] = true;\\n                j = (j + k) % n;\\n            }\\n\\n            if(subseq.size() > 0)\\n                res += minMoves2(subseq);\\n        }\\n\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373272,
                "title": "java-easy-way-by-using-gcd-and-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        k=gcd(arr.length, k);\\n        if(k==arr.length)return 0;\\n        if(k==1) return getVal(arr);\\n\\n        long ptd=0;\\n        int[] arr2 = new int[arr.length/k];\\n        for(int i=0; i<k; i++){\\n            for(int j=i; j<arr.length; j+=k){\\n                arr2[j/k]=arr[j];\\n            }\\n            ptd+=getVal(arr2);\\n        }\\n        return Math.min(ptd,getVal(arr));\\n    }\\n    private long getVal(int[] arrx){\\n        Arrays.sort(arrx);\\n        int s = arrx[arrx.length/2];\\n        long r=0;\\n        for(int t:arrx) r+=Math.abs(s-t);\\n        return r;\\n    }\\n\\n    private int gcd(int a, int b){\\n        if(a<b)return gcd(b,a);\\n        if(a%b==0)return b;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        k=gcd(arr.length, k);\\n        if(k==arr.length)return 0;\\n        if(k==1) return getVal(arr);\\n\\n        long ptd=0;\\n        int[] arr2 = new int[arr.length/k];\\n        for(int i=0; i<k; i++){\\n            for(int j=i; j<arr.length; j+=k){\\n                arr2[j/k]=arr[j];\\n            }\\n            ptd+=getVal(arr2);\\n        }\\n        return Math.min(ptd,getVal(arr));\\n    }\\n    private long getVal(int[] arrx){\\n        Arrays.sort(arrx);\\n        int s = arrx[arrx.length/2];\\n        long r=0;\\n        for(int t:arrx) r+=Math.abs(s-t);\\n        return r;\\n    }\\n\\n    private int gcd(int a, int b){\\n        if(a<b)return gcd(b,a);\\n        if(a%b==0)return b;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372216,
                "title": "java-faster-then-100",
                "content": "# Intuition\\nif groups are formed on basis of this pattern :\\n\\n# Approach\\n1,4   ,1,3   ,6,8\\nthen we can take median(after sorting) of 1,1,6 and then difference of each element with is ans=5\\nsimilarly find for 4,3,8 and add in ans+=5\\nans=10\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n    int n=arr.length,h=gcd(n,k),q=n/h;\\n    long ans=0;\\n    for(int i=0;i<h;i++)\\n    {\\n        int x[]=new int[q];\\n        for(int j=0;j<q;j++)\\n        {\\n            x[j]=arr[(h*j)+i];\\n        }\\n        Arrays.sort(x);\\n        int v=q/2;\\n        int u=q%2==0?(x[v]+x[v-1])/2:x[v];\\n        for(int o=0;o<q;o++)\\n        {ans+=Math.abs(u-x[o]);}\\n    }\\n        return ans;\\n    }\\n    public int gcd(int a, int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        else\\n            return gcd(b, Math.abs(a - b));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n    int n=arr.length,h=gcd(n,k),q=n/h;\\n    long ans=0;\\n    for(int i=0;i<h;i++)\\n    {\\n        int x[]=new int[q];\\n        for(int j=0;j<q;j++)\\n        {\\n            x[j]=arr[(h*j)+i];\\n        }\\n        Arrays.sort(x);\\n        int v=q/2;\\n        int u=q%2==0?(x[v]+x[v-1])/2:x[v];\\n        for(int o=0;o<q;o++)\\n        {ans+=Math.abs(u-x[o]);}\\n    }\\n        return ans;\\n    }\\n    public int gcd(int a, int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        else\\n            return gcd(b, Math.abs(a - b));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371353,
                "title": "simple-approach",
                "content": "# Intuition\\n/**\\n * the idea is simple , once you understand the basic thing, you can expand it towards the problem and see the answer\\n *\\n * Understanding: k is nothing but the size of the sliding window\\n * IDEA:: So every time the sliding window moves forwards, it leaves one element behind\\n * Solution: The element it leaves behind should be equal to the new element it adds to the sliding window\\n *\\n *\\n*/\\n\\n# Approach\\n/**\\n *\\n * Approach: since i th and (i+k)%n th elements should be same, I collect them and get the minimum number\\n * of steps required to make them equal\\n * then I return the total sum of number of moves;\\n */\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n\\n        if(k > arr.length) return minMove(Arrays.asList(Arrays.stream( arr ).boxed().toArray( Integer[]::new )));\\n        int len = arr.length;\\n        int flag[] = new int[arr.length];\\n        Arrays.fill(flag,0);\\n\\n\\n        List<Integer> temp = new ArrayList<>();\\n        long min =0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(flag[i] == 1) continue;\\n            int j=i;\\n            while(flag[j] == 0)\\n            {\\n                temp.add(arr[j]);\\n                flag[j] = 1;\\n                j = (j+k)%len;\\n            }\\n            min += (long)minMove(temp);\\n            temp = new ArrayList<>();\\n        }\\n\\n        return min;\\n\\n    }\\n\\n\\n    public long minMove(List<Integer> arr) {\\n        long res =0;\\n        Collections.sort(arr);\\n        Integer median = arr.get(arr.size()/2);\\n        for(Integer x:arr) res+= Math.abs(x - median);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n\\n        if(k > arr.length) return minMove(Arrays.asList(Arrays.stream( arr ).boxed().toArray( Integer[]::new )));\\n        int len = arr.length;\\n        int flag[] = new int[arr.length];\\n        Arrays.fill(flag,0);\\n\\n\\n        List<Integer> temp = new ArrayList<>();\\n        long min =0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(flag[i] == 1) continue;\\n            int j=i;\\n            while(flag[j] == 0)\\n            {\\n                temp.add(arr[j]);\\n                flag[j] = 1;\\n                j = (j+k)%len;\\n            }\\n            min += (long)minMove(temp);\\n            temp = new ArrayList<>();\\n        }\\n\\n        return min;\\n\\n    }\\n\\n\\n    public long minMove(List<Integer> arr) {\\n        long res =0;\\n        Collections.sort(arr);\\n        Integer median = arr.get(arr.size()/2);\\n        for(Integer x:arr) res+= Math.abs(x - median);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371274,
                "title": "make-k-subarray-sums-equal-java-group-same-faster-than-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        long ans=0;\\n        int n=arr.length;\\n\\n        boolean []vis=new boolean[n];\\n        for(int i=0;i<n;i++){\\n            if(vis[i]){\\n                continue;\\n            }\\n\\n            List<Integer> group=new ArrayList<>();\\n\\n            group.add(arr[i]);\\n\\n            int next=(i+k)%n;\\n            while(next!=i){\\n                if(!vis[next]){\\n                    vis[next]=true;\\n                    group.add(arr[next]);\\n                }\\n\\n                next=(next+k)%n;\\n            }\\n\\n            Collections.sort(group);\\n            int median=group.get(group.size()/2);\\n\\n            for(int ele:group){\\n                ans+=Math.abs(ele-median);\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        long ans=0;\\n        int n=arr.length;\\n\\n        boolean []vis=new boolean[n];\\n        for(int i=0;i<n;i++){\\n            if(vis[i]){\\n                continue;\\n            }\\n\\n            List<Integer> group=new ArrayList<>();\\n\\n            group.add(arr[i]);\\n\\n            int next=(i+k)%n;\\n            while(next!=i){\\n                if(!vis[next]){\\n                    vis[next]=true;\\n                    group.add(arr[next]);\\n                }\\n\\n                next=(next+k)%n;\\n            }\\n\\n            Collections.sort(group);\\n            int median=group.get(group.size()/2);\\n\\n            for(int ele:group){\\n                ans+=Math.abs(ele-median);\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370651,
                "title": "gcd-good-performance",
                "content": "# Intuition\\nTo make the sum of every contiguous subarray of size k equal, we can transform the problem into a simpler problem of finding the median of every subarray of size k and then calculate the sum of the absolute differences between the median and every element in the subarray.\\n\\nTo achieve this, we can group the numbers into k groups, each group consisting of every k-th element starting from the i-th element for i in range k. We then sort each group and take the median value as the pivot. Finally, we calculate the sum of the absolute differences between the pivot and every element in the group.\\n\\n# Complexity\\n- Time complexity: $$O(k\\u2217nlogn)$$\\nThe outer loop iterates k times, and each iteration sorts a sub-array of size $$n/k$$. The time complexity of the inner sort operation is $$O(n/k * log (n/k))$$ which can be simplified as $$O(n log n - log k)$$. Since $$k <= n$$, we can say that the time complexity of each iteration is $$O(n log n)$$. Therefore, the time complexity of the entire loop is $$O(k * n log n)$$. \\nIn the worst-case scenario, where $$k$$ is equal to 1 or $$n$$, the time complexity of the code would be $$O(n^2$$) due to the nested loop over all elements in the sub-array. However, in practice, $$k$$ is usually much smaller than $$n$$, and the code performs much better with an average time complexity of $$O(n log n)$$.\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        res = 0\\n        n = len(arr)\\n        k = math.gcd(k, n)\\n        for i in range(k):\\n            sub_arr = sorted(arr[i::k])\\n            mid = sub_arr[len(sub_arr)//2]\\n\\n            for j in range(i, n, k):\\n                res += abs(mid - arr[j])\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        res = 0\\n        n = len(arr)\\n        k = math.gcd(k, n)\\n        for i in range(k):\\n            sub_arr = sorted(arr[i::k])\\n            mid = sub_arr[len(sub_arr)//2]\\n\\n            for j in range(i, n, k):\\n                res += abs(mid - arr[j])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369647,
                "title": "c-map-sort",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    long long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n=a.size();\\n        if(n==1)return 0;\\n        ll ans=0;\\n        map<int,vector<int>> h;\\n        for(int i=0;i<k;i++)\\n        {\\n            int j=i;\\n            while(1)\\n            {\\n              if(a[j]==0)break;\\n              h[i].push_back(a[j]);\\n              a[j]=0;\\n              j=(j+k)%n;\\n            }\\n        }\\n        for(auto it:h)\\n        {\\n            vector<int> temp=it.second;  \\n            sort(temp.begin(),temp.end());\\n            int size=temp.size();\\n            int curr=temp[size/2];\\n            for(auto ele:it.second)\\n            {\\n                ans+=abs(ele-curr);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    long long makeSubKSumEqual(vector<int>& a, int k) {\\n        int n=a.size();\\n        if(n==1)return 0;\\n        ll ans=0;\\n        map<int,vector<int>> h;\\n        for(int i=0;i<k;i++)\\n        {\\n            int j=i;\\n            while(1)\\n            {\\n              if(a[j]==0)break;\\n              h[i].push_back(a[j]);\\n              a[j]=0;\\n              j=(j+k)%n;\\n            }\\n        }\\n        for(auto it:h)\\n        {\\n            vector<int> temp=it.second;  \\n            sort(temp.begin(),temp.end());\\n            int size=temp.size();\\n            int curr=temp[size/2];\\n            for(auto ele:it.second)\\n            {\\n                ans+=abs(ele-curr);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369444,
                "title": "python-sort-median-gcd-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, for an array we want to make it to the same number with minimum cost. The optimal solution is making all element equal to median of the array. You can imagine a sorted array. Start with the median, if increas one in median. The left side of median needs to increase. \\nIt\\'s obviously arr[i] have to be the same with arr[i + k]. And then it\\'s a circular array. So how to deal with the head and tail, it\\'s kind of tricky. Especially for the cases `len(arr) % k != 0`. If `len(arr) % k == 0` we can find out that we could seperate array to k parts and make them equal.\\nFor the case `arr = [1,2,3,4,5,6] k = 4` we can find out that is equal to \\n`arr = [1,2,3,4,5,6] k = 2`. And you may find out this new k is GCD(len(arr), k).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the new k.\\n2. Seperate array to k parts.\\n3. Find the median of these k parts.\\n4. Sum the differen to medain in these k parts.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) for sort\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for seperate array.\\n# Others\\nI like this one. It needs more concepts than others to finished. The median part, it took me a while to think of the mean or median. And i tried two median for len(arr) is even in the contest. But I think this may be the same cost for using any one of them. The GCD part, it\\'s the tricky part. For me, if I met this in an interview, I thought it would be hard for me to proof the correcrtness. It might be reducable with the BFS or Union find.\\n\\nThanks for reading. If you thought this helps, please upvote. Or if you have any questions or ideas, comment and let\\'s discuss.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        def cost(arr, target):\\n            ans = 0\\n            for i in range(len(arr)):\\n                ans += abs(target - arr[i])\\n            return ans\\n        def find_median(arr):\\n            arr.sort()\\n            n = len(arr)\\n            if n&1:\\n                return [arr[n//2]]\\n            else:\\n                return [arr[n//2], arr[n//2 - 1]]\\n            \\n        n = len(arr)\\n        m = n\\n        while m % k:\\n            m %= k\\n            if m < k:\\n                m, k = k, m\\n        \\n        subs = [[]for _ in range(k)]\\n        for i in range(n):\\n            subs[i%k].append(arr[i])\\n        ans = 0\\n        for sub in subs:\\n            current = math.inf\\n            for target in find_median(sub):\\n                current = min(current, cost(sub, target))\\n            ans += current\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        def cost(arr, target):\\n            ans = 0\\n            for i in range(len(arr)):\\n                ans += abs(target - arr[i])\\n            return ans\\n        def find_median(arr):\\n            arr.sort()\\n            n = len(arr)\\n            if n&1:\\n                return [arr[n//2]]\\n            else:\\n                return [arr[n//2], arr[n//2 - 1]]\\n            \\n        n = len(arr)\\n        m = n\\n        while m % k:\\n            m %= k\\n            if m < k:\\n                m, k = k, m\\n        \\n        subs = [[]for _ in range(k)]\\n        for i in range(n):\\n            subs[i%k].append(arr[i])\\n        ans = 0\\n        for sub in subs:\\n            current = math.inf\\n            for target in find_median(sub):\\n                current = min(current, cost(sub, target))\\n            ans += current\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369079,
                "title": "easy-understanding-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        int no_of_buckets = __gcd(k, n);\\n        unordered_map<int, vector<int>> buckets;\\n\\n        for(int ind = 0; ind < n; ind++) {\\n            buckets[ind % no_of_buckets].push_back(arr[ind]);\\n        }\\n        \\n        long long result = 0;\\n        for(auto& bucket : buckets) {\\n            vector<int>& nums = bucket.second;\\n            int m = nums.size();\\n            \\n            for(auto x: nums) cout<<x<<\" \";\\n            cout<<endl;\\n            \\n            sort(nums.begin(), nums.end());\\n            int median = nums[m / 2];\\n\\n            for(auto& num : nums) {\\n                result += abs(median - num);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n\\n        int no_of_buckets = __gcd(k, n);\\n        unordered_map<int, vector<int>> buckets;\\n\\n        for(int ind = 0; ind < n; ind++) {\\n            buckets[ind % no_of_buckets].push_back(arr[ind]);\\n        }\\n        \\n        long long result = 0;\\n        for(auto& bucket : buckets) {\\n            vector<int>& nums = bucket.second;\\n            int m = nums.size();\\n            \\n            for(auto x: nums) cout<<x<<\" \";\\n            cout<<endl;\\n            \\n            sort(nums.begin(), nums.end());\\n            int median = nums[m / 2];\\n\\n            for(auto& num : nums) {\\n                result += abs(median - num);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3368978,
                "title": "beats-100-time-beats-100-meomry",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        if(k>=arr.length) return 0;\\n        int n = arr.length;\\n        long sum = 0 ;\\n        boolean visited[]  =  new boolean[n]; \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(visited[i]==true)continue;\\n             ArrayList<Integer> ls = new ArrayList<>();\\n             int next = (i+k)%n ;\\n             ls.add(arr[i]);\\n             while(next!=i)\\n             {\\n                   visited[next] =  true;\\n                   ls.add(arr[next]);\\n                   next = (next+k)%n;\\n             }\\n            System.out.println(ls);\\n             Collections.sort(ls);\\n             int med = ls.get(ls.size()/2);\\n             for(int z :ls)\\n             {\\n                 sum+=Math.abs(med-z);\\n             }\\n             \\n        }\\n        return sum;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSubKSumEqual(int[] arr, int k) {\\n        if(k>=arr.length) return 0;\\n        int n = arr.length;\\n        long sum = 0 ;\\n        boolean visited[]  =  new boolean[n]; \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(visited[i]==true)continue;\\n             ArrayList<Integer> ls = new ArrayList<>();\\n             int next = (i+k)%n ;\\n             ls.add(arr[i]);\\n             while(next!=i)\\n             {\\n                   visited[next] =  true;\\n                   ls.add(arr[next]);\\n                   next = (next+k)%n;\\n             }\\n            System.out.println(ls);\\n             Collections.sort(ls);\\n             int med = ls.get(ls.size()/2);\\n             for(int z :ls)\\n             {\\n                 sum+=Math.abs(med-z);\\n             }\\n             \\n        }\\n        return sum;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368899,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn make_sub_k_sum_equal(arr: Vec<i32>, k: i32) -> i64 {\\n        fn gcd(a: i64, b: i64) -> i64 {\\n            if b == 0 {\\n                a\\n            } else {\\n                gcd(b, a % b)\\n            }\\n        }\\n\\n        let arr = arr.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let k = k as i64;\\n        let n = arr.len() as i64;\\n        let k = gcd(n, k);\\n        let mut ans = 0;\\n        for i in 0..k {\\n            let mut vec = vec![];\\n            for j in (i..n).step_by(k as usize) {\\n                vec.push(arr[j as usize]);\\n            }\\n            vec.sort();\\n            let mid = vec.len() / 2;\\n            for ind in 0..vec.len() {\\n                ans += (vec[mid] - vec[ind]).abs();\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn make_sub_k_sum_equal(arr: Vec<i32>, k: i32) -> i64 {\\n        fn gcd(a: i64, b: i64) -> i64 {\\n            if b == 0 {\\n                a\\n            } else {\\n                gcd(b, a % b)\\n            }\\n        }\\n\\n        let arr = arr.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let k = k as i64;\\n        let n = arr.len() as i64;\\n        let k = gcd(n, k);\\n        let mut ans = 0;\\n        for i in 0..k {\\n            let mut vec = vec![];\\n            for j in (i..n).step_by(k as usize) {\\n                vec.push(arr[j as usize]);\\n            }\\n            vec.sort();\\n            let mid = vec.len() / 2;\\n            for ind in 0..vec.len() {\\n                ans += (vec[mid] - vec[ind]).abs();\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368648,
                "title": "c-seperate-nums-into-group",
                "content": "To make sum of subarray all same, we need to make\\n\\t\\n\\tarr[i] == arr[i + k] == arr[i + 2 * k] == arr[i + 3 * k]...\\n\\tarr[i + 1] == arr[i + 1 + k] == arr[i + 1 + 2 * k] == arr[i + 1 + 3 * k]...\\n\\nTherefore, we can group the nums in arr according above roles, then result will be the sum of the deviation from median number in each group\\n\\n```\\n\\tpublic long MakeSubKSumEqual(int[] arr, int k) {\\n\\t\\tvar visited = new HashSet<int>();\\n        var groups = new List<HashSet<int>>();\\n        for (int i = 0; i < arr.Length; i++) {\\n            if (visited.Contains(i)) continue;\\n            var group = new HashSet<int>();\\n            var index = i;\\n            while (group.Add(index))\\n                index = (index + k) % arr.Length;\\n            visited.UnionWith(group);\\n            groups.Add(group);\\n        }\\n        long res = 0;\\n        foreach (var group in groups)\\n            res += GetOperations(arr, group);\\n        return res;\\n    }\\n\\n    public static long GetOperations(int[] arr, HashSet<int> indexes) {\\n        var nums = indexes.Select(x => arr[x]).OrderBy(x => x).ToArray();\\n        var median = nums[nums.Length / 2];\\n        long res = 0;\\n        foreach (var num in nums) \\n            res += Math.Abs(num - median);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic long MakeSubKSumEqual(int[] arr, int k) {\\n\\t\\tvar visited = new HashSet<int>();\\n        var groups = new List<HashSet<int>>();\\n        for (int i = 0; i < arr.Length; i++) {\\n            if (visited.Contains(i)) continue;\\n            var group = new HashSet<int>();\\n            var index = i;\\n            while (group.Add(index))\\n                index = (index + k) % arr.Length;\\n            visited.UnionWith(group);\\n            groups.Add(group);\\n        }\\n        long res = 0;\\n        foreach (var group in groups)\\n            res += GetOperations(arr, group);\\n        return res;\\n    }\\n\\n    public static long GetOperations(int[] arr, HashSet<int> indexes) {\\n        var nums = indexes.Select(x => arr[x]).OrderBy(x => x).ToArray();\\n        var median = nums[nums.Length / 2];\\n        long res = 0;\\n        foreach (var num in nums) \\n            res += Math.Abs(num - median);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367872,
                "title": "c-gcd",
                "content": "```C []\\nstatic int gcd(int a, int b){\\n\\twhile (b != 0){\\n\\t\\tconst int c = a % b;\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t}\\n\\treturn a;\\n}\\n\\nstatic int cmp_int_asc(const void * const p1, const void * const p2){\\n\\treturn *(const int *)p1 - *(const int *)p2;\\n}\\n\\nstatic int64_t minOperToMakeAllEqual(int * const nums, const int numsLen){\\n\\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\\n\\tint64_t result = 0;\\n\\tfor (int left = 0, right = numsLen - 1; left < right; left += 1, right -= 1){\\n\\t\\tresult += (nums[right] - nums[left]);\\n\\t}\\n\\treturn result;\\n}\\n\\nint64_t makeSubKSumEqual(\\n\\tconst int * const arr,\\n\\tconst int arrLen,\\n\\tconst int k\\n){\\n\\tint64_t result = 0;\\n\\n\\tconst int\\n\\t\\tcolLen = gcd(arrLen, k),\\n\\t\\trowLen = arrLen / colLen\\n\\t;\\n\\tassert(arrLen % colLen == 0);\\n\\n\\tfor (int col = 0; col < colLen; col += 1){\\n\\t\\tint curColBuf[rowLen];\\n\\t\\tfor (int row = 0; row < rowLen; row += 1){\\n\\t\\t\\tcurColBuf[row] = arr[colLen * row + col];\\n\\t\\t}\\n\\t\\tresult += minOperToMakeAllEqual(curColBuf, rowLen);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\nstatic int gcd(int a, int b){\\n\\twhile (b != 0){\\n\\t\\tconst int c = a % b;\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t}\\n\\treturn a;\\n}\\n\\nstatic int cmp_int_asc(const void * const p1, const void * const p2){\\n\\treturn *(const int *)p1 - *(const int *)p2;\\n}\\n\\nstatic int64_t minOperToMakeAllEqual(int * const nums, const int numsLen){\\n\\tqsort(nums, numsLen, sizeof (int), &cmp_int_asc);\\n\\tint64_t result = 0;\\n\\tfor (int left = 0, right = numsLen - 1; left < right; left += 1, right -= 1){\\n\\t\\tresult += (nums[right] - nums[left]);\\n\\t}\\n\\treturn result;\\n}\\n\\nint64_t makeSubKSumEqual(\\n\\tconst int * const arr,\\n\\tconst int arrLen,\\n\\tconst int k\\n){\\n\\tint64_t result = 0;\\n\\n\\tconst int\\n\\t\\tcolLen = gcd(arrLen, k),\\n\\t\\trowLen = arrLen / colLen\\n\\t;\\n\\tassert(arrLen % colLen == 0);\\n\\n\\tfor (int col = 0; col < colLen; col += 1){\\n\\t\\tint curColBuf[rowLen];\\n\\t\\tfor (int row = 0; row < rowLen; row += 1){\\n\\t\\t\\tcurColBuf[row] = arr[colLen * row + col];\\n\\t\\t}\\n\\t\\tresult += minOperToMakeAllEqual(curColBuf, rowLen);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367725,
                "title": "python-simple-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr, k):\\n        n, dict1 = len(arr), defaultdict(int)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a,b = find(x),find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        def dfs(arr):\\n            n = len(arr)\\n            arr.sort()\\n            middle = arr[n//2]\\n            total = 0\\n\\n            for i in arr:\\n                total += abs(i-middle)\\n\\n            return total\\n\\n        for i in range(n):\\n            union(i,(i+k)%n)\\n\\n        if k == 1:\\n            return dfs(arr)\\n\\n        dict2 = defaultdict(list)\\n\\n        for i in range(n):\\n            dict2[find(i)].append(arr[i])\\n\\n        result = 0\\n\\n        for key in dict2:\\n            result += dfs(dict2[key])\\n\\n        return result\\n\\n\\n\\n        \\n\\n        \\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr, k):\\n        n, dict1 = len(arr), defaultdict(int)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a,b = find(x),find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        def dfs(arr):\\n            n = len(arr)\\n            arr.sort()\\n            middle = arr[n//2]\\n            total = 0\\n\\n            for i in arr:\\n                total += abs(i-middle)\\n\\n            return total\\n\\n        for i in range(n):\\n            union(i,(i+k)%n)\\n\\n        if k == 1:\\n            return dfs(arr)\\n\\n        dict2 = defaultdict(list)\\n\\n        for i in range(n):\\n            dict2[find(i)].append(arr[i])\\n\\n        result = 0\\n\\n        for key in dict2:\\n            result += dfs(dict2[key])\\n\\n        return result\\n\\n\\n\\n        \\n\\n        \\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367667,
                "title": "python-3-rule-based-approach",
                "content": "To make the sum of all subarry of size `k` equal, we need to make sure number `k` space apart should be equal.\\nFor example, if n = 4 and k = 2, then we need to make sure\\n```\\nnums[0] + nums[1] = nums[1] + nums[2] => nums[0] = nums[2]\\nnums[1] + nums[2] = nums[2] + nums[3] => nums[1] = nums[3]\\n```\\nMore generally\\n```\\nnums[i] + nums[i+1] + ... + nums[i+k-1] = nums[i+1] + nums[i+2] + ... + nums[i+k] => nums[i] = nums[i+k]\\n```\\nThus:\\n- Go from left to right to pick start points which are not visited\\n- Add all numbers `k` space apart into the queue\\n- Make them all equal by picking the median and calculate the absolute difference\\n\\n\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        \\n        j = 0\\n        n = len(arr)\\n        ans = 0\\n        vis = set()\\n        \\n        while len(vis) < n:\\n            # pick a start point never visited before\\n            while j in vis:\\n                j += 1\\n            \\n            i = j\\n            cands = []\\n            # visit all the number k-space apart\\n            while i not in vis:\\n                vis.add(i)\\n                cands.append(arr[i])\\n                i = (i + k) % n\\n                \\n            # make all numbers in the queue equal by finding the abs difference median and each number\\n            cands.sort()\\n            m = len(cands)\\n            mid = cands[m // 2]\\n            ans += mid * (m // 2) - sum(cands[:m // 2]) + sum(cands[m // 2:]) - mid * (m - m // 2)\\n\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nnums[0] + nums[1] = nums[1] + nums[2] => nums[0] = nums[2]\\nnums[1] + nums[2] = nums[2] + nums[3] => nums[1] = nums[3]\\n```\n```\\nnums[i] + nums[i+1] + ... + nums[i+k-1] = nums[i+1] + nums[i+2] + ... + nums[i+k] => nums[i] = nums[i+k]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367606,
                "title": "c-easy-to-understand-k-cycles-median-dfs",
                "content": "# Intuition\\nThe first thing to notice here is that every window of size k must be same in order to have same sum. Even if one of the windows is not in order / different, for some index the sum won\\'t be the same.\\n\\nAfter this intution, it is clear that every element at the index: x , x+k , x+2*k , x+3*k . . . (x+i*k)%n must be same forming a cycle.\\n\\n# Approach\\nIn order to achieve this, for every cycle independently, consider all its elements and then find the median.\\n\\nMedian is taken as it does not gets affected by the outliers. Suppose the numbers in a particular cycle are 1 11 12 . In this case, the Mean would be 8 and so 1 would be increased and 11 and 12 both would be decreased leading to more steps i.e 14. \\nwhen Median is considered then the steps would be 10 + 1 i.e 11.\\nSo, in this scenario median is more suitable representation of center.\\n\\nFinally, find the total number of steps required to make every element of the cycle equal to the Median and repeat the same process for each of the k cycles independently.\\n\\n# Complexity\\n- Time complexity:  O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& nums, int k) {\\n        long long int n=nums.size(),ans=0,med,vis[n];\\n        memset(vis,0,sizeof(vis));\\n        \\n        for(int x=0;x<k;x++){\\n            long long int temp=-1;\\n            vector<int> vals;\\n            for(int pos=x;!vis[pos];pos=(pos+k)%n){\\n                vals.push_back(nums[pos]);\\n                vis[pos]=1;\\n            }\\n            \\n            if(vals.size()>0){\\n                sort(vals.begin(),vals.end());\\n                if(vals.size()%2==0){\\n                    med=(vals[vals.size()/2]+vals[vals.size()/2-1])/2;\\n                }\\n                else{\\n                    med=vals[vals.size()/2];\\n                }\\n\\n                for(int y=0;y<vals.size();y++){\\n                    ans+=abs(vals[y]-med);\\n                }\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& nums, int k) {\\n        long long int n=nums.size(),ans=0,med,vis[n];\\n        memset(vis,0,sizeof(vis));\\n        \\n        for(int x=0;x<k;x++){\\n            long long int temp=-1;\\n            vector<int> vals;\\n            for(int pos=x;!vis[pos];pos=(pos+k)%n){\\n                vals.push_back(nums[pos]);\\n                vis[pos]=1;\\n            }\\n            \\n            if(vals.size()>0){\\n                sort(vals.begin(),vals.end());\\n                if(vals.size()%2==0){\\n                    med=(vals[vals.size()/2]+vals[vals.size()/2-1])/2;\\n                }\\n                else{\\n                    med=vals[vals.size()/2];\\n                }\\n\\n                for(int y=0;y<vals.size();y++){\\n                    ans+=abs(vals[y]-med);\\n                }\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367600,
                "title": "easy-solution-with-dsu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDSU\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Alpha n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find_par(int a,int par[]){\\n    if(a==par[a])\\n    return a;\\n    return par[a]=find_par(par[a],par);\\n}int _union(int a,int b,int par[],int sz[]){\\n    a=find_par(a,par);\\n    b=find_par(b,par);\\n if(a==b)return 0;\\n if(sz[b]>sz[a])swap(a,b);\\n par[b]=a;\\n sz[a]+=sz[b];\\n return 1;\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n     \\n         int n=arr.size();\\n        long long ans=0;\\n    \\n        \\n        int par[n],sz[n];\\n        for(int i=0;i<n;i++){\\n            par[i]=i;sz[i]=1;\\n        }\\n       \\n        \\n\\n        for(int i=0;i<n;i++){\\n            _union(i,((i+k)%n),par,sz);\\n            \\n        }\\n    \\n         for(int i=0;i<n;i++){\\n           find_par(i,par);\\n            \\n        }\\n          map<int,vector<int>>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp[par[i]].push_back(arr[i]);\\n        }\\n       \\n        for(auto i:mp){\\n            vector<int>v=i.second;\\n            sort(v.begin(),v.end());\\n            for(int j=0;j<v.size();j++){\\n               \\n                ans+=abs(v[j]-v[v.size()/2]);       \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_par(int a,int par[]){\\n    if(a==par[a])\\n    return a;\\n    return par[a]=find_par(par[a],par);\\n}int _union(int a,int b,int par[],int sz[]){\\n    a=find_par(a,par);\\n    b=find_par(b,par);\\n if(a==b)return 0;\\n if(sz[b]>sz[a])swap(a,b);\\n par[b]=a;\\n sz[a]+=sz[b];\\n return 1;\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n     \\n         int n=arr.size();\\n        long long ans=0;\\n    \\n        \\n        int par[n],sz[n];\\n        for(int i=0;i<n;i++){\\n            par[i]=i;sz[i]=1;\\n        }\\n       \\n        \\n\\n        for(int i=0;i<n;i++){\\n            _union(i,((i+k)%n),par,sz);\\n            \\n        }\\n    \\n         for(int i=0;i<n;i++){\\n           find_par(i,par);\\n            \\n        }\\n          map<int,vector<int>>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp[par[i]].push_back(arr[i]);\\n        }\\n       \\n        for(auto i:mp){\\n            vector<int>v=i.second;\\n            sort(v.begin(),v.end());\\n            for(int j=0;j<v.size();j++){\\n               \\n                ans+=abs(v[j]-v[v.size()/2]);       \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367550,
                "title": "ported-swift-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    func makeSubKSumEqual(_ arr: [Int], _ k: Int) -> Int {\\n        var result = 0\\n        var arr = arr\\n        \\n        for i in 0..<arr.count {\\n            var cycle = Array<Int>()\\n            \\n            var j = i\\n            while arr[j] != 0 {\\n                cycle.append(arr[j])\\n                arr[j] = 0\\n                j = (j + k) % arr.count\\n            }\\n            \\n            cycle.sort()\\n            let midIndex = cycle.count / 2\\n\\n            for n in cycle {\\n                result += abs(n - cycle[midIndex])\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func makeSubKSumEqual(_ arr: [Int], _ k: Int) -> Int {\\n        var result = 0\\n        var arr = arr\\n        \\n        for i in 0..<arr.count {\\n            var cycle = Array<Int>()\\n            \\n            var j = i\\n            while arr[j] != 0 {\\n                cycle.append(arr[j])\\n                arr[j] = 0\\n                j = (j + k) % arr.count\\n            }\\n            \\n            cycle.sort()\\n            let midIndex = cycle.count / 2\\n\\n            for n in cycle {\\n                result += abs(n - cycle[midIndex])\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367517,
                "title": "cycles-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> cmp;\\n    vector<vector<int>> cmps;\\n    void dfs(int node, vector<int> &vis, vector<int> &arr, int k) {\\n        int n = vis.size();\\n        vis[node] = 1;\\n        cmp.push_back(arr[node]);\\n        node = (node + k) % n;\\n        if (!vis[node])\\n            dfs(node, vis, arr, k);\\n    }\\n    long long makeSubKSumEqual(vector<int> &arr, int k) {\\n        int n = arr.size();\\n        vector<int> vis(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            if (!vis[i]) {\\n                dfs(i, vis, arr, k);\\n                cmps.push_back(cmp);\\n                cmp.clear();\\n            }\\n        }\\n        long long res = 0;\\n        for (auto cmp : cmps) {\\n            sort(cmp.begin(), cmp.end());\\n            int len = cmp.size();\\n            int med = cmp[len / 2];\\n            long long ans = 0;\\n            for (auto num : cmp) {\\n                ans += abs(num - med);\\n            }\\n            res += ans;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cmp;\\n    vector<vector<int>> cmps;\\n    void dfs(int node, vector<int> &vis, vector<int> &arr, int k) {\\n        int n = vis.size();\\n        vis[node] = 1;\\n        cmp.push_back(arr[node]);\\n        node = (node + k) % n;\\n        if (!vis[node])\\n            dfs(node, vis, arr, k);\\n    }\\n    long long makeSubKSumEqual(vector<int> &arr, int k) {\\n        int n = arr.size();\\n        vector<int> vis(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            if (!vis[i]) {\\n                dfs(i, vis, arr, k);\\n                cmps.push_back(cmp);\\n                cmp.clear();\\n            }\\n        }\\n        long long res = 0;\\n        for (auto cmp : cmps) {\\n            sort(cmp.begin(), cmp.end());\\n            int len = cmp.size();\\n            int med = cmp[len / 2];\\n            long long ans = 0;\\n            for (auto num : cmp) {\\n                ans += abs(num - med);\\n            }\\n            res += ans;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367402,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `arr`\\n */\\nclass Solution {\\n public:\\n  long long makeSubKSumEqual(const vector<int> &arr, const int k) {\\n    const int n = static_cast<int>(arr.size());\\n    if (n == k) {\\n      return 0LL;\\n    }\\n    \\n    const int g = gcd(n, k);\\n    long long ret = 0LL;\\n    for (int start = 0; start < g; ++start) {\\n      vector<int> group;\\n      for (int index = start; index < n; index += g) {\\n        group.emplace_back(arr[index]);\\n      }\\n      const int n_group = static_cast<int>(group.size());\\n      const int mid_index = n_group / 2;\\n      nth_element(group.begin(), group.begin() + mid_index, group.end());\\n      for (const int num : group) {\\n        ret += abs(group[mid_index] - num);\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return gcd(b % a, a);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `arr`\\n */\\nclass Solution {\\n public:\\n  long long makeSubKSumEqual(const vector<int> &arr, const int k) {\\n    const int n = static_cast<int>(arr.size());\\n    if (n == k) {\\n      return 0LL;\\n    }\\n    \\n    const int g = gcd(n, k);\\n    long long ret = 0LL;\\n    for (int start = 0; start < g; ++start) {\\n      vector<int> group;\\n      for (int index = start; index < n; index += g) {\\n        group.emplace_back(arr[index]);\\n      }\\n      const int n_group = static_cast<int>(group.size());\\n      const int mid_index = n_group / 2;\\n      nth_element(group.begin(), group.begin() + mid_index, group.end());\\n      for (const int num : group) {\\n        ret += abs(group[mid_index] - num);\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return gcd(b % a, a);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367380,
                "title": "100-easy-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    \\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        def rec(nums):\\n            if len(nums)==0:\\n                return 0\\n            nums.sort()\\n            psum=[nums[0]]\\n            for i in range(1,len(nums)):\\n                psum.append(psum[-1]+nums[i])\\n            s=psum[-1]\\n            ans=float(\"inf\")\\n            temp=0\\n            n=len(nums)\\n            for i in range(n):\\n                ii=nums[i]\\n                temp+=ii\\n                s-=ii\\n                a=abs(ii*(i+1)-temp)+abs(ii*(n-i-1)-s)\\n                ans=min(ans,a)\\n                # print(ii,ans,a)\\n            return ans\\n        # if len(arr)%k==0:\\n        fans=0\\n        vis=set()\\n        for i in range(k):\\n                temparr=[]\\n                \\n                j=i\\n                while True:\\n                    if j%len(arr) not in vis:\\n                        vis.add(j%len(arr))\\n                        temparr.append(arr[j%len(arr)])\\n                    else:\\n                        break\\n                    j+=k\\n                # print(temparr)\\n                fans+=rec(temparr)\\n                \\n                    \\n            \\n        return fans\\n                \\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        def rec(nums):\\n            if len(nums)==0:\\n                return 0\\n            nums.sort()\\n            psum=[nums[0]]\\n            for i in range(1,len(nums)):\\n                psum.append(psum[-1]+nums[i])\\n            s=psum[-1]\\n            ans=float(\"inf\")\\n            temp=0\\n            n=len(nums)\\n            for i in range(n):\\n                ii=nums[i]\\n                temp+=ii\\n                s-=ii\\n                a=abs(ii*(i+1)-temp)+abs(ii*(n-i-1)-s)\\n                ans=min(ans,a)\\n                # print(ii,ans,a)\\n            return ans\\n        # if len(arr)%k==0:\\n        fans=0\\n        vis=set()\\n        for i in range(k):\\n                temparr=[]\\n                \\n                j=i\\n                while True:\\n                    if j%len(arr) not in vis:\\n                        vis.add(j%len(arr))\\n                        temparr.append(arr[j%len(arr)])\\n                    else:\\n                        break\\n                    j+=k\\n                # print(temparr)\\n                fans+=rec(temparr)\\n                \\n                    \\n            \\n        return fans\\n                \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367350,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public long MakeSubKSumEqual(int[] arr, int k)\\n    {\\n        var result = 0L;\\n        var size = arr.Length;\\n\\n        for (var i = 0; i < size; ++i)\\n        {\\n            var cycle = new List<int>();\\n\\n            for (var j = i; arr[j] != 0; j = (j + k) % size)\\n            {\\n                cycle.Add(arr[j]);\\n                arr[j] = 0;\\n            }\\n\\n            cycle.Sort();\\n            var median = cycle.Count != 0 ? cycle[cycle.Count / 2] : 0;\\n            result = cycle.Aggregate(result, (current, n) => current + Math.Abs(n - median));\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public long MakeSubKSumEqual(int[] arr, int k)\\n    {\\n        var result = 0L;\\n        var size = arr.Length;\\n\\n        for (var i = 0; i < size; ++i)\\n        {\\n            var cycle = new List<int>();\\n\\n            for (var j = i; arr[j] != 0; j = (j + k) % size)\\n            {\\n                cycle.Add(arr[j]);\\n                arr[j] = 0;\\n            }\\n\\n            cycle.Sort();\\n            var median = cycle.Count != 0 ? cycle[cycle.Count / 2] : 0;\\n            result = cycle.Aggregate(result, (current, n) => current + Math.Abs(n - median));\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367313,
                "title": "disjoint-set-c-group-all-arr-i-and-arr-i-k-and-find-median-of-grouping",
                "content": "# Intuition\\nSo **arr[i]** and **arr[i+k]** element must be same for the subarry at i and subarray at i-1 to have same sum.\\n\\nMake sure to use %n to wrap around, or you can use **i<2*n** along with **i%=n**.\\n\\nFor all elements that need to be same, we can find their median and make them all equal to it.\\n\\n# Approach\\nGroup all indexes that need to be same together.\\nNote that an index can end up in more than one group. In such case all elementas at the indexes present in both the groups would have to be equal.\\n\\nTo do this, do union find for all elements in same group.\\n\\nNow the number of parents remaining in union find is the total number of **distinct elements in final array**.\\n\\nNow for each distinct value of parent[i] make a vector with all values of indexes that have same parent as parent[i];\\n\\nNow for all such vectors solve by sorting and then calculating the absolute diffrence of each element with the median.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution\\n{\\nprivate:\\n    vector<int> par;\\n\\n    int find(int &x)\\n    {\\n        if (par[x] == x)\\n            return x;\\n        return par[x] = find(par[x]);\\n    }\\n\\n    void unionFind(int x, int y)\\n    {\\n        int px = find(x);\\n        int py = find(y);\\n        par[px] = py;\\n    }\\n\\n    long long minMovestoMakeArrayEqual(vector<int> &arr)\\n    {\\n        long long sum = 0;\\n        sort(arr.begin(), arr.end());\\n\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            sum += abs(arr[i] - arr[arr.size() / 2]);\\n        }\\n        return sum;\\n    }\\n\\npublic:\\n    long long makeSubKSumEqual(vector<int> &arr, int k)\\n    {\\n        long long ans = 0;\\n        vector<vector<int>> dp(k, vector<int>());\\n        int n = arr.size();\\n        for (int i = 0; i < 2 * n; i++)\\n        {\\n            dp[i % k].push_back(i % n);\\n        }\\n\\n        par.resize(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            par[i] = i;\\n        }\\n\\n        int sz;\\n        for (int i = 0; i < k; i++)\\n        {\\n            sz = dp[i].size();\\n            for (int j = 1; j < sz; j++)\\n            {\\n                unionFind(dp[i][j-1], dp[i][j]);\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n            find(i);\\n\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[par[i]].push_back(arr[i]);\\n        }\\n\\n        for (auto &x : mp)\\n        {\\n            ans += minMovestoMakeArrayEqual(x.second);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\nprivate:\\n    vector<int> par;\\n\\n    int find(int &x)\\n    {\\n        if (par[x] == x)\\n            return x;\\n        return par[x] = find(par[x]);\\n    }\\n\\n    void unionFind(int x, int y)\\n    {\\n        int px = find(x);\\n        int py = find(y);\\n        par[px] = py;\\n    }\\n\\n    long long minMovestoMakeArrayEqual(vector<int> &arr)\\n    {\\n        long long sum = 0;\\n        sort(arr.begin(), arr.end());\\n\\n        for (int i = 0; i < arr.size(); i++)\\n        {\\n            sum += abs(arr[i] - arr[arr.size() / 2]);\\n        }\\n        return sum;\\n    }\\n\\npublic:\\n    long long makeSubKSumEqual(vector<int> &arr, int k)\\n    {\\n        long long ans = 0;\\n        vector<vector<int>> dp(k, vector<int>());\\n        int n = arr.size();\\n        for (int i = 0; i < 2 * n; i++)\\n        {\\n            dp[i % k].push_back(i % n);\\n        }\\n\\n        par.resize(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            par[i] = i;\\n        }\\n\\n        int sz;\\n        for (int i = 0; i < k; i++)\\n        {\\n            sz = dp[i].size();\\n            for (int j = 1; j < sz; j++)\\n            {\\n                unionFind(dp[i][j-1], dp[i][j]);\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n            find(i);\\n\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[par[i]].push_back(arr[i]);\\n        }\\n\\n        for (auto &x : mp)\\n        {\\n            ans += minMovestoMakeArrayEqual(x.second);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367221,
                "title": "c-using-gcd-and-median",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        if(arr.size()==k) return 0;\\n        int n=arr.size();\\n        long long ans=0;\\n        int g=__gcd(n,k);\\n        int num=n/g;\\n        vector<vector<int>>v(g);\\n        for(int i=0;i<arr.size();i++){\\n            v[i%g].push_back(arr[i]);\\n        }\\n        for(int i=0;i<v.size();i++)\\n            sort(v[i].begin(), v[i].end());\\n        vector<int>w;\\n        if(num%2==0){\\n            for(int i=0;i<v.size();i++){\\n                int t=(long long)(v[i][num/2] + v[i][num/2 - 1])/2;   \\n                w.push_back(t); \\n            }\\n        }\\n        else {\\n            for(int i=0;i<v.size();i++){\\n                int t=v[i][num/2]; \\n                w.push_back(t); \\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            ans+=abs(arr[i]-w[i%g]);\\n        }\\n         return ans;\\n    }\\n};\\n```\\nplease upvote if it helps!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        if(arr.size()==k) return 0;\\n        int n=arr.size();\\n        long long ans=0;\\n        int g=__gcd(n,k);\\n        int num=n/g;\\n        vector<vector<int>>v(g);\\n        for(int i=0;i<arr.size();i++){\\n            v[i%g].push_back(arr[i]);\\n        }\\n        for(int i=0;i<v.size();i++)\\n            sort(v[i].begin(), v[i].end());\\n        vector<int>w;\\n        if(num%2==0){\\n            for(int i=0;i<v.size();i++){\\n                int t=(long long)(v[i][num/2] + v[i][num/2 - 1])/2;   \\n                w.push_back(t); \\n            }\\n        }\\n        else {\\n            for(int i=0;i<v.size();i++){\\n                int t=v[i][num/2]; \\n                w.push_back(t); \\n            }\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            ans+=abs(arr[i]-w[i%g]);\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367174,
                "title": "c-easy-solution-using-gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int n){\\n    long long ans = 0;\\n    sort(nums.begin(), nums.end());\\n    long long K = nums[n / 2];\\n    for (int i = 0; i < n; ++i)\\n        ans += abs(nums[i] - K);\\n\\n    if (n % 2 == 0) {\\n        long long tmp = 0;\\n        K = nums[(n / 2) - 1];\\n        for (int i = 0; i < n; ++i)\\n            tmp += abs(nums[i] - K);\\n        ans = min(ans, tmp);\\n    }\\n    return ans;\\n}\\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long n = arr.size();\\n        if(__gcd(n,(long long)k) == 1) return minCost(arr,n);\\n        else {\\n            long long ans=0;\\n            for(int i=0; i<__gcd(n,(long long)k); i++){\\n                vector<int>v1;\\n                for(int j=i; j<arr.size(); j+=__gcd(n,(long long)k))\\n                    v1.push_back(arr[j]);\\n                ans+=minCost(v1,v1.size());\\n            }\\n            return ans;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int n){\\n    long long ans = 0;\\n    sort(nums.begin(), nums.end());\\n    long long K = nums[n / 2];\\n    for (int i = 0; i < n; ++i)\\n        ans += abs(nums[i] - K);\\n\\n    if (n % 2 == 0) {\\n        long long tmp = 0;\\n        K = nums[(n / 2) - 1];\\n        for (int i = 0; i < n; ++i)\\n            tmp += abs(nums[i] - K);\\n        ans = min(ans, tmp);\\n    }\\n    return ans;\\n}\\n    \\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long n = arr.size();\\n        if(__gcd(n,(long long)k) == 1) return minCost(arr,n);\\n        else {\\n            long long ans=0;\\n            for(int i=0; i<__gcd(n,(long long)k); i++){\\n                vector<int>v1;\\n                for(int j=i; j<arr.size(); j+=__gcd(n,(long long)k))\\n                    v1.push_back(arr[j]);\\n                ans+=minCost(v1,v1.size());\\n            }\\n            return ans;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367116,
                "title": "solution-easy-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution is from YT->programming with Larry\\n\\nthe idea behind is  grouping  the element \\nExample\\n\\n[1,4,3,2,5,6,8] k=3\\n\\n1,4,3\\n#,4,3,2\\n#,#,3,2,5\\nand so on\\n\\nchanging the middle elements make no difference we need to make the end \\nelements equal that is  1,2,5 (thus forming a group)\\nsimlutating the process we will get more groups\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\nUPVOTE PLEASE\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N*log N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(N)$$\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        N=len(arr)\\n\\n        g=gcd(N,k)\\n\\n        c=collections.defaultdict(list)\\n\\n\\n        for i,x in enumerate(arr):\\n\\n            c[i%g].append(x)\\n    \\n\\n        count=0\\n\\n\\n        for i,k in c.items():\\n\\n            k.sort()\\n\\n            t=k[len(k)//2]\\n\\n            for y in k:\\n                count+=abs(t-y)\\n        return count\\n    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        N=len(arr)\\n\\n        g=gcd(N,k)\\n\\n        c=collections.defaultdict(list)\\n\\n\\n        for i,x in enumerate(arr):\\n\\n            c[i%g].append(x)\\n    \\n\\n        count=0\\n\\n\\n        for i,k in c.items():\\n\\n            k.sort()\\n\\n            t=k[len(k)//2]\\n\\n            for y in k:\\n                count+=abs(t-y)\\n        return count\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367109,
                "title": "divide-into-groups-easy-explaination",
                "content": "Lets divide the solution into 2 parts - \\n1. Divide into groups\\n2. Calculating for each group\\n\\n\\n\\n**Dividing into groups**\\n\\nLet arr = [a1 a2 a3 a4 a5 a6 a7]\\nfor k = 3, \\na1+a2+a3 = a2+a3+a4 => a1=a4\\n\\nFrom the above obervation we can see, that the elements at distance k should be equal , i.e a1=a4=a7\\nTherefore some chains would be created , in which the consecutive indexes in the chain would be at the distance k in the array\\n\\n\\n**Calculating for each group** \\nExacty same problem\\n    https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/submissions/735072118/\\n\\nWe can just find the median and then calculate cost to make each element equal to the median.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<vector<int> > groups;\\n        \\n        for(int i=0;i<n;i++){\\n            if(arr[i]==-1) continue;\\n            vector<int> group;\\n            for(int j=i;arr[j]!=-1;j = (j+k)%n){\\n                group.push_back(arr[j]);\\n                arr[j]=-1;\\n            }\\n            groups.push_back(group);\\n        }\\n        \\n        long long ans=0;\\n        for(auto &group:groups){\\n            sort(group.begin(),group.end());\\n            int median = group[group.size()/2];\\n            for(auto &e:group){\\n                ans += abs(median-e);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<vector<int> > groups;\\n        \\n        for(int i=0;i<n;i++){\\n            if(arr[i]==-1) continue;\\n            vector<int> group;\\n            for(int j=i;arr[j]!=-1;j = (j+k)%n){\\n                group.push_back(arr[j]);\\n                arr[j]=-1;\\n            }\\n            groups.push_back(group);\\n        }\\n        \\n        long long ans=0;\\n        for(auto &group:groups){\\n            sort(group.begin(),group.end());\\n            int median = group[group.size()/2];\\n            for(auto &e:group){\\n                ans += abs(median-e);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367057,
                "title": "c-find-centers-of-all-equivalent-groups",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        //group: [i],[i+k],[i+2k], ..., all have to be equal for all i = 0, 1, ... k-1\\n        long long n = arr.size(), op = 0;\\n        vector<bool> visited(k, false);\\n        for(int i = 0; i < k; ++i) {\\n            if(visited[i]) continue;\\n            \\n            vector<int> group;\\n            int j = i;\\n            do {\\n                visited[j] = true;\\n                for(; j < n; j += k)\\n                    group.push_back(arr[j]);\\n                j = j % n;\\n            }\\n            while(j < k && !visited[j]);\\n\\n            auto mid = group.begin() + group.size()/2;\\n            nth_element(group.begin(), mid, group.end());\\n            for_each(group.begin(), group.end(), [mid, &op](auto const& g) { op += abs(*mid - g); });\\n        }\\n        return op;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        //group: [i],[i+k],[i+2k], ..., all have to be equal for all i = 0, 1, ... k-1\\n        long long n = arr.size(), op = 0;\\n        vector<bool> visited(k, false);\\n        for(int i = 0; i < k; ++i) {\\n            if(visited[i]) continue;\\n            \\n            vector<int> group;\\n            int j = i;\\n            do {\\n                visited[j] = true;\\n                for(; j < n; j += k)\\n                    group.push_back(arr[j]);\\n                j = j % n;\\n            }\\n            while(j < k && !visited[j]);\\n\\n            auto mid = group.begin() + group.size()/2;\\n            nth_element(group.begin(), mid, group.end());\\n            for_each(group.begin(), group.end(), [mid, &op](auto const& g) { op += abs(*mid - g); });\\n        }\\n        return op;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366930,
                "title": "finding-median-of-cycles-code-breakdown-nth-element-to-find-median-quick-select-algorithm",
                "content": "# Intuition\\narr[i] should be equal to all arr[i+k] after all the operations are complete\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\n## **Step By Step Code Breakdown :**\\n\\n```\\nint sz = arr.size(); long long ans=0;\\n```\\nInitialize the size of the input vector arr and a variable ans to keep track of the total absolute differences between the elements in each subarray and its median value.\\n```\\nfor(int i=0;i<sz;i++)\\n```\\n\\n Iterate through each index in the input vector arr.\\n\\n```\\nvector<int> cycle; \\n```\\n\\nCreate a new vector cycle to store the subarray of length k starting at index i.\\n\\n```\\nfor(int j = i; arr[j]!=0 ; j= (j+k)%sz)\\n```\\n\\nIterate through each index in the subarray, wrapping around to the beginning of the vector if necessary. The loop stops when it reaches an element with value 0, which is set by the code in step 7.\\n\\n```\\n{ cycle.push_back(arr[j]); arr[j]=0; }:\\n``` \\n\\nAdd the current element to the cycle vector and set its value to 0 to indicate that it has been included in a subarray.\\n\\n```\\nint median_idx = (int)cycle.size()/2;\\n```\\n\\nFind the median index of the cycle vector.\\n\\n```\\nnth_element(cycle.begin(),cycle.begin()+median_idx,cycle.end());\\n```\\nRearrange the elements in the cycle vector such that the median_idx element is in its final sorted position.\\n\\n```\\nfor(auto e : cycle) cout<<e<<\" \"; cout<<endl;\\n``` \\n\\nOutput the cycle vector to the console (for debugging purposes).\\n\\n```\\nfor(auto e : cycle) { ans+= abs(e-cycle[median_idx]); }\\n```\\nIterate through each element in the cycle vector and add the absolute difference between it and the median element to the ans variable.\\n\\n```\\nreturn ans;: \\n```\\nReturn the total absolute differences between the elements in each subarray and its median value.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# References \\n[https://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3366373/k-cycles-o-n/]()\\n\\n[https://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3366534/dsu-prefix-sum-o-n-longn/]()\\n\\n[https://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3366442/python-3-find-median-of-each-gcd-defined-subarray-w-examples/]()\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n\\n        int sz = arr.size(); long long ans=0;\\n\\n        for(int i=0;i<sz;i++)\\n        {\\n            vector<int> cycle;\\n\\n            for(int j = i; arr[j]!=0 ; j= (j+k)%sz)\\n               { \\n                   cycle.push_back(arr[j]);arr[j]=0;\\n                }\\n\\n            int median_idx = (int)cycle.size()/2;\\n\\n            nth_element(cycle.begin(),cycle.begin()+median_idx,cycle.end());\\n\\n\\n            for(auto e : cycle) cout<<e<<\" \"; cout<<endl;\\n            for(auto e : cycle)\\n            {\\n                ans+= abs(e-cycle[median_idx]);\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Quickselect"
                ],
                "code": "```\\nint sz = arr.size(); long long ans=0;\\n```\n```\\nfor(int i=0;i<sz;i++)\\n```\n```\\nvector<int> cycle; \\n```\n```\\nfor(int j = i; arr[j]!=0 ; j= (j+k)%sz)\\n```\n```\\n{ cycle.push_back(arr[j]); arr[j]=0; }:\\n```\n```\\nint median_idx = (int)cycle.size()/2;\\n```\n```\\nnth_element(cycle.begin(),cycle.begin()+median_idx,cycle.end());\\n```\n```\\nfor(auto e : cycle) cout<<e<<\" \"; cout<<endl;\\n```\n```\\nfor(auto e : cycle) { ans+= abs(e-cycle[median_idx]); }\\n```\n```\\nreturn ans;: \\n```\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n\\n        int sz = arr.size(); long long ans=0;\\n\\n        for(int i=0;i<sz;i++)\\n        {\\n            vector<int> cycle;\\n\\n            for(int j = i; arr[j]!=0 ; j= (j+k)%sz)\\n               { \\n                   cycle.push_back(arr[j]);arr[j]=0;\\n                }\\n\\n            int median_idx = (int)cycle.size()/2;\\n\\n            nth_element(cycle.begin(),cycle.begin()+median_idx,cycle.end());\\n\\n\\n            for(auto e : cycle) cout<<e<<\" \"; cout<<endl;\\n            for(auto e : cycle)\\n            {\\n                ans+= abs(e-cycle[median_idx]);\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3366914,
                "title": "python3-gcd-n-k-groups-o-n-o-nlogn",
                "content": "```python\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        \\n\\t\\t# in the same group means a[1] == a[1 + k] == a[1+ 2k]\\n\\t\\t# we need lcm(n, k) to repeat\\n\\t\\t# and we will have lcm(n, k)/k members for each group\\n\\t\\t# then the group count is n / (lcm(n, k) / k)\\n\\t\\t# which is (n * k) / lcm(n, k) == gcd(n, k)\\n\\t\\t\\n\\t\\t# how many groups we will have\\n        group_count = gcd(n, k)\\n        groups = [[] for _ in range(group_count)]\\n\\t\\t\\n\\t\\t# determine group id for each i\\n        for i in range(n):\\n            groups[i % group_count].append(arr[i])\\n\\n        res = 0\\n        for group in groups:\\n            group.sort()\\n\\t\\t\\t# sum distances to median\\n            res += sum(abs(g - group[len(group)//2]) for g in group)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        n = len(arr)\\n        \\n\\t\\t# in the same group means a[1] == a[1 + k] == a[1+ 2k]\\n\\t\\t# we need lcm(n, k) to repeat\\n\\t\\t# and we will have lcm(n, k)/k members for each group\\n\\t\\t# then the group count is n / (lcm(n, k) / k)\\n\\t\\t# which is (n * k) / lcm(n, k) == gcd(n, k)\\n\\t\\t\\n\\t\\t# how many groups we will have\\n        group_count = gcd(n, k)\\n        groups = [[] for _ in range(group_count)]\\n\\t\\t\\n\\t\\t# determine group id for each i\\n        for i in range(n):\\n            groups[i % group_count].append(arr[i])\\n\\n        res = 0\\n        for group in groups:\\n            group.sort()\\n\\t\\t\\t# sum distances to median\\n            res += sum(abs(g - group[len(group)//2]) for g in group)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366884,
                "title": "sorting-to-find-the-median",
                "content": "# Intuition\\nWe should have arr[i] == arr[(i + k) % n] where n = arr.size(). So just get all these numbers in a group and find the median.\\n\\n# Approach\\nThis is to use the \"period\".\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long r = 0;\\n        const int n = arr.size();\\n        vector<bool> mark(n);\\n        for (int i = 0; i < k; ++i) {\\n            if (mark[i]) {\\n                continue;\\n            }\\n            vector<int> v;\\n            for (int j = i; !mark[j] ; j = (j + k) % n) {\\n                mark[j] = true;\\n                v.push_back(arr[j]);\\n            }\\n            sort(v.begin(), v.end());\\n            for (int x = 0, m = v.size() >> 1; x < v.size(); ++x) {\\n                r += x <= m ? (v[m] - v[x]) : (v[x] - v[m]);\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long r = 0;\\n        const int n = arr.size();\\n        vector<bool> mark(n);\\n        for (int i = 0; i < k; ++i) {\\n            if (mark[i]) {\\n                continue;\\n            }\\n            vector<int> v;\\n            for (int j = i; !mark[j] ; j = (j + k) % n) {\\n                mark[j] = true;\\n                v.push_back(arr[j]);\\n            }\\n            sort(v.begin(), v.end());\\n            for (int x = 0, m = v.size() >> 1; x < v.size(); ++x) {\\n                r += x <= m ? (v[m] - v[x]) : (v[x] - v[m]);\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366875,
                "title": "group-into-fixed-periods-and-make-each-group-equal",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def GCD(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        k = self.GCD(len(arr), k)\\n        ctr = [[] for _ in range(k)]\\n        median = [0] * k\\n        for i in range(len(arr)):\\n            ctr[i % k].append(arr[i])\\n        for i in range(k):\\n            n = len(ctr[i])\\n            ctr[i].sort()\\n            median[i] = ctr[i][(n - 1) // 2]\\n        res = 0\\n        for i in range(k):\\n            n = len(ctr[i])\\n            for j in range(n):\\n                res += abs(ctr[i][j] - median[i])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def GCD(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        k = self.GCD(len(arr), k)\\n        ctr = [[] for _ in range(k)]\\n        median = [0] * k\\n        for i in range(len(arr)):\\n            ctr[i % k].append(arr[i])\\n        for i in range(k):\\n            n = len(ctr[i])\\n            ctr[i].sort()\\n            median[i] = ctr[i][(n - 1) // 2]\\n        res = 0\\n        for i in range(k):\\n            n = len(ctr[i])\\n            for j in range(n):\\n                res += abs(ctr[i][j] - median[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366873,
                "title": "easy-solution-for-begginers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        int n = arr.size();\\n        k = __gcd(k , n);\\n        for(int i=0;i<k;i++) {\\n            vector<int> temp;\\n            for(int j = i;j<n;j+=k) {\\n                temp.push_back(arr[j]);\\n            }\\n// the nth_element function will place the nth element of vector in the correct position after sorting, it takes O(n) for average case, we can find median by sorting also but it takes O(nlogn) time.\\n            nth_element(temp.begin(),temp.begin()+(temp.size()/2),temp.end());\\n            long long med = temp[temp.size()/2];\\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(med- arr[j]);\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        int n = arr.size();\\n        k = __gcd(k , n);\\n        for(int i=0;i<k;i++) {\\n            vector<int> temp;\\n            for(int j = i;j<n;j+=k) {\\n                temp.push_back(arr[j]);\\n            }\\n// the nth_element function will place the nth element of vector in the correct position after sorting, it takes O(n) for average case, we can find median by sorting also but it takes O(nlogn) time.\\n            nth_element(temp.begin(),temp.begin()+(temp.size()/2),temp.end());\\n            long long med = temp[temp.size()/2];\\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(med- arr[j]);\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366660,
                "title": "easy-solution-to-great-problem-i-var",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to update some element in such a way that each subarray of given size sould have equal sum.\\nSo, how we can do this, think of a sequence of length n sub array sum will be equal only if first and last element are equal. Use this to solve further or continue to Read.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, moving forward with above idea, arr[i] should be equal to arr[(i+k)%n.\\nNow based on that idea we group elements which needs to have same value. now our problem is to find minimum number of given operations(++ or --) to make all element of arr equal.\\nApply this same to all group. Sum of all values will be the answer.\\n\\n# Complexity\\n- Time and Space complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    If you understand than comment time Complexity and space Complexity.\\n\\n# Code\\n``` C++ []\\nclass Solution {\\n    long long findMinVariance(vector<int> v){\\n        int n = v.size();\\n        vector<long long> uEle;\\n        map<int,int> m;\\n        long long sum=0;\\n        for(auto x:v){\\n            sum+=x;\\n            if(!m[x]){\\n                uEle.push_back(x);\\n            }\\n            m[x]++;\\n        }\\n        int n2 = uEle.size();\\n        vector<long long> count(n2+1,0);\\n        vector<long long> s(n2+1,0);\\n        \\n        for(int i=0;i<n2;i++){\\n            count[i+1] = count[i]+m[uEle[i]];\\n            s[i+1] = s[i]+uEle[i]*m[uEle[i]];\\n        }\\n        long long ans=LONG_MAX;\\n        for(int i=0;i<n2;i++){\\n            ans=min(ans,\\n                    count[i]*uEle[i]-s[i] + (sum-s[i+1])-(n-count[i+1])*uEle[i]\\n                   );\\n        }\\n        return ans;\\n    }\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        vector<int> flag(arr.size(),true);\\n        int n = arr.size();\\n        vector<vector<int>> sets;\\n        for(int i=0;i<n;i++){\\n            if(flag[i]){\\n                vector<int> temp;\\n                int j=i;\\n                while(flag[j]){\\n                    flag[j] = false;\\n                    temp.push_back(arr[j]);\\n                    j+=k;\\n                    j%=n;\\n                }\\n                sort(temp.begin(),temp.end());\\n                sets.push_back(temp);\\n            }\\n        }\\n        long long ans=0;\\n        for(auto s:sets){\\n            ans+=findMinVariance(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\n    long long findMinVariance(vector<int> v){\\n        int n = v.size();\\n        vector<long long> uEle;\\n        map<int,int> m;\\n        long long sum=0;\\n        for(auto x:v){\\n            sum+=x;\\n            if(!m[x]){\\n                uEle.push_back(x);\\n            }\\n            m[x]++;\\n        }\\n        int n2 = uEle.size();\\n        vector<long long> count(n2+1,0);\\n        vector<long long> s(n2+1,0);\\n        \\n        for(int i=0;i<n2;i++){\\n            count[i+1] = count[i]+m[uEle[i]];\\n            s[i+1] = s[i]+uEle[i]*m[uEle[i]];\\n        }\\n        long long ans=LONG_MAX;\\n        for(int i=0;i<n2;i++){\\n            ans=min(ans,\\n                    count[i]*uEle[i]-s[i] + (sum-s[i+1])-(n-count[i+1])*uEle[i]\\n                   );\\n        }\\n        return ans;\\n    }\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        vector<int> flag(arr.size(),true);\\n        int n = arr.size();\\n        vector<vector<int>> sets;\\n        for(int i=0;i<n;i++){\\n            if(flag[i]){\\n                vector<int> temp;\\n                int j=i;\\n                while(flag[j]){\\n                    flag[j] = false;\\n                    temp.push_back(arr[j]);\\n                    j+=k;\\n                    j%=n;\\n                }\\n                sort(temp.begin(),temp.end());\\n                sets.push_back(temp);\\n            }\\n        }\\n        long long ans=0;\\n        for(auto s:sets){\\n            ans+=findMinVariance(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366594,
                "title": "c-faster-than-95-math",
                "content": "# Intuition\\nFirst calculate the number of independent groups.\\n\\n# Approach\\nFirst calculate the number of independent groups - it will be the least common multiple of arr.Length and k:\\n```\\nprivate int GetMin(int n, int k)\\n```\\nThen calculate the result as a sum of results in each groups:\\n```\\nprivate long GetMin(List<int> list)\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(len(arr))$$\\n\\n- Space complexity:\\n$$O(len(arr))$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MakeSubKSumEqual(int[] arr, int k) {\\n        var shift = GetMin(arr.Length, k);\\n        var rs = 0L;\\n        for (int i = 0; i < shift; i++)\\n        {\\n            var list = GetIthList(i, shift, arr);\\n            rs += GetMin(list);\\n        }\\n        return rs;\\n    }\\n    private long GetMin(List<int> list)\\n    {\\n        var rs = 0L;\\n        list.Sort();\\n        var val = list[list.Count / 2];\\n        for (int i = 0; i < list.Count; i++)\\n        {\\n            rs += Math.Abs(list[i] - val);\\n        }\\n        return rs;\\n    }\\n    private List<int> GetIthList(int index, int shift, int[] arr)\\n    {\\n        var rs = new List<int>();\\n        for (int i = index; i < arr.Length; i += shift)\\n        {\\n            rs.Add(arr[i]);\\n        }\\n        return rs;\\n    }\\n    private int GetMin(int n, int k)\\n    {\\n        if (n % k == 0) return k;\\n        return GetMin(k, n % k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nprivate int GetMin(int n, int k)\\n```\n```\\nprivate long GetMin(List<int> list)\\n```\n```\\npublic class Solution {\\n    public long MakeSubKSumEqual(int[] arr, int k) {\\n        var shift = GetMin(arr.Length, k);\\n        var rs = 0L;\\n        for (int i = 0; i < shift; i++)\\n        {\\n            var list = GetIthList(i, shift, arr);\\n            rs += GetMin(list);\\n        }\\n        return rs;\\n    }\\n    private long GetMin(List<int> list)\\n    {\\n        var rs = 0L;\\n        list.Sort();\\n        var val = list[list.Count / 2];\\n        for (int i = 0; i < list.Count; i++)\\n        {\\n            rs += Math.Abs(list[i] - val);\\n        }\\n        return rs;\\n    }\\n    private List<int> GetIthList(int index, int shift, int[] arr)\\n    {\\n        var rs = new List<int>();\\n        for (int i = index; i < arr.Length; i += shift)\\n        {\\n            rs.Add(arr[i]);\\n        }\\n        return rs;\\n    }\\n    private int GetMin(int n, int k)\\n    {\\n        if (n % k == 0) return k;\\n        return GetMin(k, n % k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366552,
                "title": "sorting-gcd-absolute",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n    \\n        k = __gcd(k , n);\\n        for(int i=0;i<k;i++) {\\n            vector<int> val;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                val.push_back(arr[j]);\\n            }\\n            \\n            sort(val.begin() , val.end());\\n            \\n            long long midv = val[val.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans = 0;\\n        \\n        int n = arr.size();\\n    \\n        k = __gcd(k , n);\\n        for(int i=0;i<k;i++) {\\n            vector<int> val;\\n            \\n            for(int j = i;j<n;j+=k) {\\n                val.push_back(arr[j]);\\n            }\\n            \\n            sort(val.begin() , val.end());\\n            \\n            long long midv = val[val.size()/2];\\n            \\n            for(int j=i;j<n;j+=k) {\\n                ans += abs(midv - arr[j]);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366496,
                "title": "group-the-elements-at-distance-k-o-n-log-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGroup the indices at a difference of k, together, sort them and get them as equal to median of that group.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans=0;\\n        int n = arr.size();\\n        vector<bool> visited(n, false);\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                vector<int> res;\\n                int d=i;\\n                while(!visited[d]){\\n                    visited[d]=true;\\n                    res.push_back(arr[d]);\\n                    d=d+k;\\n                    d%=n;\\n                }\\n                \\n                sort(res.begin(), res.end());\\n                //choose the median\\n                int dsiz=res.size();\\n                int med=0;\\n                if(dsiz%2){\\n                    med=res[dsiz/2];\\n                }\\n                else{\\n                    med=(res[dsiz/2]+res[(dsiz+1)/2])/2.0;\\n                }\\n                \\n                for(int j=0;j<dsiz;j++){\\n                    ans+=abs(res[j]-med);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        long long ans=0;\\n        int n = arr.size();\\n        vector<bool> visited(n, false);\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                vector<int> res;\\n                int d=i;\\n                while(!visited[d]){\\n                    visited[d]=true;\\n                    res.push_back(arr[d]);\\n                    d=d+k;\\n                    d%=n;\\n                }\\n                \\n                sort(res.begin(), res.end());\\n                //choose the median\\n                int dsiz=res.size();\\n                int med=0;\\n                if(dsiz%2){\\n                    med=res[dsiz/2];\\n                }\\n                else{\\n                    med=(res[dsiz/2]+res[(dsiz+1)/2])/2.0;\\n                }\\n                \\n                for(int j=0;j<dsiz;j++){\\n                    ans+=abs(res[j]-med);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1850414,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1850218,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1850205,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1852323,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1850314,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2016810,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2016652,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1867145,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1852863,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1851228,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1850414,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1850218,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1850205,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1852323,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1850314,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2016810,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2016652,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1867145,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1852863,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1851228,
                "content": [
                    {
                        "username": "TheSAR",
                        "content": "What is this? codeforces?"
                    },
                    {
                        "username": "dimaglushkov",
                        "content": "Acceptance rate 16.1% for a medium problem is kinda non-sense :) \nThis one is definitely harder than the last one "
                    },
                    {
                        "username": "Dernibes",
                        "content": "The final few test cases seem brutal"
                    },
                    {
                        "username": "Dernibes",
                        "content": "damn I was using the mean of the subarrays to calculate the number of operations, can someone explain why using the median instead works? shouldnt the mean minimize the operations?"
                    },
                    {
                        "username": "izmitpismaniyesi",
                        "content": "Lets consider this example 1 1 1 997 ---> mean = 250. The answer is 249 + 249 + 249 +747. For the median. The answer is 997-1. Much much less."
                    },
                    {
                        "username": "lalit10368",
                        "content": "I see a lot of people are posting solutions that have gcd involved but  I don\\'t see proper justifications for taking gcd. Seems like people have got really good at pattern recognition & just copy paste ideas without proper justification at times. \\n\\nNevertheless, I did understood why it\\'s required, it improves on the number of buckets and hence the overall runtime.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "I\\'m not sure what you mean by \"number of buckets\". Can you elaborate?\\nFor how `gcd` comes into the picture, see:\\nhttps://leetcode.com/problems/make-k-subarray-sums-equal/solutions/3605884/beat-100-o-n-optimal-solution-selection-instead-of-sorting/"
                    },
                    {
                        "username": "vavishalarya",
                        "content": "Can you ellaborate on the number of buckets part, please?\\n"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "FcUk : the mistake i did while reading this word is directly proportional to mistakes i commit during contest."
                    },
                    {
                        "username": "Abhi_Bhatt",
                        "content": "How on Earth do people see the pattern here and what\\'s the intuition behind using GCD?"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "why the answer for [10,3,8] k=2 is 7  it should be 2 as we can convert to 9 3 9 in 2 operations, and the sum is equal that is 12. please help . \\n"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "9,9 would make 18"
                    },
                    {
                        "username": "akshatguptakth",
                        "content": "how the ans of this testcase possible\\narr=[8,2,5,9,8,10]\\nk=2;\\nans=11;\\n\\nBut I think ans should be 12 ."
                    },
                    {
                        "username": "MdoingIt",
                        "content": "this one should be labelled hard !!!!!\\n"
                    },
                    {
                        "username": "nikhiljha06",
                        "content": "can someone please explain the mistake in my code.\\n\\ncode:\\n\\n#define ll long long\\n#define pb push_back\\n#define all(v) v.begin(),v.end()\\nclass Solution {\\npublic:\\nll getmid(vector<int>& arr,ll& n){\\n    if(n%2) return arr[n/2];\\n    else return (arr[n/2]+arr[n/2-1])/2;\\n}\\nll getmid_chc(vector<int>& arr,ll& n,int c){\\n    vector<int> temp;\\n        for(ll i=0;i<n;i++){\\n            if(i%2==c){\\n                temp.pb(arr[i]);\\n            }\\n        }\\n        ll m=temp.size();\\n        sort(all(temp));\\n        return getmid(temp,m);\\n\\n}\\n    long long makeSubKSumEqual(vector<int>& arr, int k) {\\n        ll n=arr.size();\\n        if(k==n) return 0;\\n        if(k%2||n%2){\\n\\n            ll v1=0;\\n            sort(all(arr));\\n            ll avg=getmid(arr,n);\\n            for(ll i=0;i<n;i++){\\n                v1+=abs(avg-arr[i]);\\n                \\n            }\\n            \\n            return v1;\\n        }\\n        else{\\n            \\n            ll avg2=getmid_chc(arr,n,1),avg1=getmid_chc(arr,n,0);\\n            \\n            ll v1=1e9;\\n            ll curr1=0,curr2=0;\\n            for(ll i=0;i<n;i++){\\n                if(i%2==0){\\n                    curr1+=abs(avg1-arr[i]);\\n                \\n                }\\n                else{\\n                    curr2+=abs(avg2-arr[i]);\\n                    \\n                }\\n            }\\n            \\n            v1=(curr1+curr2);\\n            return v1;\\n        }\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Shortest Cycle in a Graph",
        "question_content": "<p>There is a <strong>bi-directional </strong>graph with <code>n</code> vertices, where each vertex is labeled from <code>0</code> to <code>n - 1</code>. The edges in the graph are represented by a given 2D integer array <code>edges</code>, where <code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> denotes an edge between vertex <code>u<sub>i</sub></code> and vertex <code>v<sub>i</sub></code>. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.</p>\n\n<p>Return <em>the length of the <strong>shortest </strong>cycle in the graph</em>. If no cycle exists, return <code>-1</code>.</p>\n\n<p>A cycle is a path that starts and ends at the same node, and each edge in the path is used only once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/04/cropped.png\" style=\"width: 387px; height: 331px;\" />\n<pre>\n<strong>Input:</strong> n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The cycle with the smallest length is : 0 -&gt; 1 -&gt; 2 -&gt; 0 \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/01/04/croppedagin.png\" style=\"width: 307px; height: 307px;\" />\n<pre>\n<strong>Input:</strong> n = 4, edges = [[0,1],[0,2]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> There are no cycles in this graph.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li>There are no repeated edges.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3366629,
                "title": "intuitive-approach-bfs-clean-code-c",
                "content": "![image](https://assets.leetcode.com/users/images/2b9fece5-79c6-40f9-b3c8-3edbcea69d8d_1680373041.4973803.jpeg)\\n\\nat every vertex we are checking for shortest cycle\\nUsing BFS \\n```\\nclass Solution\\n{\\npublic:\\n    \\n    int ans = INT_MAX;\\n\\n    void bfs(int src,vector<int> adj[],int n){\\n            vector<int> distance(n,(1e9));\\n            vector<int> parent(n, -1);\\n            \\n            queue<int> q;\\n            distance[src] = 0;\\n            q.push(src);\\n            while (!q.empty()) {\\n                int node = q.front();\\n                q.pop();\\n                for (auto neigh : adj[node]) {\\n                    if (distance[neigh] == (int)(1e9)) {\\n                        distance[neigh] = 1 + distance[node];\\n                        parent[neigh] = node;\\n                        q.push(neigh);\\n                }\\n                else if (parent[node] != neigh && parent[neigh] != node)\\n                    ans = min(ans, distance[neigh] + distance[node] + 1);\\n                }\\n            }\\n    }\\n    int findShortestCycle(int n, vector<vector<int>> &edges)\\n    {\\n\\n        vector<int> adj[n + 1];\\n        for (auto it : edges)\\n        {\\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n      \\n        for (int i = 0; i < n; i++)\\n        {\\n            bfs(i,adj,n);\\n        }\\n        if (ans == INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n};\\n\\n\\nupvote if found usefull\\n Thanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution\\n{\\npublic:\\n    \\n    int ans = INT_MAX;\\n\\n    void bfs(int src,vector<int> adj[],int n){\\n            vector<int> distance(n,(1e9));\\n            vector<int> parent(n, -1);\\n            \\n            queue<int> q;\\n            distance[src] = 0;\\n            q.push(src);\\n            while (!q.empty()) {\\n                int node = q.front();\\n                q.pop();\\n                for (auto neigh : adj[node]) {\\n                    if (distance[neigh] == (int)(1e9)) {\\n                        distance[neigh] = 1 + distance[node];\\n                        parent[neigh] = node;\\n                        q.push(neigh);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3366500,
                "title": "java-c-python-bfs",
                "content": "# **Explanation**\\nAssume a node is root and apply bfs search,\\nwhere we recode the:\\n- `dis[i]` is the distance from root to `i`\\n- `fa[i]` is the father of `i`\\n\\nIf two points met up and they are not father-son relation,\\nthey met in a cycle.\\nThe distance of circly is smaller or equal than `dis[i] + dis[j] + 1`.\\n\\nTo check the father-son relation, there some different ways:\\n- we can use an array `fa[i]` to save the father of each node.\\n- we can add `(i, father)` to the queue\\n- we can also check `dis[i] <= dis[j]`\\n\\nWe iterate all nodes as root, and we can return the minimum circle.\\n<br>\\n\\n# **Complexity**\\nTime `O(n^2)`\\nSpace `O(edges + n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> G = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            G.add(new ArrayList<>());\\n        }\\n        for (int[] e : edges) {\\n            G.get(e[0]).add(e[1]);\\n            G.get(e[1]).add(e[0]);\\n        }\\n        int inf = 10000, res = inf;\\n        Function<Integer, Integer> root = i -> {\\n            List<Integer> dis = new ArrayList<>(Collections.nCopies(n, inf));\\n            dis.set(i, 0);\\n            Queue<Integer> bfs = new LinkedList<>(Arrays.asList(i));\\n            while (!bfs.isEmpty()) {\\n                i = bfs.poll();\\n                for (int j : G.get(i)) {\\n                    if (dis.get(j) == inf) {\\n                        dis.set(j, 1 + dis.get(i));\\n                        bfs.offer(j);\\n                    } else if (dis.get(i) <= dis.get(j)) {\\n                        return dis.get(i) + dis.get(j) + 1;\\n                    }\\n                }\\n            }\\n            return inf;\\n        };\\n        for (int i = 0; i < n; ++i)\\n            res = Math.min(res, root.apply(i));\\n        return res < inf ? res : -1;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> G(n);\\n        for (auto& e : edges) {\\n            G[e[0]].push_back(e[1]);\\n            G[e[1]].push_back(e[0]);\\n        }\\n        int inf = 10000, res = inf;\\n        auto root = [&](int i) {\\n            vector<int> dis(n, inf);\\n            dis[i] = 0;\\n            queue<int> bfs{{i}};\\n            while (!bfs.empty()) {\\n                auto i = bfs.front(); bfs.pop();\\n                for (auto j : G[i]) {\\n                    if (dis[j] == inf) {\\n                        dis[j] = 1 + dis[i];\\n                        bfs.push(j);\\n                    } else if (dis[i] <= dis[j]) {\\n                        return dis[i] + dis[j] + 1;\\n                    }\\n                }\\n            }\\n            return inf;\\n        };\\n        for (int i = 0; i < n; ++i)\\n            res = min(res, root(i));\\n        return res < inf ? res : -1;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        G = [[] for _ in range(n)]\\n        for i, j in edges:\\n            G[i].append(j)\\n            G[j].append(i)\\n        def root(i):\\n            dis = [inf] * n\\n            dis[i] = 0\\n            bfs = [i]\\n            for i in bfs:\\n                for j in G[i]:\\n                    if dis[j] == inf:\\n                        dis[j] = 1 + dis[i]\\n                        bfs.append(j)\\n                    elif dis[i] <= dis[j]:\\n                        return dis[i] + dis[j] + 1\\n            return inf\\n        res = min(map(root, range(n)))\\n        return res if res < inf else -1\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> G = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            G.add(new ArrayList<>());\\n        }\\n        for (int[] e : edges) {\\n            G.get(e[0]).add(e[1]);\\n            G.get(e[1]).add(e[0]);\\n        }\\n        int inf = 10000, res = inf;\\n        Function<Integer, Integer> root = i -> {\\n            List<Integer> dis = new ArrayList<>(Collections.nCopies(n, inf));\\n            dis.set(i, 0);\\n            Queue<Integer> bfs = new LinkedList<>(Arrays.asList(i));\\n            while (!bfs.isEmpty()) {\\n                i = bfs.poll();\\n                for (int j : G.get(i)) {\\n                    if (dis.get(j) == inf) {\\n                        dis.set(j, 1 + dis.get(i));\\n                        bfs.offer(j);\\n                    } else if (dis.get(i) <= dis.get(j)) {\\n                        return dis.get(i) + dis.get(j) + 1;\\n                    }\\n                }\\n            }\\n            return inf;\\n        };\\n        for (int i = 0; i < n; ++i)\\n            res = Math.min(res, root.apply(i));\\n        return res < inf ? res : -1;\\n    }\\n```\n```cpp\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> G(n);\\n        for (auto& e : edges) {\\n            G[e[0]].push_back(e[1]);\\n            G[e[1]].push_back(e[0]);\\n        }\\n        int inf = 10000, res = inf;\\n        auto root = [&](int i) {\\n            vector<int> dis(n, inf);\\n            dis[i] = 0;\\n            queue<int> bfs{{i}};\\n            while (!bfs.empty()) {\\n                auto i = bfs.front(); bfs.pop();\\n                for (auto j : G[i]) {\\n                    if (dis[j] == inf) {\\n                        dis[j] = 1 + dis[i];\\n                        bfs.push(j);\\n                    } else if (dis[i] <= dis[j]) {\\n                        return dis[i] + dis[j] + 1;\\n                    }\\n                }\\n            }\\n            return inf;\\n        };\\n        for (int i = 0; i < n; ++i)\\n            res = min(res, root(i));\\n        return res < inf ? res : -1;\\n    }\\n```\n```py\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        G = [[] for _ in range(n)]\\n        for i, j in edges:\\n            G[i].append(j)\\n            G[j].append(i)\\n        def root(i):\\n            dis = [inf] * n\\n            dis[i] = 0\\n            bfs = [i]\\n            for i in bfs:\\n                for j in G[i]:\\n                    if dis[j] == inf:\\n                        dis[j] = 1 + dis[i]\\n                        bfs.append(j)\\n                    elif dis[i] <= dis[j]:\\n                        return dis[i] + dis[j] + 1\\n            return inf\\n        res = min(map(root, range(n)))\\n        return res if res < inf else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3366696,
                "title": "video-explanation-with-intuitive-proof",
                "content": "# Explanation\\n\\nhttps://youtu.be/_OMkeb3oTks\\n\\n[Click here if the preview above doesn\\'t works](https://youtu.be/_OMkeb3oTks)\\n\\n# Code\\n```\\nconst int N = 1e3 + 1;\\nconst int INF = 1e9;\\n\\nvector<set<int>> g(N);\\nvector<int> level(N);\\n\\nclass Solution {\\n    void bfs (int root) {\\n        queue<int> q;\\n        \\n        q.push(root);\\n        level[root] = 0;\\n        \\n        while (!q.empty()) {\\n            int top = q.front();\\n            q.pop();\\n            \\n            for (auto i : g[top]) {\\n                if (level[i] != INF) continue;\\n                level[i] = level[top] + 1;\\n                q.push(i);\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        for (int j = 0; j < n; j ++) {\\n            g[j].clear();\\n        }\\n        for (auto e : edges) {\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n        \\n        int result = INF;\\n        for (auto e : edges) {\\n            g[e[0]].erase(e[1]);\\n            g[e[1]].erase(e[0]);\\n            \\n            for (int j = 0; j < n; j ++) level[j] = INF;\\n            bfs (e[0]);\\n            \\n            result = min (result, level[e[1]] + 1);\\n        }\\n        \\n        if (result == INF) result = -1;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int N = 1e3 + 1;\\nconst int INF = 1e9;\\n\\nvector<set<int>> g(N);\\nvector<int> level(N);\\n\\nclass Solution {\\n    void bfs (int root) {\\n        queue<int> q;\\n        \\n        q.push(root);\\n        level[root] = 0;\\n        \\n        while (!q.empty()) {\\n            int top = q.front();\\n            q.pop();\\n            \\n            for (auto i : g[top]) {\\n                if (level[i] != INF) continue;\\n                level[i] = level[top] + 1;\\n                q.push(i);\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        for (int j = 0; j < n; j ++) {\\n            g[j].clear();\\n        }\\n        for (auto e : edges) {\\n            g[e[0]].insert(e[1]);\\n            g[e[1]].insert(e[0]);\\n        }\\n        \\n        int result = INF;\\n        for (auto e : edges) {\\n            g[e[0]].erase(e[1]);\\n            g[e[1]].erase(e[0]);\\n            \\n            for (int j = 0; j < n; j ++) level[j] = INF;\\n            bfs (e[0]);\\n            \\n            result = min (result, level[e[1]] + 1);\\n        }\\n        \\n        if (result == INF) result = -1;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367004,
                "title": "bfs-vs-dfs",
                "content": "## BFS\\nYou can find the exact solution for this problem on the site for geeks. I just want to optimize it a bit.\\n\\n> Cannot paste a link, sorry, or LeetCode would shadow-ban this post.\\n\\nThe idea is to run BFS from each node. For each layer, you increase `dist` to the starting node. We use `from` array to make sure we do not go back.\\n\\nIf we go from node `i` to `j`, and see that `j` has been reached `from` a different path, this is our cycle. It\\'s also the shortest cycle because we do BFS.\\n\\nThe length of the cycle be even (`dist + 1 + dist + 1`), or odd (`dist + 1 + dist`). It is odd if nodes `i` and `j` are on the same level.\\n\\n**C++**\\n```cpp\\nint bfs(int i, int n, vector<vector<int>> &al) {\\n    vector<int> q{i}, q1, from(n, -1);\\n    for (int dist = 0; !q.empty(); ++dist) {\\n        q1.clear();\\n        for (int i : q)\\n            for (int j : al[i]) {\\n                if (from[j] != i && from[i] != j) {\\n                    if (from[j] != -1)\\n                        return (dist + 1) * 2 - count(begin(q), end(q), j); // i and j are on the same level.\\n                    from[j] = i;\\n                    q1.push_back(j);\\n                }\\n            }\\n        swap(q, q1);\\n    }\\n    return INT_MAX;\\n}\\nint findShortestCycle(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> al(n);\\n    for (const auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    int res = INT_MAX;\\n    for (int i = 0; i < n; ++i)\\n        res = min(res, bfs(i, n, al));\\n    return res == INT_MAX ? -1 : res;\\n}\\n```\\n\\n## DFS\\nI initially tried DFS and it did not work, and then it gave me TLE.\\n\\nWe also run DFS from every node here, and the trick is not only track the shortest loop for the starting node, but also any loop we find along the way.\\n\\nI think that this approach is less intuitive than BFS. The intuition here is that, if we visit nodes in a certain consistent order, and start our search from each node, we would eventually discover all loops.\\n\\n**C++**\\n```cpp\\nint dfs(int i, vector<vector<int>> &al, vector<int> &d, int cur_d = 1) {\\n    if (d[i])\\n        return cur_d > d[i] + 2 ? cur_d - d[i] : INT_MAX;\\n    int res = INT_MAX;    \\n    d[i] = cur_d;\\n    for (int j : al[i])\\n        res = min(res, dfs(j, al, d, cur_d + 1));\\n    return res;\\n}    \\nint findShortestCycle(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> al(n);\\n    for (const auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    int res = INT_MAX;\\n    for (int i = 0; i < n; ++i)\\n        res = min(res, dfs(i, al, vector<int>(n) = {}));\\n    return res == INT_MAX ? -1 : res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint bfs(int i, int n, vector<vector<int>> &al) {\\n    vector<int> q{i}, q1, from(n, -1);\\n    for (int dist = 0; !q.empty(); ++dist) {\\n        q1.clear();\\n        for (int i : q)\\n            for (int j : al[i]) {\\n                if (from[j] != i && from[i] != j) {\\n                    if (from[j] != -1)\\n                        return (dist + 1) * 2 - count(begin(q), end(q), j); // i and j are on the same level.\\n                    from[j] = i;\\n                    q1.push_back(j);\\n                }\\n            }\\n        swap(q, q1);\\n    }\\n    return INT_MAX;\\n}\\nint findShortestCycle(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> al(n);\\n    for (const auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    int res = INT_MAX;\\n    for (int i = 0; i < n; ++i)\\n        res = min(res, bfs(i, n, al));\\n    return res == INT_MAX ? -1 : res;\\n}\\n```\n```cpp\\nint dfs(int i, vector<vector<int>> &al, vector<int> &d, int cur_d = 1) {\\n    if (d[i])\\n        return cur_d > d[i] + 2 ? cur_d - d[i] : INT_MAX;\\n    int res = INT_MAX;    \\n    d[i] = cur_d;\\n    for (int j : al[i])\\n        res = min(res, dfs(j, al, d, cur_d + 1));\\n    return res;\\n}    \\nint findShortestCycle(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> al(n);\\n    for (const auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    int res = INT_MAX;\\n    for (int i = 0; i < n; ++i)\\n        res = min(res, dfs(i, al, vector<int>(n) = {}));\\n    return res == INT_MAX ? -1 : res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366362,
                "title": "java-python-3-bfs-within-dfs",
                "content": "1. Construct a graph to access each edge by vertex efficiently;\\n2. Traverse all vertices, for each one, `i`, initialize the `dist` all as `MX` value except for `i`, set it as `0`; initialize `parent` all as `-1`;\\n3. Use BFS to find the shortest cycle through current vertex `i`: if any offspring of `i` has never been visited, we set its `dist` value as `1 +` its parent\\'s `dist`; If the offspring has already been visited and its parent is not the one we just visited, then a cycle found and update the mininum value `shortest`;\\n4. Repeat 3 to find the final solution.\\n\\n```java\\n    private static final int MX = Integer.MAX_VALUE; \\n    public int findShortestCycle(int n, int[][] edges) {\\n        Map<Integer, Set<Integer>> g = new HashMap<>();\\n        for (int[] e : edges) {\\n            g.computeIfAbsent(e[0], s -> new HashSet<>()).add(e[1]);\\n            g.computeIfAbsent(e[1], s -> new HashSet<>()).add(e[0]);\\n        }\\n        int shortest = MX;\\n        for (int i = 0; i < n; ++i) {\\n            int[] dist = new int[n], parent = new int[n];\\n            Arrays.fill(dist, MX);\\n            Arrays.fill(parent, -1);\\n            Queue<Integer> q = new LinkedList<>();\\n            q.offer(i);\\n            dist[i] = 0;\\n            while (!q.isEmpty()) {\\n                int node = q.poll();\\n                for (int kid : g.getOrDefault(node, Collections.emptySet())) {\\n                    if (dist[kid] == MX) {\\n                        dist[kid] = dist[node] + 1;\\n                        parent[kid] = node;\\n                        q.offer(kid);\\n                    }else if (parent[kid] != node && parent[node] != kid) {\\n                        shortest = Math.min(shortest, dist[kid] + dist[node] + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return shortest == MX ? -1 : shortest;\\n    }\\n```\\n```python\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        g = defaultdict(set)\\n        for u, v in edges:\\n            g[u].add(v)\\n            g[v].add(u)\\n        shortest = inf\\n        for i in range(n):\\n            dq, dist, parent = deque([i]), [inf] * n, [-1] * n\\n            dist[i] = 0\\n            while dq:\\n                node = dq.popleft()\\n                for kid in g.get(node, set()):\\n                    if dist[kid] == inf:\\n                        dist[kid] = dist[node] + 1\\n                        parent[kid] = node\\n                        dq.append(kid)\\n                    elif parent[kid] != node and parent[node] != kid:\\n                        shortest = min(shortest, dist[node] + dist[kid] + 1)\\n        return -1 if shortest == inf else shortest                \\n```\\n\\n**Analysis:**\\n\\nTime: `O(n * (n + E))`, space: `O(n + E)`, where `E = edges.length.`",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    private static final int MX = Integer.MAX_VALUE; \\n    public int findShortestCycle(int n, int[][] edges) {\\n        Map<Integer, Set<Integer>> g = new HashMap<>();\\n        for (int[] e : edges) {\\n            g.computeIfAbsent(e[0], s -> new HashSet<>()).add(e[1]);\\n            g.computeIfAbsent(e[1], s -> new HashSet<>()).add(e[0]);\\n        }\\n        int shortest = MX;\\n        for (int i = 0; i < n; ++i) {\\n            int[] dist = new int[n], parent = new int[n];\\n            Arrays.fill(dist, MX);\\n            Arrays.fill(parent, -1);\\n            Queue<Integer> q = new LinkedList<>();\\n            q.offer(i);\\n            dist[i] = 0;\\n            while (!q.isEmpty()) {\\n                int node = q.poll();\\n                for (int kid : g.getOrDefault(node, Collections.emptySet())) {\\n                    if (dist[kid] == MX) {\\n                        dist[kid] = dist[node] + 1;\\n                        parent[kid] = node;\\n                        q.offer(kid);\\n                    }else if (parent[kid] != node && parent[node] != kid) {\\n                        shortest = Math.min(shortest, dist[kid] + dist[node] + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return shortest == MX ? -1 : shortest;\\n    }\\n```\n```python\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        g = defaultdict(set)\\n        for u, v in edges:\\n            g[u].add(v)\\n            g[v].add(u)\\n        shortest = inf\\n        for i in range(n):\\n            dq, dist, parent = deque([i]), [inf] * n, [-1] * n\\n            dist[i] = 0\\n            while dq:\\n                node = dq.popleft()\\n                for kid in g.get(node, set()):\\n                    if dist[kid] == inf:\\n                        dist[kid] = dist[node] + 1\\n                        parent[kid] = node\\n                        dq.append(kid)\\n                    elif parent[kid] != node and parent[node] != kid:\\n                        shortest = min(shortest, dist[node] + dist[kid] + 1)\\n        return -1 if shortest == inf else shortest                \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3366859,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        dp=vector<vector<int>>(n+1);\\n        for(auto it:edges)\\n        {\\n            dp[it[0]].push_back(it[1]);\\n            dp[it[1]].push_back(it[0]);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>dis(n,-1);\\n            queue<pair<int,int>>q;\\n            q.push({i,-1});\\n            dis[i]=0;\\n            while(q.size())\\n            {\\n                auto [node,parent]=q.front();\\n                q.pop();\\n                for(auto it:dp[node])\\n                {\\n                    if(dis[it]==-1)\\n                    {\\n                        dis[it]=dis[node]+1;\\n                        q.push({it,node});\\n                    }\\n                    else if(it!=parent)\\n                    {\\n                        ans=min(ans,dis[node]+dis[it]+1);\\n                    }\\n                }\\n            }\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        dp=vector<vector<int>>(n+1);\\n        for(auto it:edges)\\n        {\\n            dp[it[0]].push_back(it[1]);\\n            dp[it[1]].push_back(it[0]);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>dis(n,-1);\\n            queue<pair<int,int>>q;\\n            q.push({i,-1});\\n            dis[i]=0;\\n            while(q.size())\\n            {\\n                auto [node,parent]=q.front();\\n                q.pop();\\n                for(auto it:dp[node])\\n                {\\n                    if(dis[it]==-1)\\n                    {\\n                        dis[it]=dis[node]+1;\\n                        q.push({it,node});\\n                    }\\n                    else if(it!=parent)\\n                    {\\n                        ans=min(ans,dis[node]+dis[it]+1);\\n                    }\\n                }\\n            }\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366746,
                "title": "simple-bfs-blindly-enumberate",
                "content": "# Intuition\\nFor each edge (x, y), just calcualte the shortest path from x to y WITHOUT this edge via BFS. And if there is a path of length m, we have a cycle of length (m + 1).\\n\\n# Approach\\nDo BFS from x to y by removing each edge (x, y). When donging BFS, we can ignore cycles so the BFS is only on a tree (of a forgest).\\n\\n# Complexity\\n- Time complexity:\\nO(n * e) where n is the number of nodes and e is the number of edges.\\n\\n- Space complexity:\\nO(n + e ) where n is the number of nodes and e is the number of edges.\\n\\n# Code\\n```\\nclass Solution {\\n    void bfs(const vector<vector<int>> &con, const vector<int> &e, int &r) {\\n        queue<int> q;\\n        const int n = con.size();\\n        vector<int> d(n, -1);\\n        d[e[0]] = 0;\\n        for (q.push(e[0]); !q.empty();) {\\n            const int x = q.front();\\n            q.pop();\\n            const int t = d[x] + 1;\\n            if (r >= 0 && t >= r) {\\n                return;\\n            }\\n            for (int y : con[x]) {\\n                if ((x == e[0] && y == e[1]) || (x == e[1] && y == e[0]) || (d[y] >= 0)) {\\n                    continue;\\n                }\\n                if (y == e[1]) {\\n                    r = t;\\n                    return;\\n                }\\n                d[y] = t;\\n                q.push(y);\\n            }\\n        }\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> con(n);\\n        for (const auto & e : edges) {\\n            con[e[0]].push_back(e[1]);\\n            con[e[1]].push_back(e[0]);\\n        }\\n        int r = -2;\\n        for (const auto & e : edges) {\\n            bfs(con, e, r);\\n        }\\n        return r + 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void bfs(const vector<vector<int>> &con, const vector<int> &e, int &r) {\\n        queue<int> q;\\n        const int n = con.size();\\n        vector<int> d(n, -1);\\n        d[e[0]] = 0;\\n        for (q.push(e[0]); !q.empty();) {\\n            const int x = q.front();\\n            q.pop();\\n            const int t = d[x] + 1;\\n            if (r >= 0 && t >= r) {\\n                return;\\n            }\\n            for (int y : con[x]) {\\n                if ((x == e[0] && y == e[1]) || (x == e[1] && y == e[0]) || (d[y] >= 0)) {\\n                    continue;\\n                }\\n                if (y == e[1]) {\\n                    r = t;\\n                    return;\\n                }\\n                d[y] = t;\\n                q.push(y);\\n            }\\n        }\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> con(n);\\n        for (const auto & e : edges) {\\n            con[e[0]].push_back(e[1]);\\n            con[e[1]].push_back(e[0]);\\n        }\\n        int r = -2;\\n        for (const auto & e : edges) {\\n            bfs(con, e, r);\\n        }\\n        return r + 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366828,
                "title": "c-very-fast-20ms-for-88-test-cases-dfs-with-greedy-strategy",
                "content": "**Motivation: every cycle vs. possible shorter cycle**\\nI don\\'t like the idea to do DFS for each node. Instead, we choose to do DFS on each connected subgraph. Of course, due to the order of visiting, normal DFS will fail to detected certain cycles.\\n\\nHere, we use **DFS with a greedy strategy**. For each connected graph, we choose arbitrarily the root. We keep track of the depth/distance to root based on ***paths explored so far***. \\n\\n**Algorithm**\\n1. All depths are intialized as INT_MAX.\\n2. Beging with the root we choose arbitrarily (e.g. node with the smallest index). We do DFS.\\n\\t2.1 The depth is updated w.r.t. paths explored\\n\\t2.2 In case the depth of current node is ***d***, we check all neighbors except the direct parent in the currently explored path\\n\\t2.2.1 if the depth of a neighbor is ***less than d***, this is an ascent and ***cycle detected***.\\n\\t2.2.2 if the depth of a neighbor is ***greater than d+1***,  we know that the routering from root to this neighbor is changed. As a result, it is possible to have a shorter cycle. \\n\\t2.2.3 otherwise, stop DFS and return.\\n\\n**Complexity**\\nTime: O(V^2/2) (TBD.)\\nSpace: O(V+E)\\n\\n**Performance**\\n```\\nRuntime: 19 ms, faster than 100.00% of C++ online submissions for Shortest Cycle in a Graph.\\nMemory Usage: 12.9 MB, less than 100.00% of C++ online submissions for Shortest Cycle in a Graph.\\n```\\n\\n**Code**\\n```\\nint ans;\\nint dep[1000];\\nvector<vector<int>> conn;\\nclass Solution {\\npublic:\\n    void dfs(int cur, int par, int d) {\\n        dep[cur]=d;\\n        for(auto sub : conn[cur]) {\\n            if(sub!=par) {\\n                if(dep[sub]>d+1) {\\n\\t\\t\\t\\t\\t// explore another path and it is possible to find a shorter cycle\\n                    dfs(sub, cur, d+1);\\n                } else if(dep[sub]<d){\\n\\t\\t\\t\\t\\t// cycle detected\\n                    ans=min(ans, d-dep[sub]+1);\\n                }\\n            }\\n        }\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        ans=INT_MAX;\\n        conn.clear();\\n        conn.resize(n);\\n        for(int i=0; i<n; dep[i++]=INT_MAX) {}\\n        for(int i=0, m=edges.size(); i<m; ++i) {\\n            conn[edges[i][0]].push_back(edges[i][1]);\\n            conn[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0, j; i<n; ++i) {\\n            if(dep[i]==INT_MAX) // DFS on each connected sub-graph\\n                dfs(i, -1, 0);\\n        }\\n        return ans==INT_MAX? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Depth-First Search"
                ],
                "code": "```\\nRuntime: 19 ms, faster than 100.00% of C++ online submissions for Shortest Cycle in a Graph.\\nMemory Usage: 12.9 MB, less than 100.00% of C++ online submissions for Shortest Cycle in a Graph.\\n```\n```\\nint ans;\\nint dep[1000];\\nvector<vector<int>> conn;\\nclass Solution {\\npublic:\\n    void dfs(int cur, int par, int d) {\\n        dep[cur]=d;\\n        for(auto sub : conn[cur]) {\\n            if(sub!=par) {\\n                if(dep[sub]>d+1) {\\n\\t\\t\\t\\t\\t// explore another path and it is possible to find a shorter cycle\\n                    dfs(sub, cur, d+1);\\n                } else if(dep[sub]<d){\\n\\t\\t\\t\\t\\t// cycle detected\\n                    ans=min(ans, d-dep[sub]+1);\\n                }\\n            }\\n        }\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        ans=INT_MAX;\\n        conn.clear();\\n        conn.resize(n);\\n        for(int i=0; i<n; dep[i++]=INT_MAX) {}\\n        for(int i=0, m=edges.size(); i<m; ++i) {\\n            conn[edges[i][0]].push_back(edges[i][1]);\\n            conn[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0, j; i<n; ++i) {\\n            if(dep[i]==INT_MAX) // DFS on each connected sub-graph\\n                dfs(i, -1, 0);\\n        }\\n        return ans==INT_MAX? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366643,
                "title": "dfs-o-n-3-c",
                "content": "# Intuition\\nThink about how you would detect a cycle. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse the visited array to record the depth.\\nDo BFS for all nodes because there might be a case where the depth changes according to which node you visit first.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        //show in which order the edges are visited\\n        int ans=INT_MAX;\\n        vector<vector<int>> adj(n);\\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        queue<int> q;\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int> visited(n,INT_MAX);\\n            vector<int> parent(n, -1);\\n            visited[i]=0;\\n            q.push(i);\\n            while(!q.empty()){\\n                int src=q.front();q.pop();\\n                for(auto nbr:adj[src]){\\n                    if(visited[nbr]==INT_MAX){\\n                        visited[nbr]=visited[src]+1;\\n                        parent[nbr]=src;\\n                        q.push(nbr);\\n                    }\\n                    else{\\n                        if(parent[src]==nbr ||parent[nbr]==src) continue;\\n                        ans=min(ans, abs(visited[src]+visited[nbr])+1);\\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        //show in which order the edges are visited\\n        int ans=INT_MAX;\\n        vector<vector<int>> adj(n);\\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        queue<int> q;\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int> visited(n,INT_MAX);\\n            vector<int> parent(n, -1);\\n            visited[i]=0;\\n            q.push(i);\\n            while(!q.empty()){\\n                int src=q.front();q.pop();\\n                for(auto nbr:adj[src]){\\n                    if(visited[nbr]==INT_MAX){\\n                        visited[nbr]=visited[src]+1;\\n                        parent[nbr]=src;\\n                        q.push(nbr);\\n                    }\\n                    else{\\n                        if(parent[src]==nbr ||parent[nbr]==src) continue;\\n                        ans=min(ans, abs(visited[src]+visited[nbr])+1);\\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366510,
                "title": "easy-best-solution-in-c-bfs",
                "content": "\\n# Code\\n### PLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution\\n{\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>> &edges)\\n    {\\n        vector<vector<int>> adj(n);\\n        for (auto it : edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans = INT_MAX;\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector<int> distance(n,INT_MAX);\\n            vector<int> par(n,-1);\\n            distance[i] = 0;\\n            queue<int> que;\\n            que.push(i);\\n            while (que.size())\\n            {\\n                int v = que.front();\\n                que.pop();\\n                for (auto it : adj[v])\\n                {\\n                    if (distance[it] == INT_MAX)\\n                    {\\n                        distance[it] = 1 + distance[v];\\n                        par[it] = v;\\n                        que.push(it);\\n                    }\\n                    else if(par[v] != it)\\n                        ans = min(ans, distance[v] + distance[it] + 1);\\n                }\\n            }\\n        }\\n        if (ans == INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/5e0a590f-40f3-447f-8f8e-5dc9535fccb6_1680365526.6758757.png)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>> &edges)\\n    {\\n        vector<vector<int>> adj(n);\\n        for (auto it : edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans = INT_MAX;\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector<int> distance(n,INT_MAX);\\n            vector<int> par(n,-1);\\n            distance[i] = 0;\\n            queue<int> que;\\n            que.push(i);\\n            while (que.size())\\n            {\\n                int v = que.front();\\n                que.pop();\\n                for (auto it : adj[v])\\n                {\\n                    if (distance[it] == INT_MAX)\\n                    {\\n                        distance[it] = 1 + distance[v];\\n                        par[it] = v;\\n                        que.push(it);\\n                    }\\n                    else if(par[v] != it)\\n                        ans = min(ans, distance[v] + distance[it] + 1);\\n                }\\n            }\\n        }\\n        if (ans == INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367128,
                "title": "python3-bfs-from-all-nodes",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/1dc118daa80cfe1161dcee412e7c3536970ca60d) for solutions of biweely 101. \\n\\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u].append(v)\\n            graph[v].append(u)\\n        ans = inf \\n        for u in range(n): \\n            dist = {}\\n            queue = deque([(u, -1, 0)])\\n            while queue: \\n                u, p, d = queue.popleft()\\n                if u in dist: \\n                    ans = min(ans, d + dist[u])\\n                    break \\n                dist[u] = d \\n                for v in graph[u]: \\n                    if v != p: queue.append((v, u, d+1))\\n        return ans if ans < inf else -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u].append(v)\\n            graph[v].append(u)\\n        ans = inf \\n        for u in range(n): \\n            dist = {}\\n            queue = deque([(u, -1, 0)])\\n            while queue: \\n                u, p, d = queue.popleft()\\n                if u in dist: \\n                    ans = min(ans, d + dist[u])\\n                    break \\n                dist[u] = d \\n                for v in graph[u]: \\n                    if v != p: queue.append((v, u, d+1))\\n        return ans if ans < inf else -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366865,
                "title": "day-366-python-c-java-explained-algorithm-100-beats",
                "content": "# Please Upvote as it really motivates me\\n##### \\u2022\\tThe problem statement is to find the length of the shortest cycle in an und graph. The approach used in this problem is to perform a breadth-first search (BFS) from each node in the graph and keep track of the distance from the starting node to each visited node. If a visited node is encountered again during the BFS, then a cycle has been found. The length of the cycle is the sum of the distances from the starting node to the two nodes that form the cycle, plus one.\\n\\n##### \\u2022\\tHere is the step-by-step algorithm:\\n\\n##### \\u2022\\tCreate an adjacency list to represent the graph.\\n##### \\u2022\\tFor each node in the graph, perform a BFS starting from that node.\\n##### \\u2022\\tDuring the BFS, keep track of the distance from the starting node to each visited node.\\n##### \\u2022\\tIf a visited node is encountered again during the BFS, then a cycle has been found.\\n##### \\u2022\\tCalculate the length of the cycle as the sum of the distances from the starting node to the two nodes that form the cycle, plus one.\\n##### \\u2022\\tKeep track of the minimum cycle length found so far.\\n##### \\u2022\\tReturn the minimum cycle length.\\n##### \\u2022\\tThe intuition behind this approach is that by performing a BFS from each node in the graph, we can find all cycles in the graph. By keeping track of the distance from the starting node to each visited node, we can calculate the length of each cycle that is found. By keeping track of the minimum cycle length found so far, we can return the length of the shortest cycle in the graph.\\n\\n\\n\\n# Code\\n```python []\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n\\n        minCycle = float(\\'inf\\')\\n        for i in range(n):\\n            dist = [-1] * n\\n            q = deque()\\n            q.append(i)\\n            dist[i] = 0\\n            while q:\\n                u = q.popleft()\\n                for v in adj[u]:\\n                    if dist[v] == -1:\\n                        dist[v] = dist[u] + 1\\n                        q.append(v)\\n                    elif v != i and dist[v] >= dist[u]:\\n                        minCycle = min(minCycle, dist[u] + dist[v] + 1)\\n\\n        return -1 if minCycle == float(\\'inf\\') else minCycle\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for (auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        int minCycle = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            vector<int> dist(n, -1);\\n            queue<int> q;\\n            q.push(i);\\n            dist[i] = 0;\\n            while (!q.empty()) {\\n                int u = q.front();\\n                q.pop();\\n                for (int v : adj[u]) {\\n                    if (dist[v] == -1) {\\n                        dist[v] = dist[u] + 1;\\n                        q.push(v);\\n                    } else if (v != i && dist[v] >= dist[u]) {\\n                        minCycle = min(minCycle, dist[u] + dist[v] + 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return minCycle == INT_MAX ? -1 : minCycle;\\n    }\\n};\\n```\\n```java []\\nclass Solution  {\\n      public int findShortestCycle(int n, int[][] edges) {\\n        List<Integer>[] adj = new List[n];\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].add(v);\\n            adj[v].add(u);\\n        }\\n\\n        int minCycle = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int[] dist = new int[n];\\n            Arrays.fill(dist, -1);\\n            Queue<Integer> queue = new LinkedList<>();\\n            queue.offer(i);\\n            dist[i] = 0;\\n            while (!queue.isEmpty()) {\\n                int u = queue.poll();\\n                for (int v : adj[u]) {\\n                    if (dist[v] == -1) {\\n                        dist[v] = dist[u] + 1;\\n                        queue.offer(v);\\n                    } else if (v != i && dist[v] >= dist[u]) {\\n                        minCycle = Math.min(minCycle, dist[u] + dist[v] + 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return minCycle == Integer.MAX_VALUE ? -1 : minCycle;\\n    }\\n}\\n```\\n\\n\\n\\n# Complexity\\n\\n##### \\u2022\\tThe time complexity (TC) of this algorithm is O(n+2E), n is the number of nodes in the graph. This is because the algorithm performs a BFS starting from each node in the graph, and each BFS can visit up to n nodes. Therefore, the total number of nodes visited is O(n+2E).\\n##### \\u2022\\tThe space complexity (SC) of this algorithm is O(n+2E), where n is the number of nodes in the graph. This is because the algorithm creates an adjacency list to represent the graph, which can have up to n+2E edges in the worst case. Additionally, the algorithm uses a queue to perform the BFS, which can have up to n nodes in the worst case. Finally, the algorithm uses an array to keep track of the distance from the starting node to each visited node, which can have up to n elements in the worst case. Therefore, the total space complexity is O(n+2E).\\n\\n##### \\u2022\\tPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n##### \\u2022\\tThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\n##### \\u2022\\tPlease give my solution an upvote! \\uD83D\\uDC4D\\n##### \\u2022\\tIt\\'s a simple way to show your appreciation and\\n##### \\u2022\\tkeep me motivated. Thank you! \\uD83D\\uDE0A\\n\\n\\n\\nhttps://leetcode.com/problems/shortest-cycle-in-a-graph/solutions/3366865/day-366-python-c-java-explained-algorithm-100-beats/?orderBy=hot",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n\\n        minCycle = float(\\'inf\\')\\n        for i in range(n):\\n            dist = [-1] * n\\n            q = deque()\\n            q.append(i)\\n            dist[i] = 0\\n            while q:\\n                u = q.popleft()\\n                for v in adj[u]:\\n                    if dist[v] == -1:\\n                        dist[v] = dist[u] + 1\\n                        q.append(v)\\n                    elif v != i and dist[v] >= dist[u]:\\n                        minCycle = min(minCycle, dist[u] + dist[v] + 1)\\n\\n        return -1 if minCycle == float(\\'inf\\') else minCycle\\n```\n```c++ []\\nclass Solution {\\npublic:\\n int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for (auto& edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        int minCycle = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            vector<int> dist(n, -1);\\n            queue<int> q;\\n            q.push(i);\\n            dist[i] = 0;\\n            while (!q.empty()) {\\n                int u = q.front();\\n                q.pop();\\n                for (int v : adj[u]) {\\n                    if (dist[v] == -1) {\\n                        dist[v] = dist[u] + 1;\\n                        q.push(v);\\n                    } else if (v != i && dist[v] >= dist[u]) {\\n                        minCycle = min(minCycle, dist[u] + dist[v] + 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return minCycle == INT_MAX ? -1 : minCycle;\\n    }\\n};\\n```\n```java []\\nclass Solution  {\\n      public int findShortestCycle(int n, int[][] edges) {\\n        List<Integer>[] adj = new List[n];\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].add(v);\\n            adj[v].add(u);\\n        }\\n\\n        int minCycle = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int[] dist = new int[n];\\n            Arrays.fill(dist, -1);\\n            Queue<Integer> queue = new LinkedList<>();\\n            queue.offer(i);\\n            dist[i] = 0;\\n            while (!queue.isEmpty()) {\\n                int u = queue.poll();\\n                for (int v : adj[u]) {\\n                    if (dist[v] == -1) {\\n                        dist[v] = dist[u] + 1;\\n                        queue.offer(v);\\n                    } else if (v != i && dist[v] >= dist[u]) {\\n                        minCycle = Math.min(minCycle, dist[u] + dist[v] + 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return minCycle == Integer.MAX_VALUE ? -1 : minCycle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366463,
                "title": "bfs-detailed-code-o-n-n-single-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector <int> graph[n+1];\\n        for(auto edge : edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        int min_cycle_length = INT_MAX;\\n        for(int root = 0; root < n; root++)\\n        {\\n            vector <int> vis(n+1,0);\\n            vector <int> dist(n+1,0);\\n            queue <pair<pair<int,int>,int>> q;\\n            vis[root]=1;\\n            q.push({{root,-1},0});\\n            int flag = 0;\\n            while(!q.empty())\\n            {\\n                int node = q.front().first.first;\\n                int parent = q.front().first.second;\\n                int length = q.front().second;\\n                q.pop();\\n                for(auto child : graph[node])\\n                {\\n                    if(child!=parent)\\n                    {\\n                        if(vis[child]==1)\\n                        {\\n                            int curr_length = dist[child]+dist[node]+1;\\n                            min_cycle_length=min(min_cycle_length,curr_length);\\n                            flag=1;\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            vis[child]=1;\\n                            dist[child]=length+1;\\n                            q.push({{child,node},length+1});\\n                        }\\n                    }\\n                }\\n                if(flag)\\n                    break;\\n            }\\n        }\\n        if(min_cycle_length==INT_MAX)\\n            return -1;\\n        return min_cycle_length;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector <int> graph[n+1];\\n        for(auto edge : edges)\\n        {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        int min_cycle_length = INT_MAX;\\n        for(int root = 0; root < n; root++)\\n        {\\n            vector <int> vis(n+1,0);\\n            vector <int> dist(n+1,0);\\n            queue <pair<pair<int,int>,int>> q;\\n            vis[root]=1;\\n            q.push({{root,-1},0});\\n            int flag = 0;\\n            while(!q.empty())\\n            {\\n                int node = q.front().first.first;\\n                int parent = q.front().first.second;\\n                int length = q.front().second;\\n                q.pop();\\n                for(auto child : graph[node])\\n                {\\n                    if(child!=parent)\\n                    {\\n                        if(vis[child]==1)\\n                        {\\n                            int curr_length = dist[child]+dist[node]+1;\\n                            min_cycle_length=min(min_cycle_length,curr_length);\\n                            flag=1;\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            vis[child]=1;\\n                            dist[child]=length+1;\\n                            q.push({{child,node},length+1});\\n                        }\\n                    }\\n                }\\n                if(flag)\\n                    break;\\n            }\\n        }\\n        if(min_cycle_length==INT_MAX)\\n            return -1;\\n        return min_cycle_length;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366628,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int help(int n,vector<int> adj[]){\\n        int ans = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            vector<int> dist(n,(1e9));\\n            vector<int> par(n, -1);\\n            dist[i] = 0;\\n            queue<int> q;\\n            q.push(i);\\n            while (!q.empty()) {\\n                int x = q.front();\\n                q.pop();\\n                for (int c : adj[x]) {\\n                    if (dist[c] == (int)(1e9)) {\\n                        dist[c] = 1 + dist[x];\\n                        par[c] = x;\\n                        q.push(c);\\n                }\\n                else if (par[x] != c && par[c] != x)\\n                    ans = min(ans, dist[x] + dist[c] + 1);\\n                }\\n            }\\n        }\\n        if (ans == INT_MAX)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto i : edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        return help(n,adj);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int help(int n,vector<int> adj[]){\\n        int ans = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            vector<int> dist(n,(1e9));\\n            vector<int> par(n, -1);\\n            dist[i] = 0;\\n            queue<int> q;\\n            q.push(i);\\n            while (!q.empty()) {\\n                int x = q.front();\\n                q.pop();\\n                for (int c : adj[x]) {\\n                    if (dist[c] == (int)(1e9)) {\\n                        dist[c] = 1 + dist[x];\\n                        par[c] = x;\\n                        q.push(c);\\n                }\\n                else if (par[x] != c && par[c] != x)\\n                    ans = min(ans, dist[x] + dist[c] + 1);\\n                }\\n            }\\n        }\\n        if (ans == INT_MAX)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto i : edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        return help(n,adj);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892330,
                "title": "easiest-solution-c-without-using-parent-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint ans=INT_MAX;\\nvoid cycle(int node,vector<int>adj[],int n,vector<bool>&vis,vector<int>&dis){\\n    queue<pair<int,int>>q;\\n    q.push({node,-1});\\n    vis[node]=true;\\n    dis[node]=0;\\n    while(!q.empty()){\\n        int node=q.front().first;\\n        int parent=q.front().second;\\n        q.pop();\\n        for(auto it:adj[node]){\\n            if(dis[it]==1e9){\\n                 dis[it]=1+dis[node];\\n                q.push({it,node});\\n            }\\n            else if(parent!=it){\\n                 ans=min(ans,dis[it]+dis[node]+1);\\n                \\n            }\\n        }\\n    }\\n    // return false;\\n\\n}\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n+1];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        bool flag=false;\\n        for(int i=0;i<n;i++){\\n            vector<int>dis(n+1,1e9);\\n            vector<bool>vis(n+1,false);\\n            cycle(i,adj,n,vis,dis);\\n            \\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans=INT_MAX;\\nvoid cycle(int node,vector<int>adj[],int n,vector<bool>&vis,vector<int>&dis){\\n    queue<pair<int,int>>q;\\n    q.push({node,-1});\\n    vis[node]=true;\\n    dis[node]=0;\\n    while(!q.empty()){\\n        int node=q.front().first;\\n        int parent=q.front().second;\\n        q.pop();\\n        for(auto it:adj[node]){\\n            if(dis[it]==1e9){\\n                 dis[it]=1+dis[node];\\n                q.push({it,node});\\n            }\\n            else if(parent!=it){\\n                 ans=min(ans,dis[it]+dis[node]+1);\\n                \\n            }\\n        }\\n    }\\n    // return false;\\n\\n}\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n+1];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        bool flag=false;\\n        for(int i=0;i<n;i++){\\n            vector<int>dis(n+1,1e9);\\n            vector<bool>vis(n+1,false);\\n            cycle(i,adj,n,vis,dis);\\n            \\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478880,
                "title": "c-approach-explained-bfs",
                "content": "perform a breadth-first search (BFS) from each vertex in the graph and check for the existence of a cycle during the BFS. To keep track of the distance of each vertex from the starting vertex and the parent of each vertex in the BFS tree, we can use two arrays dist and parent, respectively.\\n\\nFor each vertex i in the graph, we start a BFS from i and initialize dist[i] = 0 and parent[i] = -1. We also maintain a variable minCycle to store the length of the shortest cycle found so far.\\n\\nDuring the BFS, we iterate over the neighbors of the current vertex curr and check if each neighbor next has already been visited by checking dist[next]. If next has not been visited, we set dist[next] = dist[curr] + 1 and parent[next] = curr, and enqueue next into the BFS queue. If next has already been visited, we check if it is a parent of curr (i.e., parent[curr] == next) or if curr is a parent of next (i.e., parent[next] == curr). If neither of these conditions is true, we have found a cycle.\\n\\nTo compute the length of the cycle, we use the distances stored in dist and the parents stored in parent. Specifically, if next is the vertex that was previously visited and has a common ancestor with curr, we can compute the length of the cycle as 1 + dist[next] + dist[curr]. We add 1 to account for the edge connecting curr and next.\\n\\nFinally, we update minCycle with the minimum cycle length encountered so far. After performing the BFS from all vertices in the graph, we return minCycle if it is less than 1e9 (the initial value of minCycle), or -1 if no cycle was found.\\n\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, vector<int>> graph;\\n        \\n        for(const auto &edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        int minCycle = 1e9;\\n        for(int i = 0; i < n; ++i) {\\n            vector<int> dist(n, 1e9);\\n            vector<int> parent(n, -1);\\n            \\n            queue<int> q;\\n            q.push(i);\\n            dist[i] = 0;\\n\\n            while(!q.empty()) {\\n                int sz = q.size();\\n                \\n                while(sz--) {\\n                    int curr = q.front(); q.pop();\\n\\n                    for(int &next : graph[curr]) {                        \\n                        if(dist[next] == 1e9) {\\n                            dist[next] = dist[curr] + 1;\\n                            parent[next] = curr;\\n                            q.push(next);\\n                        }\\n                        else if(parent[next] != curr && parent[curr] != next) {\\n                            int cycle = 1 + dist[next] + dist[curr];\\n                            minCycle = min(minCycle, cycle);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return minCycle == 1e9 ? -1 : minCycle;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, vector<int>> graph;\\n        \\n        for(const auto &edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        int minCycle = 1e9;\\n        for(int i = 0; i < n; ++i) {\\n            vector<int> dist(n, 1e9);\\n            vector<int> parent(n, -1);\\n            \\n            queue<int> q;\\n            q.push(i);\\n            dist[i] = 0;\\n\\n            while(!q.empty()) {\\n                int sz = q.size();\\n                \\n                while(sz--) {\\n                    int curr = q.front(); q.pop();\\n\\n                    for(int &next : graph[curr]) {                        \\n                        if(dist[next] == 1e9) {\\n                            dist[next] = dist[curr] + 1;\\n                            parent[next] = curr;\\n                            q.push(next);\\n                        }\\n                        else if(parent[next] != curr && parent[curr] != next) {\\n                            int cycle = 1 + dist[next] + dist[curr];\\n                            minCycle = min(minCycle, cycle);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return minCycle == 1e9 ? -1 : minCycle;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380960,
                "title": "why-dfs-will-not-work-algorithmic-thinking",
                "content": "Many posts here claim DFS work correctly. I doubt that is true. Here what is more interesting is why DFS will not work. Here is my hypothesis:\\nSince the problem asks for shortest cycle. A distance function needs to defined over the nodes and used to drive the search. Unlike BFS, DFS computes non-optimal distance which needs \"relaxation\" to be driven down. In other word, anytime a smaller distance for node A is discovered, then it and all its children needs to have distance updated. This requires O(N^E) time complexity. This is why correctly implemented DFS will get TLE.\\nMany posted solutions here avoid the distance \"relaxation\" to beat TLE, but unfortunately, the algorithm correctness is lost and will fail on some test cases.",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "Many posts here claim DFS work correctly. I doubt that is true. Here what is more interesting is why DFS will not work. Here is my hypothesis:\\nSince the problem asks for shortest cycle. A distance function needs to defined over the nodes and used to drive the search. Unlike BFS, DFS computes non-optimal distance which needs \"relaxation\" to be driven down. In other word, anytime a smaller distance for node A is discovered, then it and all its children needs to have distance updated. This requires O(N^E) time complexity. This is why correctly implemented DFS will get TLE.\\nMany posted solutions here avoid the distance \"relaxation\" to beat TLE, but unfortunately, the algorithm correctness is lost and will fail on some test cases.",
                "codeTag": "Unknown"
            },
            {
                "id": 3398202,
                "title": "100-working-soln-bfs-approach-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApply BFS to find length of shortest cycle in graph\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V*(V+E)) where V is number of nodes and E is the edges\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(V) where V is number of nodes\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n    for (auto& edge : edges) {\\n        adj[edge[0]].push_back(edge[1]);\\n        adj[edge[1]].push_back(edge[0]);\\n    }\\n\\n    int ans = n+1;\\n    for (int i = 0; i < n; i++) {\\n        vector<int> dist(n, -1), parent(n, -1);\\n        queue<int> q;\\n        q.push(i);\\n        dist[i] = 0;\\n        while (!q.empty()) {\\n            int u = q.front(); q.pop();\\n            for (int v : adj[u]) {\\n                if (dist[v] == -1) {\\n                    dist[v] = dist[u] + 1;\\n                    parent[v] = u;\\n                    q.push(v);\\n                } else if (v != parent[u]) {\\n                    ans = min(ans, dist[u] + dist[v] + 1);\\n                }\\n            }\\n        }\\n    }\\n\\n    if (ans == n+1) ans = -1;\\n    return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n    for (auto& edge : edges) {\\n        adj[edge[0]].push_back(edge[1]);\\n        adj[edge[1]].push_back(edge[0]);\\n    }\\n\\n    int ans = n+1;\\n    for (int i = 0; i < n; i++) {\\n        vector<int> dist(n, -1), parent(n, -1);\\n        queue<int> q;\\n        q.push(i);\\n        dist[i] = 0;\\n        while (!q.empty()) {\\n            int u = q.front(); q.pop();\\n            for (int v : adj[u]) {\\n                if (dist[v] == -1) {\\n                    dist[v] = dist[u] + 1;\\n                    parent[v] = u;\\n                    q.push(v);\\n                } else if (v != parent[u]) {\\n                    ans = min(ans, dist[u] + dist[v] + 1);\\n                }\\n            }\\n        }\\n    }\\n\\n    if (ans == n+1) ans = -1;\\n    return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384401,
                "title": "c-code-that-passes-all-the-test-cases",
                "content": "\\n# Code\\n```\\nclass Solution{\\npublic:\\n  void createGraph (vector < vector < int >>&gr, vector < vector < int >>&edges)\\n  {\\n  for (auto e:edges)\\n      {\\n\\tgr[e[0]].push_back (e[1]);\\n\\tgr[e[1]].push_back (e[0]);\\n      }\\n  }\\n\\n  void bfs (vector < vector < int >>&gr, int start, vector < int >&dist,\\n\\t    vector < int >&par, int &ans)\\n  {\\n    queue < int >q;\\n    q.push (start);\\n    dist[start] = 0;\\n    while (!q.empty ())\\n      {\\n\\tint x = q.front ();\\n\\tq.pop ();\\n      for (int child:gr[x])\\n\\t  {\\n\\t    if (dist[child] == INT_MAX)\\n\\t      {\\n\\t\\tdist[child] = 1 + dist[x];\\n\\t\\tpar[child] = x;\\n\\t\\tq.push (child);\\n\\t      }\\n\\t    else if (par[x] != child and par[child] != x)\\n\\t      {\\n\\t\\tans = min (ans, dist[x] + dist[child] + 1);\\n\\t      }\\n\\t  }\\n      }\\n  }\\n\\n  int findShortestCycle (int n, vector < vector < int >>&edges)\\n  {\\n    vector < vector < int >>gr (n);\\n    createGraph (gr, edges);\\n    int ans = INT_MAX;\\n    for (int i = 0; i < n; i++)\\n      {\\n\\tvector < int >dist (n, INT_MAX);\\n\\tvector < int >par (n, -1);\\n\\tbfs (gr, i, dist, par, ans);\\n      }\\n    if (ans == INT_MAX)\\n      {\\n\\treturn -1;\\n      }\\n    else\\n      {\\n\\treturn ans;\\n      }\\n  }\\n};\\n\\n\\n```\\n\\nPlease upvote if you like.",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n  void createGraph (vector < vector < int >>&gr, vector < vector < int >>&edges)\\n  {\\n  for (auto e:edges)\\n      {\\n\\tgr[e[0]].push_back (e[1]);\\n\\tgr[e[1]].push_back (e[0]);\\n      }\\n  }\\n\\n  void bfs (vector < vector < int >>&gr, int start, vector < int >&dist,\\n\\t    vector < int >&par, int &ans)\\n  {\\n    queue < int >q;\\n    q.push (start);\\n    dist[start] = 0;\\n    while (!q.empty ())\\n      {\\n\\tint x = q.front ();\\n\\tq.pop ();\\n      for (int child:gr[x])\\n\\t  {\\n\\t    if (dist[child] == INT_MAX)\\n\\t      {\\n\\t\\tdist[child] = 1 + dist[x];\\n\\t\\tpar[child] = x;\\n\\t\\tq.push (child);\\n\\t      }\\n\\t    else if (par[x] != child and par[child] != x)\\n\\t      {\\n\\t\\tans = min (ans, dist[x] + dist[child] + 1);\\n\\t      }\\n\\t  }\\n      }\\n  }\\n\\n  int findShortestCycle (int n, vector < vector < int >>&edges)\\n  {\\n    vector < vector < int >>gr (n);\\n    createGraph (gr, edges);\\n    int ans = INT_MAX;\\n    for (int i = 0; i < n; i++)\\n      {\\n\\tvector < int >dist (n, INT_MAX);\\n\\tvector < int >par (n, -1);\\n\\tbfs (gr, i, dist, par, ans);\\n      }\\n    if (ans == INT_MAX)\\n      {\\n\\treturn -1;\\n      }\\n    else\\n      {\\n\\treturn ans;\\n      }\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369818,
                "title": "java-python-dfs-runtime-48ms",
                "content": "1. Idea is to start traverse from each unvisited node and try to find shortest length cycle.\\n2. Here we are using map to store Map<Node,[distance,status]> , status means whether this node is part of current dfs call or not.\\n2. If we have cycle like this\\n![image](https://assets.leetcode.com/users/images/89722531-69c2-4940-94f7-e98abd9a509c_1680424724.612327.png)\\nand we start from node 1 , then it will evaluate cycle of length 4 --> 1,2,3,4,1 and of length 5 --> 1,2,3,4,5,1 , and it returns back to 1 and will go to node 4 for next iteration , here we will go to node-4 only if it is not in map which means it is not previously visited, or visited but has larger distance than current Distance + 1 , or it is forming cycle at node 4. this condition in code represent above line ` if it != par and (it not in hmap or hmap[it][0] > dist + 1 or hmap[it][1] == 1):`\\n\\n**Java**\\n```\\nclass Solution {\\n    private void dfs(int curr, int par, int dist, List<List<Integer>> graph, Map<Integer, int[]> hmap, Set<Integer> vis, int[] ans) {\\n        if (hmap.containsKey(curr) && hmap.get(curr)[1] == 1) {   //checking for cycle and updating answer\\n            ans[0] = Math.min(ans[0], dist - hmap.get(curr)[0]);\\n            return;\\n        }\\n        vis.add(curr);\\n        hmap.put(curr, new int[]{dist, 1}); // marking status as 1 , means this node is part of current dfs call\\n        for (int it : graph.get(curr)) {\\n            if (it != par && (!hmap.containsKey(it) || hmap.get(it)[0] > dist + 1 || hmap.get(it)[1] == 1)) {  //checking whether it is good to visit adjacent node to avoid TLE. \\n                dfs(it, curr, dist + 1, graph, hmap, vis, ans);\\n            }\\n        }\\n        hmap.put(curr, new int[]{dist, 0}); //marking status as 0 , means dfs call is completed for this node\\n    }\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        int[] ans = new int[]{Integer.MAX_VALUE};\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        Map<Integer, int[]> hmap = new HashMap<>();\\n        Set<Integer> vis = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            if (!vis.contains(i)) {\\n                dfs(i, -1, 0, graph, hmap, vis, ans);\\n            }\\n        }\\n        return ans[0] == Integer.MAX_VALUE ? -1 : ans[0];\\n    }\\n}\\n```\\n\\n**Python3**\\n\\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = [[] for i in range(n)]\\n        ans = math.inf\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        def dfs(curr,par,dist):\\n            nonlocal ans\\n            if curr in hmap and hmap[curr][1] == 1:  # checking for cycle and updating answer\\n                ans = min(ans,dist - hmap[curr][0])\\n                return\\n            vis.add(curr)\\n            hmap[curr] = [dist,1] # marking status as 1 , means this node is part of current dfs call\\n            for it in graph[curr]:\\n                if it != par and (it not in hmap or hmap[it][0] > dist + 1 or hmap[it][1] == 1): # checking whether it is good to visit adjacent node to avoid TLE. \\n                    dfs(it,curr,dist+1)\\n            hmap[curr] = [dist,0] # marking status as 0 , means dfs call is completed for this node\\n            return\\n        vis = set()\\n        for i in range(n):\\n            if i not in vis:\\n                hmap = defaultdict(list)\\n                dfs(i,-1,0)  \\n        if ans == math.inf:\\n            return -1\\n        else:\\n            return ans\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private void dfs(int curr, int par, int dist, List<List<Integer>> graph, Map<Integer, int[]> hmap, Set<Integer> vis, int[] ans) {\\n        if (hmap.containsKey(curr) && hmap.get(curr)[1] == 1) {   //checking for cycle and updating answer\\n            ans[0] = Math.min(ans[0], dist - hmap.get(curr)[0]);\\n            return;\\n        }\\n        vis.add(curr);\\n        hmap.put(curr, new int[]{dist, 1}); // marking status as 1 , means this node is part of current dfs call\\n        for (int it : graph.get(curr)) {\\n            if (it != par && (!hmap.containsKey(it) || hmap.get(it)[0] > dist + 1 || hmap.get(it)[1] == 1)) {  //checking whether it is good to visit adjacent node to avoid TLE. \\n                dfs(it, curr, dist + 1, graph, hmap, vis, ans);\\n            }\\n        }\\n        hmap.put(curr, new int[]{dist, 0}); //marking status as 0 , means dfs call is completed for this node\\n    }\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        int[] ans = new int[]{Integer.MAX_VALUE};\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        Map<Integer, int[]> hmap = new HashMap<>();\\n        Set<Integer> vis = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            if (!vis.contains(i)) {\\n                dfs(i, -1, 0, graph, hmap, vis, ans);\\n            }\\n        }\\n        return ans[0] == Integer.MAX_VALUE ? -1 : ans[0];\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = [[] for i in range(n)]\\n        ans = math.inf\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        def dfs(curr,par,dist):\\n            nonlocal ans\\n            if curr in hmap and hmap[curr][1] == 1:  # checking for cycle and updating answer\\n                ans = min(ans,dist - hmap[curr][0])\\n                return\\n            vis.add(curr)\\n            hmap[curr] = [dist,1] # marking status as 1 , means this node is part of current dfs call\\n            for it in graph[curr]:\\n                if it != par and (it not in hmap or hmap[it][0] > dist + 1 or hmap[it][1] == 1): # checking whether it is good to visit adjacent node to avoid TLE. \\n                    dfs(it,curr,dist+1)\\n            hmap[curr] = [dist,0] # marking status as 0 , means dfs call is completed for this node\\n            return\\n        vis = set()\\n        for i in range(n):\\n            if i not in vis:\\n                hmap = defaultdict(list)\\n                dfs(i,-1,0)  \\n        if ans == math.inf:\\n            return -1\\n        else:\\n            return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367055,
                "title": "dfs-runtime-280-ms-beats-100-memory-12-9-mb-beats-100",
                "content": "\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    \\n    void dfs(int node,int par, vector<int>adj[], vector<int>&val, int d){\\n        val[node]=d;\\n        for(auto it:adj[node]){\\n            if(val[it]==0){\\n                dfs(it,node,adj,val,d+1);\\n            }\\n            else if(it!=par){\\n                ans=min(ans,abs(d-val[it])+1);\\n            }\\n        }\\n    }\\n    \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int>val(n,0);\\n        for(int i=0;i<n;i++){\\n            dfs(i,-1,adj,val,1);\\n            fill(val.begin(),val.end(),0);\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    \\n    void dfs(int node,int par, vector<int>adj[], vector<int>&val, int d){\\n        val[node]=d;\\n        for(auto it:adj[node]){\\n            if(val[it]==0){\\n                dfs(it,node,adj,val,d+1);\\n            }\\n            else if(it!=par){\\n                ans=min(ans,abs(d-val[it])+1);\\n            }\\n        }\\n    }\\n    \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int>val(n,0);\\n        for(int i=0;i<n;i++){\\n            dfs(i,-1,adj,val,1);\\n            fill(val.begin(),val.end(),0);\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366650,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    BFS\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> g[1005];\\n    int ans;\\n    void bfs(int n) {\\n        for(int s=0; s<n; s++) {\\n            vector<int> vis(n, 0), dis(n, 0), par(n, -1);\\n            dis[s] = 0;\\n            queue<int> q;\\n            q.push(s);\\n            while(!q.empty()) {\\n                int u = q.front();\\n                q.pop();\\n                for(auto v: g[u]) {\\n                    if(!vis[v]) {\\n                        vis[v] = 1;\\n                        dis[v] = dis[u] + 1;\\n                        par[v] = u;\\n                        q.push(v);\\n                    }\\n                    else if(par[u] != v and par[v] != u)\\n                        ans = min(ans, dis[u] + dis[v] + 1);\\n                }\\n            }\\n        }\\n        \\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        for(auto x: edges) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        ans = INT_MAX;\\n        bfs(n);\\n        if(ans == INT_MAX) return -1;\\n        else return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> g[1005];\\n    int ans;\\n    void bfs(int n) {\\n        for(int s=0; s<n; s++) {\\n            vector<int> vis(n, 0), dis(n, 0), par(n, -1);\\n            dis[s] = 0;\\n            queue<int> q;\\n            q.push(s);\\n            while(!q.empty()) {\\n                int u = q.front();\\n                q.pop();\\n                for(auto v: g[u]) {\\n                    if(!vis[v]) {\\n                        vis[v] = 1;\\n                        dis[v] = dis[u] + 1;\\n                        par[v] = u;\\n                        q.push(v);\\n                    }\\n                    else if(par[u] != v and par[v] != u)\\n                        ans = min(ans, dis[u] + dis[v] + 1);\\n                }\\n            }\\n        }\\n        \\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        for(auto x: edges) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        ans = INT_MAX;\\n        bfs(n);\\n        if(ans == INT_MAX) return -1;\\n        else return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366645,
                "title": "c-bfs",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First Created Adjacency list.\\n2. performed BFS to find All Cycles.\\n3. keeping track of size of each cycle and returning minimum one.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> x(n);\\n        for(int i=0;i<edges.size();i++) {\\n            x[edges[i][0]].push_back(edges[i][1]);\\n            x[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int ans=INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            vector<int> y(n, -1);\\n            queue<int> q;\\n            y[i] = 0;\\n            q.push(i);\\n            while (!q.empty()) {\\n                int u=q.front();\\n                q.pop();\\n                for (int v : x[u]) {\\n                    if (y[v] == -1) {\\n                        y[v] = y[u] + 1;\\n                        q.push(v);\\n                    }\\n                    else if (y[v]>=y[u]) ans=min(ans,y[v]+y[u]+1);\\n                }\\n            }\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> x(n);\\n        for(int i=0;i<edges.size();i++) {\\n            x[edges[i][0]].push_back(edges[i][1]);\\n            x[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int ans=INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            vector<int> y(n, -1);\\n            queue<int> q;\\n            y[i] = 0;\\n            q.push(i);\\n            while (!q.empty()) {\\n                int u=q.front();\\n                q.pop();\\n                for (int v : x[u]) {\\n                    if (y[v] == -1) {\\n                        y[v] = y[u] + 1;\\n                        q.push(v);\\n                    }\\n                    else if (y[v]>=y[u]) ans=min(ans,y[v]+y[u]+1);\\n                }\\n            }\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366572,
                "title": "c-dijkstra-algorithm-detailed-code-easy-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>> &edges)\\n    {\\n        vector<vector<int>> adj(n);\\n        for (auto it : edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans = INT_MAX;\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector<int> distance(n,INT_MAX);\\n            vector<int> par(n,-1);\\n            distance[i] = 0;\\n            queue<int> que;\\n            que.push(i);\\n            while (que.size())\\n            {\\n                int v = que.front();\\n                que.pop();\\n                for (auto it : adj[v])\\n                {\\n                    if (distance[it] == INT_MAX)\\n                    {\\n                        distance[it] = 1 + distance[v];\\n                        par[it] = v;\\n                        que.push(it);\\n                    }\\n                    else if(par[v] != it && par[it] != v)\\n                        ans = min(ans, distance[v] + distance[it] + 1);\\n                }\\n            }\\n        }\\n        if (ans == INT_MAX)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>> &edges)\\n    {\\n        vector<vector<int>> adj(n);\\n        for (auto it : edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans = INT_MAX;\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector<int> distance(n,INT_MAX);\\n            vector<int> par(n,-1);\\n            distance[i] = 0;\\n            queue<int> que;\\n            que.push(i);\\n            while (que.size())\\n            {\\n                int v = que.front();\\n                que.pop();\\n                for (auto it : adj[v])\\n                {\\n                    if (distance[it] == INT_MAX)\\n                    {\\n                        distance[it] = 1 + distance[v];\\n                        par[it] = v;\\n                        que.push(it);\\n                    }\\n                    else if(par[v] != it && par[it] != v)\\n                        ans = min(ans, distance[v] + distance[it] + 1);\\n                }\\n            }\\n        }\\n        if (ans == INT_MAX)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366459,
                "title": "binary-search",
                "content": "not a beautiful solution. just to add a different idea. \\n\\nonly 1000 edges. the longest length of a cycle is 1000. given a cycle length k,  randomly walk  k steps from each vertex to see if we can return to the origin.\\n\\ncode:\\nhttps://leetcode.com/submissions/detail/926046924/",
                "solutionTags": [
                    "Python"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3366402,
                "title": "python-3-not-correct-will-update-soon-topological-sort-bfs",
                "content": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        n = len(edges)\\n        g = defaultdict(list)\\n        indeg = Counter()\\n        inCycle = set(range(n))\\n        \\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            indeg[i] += 1\\n            indeg[j] += 1\\n        \\n        stack = [node for node in range(n) if indeg[node] <= 1]\\n        \\n        while stack:\\n            cur = stack.pop()\\n            inCycle.discard(cur)\\n            \\n            for nei in g[cur]:\\n                indeg[nei] -= 1\\n                if indeg[nei] == 1:\\n                    stack.append(nei)\\n                    \\n        \\n        def bfs(i):\\n            q = deque( [(i, 0, -1, {i})] )\\n            \\n            while q:\\n                cur, res, par, seen = q.popleft()\\n                \\n                for nei in g[cur]:\\n                    if nei in seen and nei != par:\\n                        return res + 1, seen\\n                    if nei not in seen:\\n                        q.append( (nei, res + 1, cur, seen | {nei}) )\\n        \\n        res = inf\\n        seen = set()\\n        \\n        for i in inCycle:\\n            if i not in seen:\\n                r, s = bfs(i)\\n                seen |= s\\n                res = min(res, r)\\n        \\n        return res if inCycle else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        n = len(edges)\\n        g = defaultdict(list)\\n        indeg = Counter()\\n        inCycle = set(range(n))\\n        \\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            indeg[i] += 1\\n            indeg[j] += 1\\n        \\n        stack = [node for node in range(n) if indeg[node] <= 1]\\n        \\n        while stack:\\n            cur = stack.pop()\\n            inCycle.discard(cur)\\n            \\n            for nei in g[cur]:\\n                indeg[nei] -= 1\\n                if indeg[nei] == 1:\\n                    stack.append(nei)\\n                    \\n        \\n        def bfs(i):\\n            q = deque( [(i, 0, -1, {i})] )\\n            \\n            while q:\\n                cur, res, par, seen = q.popleft()\\n                \\n                for nei in g[cur]:\\n                    if nei in seen and nei != par:\\n                        return res + 1, seen\\n                    if nei not in seen:\\n                        q.append( (nei, res + 1, cur, seen | {nei}) )\\n        \\n        res = inf\\n        seen = set()\\n        \\n        for i in inCycle:\\n            if i not in seen:\\n                r, s = bfs(i)\\n                seen |= s\\n                res = min(res, r)\\n        \\n        return res if inCycle else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366363,
                "title": "python-bfs-from-all-vertices-o-ve",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nfrom collections import deque\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        G = defaultdict(list)\\n        for v, w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        self.res = float(\\'inf\\')\\n        def bfs(v):\\n            level = defaultdict(int)\\n            visited = set()\\n            que = deque([(v,0)])\\n            while que:\\n                v, d = que.popleft()\\n                if v in visited: continue\\n                visited.add(v)\\n                level[v] = d\\n                parents = set()\\n                for w in G[v]:\\n                    if w in visited:\\n                        if level[w] == d-1:\\n                            parents.add(w)\\n                            if len(parents) == 2:\\n                                self.res = min(self.res, 2*d)\\n                                return\\n                        if level[w] == d:\\n                            self.res = min(self.res, 2*d + 1)\\n                    else:\\n                        que.append((w,d+1))\\n        for v in range(n):\\n            bfs(v)\\n        return self.res if self.res != float(\\'inf\\') else -1\\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom collections import deque\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        G = defaultdict(list)\\n        for v, w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        self.res = float(\\'inf\\')\\n        def bfs(v):\\n            level = defaultdict(int)\\n            visited = set()\\n            que = deque([(v,0)])\\n            while que:\\n                v, d = que.popleft()\\n                if v in visited: continue\\n                visited.add(v)\\n                level[v] = d\\n                parents = set()\\n                for w in G[v]:\\n                    if w in visited:\\n                        if level[w] == d-1:\\n                            parents.add(w)\\n                            if len(parents) == 2:\\n                                self.res = min(self.res, 2*d)\\n                                return\\n                        if level[w] == d:\\n                            self.res = min(self.res, 2*d + 1)\\n                    else:\\n                        que.append((w,d+1))\\n        for v in range(n):\\n            bfs(v)\\n        return self.res if self.res != float(\\'inf\\') else -1\\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719299,
                "title": "un-directed-cycle-size-detection-bfs-red",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) \\n    {\\n        unordered_map<int,unordered_set<int>> adj;\\n        for (auto& edge : edges) \\n        {\\n            adj[edge[0]].insert(edge[1]);\\n            adj[edge[1]].insert(edge[0]);\\n        }\\n    \\n        int ans = INT_MAX;\\n        for (int i = 0; i < n; i++) // going throught each and every node\\n        {\\n            vector<int> dist(n, -1), parent(n, -1);\\n            queue<int> BFS;\\n            BFS.push(i);\\n            dist[i] = 0;\\n            while (!BFS.empty()) \\n            {\\n                int u = BFS.front(); BFS.pop();\\n                for (int v : adj[u]) // visiting all the neighbour vertex\\n                {\\n                    if (dist[v] == -1) // if distance of that node from starting node is already recorded then :\\n                    {\\n                        dist[v] = dist[u] + 1;  //updating distance of this node from staring node\\n                        parent[v] = u;   // this prevent 2 node cycle \\n                        BFS.push(v); \\n                    } \\n                    else if (v != parent[u]) // if it is not its parent node \\n                    {\\n                        ans = min(ans, dist[u] + dist[v] + 1);  // then cycle length is (sum of distance of node U and V from stating node i) + 1(for that node i); \\n                    }\\n                }\\n            }\\n        }\\n    \\n        if (ans == INT_MAX) ans = -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) \\n    {\\n        unordered_map<int,unordered_set<int>> adj;\\n        for (auto& edge : edges) \\n        {\\n            adj[edge[0]].insert(edge[1]);\\n            adj[edge[1]].insert(edge[0]);\\n        }\\n    \\n        int ans = INT_MAX;\\n        for (int i = 0; i < n; i++) // going throught each and every node\\n        {\\n            vector<int> dist(n, -1), parent(n, -1);\\n            queue<int> BFS;\\n            BFS.push(i);\\n            dist[i] = 0;\\n            while (!BFS.empty()) \\n            {\\n                int u = BFS.front(); BFS.pop();\\n                for (int v : adj[u]) // visiting all the neighbour vertex\\n                {\\n                    if (dist[v] == -1) // if distance of that node from starting node is already recorded then :\\n                    {\\n                        dist[v] = dist[u] + 1;  //updating distance of this node from staring node\\n                        parent[v] = u;   // this prevent 2 node cycle \\n                        BFS.push(v); \\n                    } \\n                    else if (v != parent[u]) // if it is not its parent node \\n                    {\\n                        ans = min(ans, dist[u] + dist[v] + 1);  // then cycle length is (sum of distance of node U and V from stating node i) + 1(for that node i); \\n                    }\\n                }\\n            }\\n        }\\n    \\n        if (ans == INT_MAX) ans = -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638117,
                "title": "different-approach-c-simple-easy-to-understand",
                "content": "\\n# Approach\\nIdea is to delete an edge connecting a and b, and then find the minimum distance between a and b (without considering the deleted edge), this shortest path plus one is the size of the smallest loop having both nodes a and b. \\nRepeat the same for each edge and return the the size of minimum loop.\\n\\n# Complexity\\n- Time complexity: O(E^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)\\n    {\\n        queue<pair<int, int>> q;\\n        unordered_map<int, int> vis;\\n        q.push({a, 0});\\n        vis[a]=1;\\n        while(!q.empty())\\n        {\\n            int curr = q.front().first;\\n            int dis = q.front().second;\\n            q.pop();\\n            for(auto &x: mp[curr])\\n            {\\n                if(x.second==ind || vis[x.first]==1)\\n                    continue;\\n                if(x.first == b)\\n                    return dis+1;\\n                q.push({x.first, dis+1});\\n                vis[x.first]=1;\\n            }\\n        }\\n        return 10000;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, vector<pair<int, int>>> mp;\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            mp[edges[i][0]].push_back({edges[i][1], i});\\n            mp[edges[i][1]].push_back({edges[i][0], i});\\n        }\\n        int mn = 10000;\\n        for(int i=0; i<edges.size(); i++)\\n            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));\\n        if(mn>=10000)\\n            return -1;\\n        return mn+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)\\n    {\\n        queue<pair<int, int>> q;\\n        unordered_map<int, int> vis;\\n        q.push({a, 0});\\n        vis[a]=1;\\n        while(!q.empty())\\n        {\\n            int curr = q.front().first;\\n            int dis = q.front().second;\\n            q.pop();\\n            for(auto &x: mp[curr])\\n            {\\n                if(x.second==ind || vis[x.first]==1)\\n                    continue;\\n                if(x.first == b)\\n                    return dis+1;\\n                q.push({x.first, dis+1});\\n                vis[x.first]=1;\\n            }\\n        }\\n        return 10000;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, vector<pair<int, int>>> mp;\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            mp[edges[i][0]].push_back({edges[i][1], i});\\n            mp[edges[i][1]].push_back({edges[i][0], i});\\n        }\\n        int mn = 10000;\\n        for(int i=0; i<edges.size(); i++)\\n            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));\\n        if(mn>=10000)\\n            return -1;\\n        return mn+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399195,
                "title": "question-on-a-tricky-test-case",
                "content": "The overall idea is to apply bfs, and viewed a cycle as two different paths starting from start, and merge at a common node. \\n\\nFor this test case\\n[[0,3],[0,5],[3,4],[4,5],[1,9],[1,11],[9,10],[11,10],[2,6],[2,8],[6,7],[8,7],[0,1],[0,2],[1,2]]\\n\\nCan some one help explain why.. it forms a very special graph if you draw it. I think immediately after we found a cycle, we can return its length already, but it would fail. See code comment below. Thanks!\\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for i, j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n        \\n        def dfs(start):\\n            # return shortest cycle staring at start\\n            # store (cur, parent)\\n            dq = deque([(start, -1)])\\n            dist = [float(\\'inf\\')] * n\\n            dist[start] = 0\\n            cur_min = float(\\'inf\\')\\n            while dq:\\n                cur, par = dq.popleft()\\n                for nei in graph[cur]:\\n                    if dist[nei] == float(\\'inf\\'):\\n                        dist[nei] = dist[cur] + 1\\n                        dq.append((nei, cur))\\n                    elif nei != par:\\n                        cur_min = min(cur_min, dist[nei] + dist[cur] + 1)\\n                # if not comment out below 2 lines and return early, it will fail the list test case, why?? \\n                # I thought as long as it finds a cycle, it must be the shortest from this node due to bfs property?\\n                # if cur_min < float(\\'inf\\'):\\n                #     return cur_min\\n            return cur_min\\n        \\n        ans = min([dfs(i) for i in range(n)])\\n        return ans if ans < float(\\'inf\\') else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for i, j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n        \\n        def dfs(start):\\n            # return shortest cycle staring at start\\n            # store (cur, parent)\\n            dq = deque([(start, -1)])\\n            dist = [float(\\'inf\\')] * n\\n            dist[start] = 0\\n            cur_min = float(\\'inf\\')\\n            while dq:\\n                cur, par = dq.popleft()\\n                for nei in graph[cur]:\\n                    if dist[nei] == float(\\'inf\\'):\\n                        dist[nei] = dist[cur] + 1\\n                        dq.append((nei, cur))\\n                    elif nei != par:\\n                        cur_min = min(cur_min, dist[nei] + dist[cur] + 1)\\n                # if not comment out below 2 lines and return early, it will fail the list test case, why?? \\n                # I thought as long as it finds a cycle, it must be the shortest from this node due to bfs property?\\n                # if cur_min < float(\\'inf\\'):\\n                #     return cur_min\\n            return cur_min\\n        \\n        ans = min([dfs(i) for i in range(n)])\\n        return ans if ans < float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390956,
                "title": "bfs-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int bfs(int node, vector<int> adj[], vector<int>&vis,int n)\\n    {\\n        vis[node]=1;\\n        queue<pair<pair<int,int>,int>> q;\\n        q.push({{node,-1},0});\\n        vector<int> dist(n,0);\\n        // int curr = 1;\\n        int ans = INT_MAX;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            for(int i=0;i<sz;++i)\\n            {\\n                auto node = q.front().first.first;\\n                auto par = q.front().first.second;\\n                auto steps = q.front().second;\\n                q.pop();\\n                vis[node] =1;\\n                dist[node]=steps;\\n                for(auto &nodes:adj[node])\\n                {\\n                    if(vis[nodes] && par != nodes)\\n                        return dist[nodes]+steps+1;\\n                    if(!vis[nodes] && par != nodes)\\n                        q.push({{nodes,node},steps+1});\\n                }\\n            }\\n            // curr++;\\n        }\\n        return ans;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto &it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<n;++i)\\n        {\\n            vector<int> vis(n,0);\\n            res=min(res,bfs(i,adj,vis,n));\\n        }\\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(int node, vector<int> adj[], vector<int>&vis,int n)\\n    {\\n        vis[node]=1;\\n        queue<pair<pair<int,int>,int>> q;\\n        q.push({{node,-1},0});\\n        vector<int> dist(n,0);\\n        // int curr = 1;\\n        int ans = INT_MAX;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            for(int i=0;i<sz;++i)\\n            {\\n                auto node = q.front().first.first;\\n                auto par = q.front().first.second;\\n                auto steps = q.front().second;\\n                q.pop();\\n                vis[node] =1;\\n                dist[node]=steps;\\n                for(auto &nodes:adj[node])\\n                {\\n                    if(vis[nodes] && par != nodes)\\n                        return dist[nodes]+steps+1;\\n                    if(!vis[nodes] && par != nodes)\\n                        q.push({{nodes,node},steps+1});\\n                }\\n            }\\n            // curr++;\\n        }\\n        return ans;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto &it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<n;++i)\\n        {\\n            vector<int> vis(n,0);\\n            res=min(res,bfs(i,adj,vis,n));\\n        }\\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377453,
                "title": "bfs-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(int n,vector<vector<int>> &gr) {\\n        int ans = INT_MAX;\\n \\n    for (int i = 0; i < n; i++) {\\n \\n       \\n        vector<int> D(n+1, INT_MAX);\\n \\n       \\n        vector<int> par(n, -1);\\n \\n        \\n        D[i] = 0;\\n        queue<int> q;\\n \\n     \\n        q.push(i);\\n \\n       \\n        while (!q.empty()) {\\n \\n         \\n            int x = q.front();\\n            q.pop();\\n \\n          \\n            for (int child : gr[x]) {\\n \\n            \\n                if (D[child] == INT_MAX) {\\n \\n                    D[child] = 1 + D[x];\\n \\n                   \\n                    par[child] = x;\\n \\n                  \\n                    q.push(child);\\n                }\\n \\n              \\n                else if (par[x] != child and par[child] != x)\\n                    ans = min(ans, D[x] + D[child] + 1);\\n            }\\n        }\\n    }\\n \\n   \\n    if (ans == INT_MAX)\\n        return -1;\\n \\n    \\n    else\\n        return ans;\\n    }\\n    \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> gr(n+1);\\n        \\n        for(int i=0;i<edges.size();i++) {\\n            gr[edges[i][0]].push_back(edges[i][1]);\\n            gr[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        return solve(n,gr);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int n,vector<vector<int>> &gr) {\\n        int ans = INT_MAX;\\n \\n    for (int i = 0; i < n; i++) {\\n \\n       \\n        vector<int> D(n+1, INT_MAX);\\n \\n       \\n        vector<int> par(n, -1);\\n \\n        \\n        D[i] = 0;\\n        queue<int> q;\\n \\n     \\n        q.push(i);\\n \\n       \\n        while (!q.empty()) {\\n \\n         \\n            int x = q.front();\\n            q.pop();\\n \\n          \\n            for (int child : gr[x]) {\\n \\n            \\n                if (D[child] == INT_MAX) {\\n \\n                    D[child] = 1 + D[x];\\n \\n                   \\n                    par[child] = x;\\n \\n                  \\n                    q.push(child);\\n                }\\n \\n              \\n                else if (par[x] != child and par[child] != x)\\n                    ans = min(ans, D[x] + D[child] + 1);\\n            }\\n        }\\n    }\\n \\n   \\n    if (ans == INT_MAX)\\n        return -1;\\n \\n    \\n    else\\n        return ans;\\n    }\\n    \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>> gr(n+1);\\n        \\n        for(int i=0;i<edges.size();i++) {\\n            gr[edges[i][0]].push_back(edges[i][1]);\\n            gr[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        return solve(n,gr);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373812,
                "title": "c-easy-solution-bfs-dfs-solution-optimal-solution",
                "content": "\\n# DFS Solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int mini=INT_MAX;\\n    void dfs(int s,int c,vector<bool>& vis,map<int,vector<int>>& mp,vector<int>& time,int par){\\n        vis[s]=true;\\n        time[s]=c;\\n        for(auto it:mp[s]){\\n            if(!vis[it]){\\n                dfs(it,c+1,vis,mp,time,s);\\n            }else if(vis[it] && it!=par){\\n                \\n                mini=min(mini,abs(time[it]-time[s])+1);\\n            }\\n        }\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        mini=INT_MAX;\\n        map<int,vector<int>> mp;    \\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n                 vector<bool> vis(n,false);\\n                 vector<int> time(n,INT_MAX);\\n                dfs(i,1,vis,mp,time,-1);            \\n        }\\n        if(mini==INT_MAX){\\n            return -1;\\n        }\\n        return mini;\\n    }\\n};\\n```\\n# BFS Solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int bfs(int s,map<int,vector<int>>& mp,int n){\\n        int mini=INT_MAX;\\n        vector<bool> vis(n,false);\\n        vector<int> dist(n,INT_MAX);\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({s,{0,-1}});\\n        dist[s]=0;\\n        vis[s]=true;\\n        while(!q.empty()){\\n            int top=q.front().first;\\n            int d=q.front().second.first;\\n            int par=q.front().second.second;\\n            q.pop();\\n            for(auto it:mp[top]){\\n                if(!vis[it]){\\n                    dist[it]=1+dist[top];\\n                    vis[top]=true;\\n                    q.push({it,{dist[it],top}});\\n                }else if(it!=par){\\n                    mini=min(mini,1+d+dist[it]);\\n                }\\n            }\\n        }\\n       \\n        return mini;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n            int mini=INT_MAX;    \\n        map<int,vector<int>> mp;\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            mini=min(mini,bfs(i,mp,n));\\n        }\\n        if(mini==INT_MAX){\\n            return -1;\\n        }\\n        return mini;\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mini=INT_MAX;\\n    void dfs(int s,int c,vector<bool>& vis,map<int,vector<int>>& mp,vector<int>& time,int par){\\n        vis[s]=true;\\n        time[s]=c;\\n        for(auto it:mp[s]){\\n            if(!vis[it]){\\n                dfs(it,c+1,vis,mp,time,s);\\n            }else if(vis[it] && it!=par){\\n                \\n                mini=min(mini,abs(time[it]-time[s])+1);\\n            }\\n        }\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        mini=INT_MAX;\\n        map<int,vector<int>> mp;    \\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n                 vector<bool> vis(n,false);\\n                 vector<int> time(n,INT_MAX);\\n                dfs(i,1,vis,mp,time,-1);            \\n        }\\n        if(mini==INT_MAX){\\n            return -1;\\n        }\\n        return mini;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int bfs(int s,map<int,vector<int>>& mp,int n){\\n        int mini=INT_MAX;\\n        vector<bool> vis(n,false);\\n        vector<int> dist(n,INT_MAX);\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({s,{0,-1}});\\n        dist[s]=0;\\n        vis[s]=true;\\n        while(!q.empty()){\\n            int top=q.front().first;\\n            int d=q.front().second.first;\\n            int par=q.front().second.second;\\n            q.pop();\\n            for(auto it:mp[top]){\\n                if(!vis[it]){\\n                    dist[it]=1+dist[top];\\n                    vis[top]=true;\\n                    q.push({it,{dist[it],top}});\\n                }else if(it!=par){\\n                    mini=min(mini,1+d+dist[it]);\\n                }\\n            }\\n        }\\n       \\n        return mini;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n            int mini=INT_MAX;    \\n        map<int,vector<int>> mp;\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            mini=min(mini,bfs(i,mp,n));\\n        }\\n        if(mini==INT_MAX){\\n            return -1;\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371207,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n    vector<int> gr[100200];\\n    void Add_edge(int x, int y)\\n    {\\n        gr[x].push_back(y);\\n        gr[y].push_back(x);\\n    }\\n    int shortest_cycle(int n)\\n    {\\n        int ans = INT_MAX;\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector<int> dist(n, (int)(1e9));\\n            vector<int> par(n, -1);\\n            dist[i] = 0;\\n            queue<int> q;\\n            q.push(i);\\n            while (!q.empty())\\n            {\\n                int x = q.front();\\n                q.pop();\\n                for (int child : gr[x])\\n                {\\n                    if (dist[child] == (int)(1e9))\\n                    {\\n                        dist[child] = 1 + dist[x];\\n                        par[child] = x;\\n                        q.push(child);\\n                    }\\n                    else if (par[x] != child and par[child] != x)\\n                        ans = min(ans, dist[x] + dist[child] + 1);\\n                }\\n            }\\n        }\\n        if (ans == INT_MAX)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>> &edges)\\n    {\\n        for (auto &itr : edges)\\n        {\\n            Add_edge(itr[0], itr[1]);\\n        }\\n        int ans = shortest_cycle(n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    vector<int> gr[100200];\\n    void Add_edge(int x, int y)\\n    {\\n        gr[x].push_back(y);\\n        gr[y].push_back(x);\\n    }\\n    int shortest_cycle(int n)\\n    {\\n        int ans = INT_MAX;\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector<int> dist(n, (int)(1e9));\\n            vector<int> par(n, -1);\\n            dist[i] = 0;\\n            queue<int> q;\\n            q.push(i);\\n            while (!q.empty())\\n            {\\n                int x = q.front();\\n                q.pop();\\n                for (int child : gr[x])\\n                {\\n                    if (dist[child] == (int)(1e9))\\n                    {\\n                        dist[child] = 1 + dist[x];\\n                        par[child] = x;\\n                        q.push(child);\\n                    }\\n                    else if (par[x] != child and par[child] != x)\\n                        ans = min(ans, dist[x] + dist[child] + 1);\\n                }\\n            }\\n        }\\n        if (ans == INT_MAX)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>> &edges)\\n    {\\n        for (auto &itr : edges)\\n        {\\n            Add_edge(itr[0], itr[1]);\\n        }\\n        int ans = shortest_cycle(n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369685,
                "title": "using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void solve(int node,int par,vector<int> adj[],vector<bool> &vis,vector<int> &dist,int distance,int &ans)\\n   {\\n       vis[node]=true;\\n       dist[node]=distance;\\n       for(auto it: adj[node])\\n       {\\n           if(it==par) continue;\\n           if(vis[it]==false)\\n           {\\n               solve(it,node,adj,vis,dist,distance+1,ans);\\n           }else if(vis[it]==true)\\n           {\\n               ans=min(abs(dist[it] - distance),ans);\\n           }\\n       }\\n   }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it : edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<int> dist(n,0);\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {  vector<bool> vis(n,false);\\n            if(vis[i]==false)\\n            {\\n                solve(i,-1,adj,vis,dist,0,ans);\\n            }\\n            \\n        }\\n        return ans==INT_MAX ? -1: ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void solve(int node,int par,vector<int> adj[],vector<bool> &vis,vector<int> &dist,int distance,int &ans)\\n   {\\n       vis[node]=true;\\n       dist[node]=distance;\\n       for(auto it: adj[node])\\n       {\\n           if(it==par) continue;\\n           if(vis[it]==false)\\n           {\\n               solve(it,node,adj,vis,dist,distance+1,ans);\\n           }else if(vis[it]==true)\\n           {\\n               ans=min(abs(dist[it] - distance),ans);\\n           }\\n       }\\n   }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it : edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<int> dist(n,0);\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {  vector<bool> vis(n,false);\\n            if(vis[i]==false)\\n            {\\n                solve(i,-1,adj,vis,dist,0,ans);\\n            }\\n            \\n        }\\n        return ans==INT_MAX ? -1: ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369461,
                "title": "intuitive-approach-using-djikstra-s-algorithm-and-bfs-beats-100-time",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(|V|*(|V|+|E|))\\n\\n- Space complexity:\\nO(|V|+|E|)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n       vector<vector<int>> adj(n);\\n        for(int i = 0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i = 0;i<n;i++){\\n            vector<int> dist(n,1e9);\\n            vector<int> par(n,-1);\\n            \\n            dist[i] = 0;\\n            queue<int> q;\\n            q.push(i);\\n            \\n            while(!q.empty()){\\n                int curr = q.front();\\n                q.pop();\\n                \\n                for(auto it:adj[curr]){\\n                    if(dist[it] == 1e9){\\n                        dist[it] = 1+dist[curr];\\n                        par[it] = curr;\\n                        q.push(it);\\n                    }\\n                    \\n                    else if(par[it] != curr && par[curr] != it){\\n                        ans = min(ans,dist[it]+dist[curr] + 1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(ans == INT_MAX) return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n       vector<vector<int>> adj(n);\\n        for(int i = 0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i = 0;i<n;i++){\\n            vector<int> dist(n,1e9);\\n            vector<int> par(n,-1);\\n            \\n            dist[i] = 0;\\n            queue<int> q;\\n            q.push(i);\\n            \\n            while(!q.empty()){\\n                int curr = q.front();\\n                q.pop();\\n                \\n                for(auto it:adj[curr]){\\n                    if(dist[it] == 1e9){\\n                        dist[it] = 1+dist[curr];\\n                        par[it] = curr;\\n                        q.push(it);\\n                    }\\n                    \\n                    else if(par[it] != curr && par[curr] != it){\\n                        ans = min(ans,dist[it]+dist[curr] + 1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(ans == INT_MAX) return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367654,
                "title": "python-3-dfs",
                "content": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        g = defaultdict(list)\\n        \\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n        \\n        self.vis = set()\\n        \\n        def dfs(node, par, path):\\n            # if current path >= current shorteset cycle, then jump out of the recursion\\n            if len(path) >= self.res:\\n                return\\n            # keep track of visited nodes\\n            self.vis.add(node)\\n            \\n            for nei in g[node]:\\n                if nei == par: continue\\n                # cycle detected and involving more than three nodes                \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# if nei in path and len(path) > 2: \\n\\t\\t\\t\\tif nei in path:\\n                    self.res = min(self.res, len(path) - path[nei])\\n                    return\\n                # assign the visited order of vertex in the path\\n                new_path = path.copy()\\n                new_path[nei] = len(path)\\n                dfs(nei, node, new_path)\\n        \\n        \\n        self.res = float(\\'inf\\')\\n        for i in range(n):\\n            if i in self.vis: continue\\n            dfs(i, -1, {i: 0})\\n        \\n        return self.res if self.res < float(\\'inf\\') else -1\\n```\\nUpdates on 04/02/2023: Based on @WayWardCC, take out `len(path) > 2`",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        g = defaultdict(list)\\n        \\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n        \\n        self.vis = set()\\n        \\n        def dfs(node, par, path):\\n            # if current path >= current shorteset cycle, then jump out of the recursion\\n            if len(path) >= self.res:\\n                return\\n            # keep track of visited nodes\\n            self.vis.add(node)\\n            \\n            for nei in g[node]:\\n                if nei == par: continue\\n                # cycle detected and involving more than three nodes                \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# if nei in path and len(path) > 2: \\n\\t\\t\\t\\tif nei in path:\\n                    self.res = min(self.res, len(path) - path[nei])\\n                    return\\n                # assign the visited order of vertex in the path\\n                new_path = path.copy()\\n                new_path[nei] = len(path)\\n                dfs(nei, node, new_path)\\n        \\n        \\n        self.res = float(\\'inf\\')\\n        for i in range(n):\\n            if i in self.vis: continue\\n            dfs(i, -1, {i: 0})\\n        \\n        return self.res if self.res < float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367300,
                "title": "c-dfs-bfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(V+E)+O(V*E)$$\\n\\n- Space complexity:$$O(V)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    vector<int>vec;\\n    bool dfs(int i, int p, vector<int>&v, vector<int>adj[], int n){\\n        v[i]=1;\\n        cout<<i<<endl;\\n        for(auto it: adj[i]){\\n            if(!v[it]){\\n                if(dfs(it, i, v, adj, n)){return true;}\\n            }\\n            else if(it!=p){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    // void dfs1(int i, int p, int cnt, vector<int>&v, vector<int>&v1, vector<int>adj[], int n){\\n    //     v[i]=1;\\n    //     v1[i]=cnt;\\n    //     for(auto it: adj[i]){\\n    //         if(!v[it]){\\n    //             dfs1(it, i, cnt+1, v, v1, adj, n);\\n    //         }\\n    //         else if(it!=p){\\n    //             vec.push_back(v1[i]+v1[it]);\\n    //             //ans=min(ans, cnt);\\n    //         }\\n    //     }\\n    // }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        int chk=1;\\n        vector<int>adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>v(n, 0), v1;\\n        for(int i=0; i<n; i++){\\n            if(!v[i]){\\n                if(dfs(i, -1, v, adj, n)){\\n                    chk=-1;\\n                    v1.push_back(i);\\n                }\\n            }\\n        }\\n        if(chk==1){return -1;}\\n        //cout<<\"here\"<<endl;\\n        \\n        // vector<int>vv(n, 0), vv1(n, 0);\\n        // for(int i=0; i<n; i++){\\n        //     if(!vv[i]){\\n        //         dfs1(i, -1, 0, vv, vv1, adj, n);\\n        //     }\\n        //     cout<<\" chk\"<<endl;\\n        // }\\n        for (int i = 0; i < n; i++) {\\n            vector<int> dist(n, 1e9), par(n, -1);\\n            dist[i] = 0;\\n            queue<int> q;\\n            q.push(i);\\n            while (!q.empty()) {\\n                int x = q.front();\\n                q.pop();\\n                for (int child : adj[x]) {\\n                    if (dist[child] == (int)(1e9)) {\\n                        dist[child] = 1 + dist[x];\\n                        par[child] = x;\\n                        q.push(child);\\n                    }\\n                    else if (par[x] != child and par[child] != x)\\n                        ans = min(ans, dist[x] + dist[child] + 1);\\n                }\\n            }\\n        }\\n        // sort(vec.begin(), vec.end());\\n        // for(int i=0; i<vec.size(); i++){\\n        //     cout<<vec[i]<<\" \";\\n        //     //if(vec[i]>1){return vec[i]+1;}\\n        // }\\n        // cout<<endl;\\n        if(ans==INT_MAX){return -1;}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    vector<int>vec;\\n    bool dfs(int i, int p, vector<int>&v, vector<int>adj[], int n){\\n        v[i]=1;\\n        cout<<i<<endl;\\n        for(auto it: adj[i]){\\n            if(!v[it]){\\n                if(dfs(it, i, v, adj, n)){return true;}\\n            }\\n            else if(it!=p){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    // void dfs1(int i, int p, int cnt, vector<int>&v, vector<int>&v1, vector<int>adj[], int n){\\n    //     v[i]=1;\\n    //     v1[i]=cnt;\\n    //     for(auto it: adj[i]){\\n    //         if(!v[it]){\\n    //             dfs1(it, i, cnt+1, v, v1, adj, n);\\n    //         }\\n    //         else if(it!=p){\\n    //             vec.push_back(v1[i]+v1[it]);\\n    //             //ans=min(ans, cnt);\\n    //         }\\n    //     }\\n    // }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        int chk=1;\\n        vector<int>adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>v(n, 0), v1;\\n        for(int i=0; i<n; i++){\\n            if(!v[i]){\\n                if(dfs(i, -1, v, adj, n)){\\n                    chk=-1;\\n                    v1.push_back(i);\\n                }\\n            }\\n        }\\n        if(chk==1){return -1;}\\n        //cout<<\"here\"<<endl;\\n        \\n        // vector<int>vv(n, 0), vv1(n, 0);\\n        // for(int i=0; i<n; i++){\\n        //     if(!vv[i]){\\n        //         dfs1(i, -1, 0, vv, vv1, adj, n);\\n        //     }\\n        //     cout<<\" chk\"<<endl;\\n        // }\\n        for (int i = 0; i < n; i++) {\\n            vector<int> dist(n, 1e9), par(n, -1);\\n            dist[i] = 0;\\n            queue<int> q;\\n            q.push(i);\\n            while (!q.empty()) {\\n                int x = q.front();\\n                q.pop();\\n                for (int child : adj[x]) {\\n                    if (dist[child] == (int)(1e9)) {\\n                        dist[child] = 1 + dist[x];\\n                        par[child] = x;\\n                        q.push(child);\\n                    }\\n                    else if (par[x] != child and par[child] != x)\\n                        ans = min(ans, dist[x] + dist[child] + 1);\\n                }\\n            }\\n        }\\n        // sort(vec.begin(), vec.end());\\n        // for(int i=0; i<vec.size(); i++){\\n        //     cout<<vec[i]<<\" \";\\n        //     //if(vec[i]>1){return vec[i]+1;}\\n        // }\\n        // cout<<endl;\\n        if(ans==INT_MAX){return -1;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3366955,
                "title": "javascript-bfs-325ms",
                "content": "```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packUG = (g, edges) => { for (const [u, v] of edges) { g[u].push(v); g[v].push(u); } };\\n\\nconst findShortestCycle = (n, edges) => {\\n    let g = initializeGraph(n), res = Number.MAX_SAFE_INTEGER;\\n    packUG(g, edges);\\n    for (let i = 0; i < n; i++) res = Math.min(res, shortestCycleUG(g, i));\\n    return res == Number.MAX_SAFE_INTEGER ? -1 : res;\\n};\\n\\nconst shortestCycleUG = (g, start) => {\\n    let n = g.length, dis = Array(n).fill(Number.MAX_SAFE_INTEGER), q = [[start, -1]], res = Number.MAX_SAFE_INTEGER;\\n    dis[start] = 0;\\n    while (q.length) {\\n        let [cur, par] = q.shift();\\n        for (const child of g[cur]) {\\n            if (dis[child] > dis[cur] + 1) {\\n                dis[child] = dis[cur] + 1;\\n                q.push([child, cur]);\\n            } else if (child != par) {\\n                let cycle = dis[cur] + dis[child] + 1;\\n                res = Math.min(res, cycle);\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packUG = (g, edges) => { for (const [u, v] of edges) { g[u].push(v); g[v].push(u); } };\\n\\nconst findShortestCycle = (n, edges) => {\\n    let g = initializeGraph(n), res = Number.MAX_SAFE_INTEGER;\\n    packUG(g, edges);\\n    for (let i = 0; i < n; i++) res = Math.min(res, shortestCycleUG(g, i));\\n    return res == Number.MAX_SAFE_INTEGER ? -1 : res;\\n};\\n\\nconst shortestCycleUG = (g, start) => {\\n    let n = g.length, dis = Array(n).fill(Number.MAX_SAFE_INTEGER), q = [[start, -1]], res = Number.MAX_SAFE_INTEGER;\\n    dis[start] = 0;\\n    while (q.length) {\\n        let [cur, par] = q.shift();\\n        for (const child of g[cur]) {\\n            if (dis[child] > dis[cur] + 1) {\\n                dis[child] = dis[cur] + 1;\\n                q.push([child, cur]);\\n            } else if (child != par) {\\n                let cycle = dis[cur] + dis[child] + 1;\\n                res = Math.min(res, cycle);\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366763,
                "title": "java-python-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* stop searching if your current depth > current lowest cycle length\\n* nodes will only encounter each other if they are in the same connected component (i.e. if i save the depth of a node in a connected component, if i traverse in another connected component, i will not meet that node, so i can safely store it without needing to override that value)\\n* not the same as visiting the same node on the same connected component though. imagine multiple circles together, but the circles share some edge with at least one other circle\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* normal dfs, if at a node previously visited (check using path, rather than visited (which records the depth for me))\\n* cannot use visited since we may have visited that node in the same connected component before, but it is not on the same cycle\\n\\n# Python Code\\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        self.res = 1001\\n        self.visited = [-1 for i in range(n)]\\n        self.path = [False for i in range(n)]\\n        self.graph = [[] for i in range(n)]\\n        for x, y in edges:\\n            self.graph[x].append(y)\\n            self.graph[y].append(x)\\n        for i in range(n):\\n            if self.visited[i] == -1: self.dfs(i, -1, 0)\\n        return -1 if self.res == 1001 else self.res\\n    \\n    def dfs(self, curr, prev, depth):\\n        if self.path[curr]:\\n            self.res = min(self.res, depth - self.visited[curr])\\n            return\\n        if depth > self.res: return\\n        self.visited[curr] = depth\\n        self.path[curr] = True\\n        for i in self.graph[curr]:\\n            if i == prev: continue\\n            self.dfs(i, curr, depth + 1)\\n        self.path[curr] = False\\n```\\n\\n# Java Code\\n```\\nclass Solution {\\n    int res = 1001;\\n    List<Integer>[] graph;\\n    int[] visited;\\n    boolean[] path;\\n    public int findShortestCycle(int n, int[][] edges) {\\n        graph = new List[n];\\n        visited = new int[n];\\n        path = new boolean[n];\\n        Arrays.fill(visited, -1);\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] == -1) dfs(i, -1, 0);\\n        }\\n        return res == 1001 ? -1 : res;\\n    }\\n    public void dfs(int curr, int prev, int depth) {\\n        if (path[curr]) {\\n            res = Math.min(res, depth - visited[curr]);\\n            return;\\n        }\\n        if (depth > res) return;\\n        visited[curr] = depth;\\n        path[curr] = true;\\n        for (int neighbour : graph[curr]) {\\n            if (neighbour == prev) continue;\\n            dfs(neighbour, curr, depth + 1);\\n        }\\n        path[curr] = false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        self.res = 1001\\n        self.visited = [-1 for i in range(n)]\\n        self.path = [False for i in range(n)]\\n        self.graph = [[] for i in range(n)]\\n        for x, y in edges:\\n            self.graph[x].append(y)\\n            self.graph[y].append(x)\\n        for i in range(n):\\n            if self.visited[i] == -1: self.dfs(i, -1, 0)\\n        return -1 if self.res == 1001 else self.res\\n    \\n    def dfs(self, curr, prev, depth):\\n        if self.path[curr]:\\n            self.res = min(self.res, depth - self.visited[curr])\\n            return\\n        if depth > self.res: return\\n        self.visited[curr] = depth\\n        self.path[curr] = True\\n        for i in self.graph[curr]:\\n            if i == prev: continue\\n            self.dfs(i, curr, depth + 1)\\n        self.path[curr] = False\\n```\n```\\nclass Solution {\\n    int res = 1001;\\n    List<Integer>[] graph;\\n    int[] visited;\\n    boolean[] path;\\n    public int findShortestCycle(int n, int[][] edges) {\\n        graph = new List[n];\\n        visited = new int[n];\\n        path = new boolean[n];\\n        Arrays.fill(visited, -1);\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] == -1) dfs(i, -1, 0);\\n        }\\n        return res == 1001 ? -1 : res;\\n    }\\n    public void dfs(int curr, int prev, int depth) {\\n        if (path[curr]) {\\n            res = Math.min(res, depth - visited[curr]);\\n            return;\\n        }\\n        if (depth > res) return;\\n        visited[curr] = depth;\\n        path[curr] = true;\\n        for (int neighbour : graph[curr]) {\\n            if (neighbour == prev) continue;\\n            dfs(neighbour, curr, depth + 1);\\n        }\\n        path[curr] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366689,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        G = [[] for _ in range(n)]\\n        for i, j in edges:\\n            G[i].append(j)\\n            G[j].append(i)\\n        def root(i):\\n            dis = [inf] * n\\n            fa = [-1] * n\\n            dis[i] = 0\\n            bfs = [i]\\n            for i in bfs:\\n                for j in G[i]:\\n                    if dis[j] == inf:\\n                        dis[j] = 1 + dis[i]\\n                        fa[j] = i\\n                        bfs.append(j)\\n                    elif fa[i] != j and fa[j] != i:\\n                        return dis[i] + dis[j] + 1\\n            return inf\\n        res = min(root(i) for i in range(n))\\n        return res if res < inf else -1\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        G = [[] for _ in range(n)]\\n        for i, j in edges:\\n            G[i].append(j)\\n            G[j].append(i)\\n        def root(i):\\n            dis = [inf] * n\\n            fa = [-1] * n\\n            dis[i] = 0\\n            bfs = [i]\\n            for i in bfs:\\n                for j in G[i]:\\n                    if dis[j] == inf:\\n                        dis[j] = 1 + dis[i]\\n                        fa[j] = i\\n                        bfs.append(j)\\n                    elif fa[i] != j and fa[j] != i:\\n                        return dis[i] + dis[j] + 1\\n            return inf\\n        res = min(root(i) for i in range(n))\\n        return res if res < inf else -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366617,
                "title": "java-solution-using-bfs",
                "content": "import java.util.*;\\n\\nclass Solution {\\n   \\n\\n    public static int findShortestCycle(int n, int[][] edges) {\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int v1 = edge[0];\\n            int v2 = edge[1];\\n            graph.get(v1).add(v2);\\n            graph.get(v2).add(v1);\\n        }\\n        return bfs(graph);\\n    }\\n\\n    public static int bfs(HashMap<Integer, List<Integer>> graph) {\\n        int n = graph.size();\\n        int minCycle = Integer.MAX_VALUE;\\n        for (int src : graph.keySet()) {\\n            int[] parent = new int[n];\\n            Arrays.fill(parent, -1);\\n            Queue<Integer> queue = new LinkedList<>();\\n            queue.offer(src);\\n            parent[src] = src;\\n            while (!queue.isEmpty()) {\\n                int curr = queue.poll();\\n                for (int neighbor : graph.get(curr)) {\\n                    if (parent[curr] != neighbor && parent[neighbor] != -1) {\\n                        // Found a cycle\\n                        minCycle = Math.min(minCycle, getPathLength(src, curr, neighbor, parent));\\n                    }\\n                    if (parent[neighbor] == -1) {\\n                        // Unvisited node, add it to the queue\\n                        parent[neighbor] = curr;\\n                        queue.offer(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n        return (minCycle == Integer.MAX_VALUE) ? -1 : minCycle;\\n    }\\n\\n    public static int getPathLength(int src, int u, int v, int[] parent) {\\n        int pathLength = 0;\\n        while (u != src) {\\n            pathLength++;\\n            u = parent[u];\\n        }\\n        while (v != src) {\\n            pathLength++;\\n            v = parent[v];\\n        }\\n        return pathLength + 1; // Add 1 to count the edge between u and v\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n   \\n\\n    public static int findShortestCycle(int n, int[][] edges) {\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3366590,
                "title": "java-bfs-accepted",
                "content": "if you find my solution useful please upvote it.\\n```\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        // Initialize distance matrix\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        \\n        // BFS to find shortest cycle\\n        int minCycle = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int[] dist = new int[n];\\n            Arrays.fill(dist, -1);\\n            Queue<Integer> queue = new LinkedList<>();\\n            queue.add(i);\\n            dist[i] = 0;\\n            while (!queue.isEmpty()) {\\n                int u = queue.remove();\\n                for (int v : adj.get(u)) {\\n                    if (dist[v] == -1) {\\n                        dist[v] = dist[u] + 1;\\n                        queue.add(v);\\n                    } else if (v != i && dist[v] >= dist[u]) {\\n                        minCycle = Math.min(minCycle, dist[u] + dist[v] + 1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return (minCycle == Integer.MAX_VALUE) ? -1 : minCycle;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        // Initialize distance matrix\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        \\n        // BFS to find shortest cycle\\n        int minCycle = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int[] dist = new int[n];\\n            Arrays.fill(dist, -1);\\n            Queue<Integer> queue = new LinkedList<>();\\n            queue.add(i);\\n            dist[i] = 0;\\n            while (!queue.isEmpty()) {\\n                int u = queue.remove();\\n                for (int v : adj.get(u)) {\\n                    if (dist[v] == -1) {\\n                        dist[v] = dist[u] + 1;\\n                        queue.add(v);\\n                    } else if (v != i && dist[v] >= dist[u]) {\\n                        minCycle = Math.min(minCycle, dist[u] + dist[v] + 1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return (minCycle == Integer.MAX_VALUE) ? -1 : minCycle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366467,
                "title": "recursive-solution-with-memorization-c-recursion",
                "content": "# Explanation\\n\\nWe go through all the nodes. If the current node is unvisited, then we start building a path from this node till the end or till we find an intersection with the current path.\\nStore the position of the node in path array, so if we find an intersection we can count the length of cycle as (currentPos - intersectionNodePos + 1), where intersectionNodePos = path[intersectionNode]\\nWe mark the intersection node as visited to avoid TLE\\n\\u0410lso all nodes that do not give a cycle we mark as visited to improve performance (this is not necessary to pass tests, but performance is improved significantly).\\n\\n# Complexity\\n\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) \\n    {\\n        std::unordered_map<int, std::vector<int>> adj;\\n        for (const auto& e: edges)\\n        {\\n            if (adj.end() == adj.find(e[0]))\\n                adj[e[0]] = {};\\n            if (adj.end() == adj.find(e[1]))\\n                adj[e[1]] = {};\\n\\n            adj[e[0]].push_back(e[1]); \\n            adj[e[1]].push_back(e[0]); \\n        }\\n\\n        int visited[1001]{0};\\n        int path[1001]{0};\\n\\n        int result = n + 1;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (visited[i])\\n                continue;\\n\\n            findCycle(i, -1, 1, adj, visited, path, result);           \\n        }\\n\\n        return result > n ? -1 : result;\\n    }\\n    \\n    bool findCycle(const int& current, const int& prev, int depth, std::unordered_map<int, std::vector<int>>& adj, int* visited, int* path, int& result)\\n    {        \\n        if (visited[current])\\n            return false;\\n\\n        bool ret = false;\\n\\n        path[current] = depth; \\n        for (const int& next: adj[current])\\n        {\\n            if (!path[next])\\n            {\\n                if (findCycle(next, current, depth + 1, adj, visited, path, result))\\n                    ret = true;\\n            }\\n            else if (next != prev)\\n            {                    \\n                result = std::min(result, depth - path[next] + 1);\\n                visited[next] = 1;    \\n                ret = true;            \\n            }                    \\n        }\\n        path[current] = 0;\\n\\n        if (!ret)\\n            visited[current] = 1;\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) \\n    {\\n        std::unordered_map<int, std::vector<int>> adj;\\n        for (const auto& e: edges)\\n        {\\n            if (adj.end() == adj.find(e[0]))\\n                adj[e[0]] = {};\\n            if (adj.end() == adj.find(e[1]))\\n                adj[e[1]] = {};\\n\\n            adj[e[0]].push_back(e[1]); \\n            adj[e[1]].push_back(e[0]); \\n        }\\n\\n        int visited[1001]{0};\\n        int path[1001]{0};\\n\\n        int result = n + 1;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (visited[i])\\n                continue;\\n\\n            findCycle(i, -1, 1, adj, visited, path, result);           \\n        }\\n\\n        return result > n ? -1 : result;\\n    }\\n    \\n    bool findCycle(const int& current, const int& prev, int depth, std::unordered_map<int, std::vector<int>>& adj, int* visited, int* path, int& result)\\n    {        \\n        if (visited[current])\\n            return false;\\n\\n        bool ret = false;\\n\\n        path[current] = depth; \\n        for (const int& next: adj[current])\\n        {\\n            if (!path[next])\\n            {\\n                if (findCycle(next, current, depth + 1, adj, visited, path, result))\\n                    ret = true;\\n            }\\n            else if (next != prev)\\n            {                    \\n                result = std::min(result, depth - path[next] + 1);\\n                visited[next] = 1;    \\n                ret = true;            \\n            }                    \\n        }\\n        path[current] = 0;\\n\\n        if (!ret)\\n            visited[current] = 1;\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366461,
                "title": "shortest-cycle-in-a-graph",
                "content": "\\n\\n# Code\\n```\\n\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n#define N 10000\\n\\n\\nclass Solution {\\npublic:\\n\\n    int findShortestCycle(int n, vector<vector<int>> &edges) {\\n        vector<int> gr[N];\\n\\n        for (auto edge: edges) {\\n            gr[edge[0]].push_back(edge[1]);\\n            gr[edge[1]].push_back(edge[0]);\\n        }\\n        int ans = INT_MAX;\\n\\n\\n        for (int i = 0; i < n; i++) {\\n\\n\\n            vector<int> dist(n, (int) (1e9));\\n\\n            vector<int> par(n, -1);\\n\\n            dist[i] = 0;\\n            queue<int> q;\\n\\n\\n            q.push(i);\\n\\n            while (!q.empty()) {\\n\\n\\n                int x = q.front();\\n                q.pop();\\n\\n\\n                for (int child: gr[x]) {\\n\\n\\n                    if (dist[child] == (int) (1e9)) {\\n\\n\\n                        dist[child] = 1 + dist[x];\\n\\n\\n                        par[child] = x;\\n\\n                        q.push(child);\\n                    } else if (par[x] != child and par[child] != x)\\n                        ans = min(ans, dist[x] + dist[child] + 1);\\n                }\\n            }\\n        }\\n\\n\\n        if (ans == INT_MAX)\\n            return -1;\\n\\n        else\\n            return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n#define N 10000\\n\\n\\nclass Solution {\\npublic:\\n\\n    int findShortestCycle(int n, vector<vector<int>> &edges) {\\n        vector<int> gr[N];\\n\\n        for (auto edge: edges) {\\n            gr[edge[0]].push_back(edge[1]);\\n            gr[edge[1]].push_back(edge[0]);\\n        }\\n        int ans = INT_MAX;\\n\\n\\n        for (int i = 0; i < n; i++) {\\n\\n\\n            vector<int> dist(n, (int) (1e9));\\n\\n            vector<int> par(n, -1);\\n\\n            dist[i] = 0;\\n            queue<int> q;\\n\\n\\n            q.push(i);\\n\\n            while (!q.empty()) {\\n\\n\\n                int x = q.front();\\n                q.pop();\\n\\n\\n                for (int child: gr[x]) {\\n\\n\\n                    if (dist[child] == (int) (1e9)) {\\n\\n\\n                        dist[child] = 1 + dist[x];\\n\\n\\n                        par[child] = x;\\n\\n                        q.push(child);\\n                    } else if (par[x] != child and par[child] != x)\\n                        ans = min(ans, dist[x] + dist[child] + 1);\\n                }\\n            }\\n        }\\n\\n\\n        if (ans == INT_MAX)\\n            return -1;\\n\\n        else\\n            return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3366450,
                "title": "c-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int findShortestCycle(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> adj(n);\\n    for (auto& e : edges) {\\n        adj[e[0]].push_back(e[1]);\\n        adj[e[1]].push_back(e[0]);\\n    }\\n    int min_cycle = n + 1;\\n    for (int i = 0; i < n; i++) {\\n        vector<int> dist(n, -1);\\n        dist[i] = 0;\\n        queue<int> q;\\n        q.push(i);\\n        while (!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for (int v : adj[u]) {\\n                if (dist[v] == -1) {\\n                    dist[v] = dist[u] + 1;\\n                    q.push(v);\\n                } else if (dist[v] >= dist[u]) {\\n                    min_cycle = min(min_cycle, dist[v] + dist[u] + 1);\\n                }\\n            }\\n        }\\n    }\\n    return min_cycle <= n ? min_cycle : -1;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int findShortestCycle(int n, vector<vector<int>>& edges) {\\n    vector<vector<int>> adj(n);\\n    for (auto& e : edges) {\\n        adj[e[0]].push_back(e[1]);\\n        adj[e[1]].push_back(e[0]);\\n    }\\n    int min_cycle = n + 1;\\n    for (int i = 0; i < n; i++) {\\n        vector<int> dist(n, -1);\\n        dist[i] = 0;\\n        queue<int> q;\\n        q.push(i);\\n        while (!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for (int v : adj[u]) {\\n                if (dist[v] == -1) {\\n                    dist[v] = dist[u] + 1;\\n                    q.push(v);\\n                } else if (dist[v] >= dist[u]) {\\n                    min_cycle = min(min_cycle, dist[v] + dist[u] + 1);\\n                }\\n            }\\n        }\\n    }\\n    return min_cycle <= n ? min_cycle : -1;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366394,
                "title": "easy-c-solution-bfs-traversal",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> gr(1002);\\n        for(int i=0;i<edges.size();i++){\\n            gr[edges[i][0]].push_back(edges[i][1]);\\n\\t        gr[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int ans = INT_MAX;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tvector<int> dist(n, (int)(100000));\\n\\t\\tvector<int> par(n, -1);\\n\\t\\tdist[i] = 0;\\n\\t\\tqueue<int> q;\\n\\t\\tq.push(i);\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tint x = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\tfor (int child : gr[x]) {\\n\\t\\t\\t\\tif (dist[child] == (int)(100000)) {\\n                    dist[child] = 1 + dist[x];\\n\\t\\t\\t\\t\\tpar[child] = x;\\n\\t\\t\\t\\t\\tq.push(child);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (par[x] != child and par[child] != x)\\n\\t\\t\\t\\t\\tans = min(ans, dist[x] + dist[child] + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (ans != INT_MAX)\\n\\t\\treturn ans;\\n\\treturn -1;\\n    }\\n};\\n```\\n**PLEASE UPVOTE IF THIS HELPED U**\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> gr(1002);\\n        for(int i=0;i<edges.size();i++){\\n            gr[edges[i][0]].push_back(edges[i][1]);\\n\\t        gr[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int ans = INT_MAX;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tvector<int> dist(n, (int)(100000));\\n\\t\\tvector<int> par(n, -1);\\n\\t\\tdist[i] = 0;\\n\\t\\tqueue<int> q;\\n\\t\\tq.push(i);\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tint x = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\tfor (int child : gr[x]) {\\n\\t\\t\\t\\tif (dist[child] == (int)(100000)) {\\n                    dist[child] = 1 + dist[x];\\n\\t\\t\\t\\t\\tpar[child] = x;\\n\\t\\t\\t\\t\\tq.push(child);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (par[x] != child and par[child] != x)\\n\\t\\t\\t\\t\\tans = min(ans, dist[x] + dist[child] + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (ans != INT_MAX)\\n\\t\\treturn ans;\\n\\treturn -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074063,
                "title": "c-dfs-87-readable-commented-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse DFS to traverse the graph, a circle is detected once a node is revisited. Each node needs to be visited multiple times to find all realated circles.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Set up nodes with lists of neighbors\\n- Do DFS until all nodes are checked\\n- A node needs to be visited mutiple times before it is marked as checked. The maxium # of visits allowed for each node is determined beforehand.(Read comments for detailed explanation.)\\n- Distance bewteen visits (on the same node) in the queue can be used to calculate the cirle length.\\n- Once a circle of 3 is found, stop searching and return 3 as the final answer.\\n- If DFS is traversing consectuive 2-edge nodes and the segment is longer than the shortest circle so far. The subroutine can be ended immediately.\\n- When a node is revisited, jump to a neighbor node that\\'s different from last time so that the DFS is not traversing the same branch path again and again.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    deque<int> q;// for visited nodes during the current DFS subroutine\\n    int currMin=INT_MAX; //shortest circle found so far\\n    int clen(int i,vector<vector<int>>& nodes){\\n        //if i a 2-edge, we wanna calculate the length of consecutive 2-e nodes\\n        //that ends at i so far\\n        //if i is not 2-edge, just return 0.\\n        int ans=0;\\n        int index=0; //index in q\\n        int s=q.size();\\n        while((nodes[i].size()==2)&&(index<s)){\\n            ans++;\\n            i=q[index];\\n            index++;\\n        }\\n        return ans;\\n    }\\n    void DFS(int i, vector<vector<int>>& nodes,int prev,vector<int>& vMax){\\n        // cout<<\"Enter Node: \"<<i<<endl;\\n        if(currMin==3){return;} //we already get the smallest possible answer, no need to continue\\n        auto it= find(q.begin(),q.end(),i);\\n        int ni; // the index in q for the node we jump to from i last time\\n        if((it!=q.end())&&(!q.empty())){ //circle detected\\n            // calculate circle length and update currMin\\n            int d= distance(q.begin(),it)+1;\\n            currMin=min(d,currMin);  \\n            vMax[i]--;\\n            ni= d-1; \\n            //if i is a 2-edge node, we can use clen() to calculate \\n            // the length of consecutive 2-edge nodes so far \\n            // a 2-edge node can only belong to at most one circle\\n            // so if clen>=currMin, the possible circle containing this node has no chance to replace \\n            // the shortest circle so far, then there\\'s no need to continue\\n            if(clen(i,nodes)>currMin){return;}\\n            \\n            if(vMax[i]<=0){\\n            //when no more visists on i is allowed , terminate the subroutine\\n            // i becomes a checked node from now on\\n                return;\\n            }             \\n            \\n        } \\n        q.push_front(i);\\n\\n        vMax[i]--;// # of visits allowed decrement by one\\n        if((vMax[i]%2)==0){ //iterate neighbor list forward and backward alternately\\n            for(auto x:nodes[i]){\\n                if(x!=prev){ // Don\\'t jump back to the previous node\\n                    if((it!=q.end())&&(!q.empty())){\\n                        //we should avoid replicating the same path again and again\\n                        // cout<<\"q[ni] is \"<<q[ni]<<endl;\\n                        if(x==q[ni]){goto Label0;}\\n                    }\\n                    if (vMax[i]>=0){//jump to unchecked adjacent nodes                    \\n                        DFS(x,nodes,i,vMax);\\n                    }        \\n                    Label0:{}    \\n                }\\n            }\\n        }else{\\n            for (auto t = nodes[i].rbegin(); t != nodes[i].rend(); ++t) {\\n                int x= *t;\\n                if((it!=q.end())&&(!q.empty())){\\n                        //we should avoid replicating the same path again and again\\n                        if(x==q[ni]){goto Label1;}\\n                }\\n                if(x!=prev){ // Don\\'t jump back to the previous node\\n                    if (vMax[i]>=0){//jump to unchecked adjacent nodes                    \\n                        DFS(x,nodes,i,vMax);\\n                    }            \\n                }\\n                Label1:{}\\n            }\\n        }\\n\\n        q.pop_front(); //leave the node\\n        return;\\n    } \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> nodes(n,vector<int>());        \\n        for (auto i:edges){ //initialize nodes with neighbor lists\\n            nodes[i[0]].push_back(i[1]);\\n            nodes[i[1]].push_back(i[0]);\\n        }\\n        edges.clear();// no longer useful\\n        // for a node with x edges, the maxium number of cycles it belong to is C(x,2)\\n        // C(x,2) means the number of possible paris picked from the  x edges \\n        // In each pair, one edge is for inbound and the other is outband to form a circle\\n        // and the direction doesn\\'t matter since it\\'s in a bi-directional graph \\n        // (Here we assume there\\'s at most one circle binding to a edge-pair)\\n        // (If we could neglect situations where a pair is shared by multiple circels)\\n        // (it can be fixed by increasing vMax value)\\n        // During DFS if the node is vistited v times, it means v-1 circles are detected at this node\\n        // so v-1 must be <= C(x,2)\\n        // so we can set the cap for the maxium times of being visited allowed for eah node\\n        // which is vMax>= C(x,2)+1 (equivalet to x(x-1)/2+1)\\n        // After tesing we choose vMax=x^3\\n        vector<int> vMax(n);// maxium times of being visited allowed for eahc node\\n        for(int k=0;k<n;k++){\\n            int x=nodes[k].size(); //get # of edges\\n            if(x>0){\\n                vMax[k]=x*x*x;\\n            }else{\\n                vMax[k]=1;\\n            }\\n        }\\n        \\n        //start traversing\\n        for(int i=0;i<n;i++){\\n            if (vMax[i]>0){//unchecked nodes\\n                this->DFS(i,nodes,i,vMax);  \\n                q.clear();\\n            }\\n        }\\n\\n\\n        if(currMin==INT_MAX){ currMin=-1;} //if no circle found\\n        return currMin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    deque<int> q;// for visited nodes during the current DFS subroutine\\n    int currMin=INT_MAX; //shortest circle found so far\\n    int clen(int i,vector<vector<int>>& nodes){\\n        //if i a 2-edge, we wanna calculate the length of consecutive 2-e nodes\\n        //that ends at i so far\\n        //if i is not 2-edge, just return 0.\\n        int ans=0;\\n        int index=0; //index in q\\n        int s=q.size();\\n        while((nodes[i].size()==2)&&(index<s)){\\n            ans++;\\n            i=q[index];\\n            index++;\\n        }\\n        return ans;\\n    }\\n    void DFS(int i, vector<vector<int>>& nodes,int prev,vector<int>& vMax){\\n        // cout<<\"Enter Node: \"<<i<<endl;\\n        if(currMin==3){return;} //we already get the smallest possible answer, no need to continue\\n        auto it= find(q.begin(),q.end(),i);\\n        int ni; // the index in q for the node we jump to from i last time\\n        if((it!=q.end())&&(!q.empty())){ //circle detected\\n            // calculate circle length and update currMin\\n            int d= distance(q.begin(),it)+1;\\n            currMin=min(d,currMin);  \\n            vMax[i]--;\\n            ni= d-1; \\n            //if i is a 2-edge node, we can use clen() to calculate \\n            // the length of consecutive 2-edge nodes so far \\n            // a 2-edge node can only belong to at most one circle\\n            // so if clen>=currMin, the possible circle containing this node has no chance to replace \\n            // the shortest circle so far, then there\\'s no need to continue\\n            if(clen(i,nodes)>currMin){return;}\\n            \\n            if(vMax[i]<=0){\\n            //when no more visists on i is allowed , terminate the subroutine\\n            // i becomes a checked node from now on\\n                return;\\n            }             \\n            \\n        } \\n        q.push_front(i);\\n\\n        vMax[i]--;// # of visits allowed decrement by one\\n        if((vMax[i]%2)==0){ //iterate neighbor list forward and backward alternately\\n            for(auto x:nodes[i]){\\n                if(x!=prev){ // Don\\'t jump back to the previous node\\n                    if((it!=q.end())&&(!q.empty())){\\n                        //we should avoid replicating the same path again and again\\n                        // cout<<\"q[ni] is \"<<q[ni]<<endl;\\n                        if(x==q[ni]){goto Label0;}\\n                    }\\n                    if (vMax[i]>=0){//jump to unchecked adjacent nodes                    \\n                        DFS(x,nodes,i,vMax);\\n                    }        \\n                    Label0:{}    \\n                }\\n            }\\n        }else{\\n            for (auto t = nodes[i].rbegin(); t != nodes[i].rend(); ++t) {\\n                int x= *t;\\n                if((it!=q.end())&&(!q.empty())){\\n                        //we should avoid replicating the same path again and again\\n                        if(x==q[ni]){goto Label1;}\\n                }\\n                if(x!=prev){ // Don\\'t jump back to the previous node\\n                    if (vMax[i]>=0){//jump to unchecked adjacent nodes                    \\n                        DFS(x,nodes,i,vMax);\\n                    }            \\n                }\\n                Label1:{}\\n            }\\n        }\\n\\n        q.pop_front(); //leave the node\\n        return;\\n    } \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> nodes(n,vector<int>());        \\n        for (auto i:edges){ //initialize nodes with neighbor lists\\n            nodes[i[0]].push_back(i[1]);\\n            nodes[i[1]].push_back(i[0]);\\n        }\\n        edges.clear();// no longer useful\\n        // for a node with x edges, the maxium number of cycles it belong to is C(x,2)\\n        // C(x,2) means the number of possible paris picked from the  x edges \\n        // In each pair, one edge is for inbound and the other is outband to form a circle\\n        // and the direction doesn\\'t matter since it\\'s in a bi-directional graph \\n        // (Here we assume there\\'s at most one circle binding to a edge-pair)\\n        // (If we could neglect situations where a pair is shared by multiple circels)\\n        // (it can be fixed by increasing vMax value)\\n        // During DFS if the node is vistited v times, it means v-1 circles are detected at this node\\n        // so v-1 must be <= C(x,2)\\n        // so we can set the cap for the maxium times of being visited allowed for eah node\\n        // which is vMax>= C(x,2)+1 (equivalet to x(x-1)/2+1)\\n        // After tesing we choose vMax=x^3\\n        vector<int> vMax(n);// maxium times of being visited allowed for eahc node\\n        for(int k=0;k<n;k++){\\n            int x=nodes[k].size(); //get # of edges\\n            if(x>0){\\n                vMax[k]=x*x*x;\\n            }else{\\n                vMax[k]=1;\\n            }\\n        }\\n        \\n        //start traversing\\n        for(int i=0;i<n;i++){\\n            if (vMax[i]>0){//unchecked nodes\\n                this->DFS(i,nodes,i,vMax);  \\n                q.clear();\\n            }\\n        }\\n\\n\\n        if(currMin==INT_MAX){ currMin=-1;} //if no circle found\\n        return currMin;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4057542,
                "title": "simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- - We have  -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach\\n- Fin -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        # Creating Graph\\n        G = [[] for _ in range(n)]\\n        for u, v in edges:\\n            G[u].append(v)\\n            G[v].append(u)\\n\\n        ans = float(\\'inf\\')\\n\\n        # Finding the minimum length cycle for each vertex\\n        for i in range(n):\\n    \\n            time = [-1] * n\\n            time[i] = 0\\n            \\n            Q = deque()\\n            Q.append(i)\\n            \\n            while Q:\\n\\n                u = Q.popleft()\\n                for v in G[u]:\\n                \\n                    # If we are visiting the node for the first time\\n                    if time[v] == -1:\\n                        time[v] = time[u] + 1\\n                        Q.append(v)\\n                \\n                    # If the node v is already visited then the len of the cycle will be\\n                    # time_in[v] + time_in[u] + 1\\n                    elif time[v] >= time[u]:\\n                        ans = min(ans, time[v] + time[u] + 1)\\n\\n        return -1 if ans == float(\\'inf\\') else ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        # Creating Graph\\n        G = [[] for _ in range(n)]\\n        for u, v in edges:\\n            G[u].append(v)\\n            G[v].append(u)\\n\\n        ans = float(\\'inf\\')\\n\\n        # Finding the minimum length cycle for each vertex\\n        for i in range(n):\\n    \\n            time = [-1] * n\\n            time[i] = 0\\n            \\n            Q = deque()\\n            Q.append(i)\\n            \\n            while Q:\\n\\n                u = Q.popleft()\\n                for v in G[u]:\\n                \\n                    # If we are visiting the node for the first time\\n                    if time[v] == -1:\\n                        time[v] = time[u] + 1\\n                        Q.append(v)\\n                \\n                    # If the node v is already visited then the len of the cycle will be\\n                    # time_in[v] + time_in[u] + 1\\n                    elif time[v] >= time[u]:\\n                        ans = min(ans, time[v] + time[u] + 1)\\n\\n        return -1 if ans == float(\\'inf\\') else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023701,
                "title": "c-simple-bfs-solution",
                "content": "# Approach\\nFor every edge, we perform bfs ignoring that edge and look for another path between the nodes of the edge. If the path exits, then there is a cycle of length $$len(Path) + 1$$. We do this for every edge, and take the minimum cycle length.\\n\\n# Complexity\\n- Time complexity: $$O(v*e)$$\\n\\n- Space complexity: $$O(v)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int bfs(int src, int dest, vector<int> adj[], int n){\\n        queue<int> q;\\n        vector<int> vis(n);\\n        q.push(src);\\n        vis[src] = 1;\\n        int dist = 1;\\n        while(q.size()){\\n            int sz = q.size();\\n            while(sz--){\\n                auto node = q.front();\\n                q.pop();\\n                if(node == dest) return dist;\\n                for(auto&i:adj[node]){\\n                    if((node == src and i == dest) or (node == dest and i == src)) continue;\\n                    if(!vis[i]) vis[i] = 1, q.push(i);\\n                }\\n            }\\n            dist++;\\n        }\\n        return INT_MAX;\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto&i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        int ans = INT_MAX;\\n        for(auto&i:edges){\\n            // cout << bfs(i[0], i[1], adj, n) << \\'\\\\n\\';\\n            ans = min(ans, bfs(i[0], i[1], adj, n));\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int bfs(int src, int dest, vector<int> adj[], int n){\\n        queue<int> q;\\n        vector<int> vis(n);\\n        q.push(src);\\n        vis[src] = 1;\\n        int dist = 1;\\n        while(q.size()){\\n            int sz = q.size();\\n            while(sz--){\\n                auto node = q.front();\\n                q.pop();\\n                if(node == dest) return dist;\\n                for(auto&i:adj[node]){\\n                    if((node == src and i == dest) or (node == dest and i == src)) continue;\\n                    if(!vis[i]) vis[i] = 1, q.push(i);\\n                }\\n            }\\n            dist++;\\n        }\\n        return INT_MAX;\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto&i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        int ans = INT_MAX;\\n        for(auto&i:edges){\\n            // cout << bfs(i[0], i[1], adj, n) << \\'\\\\n\\';\\n            ans = min(ans, bfs(i[0], i[1], adj, n));\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4020597,
                "title": "c-solution",
                "content": "```\\nvoid help(int** can_to, int* count, int* number, bool* used, int now, int from, int place, int* min){\\n    number[now] = place;\\n    used[now] = true;\\n    for (int i = 0 ; i < count[now] ; i++){\\n        if (can_to[now][i] == from){\\n            continue;\\n        } else if (number[can_to[now][i]] != 0){\\n            if (place > number[can_to[now][i]]){\\n                if (place - number[can_to[now][i]] < *min){\\n                    *min = place - number[can_to[now][i]];\\n                }\\n            } else if (place+1 < number[can_to[now][i]]){\\n                help(can_to, count, number, used, can_to[now][i], now, place+1, min);\\n            }\\n        } else {\\n            help(can_to, count, number, used, can_to[now][i], now, place+1, min);\\n        }\\n    }\\n}\\n\\nint findShortestCycle(int n, int** edges, int edgesSize, int* edgesColSize){\\n    int** can_to = malloc(sizeof(int*)*n);\\n    int* count = calloc(n, sizeof(int));\\n    bool* used = calloc(n, sizeof(bool));\\n    for (int i = 0 ; i < n ; i++){\\n        can_to[i] = malloc(sizeof(int)*n);\\n    }\\n    for (int i = 0 ; i < edgesSize ; i++){\\n        can_to[edges[i][0]][count[edges[i][0]]] = edges[i][1];\\n        count[edges[i][0]]++;\\n        can_to[edges[i][1]][count[edges[i][1]]] = edges[i][0];\\n        count[edges[i][1]]++;\\n    }\\n    \\n    int min = n;\\n    \\n    for (int i = 0 ; i < n ; i++){\\n        if (used[i] == false){\\n            int* number = calloc(n, sizeof(int));\\n            help(can_to, count, number, used, i, n, 1, &min);\\n            free(number);\\n        }\\n    }\\n    for (int i = 0 ; i < n ; i++){\\n        free(can_to[i]);\\n    }\\n    free(count);\\n    free(can_to);\\n    free(used);\\n    return min == n ? -1 : min+1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid help(int** can_to, int* count, int* number, bool* used, int now, int from, int place, int* min){\\n    number[now] = place;\\n    used[now] = true;\\n    for (int i = 0 ; i < count[now] ; i++){\\n        if (can_to[now][i] == from){\\n            continue;\\n        } else if (number[can_to[now][i]] != 0){\\n            if (place > number[can_to[now][i]]){\\n                if (place - number[can_to[now][i]] < *min){\\n                    *min = place - number[can_to[now][i]];\\n                }\\n            } else if (place+1 < number[can_to[now][i]]){\\n                help(can_to, count, number, used, can_to[now][i], now, place+1, min);\\n            }\\n        } else {\\n            help(can_to, count, number, used, can_to[now][i], now, place+1, min);\\n        }\\n    }\\n}\\n\\nint findShortestCycle(int n, int** edges, int edgesSize, int* edgesColSize){\\n    int** can_to = malloc(sizeof(int*)*n);\\n    int* count = calloc(n, sizeof(int));\\n    bool* used = calloc(n, sizeof(bool));\\n    for (int i = 0 ; i < n ; i++){\\n        can_to[i] = malloc(sizeof(int)*n);\\n    }\\n    for (int i = 0 ; i < edgesSize ; i++){\\n        can_to[edges[i][0]][count[edges[i][0]]] = edges[i][1];\\n        count[edges[i][0]]++;\\n        can_to[edges[i][1]][count[edges[i][1]]] = edges[i][0];\\n        count[edges[i][1]]++;\\n    }\\n    \\n    int min = n;\\n    \\n    for (int i = 0 ; i < n ; i++){\\n        if (used[i] == false){\\n            int* number = calloc(n, sizeof(int));\\n            help(can_to, count, number, used, i, n, 1, &min);\\n            free(number);\\n        }\\n    }\\n    for (int i = 0 ; i < n ; i++){\\n        free(can_to[i]);\\n    }\\n    free(count);\\n    free(can_to);\\n    free(used);\\n    return min == n ? -1 : min+1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016002,
                "title": "dfs-with-backtrack-and-short-circut",
                "content": "\\n```\\nfunc findShortestCycle(n int, edges [][]int) int {\\n    g := getGraph(edges)\\n\\n    minPath := math.MaxInt32\\n    visiting := map[int]bool{} \\n    for i := 0; i < n; i++ {\\n        countNodesCycle(g, i, visiting, 0, &minPath)\\n    }\\n\\n    if minPath == math.MaxInt32 {\\n        minPath = -1\\n    }\\n    return minPath\\n}\\n\\nfunc countNodesCycle(g map[int]map[int]bool, n int, visiting map[int]bool, curCount int, count *int) {\\n    if visiting[n] {\\n        // cycle\\n        *count = min(*count, curCount)\\n        return\\n    }\\n\\n    // short-circuit if not better\\n    if curCount >= *count {\\n        return\\n    }\\n\\n    visiting[n] = true\\n    for nb, _ := range g[n] {\\n        delete(g[nb], n) // tmp remove reverse edge\\n        countNodesCycle(g, nb, visiting, curCount + 1, count) \\n        g[nb][n] = true // backtrack\\n    }\\n\\n    delete(visiting, n) // backtrack\\n}\\n\\nfunc getGraph(edges [][]int) map[int]map[int]bool{\\n    g := map[int]map[int]bool{}\\n    for _, e := range edges{\\n        n1 := e[0]\\n        n2 := e[1]\\n        if _, ok := g[n1]; !ok {\\n            g[n1] = map[int]bool{}\\n        }\\n        if _, ok := g[n2]; !ok {\\n            g[n2] = map[int]bool{}\\n        }\\n        g[n1][n2] = true\\n        g[n2][n1] = true\\n    }\\n\\n    return g\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc findShortestCycle(n int, edges [][]int) int {\\n    g := getGraph(edges)\\n\\n    minPath := math.MaxInt32\\n    visiting := map[int]bool{} \\n    for i := 0; i < n; i++ {\\n        countNodesCycle(g, i, visiting, 0, &minPath)\\n    }\\n\\n    if minPath == math.MaxInt32 {\\n        minPath = -1\\n    }\\n    return minPath\\n}\\n\\nfunc countNodesCycle(g map[int]map[int]bool, n int, visiting map[int]bool, curCount int, count *int) {\\n    if visiting[n] {\\n        // cycle\\n        *count = min(*count, curCount)\\n        return\\n    }\\n\\n    // short-circuit if not better\\n    if curCount >= *count {\\n        return\\n    }\\n\\n    visiting[n] = true\\n    for nb, _ := range g[n] {\\n        delete(g[nb], n) // tmp remove reverse edge\\n        countNodesCycle(g, nb, visiting, curCount + 1, count) \\n        g[nb][n] = true // backtrack\\n    }\\n\\n    delete(visiting, n) // backtrack\\n}\\n\\nfunc getGraph(edges [][]int) map[int]map[int]bool{\\n    g := map[int]map[int]bool{}\\n    for _, e := range edges{\\n        n1 := e[0]\\n        n2 := e[1]\\n        if _, ok := g[n1]; !ok {\\n            g[n1] = map[int]bool{}\\n        }\\n        if _, ok := g[n2]; !ok {\\n            g[n2] = map[int]bool{}\\n        }\\n        g[n1][n2] = true\\n        g[n2][n1] = true\\n    }\\n\\n    return g\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008619,
                "title": "shortest-path-between-every-edge-ignoring-that-edge",
                "content": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        res = float(\\'inf\\')\\n        for a, b in edges:\\n            q = deque([(a, 0)])\\n            v = {a}\\n            while len(q) > 0:\\n                curr, d = q.pop()\\n                if curr == b:\\n                    res = min(res, d + 1)\\n                for j in graph[curr]:\\n                    if j not in v and (curr, j) not in {(a, b), (b, a)}:\\n                        v.add(j)\\n                        q.appendleft((j, d + 1))\\n        if res == float(\\'inf\\'):\\n            return -1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        res = float(\\'inf\\')\\n        for a, b in edges:\\n            q = deque([(a, 0)])\\n            v = {a}\\n            while len(q) > 0:\\n                curr, d = q.pop()\\n                if curr == b:\\n                    res = min(res, d + 1)\\n                for j in graph[curr]:\\n                    if j not in v and (curr, j) not in {(a, b), (b, a)}:\\n                        v.add(j)\\n                        q.appendleft((j, d + 1))\\n        if res == float(\\'inf\\'):\\n            return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006738,
                "title": "5ms-2-2mb-rust-solution-with-explanation-beats-100-100",
                "content": "# Intuition/Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen noticing that cycle detection was the core idea of the problem, I immediately turned BFS/DFS. These algorithms both reveal cycles in worst case $$O(|V| + |E|)$$ time, but BFS makes more sense in this problems case since we are looking for minimal loops, and BFS will find shortest paths. \\n\\nThe graph may be disjointed (there are seperate interconnected groups), and so we have to check perform BFS at each node. I\\'ll call this approach the **Niave BFS**.\\n\\nOne could, at this point, notice that we can keep track of which nodes have been checked by moving our `dist[]` array out of the `for i..n` loop and skipping BFS on nodes which already have a distance. This optimization *will* find every minimal loop, but may not calculate the correct distance, due to using `dist[node] + dist[next] + 1` to find the distance. To fix this, we simply find the shortest distance between `node` and `next` using another BFS search.\\n\\n---\\n\\n# Niave BFS (~50ms)\\nThere are some simple optimizations in this code which take the time of completion from 100ms (bare bones implementation) to half that, or about 50ms.\\nThe main optimzations are not performing BFS on nodes with only 1 adjacent node, and terminating the BFS after checking up to `min` depth (where `min` is the current minimum cycle), as even if there is a cycle found, its length will be greater than min.\\n## Complexity\\n- Time complexity: $$O(|V|*(|V| + |E|))$$\\n\\n- Space complexity: $$O(|V|)$$\\n\\n## Code\\n```rust\\nuse std::{collections::VecDeque, u32::MAX};\\n\\nimpl Solution {\\n    pub fn find_shortest_cycle(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        // initialize graph which corresponds each node to its children\\n        let mut graph = vec![vec![]; n];\\n        for edge in edges {\\n            // add an edge in each direction, as the graph is undirected\\n            graph[edge[0] as usize].push(edge[1] as usize);\\n            graph[edge[1] as usize].push(edge[0] as usize);\\n        }\\n        let mut min = MAX;\\n        // perform a bfs starting at every node\\n        for i in 0..n {\\n            if graph[i].len() < 2 {\\n                continue; // nodes which only have 1 adjacent will never be in a cycle\\n            }\\n            let mut dist = vec![MAX; n];\\n            let mut queue = VecDeque::new();\\n            queue.push_back(i);\\n            dist[i] = 0;\\n            while let Some(node) = queue.pop_front() {\\n                let d = dist[node];\\n                if d > min {\\n                    break; // all cycles of less than min have been found for i\\n                }\\n                for &next in &graph[node] {\\n                    let dn = dist[next];\\n                    if dn == MAX {\\n                        dist[next] = d + 1;\\n                        queue.push_back(next);\\n                    } else if dn != d - 1 {\\n                        // the node has been cheked, and it is not the immediate parent, so we have a cycle\\n                        min = std::cmp::min(min, dn + d + 1);\\n                    }\\n                }\\n            }\\n        }\\n        if min == MAX {\\n            -1\\n        } else {\\n            min as i32\\n        }\\n    }\\n}\\n\\n```\\n---\\n# Each Group Once (~5ms)\\n## Complexity\\n- Time complexity: $$O(|V| + |E|)$$\\nI am not sure what the accuarate time complexity is for this solution, due to its slightly recusive nature, but the main BFS is only run on each node once, and find_distance is run only for the smallest cycle (worst case it could run $$|V|$$ times, regressing performance back to the old case).\\n\\n- Space complexity: $$O(|V|)$$\\n\\n## Code\\n```rust\\nuse std::{collections::VecDeque, usize::MAX};\\n\\n// basic routine to find distance between two nodes\\nfn find_distance(edges: &Vec<Vec<usize>>, start: usize, end: usize) -> Option<usize> {\\n    let mut queue = VecDeque::new();\\n    let mut dist = vec![MAX; edges.len()];\\n    queue.push_back(start);\\n    dist[start] = 0;\\n    while let Some(node) = queue.pop_front() {\\n        for &next in &edges[node] {\\n            if node == start && next == end {\\n                continue; // ignore the edge that connects start and end\\n            }\\n            if next == end {\\n                return Some(dist[node] + 1); // found a path, return immediately as we know its minimal\\n            }\\n            if dist[next] == MAX {\\n                dist[next] = dist[node] + 1;\\n                queue.push_back(next);\\n            }\\n        }\\n    }\\n    None // no path found\\n}\\n\\nimpl Solution {\\n    pub fn find_shortest_cycle(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        // initialize graph which corresponds each node to its children\\n        let mut graph = vec![vec![]; n];\\n        for edge in edges {\\n            // add an edge in each direction, as the graph is undirected\\n            graph[edge[0] as usize].push(edge[1] as usize);\\n            graph[edge[1] as usize].push(edge[0] as usize);\\n        }\\n        let mut min = MAX;\\n        // perform a bfs for each group of nodes\\n        let mut dist = vec![MAX; n];\\n        for i in 0..n {\\n            if dist[i] != MAX {\\n                continue; // node belongs to group that has already been checked\\n            }\\n            let mut queue = VecDeque::new();\\n            queue.push_back(i);\\n            dist[i] = 0;\\n            while let Some(node) = queue.pop_front() {\\n                let d = dist[node];\\n                if d > min {\\n                    break; // all cycles less than min have been found for this group\\n                }\\n                for &next in &graph[node] {\\n                    let dn = dist[next];\\n                    if dn == MAX {\\n                        dist[next] = d + 1;\\n                        queue.push_back(next);\\n                    } else if dn != d - 1 {\\n                        // the node has been cheked, and it is not the immediate parent, so we have a cycle\\n                        if let Some(distance) = find_distance(&graph, node, next) {\\n                            min = std::cmp::min(min, distance + 1);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if min == MAX {\\n            -1\\n        } else {\\n            min as i32\\n        }\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::{collections::VecDeque, u32::MAX};\\n\\nimpl Solution {\\n    pub fn find_shortest_cycle(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        // initialize graph which corresponds each node to its children\\n        let mut graph = vec![vec![]; n];\\n        for edge in edges {\\n            // add an edge in each direction, as the graph is undirected\\n            graph[edge[0] as usize].push(edge[1] as usize);\\n            graph[edge[1] as usize].push(edge[0] as usize);\\n        }\\n        let mut min = MAX;\\n        // perform a bfs starting at every node\\n        for i in 0..n {\\n            if graph[i].len() < 2 {\\n                continue; // nodes which only have 1 adjacent will never be in a cycle\\n            }\\n            let mut dist = vec![MAX; n];\\n            let mut queue = VecDeque::new();\\n            queue.push_back(i);\\n            dist[i] = 0;\\n            while let Some(node) = queue.pop_front() {\\n                let d = dist[node];\\n                if d > min {\\n                    break; // all cycles of less than min have been found for i\\n                }\\n                for &next in &graph[node] {\\n                    let dn = dist[next];\\n                    if dn == MAX {\\n                        dist[next] = d + 1;\\n                        queue.push_back(next);\\n                    } else if dn != d - 1 {\\n                        // the node has been cheked, and it is not the immediate parent, so we have a cycle\\n                        min = std::cmp::min(min, dn + d + 1);\\n                    }\\n                }\\n            }\\n        }\\n        if min == MAX {\\n            -1\\n        } else {\\n            min as i32\\n        }\\n    }\\n}\\n\\n```\n```rust\\nuse std::{collections::VecDeque, usize::MAX};\\n\\n// basic routine to find distance between two nodes\\nfn find_distance(edges: &Vec<Vec<usize>>, start: usize, end: usize) -> Option<usize> {\\n    let mut queue = VecDeque::new();\\n    let mut dist = vec![MAX; edges.len()];\\n    queue.push_back(start);\\n    dist[start] = 0;\\n    while let Some(node) = queue.pop_front() {\\n        for &next in &edges[node] {\\n            if node == start && next == end {\\n                continue; // ignore the edge that connects start and end\\n            }\\n            if next == end {\\n                return Some(dist[node] + 1); // found a path, return immediately as we know its minimal\\n            }\\n            if dist[next] == MAX {\\n                dist[next] = dist[node] + 1;\\n                queue.push_back(next);\\n            }\\n        }\\n    }\\n    None // no path found\\n}\\n\\nimpl Solution {\\n    pub fn find_shortest_cycle(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        // initialize graph which corresponds each node to its children\\n        let mut graph = vec![vec![]; n];\\n        for edge in edges {\\n            // add an edge in each direction, as the graph is undirected\\n            graph[edge[0] as usize].push(edge[1] as usize);\\n            graph[edge[1] as usize].push(edge[0] as usize);\\n        }\\n        let mut min = MAX;\\n        // perform a bfs for each group of nodes\\n        let mut dist = vec![MAX; n];\\n        for i in 0..n {\\n            if dist[i] != MAX {\\n                continue; // node belongs to group that has already been checked\\n            }\\n            let mut queue = VecDeque::new();\\n            queue.push_back(i);\\n            dist[i] = 0;\\n            while let Some(node) = queue.pop_front() {\\n                let d = dist[node];\\n                if d > min {\\n                    break; // all cycles less than min have been found for this group\\n                }\\n                for &next in &graph[node] {\\n                    let dn = dist[next];\\n                    if dn == MAX {\\n                        dist[next] = d + 1;\\n                        queue.push_back(next);\\n                    } else if dn != d - 1 {\\n                        // the node has been cheked, and it is not the immediate parent, so we have a cycle\\n                        if let Some(distance) = find_distance(&graph, node, next) {\\n                            min = std::cmp::min(min, distance + 1);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if min == MAX {\\n            -1\\n        } else {\\n            min as i32\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940694,
                "title": "c-o-n-2-bfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 2005;\\n    vector<int> G[1005];\\n    void bfs(int u, int n) {\\n        vector<int> dis(n, -1);\\n        queue<pair<int, int>> q;\\n        q.push({u, -1});\\n        dis[u] = 0;\\n        while(!q.empty()) {\\n            auto[node, par] = q.front();\\n            q.pop();\\n            for(auto &x: G[node]) {\\n                if(dis[x] == -1) {\\n                    dis[x] = 1 + dis[node];\\n                    q.push({x, node});\\n                }\\n                else if(x != par) {\\n                    ans = min(ans, dis[x] + dis[node] + 1);\\n                }\\n            }\\n        }\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        for(auto &x : edges) {\\n            G[x[0]].push_back(x[1]);\\n            G[x[1]].push_back(x[0]);\\n        }\\n        for(int i = 0; i < n; ++i) {\\n            bfs(i, n);\\n        }\\n        return ans == 2005 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 2005;\\n    vector<int> G[1005];\\n    void bfs(int u, int n) {\\n        vector<int> dis(n, -1);\\n        queue<pair<int, int>> q;\\n        q.push({u, -1});\\n        dis[u] = 0;\\n        while(!q.empty()) {\\n            auto[node, par] = q.front();\\n            q.pop();\\n            for(auto &x: G[node]) {\\n                if(dis[x] == -1) {\\n                    dis[x] = 1 + dis[node];\\n                    q.push({x, node});\\n                }\\n                else if(x != par) {\\n                    ans = min(ans, dis[x] + dis[node] + 1);\\n                }\\n            }\\n        }\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        for(auto &x : edges) {\\n            G[x[0]].push_back(x[1]);\\n            G[x[1]].push_back(x[0]);\\n        }\\n        for(int i = 0; i < n; ++i) {\\n            bfs(i, n);\\n        }\\n        return ans == 2005 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912657,
                "title": "easy-c-sol",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n+1];\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            vector<int> dist(n,1e9);\\n            vector<int> par(n,-1);\\n            dist[i]=0;\\n            queue<int>q;\\n            q.push(i);\\n            while(!q.empty()){\\n                int curr=q.front();\\n                q.pop();\\n                for(int i:adj[curr]){\\n                    if(dist[i]==1e9){\\n                        dist[i]=1+dist[curr];\\n                        par[i]=curr;\\n                        q.push(i);\\n                    }\\n                    else if(par[curr]!=i && par[i]!=curr){\\n                        ans=min(ans,dist[curr]+dist[i]+1);\\n                    }\\n                }\\n            }\\n        }\\n        return (ans==INT_MAX)?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n+1];\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            vector<int> dist(n,1e9);\\n            vector<int> par(n,-1);\\n            dist[i]=0;\\n            queue<int>q;\\n            q.push(i);\\n            while(!q.empty()){\\n                int curr=q.front();\\n                q.pop();\\n                for(int i:adj[curr]){\\n                    if(dist[i]==1e9){\\n                        dist[i]=1+dist[curr];\\n                        par[i]=curr;\\n                        q.push(i);\\n                    }\\n                    else if(par[curr]!=i && par[i]!=curr){\\n                        ans=min(ans,dist[curr]+dist[i]+1);\\n                    }\\n                }\\n            }\\n        }\\n        return (ans==INT_MAX)?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906064,
                "title": "union-find-to-identify-cycle-node-bfs-to-find-shortest-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- Union Find tells us, when two edges become part of a cycle. This means, we can use union find to get egde (and its two nodes, `c1`, `c2`) that are in cycle\\n\\n- So now, to find shortest cycle length, we use knwown node pair. We will use BFS to get distance from `c1` to `c2`. BFS gives us shortest distance, when there are no node weights or edge weights.\\n\\n- Since we know there that without `c1 -> c2`, we won\\'t have cycle due. to MST property, we know we must account for this edge, so add +1 to `bfs(c1, c2)`\\n\\n\\n# Complexity\\n- Time complexity: \\n- Space complexity:\\n\\n# Code\\n```\\nfrom collections import defaultdict, deque\\n\\nclass UF:\\n  def __init__(self, n): # O(n)\\n    self.n = n\\n    self.roots = list(range(n))\\n\\n  def find(self, p): # best: O(1), avg: O(lg N), worst: O(n)\\n    if self.roots[p] == p: return p\\n    self.roots[p] = self.find(self.roots[p])\\n    return self.roots[p]\\n\\n  def union(self, p, q):\\n    rootP = self.find(p)\\n    rootQ = self.find(q)\\n\\n    if rootP != rootQ:\\n        self.roots[self.find(p)] = self.find(q)\\n        return True\\n    return False\\n\\n\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        uf = UF(n)\\n        cycles = []\\n\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            if not uf.union(u, v):\\n                cycles.append((u, v))\\n\\n        def dist(begin, end):\\n            q = deque()\\n            q.append((begin, -1, 0))\\n            seen = set()\\n\\n            while q:\\n                node, prev, level = q.popleft()\\n                if node in seen and node == end:\\n                    return level + 1\\n\\n                seen.add(node)\\n                for child in graph[node]:\\n                    if child == node: continue\\n                    if child == prev: continue\\n                    q.append((child, node, level + 1))\\n            \\n            return float(\\'inf\\')\\n\\n        minlen = float(\\'inf\\')\\n        for start, end in cycles:\\n            minlen = min(minlen, dist(start, end))\\n\\n        return -1 if minlen == float(\\'inf\\') else int(minlen)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict, deque\\n\\nclass UF:\\n  def __init__(self, n): # O(n)\\n    self.n = n\\n    self.roots = list(range(n))\\n\\n  def find(self, p): # best: O(1), avg: O(lg N), worst: O(n)\\n    if self.roots[p] == p: return p\\n    self.roots[p] = self.find(self.roots[p])\\n    return self.roots[p]\\n\\n  def union(self, p, q):\\n    rootP = self.find(p)\\n    rootQ = self.find(q)\\n\\n    if rootP != rootQ:\\n        self.roots[self.find(p)] = self.find(q)\\n        return True\\n    return False\\n\\n\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        uf = UF(n)\\n        cycles = []\\n\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            if not uf.union(u, v):\\n                cycles.append((u, v))\\n\\n        def dist(begin, end):\\n            q = deque()\\n            q.append((begin, -1, 0))\\n            seen = set()\\n\\n            while q:\\n                node, prev, level = q.popleft()\\n                if node in seen and node == end:\\n                    return level + 1\\n\\n                seen.add(node)\\n                for child in graph[node]:\\n                    if child == node: continue\\n                    if child == prev: continue\\n                    q.append((child, node, level + 1))\\n            \\n            return float(\\'inf\\')\\n\\n        minlen = float(\\'inf\\')\\n        for start, end in cycles:\\n            minlen = min(minlen, dist(start, end))\\n\\n        return -1 if minlen == float(\\'inf\\') else int(minlen)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891386,
                "title": "easy-and-intuitive-using-dsu-in-c",
                "content": "```\\nclass DSU {\\nprivate:\\n    vector <int> root, rank;\\npublic:\\n    DSU(int n) {\\n        for(int i = 0; i < n; i++) {\\n            root.push_back(i);\\n            rank.push_back(1);\\n        }\\n    }\\n    \\n    bool Union(int u, int v) {\\n        int ru = Find(u), rv = Find(v);\\n        \\n        if(ru != rv) {\\n            if(rank[rv] > rank[ru]) {\\n                root[ru] = rv;\\n                rank[rv] += rank[ru];\\n            }\\n            else {\\n                root[rv] = ru;\\n                rank[ru] += rank[rv];\\n            }\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    } \\n    \\n    int Find(int u) {\\n        if(root[u] == u) {\\n            return u;\\n        }\\n        \\n        return root[u] = Find(root[u]);\\n    } \\n};\\n\\nclass Solution {\\npublic:\\n    int shortestPathLength(vector <unordered_set<int>> &g, int src, int dest) {\\n        queue <tuple<int, int>> q;\\n        vector <bool> vis(g.size(), false);\\n        \\n        q.push({ src, 0 });\\n        vis[src] = true;\\n        \\n        while(!q.empty()) {\\n            auto [ curr, len ] = q.front();\\n            q.pop();\\n            \\n            if(curr == dest) {\\n                // one added to include src -> dest edge\\n                return len >= 2 ? 1 + len : INT_MAX;\\n            }\\n            \\n            for(int ng : g[curr]) {\\n                if(!vis[ng]) {\\n                    q.push({ ng, len + 1 });\\n                    vis[ng] = true;\\n                }\\n            }\\n        }\\n        \\n        return INT_MAX;\\n    }\\n    \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector <unordered_set<int>> g(n);\\n        \\n        DSU dsu(n);\\n        \\n        int shortestCycleLength = INT_MAX;\\n        \\n        for(const vector <int> edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            \\n            if(!dsu.Union(u, v)) {\\n                shortestCycleLength = min(shortestCycleLength, shortestPathLength(g, u, v));\\n            }\\n            \\n            g[u].insert(v);\\n            g[v].insert(u);\\n        }\\n        \\n        return shortestCycleLength == INT_MAX ? -1 : shortestCycleLength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass DSU {\\nprivate:\\n    vector <int> root, rank;\\npublic:\\n    DSU(int n) {\\n        for(int i = 0; i < n; i++) {\\n            root.push_back(i);\\n            rank.push_back(1);\\n        }\\n    }\\n    \\n    bool Union(int u, int v) {\\n        int ru = Find(u), rv = Find(v);\\n        \\n        if(ru != rv) {\\n            if(rank[rv] > rank[ru]) {\\n                root[ru] = rv;\\n                rank[rv] += rank[ru];\\n            }\\n            else {\\n                root[rv] = ru;\\n                rank[ru] += rank[rv];\\n            }\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    } \\n    \\n    int Find(int u) {\\n        if(root[u] == u) {\\n            return u;\\n        }\\n        \\n        return root[u] = Find(root[u]);\\n    } \\n};\\n\\nclass Solution {\\npublic:\\n    int shortestPathLength(vector <unordered_set<int>> &g, int src, int dest) {\\n        queue <tuple<int, int>> q;\\n        vector <bool> vis(g.size(), false);\\n        \\n        q.push({ src, 0 });\\n        vis[src] = true;\\n        \\n        while(!q.empty()) {\\n            auto [ curr, len ] = q.front();\\n            q.pop();\\n            \\n            if(curr == dest) {\\n                // one added to include src -> dest edge\\n                return len >= 2 ? 1 + len : INT_MAX;\\n            }\\n            \\n            for(int ng : g[curr]) {\\n                if(!vis[ng]) {\\n                    q.push({ ng, len + 1 });\\n                    vis[ng] = true;\\n                }\\n            }\\n        }\\n        \\n        return INT_MAX;\\n    }\\n    \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector <unordered_set<int>> g(n);\\n        \\n        DSU dsu(n);\\n        \\n        int shortestCycleLength = INT_MAX;\\n        \\n        for(const vector <int> edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            \\n            if(!dsu.Union(u, v)) {\\n                shortestCycleLength = min(shortestCycleLength, shortestPathLength(g, u, v));\\n            }\\n            \\n            g[u].insert(v);\\n            g[v].insert(u);\\n        }\\n        \\n        return shortestCycleLength == INT_MAX ? -1 : shortestCycleLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878707,
                "title": "easiest-best-solution-bfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(int n, vector<int> adj[]){\\n\\n        int res=1e9;\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> dist(n,1e9);\\n            vector<int> par(n,-1);\\n\\n            dist[i]=0;\\n            queue<int> q;\\n            q.push(i);\\n\\n            while(!q.empty()){\\n                int node=q.front(); q.pop();\\n\\n                for(auto nbr : adj[node]){\\n                    if(dist[nbr]==(int)(1e9)){//not visited then cal dist\\n                        dist[nbr]=dist[node]+1;\\n                        par[nbr]=node;\\n                        q.push(nbr);\\n                    }\\n                    else if(par[node]!=nbr && par[nbr]!=node)\\n                    res=min(res,dist[nbr]+dist[node]+1);\\n                }\\n            }\\n        }\\n\\n        if(res==1e9) return -1;\\n        else return res;\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adj[n];\\n\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        return dfs(n,adj);\\n    }\\n};\\n```\\n\\n**if you find helpful , plz upvote :)**",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(int n, vector<int> adj[]){\\n\\n        int res=1e9;\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> dist(n,1e9);\\n            vector<int> par(n,-1);\\n\\n            dist[i]=0;\\n            queue<int> q;\\n            q.push(i);\\n\\n            while(!q.empty()){\\n                int node=q.front(); q.pop();\\n\\n                for(auto nbr : adj[node]){\\n                    if(dist[nbr]==(int)(1e9)){//not visited then cal dist\\n                        dist[nbr]=dist[node]+1;\\n                        par[nbr]=node;\\n                        q.push(nbr);\\n                    }\\n                    else if(par[node]!=nbr && par[nbr]!=node)\\n                    res=min(res,dist[nbr]+dist[node]+1);\\n                }\\n            }\\n        }\\n\\n        if(res==1e9) return -1;\\n        else return res;\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        \\n        vector<int> adj[n];\\n\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        return dfs(n,adj);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876017,
                "title": "simple-dfs-with-java",
                "content": "# Intuition\\nIdea is to use DFS with length variable to keep track of length of curent cycle. If we see another node that is already visited that means we have a cycle and we can store min of current cycle length and our ans length. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(V *(V + E)\\n\\n- Space complexity:\\nO(V+E)\\n\\n# Code\\n```\\nclass Solution {\\n    Map<Integer,List<Integer>> map=new HashMap<>();\\n    boolean[] visited;\\n    int length=Integer.MAX_VALUE;\\n    public int findShortestCycle(int n, int[][] edges) {\\n        visited=new boolean[n];\\n        for(int i=0;i<n;i++){\\n            map.put(i,new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            map.get(edges[i][0]).add(edges[i][1]);\\n            map.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            callForDFS(i,i,0);\\n        }\\n        return length==Integer.MAX_VALUE?-1:length;\\n    }\\n    public void callForDFS(int source,int parent,int len){\\n        if(len>length){\\n            return;\\n        }\\n        visited[source]=true;\\n        for(int i:map.get(source)){\\n            if(i==parent){\\n                continue;\\n            }\\n            if(visited[i]){\\n                length=Math.min(length,len+1);\\n            }else{\\n                callForDFS(i,source,len+1);\\n            }\\n        }\\n        visited[source]=false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer,List<Integer>> map=new HashMap<>();\\n    boolean[] visited;\\n    int length=Integer.MAX_VALUE;\\n    public int findShortestCycle(int n, int[][] edges) {\\n        visited=new boolean[n];\\n        for(int i=0;i<n;i++){\\n            map.put(i,new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            map.get(edges[i][0]).add(edges[i][1]);\\n            map.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            callForDFS(i,i,0);\\n        }\\n        return length==Integer.MAX_VALUE?-1:length;\\n    }\\n    public void callForDFS(int source,int parent,int len){\\n        if(len>length){\\n            return;\\n        }\\n        visited[source]=true;\\n        for(int i:map.get(source)){\\n            if(i==parent){\\n                continue;\\n            }\\n            if(visited[i]){\\n                length=Math.min(length,len+1);\\n            }else{\\n                callForDFS(i,source,len+1);\\n            }\\n        }\\n        visited[source]=false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846346,
                "title": "using-bfs-c-easy-to-understand-straightforward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse bfs on every vertex \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimilar to Dijkstra\\'s algorithm\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V*(V+E))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(V+E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            vector<int> parent(n,-1);\\n            vector<int> dist(n,1e9);\\n            dist[i]=0;\\n            queue<int> q;\\n            q.push(i);\\n            while(!q.empty()){\\n                int u=q.front();\\n                q.pop();\\n                for(auto v:adj[u]){\\n                    if(dist[v]==1e9){\\n                        dist[v]=1+dist[u];\\n                        parent[v]=u;\\n                        q.push(v);\\n                    }\\n                    else if(parent[v]!=u && parent[u]!=v){\\n                        ans=min(ans,dist[u]+dist[v]+1);\\n                    }\\n                }\\n            }\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            vector<int> parent(n,-1);\\n            vector<int> dist(n,1e9);\\n            dist[i]=0;\\n            queue<int> q;\\n            q.push(i);\\n            while(!q.empty()){\\n                int u=q.front();\\n                q.pop();\\n                for(auto v:adj[u]){\\n                    if(dist[v]==1e9){\\n                        dist[v]=1+dist[u];\\n                        parent[v]=u;\\n                        q.push(v);\\n                    }\\n                    else if(parent[v]!=u && parent[u]!=v){\\n                        ans=min(ans,dist[u]+dist[v]+1);\\n                    }\\n                }\\n            }\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834680,
                "title": "easy-c-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int s,int d,unordered_map<int,vector<int>>&v,int n){\\n        vector<int>dp(n,INT_MAX);\\n        queue<int>q;\\n        q.push(s);\\n        dp[s]=0;\\n        while(!q.empty()){\\n            int top=q.front();\\n            q.pop(); \\n            for(int i=0;i<v[top].size();i++){\\n                if(dp[v[top][i]]!=INT_MAX) continue;\\n                dp[v[top][i]]=dp[top]+1;\\n                if(v[top][i]==d) return dp[v[top][i]];\\n                q.push(v[top][i]);\\n            }\\n        }\\n        return dp[d];\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>>v(n);\\n        for(int i=0;i<edges.size();i++){\\n            v[edges[i][0]].push_back(edges[i][1]);\\n            v[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<edges.size();i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            v[edges[i][0]].erase(remove(v[edges[i][0]].begin(),v[edges[i][0]].end(),edges[i][1]),v[edges[i][0]].end());\\n            v[edges[i][1]].erase(remove(v[edges[i][1]].begin(),v[edges[i][1]].end(),edges[i][0]),v[edges[i][1]].end());\\n            res=min(solve(edges[i][0],edges[i][1],v,n),res);\\n        }\\n        if(res==INT_MAX) return -1;\\n        return res+1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int s,int d,unordered_map<int,vector<int>>&v,int n){\\n        vector<int>dp(n,INT_MAX);\\n        queue<int>q;\\n        q.push(s);\\n        dp[s]=0;\\n        while(!q.empty()){\\n            int top=q.front();\\n            q.pop(); \\n            for(int i=0;i<v[top].size();i++){\\n                if(dp[v[top][i]]!=INT_MAX) continue;\\n                dp[v[top][i]]=dp[top]+1;\\n                if(v[top][i]==d) return dp[v[top][i]];\\n                q.push(v[top][i]);\\n            }\\n        }\\n        return dp[d];\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>>v(n);\\n        for(int i=0;i<edges.size();i++){\\n            v[edges[i][0]].push_back(edges[i][1]);\\n            v[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<edges.size();i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            v[edges[i][0]].erase(remove(v[edges[i][0]].begin(),v[edges[i][0]].end(),edges[i][1]),v[edges[i][0]].end());\\n            v[edges[i][1]].erase(remove(v[edges[i][1]].begin(),v[edges[i][1]].end(),edges[i][0]),v[edges[i][1]].end());\\n            res=min(solve(edges[i][0],edges[i][1],v,n),res);\\n        }\\n        if(res==INT_MAX) return -1;\\n        return res+1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807325,
                "title": "python-hard",
                "content": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n\\n        for start, end in edges:\\n            adj[start].append(end)\\n            adj[end].append(start)\\n\\n        def bfs(node):\\n\\n            q = deque()\\n\\n            q.append((node, -1, 0))\\n\\n            seen = set()\\n\\n            while q:\\n\\n                nxt = deque()\\n\\n                while q:\\n\\n                    curNode, prev, path = q.popleft()\\n\\n                    if path > res:\\n                        continue\\n                    \\n                    if curNode == node and prev != -1:\\n                        return path\\n\\n                    seen.add(curNode)\\n\\n                    for nxtNode in adj[curNode]:\\n                        if nxtNode == prev:\\n                            continue\\n\\n                        nxt.append((nxtNode, curNode, path + 1))\\n                    \\n                q = nxt\\n\\n\\n            return float(\"inf\")\\n\\n                    \\n        res = float(\"inf\")\\n        for node in range(n):\\n            res = min(res, bfs(node))\\n\\n        \\n        return res if res != float(\"inf\") else -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n\\n        for start, end in edges:\\n            adj[start].append(end)\\n            adj[end].append(start)\\n\\n        def bfs(node):\\n\\n            q = deque()\\n\\n            q.append((node, -1, 0))\\n\\n            seen = set()\\n\\n            while q:\\n\\n                nxt = deque()\\n\\n                while q:\\n\\n                    curNode, prev, path = q.popleft()\\n\\n                    if path > res:\\n                        continue\\n                    \\n                    if curNode == node and prev != -1:\\n                        return path\\n\\n                    seen.add(curNode)\\n\\n                    for nxtNode in adj[curNode]:\\n                        if nxtNode == prev:\\n                            continue\\n\\n                        nxt.append((nxtNode, curNode, path + 1))\\n                    \\n                q = nxt\\n\\n\\n            return float(\"inf\")\\n\\n                    \\n        res = float(\"inf\")\\n        for node in range(n):\\n            res = min(res, bfs(node))\\n\\n        \\n        return res if res != float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806995,
                "title": "easiest-hard-problem",
                "content": "\\n\\n# DFS Code\\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void dfs(int node, int parent,int dist, vector<int> &vis, vector<int> adj[], vector<int> &path){\\n        vis[node]=1;\\n        path[node]=dist;\\n        for(auto it: adj[node]){\\n            if(!vis[it]){\\n                dfs(it,node,dist+1,vis,adj,path);\\n            }\\n            else if(it!=parent){\\n                ans=min(ans,1+abs(path[it]-dist));\\n                if(path[it]>dist+1){\\n                    path[it]=dist+1;\\n                }\\n            }\\n        }\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0; i<n; i++){\\n            vector<int> vis(n,0);\\n            vector<int> path(n,INT_MAX);\\n            dfs(i,-1,1,vis,adj,path);\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void dfs(int node, int parent,int dist, vector<int> &vis, vector<int> adj[], vector<int> &path){\\n        vis[node]=1;\\n        path[node]=dist;\\n        for(auto it: adj[node]){\\n            if(!vis[it]){\\n                dfs(it,node,dist+1,vis,adj,path);\\n            }\\n            else if(it!=parent){\\n                ans=min(ans,1+abs(path[it]-dist));\\n                if(path[it]>dist+1){\\n                    path[it]=dist+1;\\n                }\\n            }\\n        }\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0; i<n; i++){\\n            vector<int> vis(n,0);\\n            vector<int> path(n,INT_MAX);\\n            dfs(i,-1,1,vis,adj,path);\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796960,
                "title": "java-90-faster-topology-sort-bfs",
                "content": "# Intuition\\nThe initial idea is clear, we need to run DFS or BFS from each node in a graph and store minum cycle length if founds.\\nThe tricky point is not to go back in bi-directional graph, good solution can be found in this article https://leetcode.com/problems/shortest-cycle-in-a-graph/solutions/3366500/java-c-python-bfs/ \\n\\nThank you to [@pigorski](https://leetcode.com/pigorski/) for working solution.\\n\\nBut I presonally was confused by the fact if find a minimal cycle of `k` nodes, we will need to find it again and again for each of `k` node in the cycle. Do we have any way to reduce the redundant computation?\\n\\n# Optimizations\\n## 1\\nMaybe we can run BFS not for each node in the graph but only for nodes that can be in cycle? \\nIf there is only onve edges for node `x`, so node `x` cant be in a cycle.. So, let\\'s calculate count of edges pernode and ingore all nodes with edges `... < 1`.\\nAlso it can be some long chain `x - y - z`, let\\'s remove node `x` first and then dicrease count of nodes for `y` and repeat the operation. So, we beacome to something similat to Topology sort by `Kahn\\u2019s` algorithm.\\nI used array `degree` for this optimization. \\n## 2\\nThis one is more effiction then optiomization #1. \\nIf found that node `x` in a cycle, the BFS algorithm will return the minimal length where `x` is in cycle path. \\nUnfortinatly I didn\\'t find a way to remove all nodes in cycle from the future computation because it might be a smaller cycle which share the same nodes for example:\\n`1->2->3->4->5->6->1` and `2->3->4->2`.  But we defently can remove the node `x` from the future computation. \\nI usesd array `visited` for thiss optimization and `visited[x]=true` in the end of BFS computation for node.\\nIf the node was `visited` I will not to add it to Queue in BFS, so I will find a cycle `1->2->3->4->5->6->1` only once for node `1`.\\n\\n# Complexity\\n- Time complexity: still `~O(n^2)`\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        int[] degree = new int[n];\\n        Map<Integer, List<Integer>> nodes = new HashMap<>();\\n        for (int[] e : edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            nodes.computeIfAbsent(u, k -> new ArrayList<Integer>()).add(v);\\n            nodes.computeIfAbsent(v, k -> new ArrayList<Integer>()).add(u);\\n            degree[v]++;\\n            degree[u]++;\\n        }\\n\\n        {\\n            LinkedList<Integer> queue = new LinkedList<>();\\n            for (int i=0; i<n; i++) {\\n                if (degree[i] == 1) {\\n                    queue.add(i);\\n                }\\n            }\\n            while (!queue.isEmpty()) {\\n                var node = queue.poll();\\n                degree[node]--;\\n                for (int next : nodes.getOrDefault(node, Collections.emptyList())) {\\n                    degree[next]--;\\n                    if (degree[next] == 1) {\\n                        queue.add(next);\\n                    }\\n                }\\n            }\\n        }\\n\\n        boolean[] visited = new boolean[n];\\n        Function<Integer, Integer> minPath = root -> {\\n            LinkedList<Integer> queue = new LinkedList<>();\\n            queue.add(root);\\n            \\n            int dist = 0;\\n            Map<Integer, Integer> dists = new HashMap<>();\\n            dists.put(root, dist);\\n            int localMin = Integer.MAX_VALUE;\\n            while (!queue.isEmpty()) {\\n                for (int sz=queue.size(); sz > 0; sz--) {\\n                    int curr = queue.poll();\\n                    if (dists.containsKey(curr)) {\\n                        dists.put(curr, Math.min(dist, dists.get(curr)));\\n                    }\\n                    for (int next : nodes.getOrDefault(curr, Collections.emptyList())) {\\n                        if (visited[next]) continue;\\n                        \\n                        if (!dists.containsKey(next)) {\\n                            dists.put(next, dist + 1);\\n                            queue.add(next);\\n                        } else { //cycle found\\n                            int distToNext = dists.get(next);\\n                            int distToCurr = dists.get(curr);\\n                            if (distToCurr <= distToNext) {\\n                                localMin = Math.min(localMin, distToNext + distToCurr + 1);\\n                            }\\n                        }\\n                    }\\n                }\\n                dist++;\\n            }\\n            visited[root] = true;\\n            return localMin;\\n        };\\n        \\n        int min = n + 1;\\n        for (int i=0; i<n; i++) {\\n            if (degree[i] > 1)\\n                min = Math.min(min, minPath.apply(i));\\n        }\\n\\n        return min > n ? -1 : min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        int[] degree = new int[n];\\n        Map<Integer, List<Integer>> nodes = new HashMap<>();\\n        for (int[] e : edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            nodes.computeIfAbsent(u, k -> new ArrayList<Integer>()).add(v);\\n            nodes.computeIfAbsent(v, k -> new ArrayList<Integer>()).add(u);\\n            degree[v]++;\\n            degree[u]++;\\n        }\\n\\n        {\\n            LinkedList<Integer> queue = new LinkedList<>();\\n            for (int i=0; i<n; i++) {\\n                if (degree[i] == 1) {\\n                    queue.add(i);\\n                }\\n            }\\n            while (!queue.isEmpty()) {\\n                var node = queue.poll();\\n                degree[node]--;\\n                for (int next : nodes.getOrDefault(node, Collections.emptyList())) {\\n                    degree[next]--;\\n                    if (degree[next] == 1) {\\n                        queue.add(next);\\n                    }\\n                }\\n            }\\n        }\\n\\n        boolean[] visited = new boolean[n];\\n        Function<Integer, Integer> minPath = root -> {\\n            LinkedList<Integer> queue = new LinkedList<>();\\n            queue.add(root);\\n            \\n            int dist = 0;\\n            Map<Integer, Integer> dists = new HashMap<>();\\n            dists.put(root, dist);\\n            int localMin = Integer.MAX_VALUE;\\n            while (!queue.isEmpty()) {\\n                for (int sz=queue.size(); sz > 0; sz--) {\\n                    int curr = queue.poll();\\n                    if (dists.containsKey(curr)) {\\n                        dists.put(curr, Math.min(dist, dists.get(curr)));\\n                    }\\n                    for (int next : nodes.getOrDefault(curr, Collections.emptyList())) {\\n                        if (visited[next]) continue;\\n                        \\n                        if (!dists.containsKey(next)) {\\n                            dists.put(next, dist + 1);\\n                            queue.add(next);\\n                        } else { //cycle found\\n                            int distToNext = dists.get(next);\\n                            int distToCurr = dists.get(curr);\\n                            if (distToCurr <= distToNext) {\\n                                localMin = Math.min(localMin, distToNext + distToCurr + 1);\\n                            }\\n                        }\\n                    }\\n                }\\n                dist++;\\n            }\\n            visited[root] = true;\\n            return localMin;\\n        };\\n        \\n        int min = n + 1;\\n        for (int i=0; i<n; i++) {\\n            if (degree[i] > 1)\\n                min = Math.min(min, minPath.apply(i));\\n        }\\n\\n        return min > n ? -1 : min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792453,
                "title": "simple-java-bfs-easy-solution",
                "content": "# Intuition\\nRun BFS on each node and find the length smallest cycle including that node. And since we\\'re running BFS on each node the cycle we will find will be the smallest. and also check a corner condition where if a node is visited then check if they are not directly connected (they\\'re not parents of each other).\\n\\n# Complexity\\n- Time complexity:\\nO((V + E)^2)\\n\\n- Space complexity:\\nO(V + E)\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    \\n    public int bfs(int src, ArrayList<ArrayList<Integer>> adj, int n){\\n        \\n        int[] vis = new int[n];\\n        int[] par = new int[n];\\n        Arrays.fill(par, -1);\\n        \\n        Arrays.fill(vis, -1);\\n        vis[src] = 0;\\n        \\n        Queue<Integer> q= new LinkedList<>();\\n        q.add(src);\\n        \\n        int len = (int) 1e9;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int curr = q.remove();\\n            \\n            ArrayList<Integer> adjcent = adj.get(curr);\\n            \\n            for(int i=0; i<adjcent.size(); i++){\\n                \\n                int next = adjcent.get(i);\\n                \\n                if(vis[next] == -1){\\n                    vis[next] = vis[curr] + 1;\\n                    par[next] = curr;\\n                    q.add(next);\\n                } else{\\n                    \\n                    if(par[curr] != next && par[next] != curr){\\n                    \\n                    len = Math.min(len, vis[next] + vis[curr] + 1);\\n                    }\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return len;\\n        \\n    }\\n    \\n    public int findShortestCycle(int n, int[][] edges) {\\n        \\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n        \\n        for(int i=0; i<edges.length; i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            \\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        \\n        int len = (int) 1e9;\\n        for(int i=0; i<n; i++){\\n            \\n            len = Math.min(len, bfs(i, adj, n));\\n            \\n        }\\n        \\n        if(len == (int) 1e9) return -1;\\n        \\n        return len;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    \\n    public int bfs(int src, ArrayList<ArrayList<Integer>> adj, int n){\\n        \\n        int[] vis = new int[n];\\n        int[] par = new int[n];\\n        Arrays.fill(par, -1);\\n        \\n        Arrays.fill(vis, -1);\\n        vis[src] = 0;\\n        \\n        Queue<Integer> q= new LinkedList<>();\\n        q.add(src);\\n        \\n        int len = (int) 1e9;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int curr = q.remove();\\n            \\n            ArrayList<Integer> adjcent = adj.get(curr);\\n            \\n            for(int i=0; i<adjcent.size(); i++){\\n                \\n                int next = adjcent.get(i);\\n                \\n                if(vis[next] == -1){\\n                    vis[next] = vis[curr] + 1;\\n                    par[next] = curr;\\n                    q.add(next);\\n                } else{\\n                    \\n                    if(par[curr] != next && par[next] != curr){\\n                    \\n                    len = Math.min(len, vis[next] + vis[curr] + 1);\\n                    }\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return len;\\n        \\n    }\\n    \\n    public int findShortestCycle(int n, int[][] edges) {\\n        \\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n        \\n        for(int i=0; i<edges.length; i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            \\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        \\n        int len = (int) 1e9;\\n        for(int i=0; i<n; i++){\\n            \\n            len = Math.min(len, bfs(i, adj, n));\\n            \\n        }\\n        \\n        if(len == (int) 1e9) return -1;\\n        \\n        return len;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783213,
                "title": "clean-easiest-approach-with-bfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 1e9+6;\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n\\n        vector<vector<int>>gr(n);\\n\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            gr[edges[i][0]].push_back(edges[i][1]);\\n            gr[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>d(n,1e9+8);\\n            queue<int>q;\\n            vector<bool>vis(n,false);\\n            vector<int>par(n,-2);\\n\\n            q.push(i); d[i]=0;\\n            while(!q.empty())\\n            {\\n                int ind = q.front();\\n                q.pop();\\n                vis[ind]=true;\\n                for(auto it:gr[ind])\\n                {\\n                    if(!vis[it])\\n                    {\\n                        vis[it]=true;\\n                        d[it] = 1+d[ind];\\n                        par[it]=ind;\\n                        q.push(it);\\n                    }\\n                    else if(par[it]!=ind and par[ind]!=it)\\n                    {\\n                        ans = min(ans,d[it]+d[ind]+1);\\n                    }\\n                }\\n            }\\n        }\\n        if(ans>1e9)return -1;\\n        else return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 1e9+6;\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n\\n        vector<vector<int>>gr(n);\\n\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            gr[edges[i][0]].push_back(edges[i][1]);\\n            gr[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>d(n,1e9+8);\\n            queue<int>q;\\n            vector<bool>vis(n,false);\\n            vector<int>par(n,-2);\\n\\n            q.push(i); d[i]=0;\\n            while(!q.empty())\\n            {\\n                int ind = q.front();\\n                q.pop();\\n                vis[ind]=true;\\n                for(auto it:gr[ind])\\n                {\\n                    if(!vis[it])\\n                    {\\n                        vis[it]=true;\\n                        d[it] = 1+d[ind];\\n                        par[it]=ind;\\n                        q.push(it);\\n                    }\\n                    else if(par[it]!=ind and par[ind]!=it)\\n                    {\\n                        ans = min(ans,d[it]+d[ind]+1);\\n                    }\\n                }\\n            }\\n        }\\n        if(ans>1e9)return -1;\\n        else return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782575,
                "title": "memory-efficient-solution-with-circular-queue-beats-100-js-solutions",
                "content": "![image.png](https://assets.leetcode.com/users/images/d2063dfd-e7c2-4f7a-97b5-63105e60e9e2_1689674713.5497398.png)\\n\\n\\n# Intuition\\nThe shortest cycle that includes an edge `e = [u, v]` is `e` itself combines with the shortest path from `u` to `v` when `e` is ignored from the graph; if such shortest path doesn\\'t exist, we can conclude that `e` does not belong to any cycles.\\n\\n# Approach\\n- Since the constrain of `edges.length` is pretty small, we can iterate through each edge, try removing it as well as find the shortest path on the remaining graph. \\n- The common algorithm to find shortest path is **Breadth-First Search** (or **BFS**).\\n\\n- **Optimization 1**: Note that we can utilize `visited` to store the length of the shortest path from the original node.\\n- **Optimization 2**: We don\\'t need to create a new `visited` and a new `queue` every single time we make a call to BFS. The idea is just using one `visited` and `queue` for all and resetting them each time we start BFS.\\n- **Optimization 3**: The fastest way to reset a queue is... not resetting it at all! The common way to implement queue is to use an array `a` with a variable `bottom`, indicating `a[bottom]` is the first element in the queue. Therefore, resetting queue is just setting `bottom = a.length`. After that, we can continue to append new items to `a`.\\n- **Optimization 4**: Notice that the real \"queue\" would never exceed `n` elements. Therefore, we can avoiding wasting memories to store old elements in the `queue` by using **circular queue** with `capacity = n`.\\n\\n# Complexity\\n- let `m = edges.length`.\\n- Time complexity: $$O(m * (m + n))$$\\n- Space complexity: $$O(m + n)$$ (we need to store the **graph**, queue storage only requires $$O(n)$$)\\n\\n# Code\\n```jsx\\n/**\\n * @template TItem\\n */\\nclass CircularQueue {\\n  /**\\n   * @param {number} capacity\\n   */\\n  constructor(capacity) {\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._capacity = capacity;\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._size = 0;\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._bottom = 0;\\n\\n    /**\\n     * @private\\n     * @type {TItem[]}\\n     */\\n    this._data = Array(capacity).fill(undefined);\\n  }\\n\\n  get size() {\\n    return this._size;\\n  }\\n\\n  /**\\n   * @param  {...TItem} items\\n   */\\n  enqueue(...items) {\\n    if (this._size + items.length > this._capacity) throw new Error(\"Queue capacity exceeded.\");\\n\\n    let queueIndex = (this._bottom + this._size) % this._capacity;\\n    this._size += items.length;\\n    for (let i = 0; i < items.length; i++) {\\n      this._data[queueIndex] = items[i];\\n      queueIndex = (queueIndex + 1) % this._capacity;\\n    }\\n  }\\n\\n  /**\\n   * @returns {TItem | undefined}\\n   */\\n  dequeue() {\\n    if (!this._size) return undefined;\\n\\n    const result = this._data[this._bottom];\\n    this._bottom = (this._bottom + 1) % this._capacity;\\n    this._size--;\\n\\n    return result;\\n  }\\n\\n  clear() {\\n    this._size = 0;\\n  }\\n}\\n\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar findShortestCycle = function(n, edges) {\\n  const oo = 1000000000;\\n  let result = oo;\\n\\n  /** @type {number[][]} */\\n  const graph = [];\\n  for (let i = 0; i < n; i++) graph.push([]);\\n  for (let i = 0; i < edges.length; i++) {\\n    graph[edges[i][0]].push(edges[i][1]);\\n    graph[edges[i][1]].push(edges[i][0]);\\n  } \\n\\n  const q = new CircularQueue(n);\\n  const visited = Array(n);\\n  \\n  function bfs(fr, to) {\\n    visited.fill(0);\\n    q.clear();\\n    q.enqueue(fr);\\n    visited[fr] = 1;\\n\\n    while (q.size) {\\n      const curr = q.dequeue();\\n      const newVisited = visited[curr] + 1;\\n\\n      for (let next of graph[curr]) {\\n        if (visited[next]) continue;\\n        if (next === to) {\\n          if (curr === fr) continue;\\n          return newVisited;\\n        }\\n        q.enqueue(next);\\n        visited[next] = newVisited;\\n      }\\n    }\\n\\n    return oo;\\n  }\\n\\n  edges.forEach(edge => {\\n    result = Math.min(result, bfs(...edge));\\n  })\\n\\n  return result === oo? -1 : result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```jsx\\n/**\\n * @template TItem\\n */\\nclass CircularQueue {\\n  /**\\n   * @param {number} capacity\\n   */\\n  constructor(capacity) {\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._capacity = capacity;\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._size = 0;\\n    /**\\n     * @private\\n     * @type {number}\\n     */\\n    this._bottom = 0;\\n\\n    /**\\n     * @private\\n     * @type {TItem[]}\\n     */\\n    this._data = Array(capacity).fill(undefined);\\n  }\\n\\n  get size() {\\n    return this._size;\\n  }\\n\\n  /**\\n   * @param  {...TItem} items\\n   */\\n  enqueue(...items) {\\n    if (this._size + items.length > this._capacity) throw new Error(\"Queue capacity exceeded.\");\\n\\n    let queueIndex = (this._bottom + this._size) % this._capacity;\\n    this._size += items.length;\\n    for (let i = 0; i < items.length; i++) {\\n      this._data[queueIndex] = items[i];\\n      queueIndex = (queueIndex + 1) % this._capacity;\\n    }\\n  }\\n\\n  /**\\n   * @returns {TItem | undefined}\\n   */\\n  dequeue() {\\n    if (!this._size) return undefined;\\n\\n    const result = this._data[this._bottom];\\n    this._bottom = (this._bottom + 1) % this._capacity;\\n    this._size--;\\n\\n    return result;\\n  }\\n\\n  clear() {\\n    this._size = 0;\\n  }\\n}\\n\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar findShortestCycle = function(n, edges) {\\n  const oo = 1000000000;\\n  let result = oo;\\n\\n  /** @type {number[][]} */\\n  const graph = [];\\n  for (let i = 0; i < n; i++) graph.push([]);\\n  for (let i = 0; i < edges.length; i++) {\\n    graph[edges[i][0]].push(edges[i][1]);\\n    graph[edges[i][1]].push(edges[i][0]);\\n  } \\n\\n  const q = new CircularQueue(n);\\n  const visited = Array(n);\\n  \\n  function bfs(fr, to) {\\n    visited.fill(0);\\n    q.clear();\\n    q.enqueue(fr);\\n    visited[fr] = 1;\\n\\n    while (q.size) {\\n      const curr = q.dequeue();\\n      const newVisited = visited[curr] + 1;\\n\\n      for (let next of graph[curr]) {\\n        if (visited[next]) continue;\\n        if (next === to) {\\n          if (curr === fr) continue;\\n          return newVisited;\\n        }\\n        q.enqueue(next);\\n        visited[next] = newVisited;\\n      }\\n    }\\n\\n    return oo;\\n  }\\n\\n  edges.forEach(edge => {\\n    result = Math.min(result, bfs(...edge));\\n  })\\n\\n  return result === oo? -1 : result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778585,
                "title": "path-visited-dfs-striver-distarray",
                "content": "# Intuition\\nsimply explore all the paths and here use a path viisted array that can track your current path simply check it to 1 and during backtrak simply uncheck the path visited with 0 so that u can explore the other path too which goes through that node and carry a Dist array to store the min distance\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int src,int prnt,vector<int>&dis,int &ans,vector<int>adj[],int ini_dis,vector<int>&path_visited)\\n    {\\n        dis[src]=1+ini_dis;\\n        path_visited[src]=1;\\n\\n        for(auto it:adj[src])\\n        {\\n            if(it!=prnt && path_visited[it]==1)\\n                 ans=min(ans,abs(dis[it]-dis[src]));\\n            else if(it!=prnt && path_visited[it]==0 && dis[src]+1<dis[it])\\n            {\\n                dfs(it,src,dis,ans,adj,dis[src],path_visited);\\n            }\\n        }\\n        path_visited[src]=0;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) \\n    {\\n       \\n        vector<int>dis(n,1e9);\\n        vector<int>adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n         int ans=INT_MAX;\\n         vector<int>path_visited(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dis[i]==1e9)\\n            {   \\n                \\n                dfs(i,-1,dis,ans,adj,-1,path_visited);\\n                cout<<ans<<endl;\\n            }\\n        }\\n        \\n        if(ans==INT_MAX) return -1;\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(int src,int prnt,vector<int>&dis,int &ans,vector<int>adj[],int ini_dis,vector<int>&path_visited)\\n    {\\n        dis[src]=1+ini_dis;\\n        path_visited[src]=1;\\n\\n        for(auto it:adj[src])\\n        {\\n            if(it!=prnt && path_visited[it]==1)\\n                 ans=min(ans,abs(dis[it]-dis[src]));\\n            else if(it!=prnt && path_visited[it]==0 && dis[src]+1<dis[it])\\n            {\\n                dfs(it,src,dis,ans,adj,dis[src],path_visited);\\n            }\\n        }\\n        path_visited[src]=0;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) \\n    {\\n       \\n        vector<int>dis(n,1e9);\\n        vector<int>adj[n];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n         int ans=INT_MAX;\\n         vector<int>path_visited(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dis[i]==1e9)\\n            {   \\n                \\n                dfs(i,-1,dis,ans,adj,-1,path_visited);\\n                cout<<ans<<endl;\\n            }\\n        }\\n        \\n        if(ans==INT_MAX) return -1;\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3773028,
                "title": "c-bfs",
                "content": "# Intuition\\nFor each edge (start, end) we are trying to find a shortest path between start, end that does not go throw the edge. This is done using BFS. For optimization purposes we do not run searchers that a longer than the best known answer so far.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindShortestCycle(int n, int[][] edges) \\n    {\\n        var graph = new Dictionary<int, HashSet<int>>();\\n\\n        foreach(var edge in edges)\\n        {\\n            graph.TryAdd(edge[0], new HashSet<int>());\\n            graph.TryAdd(edge[1], new HashSet<int>());\\n\\n            graph[edge[0]].Add(edge[1]);\\n            graph[edge[1]].Add(edge[0]);\\n        }\\n\\n        \\n        var result = int.MaxValue;\\n        \\n        foreach(var edge in edges)\\n        {\\n            var start = edge[0];\\n            var end = edge[1];\\n\\n            graph[start].Remove(end);\\n            graph[end].Remove(start);\\n\\n            var toVisit = new HashSet<int>() {start};\\n            var count = 0;\\n\\n            var visited = new HashSet<int>();\\n\\n            while(toVisit.Count > 0 && count - 5 <= result)\\n            {\\n                var newToVisit = new HashSet<int>();\\n\\n                ++count;\\n                foreach(var candidate in toVisit)\\n                {\\n                    foreach(var newCandidate in graph[candidate])\\n                    {\\n                        if(newCandidate == end)\\n                        {\\n                            result = Math.Min(result, count + 1);\\n                            break;\\n                        }\\n\\n                        if(!visited.Contains(newCandidate))\\n                        {\\n                            newToVisit.Add(newCandidate);\\n                        }\\n                    }\\n                    visited.Add(candidate);\\n                }\\n\\n                toVisit = newToVisit;\\n            }\\n\\n            graph[start].Add(end);\\n            graph[end].Add(start);\\n        }\\n\\n        return result == int.MaxValue ? -1 : result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindShortestCycle(int n, int[][] edges) \\n    {\\n        var graph = new Dictionary<int, HashSet<int>>();\\n\\n        foreach(var edge in edges)\\n        {\\n            graph.TryAdd(edge[0], new HashSet<int>());\\n            graph.TryAdd(edge[1], new HashSet<int>());\\n\\n            graph[edge[0]].Add(edge[1]);\\n            graph[edge[1]].Add(edge[0]);\\n        }\\n\\n        \\n        var result = int.MaxValue;\\n        \\n        foreach(var edge in edges)\\n        {\\n            var start = edge[0];\\n            var end = edge[1];\\n\\n            graph[start].Remove(end);\\n            graph[end].Remove(start);\\n\\n            var toVisit = new HashSet<int>() {start};\\n            var count = 0;\\n\\n            var visited = new HashSet<int>();\\n\\n            while(toVisit.Count > 0 && count - 5 <= result)\\n            {\\n                var newToVisit = new HashSet<int>();\\n\\n                ++count;\\n                foreach(var candidate in toVisit)\\n                {\\n                    foreach(var newCandidate in graph[candidate])\\n                    {\\n                        if(newCandidate == end)\\n                        {\\n                            result = Math.Min(result, count + 1);\\n                            break;\\n                        }\\n\\n                        if(!visited.Contains(newCandidate))\\n                        {\\n                            newToVisit.Add(newCandidate);\\n                        }\\n                    }\\n                    visited.Add(candidate);\\n                }\\n\\n                toVisit = newToVisit;\\n            }\\n\\n            graph[start].Add(end);\\n            graph[end].Add(start);\\n        }\\n\\n        return result == int.MaxValue ? -1 : result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764573,
                "title": "python",
                "content": "# Code\\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n\\n\\n        graph = defaultdict(list)\\n        for i in range(len(edges)):\\n            graph[edges[i][0]].append(edges[i][1])\\n            graph[edges[i][1]].append(edges[i][0])\\n        print(graph)\\n        def bfs(i):\\n            res = float(\\'inf\\')\\n            for j in graph[i]:\\n                visited = [False for _ in range(n)]\\n                visited[i] = True\\n                visited[j] = True\\n                q = deque()\\n                q.append((j, 1)) \\n                while q:\\n                    node, d = q.popleft()\\n\\n                    for nei in graph[node]:\\n                        if nei == i:\\n                            if d+1 != 2:\\n                                res = min(res, d+1)\\n                        if not visited[nei]:\\n                            q.append((nei, d+1))\\n                            visited[nei] = True\\n            if res == 2:\\n                return -1\\n\\n            return res\\n            \\n\\n        ans = float(\\'inf\\')\\n        for i in range(n):\\n            r = bfs(i)\\n            print(r, i)\\n            if r != -1:\\n                ans = min(ans, r)\\n        \\n        if ans == float(\\'inf\\'):\\n            return -1\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n\\n\\n        graph = defaultdict(list)\\n        for i in range(len(edges)):\\n            graph[edges[i][0]].append(edges[i][1])\\n            graph[edges[i][1]].append(edges[i][0])\\n        print(graph)\\n        def bfs(i):\\n            res = float(\\'inf\\')\\n            for j in graph[i]:\\n                visited = [False for _ in range(n)]\\n                visited[i] = True\\n                visited[j] = True\\n                q = deque()\\n                q.append((j, 1)) \\n                while q:\\n                    node, d = q.popleft()\\n\\n                    for nei in graph[node]:\\n                        if nei == i:\\n                            if d+1 != 2:\\n                                res = min(res, d+1)\\n                        if not visited[nei]:\\n                            q.append((nei, d+1))\\n                            visited[nei] = True\\n            if res == 2:\\n                return -1\\n\\n            return res\\n            \\n\\n        ans = float(\\'inf\\')\\n        for i in range(n):\\n            r = bfs(i)\\n            print(r, i)\\n            if r != -1:\\n                ans = min(ans, r)\\n        \\n        if ans == float(\\'inf\\'):\\n            return -1\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759992,
                "title": "hehe-bfs-o-n",
                "content": "# Intuition\\nWe want shortest cycle so to check a cycle i need a point and see oh i visited it again so it must form a cycle. so i take any single point from all the cycle and make my applying bfs on each point \\n\\nNow you collect the point by applying DFS if your reach a visited vertex which aint it parent than it is a node in the cycle \\n\\nNow apply BFS, on the collected nodes \\n![Capture.PNG](https://assets.leetcode.com/users/images/9d3fea04-5a21-4af3-9cab-6710bc6f79a2_1689262586.0513668.png)\\nfrom above graph by applying dfs 2 node will be given (1 and 6)\\n\\nNow i start applying BFS as first on node 1\\nA vector marking start node of each bfs is kept because a bfs will consider all the possible cycles in which node 1 is \\nSo if node 6 has node 1 common in a cycle i dont need to check this cycle \\nNow return minimum\\n\\n\\n# Complexity\\nO(n)\\n\\n\\n\\n\\n# Code\\n```\\nclass Pair {\\npublic:\\nint p ;\\nint d;\\nint st;\\nPair(int p , int d , int st){\\n    this->p = p;\\n    this->d = d;\\n    this->st = st;\\n}\\n};\\nclass Solution {\\npublic:\\n    int ans = 1001;\\n    void dfs(vector<int>&visited , vector<vector<int>>&g, int st, set<int>&list ,int p  ){\\n        \\n       visited[st] = 1;\\n       for(auto x : g[st]){\\n           if(x == p){\\n               continue;\\n           }\\n           if(visited[x] == -1){\\n           dfs(visited , g, x, list  , st);}\\n           else {\\n               list.insert(x);\\n           }\\n       }\\n    }\\n    void bfs ( vector<vector<int>>&g, int st , vector<int>&visited){\\n         queue<Pair>q;\\n         q.push(Pair(st, 0 , st));\\n        \\n         while(q.size() > 0 ){\\n             Pair top = q.front();\\n             q.pop();\\n             \\n             if(top.st == st && top.p != st){\\n                \\n               ans = min(ans, top.d);\\n               return;\\n             }\\n             for(auto x : g[top.st]){\\n              \\n                 if(x == top.p || (visited[x] == 1 && x  != st)){\\n                   \\n                     continue;\\n                 }\\n                  q.push(Pair(top.st, top.d + 1 ,x ));\\n             }\\n         }\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>g(n);\\n        for(int i  = 0 ; i<edges.size(); i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        vector<int>visited(n, -1);\\n        set<int>list;\\n        for(int i = 0 ; i<n ;i++){\\n            if(visited[i] == -1){\\n        dfs(visited ,g, i , list, i);\\n\\n            }\\n        }\\n \\n        vector<int>visited2(n, -1);\\n   \\n        for(auto x : list){\\n            visited2[x] = 1;\\n            bfs(g, x , visited2);\\n        }\\n        if(ans == 1001){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Pair {\\npublic:\\nint p ;\\nint d;\\nint st;\\nPair(int p , int d , int st){\\n    this->p = p;\\n    this->d = d;\\n    this->st = st;\\n}\\n};\\nclass Solution {\\npublic:\\n    int ans = 1001;\\n    void dfs(vector<int>&visited , vector<vector<int>>&g, int st, set<int>&list ,int p  ){\\n        \\n       visited[st] = 1;\\n       for(auto x : g[st]){\\n           if(x == p){\\n               continue;\\n           }\\n           if(visited[x] == -1){\\n           dfs(visited , g, x, list  , st);}\\n           else {\\n               list.insert(x);\\n           }\\n       }\\n    }\\n    void bfs ( vector<vector<int>>&g, int st , vector<int>&visited){\\n         queue<Pair>q;\\n         q.push(Pair(st, 0 , st));\\n        \\n         while(q.size() > 0 ){\\n             Pair top = q.front();\\n             q.pop();\\n             \\n             if(top.st == st && top.p != st){\\n                \\n               ans = min(ans, top.d);\\n               return;\\n             }\\n             for(auto x : g[top.st]){\\n              \\n                 if(x == top.p || (visited[x] == 1 && x  != st)){\\n                   \\n                     continue;\\n                 }\\n                  q.push(Pair(top.st, top.d + 1 ,x ));\\n             }\\n         }\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>g(n);\\n        for(int i  = 0 ; i<edges.size(); i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        vector<int>visited(n, -1);\\n        set<int>list;\\n        for(int i = 0 ; i<n ;i++){\\n            if(visited[i] == -1){\\n        dfs(visited ,g, i , list, i);\\n\\n            }\\n        }\\n \\n        vector<int>visited2(n, -1);\\n   \\n        for(auto x : list){\\n            visited2[x] = 1;\\n            bfs(g, x , visited2);\\n        }\\n        if(ans == 1001){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693201,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    void bfs(vector<vector<int>> &g,int n, int source, int &ans) \\n    {\\n        queue<int> q;\\n        vector<int> d(n,-1);\\n\\n        q.push(source);\\n        d[source]=0;\\n\\n        while(!q.empty()) \\n        {\\n            int x=q.front();\\n            q.pop();\\n\\n            for(int i=0;i<g[x].size();i++) \\n            {\\n                if(d[g[x][i]]==-1) \\n                {\\n                    d[g[x][i]]=d[x]+1;\\n                    q.push(g[x][i]);\\n                }\\n\\n                else if(d[g[x][i]]>=d[x]) \\n                {\\n                    ans=min(ans,d[g[x][i]]+d[x]+1);\\n                }\\n            }\\n        }\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) \\n    {\\n        int ans;\\n        ans=INT_MAX;\\n\\n        vector<vector<int>> g(n);\\n\\n        for(int i=0;i<edges.size();i++) \\n        {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            bfs(g,n,i,ans);\\n        } \\n\\n        return ans==INT_MAX?-1:ans;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void bfs(vector<vector<int>> &g,int n, int source, int &ans) \\n    {\\n        queue<int> q;\\n        vector<int> d(n,-1);\\n\\n        q.push(source);\\n        d[source]=0;\\n\\n        while(!q.empty()) \\n        {\\n            int x=q.front();\\n            q.pop();\\n\\n            for(int i=0;i<g[x].size();i++) \\n            {\\n                if(d[g[x][i]]==-1) \\n                {\\n                    d[g[x][i]]=d[x]+1;\\n                    q.push(g[x][i]);\\n                }\\n\\n                else if(d[g[x][i]]>=d[x]) \\n                {\\n                    ans=min(ans,d[g[x][i]]+d[x]+1);\\n                }\\n            }\\n        }\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) \\n    {\\n        int ans;\\n        ans=INT_MAX;\\n\\n        vector<vector<int>> g(n);\\n\\n        for(int i=0;i<edges.size();i++) \\n        {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            bfs(g,n,i,ans);\\n        } \\n\\n        return ans==INT_MAX?-1:ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647081,
                "title": "c-easy-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n+1];\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>dis(n,-1);\\n            queue<pair<int,int>>q;\\n            q.push({i,-1});\\n            dis[i]=0;\\n            while(!q.empty())\\n            {\\n                auto [node,parent]=q.front();\\n                q.pop();\\n                for(auto it:adj[node])\\n                {\\n                    if(dis[it]==-1)\\n                    {\\n                        dis[it]=dis[node]+1;\\n                        q.push({it,node});\\n                    }\\n                    else if(it!=parent)\\n                    {\\n                        ans=min(ans,dis[node]+dis[it]+1);\\n                    }\\n                }\\n            }\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n+1];\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>dis(n,-1);\\n            queue<pair<int,int>>q;\\n            q.push({i,-1});\\n            dis[i]=0;\\n            while(!q.empty())\\n            {\\n                auto [node,parent]=q.front();\\n                q.pop();\\n                for(auto it:adj[node])\\n                {\\n                    if(dis[it]==-1)\\n                    {\\n                        dis[it]=dis[node]+1;\\n                        q.push({it,node});\\n                    }\\n                    else if(it!=parent)\\n                    {\\n                        ans=min(ans,dis[node]+dis[it]+1);\\n                    }\\n                }\\n            }\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644036,
                "title": "java-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++)\\n            adj.add(new ArrayList<Integer>());\\n        for (int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            dfs(adj, new HashSet<Integer>(), i);\\n        }\\n\\n        return min == Integer.MAX_VALUE ? - 1 : min;\\n    }\\n\\n    void dfs(List<List<Integer>> adj, Set<Integer> set, int node) {\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        set.add(node);\\n        int level = 1;\\n        queue.add(new int[] {node, node});\\n\\n        int[] distance = new int[adj.size()];\\n        Arrays.fill(distance, -1);\\n        distance[node] = 0;\\n\\n        while (!queue.isEmpty()) {\\n            \\n            int[] arr = queue.poll();\\n            int topNode = arr[0];\\n            int  from = arr[1];\\n            \\n\\n            for  (int i : adj.get(topNode)) {\\n                if (i == from)\\n                    continue;\\n                if (set.contains(i)) {\\n                    min = Math.min(min, distance[topNode] + distance[i] + 1);\\n                    continue;\\n                }\\n\\n                set.add(i);\\n                distance[i] = distance[topNode] + 1;\\n                queue.add(new int[] {i, topNode});\\n\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++)\\n            adj.add(new ArrayList<Integer>());\\n        for (int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            dfs(adj, new HashSet<Integer>(), i);\\n        }\\n\\n        return min == Integer.MAX_VALUE ? - 1 : min;\\n    }\\n\\n    void dfs(List<List<Integer>> adj, Set<Integer> set, int node) {\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        set.add(node);\\n        int level = 1;\\n        queue.add(new int[] {node, node});\\n\\n        int[] distance = new int[adj.size()];\\n        Arrays.fill(distance, -1);\\n        distance[node] = 0;\\n\\n        while (!queue.isEmpty()) {\\n            \\n            int[] arr = queue.poll();\\n            int topNode = arr[0];\\n            int  from = arr[1];\\n            \\n\\n            for  (int i : adj.get(topNode)) {\\n                if (i == from)\\n                    continue;\\n                if (set.contains(i)) {\\n                    min = Math.min(min, distance[topNode] + distance[i] + 1);\\n                    continue;\\n                }\\n\\n                set.add(i);\\n                distance[i] = distance[topNode] + 1;\\n                queue.add(new int[] {i, topNode});\\n\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617856,
                "title": "c",
                "content": "```\\nclass Solution {\\n    int n ;\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        this->n = n ;\\n        vector<unordered_set<int>>next(n) ;        \\n        for(auto& e : edges){\\n            int u = e[0] ;\\n            int v = e[1] ;\\n            next[u].insert(v) ;\\n            next[v].insert(u) ;\\n        }\\n        int ret = INT_MAX ;\\n        for(auto& e : edges){\\n            int u = e[0] ;\\n            int v = e[1] ;\\n            next[u].erase(v) ;\\n            next[v].erase(u) ;            \\n            ret = fmin(ret, BFS(u, v, next)) ;\\n            next[u].insert(v) ;\\n            next[v].insert(u) ;\\n        }\\n        return (ret == INT_MAX) ? -1 : ret ;    \\n    }\\n    \\n    int BFS(int start, int end, vector<unordered_set<int>>&next){\\n        queue<int>q ;\\n        q.push(start) ;\\n        int step = 0 ;\\n        vector<bool>visited(n) ;\\n        visited[start] = true ;\\n        while(!q.empty()){\\n            int sz = q.size() ;\\n            for(int i = 0; i < sz; i++){\\n                int x = q.front() ;\\n                q.pop() ;\\n                if(x == end)\\n                    return step+1 ;\\n                for(auto nxt : next[x]){\\n                    if(visited[nxt]) continue ;\\n                    visited[nxt] = true ;\\n                    q.push(nxt) ;\\n                }\\n            }\\n            step++ ;\\n        }\\n        return INT_MAX ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int n ;\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        this->n = n ;\\n        vector<unordered_set<int>>next(n) ;        \\n        for(auto& e : edges){\\n            int u = e[0] ;\\n            int v = e[1] ;\\n            next[u].insert(v) ;\\n            next[v].insert(u) ;\\n        }\\n        int ret = INT_MAX ;\\n        for(auto& e : edges){\\n            int u = e[0] ;\\n            int v = e[1] ;\\n            next[u].erase(v) ;\\n            next[v].erase(u) ;            \\n            ret = fmin(ret, BFS(u, v, next)) ;\\n            next[u].insert(v) ;\\n            next[v].insert(u) ;\\n        }\\n        return (ret == INT_MAX) ? -1 : ret ;    \\n    }\\n    \\n    int BFS(int start, int end, vector<unordered_set<int>>&next){\\n        queue<int>q ;\\n        q.push(start) ;\\n        int step = 0 ;\\n        vector<bool>visited(n) ;\\n        visited[start] = true ;\\n        while(!q.empty()){\\n            int sz = q.size() ;\\n            for(int i = 0; i < sz; i++){\\n                int x = q.front() ;\\n                q.pop() ;\\n                if(x == end)\\n                    return step+1 ;\\n                for(auto nxt : next[x]){\\n                    if(visited[nxt]) continue ;\\n                    visited[nxt] = true ;\\n                    q.push(nxt) ;\\n                }\\n            }\\n            step++ ;\\n        }\\n        return INT_MAX ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606629,
                "title": "clean-code-with-no-parent-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> g;\\n\\n    void bfs(int n, int source, int &ans) {\\n        queue<int> q;\\n        vector<int> d(n, INT_MAX);\\n        q.push(source);\\n        d[source] = 0;\\n        while (!q.empty()) {\\n            int cur = q.front();\\n            q.pop();\\n            for (auto neigh: g[cur]) {\\n                if (d[neigh] == INT_MAX) {\\n                    d[neigh] = d[cur] + 1;\\n                    q.push(neigh);\\n                } else if (d[neigh] >= d[cur]) {\\n                    ans = min(ans, d[neigh] + d[cur] + 1);\\n                }\\n            }\\n        }\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        g.resize(n + 1);\\n        for (int i = 0; i < edges.size(); i++) {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int ans = 1e9;\\n        for (int i = 0; i < n; i++) {\\n            bfs(n, i, ans);\\n        } \\n        if (ans == 1e9) {\\n            return -1;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> g;\\n\\n    void bfs(int n, int source, int &ans) {\\n        queue<int> q;\\n        vector<int> d(n, INT_MAX);\\n        q.push(source);\\n        d[source] = 0;\\n        while (!q.empty()) {\\n            int cur = q.front();\\n            q.pop();\\n            for (auto neigh: g[cur]) {\\n                if (d[neigh] == INT_MAX) {\\n                    d[neigh] = d[cur] + 1;\\n                    q.push(neigh);\\n                } else if (d[neigh] >= d[cur]) {\\n                    ans = min(ans, d[neigh] + d[cur] + 1);\\n                }\\n            }\\n        }\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        g.resize(n + 1);\\n        for (int i = 0; i < edges.size(); i++) {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n\\n        }\\n        int ans = 1e9;\\n        for (int i = 0; i < n; i++) {\\n            bfs(n, i, ans);\\n        } \\n        if (ans == 1e9) {\\n            return -1;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569797,
                "title": "solution",
                "content": "```C++\\n#include <cstdint>\\n#include <ios>\\n#include <iostream>\\n#include <numeric>\\n#include <set>\\n#include <tuple>\\n#include <utility>\\n#include <vector>\\n\\nclass Solution {\\n public:\\n  static int32_t findShortestCycle(\\n      const int32_t& number_of_vertices,\\n      std::vector<std::vector<int32_t>>& edge_list) {\\n    static auto flag = std::ios_base::sync_with_stdio(false);\\n    if (flag) {\\n      std::cin.tie(nullptr);\\n      flag = false;\\n    }\\n    std::vector<int32_t> parents(number_of_vertices);\\n    std::iota(parents.begin(), parents.end(), 0);\\n    std::vector<uint16_t> sizes(number_of_vertices, 1u);\\n    std::vector<std::vector<int32_t>> adjacency_list(number_of_vertices);\\n    auto length_of_shortest_cycle = INT32_MAX;\\n    Kruskal(edge_list, parents, sizes, adjacency_list,\\n            length_of_shortest_cycle);\\n    if (length_of_shortest_cycle != INT32_MAX) {\\n      return length_of_shortest_cycle;\\n    }\\n    return -1;\\n  }\\n\\n private:\\n  static int32_t Find(const int32_t& vertex, std::vector<int32_t>& parents) {\\n    if (vertex == parents.at(vertex)) {\\n      return vertex;\\n    }\\n    parents.at(vertex) = Find(parents.at(vertex), parents);\\n    return parents.at(vertex);\\n  }\\n\\n  static void Unite(const int32_t& lhs, const int32_t& rhs,\\n                    std::vector<uint16_t>& sizes,\\n                    std::vector<int32_t>& parents) {\\n    auto find_lhs = Find(lhs, parents);\\n    auto find_rhs = Find(rhs, parents);\\n    if (sizes.at(find_lhs) < sizes.at(find_rhs)) {\\n      std::swap(find_lhs, find_rhs);\\n    }\\n    parents.at(find_rhs) = find_lhs;\\n    sizes.at(find_lhs) += sizes.at(find_rhs);\\n  }\\n\\n  static void Kruskal(const std::vector<std::vector<int32_t>>& edge_list,\\n                      std::vector<int32_t>& parents,\\n                      std::vector<uint16_t>& sizes,\\n                      std::vector<std::vector<int32_t>>& adjacency_list,\\n                      int32_t& length_of_shortest_cycle) {\\n    int32_t from;\\n    int32_t to;\\n    for (const auto& el : edge_list) {\\n      from = el.front();\\n      to = el.back();\\n      Unite(from, to, sizes, parents);\\n      if (parents.at(from) == parents.at(to)) {\\n        Dijkstra(adjacency_list, from, to, length_of_shortest_cycle);\\n      }\\n      adjacency_list.at(from).emplace_back(to);\\n      adjacency_list.at(to).emplace_back(from);\\n    }\\n  }\\n\\n  static void Dijkstra(const std::vector<std::vector<int32_t>>& adjacency_list,\\n                       const int32_t& starting_point,\\n                       const int32_t& ending_point,\\n                       int32_t& length_of_shortest_cycle) {\\n    std::vector<int32_t> distances(adjacency_list.size(), INT32_MAX);\\n    distances.at(starting_point) = 1;\\n    std::set<std::pair<int32_t, int32_t>> set;\\n    set.emplace(distances.at(starting_point), starting_point);\\n    {\\n      int32_t distance;\\n      int32_t vertex;\\n      int32_t candidate;\\n      while (!set.empty()) {\\n        std::tie(distance, vertex) = *set.begin();\\n        set.erase(set.begin());\\n        for (const auto& el : adjacency_list.at(vertex)) {\\n          if (candidate = distance + 1; candidate < distances.at(el)) {\\n            distances.at(el) = candidate;\\n            set.emplace(distances.at(el), el);\\n          }\\n        }\\n      }\\n    }\\n    if (length_of_shortest_cycle > distances.at(ending_point)) {\\n      length_of_shortest_cycle = distances.at(ending_point);\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```C++\\n#include <cstdint>\\n#include <ios>\\n#include <iostream>\\n#include <numeric>\\n#include <set>\\n#include <tuple>\\n#include <utility>\\n#include <vector>\\n\\nclass Solution {\\n public:\\n  static int32_t findShortestCycle(\\n      const int32_t& number_of_vertices,\\n      std::vector<std::vector<int32_t>>& edge_list) {\\n    static auto flag = std::ios_base::sync_with_stdio(false);\\n    if (flag) {\\n      std::cin.tie(nullptr);\\n      flag = false;\\n    }\\n    std::vector<int32_t> parents(number_of_vertices);\\n    std::iota(parents.begin(), parents.end(), 0);\\n    std::vector<uint16_t> sizes(number_of_vertices, 1u);\\n    std::vector<std::vector<int32_t>> adjacency_list(number_of_vertices);\\n    auto length_of_shortest_cycle = INT32_MAX;\\n    Kruskal(edge_list, parents, sizes, adjacency_list,\\n            length_of_shortest_cycle);\\n    if (length_of_shortest_cycle != INT32_MAX) {\\n      return length_of_shortest_cycle;\\n    }\\n    return -1;\\n  }\\n\\n private:\\n  static int32_t Find(const int32_t& vertex, std::vector<int32_t>& parents) {\\n    if (vertex == parents.at(vertex)) {\\n      return vertex;\\n    }\\n    parents.at(vertex) = Find(parents.at(vertex), parents);\\n    return parents.at(vertex);\\n  }\\n\\n  static void Unite(const int32_t& lhs, const int32_t& rhs,\\n                    std::vector<uint16_t>& sizes,\\n                    std::vector<int32_t>& parents) {\\n    auto find_lhs = Find(lhs, parents);\\n    auto find_rhs = Find(rhs, parents);\\n    if (sizes.at(find_lhs) < sizes.at(find_rhs)) {\\n      std::swap(find_lhs, find_rhs);\\n    }\\n    parents.at(find_rhs) = find_lhs;\\n    sizes.at(find_lhs) += sizes.at(find_rhs);\\n  }\\n\\n  static void Kruskal(const std::vector<std::vector<int32_t>>& edge_list,\\n                      std::vector<int32_t>& parents,\\n                      std::vector<uint16_t>& sizes,\\n                      std::vector<std::vector<int32_t>>& adjacency_list,\\n                      int32_t& length_of_shortest_cycle) {\\n    int32_t from;\\n    int32_t to;\\n    for (const auto& el : edge_list) {\\n      from = el.front();\\n      to = el.back();\\n      Unite(from, to, sizes, parents);\\n      if (parents.at(from) == parents.at(to)) {\\n        Dijkstra(adjacency_list, from, to, length_of_shortest_cycle);\\n      }\\n      adjacency_list.at(from).emplace_back(to);\\n      adjacency_list.at(to).emplace_back(from);\\n    }\\n  }\\n\\n  static void Dijkstra(const std::vector<std::vector<int32_t>>& adjacency_list,\\n                       const int32_t& starting_point,\\n                       const int32_t& ending_point,\\n                       int32_t& length_of_shortest_cycle) {\\n    std::vector<int32_t> distances(adjacency_list.size(), INT32_MAX);\\n    distances.at(starting_point) = 1;\\n    std::set<std::pair<int32_t, int32_t>> set;\\n    set.emplace(distances.at(starting_point), starting_point);\\n    {\\n      int32_t distance;\\n      int32_t vertex;\\n      int32_t candidate;\\n      while (!set.empty()) {\\n        std::tie(distance, vertex) = *set.begin();\\n        set.erase(set.begin());\\n        for (const auto& el : adjacency_list.at(vertex)) {\\n          if (candidate = distance + 1; candidate < distances.at(el)) {\\n            distances.at(el) = candidate;\\n            set.emplace(distances.at(el), el);\\n          }\\n        }\\n      }\\n    }\\n    if (length_of_shortest_cycle > distances.at(ending_point)) {\\n      length_of_shortest_cycle = distances.at(ending_point);\\n    }\\n  }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3549081,
                "title": "simple-bfs-uf-beats-95",
                "content": "# Approach\\nWe are maintaining Union-Find structure: `ufmap` vector and `root` method. This UF is used both for checking for cycles and not running BFS if not needed.\\n\\nTo make BFS fast we are updating vector of connected vertices for each vector.\\n\\nMain loop follows logic:\\n1. Check using UF that new edge is in same connected component.\\n2. **If in same:** compute minimal distance between vertices in current edge using BFS. Length of cycle will be just this distance + 1. \\n3. **If not in same:** update UF structure and don\\'t check for cycle.\\n4. Update our list of adjacent vertices.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> emap;\\n    vector<int> ufmap;\\npublic:\\n    int root(int x){\\n        if(ufmap[x] == x)\\n            return x;\\n        return ufmap[x] = root(ufmap[x]);\\n    }\\n\\n    int shortest_path(int a, int b){\\n        vector<bool> seen(emap.size(), false);\\n        queue<tuple<int, int>> q;\\n        q.push(make_tuple(a, 0));\\n        seen[a] = true;\\n        while(!q.empty()){\\n            auto tmp = q.front();\\n            q.pop();\\n            int v = get<0>(tmp);\\n            int d = get<1>(tmp) + 1;\\n            for(auto w: emap[v]){\\n                if(seen[w])\\n                    continue;\\n                if(w == b)\\n                    return d;\\n                seen[w] = true;\\n                q.push(make_tuple(w, d));\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        emap.resize(n);\\n        ufmap.resize(n);\\n        for(int i = 0; i < n; i++)\\n            ufmap[i] = i;\\n\\n        int res = INT_MAX;\\n        for(const auto &e: edges){\\n            int r0 = root(e[0]);\\n            int r1 = root(e[1]);\\n            if(r0 == r1)\\n                res = min(shortest_path(e[0], e[1]) + 1, res);\\n            else\\n                ufmap[r0] = r1;\\n            emap[e[0]].push_back(e[1]);\\n            emap[e[1]].push_back(e[0]);\\n        }\\n        return res > n ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> emap;\\n    vector<int> ufmap;\\npublic:\\n    int root(int x){\\n        if(ufmap[x] == x)\\n            return x;\\n        return ufmap[x] = root(ufmap[x]);\\n    }\\n\\n    int shortest_path(int a, int b){\\n        vector<bool> seen(emap.size(), false);\\n        queue<tuple<int, int>> q;\\n        q.push(make_tuple(a, 0));\\n        seen[a] = true;\\n        while(!q.empty()){\\n            auto tmp = q.front();\\n            q.pop();\\n            int v = get<0>(tmp);\\n            int d = get<1>(tmp) + 1;\\n            for(auto w: emap[v]){\\n                if(seen[w])\\n                    continue;\\n                if(w == b)\\n                    return d;\\n                seen[w] = true;\\n                q.push(make_tuple(w, d));\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        emap.resize(n);\\n        ufmap.resize(n);\\n        for(int i = 0; i < n; i++)\\n            ufmap[i] = i;\\n\\n        int res = INT_MAX;\\n        for(const auto &e: edges){\\n            int r0 = root(e[0]);\\n            int r1 = root(e[1]);\\n            if(r0 == r1)\\n                res = min(shortest_path(e[0], e[1]) + 1, res);\\n            else\\n                ufmap[r0] = r1;\\n            emap[e[0]].push_back(e[1]);\\n            emap[e[1]].push_back(e[0]);\\n        }\\n        return res > n ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539411,
                "title": "easy-bfs-runtime-478-ms-beats-30-82",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    LinkedList< Integer > [] list;\\n    public int findShortestCycle(int n, int[][] edges) {\\n        \\n        list = new LinkedList[n];\\n        for(int i = 0; i < n; i++) list[i] = new LinkedList<>();\\n\\n        for(int[] a : edges){\\n            int v = a[0], u = a[1];\\n            list[v].add(u);\\n            list[u].add(v);\\n        }\\n        int max = 1000000000;\\n        int[] dp = new int[n];\\n        for(int i = 0; i < n; i++){\\n            dp = new int[n];\\n            Queue< Integer > queue = new LinkedList<>();\\n            queue.add(i);\\n            dp[i] = 1;\\n            while(!queue.isEmpty()){\\n                int l = queue.remove();\\n                for(Integer k : list[l]){\\n                    if(dp[k] != 0 && dp[k] < dp[l]) continue;\\n                    if(dp[k] == 0){\\n                        dp[k] = dp[l] + 1;\\n                        queue.add(k);\\n                    }\\n                    else if(dp[k] == dp[l]){\\n                        max = Math.min(max,dp[l] + dp[k] -  1);                          \\n                    }\\n                    else if(dp[l] + 1 == dp[k]){\\n                        max = Math.min(max,(dp[k] - 1) * 2);\\n                    }\\n                }\\n            }\\n\\n        }\\n\\n        if(max == 1000000000) return -1;\\n\\n        return  max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    LinkedList< Integer > [] list;\\n    public int findShortestCycle(int n, int[][] edges) {\\n        \\n        list = new LinkedList[n];\\n        for(int i = 0; i < n; i++) list[i] = new LinkedList<>();\\n\\n        for(int[] a : edges){\\n            int v = a[0], u = a[1];\\n            list[v].add(u);\\n            list[u].add(v);\\n        }\\n        int max = 1000000000;\\n        int[] dp = new int[n];\\n        for(int i = 0; i < n; i++){\\n            dp = new int[n];\\n            Queue< Integer > queue = new LinkedList<>();\\n            queue.add(i);\\n            dp[i] = 1;\\n            while(!queue.isEmpty()){\\n                int l = queue.remove();\\n                for(Integer k : list[l]){\\n                    if(dp[k] != 0 && dp[k] < dp[l]) continue;\\n                    if(dp[k] == 0){\\n                        dp[k] = dp[l] + 1;\\n                        queue.add(k);\\n                    }\\n                    else if(dp[k] == dp[l]){\\n                        max = Math.min(max,dp[l] + dp[k] -  1);                          \\n                    }\\n                    else if(dp[l] + 1 == dp[k]){\\n                        max = Math.min(max,(dp[k] - 1) * 2);\\n                    }\\n                }\\n            }\\n\\n        }\\n\\n        if(max == 1000000000) return -1;\\n\\n        return  max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520764,
                "title": "easy-simple-and-fastest-solution-in-c-using-bfs",
                "content": "# Code\\n```\\nclass Solution {\\n    unordered_map<int, vector<int>> mp;\\n    int BFS(int len) {\\n        int ans = 1e9+7;\\n\\n        for(int i=0; i<len; i++) {\\n            vector<int> distance(len, 1e9+7);\\n            vector<int> parent(len, -1);\\n            queue<int> q;\\n            q.push(i);\\n            distance[i] = 0;\\n            while(!q.empty()) {\\n                int nbr = q.front(); \\n                q.pop();\\n                \\n                vector<int> edges = mp[nbr];\\n                for(int ed : edges) {\\n                     if(parent[nbr] == ed) continue;\\n                    \\n                    if(distance[ed] != 1e9+7) {\\n                        ans = min(ans, distance[ed]+distance[nbr] + 1);\\n                    }\\n                    else {\\n                        distance[ed] = 1 + distance[nbr];\\n                        parent[ed] = nbr;\\n                        q.push(ed);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        int res = 1e9+7;\\n        for(vector<int> e : edges) {\\n            mp[e[0]].push_back(e[1]); \\n            mp[e[1]].push_back(e[0]); \\n        }\\n\\n        res = BFS(n);\\n        \\n\\n        if(res == 1e9+7) return -1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int, vector<int>> mp;\\n    int BFS(int len) {\\n        int ans = 1e9+7;\\n\\n        for(int i=0; i<len; i++) {\\n            vector<int> distance(len, 1e9+7);\\n            vector<int> parent(len, -1);\\n            queue<int> q;\\n            q.push(i);\\n            distance[i] = 0;\\n            while(!q.empty()) {\\n                int nbr = q.front(); \\n                q.pop();\\n                \\n                vector<int> edges = mp[nbr];\\n                for(int ed : edges) {\\n                     if(parent[nbr] == ed) continue;\\n                    \\n                    if(distance[ed] != 1e9+7) {\\n                        ans = min(ans, distance[ed]+distance[nbr] + 1);\\n                    }\\n                    else {\\n                        distance[ed] = 1 + distance[nbr];\\n                        parent[ed] = nbr;\\n                        q.push(ed);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        int res = 1e9+7;\\n        for(vector<int> e : edges) {\\n            mp[e[0]].push_back(e[1]); \\n            mp[e[1]].push_back(e[0]); \\n        }\\n\\n        res = BFS(n);\\n        \\n\\n        if(res == 1e9+7) return -1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515342,
                "title": "bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    // smallCycle\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> list[n];\\n        for(auto x: edges)\\n        {\\n            list[x[0]].push_back(x[1]);\\n            list[x[1]].push_back(x[0]);\\n        }\\n        \\n    // every vetices of graph\\n    for (int i = 0; i < n; i++) {\\n \\n        // distance maximum\\n        vector<int> distance(n, (int)(1e9));\\n \\n        // Take a imaginary parent\\n        vector<int> parent(n, -1);\\n        distance[i] = 0;\\n        queue<int> q;\\n        q.push(i);\\n\\n        while (!q.empty()) {\\n            int temp = q.front();\\n            q.pop();\\n \\n            // Traverse for all it\\'s childs\\n            for (int child : list[temp]) {\\n \\n                // If it is not visited yet\\n                if (distance[child] == (int)(1e9)) {\\n                    q.push(child);\\n                    parent[child] = temp;\\n                    distance[child] = 1 + distance[temp];  \\n                }\\n\\n                // If it is already visited\\n                else if (parent[temp] != child and parent[child] != temp)\\n                    ans = min(ans, distance[temp] + distance[child] + 1);\\n            }\\n        }\\n    }\\n \\n    if (ans == INT_MAX)\\n        return -1; \\n    else\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    // smallCycle\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> list[n];\\n        for(auto x: edges)\\n        {\\n            list[x[0]].push_back(x[1]);\\n            list[x[1]].push_back(x[0]);\\n        }\\n        \\n    // every vetices of graph\\n    for (int i = 0; i < n; i++) {\\n \\n        // distance maximum\\n        vector<int> distance(n, (int)(1e9));\\n \\n        // Take a imaginary parent\\n        vector<int> parent(n, -1);\\n        distance[i] = 0;\\n        queue<int> q;\\n        q.push(i);\\n\\n        while (!q.empty()) {\\n            int temp = q.front();\\n            q.pop();\\n \\n            // Traverse for all it\\'s childs\\n            for (int child : list[temp]) {\\n \\n                // If it is not visited yet\\n                if (distance[child] == (int)(1e9)) {\\n                    q.push(child);\\n                    parent[child] = temp;\\n                    distance[child] = 1 + distance[temp];  \\n                }\\n\\n                // If it is already visited\\n                else if (parent[temp] != child and parent[child] != temp)\\n                    ans = min(ans, distance[temp] + distance[child] + 1);\\n            }\\n        }\\n    }\\n \\n    if (ans == INT_MAX)\\n        return -1; \\n    else\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502636,
                "title": "javascript-bfs",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar findShortestCycle = function (n, edges) {\\n  let ans = Infinity;\\n  const graph = new Array(n).fill().map((_) => []);\\n\\n  for (const [v1, v2] of edges) {\\n    graph[v1].push(v2);\\n    graph[v2].push(v1);\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    ans = Math.min(ans, bfs(graph, i, n));\\n  }\\n\\n  return ans === Infinity ? -1 : ans;\\n};\\n\\nfunction bfs(graph, node, n) {\\n  const parent = new Array(n).fill();\\n  const distance = new Array(n).fill();\\n  let minDistance = Infinity;\\n  const queue = [node];\\n  distance[node] = 0;\\n\\n  while (queue.length) {\\n    const len = queue.length;\\n    for (let i = 0; i < len; i++) {\\n      const curr = queue.shift();\\n      for (const next of graph[curr]) {\\n        if (distance[next] === undefined) {\\n          distance[next] = distance[curr] + 1;\\n          parent[next] = curr;\\n          queue.push(next);\\n        } else if (parent[curr] !== next) {\\n          // find the cycle\\n          minDistance = Math.min(\\n            minDistance,\\n            1 + distance[curr] + distance[next]\\n          );\\n        }\\n      }\\n    }\\n  }\\n\\n  return minDistance;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar findShortestCycle = function (n, edges) {\\n  let ans = Infinity;\\n  const graph = new Array(n).fill().map((_) => []);\\n\\n  for (const [v1, v2] of edges) {\\n    graph[v1].push(v2);\\n    graph[v2].push(v1);\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    ans = Math.min(ans, bfs(graph, i, n));\\n  }\\n\\n  return ans === Infinity ? -1 : ans;\\n};\\n\\nfunction bfs(graph, node, n) {\\n  const parent = new Array(n).fill();\\n  const distance = new Array(n).fill();\\n  let minDistance = Infinity;\\n  const queue = [node];\\n  distance[node] = 0;\\n\\n  while (queue.length) {\\n    const len = queue.length;\\n    for (let i = 0; i < len; i++) {\\n      const curr = queue.shift();\\n      for (const next of graph[curr]) {\\n        if (distance[next] === undefined) {\\n          distance[next] = distance[curr] + 1;\\n          parent[next] = curr;\\n          queue.push(next);\\n        } else if (parent[curr] !== next) {\\n          // find the cycle\\n          minDistance = Math.min(\\n            minDistance,\\n            1 + distance[curr] + distance[next]\\n          );\\n        }\\n      }\\n    }\\n  }\\n\\n  return minDistance;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497234,
                "title": "o-n-beats-100-java-solution-helper-method-used",
                "content": "# # UPVOTE ME \\u2B06\\uFE0F\\uD83D\\uDD1D\\u2B06\\uFE0F\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private int output = 1001;\\n\\n    public int findShortestCycle(int n, int[][] edges) {\\n        ArrayList<Integer>[] nexts = new ArrayList[n];\\n        int[] ranks = new int[n];\\n        for (int i = 0; i < n; i++) nexts[i] = new ArrayList<>();\\n        for (int[] edge : edges) for (int i = 0; i < 2; i++) nexts[edge[i]].add(edge[1 - i]);\\n        for (int i = 0; i < n; i++) if (ranks[i] == 0) findShortestCycle(nexts, i, -1, -1001, ranks);\\n        return output == 1001 ? -1 : output;\\n    }\\n\\n    private void findShortestCycle(ArrayList<Integer>[] nexts, int c, int p, int r, int[] ranks) {\\n        ranks[c] = r;\\n        for (int n : nexts[c]) if (n != p)\\n            if (ranks[n] > r + 1) findShortestCycle(nexts, n, c, r + 1, ranks);\\n            else if (ranks[c] > ranks[n]) output = Math.min(output, ranks[c] - ranks[n] + 1);\\n    }\\n\\n}\\n```\\n# # UPVOTE ME \\u2B06\\uFE0F\\uD83D\\uDD1D\\u2B06\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\n    private int output = 1001;\\n\\n    public int findShortestCycle(int n, int[][] edges) {\\n        ArrayList<Integer>[] nexts = new ArrayList[n];\\n        int[] ranks = new int[n];\\n        for (int i = 0; i < n; i++) nexts[i] = new ArrayList<>();\\n        for (int[] edge : edges) for (int i = 0; i < 2; i++) nexts[edge[i]].add(edge[1 - i]);\\n        for (int i = 0; i < n; i++) if (ranks[i] == 0) findShortestCycle(nexts, i, -1, -1001, ranks);\\n        return output == 1001 ? -1 : output;\\n    }\\n\\n    private void findShortestCycle(ArrayList<Integer>[] nexts, int c, int p, int r, int[] ranks) {\\n        ranks[c] = r;\\n        for (int n : nexts[c]) if (n != p)\\n            if (ranks[n] > r + 1) findShortestCycle(nexts, n, c, r + 1, ranks);\\n            else if (ranks[c] > ranks[n]) output = Math.min(output, ranks[c] - ranks[n] + 1);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486783,
                "title": "c-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(n);\\n        for(auto& e:edges){\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        int res = 9999;\\n        for(int i=0;i<n;i++) res = min(res, shortestCycle(g, i));\\n        return res == 9999 ? -1 : res;\\n    }\\n\\n    int shortestCycle(const vector<vector<int>>& g, int start){\\n        queue<tuple<int,int,int>> q; //i, par, len\\n        q.emplace(start, -1, 0);\\n        vector<int> dis(g.size(), -1);\\n        while(!q.empty()){\\n            auto [i, par, len] = q.front(); q.pop();\\n            dis[i] = len;\\n            for(auto j:g[i]){\\n                if(j == par) continue;\\n                if(dis[j] == -1) q.emplace(j, i, len+1);\\n                else if(j!=par) return 1 +len + dis[j];\\n            }\\n        }\\n        return 9999;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(n);\\n        for(auto& e:edges){\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        int res = 9999;\\n        for(int i=0;i<n;i++) res = min(res, shortestCycle(g, i));\\n        return res == 9999 ? -1 : res;\\n    }\\n\\n    int shortestCycle(const vector<vector<int>>& g, int start){\\n        queue<tuple<int,int,int>> q; //i, par, len\\n        q.emplace(start, -1, 0);\\n        vector<int> dis(g.size(), -1);\\n        while(!q.empty()){\\n            auto [i, par, len] = q.front(); q.pop();\\n            dis[i] = len;\\n            for(auto j:g[i]){\\n                if(j == par) continue;\\n                if(dis[j] == -1) q.emplace(j, i, len+1);\\n                else if(j!=par) return 1 +len + dis[j];\\n            }\\n        }\\n        return 9999;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466255,
                "title": "shortest-cycle-in-a-graph",
                "content": "------------------- Easy C++ Solution --------------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(n);\\n        for (auto& e : edges) {\\n            int u = e[0], v = e[1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        const int inf = 1 << 30;\\n        auto bfs = [&](int u) -> int {\\n            int dist[n];\\n            memset(dist, -1, sizeof(dist));\\n            dist[u] = 0;\\n            queue<pair<int, int>> q;\\n            q.emplace(u, -1);\\n            int ans = inf;\\n            while (!q.empty()) {\\n                auto p = q.front();\\n                u = p.first;\\n                int fa = p.second;\\n                q.pop();\\n                for (int v : g[u]) {\\n                    if (dist[v] < 0) {\\n                        dist[v] = dist[u] + 1;\\n                        q.emplace(v, u);\\n                    } else if (v != fa) {\\n                        ans = min(ans, dist[u] + dist[v] + 1);\\n                    }\\n                }\\n            }\\n            return ans;\\n        };\\n        int ans = inf;\\n        for (int i = 0; i < n; ++i) {\\n            ans = min(ans, bfs(i));\\n        }\\n        return ans < inf ? ans : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> g(n);\\n        for (auto& e : edges) {\\n            int u = e[0], v = e[1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        const int inf = 1 << 30;\\n        auto bfs = [&](int u) -> int {\\n            int dist[n];\\n            memset(dist, -1, sizeof(dist));\\n            dist[u] = 0;\\n            queue<pair<int, int>> q;\\n            q.emplace(u, -1);\\n            int ans = inf;\\n            while (!q.empty()) {\\n                auto p = q.front();\\n                u = p.first;\\n                int fa = p.second;\\n                q.pop();\\n                for (int v : g[u]) {\\n                    if (dist[v] < 0) {\\n                        dist[v] = dist[u] + 1;\\n                        q.emplace(v, u);\\n                    } else if (v != fa) {\\n                        ans = min(ans, dist[u] + dist[v] + 1);\\n                    }\\n                }\\n            }\\n            return ans;\\n        };\\n        int ans = inf;\\n        for (int i = 0; i < n; ++i) {\\n            ans = min(ans, bfs(i));\\n        }\\n        return ans < inf ? ans : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414453,
                "title": "python-redundant-connection-dfs-bfs-time-o-e-n-space-o-e-n",
                "content": "# Intuition\\n1. First do [Redundant Connection](https://leetcode.com/problems/redundant-connection/) to find the edge `u, v` that, if added, would make a cycle.\\n2. Then do a BFS to find the shortest cycle between `u` and `v`.\\n\\n# Complexity\\n- Time complexity:\\n`O(E * (N + E))`. For every edge, do a dfs `O(N + E)` then a bfs `O(N + E)`.\\n\\n- Space complexity:\\n`O(E + N)`. The graph adj list requires `O(E)`, both the dfs and bfs requires `O(N)` to track visited.\\n\\n# Code\\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        def dfs(src, tgt):\\n            \"\"\"Checks for path from src to tgt.\"\"\"\\n            if src in visited:\\n                return\\n            visited.add(src)\\n            if src == tgt:\\n                return True\\n            return any(dfs(nei, tgt) for nei in graph[src])\\n        \\n        def bfs(src, tgt):\\n            \"\"\"Shortest path from src to tgt.\"\"\"\\n            seen = {src}\\n            q = collections.deque([(src, 0)])\\n            while q:\\n                curr, dist = q.popleft()\\n                if curr == tgt:\\n                    return dist\\n                for nei in graph[curr]:\\n                    if nei not in seen:\\n                        seen.add(nei)\\n                        q.append((nei, dist + 1))\\n        \\n        graph = collections.defaultdict(list)\\n        res = math.inf\\n        for u, v in edges:\\n            visited = set()\\n            if u in graph and v in graph:\\n                if dfs(u, v):\\n                    res = min(res, bfs(u, v))\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        # Add 1 for the edge that caused the cycle\\n        return res + 1 if res < math.inf else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        def dfs(src, tgt):\\n            \"\"\"Checks for path from src to tgt.\"\"\"\\n            if src in visited:\\n                return\\n            visited.add(src)\\n            if src == tgt:\\n                return True\\n            return any(dfs(nei, tgt) for nei in graph[src])\\n        \\n        def bfs(src, tgt):\\n            \"\"\"Shortest path from src to tgt.\"\"\"\\n            seen = {src}\\n            q = collections.deque([(src, 0)])\\n            while q:\\n                curr, dist = q.popleft()\\n                if curr == tgt:\\n                    return dist\\n                for nei in graph[curr]:\\n                    if nei not in seen:\\n                        seen.add(nei)\\n                        q.append((nei, dist + 1))\\n        \\n        graph = collections.defaultdict(list)\\n        res = math.inf\\n        for u, v in edges:\\n            visited = set()\\n            if u in graph and v in graph:\\n                if dfs(u, v):\\n                    res = min(res, bfs(u, v))\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        # Add 1 for the edge that caused the cycle\\n        return res + 1 if res < math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412659,
                "title": "2608-shortest-cycle-in-a-graph-java",
                "content": "for every edge u-v, remove that edge and try to find shortest path between u and v. that will be cycle length, minimize this length for every edge.\\n\\n# Code\\n```\\nclass Solution {\\n    HashSet<Integer>[] graph;\\n    public int findShortestCycle(int n, int[][] edges) {\\n        graph=new HashSet[n];\\n        for(int i=0;i<n;i++)graph[i]=new HashSet<>();\\n        for(int[] e:edges){\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int[] e:edges){\\n            graph[e[0]].remove(e[1]);\\n            graph[e[1]].remove(e[0]);\\n            int len=bfs(e[0],e[1]);\\n            if(len>0)ans=Math.min(ans,len+1);\\n        }\\n        return ans==Integer.MAX_VALUE?-1:ans;\\n    }\\n\\n    int bfs(int u,int v){\\n        Queue<int[]> q=new LinkedList<>();\\n        HashSet<Integer> visited=new HashSet<>();\\n        visited.add(u);\\n        q.add(new int[]{u,0});\\n        while(!q.isEmpty()){   \\n            int[] x=q.poll();\\n            int uu=x[0];\\n            if(uu==v)return x[1];\\n            for(int vv:graph[uu]){\\n                if(!visited.contains(vv)){\\n                    visited.add(vv);\\n                    q.add(new int[]{vv,x[1]+1});\\n                };\\n            }\\n        }\\n        return -1;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashSet<Integer>[] graph;\\n    public int findShortestCycle(int n, int[][] edges) {\\n        graph=new HashSet[n];\\n        for(int i=0;i<n;i++)graph[i]=new HashSet<>();\\n        for(int[] e:edges){\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int[] e:edges){\\n            graph[e[0]].remove(e[1]);\\n            graph[e[1]].remove(e[0]);\\n            int len=bfs(e[0],e[1]);\\n            if(len>0)ans=Math.min(ans,len+1);\\n        }\\n        return ans==Integer.MAX_VALUE?-1:ans;\\n    }\\n\\n    int bfs(int u,int v){\\n        Queue<int[]> q=new LinkedList<>();\\n        HashSet<Integer> visited=new HashSet<>();\\n        visited.add(u);\\n        q.add(new int[]{u,0});\\n        while(!q.isEmpty()){   \\n            int[] x=q.poll();\\n            int uu=x[0];\\n            if(uu==v)return x[1];\\n            for(int vv:graph[uu]){\\n                if(!visited.contains(vv)){\\n                    visited.add(vv);\\n                    q.add(new int[]{vv,x[1]+1});\\n                };\\n            }\\n        }\\n        return -1;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407306,
                "title": "c-easy-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    int solve(int ind, vector<vector<int>>& adj, vector<int>& vis){\\n        queue<pair<int,int>> q;\\n        q.push({ind,-1});\\n        int count = 1;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                int val = q.front().first;\\n                int par = q.front().second;\\n                vis[val] = count;\\n                q.pop();\\n                for(int i=0; i<adj[val].size(); i++){\\n                    if(2*count-1 > ans) return INT_MAX;\\n                    if(vis[adj[val][i]] != 0 && vis[adj[val][i]] == count && par != adj[val][i]){\\n                        return 2*count-1;\\n                    }else if(vis[adj[val][i]] != 0 && vis[adj[val][i]] != count && par != adj[val][i]){\\n                        return 2*count-2;\\n                    } \\n                    else if(vis[adj[val][i]] == 0){\\n                        q.push({adj[val][i],val});\\n                    }\\n                }\\n            }\\n            count++;\\n        }\\n        return INT_MAX;\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n); \\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0; i<adj.size(); i++){\\n            vector<int> vis(n,0);    \\n            ans = min(ans,solve(i,adj,vis));   \\n        }\\n        if(ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    int solve(int ind, vector<vector<int>>& adj, vector<int>& vis){\\n        queue<pair<int,int>> q;\\n        q.push({ind,-1});\\n        int count = 1;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                int val = q.front().first;\\n                int par = q.front().second;\\n                vis[val] = count;\\n                q.pop();\\n                for(int i=0; i<adj[val].size(); i++){\\n                    if(2*count-1 > ans) return INT_MAX;\\n                    if(vis[adj[val][i]] != 0 && vis[adj[val][i]] == count && par != adj[val][i]){\\n                        return 2*count-1;\\n                    }else if(vis[adj[val][i]] != 0 && vis[adj[val][i]] != count && par != adj[val][i]){\\n                        return 2*count-2;\\n                    } \\n                    else if(vis[adj[val][i]] == 0){\\n                        q.push({adj[val][i],val});\\n                    }\\n                }\\n            }\\n            count++;\\n        }\\n        return INT_MAX;\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n); \\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0; i<adj.size(); i++){\\n            vector<int> vis(n,0);    \\n            ans = min(ans,solve(i,adj,vis));   \\n        }\\n        if(ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394465,
                "title": "test-case-84-give-priority-to-odd",
                "content": "# New Test Case\\nSeems like new test cases had been added, making some previously accepted submissions no longer being accepted.\\n\\nThere is this test case:\\n`edges [[4,2],[5,1],[5,0],[0,3],[5,2],[1,4],[1,3],[3,4]]`\\n`n = 6`\\n\\nOriginal codes will **first** check if the visited node is present at current level; if it is, then return even number of nodes. This check is actually not sufficient. There can also be other visited node(s) present in current level that has been visited at previous but not current level, in which case the odd number of nodes should be returned because it is smaller than even. That is what\\'s happening in the test case above.\\n\\n# Working Check\\nFor each layer, first check, if there is any visited nodes present in the queue. If there is, that node must have been visited at last level, then return odd number of nodes. Then check, if there is duplicated node values in the queue. If there is, return even number of nodes. If both checks fail, continue your BFS.\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar findShortestCycle = function (n, edges) {\\n    // Build adjacency lists\\n    const adj = Array.from({ length: n }, () => []);\\n    for (const [n1, n2] of edges) {\\n        adj[n1].push(n2);\\n        adj[n2].push(n1);\\n    }\\n\\n    // Spam all nodes\\n    let ans = Infinity;\\n    for (let i = 0; i < n; i++) {\\n        ans = Math.min(ans, bfs(i));\\n    }\\n    return ans == Infinity ? -1 : ans;\\n\\n    function bfs(node) {\\n        const visited = new Array(n); // Initiate for each i, cannot keep global, other starting i might need to use the nodes\\n        const queue = [node];\\n        const parent = [-1]; // parent[i] is the parent node of queue[i]\\n        let count = -1; // Initial value depends on wht you returning\\n        while (queue.length) {\\n            const len = queue.length;\\n            // Check first can return or not at this level\\n            for (let i = 0; i < len; i++) {\\n                if (visited[queue[i]]) return count + count + 1;\\n            }\\n            if (new Set(queue).size != queue.length) return count + count + 2;\\n            // If still no return, then no return in this level\\n            for (let i = 0; i < len; i++) {\\n                const crtNode = queue[i];\\n                const crtParent = parent[i];\\n                visited[crtNode] = true; // Mark only after popping, don\\'t mark before inserting to queueNext, you want to insert a node more than once in even case\\n                for (const child of adj[crtNode]) {\\n                    if (child != crtParent) { // Don\\'t mark visited here, will want to push duplicate nodes to check even or odd cycle\\n                        queue.push(child);\\n                        parent.push(crtNode);\\n                    }\\n                }\\n            }\\n            queue.splice(0, len);\\n            parent.splice(0, len);\\n            count++;\\n            if (count + count + 1 > ans) return Infinity; // Can no longer replace ans, can just stop\\n        }\\n        return Infinity; // No cycle\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar findShortestCycle = function (n, edges) {\\n    // Build adjacency lists\\n    const adj = Array.from({ length: n }, () => []);\\n    for (const [n1, n2] of edges) {\\n        adj[n1].push(n2);\\n        adj[n2].push(n1);\\n    }\\n\\n    // Spam all nodes\\n    let ans = Infinity;\\n    for (let i = 0; i < n; i++) {\\n        ans = Math.min(ans, bfs(i));\\n    }\\n    return ans == Infinity ? -1 : ans;\\n\\n    function bfs(node) {\\n        const visited = new Array(n); // Initiate for each i, cannot keep global, other starting i might need to use the nodes\\n        const queue = [node];\\n        const parent = [-1]; // parent[i] is the parent node of queue[i]\\n        let count = -1; // Initial value depends on wht you returning\\n        while (queue.length) {\\n            const len = queue.length;\\n            // Check first can return or not at this level\\n            for (let i = 0; i < len; i++) {\\n                if (visited[queue[i]]) return count + count + 1;\\n            }\\n            if (new Set(queue).size != queue.length) return count + count + 2;\\n            // If still no return, then no return in this level\\n            for (let i = 0; i < len; i++) {\\n                const crtNode = queue[i];\\n                const crtParent = parent[i];\\n                visited[crtNode] = true; // Mark only after popping, don\\'t mark before inserting to queueNext, you want to insert a node more than once in even case\\n                for (const child of adj[crtNode]) {\\n                    if (child != crtParent) { // Don\\'t mark visited here, will want to push duplicate nodes to check even or odd cycle\\n                        queue.push(child);\\n                        parent.push(crtNode);\\n                    }\\n                }\\n            }\\n            queue.splice(0, len);\\n            parent.splice(0, len);\\n            count++;\\n            if (count + count + 1 > ans) return Infinity; // Can no longer replace ans, can just stop\\n        }\\n        return Infinity; // No cycle\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3393981,
                "title": "javascript-2608-shortest-cycle-in-a-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar findShortestCycle = function (n, edges) {\\n    let g = new Map();\\n    for (let [u, v] of edges) {\\n        if (!g.has(u)) g.set(u, new Map());\\n        g.get(u).set(v, 1);\\n        if (!g.has(v)) g.set(v, new Map());\\n        g.get(v).set(u, 1);\\n    }\\n\\n    let minC = Infinity;\\n    let dist2s = new Map();\\n    let vis = new Set();\\n    for (let s = 0; s < n; s++) {\\n        dfs(s, -1, 0);\\n    }\\n    return minC === Infinity ? -1 : minC;\\n\\n    function dfs(u, p, total_dist) {\\n        if (vis.has(u)) {\\n            minC = Math.min(minC, total_dist - dist2s.get(u));\\n            return;\\n        }\\n        if (dist2s.get(u) >= (dist2s.get(p) || Infinity)) {\\n            return;\\n        }\\n\\n        vis.add(u);\\n        if (total_dist < (dist2s.get(u) || Infinity)) {\\n            dist2s.set(u, total_dist);\\n        }\\n        for (let [v, d] of g.get(u) || new Map()) {\\n            if (v === p) continue;\\n            dfs(v, u, total_dist + d);\\n        }\\n        vis.delete(u);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findShortestCycle = function (n, edges) {\\n    let g = new Map();\\n    for (let [u, v] of edges) {\\n        if (!g.has(u)) g.set(u, new Map());\\n        g.get(u).set(v, 1);\\n        if (!g.has(v)) g.set(v, new Map());\\n        g.get(v).set(u, 1);\\n    }\\n\\n    let minC = Infinity;\\n    let dist2s = new Map();\\n    let vis = new Set();\\n    for (let s = 0; s < n; s++) {\\n        dfs(s, -1, 0);\\n    }\\n    return minC === Infinity ? -1 : minC;\\n\\n    function dfs(u, p, total_dist) {\\n        if (vis.has(u)) {\\n            minC = Math.min(minC, total_dist - dist2s.get(u));\\n            return;\\n        }\\n        if (dist2s.get(u) >= (dist2s.get(p) || Infinity)) {\\n            return;\\n        }\\n\\n        vis.add(u);\\n        if (total_dist < (dist2s.get(u) || Infinity)) {\\n            dist2s.set(u, total_dist);\\n        }\\n        for (let [v, d] of g.get(u) || new Map()) {\\n            if (v === p) continue;\\n            dfs(v, u, total_dist + d);\\n        }\\n        vis.delete(u);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3391302,
                "title": "bfs-javascript-399-ms",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar findShortestCycle = function(n, edges) {\\n    const map = new Map();\\n    let result = Number.MAX_VALUE;\\n    const costs = new Array(n);\\n    let nodes;\\n    const stack = [];\\n    let count;\\n\\n    for (const [from, to] of edges) {\\n        nodes = map.get(from);\\n        if (nodes) nodes.push(to);\\n        else map.set(from, [to]);\\n        nodes = map.get(to);\\n        if (nodes) nodes.push(from);\\n        else map.set(to, [from]);\\n    }\\n\\n    for (let i = 0; i < n; ++i) {\\n        nodes = map.get(i);\\n        if (!nodes || nodes.length < 2) continue;\\n        costs.fill(-1);\\n        costs[i] = 0;\\n\\n        stack.push([i , 0, null]);\\n        while (stack.length) {\\n            count = stack.length;\\n            for (let i = 0; i < count; ++i) {\\n                const [node, len, from] = stack.shift();\\n                if (len >= result) continue;\\n                const neighbors = map.get(node);\\n                for (const n of neighbors) {\\n                    if (costs[n] !== -1) {\\n                        if (from !== n) {\\n                            result = Math.min(result, costs[n] + len + 1);\\n                        }\\n                    } else {\\n                        costs[n] = len + 1;\\n                        stack.push([n, len + 1, node]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return result === Number.MAX_VALUE ? -1 : result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar findShortestCycle = function(n, edges) {\\n    const map = new Map();\\n    let result = Number.MAX_VALUE;\\n    const costs = new Array(n);\\n    let nodes;\\n    const stack = [];\\n    let count;\\n\\n    for (const [from, to] of edges) {\\n        nodes = map.get(from);\\n        if (nodes) nodes.push(to);\\n        else map.set(from, [to]);\\n        nodes = map.get(to);\\n        if (nodes) nodes.push(from);\\n        else map.set(to, [from]);\\n    }\\n\\n    for (let i = 0; i < n; ++i) {\\n        nodes = map.get(i);\\n        if (!nodes || nodes.length < 2) continue;\\n        costs.fill(-1);\\n        costs[i] = 0;\\n\\n        stack.push([i , 0, null]);\\n        while (stack.length) {\\n            count = stack.length;\\n            for (let i = 0; i < count; ++i) {\\n                const [node, len, from] = stack.shift();\\n                if (len >= result) continue;\\n                const neighbors = map.get(node);\\n                for (const n of neighbors) {\\n                    if (costs[n] !== -1) {\\n                        if (from !== n) {\\n                            result = Math.min(result, costs[n] + len + 1);\\n                        }\\n                    } else {\\n                        costs[n] = len + 1;\\n                        stack.push([n, len + 1, node]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return result === Number.MAX_VALUE ? -1 : result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3389540,
                "title": "c-dfs-vs-bfs",
                "content": "1. DFS (32 ms)\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for (auto& e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        int ans = n+1, dis[n];\\n        fill(dis, dis+n, n+1);\\n        function<void(int, int, int)> dfs = [&] (int u, int p, int d)  {\\n            dis[u] = d;\\n            for (auto v: adj[u]) {\\n                if (v != p) {\\n                    if (dis[v] > d+1)\\n                        dfs(v, u, d+1);\\n                    else if (dis[v] < d)\\n                        ans = min(ans, d-dis[v]+1);\\n                }\\n            }\\n        };\\n        for (int i = 0; i < n; ++i) {\\n            if (dis[i] > n)\\n                dfs(i, -1, 0);\\n        }\\n        return ans > n ? -1 : ans;\\n    }\\n};\\n```\\n2. BFS (426 ms)\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for(auto& e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        int ans = n + 1, dis[n];\\n        for (int i = 0; i < n; ++i) {\\n            fill(dis, dis+n, -1);\\n            dis[i] = 0;\\n            queue<int> q{{i}};\\n            while (!q.empty()) {\\n                auto u = q.front(); q.pop();\\n                for (auto v: adj[u]) {\\n                    if (dis[v] == -1)\\n                        dis[v] = dis[u] + 1, q.push(v);\\n                    else if (dis[v] >= dis[u])\\n                        ans = min(ans, dis[v] + dis[u] + 1);\\n                }\\n            }\\n        }\\n        return ans > n ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for (auto& e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        int ans = n+1, dis[n];\\n        fill(dis, dis+n, n+1);\\n        function<void(int, int, int)> dfs = [&] (int u, int p, int d)  {\\n            dis[u] = d;\\n            for (auto v: adj[u]) {\\n                if (v != p) {\\n                    if (dis[v] > d+1)\\n                        dfs(v, u, d+1);\\n                    else if (dis[v] < d)\\n                        ans = min(ans, d-dis[v]+1);\\n                }\\n            }\\n        };\\n        for (int i = 0; i < n; ++i) {\\n            if (dis[i] > n)\\n                dfs(i, -1, 0);\\n        }\\n        return ans > n ? -1 : ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for(auto& e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        int ans = n + 1, dis[n];\\n        for (int i = 0; i < n; ++i) {\\n            fill(dis, dis+n, -1);\\n            dis[i] = 0;\\n            queue<int> q{{i}};\\n            while (!q.empty()) {\\n                auto u = q.front(); q.pop();\\n                for (auto v: adj[u]) {\\n                    if (dis[v] == -1)\\n                        dis[v] = dis[u] + 1, q.push(v);\\n                    else if (dis[v] >= dis[u])\\n                        ans = min(ans, dis[v] + dis[u] + 1);\\n                }\\n            }\\n        }\\n        return ans > n ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389510,
                "title": "c-simple-solution-t-c-o-n-2-s-c-o-n",
                "content": "# Intuition\\n\\n\\n# Approach\\n[youtube.com/watch?v=SHm_Au4CJTo&ab_channel=LogicBehindCode]()\\n\\n# Complexity\\n- Time complexity:\\nO[N^2]\\n\\n- Space complexity:\\nO[N]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int min_len=INT_MAX;\\n    \\n    void find_min_cycle(vector<vector<int>>& adj, int cur, vector<int>& visit)\\n    {\\n        vector<int> dis(visit.size(), -1);\\n        queue<pair<int, int>> Q;\\n        Q.push({cur, -1}); // {value, parent}\\n        visit[cur]=0;\\n        dis[cur]=0;\\n\\n        while(Q.empty()==false)\\n        {\\n            pair<int, int> top=Q.front();\\n            Q.pop();\\n\\n            int t=top.first;\\n            int p=top.second;\\n\\n            int cur_dis=dis[t];\\n\\n            for(int k=0;k<adj[t].size();k++)\\n            {\\n                if(adj[t][k]==p)\\n                {\\n                    continue;\\n                }\\n                else if(dis[adj[t][k]]!=-1)\\n                {\\n                    min_len=min(min_len, dis[adj[t][k]]+dis[t]+1);\\n                    // cout << adj[t][k] << \"---\" << t << \"  dis= \" << dis[adj[t][k]]+dis[t]+1 << endl;\\n                    continue;\\n                }\\n\\n                dis[adj[t][k]]=cur_dis+1;\\n                Q.push({adj[t][k], t});\\n                // cout << t << \" and \" << adj[t][k] << \" \" << dis[adj[t][k]] << endl;\\n\\n            }\\n        }\\n\\n    }\\n    \\n    int findShortestCycle(int n, vector<vector<int>>& edges) \\n    {\\n        vector<int> visit(n, -1);\\n        \\n        vector<vector<int>> adj(n);\\n        int i;\\n        for(i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(visit[i]==-1)\\n            {\\n                find_min_cycle(adj, i, visit);\\n            }\\n        }\\n\\n        if(min_len==INT_MAX)\\n        {\\n            return -1;\\n        }\\n\\n        return min_len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int min_len=INT_MAX;\\n    \\n    void find_min_cycle(vector<vector<int>>& adj, int cur, vector<int>& visit)\\n    {\\n        vector<int> dis(visit.size(), -1);\\n        queue<pair<int, int>> Q;\\n        Q.push({cur, -1}); // {value, parent}\\n        visit[cur]=0;\\n        dis[cur]=0;\\n\\n        while(Q.empty()==false)\\n        {\\n            pair<int, int> top=Q.front();\\n            Q.pop();\\n\\n            int t=top.first;\\n            int p=top.second;\\n\\n            int cur_dis=dis[t];\\n\\n            for(int k=0;k<adj[t].size();k++)\\n            {\\n                if(adj[t][k]==p)\\n                {\\n                    continue;\\n                }\\n                else if(dis[adj[t][k]]!=-1)\\n                {\\n                    min_len=min(min_len, dis[adj[t][k]]+dis[t]+1);\\n                    // cout << adj[t][k] << \"---\" << t << \"  dis= \" << dis[adj[t][k]]+dis[t]+1 << endl;\\n                    continue;\\n                }\\n\\n                dis[adj[t][k]]=cur_dis+1;\\n                Q.push({adj[t][k], t});\\n                // cout << t << \" and \" << adj[t][k] << \" \" << dis[adj[t][k]] << endl;\\n\\n            }\\n        }\\n\\n    }\\n    \\n    int findShortestCycle(int n, vector<vector<int>>& edges) \\n    {\\n        vector<int> visit(n, -1);\\n        \\n        vector<vector<int>> adj(n);\\n        int i;\\n        for(i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(visit[i]==-1)\\n            {\\n                find_min_cycle(adj, i, visit);\\n            }\\n        }\\n\\n        if(min_len==INT_MAX)\\n        {\\n            return -1;\\n        }\\n\\n        return min_len;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3389290,
                "title": "dfs-code-time-97-space-98-easy-to-underestand-go-for-it",
                "content": "# Intuition\\n Intuition : When i am thinking to visite the visiting node again then it may be possible that it has visited previously also But now if you visit this time then it can give you the minimal path.\\nAfter Thoughtprocessing: if i am visiting that node again and the count value is less this time than i dont have to return i have to go further .\\n# Approach\\nOne edge case 1->2 then again 2->1 will create a coutn greter than visited But i know a cycle can made of minimum 3 node \\nCondition :\\nIf(visited[i]<count && count>visited[i]+2):\\n     only You can make changes in ans\\nelse \\n    simly return ;\\n\\n# Complexity\\n- Time complexity:\\n  O(nodes* edges)// in case of highly dense graph\\n- Space complexity:\\nO(n);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<int>>& helper , int i , vector<int> & visited , int & ans, int count )\\n    {\\n        if(visited[i]!=-1 && visited[i]<count)\\n        {\\n            if(count>visited[i]+2)\\n            {\\n                ans = min(ans , count-visited[i]);\\n            }\\n            return ;\\n        }\\n        visited[i]= count  ;\\n        for(int j =0;j<helper[i].size() ;j++)\\n        {\\n            DFS(helper, helper[i][j] , visited, ans, count+1);\\n        }\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> helper(n);\\n        for( int i =0;i<edges.size() ;i++)\\n        {\\n            helper[edges[i][0]].push_back(edges[i][1]);\\n            helper[edges[i][1]].push_back(edges[i][0]);\\n        }      \\n        vector<int> visited (n , -1);\\n        int ans =100000;\\n        for(int i=0;i<n ;i++)\\n        {\\n            if(visited[i]==-1)\\n            {\\n                \\n                DFS(helper, i , visited, ans , 1);\\n            }\\n        }\\n        if(ans>90000)\\n        {\\n            return -1;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<int>>& helper , int i , vector<int> & visited , int & ans, int count )\\n    {\\n        if(visited[i]!=-1 && visited[i]<count)\\n        {\\n            if(count>visited[i]+2)\\n            {\\n                ans = min(ans , count-visited[i]);\\n            }\\n            return ;\\n        }\\n        visited[i]= count  ;\\n        for(int j =0;j<helper[i].size() ;j++)\\n        {\\n            DFS(helper, helper[i][j] , visited, ans, count+1);\\n        }\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> helper(n);\\n        for( int i =0;i<edges.size() ;i++)\\n        {\\n            helper[edges[i][0]].push_back(edges[i][1]);\\n            helper[edges[i][1]].push_back(edges[i][0]);\\n        }      \\n        vector<int> visited (n , -1);\\n        int ans =100000;\\n        for(int i=0;i<n ;i++)\\n        {\\n            if(visited[i]==-1)\\n            {\\n                \\n                DFS(helper, i , visited, ans , 1);\\n            }\\n        }\\n        if(ans>90000)\\n        {\\n            return -1;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387555,
                "title": "simple-breadth-first-search-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen current node is equal to source node and current node is not equal to parent node, mean cycle found with minimum number of node.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int findShortestCycle(int n, int[][] edges) {\\n\\n        List<List<Integer>> adjList = new ArrayList<>();\\n\\n        for(int i=0;i<n;i++)\\n            adjList.add(new ArrayList<>());\\n\\n        for(int i=0;i<edges.length;i++){\\n            adjList.get(edges[i][0]).add(edges[i][1]);\\n            adjList.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        Queue<int[]> q = new LinkedList<>();\\n            \\n        for(int i=0;i<n;i++){\\n            q.add(new int[]{i,-1,i,1});\\n        }\\n\\n        while(!q.isEmpty())\\n        {\\n            int[] temp = q.poll();\\n            int node = temp[0];\\n            int parentNode = temp[1];\\n            int sourceNode = temp[2];\\n            int shortestCycleLenght = temp[3];\\n\\n            for(int i=0;i<adjList.get(node).size();i++)\\n            {\\n                int adjNode = adjList.get(node).get(i);\\n                    \\n                if(adjNode != parentNode && adjNode == sourceNode )\\n                {\\n                    return shortestCycleLenght;\\n                }\\n                \\n                if(adjNode != parentNode)\\n                    q.add(new int[]{adjNode,node,sourceNode,shortestCycleLenght+1});\\n            }\\n        }\\n      \\n        return -1;\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int findShortestCycle(int n, int[][] edges) {\\n\\n        List<List<Integer>> adjList = new ArrayList<>();\\n\\n        for(int i=0;i<n;i++)\\n            adjList.add(new ArrayList<>());\\n\\n        for(int i=0;i<edges.length;i++){\\n            adjList.get(edges[i][0]).add(edges[i][1]);\\n            adjList.get(edges[i][1]).add(edges[i][0]);\\n        }\\n\\n        Queue<int[]> q = new LinkedList<>();\\n            \\n        for(int i=0;i<n;i++){\\n            q.add(new int[]{i,-1,i,1});\\n        }\\n\\n        while(!q.isEmpty())\\n        {\\n            int[] temp = q.poll();\\n            int node = temp[0];\\n            int parentNode = temp[1];\\n            int sourceNode = temp[2];\\n            int shortestCycleLenght = temp[3];\\n\\n            for(int i=0;i<adjList.get(node).size();i++)\\n            {\\n                int adjNode = adjList.get(node).get(i);\\n                    \\n                if(adjNode != parentNode && adjNode == sourceNode )\\n                {\\n                    return shortestCycleLenght;\\n                }\\n                \\n                if(adjNode != parentNode)\\n                    q.add(new int[]{adjNode,node,sourceNode,shortestCycleLenght+1});\\n            }\\n        }\\n      \\n        return -1;\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385961,
                "title": "python-dfs-bfs-136-ms",
                "content": "1. For each connected component, use DFS to find all possible starting nodes. A starting node would be part of a cycle.\\n2. For every starting node, use BFS to find the shortest length of the cycle containing that starting node.\\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        go_to = defaultdict(list)\\n        for a, b in edges:\\n            go_to[a].append(b)\\n            go_to[b].append(a)\\n        untouched = {i for i in range(n)}\\n        self.ans = n+1\\n        \\n        def dfs(node, parent=None):\\n            ret = set()\\n            for nxt in go_to[node]:\\n                if nxt in untouched:\\n                    untouched.remove(nxt)\\n                    ret = ret.union(dfs(nxt, node))\\n                elif nxt != parent:\\n                    ret.add(nxt)\\n            return ret\\n        \\n        def bfs(start):\\n            rec_step = defaultdict(int)\\n            rec_step[start] = 0\\n            \\n            dq = deque()\\n            dq.append((start, None))\\n            step = 0\\n            out = False\\n            while dq:\\n                if out: break\\n                step += 1\\n                for _ in range(len(dq)):\\n                    node, parent = dq.popleft()\\n                    for nxt in go_to[node]:\\n                        if nxt not in rec_step:\\n                            dq.append((nxt, node))\\n                            rec_step[nxt] = step\\n                        elif nxt != parent:\\n                            s = rec_step[nxt]\\n                            self.ans = min(self.ans, s+step)\\n                            out = True\\n            return\\n        \\n        while untouched:\\n            ret = dfs(untouched.pop())\\n            for node in ret:\\n                bfs(node)\\n        return self.ans if self.ans <= n else -1",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        go_to = defaultdict(list)\\n        for a, b in edges:\\n            go_to[a].append(b)\\n            go_to[b].append(a)\\n        untouched = {i for i in range(n)}",
                "codeTag": "Java"
            },
            {
                "id": 3384846,
                "title": "easy-and-straightforward-mst-bfs-beats-95",
                "content": "Many posts cover BFS/DFS from all nodes. This approach wasn\\'t intuitive to me. I solved this problem by first generating an MST (and keeping track of non tree edges).\\n\\nAfter generating an MST, I go over the non tree edges and from each non tree edge, I find the shortest path between the two nodes comprising the non tree edge. I used BFS for this and I exlcude the non tree edge while computing the shortest path between two nodes comprising the non tree edge. This gives the shortest cycle length in the graph if the graph contains a cycle!\\n\\nPlease comment and share your feedback.\\n\\n```\\nclass UnionFind {\\n  private:\\n    std::vector<int> parent_;\\n  \\n  public:\\n    UnionFind(const int N) {\\n      for (int i = 0; i < N; i++) {\\n        parent_.push_back(i);\\n      }\\n    }\\n  \\n    int getParent(const int n) {\\n      if (n >= (int)parent_.size()) return -1;\\n      \\n      if (n != parent_[n]) {\\n        parent_[n] = getParent(parent_[n]);\\n      }\\n      return parent_[n];\\n    }\\n  \\n    bool unite(const int a, const int b) {\\n      const auto aP = getParent(a);\\n      if (-1 == aP) return false;\\n      \\n      const auto bP = getParent(b);\\n      if (-1 == bP) return false;\\n      if (aP == bP) return false;\\n      \\n      parent_[aP] = bP;\\n      return true;\\n    }\\n};\\n\\ntypedef std::unordered_map<int, std::unordered_map<int, bool>> Graph;\\n\\nclass Solution {\\n  public:\\n    int getDistBetween(const int a, const int b, const std::vector<int>& nonTreeEdge, const Graph& g) {\\n      std::unordered_map<int, int> dist;\\n      std::queue<int> bfsQ;\\n      bfsQ.push(a);\\n      dist[a] = 0;\\n      \\n      while (!bfsQ.empty()) {\\n        const auto n = bfsQ.front();\\n        bfsQ.pop();\\n        \\n        auto dIter = dist.find(n);\\n        if (dIter == dist.end()) continue;\\n        const auto nDist = dIter->second;\\n        \\n        if (n == b) {\\n          return nDist;\\n        }\\n        \\n        const auto nIter = g.find(n);\\n        if (nIter != g.end()) {\\n          const auto& neighs = nIter->second;\\n          for (const auto& neigh : neighs) {\\n            if (!neigh.second) continue;\\n            const auto nei = neigh.first;\\n            const auto dIter = dist.find(nei);\\n            if (dIter != dist.end()) continue;\\n            \\n            // Exclude nonTreeEdge in the path\\n            if (n == nonTreeEdge.front() && nei == nonTreeEdge.back()) continue;\\n            if (nei == nonTreeEdge.front() && n == nonTreeEdge.back()) continue;\\n            \\n            dist[nei] = nDist + 1;\\n            bfsQ.push(nei);\\n          }\\n        }\\n      }\\n      \\n      return -1;\\n    }\\n  \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n      Graph g;\\n      for (const auto& edge : edges) {\\n        g[edge.front()][edge.back()] = true;\\n        g[edge.back()][edge.front()] = true;\\n      }\\n      \\n      UnionFind uf(n);\\n      std::vector<std::vector<int>> nonTreeEdges;\\n      for (const auto& edge : edges) {\\n        const auto uniteResult = uf.unite(edge.front(), edge.back());\\n        if (!uniteResult) {\\n          nonTreeEdges.push_back(edge);\\n        }\\n      }\\n      \\n      int ans = INT_MAX;\\n      for (const auto& nonTreeEdge : nonTreeEdges) {\\n        const auto d = getDistBetween(nonTreeEdge.front(), nonTreeEdge.back(), nonTreeEdge, g);\\n        if (-1 == d) continue;\\n        ans = std::min(ans, d + 1);\\n      }\\n      return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind {\\n  private:\\n    std::vector<int> parent_;\\n  \\n  public:\\n    UnionFind(const int N) {\\n      for (int i = 0; i < N; i++) {\\n        parent_.push_back(i);\\n      }\\n    }\\n  \\n    int getParent(const int n) {\\n      if (n >= (int)parent_.size()) return -1;\\n      \\n      if (n != parent_[n]) {\\n        parent_[n] = getParent(parent_[n]);\\n      }\\n      return parent_[n];\\n    }\\n  \\n    bool unite(const int a, const int b) {\\n      const auto aP = getParent(a);\\n      if (-1 == aP) return false;\\n      \\n      const auto bP = getParent(b);\\n      if (-1 == bP) return false;\\n      if (aP == bP) return false;\\n      \\n      parent_[aP] = bP;\\n      return true;\\n    }\\n};\\n\\ntypedef std::unordered_map<int, std::unordered_map<int, bool>> Graph;\\n\\nclass Solution {\\n  public:\\n    int getDistBetween(const int a, const int b, const std::vector<int>& nonTreeEdge, const Graph& g) {\\n      std::unordered_map<int, int> dist;\\n      std::queue<int> bfsQ;\\n      bfsQ.push(a);\\n      dist[a] = 0;\\n      \\n      while (!bfsQ.empty()) {\\n        const auto n = bfsQ.front();\\n        bfsQ.pop();\\n        \\n        auto dIter = dist.find(n);\\n        if (dIter == dist.end()) continue;\\n        const auto nDist = dIter->second;\\n        \\n        if (n == b) {\\n          return nDist;\\n        }\\n        \\n        const auto nIter = g.find(n);\\n        if (nIter != g.end()) {\\n          const auto& neighs = nIter->second;\\n          for (const auto& neigh : neighs) {\\n            if (!neigh.second) continue;\\n            const auto nei = neigh.first;\\n            const auto dIter = dist.find(nei);\\n            if (dIter != dist.end()) continue;\\n            \\n            // Exclude nonTreeEdge in the path\\n            if (n == nonTreeEdge.front() && nei == nonTreeEdge.back()) continue;\\n            if (nei == nonTreeEdge.front() && n == nonTreeEdge.back()) continue;\\n            \\n            dist[nei] = nDist + 1;\\n            bfsQ.push(nei);\\n          }\\n        }\\n      }\\n      \\n      return -1;\\n    }\\n  \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n      Graph g;\\n      for (const auto& edge : edges) {\\n        g[edge.front()][edge.back()] = true;\\n        g[edge.back()][edge.front()] = true;\\n      }\\n      \\n      UnionFind uf(n);\\n      std::vector<std::vector<int>> nonTreeEdges;\\n      for (const auto& edge : edges) {\\n        const auto uniteResult = uf.unite(edge.front(), edge.back());\\n        if (!uniteResult) {\\n          nonTreeEdges.push_back(edge);\\n        }\\n      }\\n      \\n      int ans = INT_MAX;\\n      for (const auto& nonTreeEdge : nonTreeEdges) {\\n        const auto d = getDistBetween(nonTreeEdge.front(), nonTreeEdge.back(), nonTreeEdge, g);\\n        if (-1 == d) continue;\\n        ans = std::min(ans, d + 1);\\n      }\\n      return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382524,
                "title": "c-easy-bfs-solution-intuitive-approach",
                "content": "# Approach\\n- Apply BFS for each node.\\n- Use clock/dist array to track time/dist.\\n- Store and Compare length of cycle in each traversal.\\nHow?\\nIF (Time of Neighbour >= Time of Parent Node)\\nMeans - Already Traversed & Hence Cycle\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\nTraversal at each Node for every BFS Call i.e. N * N\\n\\n- Space complexity:\\nO(N)\\nClock/Dist array + Queue\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define inf 10000\\n\\n    int BFS(int node, int n, vector<vector<int>>& adjList) {\\n        vector<int> clock(n, inf);\\n        queue<int> q;\\n        clock[node] = 0;\\n        q.push(node);\\n        int ans = inf;\\n\\n        while(!q.empty()) {\\n            node = q.front(); q.pop();\\n\\n            for(auto nbr : adjList[node]) {\\n                if(clock[nbr] == inf) {\\n                    q.push(nbr);\\n                    clock[nbr] = clock[node] + 1;\\n\\n                } else if(clock[nbr] >= clock[node]) {\\n                    ans = min(ans, clock[node] + clock[nbr] + 1);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adjList(n);\\n        for(int i = 0; i < edges.size(); i++) {\\n            adjList[edges[i][0]].push_back(edges[i][1]);\\n            adjList[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        int res = inf;\\n        for(int i = 0; i < n; i++) {\\n            res = min( res, \\n                       BFS(i, n, adjList) );\\n        }\\n        \\n        return (res != inf) ? res : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define inf 10000\\n\\n    int BFS(int node, int n, vector<vector<int>>& adjList) {\\n        vector<int> clock(n, inf);\\n        queue<int> q;\\n        clock[node] = 0;\\n        q.push(node);\\n        int ans = inf;\\n\\n        while(!q.empty()) {\\n            node = q.front(); q.pop();\\n\\n            for(auto nbr : adjList[node]) {\\n                if(clock[nbr] == inf) {\\n                    q.push(nbr);\\n                    clock[nbr] = clock[node] + 1;\\n\\n                } else if(clock[nbr] >= clock[node]) {\\n                    ans = min(ans, clock[node] + clock[nbr] + 1);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adjList(n);\\n        for(int i = 0; i < edges.size(); i++) {\\n            adjList[edges[i][0]].push_back(edges[i][1]);\\n            adjList[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        int res = inf;\\n        for(int i = 0; i < n; i++) {\\n            res = min( res, \\n                       BFS(i, n, adjList) );\\n        }\\n        \\n        return (res != inf) ? res : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381206,
                "title": "swift-dfs",
                "content": "**DFS (accepted answer)**\\n```\\nclass Solution {\\n    func findShortestCycle(_ n: Int, _ edges: [[Int]]) -> Int {\\n        let graph = edges.reduce(into: [Int: [Int]]()) { graph, edge in\\n            graph[edge[0], default:[]].append(edge[1])\\n            graph[edge[1], default:[]].append(edge[0])\\n        }\\n\\n        var minCycleLength = Int.max\\n        var visited = Set<Int>()\\n\\n        func dfs(_ node:Int, _ path:[Int] = []) {\\n            guard\\n                !visited.contains(node),\\n                let neighbors = graph[node]\\n            else { return }\\n            \\n            for (i, n) in path.dropLast().enumerated().reversed() where neighbors.contains(n) {\\n                minCycleLength = min(minCycleLength, path.count - i + 1)\\n                return\\n            }\\n\\n            let newPath = path + [node]\\n            guard newPath.count < minCycleLength else { return }\\n            for neighbor in neighbors where !path.contains(neighbor) {\\n                dfs(neighbor, newPath)\\n            }\\n        }\\n\\n        for node in 0 ..< n {\\n            dfs(node)\\n            visited.insert(node)\\n        }\\n\\n        return minCycleLength == Int.max ? -1 : minCycleLength\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findShortestCycle(_ n: Int, _ edges: [[Int]]) -> Int {\\n        let graph = edges.reduce(into: [Int: [Int]]()) { graph, edge in\\n            graph[edge[0], default:[]].append(edge[1])\\n            graph[edge[1], default:[]].append(edge[0])\\n        }\\n\\n        var minCycleLength = Int.max\\n        var visited = Set<Int>()\\n\\n        func dfs(_ node:Int, _ path:[Int] = []) {\\n            guard\\n                !visited.contains(node),\\n                let neighbors = graph[node]\\n            else { return }\\n            \\n            for (i, n) in path.dropLast().enumerated().reversed() where neighbors.contains(n) {\\n                minCycleLength = min(minCycleLength, path.count - i + 1)\\n                return\\n            }\\n\\n            let newPath = path + [node]\\n            guard newPath.count < minCycleLength else { return }\\n            for neighbor in neighbors where !path.contains(neighbor) {\\n                dfs(neighbor, newPath)\\n            }\\n        }\\n\\n        for node in 0 ..< n {\\n            dfs(node)\\n            visited.insert(node)\\n        }\\n\\n        return minCycleLength == Int.max ? -1 : minCycleLength\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381174,
                "title": "python3-bfs-based-approach-to-finding-shortest-cycle-in-undirected-graphs",
                "content": "# Intuition\\nThe problem requires us to find the length of the shortest cycle present in a given undirected graph.\\n\\nWe can make use of Breadth-First Search(BFS) to find cycles in the graph. Starting from a node, we traverse all of its neighbors in the first layer of the BFS. Then, we traverse all the neighbors of those nodes that were reached in the previous layer. By maintaining a distance of each node from the start node, we can detect when we have found a cycle.\\n\\nIf a neighbor node of the current node has already been visited in the current BFS traversal, then that means a cycle exists. In that case, we can calculate the length of the cycle as the sum of distances of both the nodes from the start node and add 1.\\n\\nWe keep track of the minimum length of the cycle that we find over all possible start nodes.\\n\\n# Approach\\nCreate an adjacency list to represent the graph.\\nFor each node in the graph, run the BFS traversal, and find the shortest cycle length.\\nReturn the minimum cycle length.\\n\\n# Complexity\\n- Time complexity:\\nO(n*(m+n)) where n is the number of nodes and m is the number of edges in the graph. We visit each node at most once and each edge twice(once for each endpoint). In the worst-case scenario, we visit all nodes for all BFS traversals.\\n\\n- Space complexity:\\nO(n+m) for the adjacency list. Additionally, we use O(n) space for the queue and O(n) space for the dist array. Therefore, the total space complexity is O(n+m).\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        def bfs(start: int) -> int:\\n            queue = [start]\\n            dist = [-1] * n\\n            dist[start] = 0\\n            min_cycle_len = float(\"inf\")\\n            \\n            while queue:\\n                curr = queue.pop(0)\\n                for neighbor in graph[curr]:\\n                    if dist[neighbor] == -1:\\n                        dist[neighbor] = dist[curr] + 1\\n                        queue.append(neighbor)\\n                    elif dist[neighbor] >= dist[curr]:  # cycle found\\n                        cycle_len = dist[curr] + dist[neighbor] + 1\\n                        min_cycle_len = min(min_cycle_len, cycle_len)\\n            return min_cycle_len\\n        \\n        min_cycle_len = float(\"inf\")\\n        for i in range(n):\\n            min_cycle_len = min(min_cycle_len, bfs(i))\\n        \\n        return -1 if min_cycle_len == float(\"inf\") else min_cycle_len\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        def bfs(start: int) -> int:\\n            queue = [start]\\n            dist = [-1] * n\\n            dist[start] = 0\\n            min_cycle_len = float(\"inf\")\\n            \\n            while queue:\\n                curr = queue.pop(0)\\n                for neighbor in graph[curr]:\\n                    if dist[neighbor] == -1:\\n                        dist[neighbor] = dist[curr] + 1\\n                        queue.append(neighbor)\\n                    elif dist[neighbor] >= dist[curr]:  # cycle found\\n                        cycle_len = dist[curr] + dist[neighbor] + 1\\n                        min_cycle_len = min(min_cycle_len, cycle_len)\\n            return min_cycle_len\\n        \\n        min_cycle_len = float(\"inf\")\\n        for i in range(n):\\n            min_cycle_len = min(min_cycle_len, bfs(i))\\n        \\n        return -1 if min_cycle_len == float(\"inf\") else min_cycle_len\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378615,
                "title": "python-clear-bfs",
                "content": "```\\nclass Solution:\\n    def bfs(self, node, answer, graph):\\n        seen = set([node])\\n        todo = deque([node])\\n        depts = defaultdict(int)\\n        depts[node] = 0\\n        parents = defaultdict(int)\\n        parents[node] = -1\\n        while todo:\\n            cur = todo.popleft()\\n            for neighbor in graph[cur]:\\n                if neighbor not in seen:\\n                    todo.append(neighbor)\\n                    seen.add(neighbor)\\n                    depts[neighbor] = depts[cur] + 1\\n                    parents[neighbor] = cur\\n                elif neighbor != parents[cur]:\\n                    answer[0] = min(answer[0], depts[neighbor] + depts[cur] + 1)\\n                \\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = [ [] for _ in range(n) ]\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        answer = [1001]\\n        for node in range(n):\\n            self.bfs(node, answer, graph)\\n        \\n        if answer[0] == 1001:\\n            answer[0] = -1\\n        \\n        return answer[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def bfs(self, node, answer, graph):\\n        seen = set([node])\\n        todo = deque([node])\\n        depts = defaultdict(int)\\n        depts[node] = 0\\n        parents = defaultdict(int)\\n        parents[node] = -1\\n        while todo:\\n            cur = todo.popleft()\\n            for neighbor in graph[cur]:\\n                if neighbor not in seen:\\n                    todo.append(neighbor)\\n                    seen.add(neighbor)\\n                    depts[neighbor] = depts[cur] + 1\\n                    parents[neighbor] = cur\\n                elif neighbor != parents[cur]:\\n                    answer[0] = min(answer[0], depts[neighbor] + depts[cur] + 1)\\n                \\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = [ [] for _ in range(n) ]\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        answer = [1001]\\n        for node in range(n):\\n            self.bfs(node, answer, graph)\\n        \\n        if answer[0] == 1001:\\n            answer[0] = -1\\n        \\n        return answer[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376486,
                "title": "python3-memoized-dfs-union-find-is-this-correct",
                "content": "Simple union find to detect disconnected graphs. Memoized depth first search on the representative of each island. Would be easy enough to skip the union find and just check each member that hasn\\'t been searched before but I\\'m just trying to practice using union find on some problems.\\n\\nMy main concern is that I\\'m worried my memoization technique of memoizing the depth may not actually work for all graphs. It passed all test cases (without the d parameter it fails) but I didn\\'t exactly add that parameter with any sound logic involved, it was just a thing I added that worked and I can\\'t explain why.\\n\\n```python\\nclass UFR:\\n    def __init__(self, n: int):\\n        self.a = list(range(n))\\n    \\n    def find(self, p: int) -> int:\\n        if self.a[p] != p:\\n            self.a[p] = self.find(self.a[p])\\n        return self.a[p]\\n    \\n    def union(self, p: int, q: int) -> None:\\n        l = self.find(p)\\n        r = self.find(q)\\n        self.a[min(l, r)] = max(l, r)\\n\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        g = defaultdict(set)\\n        u = UFR(n)\\n        for p, q in edges:\\n            g[p].add(q)\\n            g[q].add(p)\\n            u.union(p, q)\\n            \\n        seen = {}\\n        \\n        @cache\\n        def dfs(i: int, r: int, d: int = 0) -> int | Literal[inf]:\\n            if r not in seen:\\n                seen[r] = {}\\n            if i in seen[r]:\\n                return len(seen[r]) - seen[r][i]\\n            seen[r][i] = len(seen[r])\\n            answer = inf\\n            for j in g[i]:\\n                if seen[r].get(j) != len(seen[r]) - 2:\\n                    answer = min(dfs(j, r, d+1), answer)\\n            del seen[r][i]\\n            return answer\\n        \\n        answer = inf\\n        for i in g:\\n            if u.find(i) == i:\\n                answer = min(answer, dfs(i, i))\\n                \\n        if answer == float(\\'inf\\'):\\n            return -1\\n        \\n        return answer\\n```",
                "solutionTags": [],
                "code": "```python\\nclass UFR:\\n    def __init__(self, n: int):\\n        self.a = list(range(n))\\n    \\n    def find(self, p: int) -> int:\\n        if self.a[p] != p:\\n            self.a[p] = self.find(self.a[p])\\n        return self.a[p]\\n    \\n    def union(self, p: int, q: int) -> None:\\n        l = self.find(p)\\n        r = self.find(q)\\n        self.a[min(l, r)] = max(l, r)\\n\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        g = defaultdict(set)\\n        u = UFR(n)\\n        for p, q in edges:\\n            g[p].add(q)\\n            g[q].add(p)\\n            u.union(p, q)\\n            \\n        seen = {}\\n        \\n        @cache\\n        def dfs(i: int, r: int, d: int = 0) -> int | Literal[inf]:\\n            if r not in seen:\\n                seen[r] = {}\\n            if i in seen[r]:\\n                return len(seen[r]) - seen[r][i]\\n            seen[r][i] = len(seen[r])\\n            answer = inf\\n            for j in g[i]:\\n                if seen[r].get(j) != len(seen[r]) - 2:\\n                    answer = min(dfs(j, r, d+1), answer)\\n            del seen[r][i]\\n            return answer\\n        \\n        answer = inf\\n        for i in g:\\n            if u.find(i) == i:\\n                answer = min(answer, dfs(i, i))\\n                \\n        if answer == float(\\'inf\\'):\\n            return -1\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375438,
                "title": "dfs-approach-100-ac-34ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLook for every Loop and consider it\\'s length. Also if the distance of current node from root is minimized but new path the re explore the this node and loop consisting this node.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int r,int h,vector<vector<int>>&adj,vector<int>&vis,int& ans){\\n        vis[r]=h;\\n        for(auto i:adj[r]){\\n            if(!vis[i] || vis[i]>h+1)dfs(i,h+1,adj,vis,ans);\\n            else if(h>=vis[i]+2) ans=min(ans,h-vis[i]+1);\\n        }\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        for(auto i:edges)adj[i[0]].push_back(i[1]),adj[i[1]].push_back(i[0]);\\n        vector<int>vis(n);\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i])dfs(i,1,adj,vis,ans);\\n        }\\n        return (ans==INT_MAX)?-1:ans;\\n    }\\n};\\n```\\n# Upvote\\nIf you like the solution please upvote this post.\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int r,int h,vector<vector<int>>&adj,vector<int>&vis,int& ans){\\n        vis[r]=h;\\n        for(auto i:adj[r]){\\n            if(!vis[i] || vis[i]>h+1)dfs(i,h+1,adj,vis,ans);\\n            else if(h>=vis[i]+2) ans=min(ans,h-vis[i]+1);\\n        }\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        for(auto i:edges)adj[i[0]].push_back(i[1]),adj[i[1]].push_back(i[0]);\\n        vector<int>vis(n);\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i])dfs(i,1,adj,vis,ans);\\n        }\\n        return (ans==INT_MAX)?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373718,
                "title": "c-bfs-level-order-traversal",
                "content": "# Approach\\n- So what we can do is we can do is we can do level order traversal from each node as a root and it we found some node is linked with some other node and they are not contains parent child relationship so they are making cycle that is for sure and we can find the length by formula `level of 1st + level of 2nd + 1`\\n\\n# Complexity\\n- Time complexity: $$O(N*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int,vector<int>> adj;\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            queue<pair<int,int>> q;\\n            vector<int> dis(n,-1);\\n            dis[i]=0;\\n            q.push({i,-1});\\n\\n            while(!q.empty()){\\n                auto [node,par] = q.front();\\n                q.pop();\\n\\n                for(auto x:adj[node]){\\n                    if(dis[x]==-1){\\n                        dis[x]=dis[node]+1;\\n                        q.push({x,node});\\n                    }\\n                    else if(x!=par){\\n                        ans=min(ans,(dis[node]+dis[x]+1));\\n                    }\\n                }\\n            }\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int,vector<int>> adj;\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        for(auto x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            queue<pair<int,int>> q;\\n            vector<int> dis(n,-1);\\n            dis[i]=0;\\n            q.push({i,-1});\\n\\n            while(!q.empty()){\\n                auto [node,par] = q.front();\\n                q.pop();\\n\\n                for(auto x:adj[node]){\\n                    if(dis[x]==-1){\\n                        dis[x]=dis[node]+1;\\n                        q.push({x,node});\\n                    }\\n                    else if(x!=par){\\n                        ans=min(ans,(dis[node]+dis[x]+1));\\n                    }\\n                }\\n            }\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373122,
                "title": "100-faster-in-time-and-space-c-bfs-optimization",
                "content": "Although my idea is also same as applying BFS from all the nodes -> calculating size of cycle from them if exists -> then updating the answer.\\n**But for any node i, we should not consider the nodes for which we have done cycle detection, otherwise we might be detecting the same cycle but from the current node**. So for any node i , we should not consider nodes from 0 to i-1 i.e. 0 , 1, 2, .... i-1.\\nAfter this optimization my sol became 100% faster.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int res = 1e5;\\n    \\n    void bfs(int src, vector<vector<int>>& graph, vector<int> & vec, vector<pair<int,int>> & value){\\n        \\n        vector<int> visited(graph.size());\\n        \\n        queue<vector<int>> q;\\n        q.push({src, 0, -1}); // node, level, parent\\n        visited[src] = true;\\n        value[src].first = 0;\\n        \\n        \\n        while(!q.empty()){\\n            \\n            auto p = q.front(); q.pop();\\n            int u = p[0], level = p[1], parent = p[2];\\n            \\n            for(auto v : graph[u]){\\n                if(!visited[v] && !vec[v]){\\n                    visited[v] = true; value[v].first = level + 1;\\n                    q.push({v, level + 1, u});\\n                }\\n                else if(v != parent){\\n                    int val = level + 1;\\n                    if(val > value[v].first && val < value[v].second){\\n                        value[v].second = val;\\n                    }\\n                    else if(val < value[v].first){\\n                        value[v].second = value[v].first; value[v].first = val;\\n                    }\\n                    \\n                    res = min(res, value[v].second + value[v].first);\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        for(auto & e : edges){\\n            int u = e[0], v = e[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        vector<int> vec(n); // bery bery important\\n        \\n        for(int i = 0; i<n; i++){\\n            vector<pair<int,int>> value(n, {1e5, 1e5});\\n            bfs(i, graph, vec, value);\\n            vec[i] = 1;\\n        }\\n        \\n        return (res == 1e5 ? -1 : res) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int res = 1e5;\\n    \\n    void bfs(int src, vector<vector<int>>& graph, vector<int> & vec, vector<pair<int,int>> & value){\\n        \\n        vector<int> visited(graph.size());\\n        \\n        queue<vector<int>> q;\\n        q.push({src, 0, -1}); // node, level, parent\\n        visited[src] = true;\\n        value[src].first = 0;\\n        \\n        \\n        while(!q.empty()){\\n            \\n            auto p = q.front(); q.pop();\\n            int u = p[0], level = p[1], parent = p[2];\\n            \\n            for(auto v : graph[u]){\\n                if(!visited[v] && !vec[v]){\\n                    visited[v] = true; value[v].first = level + 1;\\n                    q.push({v, level + 1, u});\\n                }\\n                else if(v != parent){\\n                    int val = level + 1;\\n                    if(val > value[v].first && val < value[v].second){\\n                        value[v].second = val;\\n                    }\\n                    else if(val < value[v].first){\\n                        value[v].second = value[v].first; value[v].first = val;\\n                    }\\n                    \\n                    res = min(res, value[v].second + value[v].first);\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        for(auto & e : edges){\\n            int u = e[0], v = e[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        vector<int> vec(n); // bery bery important\\n        \\n        for(int i = 0; i<n; i++){\\n            vector<pair<int,int>> value(n, {1e5, 1e5});\\n            bfs(i, graph, vec, value);\\n            vec[i] = 1;\\n        }\\n        \\n        return (res == 1e5 ? -1 : res) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373004,
                "title": "simple-easiest-graph-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNot an hard problem it is a simple graph traversal or detect cycle in s directed graph problem. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Simply maintain a distance array while traversing the graph.\\n2. do normal BFS or DFS as you want.\\n3. if(current node != parent && dist[v]>=dist[u]){\\n4.     cycle = min(cycle,dist[v]+dist[u]+1)\\n4. }\\n5.     return cycle ==INT_MAX ? -1:cycle\\n\\n# Complexity\\n- Time complexity:\\n- O(V*E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(int n,vector<int>graph[],vector<bool>visited,vector<bool>parent){\\n         int minCycle = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            vector<int>dist(n,-1);\\n            queue<int>q;\\n            q.push(i);\\n            dist[i] = 0;\\n            while (!q.empty()) {\\n                int u = q.front();\\n                q.pop();\\n                for (int v : graph[u]) {\\n                    if (dist[v] == -1) {\\n                        dist[v] = dist[u] + 1;\\n                        q.push(v);\\n                    } else if (v != i && dist[v] >= dist[u]) {\\n                        minCycle = min(minCycle, dist[u] + dist[v] + 1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return minCycle == INT_MAX ? -1 : minCycle;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int>graph[n+1];\\n        for(auto v : edges){\\n            graph[v[0]].push_back(v[1]);\\n            graph[v[1]].push_back(v[0]);\\n        }\\n        vector<bool>visited(n,false);\\n        vector<bool>parent(n,false);\\n        return bfs(n,graph,visited,parent);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(int n,vector<int>graph[],vector<bool>visited,vector<bool>parent){\\n         int minCycle = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            vector<int>dist(n,-1);\\n            queue<int>q;\\n            q.push(i);\\n            dist[i] = 0;\\n            while (!q.empty()) {\\n                int u = q.front();\\n                q.pop();\\n                for (int v : graph[u]) {\\n                    if (dist[v] == -1) {\\n                        dist[v] = dist[u] + 1;\\n                        q.push(v);\\n                    } else if (v != i && dist[v] >= dist[u]) {\\n                        minCycle = min(minCycle, dist[u] + dist[v] + 1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return minCycle == INT_MAX ? -1 : minCycle;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int>graph[n+1];\\n        for(auto v : edges){\\n            graph[v[0]].push_back(v[1]);\\n            graph[v[1]].push_back(v[0]);\\n        }\\n        vector<bool>visited(n,false);\\n        vector<bool>parent(n,false);\\n        return bfs(n,graph,visited,parent);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372626,
                "title": "using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        for(int  i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n       int ans=INT_MAX;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            vector<int>vis(n,-1);\\n            queue<pair<int,pair<int,int>>>q;\\n            q.push({i,{0,-1}});\\n            vector<int>distance(n,0);\\n            \\n            \\n            while(q.size()>0){\\n                 pair<int,pair<int,int>>p=q.front();\\n                  q.pop();\\n                    int node=p.first;\\n                    vis[node]=1;\\n                    int d=p.second.first;\\n                    int parent=p.second.second;\\n                    for(auto it:adj[node]){\\n                        if(vis[it]==-1){\\n                           distance[it]=d+1;\\n                            q.push({it,{d+1,node}});\\n                        }\\n                        else{\\n                            if(parent!=it) ans=min(ans,d+distance[it]);\\n                        }\\n                    }\\n              }\\n            \\n            \\n            \\n        }\\n        \\n        if(ans==INT_MAX)return -1;\\n        return ans+1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int>adj[n];\\n        for(int  i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n       int ans=INT_MAX;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            vector<int>vis(n,-1);\\n            queue<pair<int,pair<int,int>>>q;\\n            q.push({i,{0,-1}});\\n            vector<int>distance(n,0);\\n            \\n            \\n            while(q.size()>0){\\n                 pair<int,pair<int,int>>p=q.front();\\n                  q.pop();\\n                    int node=p.first;\\n                    vis[node]=1;\\n                    int d=p.second.first;\\n                    int parent=p.second.second;\\n                    for(auto it:adj[node]){\\n                        if(vis[it]==-1){\\n                           distance[it]=d+1;\\n                            q.push({it,{d+1,node}});\\n                        }\\n                        else{\\n                            if(parent!=it) ans=min(ans,d+distance[it]);\\n                        }\\n                    }\\n              }\\n            \\n            \\n            \\n        }\\n        \\n        if(ans==INT_MAX)return -1;\\n        return ans+1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371990,
                "title": "rough-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we start from a node and return back to it then there is circle. Multiple circle may exist in a graph. We have to track the circle with minimum length.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake a adjacency matrix for the given graph.\\nRun a loop which will cover each node.\\nFor every node do a bfs traversal. \\nDuring BFS we will keep track of visited node and its distance from the parent node.\\nIf a node is encontured again there is a circle. \\nIf node is in visited, then the cycle_length will be length from starting node to its parent node plus and its distance from its parent. \\nIf neighbour of that node is in visited then cycle_length will be length from the very first to its parent node plus distance of node from its parent plus 1 because it is a neighbouring node.\\nEvery time we obtain a cycle we will update the minimum length.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(edges+n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        \\n        d=defaultdict(list)\\n        for i,j in edges:\\n            d[i].append(j)\\n            d[j].append(i)\\n        \\n        \\n        cycle=float(inf)\\n        \\n        for i in range(len(edges)):\\n            q=[(i,0,None)]\\n            visited=set()\\n            dist={i:0}\\n            while q:\\n                node,length,parent=q.pop(0)\\n                if node in visited:\\n                    cycle_length=length+dist[parent]\\n                    cycle=min(cycle,cycle_length)\\n                else:\\n                    visited.add(node)\\n                    for neighbour in d[node]:\\n                        if neighbour!=parent:\\n                            if neighbour in dist:\\n                                cycle_length=length+dist[neighbour]+1\\n                                cycle=min(cycle,cycle_length)\\n                            else:\\n                                q.append((neighbour,length+1,node))\\n                                dist[neighbour]=length+1\\n                            \\n        return cycle if cycle!=float(\\'inf\\') else -1\\n                        \\n        \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        \\n        \\n        d=defaultdict(list)\\n        for i,j in edges:\\n            d[i].append(j)\\n            d[j].append(i)\\n        \\n        \\n        cycle=float(inf)\\n        \\n        for i in range(len(edges)):\\n            q=[(i,0,None)]\\n            visited=set()\\n            dist={i:0}\\n            while q:\\n                node,length,parent=q.pop(0)\\n                if node in visited:\\n                    cycle_length=length+dist[parent]\\n                    cycle=min(cycle,cycle_length)\\n                else:\\n                    visited.add(node)\\n                    for neighbour in d[node]:\\n                        if neighbour!=parent:\\n                            if neighbour in dist:\\n                                cycle_length=length+dist[neighbour]+1\\n                                cycle=min(cycle,cycle_length)\\n                            else:\\n                                q.append((neighbour,length+1,node))\\n                                dist[neighbour]=length+1\\n                            \\n        return cycle if cycle!=float(\\'inf\\') else -1\\n                        \\n        \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371939,
                "title": "java-bfs-solution",
                "content": "# Approach\\nI use queue to store parent index, nubmer of step till the current point and current point.\\n\\n# Complexity\\n- Time complexity:\\nO(n * m)\\nm is the number of edges.\\nn is the number of nodes.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int[] edge : edges)\\n        {\\n            map.computeIfAbsent(edge[0], k-> new ArrayList<>()).add(edge[1]);   \\n            map.computeIfAbsent(edge[1], k-> new ArrayList<>()).add(edge[0]);\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++)\\n        {\\n            Queue<int[]> q = new LinkedList<>();\\n            q.offer(new int[] {i, 0, -1});\\n            int[] visited = new int[n];\\n            while(!q.isEmpty())\\n            {\\n                int[] t = q.poll();\\n                int idx = t[0];\\n                \\n                if(!map.containsKey(idx))\\n                {\\n                    continue;\\n                }\\n                if(visited[idx] != 0)\\n                {\\n                    res = Math.min(res, visited[idx] + t[1]);                        \\n                    continue;\\n                }\\n                visited[idx] = t[1];\\n                for(int val : map.get(idx))\\n                {\\n                    if(val != t[2])\\n                        q.offer(new int[] {val, t[1] + 1, idx});\\n                }\\n            }\\n        }\\n        \\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int[] edge : edges)\\n        {\\n            map.computeIfAbsent(edge[0], k-> new ArrayList<>()).add(edge[1]);   \\n            map.computeIfAbsent(edge[1], k-> new ArrayList<>()).add(edge[0]);\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++)\\n        {\\n            Queue<int[]> q = new LinkedList<>();\\n            q.offer(new int[] {i, 0, -1});\\n            int[] visited = new int[n];\\n            while(!q.isEmpty())\\n            {\\n                int[] t = q.poll();\\n                int idx = t[0];\\n                \\n                if(!map.containsKey(idx))\\n                {\\n                    continue;\\n                }\\n                if(visited[idx] != 0)\\n                {\\n                    res = Math.min(res, visited[idx] + t[1]);                        \\n                    continue;\\n                }\\n                visited[idx] = t[1];\\n                for(int val : map.get(idx))\\n                {\\n                    if(val != t[2])\\n                        q.offer(new int[] {val, t[1] + 1, idx});\\n                }\\n            }\\n        }\\n        \\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371615,
                "title": "js-solution-using-dfs-with-adjacencylist-and-visited",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou can either use BFS or DFS. BFS is probably better, since you can stop when you have found a cycle and already know it is the shortest. But I thought DFS might be easier to implement, so I went with that.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake adjacencyList (hashMap with neighbours per node)\\nFor each node start a DFS. keep track of visited per dfs and a visits that let you know you can skipp certain starting nodes, if they have already been visited. Lastly, keep track of the depth you are at, if depth > answer you can stop that particular iteration.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nnot sure, it\\'s not great, but runs in 487 ms\\n- Space complexity:\\n- not sure, it\\'s not great, but runs in 75Mb\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar findShortestCycle = function(n, edges) {\\n    let adacencyList = new Map()\\n    edges.forEach(edge => {\\n        if (adacencyList.has(edge[0])) {\\n            let neighbours = adacencyList.get(edge[0])\\n            neighbours.push(edge[1])\\n            adacencyList.set(edge[0], neighbours)\\n        } else {\\n            adacencyList.set(edge[0], [edge[1]])\\n        }\\n        if (adacencyList.has(edge[1])) {\\n            let neighbours = adacencyList.get(edge[1])\\n            neighbours.push(edge[0])\\n            adacencyList.set(edge[1], neighbours)\\n        } else {\\n            adacencyList.set(edge[1], [edge[0]])\\n        }\\n    })\\n    let answer = Infinity\\n    let visits = new Set()\\n    const dfs = (node, prevNode, visited, j, depth) => {\\n        if (depth > answer) return\\n        visits.add(node)\\n        let neighbours = adacencyList.get(node)\\n        let found = false\\n        neighbours.forEach(neighbour => {\\n            if (neighbour === prevNode) return\\n            if (visited.has(neighbour) ) {\\n                let length = visited.size - new Array(...visited).indexOf(neighbour)\\n                answer = Math.min(answer, length)\\n                found  = true\\n            }\\n        })\\n        if (found) return\\n        neighbours.forEach(neighbour => {\\n            if (neighbour === prevNode) return\\n            let alreadyVisited = new Set(visited)\\n            alreadyVisited.add(neighbour)\\n            dfs(neighbour, node, alreadyVisited, j, depth+1)\\n        })\\n        \\n    }\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (adacencyList.has(i)) { \\n            if (!visits.has(i)) dfs(i, -1, new Set(), i, 0)\\n        }\\n    }\\n    if (answer === Infinity) return -1\\n    return answer\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @return {number}\\n */\\nvar findShortestCycle = function(n, edges) {\\n    let adacencyList = new Map()\\n    edges.forEach(edge => {\\n        if (adacencyList.has(edge[0])) {\\n            let neighbours = adacencyList.get(edge[0])\\n            neighbours.push(edge[1])\\n            adacencyList.set(edge[0], neighbours)\\n        } else {\\n            adacencyList.set(edge[0], [edge[1]])\\n        }\\n        if (adacencyList.has(edge[1])) {\\n            let neighbours = adacencyList.get(edge[1])\\n            neighbours.push(edge[0])\\n            adacencyList.set(edge[1], neighbours)\\n        } else {\\n            adacencyList.set(edge[1], [edge[0]])\\n        }\\n    })\\n    let answer = Infinity\\n    let visits = new Set()\\n    const dfs = (node, prevNode, visited, j, depth) => {\\n        if (depth > answer) return\\n        visits.add(node)\\n        let neighbours = adacencyList.get(node)\\n        let found = false\\n        neighbours.forEach(neighbour => {\\n            if (neighbour === prevNode) return\\n            if (visited.has(neighbour) ) {\\n                let length = visited.size - new Array(...visited).indexOf(neighbour)\\n                answer = Math.min(answer, length)\\n                found  = true\\n            }\\n        })\\n        if (found) return\\n        neighbours.forEach(neighbour => {\\n            if (neighbour === prevNode) return\\n            let alreadyVisited = new Set(visited)\\n            alreadyVisited.add(neighbour)\\n            dfs(neighbour, node, alreadyVisited, j, depth+1)\\n        })\\n        \\n    }\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (adacencyList.has(i)) { \\n            if (!visits.has(i)) dfs(i, -1, new Set(), i, 0)\\n        }\\n    }\\n    if (answer === Infinity) return -1\\n    return answer\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3371495,
                "title": "union-find-dfs-bfs-iterative-dfs",
                "content": "# Intuition -- BFS\\nWe start from each vertex of the graph and use breadth-first search to find the shortest path to all other vertices. During the BFS, if we encounter a vertex that is already visited and has a distance that is less than or equal to the current vertex\\'s distance, then it means there is a cycle in the graph. The length of the cycle can be calculated by adding the distances of the current and already visited vertices and adding 1. We can repeat this process for all vertices of the graph and return the minimum length cycle found.\\n\\n# Complexity\\n- Time complexity: $$O(N*(N+E))$$, where *N* is the number of vertices and *E* is the number of edges. The outer loop runs N times, and for each vertex, the BFS algorithm is run on a graph with N vertices and E edges. The time complexity of the BFS algorithm is $$O(N+E)$$, as each edge is visited only once. Therefore, the overall time complexity of the algorithm is $$O(N*(N+E))$$.\\n\\n- Space complexity: $$O(N+E)$$, as we need to maintain an adjacency list of the graph and a queue for BFS. The adjacency list requires $$O(E)$$ space to store the edges, and the queue can have at most N vertices in it. Therefore, the overall space complexity of the algorithm is $$O(N+E)$$.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for (const auto& e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        int res = INT_MAX;\\n        for (int u = 0; u < n; ++u) {\\n            int length_cycle = bfs(u, adj);\\n            if(length_cycle < 0) continue;\\n            res = min(res, length_cycle);\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n\\nprivate:\\n    int bfs(int u, const vector<vector<int>>& adj) {\\n        int n = adj.size();\\n        vector<int> dist(n, -1);\\n        dist[u] = 0;\\n        queue<int> q{{u}};\\n        while (!q.empty()) {\\n            int v = q.front(); q.pop();\\n            for (int w : adj[v]) {\\n                if (dist[w] == -1) {\\n                    dist[w] = dist[v] + 1;\\n                    q.push(w);\\n                } else if (dist[v] <= dist[w]) {\\n                    return dist[v] + dist[w] + 1;\\n                } \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for e in edges:\\n            adj[e[0]].append(e[1])\\n            adj[e[1]].append(e[0])\\n\\n        res = float(\\'inf\\')\\n        for u in range(n):\\n            length_cycle = self.bfs(u, adj, n)\\n            if length_cycle > 0:\\n                res = min(res, length_cycle)\\n        return res if res != float(\\'inf\\') else -1\\n\\n    def bfs(self, u: int, adj: List[List[int]], n: int) -> int:\\n        dist = [-1] * n\\n        dist[u] = 0\\n        q = deque([u])\\n        while q:\\n            v = q.popleft()\\n            for w in adj[v]:\\n                if dist[w] == -1:\\n                    dist[w] = dist[v] + 1\\n                    q.append(w)\\n                elif dist[v] <= dist[w]:\\n                    return dist[v] + dist[w] + 1\\n        return -1\\n```\\n---\\n# Iterative DFS\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tint dfs(int i, vector<vector<int>>& adj) {\\n\\t\\tvector<int> d(adj.size(), INT_MAX);\\n\\t\\tstack<pair<int,int>> st;\\n\\t\\tst.push({i, 0});\\n\\t\\tint min_cycle_len = INT_MAX;\\n\\t\\twhile (!st.empty()) {\\n\\t\\t\\tauto [node, depth] = st.top(); st.pop();\\n\\t\\t\\tif (depth >= min_cycle_len) continue;\\n\\t\\t\\tif (d[node] != INT_MAX) {\\n\\t\\t\\t\\tif (depth - d[node] > 2) {\\n\\t\\t\\t\\t\\tmin_cycle_len = min(min_cycle_len, depth - d[node]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(d[node] > depth){\\n\\t\\t\\t\\td[node] = depth;\\n\\t\\t\\t\\tfor (int j : adj[node]) {\\n\\t\\t\\t\\t\\tst.push({j, depth + 1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn min_cycle_len;\\n\\t}\\n\\n\\tint findShortestCycle(int n, vector<vector<int>>& edges) {\\n\\t\\tvector<vector<int>> adj(n);\\n\\t\\tfor (const auto &e : edges) {\\n\\t\\t\\tadj[e[0]].push_back(e[1]);\\n\\t\\t\\tadj[e[1]].push_back(e[0]);\\n\\t\\t}\\n\\t\\tint res = INT_MAX;\\n\\t\\tfor (int u = 0; u < n; ++u){\\n\\t\\t\\tres = min(res, dfs(u, adj));\\n\\t\\t}\\n\\t\\treturn res == INT_MAX ? -1 : res;\\n\\t}\\n};\\n```\\n---\\n# Union-Find + Iterative Deepening Search\\n# Complexity\\n- Time complexity: $$O(nlogn + elogn)$$\\n    - UnionFind\\n        - constructor is $$O(n)$$, as it needs to initialize the parent and rank arrays for all n vertices. \\n        - find method is $$O(log n)$$ as it needs to traverse the parent array to find the root of a group. \\n\\t    - unionSet method is also $$O(log n)$$, as it needs to find the roots of the groups of x and y, and then update the parent and rank arrays accordingly.\\n    - Building the adjacency list is $$O(e)$$, where *e* is the number of edges.\\n    - DFS function is $$O(n * (e/n)) = O(e)$$, as it traverses all edges in the worst case. \\n    - Main loop is $$O(n log n)$$, as we need to find the root of each vertex using UnionFind.find and call the DFS function for each unique group.\\n\\n- Space complexity: $$O(N+E)$$\\n    - UnionFind: $$O(n)$$\\n    - Adjacency list: $$O(e)$$\\n    - Hashset: $$O(m)$$, m is the number of groups.\\n    - Stack in DFS: $$O(n)$$\\n\\n```C++ []\\nclass UnionFind {\\nprivate:\\n\\tvector<int> parent, rank;\\npublic:\\n\\tUnionFind(int n) {\\n\\t\\tparent.resize(n);\\n\\t\\trank.resize(n);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\trank[i] = 1;\\n\\t\\t}\\n\\t}\\n\\tint find(int x) {\\n\\t\\tif (parent[x] != x) {\\n\\t\\t\\tparent[x] = find(parent[x]);\\n\\t\\t}\\n\\t\\treturn parent[x];\\n\\t}\\n\\tvoid unionSet(int x, int y) {\\n\\t\\tint rootX = find(x), rootY = find(y);\\n\\t\\tif (rootX == rootY) return;\\n\\t\\tif (rank[rootX] < rank[rootY]) swap(rootX, rootY);\\n\\t\\tparent[rootY] = rootX;\\n\\t\\trank[rootX] += rank[rootY];\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n\\tint findShortestCycle(int n, vector<vector<int>>& edges) {\\n\\t\\tUnionFind UnionFind(n);\\n\\t\\tfor (auto edge : edges) {\\n\\t\\t\\tUnionFind.unionSet(edge[0], edge[1]);\\n\\t\\t}\\n\\t\\t\\n\\t\\tvector<vector<int>> adj(n);\\n\\t\\tfor (const auto &e : edges) {\\n\\t\\t\\tadj[e[0]].push_back(e[1]);\\n\\t\\t\\tadj[e[1]].push_back(e[0]);\\n\\t\\t}\\n\\t\\t\\n\\t\\tint res = INT_MAX;\\n\\t\\tvector<bool> visited(n, false);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint group = UnionFind.find(i);\\n\\t\\t\\tif (visited[group]) continue;\\n\\t\\t\\tvisited[group] = true;\\n\\t\\t\\t\\n\\t\\t\\tres = min(res, dfs(i, adj));\\n\\t\\t}\\n\\t\\treturn res == INT_MAX ? -1 : res;\\n\\t}\\nprivate:\\n\\tint dfs(int i, vector<vector<int>>& adj) {\\n\\t\\tvector<int> d(adj.size(), INT_MAX);\\n\\t\\tstack<pair<int,int>> st;\\n\\t\\tst.push({i, 0});\\n\\t\\tint min_cycle_len = INT_MAX;\\n\\t\\twhile (!st.empty()) {\\n\\t\\t\\tauto [node, depth] = st.top(); st.pop();\\n\\t\\t\\tif (d[node] != INT_MAX) {\\n\\t\\t\\t\\tif (depth - d[node] > 2) {\\n\\t\\t\\t\\t\\tmin_cycle_len = min(min_cycle_len, depth - d[node]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(d[node] > depth){\\n\\t\\t\\t\\td[node] = depth;\\n\\t\\t\\t\\tfor (int j : adj[node]) {\\n\\t\\t\\t\\t\\tst.push({j, depth + 1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn min_cycle_len;\\n\\t}\\t\\n};\\n```\\n```python []\\nclass UnionFind:\\n\\tdef __init__(self, n):\\n\\t\\tself.parent = [i for i in range(n)]\\n\\t\\tself.rank = [1] * n\\n\\n\\tdef find(self, x):\\n\\t\\tif self.parent[x] != x:\\n\\t\\t\\tself.parent[x] = self.find(self.parent[x])\\n\\t\\treturn self.parent[x]\\n\\n\\tdef unionSet(self, x, y):\\n\\t\\trootX = self.find(x)\\n\\t\\trootY = self.find(y)\\n\\t\\tif rootX == rootY: return\\n\\t\\tif self.rank[rootX] < self.rank[rootY]:\\n\\t\\t\\trootX, rootY = rootY, rootX\\n\\t\\tself.parent[rootY] = rootX\\n\\t\\tself.rank[rootX] += self.rank[rootY]\\n\\nclass Solution:\\n\\tdef findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n\\t\\tUnionFindObj = UnionFind(n)\\n\\t\\tfor edge in edges:\\n\\t\\t\\tUnionFindObj.unionSet(edge[0], edge[1])\\n\\n\\t\\tadj = [[] for _ in range(n)]\\n\\t\\tfor e in edges:\\n\\t\\t\\tadj[e[0]].append(e[1])\\n\\t\\t\\tadj[e[1]].append(e[0])\\n\\t\\t\\n\\t\\tres = float(\\'inf\\')\\n\\t\\tvisitedgroup = set()\\n\\t\\tfor i in range(n):\\n\\t\\t\\tgroup = UnionFindObj.find(i)\\n\\t\\t\\tif group in visitedgroup:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tvisitedgroup.add(group)\\n\\t\\t\\tres = min(res, self.dfs(i, adj))\\n\\t\\treturn res if res != float(\\'inf\\') else -1\\n\\n\\tdef dfs(self, i, adj):\\n\\t\\td = [float(\\'inf\\')] * len(adj)\\n\\t\\tst = [(i, 0)]\\n\\t\\tmin_cycle_len = float(\\'inf\\')\\n\\t\\twhile st:\\n\\t\\t\\tnode, depth = st.pop()\\n\\t\\t\\tif d[node] != float(\\'inf\\'):\\n\\t\\t\\t\\tif depth - d[node] > 2:\\n\\t\\t\\t\\t\\tmin_cycle_len = min(min_cycle_len, depth - d[node])\\n\\t\\t\\tif d[node] > depth:\\n\\t\\t\\t\\td[node] = depth\\n\\t\\t\\t\\tfor j in adj[node]:\\n\\t\\t\\t\\t\\tst.append((j, depth + 1))\\n\\t\\treturn min_cycle_len\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(n);\\n        for (const auto& e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        int res = INT_MAX;\\n        for (int u = 0; u < n; ++u) {\\n            int length_cycle = bfs(u, adj);\\n            if(length_cycle < 0) continue;\\n            res = min(res, length_cycle);\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n\\nprivate:\\n    int bfs(int u, const vector<vector<int>>& adj) {\\n        int n = adj.size();\\n        vector<int> dist(n, -1);\\n        dist[u] = 0;\\n        queue<int> q{{u}};\\n        while (!q.empty()) {\\n            int v = q.front(); q.pop();\\n            for (int w : adj[v]) {\\n                if (dist[w] == -1) {\\n                    dist[w] = dist[v] + 1;\\n                    q.push(w);\\n                } else if (dist[v] <= dist[w]) {\\n                    return dist[v] + dist[w] + 1;\\n                } \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for e in edges:\\n            adj[e[0]].append(e[1])\\n            adj[e[1]].append(e[0])\\n\\n        res = float(\\'inf\\')\\n        for u in range(n):\\n            length_cycle = self.bfs(u, adj, n)\\n            if length_cycle > 0:\\n                res = min(res, length_cycle)\\n        return res if res != float(\\'inf\\') else -1\\n\\n    def bfs(self, u: int, adj: List[List[int]], n: int) -> int:\\n        dist = [-1] * n\\n        dist[u] = 0\\n        q = deque([u])\\n        while q:\\n            v = q.popleft()\\n            for w in adj[v]:\\n                if dist[w] == -1:\\n                    dist[w] = dist[v] + 1\\n                    q.append(w)\\n                elif dist[v] <= dist[w]:\\n                    return dist[v] + dist[w] + 1\\n        return -1\\n```\n```\\nclass Solution {\\npublic:\\n\\tint dfs(int i, vector<vector<int>>& adj) {\\n\\t\\tvector<int> d(adj.size(), INT_MAX);\\n\\t\\tstack<pair<int,int>> st;\\n\\t\\tst.push({i, 0});\\n\\t\\tint min_cycle_len = INT_MAX;\\n\\t\\twhile (!st.empty()) {\\n\\t\\t\\tauto [node, depth] = st.top(); st.pop();\\n\\t\\t\\tif (depth >= min_cycle_len) continue;\\n\\t\\t\\tif (d[node] != INT_MAX) {\\n\\t\\t\\t\\tif (depth - d[node] > 2) {\\n\\t\\t\\t\\t\\tmin_cycle_len = min(min_cycle_len, depth - d[node]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(d[node] > depth){\\n\\t\\t\\t\\td[node] = depth;\\n\\t\\t\\t\\tfor (int j : adj[node]) {\\n\\t\\t\\t\\t\\tst.push({j, depth + 1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn min_cycle_len;\\n\\t}\\n\\n\\tint findShortestCycle(int n, vector<vector<int>>& edges) {\\n\\t\\tvector<vector<int>> adj(n);\\n\\t\\tfor (const auto &e : edges) {\\n\\t\\t\\tadj[e[0]].push_back(e[1]);\\n\\t\\t\\tadj[e[1]].push_back(e[0]);\\n\\t\\t}\\n\\t\\tint res = INT_MAX;\\n\\t\\tfor (int u = 0; u < n; ++u){\\n\\t\\t\\tres = min(res, dfs(u, adj));\\n\\t\\t}\\n\\t\\treturn res == INT_MAX ? -1 : res;\\n\\t}\\n};\\n```\n```C++ []\\nclass UnionFind {\\nprivate:\\n\\tvector<int> parent, rank;\\npublic:\\n\\tUnionFind(int n) {\\n\\t\\tparent.resize(n);\\n\\t\\trank.resize(n);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\trank[i] = 1;\\n\\t\\t}\\n\\t}\\n\\tint find(int x) {\\n\\t\\tif (parent[x] != x) {\\n\\t\\t\\tparent[x] = find(parent[x]);\\n\\t\\t}\\n\\t\\treturn parent[x];\\n\\t}\\n\\tvoid unionSet(int x, int y) {\\n\\t\\tint rootX = find(x), rootY = find(y);\\n\\t\\tif (rootX == rootY) return;\\n\\t\\tif (rank[rootX] < rank[rootY]) swap(rootX, rootY);\\n\\t\\tparent[rootY] = rootX;\\n\\t\\trank[rootX] += rank[rootY];\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n\\tint findShortestCycle(int n, vector<vector<int>>& edges) {\\n\\t\\tUnionFind UnionFind(n);\\n\\t\\tfor (auto edge : edges) {\\n\\t\\t\\tUnionFind.unionSet(edge[0], edge[1]);\\n\\t\\t}\\n\\t\\t\\n\\t\\tvector<vector<int>> adj(n);\\n\\t\\tfor (const auto &e : edges) {\\n\\t\\t\\tadj[e[0]].push_back(e[1]);\\n\\t\\t\\tadj[e[1]].push_back(e[0]);\\n\\t\\t}\\n\\t\\t\\n\\t\\tint res = INT_MAX;\\n\\t\\tvector<bool> visited(n, false);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint group = UnionFind.find(i);\\n\\t\\t\\tif (visited[group]) continue;\\n\\t\\t\\tvisited[group] = true;\\n\\t\\t\\t\\n\\t\\t\\tres = min(res, dfs(i, adj));\\n\\t\\t}\\n\\t\\treturn res == INT_MAX ? -1 : res;\\n\\t}\\nprivate:\\n\\tint dfs(int i, vector<vector<int>>& adj) {\\n\\t\\tvector<int> d(adj.size(), INT_MAX);\\n\\t\\tstack<pair<int,int>> st;\\n\\t\\tst.push({i, 0});\\n\\t\\tint min_cycle_len = INT_MAX;\\n\\t\\twhile (!st.empty()) {\\n\\t\\t\\tauto [node, depth] = st.top(); st.pop();\\n\\t\\t\\tif (d[node] != INT_MAX) {\\n\\t\\t\\t\\tif (depth - d[node] > 2) {\\n\\t\\t\\t\\t\\tmin_cycle_len = min(min_cycle_len, depth - d[node]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(d[node] > depth){\\n\\t\\t\\t\\td[node] = depth;\\n\\t\\t\\t\\tfor (int j : adj[node]) {\\n\\t\\t\\t\\t\\tst.push({j, depth + 1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn min_cycle_len;\\n\\t}\\t\\n};\\n```\n```python []\\nclass UnionFind:\\n\\tdef __init__(self, n):\\n\\t\\tself.parent = [i for i in range(n)]\\n\\t\\tself.rank = [1] * n\\n\\n\\tdef find(self, x):\\n\\t\\tif self.parent[x] != x:\\n\\t\\t\\tself.parent[x] = self.find(self.parent[x])\\n\\t\\treturn self.parent[x]\\n\\n\\tdef unionSet(self, x, y):\\n\\t\\trootX = self.find(x)\\n\\t\\trootY = self.find(y)\\n\\t\\tif rootX == rootY: return\\n\\t\\tif self.rank[rootX] < self.rank[rootY]:\\n\\t\\t\\trootX, rootY = rootY, rootX\\n\\t\\tself.parent[rootY] = rootX\\n\\t\\tself.rank[rootX] += self.rank[rootY]\\n\\nclass Solution:\\n\\tdef findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n\\t\\tUnionFindObj = UnionFind(n)\\n\\t\\tfor edge in edges:\\n\\t\\t\\tUnionFindObj.unionSet(edge[0], edge[1])\\n\\n\\t\\tadj = [[] for _ in range(n)]\\n\\t\\tfor e in edges:\\n\\t\\t\\tadj[e[0]].append(e[1])\\n\\t\\t\\tadj[e[1]].append(e[0])\\n\\t\\t\\n\\t\\tres = float(\\'inf\\')\\n\\t\\tvisitedgroup = set()\\n\\t\\tfor i in range(n):\\n\\t\\t\\tgroup = UnionFindObj.find(i)\\n\\t\\t\\tif group in visitedgroup:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tvisitedgroup.add(group)\\n\\t\\t\\tres = min(res, self.dfs(i, adj))\\n\\t\\treturn res if res != float(\\'inf\\') else -1\\n\\n\\tdef dfs(self, i, adj):\\n\\t\\td = [float(\\'inf\\')] * len(adj)\\n\\t\\tst = [(i, 0)]\\n\\t\\tmin_cycle_len = float(\\'inf\\')\\n\\t\\twhile st:\\n\\t\\t\\tnode, depth = st.pop()\\n\\t\\t\\tif d[node] != float(\\'inf\\'):\\n\\t\\t\\t\\tif depth - d[node] > 2:\\n\\t\\t\\t\\t\\tmin_cycle_len = min(min_cycle_len, depth - d[node])\\n\\t\\t\\tif d[node] > depth:\\n\\t\\t\\t\\td[node] = depth\\n\\t\\t\\t\\tfor j in adj[node]:\\n\\t\\t\\t\\t\\tst.append((j, depth + 1))\\n\\t\\treturn min_cycle_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371278,
                "title": "c-100-faster-in-space-and-time-solution-using-bfs",
                "content": "```\\nint findShortestCycle(int n, vector<vector<int>>& edges) {\\n        \\n        vector<set<int>>g(n) ;\\n        \\n        for( auto i : edges )\\n        {\\n            g[i[0]].insert(i[1]) ;\\n            g[i[1]].insert(i[0]) ;\\n        }\\n        \\n        int ans = INT_MAX ;\\n        \\n        for( auto e : edges )\\n        {\\n            g[e[0]].erase(e[1]) ;\\n            g[e[1]].erase(e[0]) ;\\n            \\n            vector<int>dis( n , 100000 ) ;\\n            queue<int>q ;\\n            \\n            q.push(e[0]) ;\\n            vector<bool>vis( n , false ) ;\\n            vis[e[0]] = true ;\\n            dis[e[0]] = 0 ;\\n            \\n            while(!q.empty())\\n            {\\n                auto it = q.front() ;\\n                q.pop() ;\\n                \\n                for( auto c : g[it] )\\n                {\\n                    if(!vis[c] && dis[it] + 1 < dis[c] )\\n                    {\\n                        dis[c] = dis[it] + 1 ;\\n                        vis[c] = true ;\\n                        q.push(c) ;\\n                    }\\n                }\\n            }\\n            \\n            ans = min( ans ,  dis[e[0]] + dis[e[1]] + 1 ) ;\\n            \\n        }\\n        \\n        if( ans >= 100000 ) return -1 ;\\n        \\n        return ans ;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findShortestCycle(int n, vector<vector<int>>& edges) {\\n        \\n        vector<set<int>>g(n) ;\\n        \\n        for( auto i : edges )\\n        {\\n            g[i[0]].insert(i[1]) ;\\n            g[i[1]].insert(i[0]) ;\\n        }\\n        \\n        int ans = INT_MAX ;\\n        \\n        for( auto e : edges )\\n        {\\n            g[e[0]].erase(e[1]) ;\\n            g[e[1]].erase(e[0]) ;\\n            \\n            vector<int>dis( n , 100000 ) ;\\n            queue<int>q ;\\n            \\n            q.push(e[0]) ;\\n            vector<bool>vis( n , false ) ;\\n            vis[e[0]] = true ;\\n            dis[e[0]] = 0 ;\\n            \\n            while(!q.empty())\\n            {\\n                auto it = q.front() ;\\n                q.pop() ;\\n                \\n                for( auto c : g[it] )\\n                {\\n                    if(!vis[c] && dis[it] + 1 < dis[c] )\\n                    {\\n                        dis[c] = dis[it] + 1 ;\\n                        vis[c] = true ;\\n                        q.push(c) ;\\n                    }\\n                }\\n            }\\n            \\n            ans = min( ans ,  dis[e[0]] + dis[e[1]] + 1 ) ;\\n            \\n        }\\n        \\n        if( ans >= 100000 ) return -1 ;\\n        \\n        return ans ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3371122,
                "title": "bfs-with-an-easier-mental-model",
                "content": "# Intuition & Approach\\n1. Notice that plain DFS does not work for this problem.\\nPlain DFS traverses a group of connected vertices only once. However, this does not guarantee that it could find the shortest length of a cycle in a group. Counter example is `n = 8, graph = \\n[[0,1],[1,2],[2,3],[3,4],[4,5],[0,7],[0,6],[5,7],[5,6]]`.\\n\\n2. Try to generalize the problem using the meaning of \"cycle\".\\nCycle means that a starting node and an ending node are the same. In other words, starting from node `v`, we can certainly comeback to the node `v` if it has a cycle. So, let\\'s find the shortest cycle length from `v1` to `v1`, from `v2` to `v2`, and so on, and so forth, and take the smallest one of them!\\n\\n3. Use BFS since it is suitable to find the shortest path from a node to another node.\\n\\nGot this intuition after reading [this post](https://leetcode.com/problems/shortest-cycle-in-a-graph/solutions/3366500/java-c-python-bfs/?orderBy=most_votes%20) and [this post](https://leetcode.com/problems/shortest-cycle-in-a-graph/solutions/3366696/video-explanation-with-intuitive-proof/?orderBy=most_votes) after the contest. Thanks to them.\\n\\n# Complexity\\n- Time complexity: O(V * (V + E)) where V is the number of vertices and E is the number of edges.\\n\\n- Space complexity: O(V)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>> &edges) {\\n        // 1. make a graph.\\n        unordered_map<int, vector<int>> graph;\\n        for (const auto &edge: edges) {\\n            int v1 = edge[0], v2 = edge[1];\\n            graph[v1].push_back(v2);\\n            graph[v2].push_back(v1);\\n        }\\n\\n        int shortest = INT_MAX;\\n\\n        // 2. find the shortest cycle paths from each node to the same node,\\n        //    and take the smallest one as an answer.\\n        for (int v = 0; v < n; ++v) {\\n            queue<int> bfs_q;\\n            vector<int> dists(n, INT_MAX); // distances from root node.\\n            bfs_q.push(v);\\n            dists[v] = 0;\\n\\n            bool found = false;\\n            while (!bfs_q.empty() && !found) {\\n                for (int i = bfs_q.size(); i > 0; --i) {\\n                    int cur = bfs_q.front();\\n                    bfs_q.pop();\\n\\n                    for (int near: graph[cur]) {\\n                        if (dists[near] < dists[cur]) // filter out parent-child case\\n                            continue;\\n                        if (dists[near] != INT_MAX) {\\n                            shortest = min(shortest, dists[cur] + dists[near] + 1);\\n                            found = true;\\n                            continue;\\n                        }\\n                        dists[near] = dists[cur] + 1;\\n                        bfs_q.push(near);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return shortest == INT_MAX ? -1 : shortest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>> &edges) {\\n        // 1. make a graph.\\n        unordered_map<int, vector<int>> graph;\\n        for (const auto &edge: edges) {\\n            int v1 = edge[0], v2 = edge[1];\\n            graph[v1].push_back(v2);\\n            graph[v2].push_back(v1);\\n        }\\n\\n        int shortest = INT_MAX;\\n\\n        // 2. find the shortest cycle paths from each node to the same node,\\n        //    and take the smallest one as an answer.\\n        for (int v = 0; v < n; ++v) {\\n            queue<int> bfs_q;\\n            vector<int> dists(n, INT_MAX); // distances from root node.\\n            bfs_q.push(v);\\n            dists[v] = 0;\\n\\n            bool found = false;\\n            while (!bfs_q.empty() && !found) {\\n                for (int i = bfs_q.size(); i > 0; --i) {\\n                    int cur = bfs_q.front();\\n                    bfs_q.pop();\\n\\n                    for (int near: graph[cur]) {\\n                        if (dists[near] < dists[cur]) // filter out parent-child case\\n                            continue;\\n                        if (dists[near] != INT_MAX) {\\n                            shortest = min(shortest, dists[cur] + dists[near] + 1);\\n                            found = true;\\n                            continue;\\n                        }\\n                        dists[near] = dists[cur] + 1;\\n                        bfs_q.push(near);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return shortest == INT_MAX ? -1 : shortest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370813,
                "title": "python-100-time-and-100-space-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe should connect edges if they have edges. we will use Disjoint set(Union find). Then when we try to join two nodes if they have the same root, that means there is a cycle. so we will run bfs to find the distance between two edges.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn(v + e)$$) \\nthe union find is worst case $$O(nlogn$$) and the bfs $$O(v + e$$)\\n\\n# Code\\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        parent = [i for i in range(n)]\\n        rank = [1] * n\\n        def bfs(s, e):\\n            q = deque([s])\\n            ans = 0\\n            vis = set()\\n            while q:\\n                size = len(q)\\n                for _ in range(size):\\n                    top = q.popleft()\\n                    vis.add(top)\\n                    if top == e:\\n                        return ans\\n                    for nbr in graph[top]:\\n                        if nbr not in vis:\\n                            q.append(nbr)\\n                ans += 1\\n        def f(x):\\n            if x == parent[x]:\\n                return x\\n            parent[x] = f(parent[x])\\n            return parent[x]\\n        ans = inf\\n        def u(x, y):\\n            nonlocal ans\\n            px = f(x)\\n            py = f(y)\\n\\n            if px == py:\\n                ans = min(ans, bfs(x,y) + 1)\\n            else:\\n                if rank[px] > rank[py]:\\n                    parent[py] = px\\n                    rank[px] += rank[py]\\n                else:\\n                    parent[px] = py\\n                    rank[py] += rank[px]\\n        for a, b in edges:\\n            u(a, b)\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        return ans if ans != inf else -1\\n\\n        \\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        parent = [i for i in range(n)]\\n        rank = [1] * n\\n        def bfs(s, e):\\n            q = deque([s])\\n            ans = 0\\n            vis = set()\\n            while q:\\n                size = len(q)\\n                for _ in range(size):\\n                    top = q.popleft()\\n                    vis.add(top)\\n                    if top == e:\\n                        return ans\\n                    for nbr in graph[top]:\\n                        if nbr not in vis:\\n                            q.append(nbr)\\n                ans += 1\\n        def f(x):\\n            if x == parent[x]:\\n                return x\\n            parent[x] = f(parent[x])\\n            return parent[x]\\n        ans = inf\\n        def u(x, y):\\n            nonlocal ans\\n            px = f(x)\\n            py = f(y)\\n\\n            if px == py:\\n                ans = min(ans, bfs(x,y) + 1)\\n            else:\\n                if rank[px] > rank[py]:\\n                    parent[py] = px\\n                    rank[px] += rank[py]\\n                else:\\n                    parent[px] = py\\n                    rank[py] += rank[px]\\n        for a, b in edges:\\n            u(a, b)\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        return ans if ans != inf else -1\\n\\n        \\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370796,
                "title": "antarnab-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   // public int findShortestCycle(int n, int[][] edges) {\\n            private static final int MX = Integer.MAX_VALUE; \\n    public int findShortestCycle(int n, int[][] edges) {\\n        Map<Integer, Set<Integer>> g = new HashMap<>();\\n        for (int[] e : edges) {\\n            g.computeIfAbsent(e[0], s -> new HashSet<>()).add(e[1]);\\n            g.computeIfAbsent(e[1], s -> new HashSet<>()).add(e[0]);\\n        }\\n        int s = MX;\\n        for (int i = 0; i < n; ++i) {\\n            int[] dist = new int[n], parent = new int[n];\\n            Arrays.fill(dist, MX);\\n            Arrays.fill(parent, -1);\\n            Queue<Integer> q = new LinkedList<>();\\n            q.offer(i);\\n            dist[i] = 0;\\n            while (!q.isEmpty()) {\\n                int node = q.poll();\\n                for (int kid : g.getOrDefault(node, Collections.emptySet())) {\\n                    if (dist[kid] == MX) {\\n                        dist[kid] = dist[node] + 1;\\n                        parent[kid] = node;\\n                        q.offer(kid);\\n                    }else if (parent[kid] != node && parent[node] != kid) {\\n                        s = Math.min(s, dist[kid] + dist[node] + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return s == MX ? -1 : s;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   // public int findShortestCycle(int n, int[][] edges) {\\n            private static final int MX = Integer.MAX_VALUE; \\n    public int findShortestCycle(int n, int[][] edges) {\\n        Map<Integer, Set<Integer>> g = new HashMap<>();\\n        for (int[] e : edges) {\\n            g.computeIfAbsent(e[0], s -> new HashSet<>()).add(e[1]);\\n            g.computeIfAbsent(e[1], s -> new HashSet<>()).add(e[0]);\\n        }\\n        int s = MX;\\n        for (int i = 0; i < n; ++i) {\\n            int[] dist = new int[n], parent = new int[n];\\n            Arrays.fill(dist, MX);\\n            Arrays.fill(parent, -1);\\n            Queue<Integer> q = new LinkedList<>();\\n            q.offer(i);\\n            dist[i] = 0;\\n            while (!q.isEmpty()) {\\n                int node = q.poll();\\n                for (int kid : g.getOrDefault(node, Collections.emptySet())) {\\n                    if (dist[kid] == MX) {\\n                        dist[kid] = dist[node] + 1;\\n                        parent[kid] = node;\\n                        q.offer(kid);\\n                    }else if (parent[kid] != node && parent[node] != kid) {\\n                        s = Math.min(s, dist[kid] + dist[node] + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return s == MX ? -1 : s;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370559,
                "title": "c-shortest-cycle-in-graph-passing-all-testcases",
                "content": "**If Helpful Please like or Upvoke**\\n```\\nclass Solution {\\npublic:\\n    \\n     int dfs(int n, vector<int>adj[]){ \\n         int ans=1e9;\\n         \\n    for (int i = 0; i < n; i++) {\\n\\n        vector<int> dist(n, 1e9);\\n        vector<int> par(n, -1);\\n        dist[i] = 0;\\n        queue<int> q;\\n        q.push(i);\\n        while (!q.empty()) {\\n            int x = q.front();\\n            q.pop();\\n            for (int child :adj[x]) {\\n                if (dist[child] ==1e9) {\\n                    dist[child] = 1 + dist[x];\\n                    par[child] = x;\\n                    q.push(child);\\n                }\\n                else if (par[x] != child and par[child] != x)\\n                    ans = min(ans, dist[x] + dist[child] + 1);\\n            }\\n        }\\n    }\\n\\n    if (ans == 1e9)\\n        return -1;\\n    else\\n        return ans;\\n}\\n     \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n       \\n        for(auto i: edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        \\n        return dfs(n, adj);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     int dfs(int n, vector<int>adj[]){ \\n         int ans=1e9;\\n         \\n    for (int i = 0; i < n; i++) {\\n\\n        vector<int> dist(n, 1e9);\\n        vector<int> par(n, -1);\\n        dist[i] = 0;\\n        queue<int> q;\\n        q.push(i);\\n        while (!q.empty()) {\\n            int x = q.front();\\n            q.pop();\\n            for (int child :adj[x]) {\\n                if (dist[child] ==1e9) {\\n                    dist[child] = 1 + dist[x];\\n                    par[child] = x;\\n                    q.push(child);\\n                }\\n                else if (par[x] != child and par[child] != x)\\n                    ans = min(ans, dist[x] + dist[child] + 1);\\n            }\\n        }\\n    }\\n\\n    if (ans == 1e9)\\n        return -1;\\n    else\\n        return ans;\\n}\\n     \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n       \\n        for(auto i: edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        \\n        return dfs(n, adj);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370519,
                "title": "easy-to-understand-heavily-commented-beats-90-c-dfs-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic DFS going down on nodes and if a node is already visited and is not parent i.e found a cycle then update ans\\n\\n```ans = len+1-visited[x];```\\n\\nAs len here is length of curr node from starting node visited is storing its previous length or distance we just have to subtract that and we will get the length of cycle.\\n\\n# Complexity\\n- Time complexity:  $$O(n*n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nas we are performing dfs from each node.\\n\\n\\n- Space complexity:  $$O(n) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ans = INT_MAX;\\n\\n\\n    void dfs(map<int,vector<int>>&graph,vector<int>&visited,int node,int len,int parent)\\n    {\\n        visited[node] = len;\\n        for(auto&x:graph[node])\\n        {\\n            \\n            if(visited[x]==-1  )\\n            {\\n                dfs(graph,visited,x,len+1,node);\\n            }\\n            else if(x!=parent  )\\n            {\\n                // cout<<node<<\" \"<<x<<endl;\\n                if(len+1-visited[x] >0)\\n                    ans = min(ans,len+1-visited[x]);\\n            }\\n        }\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        \\n        map<int,vector<int>>graph;\\n        for(auto&x:edges)\\n        {\\n            int u = x[0];\\n            int v = x[1];\\n\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n\\n        }\\n       \\n    //dfs from each node as a single node can appear in multiple cycles\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>visited(n,-1);\\n            dfs(graph,visited,i,0,-1);\\n           \\n        }\\n\\n        return ans==INT_MAX ?-1:ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```ans = len+1-visited[x];```\n```\\nclass Solution {\\n    int ans = INT_MAX;\\n\\n\\n    void dfs(map<int,vector<int>>&graph,vector<int>&visited,int node,int len,int parent)\\n    {\\n        visited[node] = len;\\n        for(auto&x:graph[node])\\n        {\\n            \\n            if(visited[x]==-1  )\\n            {\\n                dfs(graph,visited,x,len+1,node);\\n            }\\n            else if(x!=parent  )\\n            {\\n                // cout<<node<<\" \"<<x<<endl;\\n                if(len+1-visited[x] >0)\\n                    ans = min(ans,len+1-visited[x]);\\n            }\\n        }\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        \\n        map<int,vector<int>>graph;\\n        for(auto&x:edges)\\n        {\\n            int u = x[0];\\n            int v = x[1];\\n\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n\\n        }\\n       \\n    //dfs from each node as a single node can appear in multiple cycles\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>visited(n,-1);\\n            dfs(graph,visited,i,0,-1);\\n           \\n        }\\n\\n        return ans==INT_MAX ?-1:ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3370518,
                "title": "bfs-python-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. \\n-->\\nUse BFS on each node to find the cycle that starts with that node.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe BFS will split to multiple paths to visit, if a path converges, the `dist[currNode]` <= `dist[neighbour]`. \\nif `dist[neighbour]` < `dist[currNode]` this would just mean represent the bidirection cycle of a parent and child\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        g = defaultdict(list)\\n        \\n        for u,v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        \\n        minCycle = float(\\'inf\\')\\n\\n        def findCycle(root):\\n            nonlocal minCycle\\n\\n            dist = [-1] * n\\n            dist[root] = 0\\n            q = deque()\\n            q.append(root)\\n\\n            while len(q) > 0:\\n                currNode = q.popleft()\\n                \\n                # search neighbours through BFS\\n                for neighbour in g[currNode]:\\n\\n                    # if node was not visited before\\n                    if dist[neighbour] == -1:\\n                        dist[neighbour] = dist[currNode] + 1\\n                        q.append(neighbour)\\n                    \\n                    # make sure that the cycle is not just because of the bidirectional children-father relationship and the current Node is previously visited by this BFS, if neighbour is previously explored and current Node was explroed\\n                    elif currNode != neighbour and dist[currNode] <= dist[neighbour]:\\n                        cycleLen = dist[currNode] + dist[neighbour] + 1\\n                        minCycle = min(minCycle,cycleLen)\\n\\n        for i in range(n):\\n            findCycle(i)\\n        return minCycle if minCycle != float(\\'inf\\') else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        g = defaultdict(list)\\n        \\n        for u,v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        \\n        minCycle = float(\\'inf\\')\\n\\n        def findCycle(root):\\n            nonlocal minCycle\\n\\n            dist = [-1] * n\\n            dist[root] = 0\\n            q = deque()\\n            q.append(root)\\n\\n            while len(q) > 0:\\n                currNode = q.popleft()\\n                \\n                # search neighbours through BFS\\n                for neighbour in g[currNode]:\\n\\n                    # if node was not visited before\\n                    if dist[neighbour] == -1:\\n                        dist[neighbour] = dist[currNode] + 1\\n                        q.append(neighbour)\\n                    \\n                    # make sure that the cycle is not just because of the bidirectional children-father relationship and the current Node is previously visited by this BFS, if neighbour is previously explored and current Node was explroed\\n                    elif currNode != neighbour and dist[currNode] <= dist[neighbour]:\\n                        cycleLen = dist[currNode] + dist[neighbour] + 1\\n                        minCycle = min(minCycle,cycleLen)\\n\\n        for i in range(n):\\n            findCycle(i)\\n        return minCycle if minCycle != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370288,
                "title": "c-using-bfs-from-each-node-and-returning-the-minimum-cycle-among-them",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    class node{\\n        public:\\n        int data;\\n        vector<node*> neigh;\\n    };\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,node*> u;\\n        for(int i=0;i<int(edges.size());i++){\\n            if(!u[edges[i][0]]){\\n                node *n=new node();\\n                n->data=edges[i][0];\\n                u[edges[i][0]]=n;\\n            }\\n            if(!u[edges[i][1]]){\\n                node *n=new node();\\n                n->data=edges[i][1];\\n                u[edges[i][1]]=n;\\n            }\\n            u[edges[i][0]]->neigh.push_back(u[edges[i][1]]);\\n            u[edges[i][1]]->neigh.push_back(u[edges[i][0]]);\\n        }\\n\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(u[i]==nullptr){\\n                continue;\\n            }\\n            vector<int> visited(n,-1);\\n            queue<node*> q;\\n            int steps=1;\\n            q.push(u[i]);\\n            visited[i]=steps;\\n            q.push(nullptr);\\n            steps++;\\n\\n            while(int(q.size())>1){\\n                node *no=q.front();\\n                q.pop();\\n                if(!no){\\n                    q.push(nullptr);\\n                    steps++;\\n                    goto y;\\n                }\\n                for(int j=0;j<int(no->neigh.size());j++){\\n                    if(visited[no->neigh[j]->data]==-1){\\n                        q.push(no->neigh[j]);\\n                        visited[no->neigh[j]->data]=steps;\\n                    }\\n                    else if(visited[no->neigh[j]->data]==visited[no->data]-1){\\n                        continue;\\n                    }\\n                    else{\\n                        ans=min(ans,visited[no->data]+visited[no->neigh[j]->data]-1);\\n                        goto x;\\n                    }\\n                }\\n                y:;\\n            }\\n            cout<<endl;\\n            x:;\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class node{\\n        public:\\n        int data;\\n        vector<node*> neigh;\\n    };\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,node*> u;\\n        for(int i=0;i<int(edges.size());i++){\\n            if(!u[edges[i][0]]){\\n                node *n=new node();\\n                n->data=edges[i][0];\\n                u[edges[i][0]]=n;\\n            }\\n            if(!u[edges[i][1]]){\\n                node *n=new node();\\n                n->data=edges[i][1];\\n                u[edges[i][1]]=n;\\n            }\\n            u[edges[i][0]]->neigh.push_back(u[edges[i][1]]);\\n            u[edges[i][1]]->neigh.push_back(u[edges[i][0]]);\\n        }\\n\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(u[i]==nullptr){\\n                continue;\\n            }\\n            vector<int> visited(n,-1);\\n            queue<node*> q;\\n            int steps=1;\\n            q.push(u[i]);\\n            visited[i]=steps;\\n            q.push(nullptr);\\n            steps++;\\n\\n            while(int(q.size())>1){\\n                node *no=q.front();\\n                q.pop();\\n                if(!no){\\n                    q.push(nullptr);\\n                    steps++;\\n                    goto y;\\n                }\\n                for(int j=0;j<int(no->neigh.size());j++){\\n                    if(visited[no->neigh[j]->data]==-1){\\n                        q.push(no->neigh[j]);\\n                        visited[no->neigh[j]->data]=steps;\\n                    }\\n                    else if(visited[no->neigh[j]->data]==visited[no->data]-1){\\n                        continue;\\n                    }\\n                    else{\\n                        ans=min(ans,visited[no->data]+visited[no->neigh[j]->data]-1);\\n                        goto x;\\n                    }\\n                }\\n                y:;\\n            }\\n            cout<<endl;\\n            x:;\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3369583,
                "title": "java-simple-bfs",
                "content": "```\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<Integer>[] graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for (int[] e : edges) {\\n\\t\\t    // delete one edge (u,v), do a bfs to find the minimum distance between u and v, then the ans is dist + 1 \\n            ans = Math.min(bfs(graph, e[0], e[1]), ans);\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n\\n    int bfs(List<Integer>[] graph, int start, int end) {\\n        int dist = 0;\\n        Deque<Integer> queue = new LinkedList<>();\\n        boolean[] visited = new boolean[graph.length];\\n        visited[start] = true;\\n        queue.offer(start);\\n        while (!queue.isEmpty()) {\\n            for (int i = 0, size = queue.size(); i < size; i++) {\\n                int t = queue.poll();\\n                if (t == end) {\\n                    return dist + 1;\\n                }\\n                for (int g : graph[t]) {\\n                    if ((t == start && g == end) || visited[g]) {\\n                        continue;\\n                    }\\n                    visited[g] = true;\\n                    queue.offer(g);\\n                }\\n            }\\n            dist++;\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<Integer>[] graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for (int[] e : edges) {\\n\\t\\t    // delete one edge (u,v), do a bfs to find the minimum distance between u and v, then the ans is dist + 1 \\n            ans = Math.min(bfs(graph, e[0], e[1]), ans);\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n\\n    int bfs(List<Integer>[] graph, int start, int end) {\\n        int dist = 0;\\n        Deque<Integer> queue = new LinkedList<>();\\n        boolean[] visited = new boolean[graph.length];\\n        visited[start] = true;\\n        queue.offer(start);\\n        while (!queue.isEmpty()) {\\n            for (int i = 0, size = queue.size(); i < size; i++) {\\n                int t = queue.poll();\\n                if (t == end) {\\n                    return dist + 1;\\n                }\\n                for (int g : graph[t]) {\\n                    if ((t == start && g == end) || visited[g]) {\\n                        continue;\\n                    }\\n                    visited[g] = true;\\n                    queue.offer(g);\\n                }\\n            }\\n            dist++;\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369557,
                "title": "simple-bfs-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        // Create an adjacency list to represent the graph\\n        vector<vector<int>> adj(n);\\n        for(auto edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        int shortest = INT_MAX;\\n\\n        // For each vertex, find the shortest cycle that includes it\\n        for(int i = 0; i < n; i++) {\\n            // Initialize distance and parent arrays\\n            vector<int> dist(n, -1);\\n            vector<int> parent(n, -1);\\n            queue<int> q;\\n\\n            // Add the current vertex to the queue and set its distance to 0\\n            q.push(i);\\n            dist[i] = 0;\\n\\n            while(!q.empty()) {\\n                int u = q.front();\\n                q.pop();\\n                for(int v : adj[u]) {\\n                    if(v == parent[u]) {\\n                        continue; // Skip the parent node\\n                    }\\n                    if(dist[v] == -1) {\\n                        dist[v] = dist[u] + 1;\\n                        parent[v] = u;\\n                        q.push(v);\\n                    } \\n                    else if(parent[u] != v) {\\n                        shortest = min(shortest, dist[u] + dist[v] + 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (shortest == INT_MAX) ? -1 : shortest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        // Create an adjacency list to represent the graph\\n        vector<vector<int>> adj(n);\\n        for(auto edge : edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        int shortest = INT_MAX;\\n\\n        // For each vertex, find the shortest cycle that includes it\\n        for(int i = 0; i < n; i++) {\\n            // Initialize distance and parent arrays\\n            vector<int> dist(n, -1);\\n            vector<int> parent(n, -1);\\n            queue<int> q;\\n\\n            // Add the current vertex to the queue and set its distance to 0\\n            q.push(i);\\n            dist[i] = 0;\\n\\n            while(!q.empty()) {\\n                int u = q.front();\\n                q.pop();\\n                for(int v : adj[u]) {\\n                    if(v == parent[u]) {\\n                        continue; // Skip the parent node\\n                    }\\n                    if(dist[v] == -1) {\\n                        dist[v] = dist[u] + 1;\\n                        parent[v] = u;\\n                        q.push(v);\\n                    } \\n                    else if(parent[u] != v) {\\n                        shortest = min(shortest, dist[u] + dist[v] + 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (shortest == INT_MAX) ? -1 : shortest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369544,
                "title": "easy-solution-using-dfs-c",
                "content": "```\\nint ans=1001;\\n    void dfs(int i, int prnt, vector<vector<int>>& adj, vector<int>&dis,int d){\\n        dis[i]=d;\\n        \\n        for(auto it : adj[i]){\\n            if(dis[it]==0){\\n                dfs(it,i,adj,dis,d+1);\\n            }\\n            \\n            else if(prnt!=it){\\n                ans=min(ans,abs(d-dis[it])+1);\\n            }\\n        }\\n      \\n    }\\n    \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        vector<int>vis(n,0);\\n        \\n        for(auto i : edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int>dis(n,0);\\n           dfs(i,-1,adj,dis,1);\\n            \\n        }\\n        return ans==1001?-1:ans;\\n```\\n**Please Upvote If Found Useful**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nint ans=1001;\\n    void dfs(int i, int prnt, vector<vector<int>>& adj, vector<int>&dis,int d){\\n        dis[i]=d;\\n        \\n        for(auto it : adj[i]){\\n            if(dis[it]==0){\\n                dfs(it,i,adj,dis,d+1);\\n            }\\n            \\n            else if(prnt!=it){\\n                ans=min(ans,abs(d-dis[it])+1);\\n            }\\n        }\\n      \\n    }\\n    \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>>adj(n);\\n        vector<int>vis(n,0);\\n        \\n        for(auto i : edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            vector<int>dis(n,0);\\n           dfs(i,-1,adj,dis,1);\\n            \\n        }\\n        return ans==1001?-1:ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3369376,
                "title": "simple-dfs-in-java-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int min=(int)1e9;\\n    public void dfs(ArrayList<ArrayList<Integer>>arr,int n,int vis[],int length,int parent)\\n    {\\n        vis[n]=1;\\n        for(int a:arr.get(n))\\n        {\\n            if(vis[a]==1&&a!=parent)\\n            {\\n                min=Math.min(length+1,min);\\n                System.out.println(length+\" \"+n+\" \"+a);\\n            }\\n            else\\n            {\\n               if(a!=parent&&(length+1<min))\\n               {\\n                   \\n                  \\n                dfs(arr,a,vis,length+1,n);\\n               }\\n            \\n            }\\n        }\\n        vis[n]=0;\\n        \\n    }\\n    public int findShortestCycle(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>>arr=new ArrayList<ArrayList<Integer>>(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            arr.add(new ArrayList<Integer>());\\n\\n        }\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            arr.get(edges[i][0]).add(edges[i][1]);\\n             arr.get(edges[i][1]).add(edges[i][0]);\\n            \\n        } \\n        int visited[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            dfs(arr,i,visited,0,-1);\\n        }\\n        if(min==(int)1e9)\\n        {\\n            return -1;\\n        }\\n        return min;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int min=(int)1e9;\\n    public void dfs(ArrayList<ArrayList<Integer>>arr,int n,int vis[],int length,int parent)\\n    {\\n        vis[n]=1;\\n        for(int a:arr.get(n))\\n        {\\n            if(vis[a]==1&&a!=parent)\\n            {\\n                min=Math.min(length+1,min);\\n                System.out.println(length+\" \"+n+\" \"+a);\\n            }\\n            else\\n            {\\n               if(a!=parent&&(length+1<min))\\n               {\\n                   \\n                  \\n                dfs(arr,a,vis,length+1,n);\\n               }\\n            \\n            }\\n        }\\n        vis[n]=0;\\n        \\n    }\\n    public int findShortestCycle(int n, int[][] edges) {\\n        ArrayList<ArrayList<Integer>>arr=new ArrayList<ArrayList<Integer>>(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            arr.add(new ArrayList<Integer>());\\n\\n        }\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            arr.get(edges[i][0]).add(edges[i][1]);\\n             arr.get(edges[i][1]).add(edges[i][0]);\\n            \\n        } \\n        int visited[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            dfs(arr,i,visited,0,-1);\\n        }\\n        if(min==(int)1e9)\\n        {\\n            return -1;\\n        }\\n        return min;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369158,
                "title": "dfs-solution-easy-c-100-both-in-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int answer = INT_MAX;\\n    // void dfs(int node, vector<int>& edges, unordered_map<int, int>& dist, vector<bool>& visit) {\\n    //     visit[node] = true;\\n    //     int neighbor = edges[node];\\n\\n    //     if (neighbor != -1 && !visit[neighbor]) {\\n    //         dist[neighbor] = dist[node] + 1;\\n    //         dfs(neighbor, edges, dist, visit);\\n    //     } else if (neighbor != -1 && dist.count(neighbor)) {\\n    //         answer = max(answer, dist[node] - dist[neighbor] + 1);\\n    //     }\\n\\n    //     //Here is the code\\n    // }\\n\\n    void dfs(int node, vector<vector<int>>& graph, unordered_map<int, int>& dist, vector<bool> &isvisited,int parent){\\n        isvisited[node] = true;\\n        for(auto x:graph[node]){\\n            if(x!=parent){\\n                if(!isvisited[x]){\\n                    dist[x]=dist[node]+1;\\n                    dfs(x,graph,dist,isvisited,node);\\n                }\\n                else{\\n                    answer = min(answer,abs(dist[x]-dist[node])+1);\\n                }\\n            }\\n            \\n        }\\n\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            vector<bool> isvisited(n);\\n            unordered_map<int,int> dist;\\n            \\n            dfs(i,graph,dist,isvisited,i);\\n            \\n        }\\n       \\n        if(answer==INT_MAX){\\n            return -1;\\n        }\\n        \\n        return answer;\\n        \\n        \\n    }\\n};\\n\\n![image.png](https://assets.leetcode.com/users/images/c54cea91-bc59-4362-ad6c-e823de6566de_1680415521.5596159.png)\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int answer = INT_MAX;\\n    // void dfs(int node, vector<int>& edges, unordered_map<int, int>& dist, vector<bool>& visit) {\\n    //     visit[node] = true;\\n    //     int neighbor = edges[node];\\n\\n    //     if (neighbor != -1 && !visit[neighbor]) {\\n    //         dist[neighbor] = dist[node] + 1;\\n    //         dfs(neighbor, edges, dist, visit);\\n    //     } else if (neighbor != -1 && dist.count(neighbor)) {\\n    //         answer = max(answer, dist[node] - dist[neighbor] + 1);\\n    //     }\\n\\n    //     //Here is the code\\n    // }\\n\\n    void dfs(int node, vector<vector<int>>& graph, unordered_map<int, int>& dist, vector<bool> &isvisited,int parent){\\n        isvisited[node] = true;\\n        for(auto x:graph[node]){\\n            if(x!=parent){\\n                if(!isvisited[x]){\\n                    dist[x]=dist[node]+1;\\n                    dfs(x,graph,dist,isvisited,node);\\n                }\\n                else{\\n                    answer = min(answer,abs(dist[x]-dist[node])+1);\\n                }\\n            }\\n            \\n        }\\n\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<vector<int>> graph(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            vector<bool> isvisited(n);\\n            unordered_map<int,int> dist;\\n            \\n            dfs(i,graph,dist,isvisited,i);\\n            \\n        }\\n       \\n        if(answer==INT_MAX){\\n            return -1;\\n        }\\n        \\n        return answer;\\n        \\n        \\n    }\\n};\\n\\n![image.png](https://assets.leetcode.com/users/images/c54cea91-bc59-4362-ad6c-e823de6566de_1680415521.5596159.png)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369000,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn find_shortest_cycle(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n        let mut g = vec![vec![]; n as usize];\\n        for e in edges.iter() {\\n            g[e[0] as usize].push(e[1]);\\n            g[e[1] as usize].push(e[0]);\\n        }\\n        let inf = 10000;\\n        let mut res = inf;\\n        let root = |i: i32| {\\n            let mut dis = vec![inf; n as usize];\\n            dis[i as usize] = 0;\\n            let mut bfs = vec![i];\\n            while !bfs.is_empty() {\\n                let i = bfs.remove(0) as usize;\\n                for &jj in g[i].iter() {\\n                    let j = jj as usize;\\n                    if dis[j] == inf {\\n                        dis[j] = 1 + dis[i];\\n                        bfs.push(jj);\\n                    } else if dis[i] <= dis[j] {\\n                        return dis[i] + dis[j] + 1;\\n                    }\\n                }\\n            }\\n            inf\\n        };\\n        for i in 0..n {\\n            res = res.min(root(i));\\n        }\\n        if res < inf {\\n            res\\n        } else {\\n            -1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_shortest_cycle(n: i32, edges: Vec<Vec<i32>>) -> i32 {\\n        let mut g = vec![vec![]; n as usize];\\n        for e in edges.iter() {\\n            g[e[0] as usize].push(e[1]);\\n            g[e[1] as usize].push(e[0]);\\n        }\\n        let inf = 10000;\\n        let mut res = inf;\\n        let root = |i: i32| {\\n            let mut dis = vec![inf; n as usize];\\n            dis[i as usize] = 0;\\n            let mut bfs = vec![i];\\n            while !bfs.is_empty() {\\n                let i = bfs.remove(0) as usize;\\n                for &jj in g[i].iter() {\\n                    let j = jj as usize;\\n                    if dis[j] == inf {\\n                        dis[j] = 1 + dis[i];\\n                        bfs.push(jj);\\n                    } else if dis[i] <= dis[j] {\\n                        return dis[i] + dis[j] + 1;\\n                    }\\n                }\\n            }\\n            inf\\n        };\\n        for i in 0..n {\\n            res = res.min(root(i));\\n        }\\n        if res < inf {\\n            res\\n        } else {\\n            -1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368864,
                "title": "100-beats-time-100-beats-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n  class Solution {\\n     public int findShortestCycle(int n, int[][] edges) {\\n              ArrayList<ArrayList<Integer>> list = new ArrayList<>();\\n            for(int i = 0;i<n;i++)list.add(new ArrayList<>());\\n                \\n        for(int i = 0;i<edges.length;i++)\\n        {\\n            int a  = edges[i][0];\\n            int b = edges[i][1];\\n            list.get(b).add(a);\\n             list.get(a).add(b);\\n             }\\n            \\n             boolean visited[] ;\\n            Queue<Integer> q = new LinkedList<>();\\n               int min = Integer.MAX_VALUE;    \\n             for(int i = 0;i<n;i++)\\n            {\\n                visited = new boolean[n];\\n                if(visited[i]==false)\\n                {\\n \\n                        int parent[] = new int[n];\\n                        parent[i] = -1;\\n                       int nums [] = new int[n];\\n                       nums[i]  = 0;\\n                       q.add(i);\\n                      while(!q.isEmpty())\\n                      {\\n                        int v  = q.poll();\\n                        ArrayList<Integer> neb = list.get(v);\\n                        \\n                        for(int x : neb)\\n                        {\\n                            if(parent[v]==x)continue;\\n                            if(visited[x]==false)\\n                            {\\n                                 parent[x] = v;\\n                                nums[x] = nums[v]+1;\\n                                visited[x] = true;\\n                                q.add(x);\\n                            }else \\n                            {\\n                                min = Math.min(min,nums[x]+nums[v]+1);\\n                             }\\n                        }\\n                      }\\n                  } \\n            } \\n            if(min==Integer.MAX_VALUE)return -1;\\n            return min;\\n      }\\n    // public void dfs(int v , ArrayList<ArrayList<Integer>> list ,\\n    //  boolean []visited ,int p , int num[] , int x)\\n    // {\\n    //     visited[v]=  true;\\n    //     ArrayList<Integer> neb = list.get(v);\\n    //      num[v] = x;\\n    //     for(int i :neb)\\n    //     {\\n    //         if(i==p)continue;\\n    //         if(visited[i]==false)\\n    //         {\\n    //          dfs(i , list, visited ,v,num, x+1);\\n    //         }else if(visited[i]==true)\\n    //         {\\n                 \\n    //             if(num[v] - num[i] < 0)continue;\\n    //             q.add(num[v]-num[i] +1);\\n    //         }\\n            \\n    //     } \\n    // }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  class Solution {\\n     public int findShortestCycle(int n, int[][] edges) {\\n              ArrayList<ArrayList<Integer>> list = new ArrayList<>();\\n            for(int i = 0;i<n;i++)list.add(new ArrayList<>());\\n                \\n        for(int i = 0;i<edges.length;i++)\\n        {\\n            int a  = edges[i][0];\\n            int b = edges[i][1];\\n            list.get(b).add(a);\\n             list.get(a).add(b);\\n             }\\n            \\n             boolean visited[] ;\\n            Queue<Integer> q = new LinkedList<>();\\n               int min = Integer.MAX_VALUE;    \\n             for(int i = 0;i<n;i++)\\n            {\\n                visited = new boolean[n];\\n                if(visited[i]==false)\\n                {\\n \\n                        int parent[] = new int[n];\\n                        parent[i] = -1;\\n                       int nums [] = new int[n];\\n                       nums[i]  = 0;\\n                       q.add(i);\\n                      while(!q.isEmpty())\\n                      {\\n                        int v  = q.poll();\\n                        ArrayList<Integer> neb = list.get(v);\\n                        \\n                        for(int x : neb)\\n                        {\\n                            if(parent[v]==x)continue;\\n                            if(visited[x]==false)\\n                            {\\n                                 parent[x] = v;\\n                                nums[x] = nums[v]+1;\\n                                visited[x] = true;\\n                                q.add(x);\\n                            }else \\n                            {\\n                                min = Math.min(min,nums[x]+nums[v]+1);\\n                             }\\n                        }\\n                      }\\n                  } \\n            } \\n            if(min==Integer.MAX_VALUE)return -1;\\n            return min;\\n      }\\n    // public void dfs(int v , ArrayList<ArrayList<Integer>> list ,\\n    //  boolean []visited ,int p , int num[] , int x)\\n    // {\\n    //     visited[v]=  true;\\n    //     ArrayList<Integer> neb = list.get(v);\\n    //      num[v] = x;\\n    //     for(int i :neb)\\n    //     {\\n    //         if(i==p)continue;\\n    //         if(visited[i]==false)\\n    //         {\\n    //          dfs(i , list, visited ,v,num, x+1);\\n    //         }else if(visited[i]==true)\\n    //         {\\n                 \\n    //             if(num[v] - num[i] < 0)continue;\\n    //             q.add(num[v]-num[i] +1);\\n    //         }\\n            \\n    //     } \\n    // }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368828,
                "title": "dfs-gives-tle-in-general-bfs-is-king",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n        \\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        // bfs will give correct answer, dfs is giving tle. \\n        int res = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            queue<pair<int,int>> q;\\n            vector<int> dis(n+1, -1);\\n            q.push({i, -1});\\n            dis[i] = 0;\\n            while(!q.empty()){\\n                auto x = q.front();\\n                int u = x.first;\\n                int par = x.second;\\n                q.pop();\\n\\n                for(auto v: adj[u]){\\n                    if(dis[v] == -1){\\n                        dis[v] = dis[u] + 1;\\n                        q.push({v, u});\\n                    }\\n                    else if(par != v){\\n                        res = min(res, dis[v] + dis[u] + 1);\\n                    }\\n                }\\n            }\\n\\n        }\\n\\n        return res == INT_MAX ? -1: res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n+1];\\n        \\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        // bfs will give correct answer, dfs is giving tle. \\n        int res = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            queue<pair<int,int>> q;\\n            vector<int> dis(n+1, -1);\\n            q.push({i, -1});\\n            dis[i] = 0;\\n            while(!q.empty()){\\n                auto x = q.front();\\n                int u = x.first;\\n                int par = x.second;\\n                q.pop();\\n\\n                for(auto v: adj[u]){\\n                    if(dis[v] == -1){\\n                        dis[v] = dis[u] + 1;\\n                        q.push({v, u});\\n                    }\\n                    else if(par != v){\\n                        res = min(res, dis[v] + dis[u] + 1);\\n                    }\\n                }\\n            }\\n\\n        }\\n\\n        return res == INT_MAX ? -1: res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368665,
                "title": "bfs-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    static int findShortestCycle(const int n, vector<vector<int>> const& edges) {\\n        vector<vector<int>> adj(n);\\n        for (auto& e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        int ret = INT_MAX;\\n\\n        auto bfs = [&] (int i) {\\n            vector<int> dists(n, INT_MAX);\\n            queue<pair<int, int>> q;\\n            q.emplace(i, -1);\\n            dists[i] = 0;\\n            for (int dist = 1, sz; (sz = size(q)) && 2 * dist <= ret; ++dist)\\n                while (sz-- > 0) {\\n                    auto [i, from] = q.front();\\n                    q.pop();\\n                    for (int j : adj[i]) {\\n                        if (j == from)\\n                            continue;\\n                        if (dists[j] <= dist)\\n                            ret = min(ret, dist + dists[j]);\\n                        dists[j] = dist;\\n                        q.emplace(j, i);\\n                    }\\n                }\\n        };\\n\\n        for (int i = 0; i < n; ++i)\\n            bfs(i);\\n        return ret == INT_MAX ? -1 : ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int findShortestCycle(const int n, vector<vector<int>> const& edges) {\\n        vector<vector<int>> adj(n);\\n        for (auto& e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        int ret = INT_MAX;\\n\\n        auto bfs = [&] (int i) {\\n            vector<int> dists(n, INT_MAX);\\n            queue<pair<int, int>> q;\\n            q.emplace(i, -1);\\n            dists[i] = 0;\\n            for (int dist = 1, sz; (sz = size(q)) && 2 * dist <= ret; ++dist)\\n                while (sz-- > 0) {\\n                    auto [i, from] = q.front();\\n                    q.pop();\\n                    for (int j : adj[i]) {\\n                        if (j == from)\\n                            continue;\\n                        if (dists[j] <= dist)\\n                            ret = min(ret, dist + dists[j]);\\n                        dists[j] = dist;\\n                        q.emplace(j, i);\\n                    }\\n                }\\n        };\\n\\n        for (int i = 0; i < n; ++i)\\n            bfs(i);\\n        return ret == INT_MAX ? -1 : ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367821,
                "title": "python-simple-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findShortestCycle(self, n, edges):\\n        dict1, min_val = defaultdict(list), float(\"inf\")\\n\\n        for i,j in edges:\\n            dict1[i].append(j)\\n            dict1[j].append(i)\\n\\n        for i in range(n):\\n            dis, stack = [-1]*n, [i]\\n\\n            dis[i] = 0\\n\\n            while stack:\\n                node = stack.pop(0)\\n\\n                for neighbor in dict1[node]:\\n                    if dis[neighbor] == -1:\\n                        dis[neighbor] = dis[node] + 1\\n                        stack.append(neighbor)\\n                    elif dis[neighbor] >= dis[node]:\\n                        min_val = min(min_val,dis[neighbor]+dis[node]+1)\\n\\n        return min_val if min_val != float(\"inf\") else -1\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n            \\n\\n        \\n\\n        \\n\\n        \\n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findShortestCycle(self, n, edges):\\n        dict1, min_val = defaultdict(list), float(\"inf\")\\n\\n        for i,j in edges:\\n            dict1[i].append(j)\\n            dict1[j].append(i)\\n\\n        for i in range(n):\\n            dis, stack = [-1]*n, [i]\\n\\n            dis[i] = 0\\n\\n            while stack:\\n                node = stack.pop(0)\\n\\n                for neighbor in dict1[node]:\\n                    if dis[neighbor] == -1:\\n                        dis[neighbor] = dis[node] + 1\\n                        stack.append(neighbor)\\n                    elif dis[neighbor] >= dis[node]:\\n                        min_val = min(min_val,dis[neighbor]+dis[node]+1)\\n\\n        return min_val if min_val != float(\"inf\") else -1\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n            \\n\\n        \\n\\n        \\n\\n        \\n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367814,
                "title": "java-bfs",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> graph = getGraph(edges , n);\\n        int shortestCycle = Integer.MAX_VALUE;\\n\\n        for(int i=0; i<n; i++){\\n\\n            Queue<Integer> q = new LinkedList<>();\\n            int[] distance = new int[n];\\n            int[] parent = new int[n];\\n            Arrays.fill(distance , Integer.MAX_VALUE);\\n            Arrays.fill(parent , -1 );\\n\\n            q.add(i);\\n            distance[i] = 0;\\n\\n            while(!q.isEmpty()){\\n                int node = q.poll();\\n\\n                for(int edge : graph.get(node)){\\n\\n                    if(distance[edge] == Integer.MAX_VALUE){\\n\\n                        parent[edge] = node;\\n                        distance[edge] = distance[node] + 1;\\n\\n                        q.add(edge);\\n\\n                    }else if(parent[node] != edge && parent[edge]!=node){\\n\\n                        int dist = distance[edge] + distance[node] + 1;\\n                        shortestCycle = Math.min(shortestCycle , dist );\\n                    }\\n                }\\n            }\\n        }\\n        if(shortestCycle == Integer.MAX_VALUE){\\n            return -1;\\n        }else{\\n            return shortestCycle;\\n        }\\n    }\\n    private List<List<Integer>> getGraph(int[][] edges , int n){\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0; i<n+1; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int[] i : edges){\\n            int u = i[0];\\n            int v = i[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        return graph;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> graph = getGraph(edges , n);\\n        int shortestCycle = Integer.MAX_VALUE;\\n\\n        for(int i=0; i<n; i++){\\n\\n            Queue<Integer> q = new LinkedList<>();\\n            int[] distance = new int[n];\\n            int[] parent = new int[n];\\n            Arrays.fill(distance , Integer.MAX_VALUE);\\n            Arrays.fill(parent , -1 );\\n\\n            q.add(i);\\n            distance[i] = 0;\\n\\n            while(!q.isEmpty()){\\n                int node = q.poll();\\n\\n                for(int edge : graph.get(node)){\\n\\n                    if(distance[edge] == Integer.MAX_VALUE){\\n\\n                        parent[edge] = node;\\n                        distance[edge] = distance[node] + 1;\\n\\n                        q.add(edge);\\n\\n                    }else if(parent[node] != edge && parent[edge]!=node){\\n\\n                        int dist = distance[edge] + distance[node] + 1;\\n                        shortestCycle = Math.min(shortestCycle , dist );\\n                    }\\n                }\\n            }\\n        }\\n        if(shortestCycle == Integer.MAX_VALUE){\\n            return -1;\\n        }else{\\n            return shortestCycle;\\n        }\\n    }\\n    private List<List<Integer>> getGraph(int[][] edges , int n){\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0; i<n+1; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int[] i : edges){\\n            int u = i[0];\\n            int v = i[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        return graph;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367712,
                "title": "c-union-find-bfs-approach",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int> rank;\\n    vector<int> root;\\n    \\n    int find(int x){\\n        if(root[x] == x) return x;\\n        return root[x] = find(root[x]);\\n    }\\n    \\n    bool merge(int x, int y){\\n        int rx = find(x);\\n        int ry = find(y);\\n        \\n        \\n        if(rx!=ry){\\n            if(rank[rx] >= rank[ry]){\\n                root[ry]=rx;\\n                rank[rx]+=rank[ry];\\n            } else{\\n                root[rx] = ry;\\n                rank[ry]+= rank[rx];\\n            }\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    int cycleLength(int start, int end, int n, vector<vector<int>>& adj){\\n        queue<int> q;\\n        q.push(start);\\n        int level=0;\\n        vector<bool> visited(n, false);\\n        \\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int f = q.front();q.pop();\\n                visited[f]=true;\\n                \\n                if(f==end) return level+1;\\n                \\n                for(auto x:adj[f]){\\n                    if(!visited[x]) q.push(x);\\n                }\\n            }\\n            level+=1;\\n        }\\n        \\n        return level+1;\\n    }\\n    \\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        root.resize(n);\\n        rank.resize(n, 1);\\n        \\n        for(int i=0;i<n;i++) root[i]=i;\\n        \\n        int minLength=INT_MAX;\\n        vector<vector<int>> adj(n);\\n        \\n        for(auto e:edges){\\n            int u = e[0], v = e[1];\\n            \\n            \\n            if(!merge(u, v)){\\n                minLength = min(minLength, cycleLength(u, v, n, adj));\\n            }\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        \\n        return minLength==INT_MAX?-1:minLength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> rank;\\n    vector<int> root;\\n    \\n    int find(int x){\\n        if(root[x] == x) return x;\\n        return root[x] = find(root[x]);\\n    }\\n    \\n    bool merge(int x, int y){\\n        int rx = find(x);\\n        int ry = find(y);\\n        \\n        \\n        if(rx!=ry){\\n            if(rank[rx] >= rank[ry]){\\n                root[ry]=rx;\\n                rank[rx]+=rank[ry];\\n            } else{\\n                root[rx] = ry;\\n                rank[ry]+= rank[rx];\\n            }\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    int cycleLength(int start, int end, int n, vector<vector<int>>& adj){\\n        queue<int> q;\\n        q.push(start);\\n        int level=0;\\n        vector<bool> visited(n, false);\\n        \\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                int f = q.front();q.pop();\\n                visited[f]=true;\\n                \\n                if(f==end) return level+1;\\n                \\n                for(auto x:adj[f]){\\n                    if(!visited[x]) q.push(x);\\n                }\\n            }\\n            level+=1;\\n        }\\n        \\n        return level+1;\\n    }\\n    \\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        root.resize(n);\\n        rank.resize(n, 1);\\n        \\n        for(int i=0;i<n;i++) root[i]=i;\\n        \\n        int minLength=INT_MAX;\\n        vector<vector<int>> adj(n);\\n        \\n        for(auto e:edges){\\n            int u = e[0], v = e[1];\\n            \\n            \\n            if(!merge(u, v)){\\n                minLength = min(minLength, cycleLength(u, v, n, adj));\\n            }\\n            \\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        \\n        return minLength==INT_MAX?-1:minLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367576,
                "title": "c-2-solution-bfs-dfs",
                "content": "# Code\\n```\\n// BFS\\nclass Solution {\\n    void bfs(int node, vector<int> adjList[], int &ans, int &n) {\\n        vector<int> parent(n, -1);\\n        vector<int> dist(n, -1);\\n        queue<int> Queue;\\n        Queue.push(node);\\n        dist[node] = 0;\\n        while(!Queue.empty()) {\\n            int sz = Queue.size();\\n            for(int i = 0; i < sz; i++) {\\n                int curr = Queue.front();\\n                Queue.pop();\\n                for(int next: adjList[curr]) {\\n                    if(dist[next] == -1) {\\n                        Queue.push(next);\\n                        dist[next] = dist[curr] + 1;\\n                        parent[next] = curr;\\n                    } else if(parent[curr] != next && parent[next] != curr) {\\n                        ans = min(ans, dist[curr] + dist[next] + 1);\\n                    }\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adjList[n];\\n        for(vector<int> edge: edges) {\\n            adjList[edge[0]].push_back(edge[1]);\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        int ans = INT_MAX;\\n        for(int i = 0; i < n; i++) {\\n            bfs(i, adjList, ans, n);\\n        }\\n        if(ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n\\n\\n// DFS\\nclass Solution {\\n    void dfs(int curr, int parent, vector<int> adjList[], vector<int> &dist, int &ans) {\\n        for(int next: adjList[curr]) {\\n            if(next == parent) continue;\\n            if(dist[next] == -1) {\\n                dist[next] = dist[curr] + 1;\\n                dfs(next, curr, adjList, dist, ans);\\n            } else {\\n                ans = min(ans, abs(dist[curr] - dist[next]) + 1);\\n            }\\n        }\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adjList[n];\\n        for(vector<int> edge: edges) {\\n            adjList[edge[0]].push_back(edge[1]);\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        int ans = INT_MAX;\\n        for(int i = 0; i < n; i++) {\\n            vector<int> dist(n, -1);\\n            dist[i] = 0;\\n            dfs(i, -1, adjList, dist, ans);\\n        }\\n        if(ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n// BFS\\nclass Solution {\\n    void bfs(int node, vector<int> adjList[], int &ans, int &n) {\\n        vector<int> parent(n, -1);\\n        vector<int> dist(n, -1);\\n        queue<int> Queue;\\n        Queue.push(node);\\n        dist[node] = 0;\\n        while(!Queue.empty()) {\\n            int sz = Queue.size();\\n            for(int i = 0; i < sz; i++) {\\n                int curr = Queue.front();\\n                Queue.pop();\\n                for(int next: adjList[curr]) {\\n                    if(dist[next] == -1) {\\n                        Queue.push(next);\\n                        dist[next] = dist[curr] + 1;\\n                        parent[next] = curr;\\n                    } else if(parent[curr] != next && parent[next] != curr) {\\n                        ans = min(ans, dist[curr] + dist[next] + 1);\\n                    }\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adjList[n];\\n        for(vector<int> edge: edges) {\\n            adjList[edge[0]].push_back(edge[1]);\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        int ans = INT_MAX;\\n        for(int i = 0; i < n; i++) {\\n            bfs(i, adjList, ans, n);\\n        }\\n        if(ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n\\n\\n// DFS\\nclass Solution {\\n    void dfs(int curr, int parent, vector<int> adjList[], vector<int> &dist, int &ans) {\\n        for(int next: adjList[curr]) {\\n            if(next == parent) continue;\\n            if(dist[next] == -1) {\\n                dist[next] = dist[curr] + 1;\\n                dfs(next, curr, adjList, dist, ans);\\n            } else {\\n                ans = min(ans, abs(dist[curr] - dist[next]) + 1);\\n            }\\n        }\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adjList[n];\\n        for(vector<int> edge: edges) {\\n            adjList[edge[0]].push_back(edge[1]);\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        int ans = INT_MAX;\\n        for(int i = 0; i < n; i++) {\\n            vector<int> dist(n, -1);\\n            dist[i] = 0;\\n            dfs(i, -1, adjList, dist, ans);\\n        }\\n        if(ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367477,
                "title": "brute-force-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSearch for a cycle from every node and return the smallest cycle length.\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n\\n        for (int i=0; i<n; i++) {\\n            adj.add(new ArrayList<>());\\n        }        \\n        for (int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n\\n        for (int i=0; i<n; i++) {\\n            Map<Integer, Integer> dist = new HashMap<>();\\n            boolean[] visited = new boolean[n];\\n            dist.put(i, 1);\\n            dfs(i, -1, dist, adj, visited);\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n\\n    public void dfs(int node, int parent, Map<Integer, Integer> dist, List<List<Integer>> adj, boolean[] visited) {\\n        visited[node] = true;\\n\\n        for (int u : adj.get(node)) {\\n            if (!visited[u]) {\\n                dist.put(u, dist.get(node) + 1);\\n                dfs(u, node, dist, adj, visited);\\n            } else if (u != parent) {\\n                ans = Math.min(ans, Math.abs(dist.get(node) - dist.get(u)) + 1);\\n            } \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n\\n        for (int i=0; i<n; i++) {\\n            adj.add(new ArrayList<>());\\n        }        \\n        for (int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n\\n        for (int i=0; i<n; i++) {\\n            Map<Integer, Integer> dist = new HashMap<>();\\n            boolean[] visited = new boolean[n];\\n            dist.put(i, 1);\\n            dfs(i, -1, dist, adj, visited);\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n\\n    public void dfs(int node, int parent, Map<Integer, Integer> dist, List<List<Integer>> adj, boolean[] visited) {\\n        visited[node] = true;\\n\\n        for (int u : adj.get(node)) {\\n            if (!visited[u]) {\\n                dist.put(u, dist.get(node) + 1);\\n                dfs(u, node, dist, adj, visited);\\n            } else if (u != parent) {\\n                ans = Math.min(ans, Math.abs(dist.get(node) - dist.get(u)) + 1);\\n            } \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367433,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int FindShortestCycle(int n, int[][] edges)\\n    {\\n        var g = new List<List<int>>();\\n        \\n        for (var i = 0; i < n; ++i)\\n            g.Add(new List<int>());\\n        \\n        foreach (var e in edges)\\n        {\\n            g[e[0]].Add(e[1]);\\n            g[e[1]].Add(e[0]);\\n        }\\n\\n        const int inf = 10000;\\n        var result = inf;\\n\\n        for (var i = 0; i < n; ++i)\\n            result = Math.Min(result, Root(i));\\n\\n        int Root(int i)\\n        {\\n            var dis = Enumerable.Repeat(inf, n).ToList();\\n            var fa = Enumerable.Repeat(-1, n).ToList();\\n            dis[i] = 0;\\n            var bfs = new Queue<int>(new[] { i });\\n\\n            while (bfs.Count > 0)\\n            {\\n                i = bfs.Dequeue();\\n\\n                foreach (var j in g[i])\\n                    if (dis[j] == inf)\\n                    {\\n                        dis[j] = 1 + dis[i];\\n                        fa[j] = i;\\n                        bfs.Enqueue(j);\\n                    }\\n                    else if (fa[i] != j)\\n                        return dis[i] + dis[j] + 1;\\n            }\\n\\n            return inf;\\n        }\\n\\n        return result < inf ? result : -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int FindShortestCycle(int n, int[][] edges)\\n    {\\n        var g = new List<List<int>>();\\n        \\n        for (var i = 0; i < n; ++i)\\n            g.Add(new List<int>());\\n        \\n        foreach (var e in edges)\\n        {\\n            g[e[0]].Add(e[1]);\\n            g[e[1]].Add(e[0]);\\n        }\\n\\n        const int inf = 10000;\\n        var result = inf;\\n\\n        for (var i = 0; i < n; ++i)\\n            result = Math.Min(result, Root(i));\\n\\n        int Root(int i)\\n        {\\n            var dis = Enumerable.Repeat(inf, n).ToList();\\n            var fa = Enumerable.Repeat(-1, n).ToList();\\n            dis[i] = 0;\\n            var bfs = new Queue<int>(new[] { i });\\n\\n            while (bfs.Count > 0)\\n            {\\n                i = bfs.Dequeue();\\n\\n                foreach (var j in g[i])\\n                    if (dis[j] == inf)\\n                    {\\n                        dis[j] = 1 + dis[i];\\n                        fa[j] = i;\\n                        bfs.Enqueue(j);\\n                    }\\n                    else if (fa[i] != j)\\n                        return dis[i] + dis[j] + 1;\\n            }\\n\\n            return inf;\\n        }\\n\\n        return result < inf ? result : -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367328,
                "title": "c-easy-solution-with-detailed-explanation-bfs-cycle-detection-using-bfs",
                "content": "# Intuition\\n- shortest cycle lenght is smallest length among shortest cycles with ith node as root node in BFS cycle detection \\n- BFS give minimum distance becuase we are growing 1 unit by 1 unit \\n- Cycle is detected if any node has 2 parents i.e in BFS 2 times visited then identified as Cycle \\n- lenght of cycle : root -> parent + root-> node with 2 parents + 1 \\n- becuse cycle is like : root-> parent -> last node -> root \\n\\n# Complexity\\n- Time complexity: O(N^2 )\\n- but it will run becuase constraints \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int rt , vector<vector<int>> &adj )\\n    {\\n        int n = adj.size();\\n        int inf = 10000;\\n        vector<int> level(n,inf);\\n        \\n        level[rt]=0;\\n        queue<int> q;\\n        q.push(rt);\\n        \\n        while(!q.empty())\\n        {\\n            int tp = q.front();\\n            q.pop();\\n            \\n            for(auto it : adj[tp])\\n            {\\n                          \\n                if(level[it] == inf )\\n                {\\n                     level[it] = level[tp]+1;\\n                    q.push(it);\\n                }\\n                else if(level[it] >= level[tp]) // priviously visited and shortest cycle for given root . \\n                {\\n                    return level[tp] + level[it] + 1 ;\\n                }\\n            }\\n            \\n            \\n        }\\n        return inf;\\n        \\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n         \\n        int ans = 10000;\\n        vector<vector<int>> adj(n);\\n        // Creating graph using adjecency list \\n        for(auto& edge : edges)\\n        {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        for( int i = 0 ; i < n ; ++i ) // For each node as root node find the shoretest cycle with ith node is at root \\n        {  int x =  helper(i,adj);\\n            ans = min (ans ,x);\\n            cout<<i<<\" \"<<x<<\" \\\\n\";\\n        }\\n        if(ans == 10000) ans = -1;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int rt , vector<vector<int>> &adj )\\n    {\\n        int n = adj.size();\\n        int inf = 10000;\\n        vector<int> level(n,inf);\\n        \\n        level[rt]=0;\\n        queue<int> q;\\n        q.push(rt);\\n        \\n        while(!q.empty())\\n        {\\n            int tp = q.front();\\n            q.pop();\\n            \\n            for(auto it : adj[tp])\\n            {\\n                          \\n                if(level[it] == inf )\\n                {\\n                     level[it] = level[tp]+1;\\n                    q.push(it);\\n                }\\n                else if(level[it] >= level[tp]) // priviously visited and shortest cycle for given root . \\n                {\\n                    return level[tp] + level[it] + 1 ;\\n                }\\n            }\\n            \\n            \\n        }\\n        return inf;\\n        \\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n         \\n        int ans = 10000;\\n        vector<vector<int>> adj(n);\\n        // Creating graph using adjecency list \\n        for(auto& edge : edges)\\n        {\\n            int u = edge[0];\\n            int v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        for( int i = 0 ; i < n ; ++i ) // For each node as root node find the shoretest cycle with ith node is at root \\n        {  int x =  helper(i,adj);\\n            ans = min (ans ,x);\\n            cout<<i<<\" \"<<x<<\" \\\\n\";\\n        }\\n        if(ans == 10000) ans = -1;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3367237,
                "title": "beats-100-c-bfs",
                "content": "```\\nvector<int>g[1001];\\n\\nclass Solution {\\npublic:\\n    int n;\\n    int bfs(int i){\\n        vector<int>dis(n+1,INT_MAX);\\n        vector<int>f(n+1);\\n        f[i]=0;\\n        dis[i]=0;\\n        int ans=INT_MAX;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n        q.push({0,i});\\n        while(q.size()){\\n           int pdis=q.top().first;\\n            int par=q.top().second;\\n            q.pop();\\n            for(auto j:g[par]){\\n                if(j==f[par])continue;\\n                if(dis[j]!=INT_MAX){\\n                    ans=min(ans,dis[par]+dis[j]+1);\\n                }\\n                else{\\n                    dis[j]=dis[par]+1;\\n                    f[j]=par;\\n                    q.push({dis[j],j});\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    int findShortestCycle(int N, vector<vector<int>>& e) {\\n        n=N;\\n        for(int i=0;i<n+1;i++)g[i].clear();\\n        for(auto &i:e){\\n            g[i[1]].push_back(i[0]);\\n            g[i[0]].push_back(i[1]);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n               ans=min(ans,bfs(i));\\n        if(ans==INT_MAX)return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int>g[1001];\\n\\nclass Solution {\\npublic:\\n    int n;\\n    int bfs(int i){\\n        vector<int>dis(n+1,INT_MAX);\\n        vector<int>f(n+1);\\n        f[i]=0;\\n        dis[i]=0;\\n        int ans=INT_MAX;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n        q.push({0,i});\\n        while(q.size()){\\n           int pdis=q.top().first;\\n            int par=q.top().second;\\n            q.pop();\\n            for(auto j:g[par]){\\n                if(j==f[par])continue;\\n                if(dis[j]!=INT_MAX){\\n                    ans=min(ans,dis[par]+dis[j]+1);\\n                }\\n                else{\\n                    dis[j]=dis[par]+1;\\n                    f[j]=par;\\n                    q.push({dis[j],j});\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    int findShortestCycle(int N, vector<vector<int>>& e) {\\n        n=N;\\n        for(int i=0;i<n+1;i++)g[i].clear();\\n        for(auto &i:e){\\n            g[i[1]].push_back(i[0]);\\n            g[i[0]].push_back(i[1]);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n               ans=min(ans,bfs(i));\\n        if(ans==INT_MAX)return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367227,
                "title": "my-solutions",
                "content": "**1. Iterate every edge and use the BFS to check whether there exists a cycle containing the edge**\\n```\\n/**\\n * Time Complexity: O(n_edges * n_edges)\\n * Space Complexity: O(n + n_edges)\\n * where `n_edges` is the length of the vector `edges`\\n */\\nclass Solution {\\n private:\\n  static constexpr unsigned int invalid_step = -1U;\\n  \\n public:\\n  int findShortestCycle(const int n, const vector<vector<int>> &edges) {\\n    constexpr int i_node1 = 0;\\n    constexpr int i_node2 = 1;\\n    vector<int> graph[n];\\n    for (const vector<int> &edge : edges) {\\n      const int node1 = edge[i_node1];\\n      const int node2 = edge[i_node2];\\n      graph[node1].emplace_back(node2);\\n      graph[node2].emplace_back(node1);\\n    }\\n    \\n    unsigned int ret = invalid_step;\\n    for (const vector<int> &edge : edges) {\\n      const int start = edge[i_node1];\\n      const int end = edge[i_node2];\\n      ret = min(ret, bfs(graph, n, start, end));\\n    }\\n    return static_cast<int>(ret);\\n  }\\n  \\n private:\\n  unsigned int bfs(const vector<int> *graph, const int n, const int start, const int end) {\\n    unsigned int steps[n];\\n    memset(steps, invalid_step, sizeof(steps));\\n    steps[start] = 0;\\n    queue<int> q({start});\\n    while (!q.empty()) {\\n      const int current = q.front();\\n      q.pop();\\n      for (const int next : graph[current]) {\\n        if (current == start && next == end) {\\n          continue;\\n        }\\n\\n        if (steps[next] == invalid_step) {\\n          steps[next] = steps[current] + 1;\\n          if (next == end) {\\n            return steps[next] + 1;\\n          }\\n          q.emplace(next);\\n        }\\n      }\\n    }\\n    return invalid_step;\\n  }\\n};\\n```\\n**2. Iterate every vertex and use the BFS to check whether there exists a cycle**\\n```\\n/**\\n * Time Complexity: O(n * n_edges)\\n * Space Complexity: O(n + n_edges)\\n * where `n_edges` is the length of the vector `edges`\\n */\\nclass Solution {\\n private:\\n  static constexpr unsigned int invalid_step = -1U;\\n  \\n public:\\n  int findShortestCycle(const int n, const vector<vector<int>> &edges) {\\n    constexpr int i_node1 = 0;\\n    constexpr int i_node2 = 1;\\n    vector<int> graph[n];\\n    for (const vector<int> &edge : edges) {\\n      const int node1 = edge[i_node1];\\n      const int node2 = edge[i_node2];\\n      graph[node1].emplace_back(node2);\\n      graph[node2].emplace_back(node1);\\n    }\\n    \\n    unsigned int ret = invalid_step;\\n    for (int node = 0; node < n; ++node) {\\n      ret = min(ret, bfs(graph, n, node));\\n    }\\n    return static_cast<int>(ret);\\n  }\\n  \\n private:\\n  unsigned int bfs(const vector<int> *graph, const int n, const int start) {\\n    using q_node_t = pair<int, int>;   // {the node, the parent node}\\n    constexpr int invalid_parent = -1;\\n    unsigned int steps[n];\\n    memset(steps, invalid_step, sizeof(steps));\\n    steps[start] = 0;\\n    queue<pair<int, int>> q({make_pair(start, invalid_parent)});\\n    while (!q.empty()) {\\n      const auto [node, parent] = q.front();\\n      q.pop();\\n      for (const int next : graph[node]) {\\n        if (next == parent) {\\n          continue;\\n        }\\n\\n        if (steps[next] == invalid_step) {\\n          steps[next] = steps[node] + 1;\\n          q.emplace(next, node);\\n        } else {\\n          // find a joining vertex\\n          return steps[node] + steps[next] + 1;\\n        }\\n      }\\n    }\\n    return invalid_step;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n_edges * n_edges)\\n * Space Complexity: O(n + n_edges)\\n * where `n_edges` is the length of the vector `edges`\\n */\\nclass Solution {\\n private:\\n  static constexpr unsigned int invalid_step = -1U;\\n  \\n public:\\n  int findShortestCycle(const int n, const vector<vector<int>> &edges) {\\n    constexpr int i_node1 = 0;\\n    constexpr int i_node2 = 1;\\n    vector<int> graph[n];\\n    for (const vector<int> &edge : edges) {\\n      const int node1 = edge[i_node1];\\n      const int node2 = edge[i_node2];\\n      graph[node1].emplace_back(node2);\\n      graph[node2].emplace_back(node1);\\n    }\\n    \\n    unsigned int ret = invalid_step;\\n    for (const vector<int> &edge : edges) {\\n      const int start = edge[i_node1];\\n      const int end = edge[i_node2];\\n      ret = min(ret, bfs(graph, n, start, end));\\n    }\\n    return static_cast<int>(ret);\\n  }\\n  \\n private:\\n  unsigned int bfs(const vector<int> *graph, const int n, const int start, const int end) {\\n    unsigned int steps[n];\\n    memset(steps, invalid_step, sizeof(steps));\\n    steps[start] = 0;\\n    queue<int> q({start});\\n    while (!q.empty()) {\\n      const int current = q.front();\\n      q.pop();\\n      for (const int next : graph[current]) {\\n        if (current == start && next == end) {\\n          continue;\\n        }\\n\\n        if (steps[next] == invalid_step) {\\n          steps[next] = steps[current] + 1;\\n          if (next == end) {\\n            return steps[next] + 1;\\n          }\\n          q.emplace(next);\\n        }\\n      }\\n    }\\n    return invalid_step;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n * n_edges)\\n * Space Complexity: O(n + n_edges)\\n * where `n_edges` is the length of the vector `edges`\\n */\\nclass Solution {\\n private:\\n  static constexpr unsigned int invalid_step = -1U;\\n  \\n public:\\n  int findShortestCycle(const int n, const vector<vector<int>> &edges) {\\n    constexpr int i_node1 = 0;\\n    constexpr int i_node2 = 1;\\n    vector<int> graph[n];\\n    for (const vector<int> &edge : edges) {\\n      const int node1 = edge[i_node1];\\n      const int node2 = edge[i_node2];\\n      graph[node1].emplace_back(node2);\\n      graph[node2].emplace_back(node1);\\n    }\\n    \\n    unsigned int ret = invalid_step;\\n    for (int node = 0; node < n; ++node) {\\n      ret = min(ret, bfs(graph, n, node));\\n    }\\n    return static_cast<int>(ret);\\n  }\\n  \\n private:\\n  unsigned int bfs(const vector<int> *graph, const int n, const int start) {\\n    using q_node_t = pair<int, int>;   // {the node, the parent node}\\n    constexpr int invalid_parent = -1;\\n    unsigned int steps[n];\\n    memset(steps, invalid_step, sizeof(steps));\\n    steps[start] = 0;\\n    queue<pair<int, int>> q({make_pair(start, invalid_parent)});\\n    while (!q.empty()) {\\n      const auto [node, parent] = q.front();\\n      q.pop();\\n      for (const int next : graph[node]) {\\n        if (next == parent) {\\n          continue;\\n        }\\n\\n        if (steps[next] == invalid_step) {\\n          steps[next] = steps[node] + 1;\\n          q.emplace(next, node);\\n        } else {\\n          // find a joining vertex\\n          return steps[node] + steps[next] + 1;\\n        }\\n      }\\n    }\\n    return invalid_step;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367163,
                "title": "easy-approach-c-intuitive-solution-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestCycle(int numVertices, vector<int> graph[]){\\n        int minCycleLen = INT_MAX;\\n        for (int srcVertex = 0; srcVertex < numVertices; srcVertex++) {\\n            \\n            vector<int> distances(numVertices, (int)(1e9));\\n            \\n            vector<int> parent(numVertices, -1);\\n            distances[srcVertex] = 0;\\n            queue<int> vertexQueue;\\n            vertexQueue.push(srcVertex);\\n            while (!vertexQueue.empty()) {\\n                int currVertex = vertexQueue.front();\\n                vertexQueue.pop();\\n\\n                for (int childVertex : graph[currVertex]) {\\n                    if (distances[childVertex] == (int)(1e9)) {\\n                        distances[childVertex] = 1 + distances[currVertex];\\n                        parent[childVertex] = currVertex;\\n\\n                        vertexQueue.push(childVertex);\\n                    }\\n\\n                    else if (parent[currVertex] != childVertex and parent[childVertex] != currVertex)\\n                        minCycleLen = min(minCycleLen, distances[currVertex] + distances[childVertex] + 1);\\n                }\\n            }\\n        }\\n\\n        if (minCycleLen == INT_MAX)\\n            return -1;\\n        else\\n            return minCycleLen;\\n    }\\n\\n    int findShortestCycle(int numVertices, vector<vector<int>>& edges) {\\n        vector<int> adjList[numVertices];\\n        for(auto edge: edges){\\n            adjList[edge[0]].push_back(edge[1]);\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        return shortestCycle(numVertices, adjList);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestCycle(int numVertices, vector<int> graph[]){\\n        int minCycleLen = INT_MAX;\\n        for (int srcVertex = 0; srcVertex < numVertices; srcVertex++) {\\n            \\n            vector<int> distances(numVertices, (int)(1e9));\\n            \\n            vector<int> parent(numVertices, -1);\\n            distances[srcVertex] = 0;\\n            queue<int> vertexQueue;\\n            vertexQueue.push(srcVertex);\\n            while (!vertexQueue.empty()) {\\n                int currVertex = vertexQueue.front();\\n                vertexQueue.pop();\\n\\n                for (int childVertex : graph[currVertex]) {\\n                    if (distances[childVertex] == (int)(1e9)) {\\n                        distances[childVertex] = 1 + distances[currVertex];\\n                        parent[childVertex] = currVertex;\\n\\n                        vertexQueue.push(childVertex);\\n                    }\\n\\n                    else if (parent[currVertex] != childVertex and parent[childVertex] != currVertex)\\n                        minCycleLen = min(minCycleLen, distances[currVertex] + distances[childVertex] + 1);\\n                }\\n            }\\n        }\\n\\n        if (minCycleLen == INT_MAX)\\n            return -1;\\n        else\\n            return minCycleLen;\\n    }\\n\\n    int findShortestCycle(int numVertices, vector<vector<int>>& edges) {\\n        vector<int> adjList[numVertices];\\n        for(auto edge: edges){\\n            adjList[edge[0]].push_back(edge[1]);\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        return shortestCycle(numVertices, adjList);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367137,
                "title": "bfs-approach-c-clean-code",
                "content": "# Approach\\nWe first create an adjacency list for the given list of edges and call our bfs function for each node. \\nWe mark the distance of the root node as 0 and push it into the queue and perform the bfs and travel to all its neighbouring nodes and if the neighbouring node has not been visited yet, we calculate its distance from the root node as distance of the previous node plus one. \\nIf the neighbouring node had been visited earlier we check that the distance of the neighbouring node is either greater than or equal to the parent node to ensure that both these distances have been calculated though different paths. We then store the shortest cycle so far in our ans variable and the length of the cycle is calculated by dist[u]+dist[v]+1 (+1 for extra edge between u and v).\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int ans=INT_MAX;\\n    void bfs(int node,vector<int> adj[],int n){\\n        vector<int>dist(n,-1);\\n        dist[node]=0;\\n        queue<int> q;\\n        q.push(node);\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto v:adj[u]){\\n                if(dist[v]==-1){\\n                    dist[v]=dist[u]+1;\\n                    q.push(v);\\n                }\\n                else if(v!=u && dist[v]>=dist[u]){\\n                    ans=min(ans,dist[u]+dist[v]+1);\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            bfs(i,adj,n);\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int ans=INT_MAX;\\n    void bfs(int node,vector<int> adj[],int n){\\n        vector<int>dist(n,-1);\\n        dist[node]=0;\\n        queue<int> q;\\n        q.push(node);\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto v:adj[u]){\\n                if(dist[v]==-1){\\n                    dist[v]=dist[u]+1;\\n                    q.push(v);\\n                }\\n                else if(v!=u && dist[v]>=dist[u]){\\n                    ans=min(ans,dist[u]+dist[v]+1);\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            bfs(i,adj,n);\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367107,
                "title": "python-bfs-with-re-rooting",
                "content": "# Intuition\\nConstraints are small enough to run $$O(N^2)$$ running time algorithm. \\nSimply try to do bfs from every node as root (try every node as root).\\nWhen processing nodes, remember node distance from current node (number of edges).\\nIf we reach node that is already processed, we found cycle (one needs to be carefull to check adjacent nodes from previous step to current one, this is not cycle but adjacent node).\\nTake smallest cycle found if one exists.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def find_smallest_cycle_from(self, root, g, n):\\n        result = inf\\n        distance = [inf] * n\\n        paired = set()\\n        distance[root] = 0\\n        qu = deque()\\n        qu.append(root)\\n        while qu:\\n            x = qu.popleft()\\n            for to in g[x]:\\n                pair_tuple = tuple(sorted((x, to)))\\n                if distance[to] == inf:\\n                    distance[to] = 1 + distance[x]\\n                    paired.add(pair_tuple)\\n                    qu.append(to)\\n                elif pair_tuple not in paired:\\n                    result = min(result, distance[x] + distance[to] + 1)  \\n        return result\\n\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        g = defaultdict(set)\\n        \\n        for f,t in edges:\\n            g[f].add(t)\\n            g[t].add(f)\\n            \\n        result = min([self.find_smallest_cycle_from(root, g, n) for root in range(n)])\\n\\n        return -1 if result == inf else result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def find_smallest_cycle_from(self, root, g, n):\\n        result = inf\\n        distance = [inf] * n\\n        paired = set()\\n        distance[root] = 0\\n        qu = deque()\\n        qu.append(root)\\n        while qu:\\n            x = qu.popleft()\\n            for to in g[x]:\\n                pair_tuple = tuple(sorted((x, to)))\\n                if distance[to] == inf:\\n                    distance[to] = 1 + distance[x]\\n                    paired.add(pair_tuple)\\n                    qu.append(to)\\n                elif pair_tuple not in paired:\\n                    result = min(result, distance[x] + distance[to] + 1)  \\n        return result\\n\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        g = defaultdict(set)\\n        \\n        for f,t in edges:\\n            g[f].add(t)\\n            g[t].add(f)\\n            \\n        result = min([self.find_smallest_cycle_from(root, g, n) for root in range(n)])\\n\\n        return -1 if result == inf else result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367051,
                "title": "go-python-o-n-2-time-o-n-space",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc findShortestCycle(n int, edges [][]int) int {\\n    answer := math.MaxInt\\n    graph := make(map[int][]int)\\n    for _,edge := range(edges){\\n        a := edge[0]\\n        b := edge[1]\\n        graph[a] = append(graph[a],b)\\n        graph[b] = append(graph[b],a)\\n    }\\n    \\n    for i:=0;i<n;i++{\\n        dist := map[int]int{i:0}\\n        par := make(map[int]int)\\n        q := []int{i}\\n        for len(q)>0{\\n            node := q[0]\\n            q = q[1:]\\n            for _,nei := range(graph[node]){\\n                if _,ok := dist[nei]; !ok{\\n                    dist[nei] = 1 + dist[node]\\n                    par[nei] = node\\n                    q = append(q,nei)\\n                }else if  par[node] != nei && par[nei] != node{\\n                    answer = min(answer, dist[node] + dist[nei] + 1)\\n                }\\n            }\\n        }\\n    }\\n\\n    if answer == math.MaxInt{\\n        return -1\\n    }\\n    return answer\\n}\\n\\nfunc min(a,b int) int{\\n    if a < b{\\n        return a\\n    }\\n    return b\\n}\\n```\\n```python []\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        answer = float(\"inf\")\\n        graph = defaultdict(list)\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        for i in range(n):\\n            dist = {i:0}\\n            par = {}\\n            q = deque()\\n            q.append(i)\\n            while q:\\n                node = q.popleft()\\n                for nei in graph[node]:\\n                    if nei not in dist:\\n                        dist[nei] = 1 + dist[node]\\n                        par[nei] = node\\n                        q.append(nei)\\n                    elif par[node] != nei and par[nei] != node:\\n                        answer = min(answer, dist[node] + dist[nei] + 1)\\n \\n        if answer == float(\"inf\"):\\n            return -1\\n        return answer\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Hash Table",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```golang []\\nfunc findShortestCycle(n int, edges [][]int) int {\\n    answer := math.MaxInt\\n    graph := make(map[int][]int)\\n    for _,edge := range(edges){\\n        a := edge[0]\\n        b := edge[1]\\n        graph[a] = append(graph[a],b)\\n        graph[b] = append(graph[b],a)\\n    }\\n    \\n    for i:=0;i<n;i++{\\n        dist := map[int]int{i:0}\\n        par := make(map[int]int)\\n        q := []int{i}\\n        for len(q)>0{\\n            node := q[0]\\n            q = q[1:]\\n            for _,nei := range(graph[node]){\\n                if _,ok := dist[nei]; !ok{\\n                    dist[nei] = 1 + dist[node]\\n                    par[nei] = node\\n                    q = append(q,nei)\\n                }else if  par[node] != nei && par[nei] != node{\\n                    answer = min(answer, dist[node] + dist[nei] + 1)\\n                }\\n            }\\n        }\\n    }\\n\\n    if answer == math.MaxInt{\\n        return -1\\n    }\\n    return answer\\n}\\n\\nfunc min(a,b int) int{\\n    if a < b{\\n        return a\\n    }\\n    return b\\n}\\n```\n```python []\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        answer = float(\"inf\")\\n        graph = defaultdict(list)\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        for i in range(n):\\n            dist = {i:0}\\n            par = {}\\n            q = deque()\\n            q.append(i)\\n            while q:\\n                node = q.popleft()\\n                for nei in graph[node]:\\n                    if nei not in dist:\\n                        dist[nei] = 1 + dist[node]\\n                        par[nei] = node\\n                        q.append(nei)\\n                    elif par[node] != nei and par[nei] != node:\\n                        answer = min(answer, dist[node] + dist[nei] + 1)\\n \\n        if answer == float(\"inf\"):\\n            return -1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367048,
                "title": "bfs",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it: edges) {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        int ans = n+1;\\n        for(int i=0; i<n; i++) {\\n            int root = i;\\n            queue<int> q;\\n            q.push(root);\\n            \\n            vector<int> vis(n,0), par(n,-1), dis(n,0);\\n            vis[root] = 1;\\n            \\n            while(!q.empty()) {\\n                int node = q.front();\\n                q.pop();\\n                \\n                for(auto it: adj[node]) {\\n                    if(it == par[node]) continue;\\n                    \\n                    if(vis[it]) {\\n                        ans = min(ans, dis[node] + dis[it] + 1);\\n                        continue;\\n                    }\\n                    \\n                    par[it] = node;\\n                    q.push(it);\\n                    vis[it] = 1;\\n                    dis[it] = dis[node] + 1;\\n                }\\n            }\\n        }\\n        if(ans==n+1) ans = -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it: edges) {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        int ans = n+1;\\n        for(int i=0; i<n; i++) {\\n            int root = i;\\n            queue<int> q;\\n            q.push(root);\\n            \\n            vector<int> vis(n,0), par(n,-1), dis(n,0);\\n            vis[root] = 1;\\n            \\n            while(!q.empty()) {\\n                int node = q.front();\\n                q.pop();\\n                \\n                for(auto it: adj[node]) {\\n                    if(it == par[node]) continue;\\n                    \\n                    if(vis[it]) {\\n                        ans = min(ans, dis[node] + dis[it] + 1);\\n                        continue;\\n                    }\\n                    \\n                    par[it] = node;\\n                    q.push(it);\\n                    vis[it] = 1;\\n                    dis[it] = dis[node] + 1;\\n                }\\n            }\\n        }\\n        if(ans==n+1) ans = -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367026,
                "title": "o-m-n-height-using-bfs-with-two-queues",
                "content": "# Main Idea:\\n+ Using BFS with two queues to build bfs tree\\n+ At every node u of BFS Tree, v is adjacency node of u. There are two cases: v is child or sibling of u. \\n+ We find the common path of (root, u) and (root, v) and update the length of common path to ans with minimum operator.\\n\\n# Example:\\n```\\nExample 1: n = 7, edges = [[0, 1], [1, 2], [2, 0], [3, 4], [4, 5], [5, 6], [6, 3]]\\n\\nadj: [[1, 2], [0, 2], [1, 0], [4, 6], [3, 5], [4, 6], [5, 3]]\\nProcess Node 0:\\n+ 1,2 -> [1, 0], [2, 0], len=3 => ans = 8\\n+ 2,1 -> [2, 0], [1, 0], len=3 => ans = 3\\nProcess Node 3:\\n+ 6,5 -> [6, 3], [5, 4, 3], len=4 => ans = 3\\nans: 3\\n--------\\n\\nExample 2: n = 4, edges = [[0, 1], [0, 2]]\\n\\nadj: [[1, 2], [0], [0], []]\\nProcess Node 0:\\nProcess Node 3:\\nans: -1\\n--------\\n\\nExample 3: n = 8, edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [0, 7], [0, 6], [5, 7], [5, 6]]\\n\\nadj: [[1, 7, 6], [0, 2], [1, 3], [2, 4], [3, 5], [4, 7, 6], [0, 5], [0, 5]]\\nProcess Node 0:\\n+ 6,5 -> [6, 0], [5, 7, 0], len=4 => ans = 9\\n+ 3,4 -> [3, 2, 1, 0], [4, 5, 7, 0], len=7 => ans = 4\\n+ 4,3 -> [4, 5, 7, 0], [3, 2, 1, 0], len=7 => ans = 4\\nans: 4\\n--------\\n\\n```\\n# Code\\n+ Python\\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        # adj\\n        adj = [[] for _ in range(n)]\\n        for ai, bi in edges:\\n            adj[ai].append(bi)\\n            adj[bi].append(ai)\\n        # print(adj)\\n        \\n        level  = [-1] * n\\n        parent = [-1] * n\\n        check = [0]  * n\\n        ans = n + 1\\n        for i in range(n):\\n            if check[i] == 0:\\n                check[i] = 1\\n                q1 = [i]\\n                cur = 1\\n                while len(q1)>0:\\n                    q2 = []\\n                    for u in q1:\\n                        for v in adj[u]:\\n                            if check[v] == 0:\\n                                q2.append(v)\\n                                check[v] = 1\\n                                parent[v] = u\\n                                level[v] = cur\\n                            elif check[v] == 1 and level[v]>=level[u]:\\n                                pv = []\\n                                t = v\\n                                while t!=-1:\\n                                    pv.append(t)\\n                                    t = parent[t]\\n                                \\n                                pu = []\\n                                t = u\\n                                while t!=-1:\\n                                    pu.append(t)\\n                                    t = parent[t]\\n\\n                                while pu[-2] == pv[-2]:\\n                                    pu.pop(-1)\\n                                    pv.pop(-1)\\n                                \\n                                ans = min(ans, len(pu) - 1  + len(pv) - 1 + 1)\\n\\n                                print(pv, pu)\\n\\n                    q1 = q2\\n                    cur += 1\\n        if ans == n+1:\\n            ans = -1\\n        \\n        # print(level)\\n        # print(\"--------\")\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nExample 1: n = 7, edges = [[0, 1], [1, 2], [2, 0], [3, 4], [4, 5], [5, 6], [6, 3]]\\n\\nadj: [[1, 2], [0, 2], [1, 0], [4, 6], [3, 5], [4, 6], [5, 3]]\\nProcess Node 0:\\n+ 1,2 -> [1, 0], [2, 0], len=3 => ans = 8\\n+ 2,1 -> [2, 0], [1, 0], len=3 => ans = 3\\nProcess Node 3:\\n+ 6,5 -> [6, 3], [5, 4, 3], len=4 => ans = 3\\nans: 3\\n--------\\n\\nExample 2: n = 4, edges = [[0, 1], [0, 2]]\\n\\nadj: [[1, 2], [0], [0], []]\\nProcess Node 0:\\nProcess Node 3:\\nans: -1\\n--------\\n\\nExample 3: n = 8, edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [0, 7], [0, 6], [5, 7], [5, 6]]\\n\\nadj: [[1, 7, 6], [0, 2], [1, 3], [2, 4], [3, 5], [4, 7, 6], [0, 5], [0, 5]]\\nProcess Node 0:\\n+ 6,5 -> [6, 0], [5, 7, 0], len=4 => ans = 9\\n+ 3,4 -> [3, 2, 1, 0], [4, 5, 7, 0], len=7 => ans = 4\\n+ 4,3 -> [4, 5, 7, 0], [3, 2, 1, 0], len=7 => ans = 4\\nans: 4\\n--------\\n\\n```\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        # adj\\n        adj = [[] for _ in range(n)]\\n        for ai, bi in edges:\\n            adj[ai].append(bi)\\n            adj[bi].append(ai)\\n        # print(adj)\\n        \\n        level  = [-1] * n\\n        parent = [-1] * n\\n        check = [0]  * n\\n        ans = n + 1\\n        for i in range(n):\\n            if check[i] == 0:\\n                check[i] = 1\\n                q1 = [i]\\n                cur = 1\\n                while len(q1)>0:\\n                    q2 = []\\n                    for u in q1:\\n                        for v in adj[u]:\\n                            if check[v] == 0:\\n                                q2.append(v)\\n                                check[v] = 1\\n                                parent[v] = u\\n                                level[v] = cur\\n                            elif check[v] == 1 and level[v]>=level[u]:\\n                                pv = []\\n                                t = v\\n                                while t!=-1:\\n                                    pv.append(t)\\n                                    t = parent[t]\\n                                \\n                                pu = []\\n                                t = u\\n                                while t!=-1:\\n                                    pu.append(t)\\n                                    t = parent[t]\\n\\n                                while pu[-2] == pv[-2]:\\n                                    pu.pop(-1)\\n                                    pv.pop(-1)\\n                                \\n                                ans = min(ans, len(pu) - 1  + len(pv) - 1 + 1)\\n\\n                                print(pv, pu)\\n\\n                    q1 = q2\\n                    cur += 1\\n        if ans == n+1:\\n            ans = -1\\n        \\n        # print(level)\\n        # print(\"--------\")\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366960,
                "title": "java-dfs-and-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nrun DFS from each node - O(n * (m+n))\\n- Space complexity:\\nO (m+n)\\n\\n# Code\\n```\\nclass Solution {\\n    List<Integer>[] adjList;\\n    int[] visited; //stores the order\\n    int[] parent;\\n    int ans = Integer.MAX_VALUE;\\n    public int findShortestCycle(int n, int[][] edges) {\\n        parent = new int[n];\\n        Arrays.fill(parent, -1);\\n        \\n        buildGraph(n, edges);\\n\\n        // for (int i = 0; i < n; i++){\\n        //     visited = new int[n];\\n        //     Arrays.fill(visited, -1);\\n        //     if (visited[i] == -1){\\n        //         dfs(i,0);\\n        //     }\\n        // }\\n\\n        for (int i = 0; i < n; i++){\\n            int res = bfs(i, n);\\n            ans = Math.min(ans,res);\\n        }\\n        return (ans == Integer.MAX_VALUE) ? -1 : ans;\\n\\n    }\\n    \\n    private void dfs (int node, int level){\\n        visited[node] = level;\\n        \\n        for (int neigh : adjList[node]){\\n            if (visited[neigh] == -1){\\n                parent[neigh] = node;\\n                dfs (neigh, level+1);\\n            } else {\\n                //check for parent\\n                if (parent[node] != neigh){\\n                    int cycleLen =   Math.abs(visited[node] - visited[neigh]) + 1;\\n                    ans = Math.min(ans, cycleLen);\\n                }\\n            }\\n        }\\n        \\n    }\\n\\n    private int bfs (int src, int n){\\n        int[] dist = new int[n];\\n        int[] parent = new int[n];\\n        Arrays.fill (dist, Integer.MAX_VALUE);\\n        Arrays.fill (parent , -1);\\n        int result = Integer.MAX_VALUE;\\n\\n        Deque<Integer> queue = new LinkedList<>();\\n        queue.offer(src);\\n        dist[src] = 0;\\n        while (!queue.isEmpty()){\\n            int node = queue.poll();\\n            for (int neigh : adjList[node]){\\n                if (dist[neigh] == Integer.MAX_VALUE){\\n                    dist[neigh] = dist[node]+1;\\n                    parent[neigh] = node;\\n                    queue.offer(neigh);\\n                } else if (parent[node] != neigh){\\n                    int cycleLen = dist[node] + dist[neigh] + 1;\\n                    result = Math.min(result, cycleLen);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void buildGraph(int n, int[][] edges){\\n        adjList = new ArrayList[n];\\n        \\n        for (int i = 0; i < n; i++){\\n            adjList[i] = new ArrayList<>();\\n        }\\n        for (int[] edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            adjList[u].add(v);\\n            adjList[v].add(u);\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer>[] adjList;\\n    int[] visited; //stores the order\\n    int[] parent;\\n    int ans = Integer.MAX_VALUE;\\n    public int findShortestCycle(int n, int[][] edges) {\\n        parent = new int[n];\\n        Arrays.fill(parent, -1);\\n        \\n        buildGraph(n, edges);\\n\\n        // for (int i = 0; i < n; i++){\\n        //     visited = new int[n];\\n        //     Arrays.fill(visited, -1);\\n        //     if (visited[i] == -1){\\n        //         dfs(i,0);\\n        //     }\\n        // }\\n\\n        for (int i = 0; i < n; i++){\\n            int res = bfs(i, n);\\n            ans = Math.min(ans,res);\\n        }\\n        return (ans == Integer.MAX_VALUE) ? -1 : ans;\\n\\n    }\\n    \\n    private void dfs (int node, int level){\\n        visited[node] = level;\\n        \\n        for (int neigh : adjList[node]){\\n            if (visited[neigh] == -1){\\n                parent[neigh] = node;\\n                dfs (neigh, level+1);\\n            } else {\\n                //check for parent\\n                if (parent[node] != neigh){\\n                    int cycleLen =   Math.abs(visited[node] - visited[neigh]) + 1;\\n                    ans = Math.min(ans, cycleLen);\\n                }\\n            }\\n        }\\n        \\n    }\\n\\n    private int bfs (int src, int n){\\n        int[] dist = new int[n];\\n        int[] parent = new int[n];\\n        Arrays.fill (dist, Integer.MAX_VALUE);\\n        Arrays.fill (parent , -1);\\n        int result = Integer.MAX_VALUE;\\n\\n        Deque<Integer> queue = new LinkedList<>();\\n        queue.offer(src);\\n        dist[src] = 0;\\n        while (!queue.isEmpty()){\\n            int node = queue.poll();\\n            for (int neigh : adjList[node]){\\n                if (dist[neigh] == Integer.MAX_VALUE){\\n                    dist[neigh] = dist[node]+1;\\n                    parent[neigh] = node;\\n                    queue.offer(neigh);\\n                } else if (parent[node] != neigh){\\n                    int cycleLen = dist[node] + dist[neigh] + 1;\\n                    result = Math.min(result, cycleLen);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void buildGraph(int n, int[][] edges){\\n        adjList = new ArrayList[n];\\n        \\n        for (int i = 0; i < n; i++){\\n            adjList[i] = new ArrayList<>();\\n        }\\n        for (int[] edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            adjList[u].add(v);\\n            adjList[v].add(u);\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366918,
                "title": "easiest-solution-in-c-using-dfs-approach-with-2-visited-vectors",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    void dfs(int src, vector<int> &visited, vector<int> &curr, int &mini, vector<int> adj[], vector<int> &depth, int parent){\\n        visited[src] = 1;\\n        curr[src] = 1;\\n        \\n        if(parent != -1)\\n            depth[src] = depth[parent] + 1;\\n        \\n        for(auto child : adj[src]){\\n            if(child == parent) continue;\\n            if(!visited[child]){\\n                dfs(child,visited,curr,mini,adj,depth,src);\\n            }\\n            else if(curr[child]){\\n                int length = depth[src] - depth[child] + 1;\\n                mini = min(length, mini);\\n            }\\n        }\\n        curr[src] = 0;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        int min = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            vector<int> depth(n,0);\\n            vector<int> visited(n,0);\\n            vector<int> curr(n,0);\\n            dfs(i,visited,curr,min,adj,depth,-1);\\n        }\\n        \\n        if(min == INT_MAX) return -1;\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    void dfs(int src, vector<int> &visited, vector<int> &curr, int &mini, vector<int> adj[], vector<int> &depth, int parent){\\n        visited[src] = 1;\\n        curr[src] = 1;\\n        \\n        if(parent != -1)\\n            depth[src] = depth[parent] + 1;\\n        \\n        for(auto child : adj[src]){\\n            if(child == parent) continue;\\n            if(!visited[child]){\\n                dfs(child,visited,curr,mini,adj,depth,src);\\n            }\\n            else if(curr[child]){\\n                int length = depth[src] - depth[child] + 1;\\n                mini = min(length, mini);\\n            }\\n        }\\n        curr[src] = 0;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        vector<int> adj[n];\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        int min = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            vector<int> depth(n,0);\\n            vector<int> visited(n,0);\\n            vector<int> curr(n,0);\\n            dfs(i,visited,curr,min,adj,depth,-1);\\n        }\\n        \\n        if(min == INT_MAX) return -1;\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366915,
                "title": "c-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>* adj;\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        //BFS\\n        //calculate for each vertex\\n        //O(N2)\\n\\n        adj=new vector<int>[n];\\n        for(auto it: edges) {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        int cycle=1e9;\\n\\n        for(int i=0;i<n;i++) {\\n            queue<pair<int,int>> q; //current and parent\\n            vector<int> distance(n,-1);\\n            q.push(make_pair(i,-1));\\n            distance[i]=0;\\n\\n            while(!q.empty()) {\\n                pair<int,int> pi=q.front(); q.pop();\\n                for(auto it: adj[pi.first]) {\\n                    if(distance[it]==-1) { //not visited yet\\n                        distance[it]=distance[pi.first]+1;\\n                        q.push(make_pair(it,pi.first));\\n                    }\\n                    else if(pi.second != it) cycle=min(cycle, distance[pi.first]+distance[it]+1);\\n                }\\n            }\\n        }\\n\\n        return cycle==1e9 ? -1 : cycle;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>* adj;\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        //BFS\\n        //calculate for each vertex\\n        //O(N2)\\n\\n        adj=new vector<int>[n];\\n        for(auto it: edges) {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        int cycle=1e9;\\n\\n        for(int i=0;i<n;i++) {\\n            queue<pair<int,int>> q; //current and parent\\n            vector<int> distance(n,-1);\\n            q.push(make_pair(i,-1));\\n            distance[i]=0;\\n\\n            while(!q.empty()) {\\n                pair<int,int> pi=q.front(); q.pop();\\n                for(auto it: adj[pi.first]) {\\n                    if(distance[it]==-1) { //not visited yet\\n                        distance[it]=distance[pi.first]+1;\\n                        q.push(make_pair(it,pi.first));\\n                    }\\n                    else if(pi.second != it) cycle=min(cycle, distance[pi.first]+distance[it]+1);\\n                }\\n            }\\n        }\\n\\n        return cycle==1e9 ? -1 : cycle;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366880,
                "title": "easy-java-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMULTIPLE SOURCE BFS\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Using multiple source bfs to to find the cycle as the first cycle we detect is the shortest cycle\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public class Node{\\n        int val;\\n        int dist;\\n        int par;\\n        int src;\\n        Node(int val,int dist,int par,int src){\\n            this.val = val;\\n            this.dist = dist;\\n            this.par = par;\\n            this.src = src;\\n        }\\n    }\\n    public int findShortestCycle(int n, int[][] edges) {\\n        Queue<Node> q = new LinkedList<>();\\n        ArrayList<Integer>[] al = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            al[i]  = new ArrayList<Integer>();\\n        }\\n        boolean[] vis = new boolean[n];\\n        for(int[] edge: edges){\\n            al[edge[0]].add(edge[1]);\\n            al[edge[1]].add(edge[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            q.add(new Node(i,1,-1,i));\\n        }\\n        \\n        while(!q.isEmpty()){\\n            Node cur = q.poll();\\n            int val = cur.val;\\n            vis[val] = true;\\n            int dist = cur.dist;\\n            int par = cur.par;\\n            for(int i : al[val]){\\n                if(i!=cur.par && cur.src==i){\\n                    return dist;\\n                }\\n                if(i!=cur.par){\\n                    q.add(new Node(i,dist+1,val,cur.src));\\n                }\\n            }\\n        }\\n        System.out.println();\\n        return -1;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public class Node{\\n        int val;\\n        int dist;\\n        int par;\\n        int src;\\n        Node(int val,int dist,int par,int src){\\n            this.val = val;\\n            this.dist = dist;\\n            this.par = par;\\n            this.src = src;\\n        }\\n    }\\n    public int findShortestCycle(int n, int[][] edges) {\\n        Queue<Node> q = new LinkedList<>();\\n        ArrayList<Integer>[] al = new ArrayList[n];\\n        for(int i=0;i<n;i++){\\n            al[i]  = new ArrayList<Integer>();\\n        }\\n        boolean[] vis = new boolean[n];\\n        for(int[] edge: edges){\\n            al[edge[0]].add(edge[1]);\\n            al[edge[1]].add(edge[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            q.add(new Node(i,1,-1,i));\\n        }\\n        \\n        while(!q.isEmpty()){\\n            Node cur = q.poll();\\n            int val = cur.val;\\n            vis[val] = true;\\n            int dist = cur.dist;\\n            int par = cur.par;\\n            for(int i : al[val]){\\n                if(i!=cur.par && cur.src==i){\\n                    return dist;\\n                }\\n                if(i!=cur.par){\\n                    q.add(new Node(i,dist+1,val,cur.src));\\n                }\\n            }\\n        }\\n        System.out.println();\\n        return -1;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366856,
                "title": "c-bfs-beats-100-100",
                "content": "# Intuition\\nWe Do BFS from all the nodes to get the minimum length cycle in the graph\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void bfs(vector<vector<int>> &adj,vector<int> &vi,int i,int &ans){\\n        vi[i]=1;\\n        queue<pair<int,int>> q;\\n        q.push({i,-1});\\n        int cr=1;\\n\\n        while(!q.empty()){\\n            cr++;\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                int nd = q.front().first;\\n                int pr = q.front().second;\\n                q.pop();\\n\\n                for(auto &it : adj[nd]){\\n                    if(vi[it]==0){\\n                        vi[it]=cr;\\n                        q.push({it,nd});\\n                    }\\n                    else if(pr!=it){\\n                        ans = min(ans,vi[nd]+vi[it]-1);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            vector<int> vi(n,0);\\n            bfs(adj,vi,i,ans);\\n        }\\n        \\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void bfs(vector<vector<int>> &adj,vector<int> &vi,int i,int &ans){\\n        vi[i]=1;\\n        queue<pair<int,int>> q;\\n        q.push({i,-1});\\n        int cr=1;\\n\\n        while(!q.empty()){\\n            cr++;\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                int nd = q.front().first;\\n                int pr = q.front().second;\\n                q.pop();\\n\\n                for(auto &it : adj[nd]){\\n                    if(vi[it]==0){\\n                        vi[it]=cr;\\n                        q.push({it,nd});\\n                    }\\n                    else if(pr!=it){\\n                        ans = min(ans,vi[nd]+vi[it]-1);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            vector<int> vi(n,0);\\n            bfs(adj,vi,i,ans);\\n        }\\n        \\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366849,
                "title": "go-bfs",
                "content": "# Code\\n```\\nfunc findShortestCycle(n int, edges [][]int) int {\\n    next := make(map[int][]int)\\n    for _, edge := range edges {\\n        s, e := edge[0], edge[1]\\n        if _, ok := next[s]; !ok {\\n            next[s] = []int{}\\n        }\\n        next[s] = append(next[s], e)\\n        if _, ok := next[e]; !ok {\\n            next[e] = []int{}\\n        }\\n        next[e] = append(next[e], s)\\n    }\\n\\n    ans := math.MaxInt32\\n    for i := 0; i < n; i++ {\\n        curr := make(map[int]int)\\n        q := [][]int{ []int{i, -1, 0} }  // current position, previous position, counter\\n        for len(q) > 0 {\\n            p, prev, counter := q[0][0], q[0][1], q[0][2]\\n            q = q[1:]\\n\\n            if v, ok := curr[p]; ok {\\n                // start at position i, find a min cycle\\n                if counter + v < ans  { ans = counter + v }\\n                break\\n            }\\n            curr[p] = counter\\n\\n            for _, nxt := range next[p] {\\n                if nxt == prev { continue }\\n                q = append(q, []int{nxt, p, counter+1})\\n            }\\n\\n        }\\n    }\\n    if ans == math.MaxInt32 { return -1 }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc findShortestCycle(n int, edges [][]int) int {\\n    next := make(map[int][]int)\\n    for _, edge := range edges {\\n        s, e := edge[0], edge[1]\\n        if _, ok := next[s]; !ok {\\n            next[s] = []int{}\\n        }\\n        next[s] = append(next[s], e)\\n        if _, ok := next[e]; !ok {\\n            next[e] = []int{}\\n        }\\n        next[e] = append(next[e], s)\\n    }\\n\\n    ans := math.MaxInt32\\n    for i := 0; i < n; i++ {\\n        curr := make(map[int]int)\\n        q := [][]int{ []int{i, -1, 0} }  // current position, previous position, counter\\n        for len(q) > 0 {\\n            p, prev, counter := q[0][0], q[0][1], q[0][2]\\n            q = q[1:]\\n\\n            if v, ok := curr[p]; ok {\\n                // start at position i, find a min cycle\\n                if counter + v < ans  { ans = counter + v }\\n                break\\n            }\\n            curr[p] = counter\\n\\n            for _, nxt := range next[p] {\\n                if nxt == prev { continue }\\n                q = append(q, []int{nxt, p, counter+1})\\n            }\\n\\n        }\\n    }\\n    if ans == math.MaxInt32 { return -1 }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1850621,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "Example of why normal DFS is not working:\\n\\n![image.png](https://assets.leetcode.com/users/images/5df4d6a1-83b3-4ec9-9666-8893fade3478_1680376230.8115823.png)\\n\\nSuppose, we start from 0, and do DFS like\\n$0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4$\\nThe cycle detected will be of length 5, $0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4 \\\\to 0$\\nBut the answer is 4, with cycle of $0 \\\\to 4 \\\\to 3 \\\\to 5 \\\\to 0$\\nSo, in DFS, it is possible to take a long cyclic route back to start, while ignoring the shorter cycles."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah,the leetcode one is way too simple. I tried searching for question that needed a longest cycle and the directed graph had nodes with multiple outgoing edges but I couldn\\'t find such a question anywhere at all. Well guess if some  interviewer does decide to ask it,I can always try applying this algo first and then think from there or even the BFS method would work on directed graphs."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Indeed it was a great question. Yes I think it should work on directed as only change is that we don\\'t have to add both side edges while creating adjacency list from `edges`. And for longest cycle we can initialize depth array with -1, check for `depth[next] < depth[curr] + 1` for not visited or already visited via shorter d. I am not sure though where to confirm as LeetCode\\'s one has only one outgoing directed edge."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah I finally did this solution as well. Had to search a lot and do a lot of thinking. This was a really good question. Do you think this same logic could be used for finding the longest cycle as well?And do you think it will work in a similar way on Directed Graphs as well? Actually I was trying to think of a general way for such cycle length questions that would apply to any general graph be it directed or undirected with minor changes."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Thanks for pointing this, looks like LeetCode has added strong test cases. See this failed graph:\n![image.png](https://assets.leetcode.com/users/images/ede2ed33-829e-4f41-88ef-a4787e3171ef_1683659936.2227714.png)\nDFS does not guarantee that we will reach the shortest cycle first. And if we marked the nodes as visited while going through a longer cycle first, then we will never traverse the shorter cycle.\nSo, based on this I have updated the link in my previous comment. See this [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) solution.\nHere I am traversing one complete component at a time. Main logic lies within these two statements:\n1. `if (depth[next] > depth[curr] + 1)`: In this case we are doing normal DFS traversal with increased depth `d + 1`. The if condition will be true if `depth[next] = INT_MAX` ie., not visited, OR if `depth[next] != INT_MAX && depth[next] > depth[curr] + 1` ie., we have visited this `next` node before but through a larger depth and now we want to visited it with some smaller depth `d + 1` so it is still possible to find a shorter cycle along this path.\n2. `if (depth[next] < depth[curr])`: In this case the shortest cycle for the current node has been found. Because we want to visit `next` with depth `d + 1` but it has already been visited with some smaller depth `depth[next]`. So we decide not to go along that path again and just update cycle length."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) I saw your DFS solution,but I am having difficulty understanding it,could you explain it in brief?I also copy pasted the DFS code from the link you gave and it failed at test case 85\n9\n[[4,5],[1,6],[6,4],[5,3],[3,6],[0,2],[5,8],[0,6],[3,0],[6,8],[2,8],[1,2]]\nIn fact all the DFS solutions in the solution section is failing this test case\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) Thanks that was super helpful. What made the difference in the end was adding a variable for depth and stopping when depth was larger than answer (i.e. the shortest path I had already found)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Psriraj](/Psriraj) See this traversal:\\n\\n![image.png](https://assets.leetcode.com/users/images/95caf2b2-c75b-4f71-8666-38d47f7b3925_1680419448.1463418.png)\\n\\nTry to do iterations, refer to iteration numbers. Green are those which are doing next recursive call. Reds are the backtracks when cycle is found, to previous call, by marking visited of current false. Underlined are those where cycle was found.\\n\\nSee how many times it is traversing on the same cycle again. And think if there was one more node in same graph, like $0 - 5 - 2$, then how many times it would have gone to same nodes again."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) I also tried to do DFS in contest, but it was TLE. But actually DFS solution is possible. See these: [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) and [BFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926373494/)."
                    },
                    {
                        "username": "Psriraj",
                        "content": "This is case is actually Handled here, but im not sure why this is giving a TLE!!\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I do get that, that is a nice illustration though! So I was looking for all possible cycles and wanted to just return the shortest one. Somewhat obviously that gives TLE. So I  was looking to use some sort of visited Set, or memo to stop  a search if the node is already visited, that gives the wrong answer for me. Is there absolutely no way around this?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I am trying to do this with DFS, which gave me TLE, I tried adding memorization, but I run out of memory. Is it possible to do it with DFS, or should I just give up and switch to BFS?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Mister_CK](/Mister_CK) thank you bro so much ur a life saver, "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "thanks for the help! What solve TLE for me in the end was to keep track of current cycle length (depth) and stop any iteration if depth>answer. "
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\n\\n[@nikhil97agra](/nikhil97agra)  Same issue here,\\nIts giving TLE with dfs , Heres is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n\\n\\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "@Mister_CK you may check this out https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926060450/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhil97agra](/nikhil97agra) sure, this is the code incl. memo, which ran out of space, without memo it runs out of time:\nhttps://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926046807/\n\nvar findShortestCycle = function(n, edges) {\n    let adacencyList = new Map()\n    edges.forEach(edge => {\n        if (adacencyList.has(edge[0])) {\n            let neighbours = adacencyList.get(edge[0])\n            neighbours.push(edge[1])\n            adacencyList.set(edge[0], neighbours)\n        } else {\n            adacencyList.set(edge[0], [edge[1]])\n        }\n        if (adacencyList.has(edge[1])) {\n            let neighbours = adacencyList.get(edge[1])\n            neighbours.push(edge[0])\n            adacencyList.set(edge[1], neighbours)\n        } else {\n            adacencyList.set(edge[1], [edge[0]])\n        }\n    })\n    //console.log(adacencyList)\n    let answer = Infinity\n    let visits = new Set()\n    let memo = {}\n    const dfs = (node, prevNode, visited) => {\n        let key ='' + node.toString()\n        visited.forEach(el => key += el.toString())\n        if (key in memo) return\n        memo[key] = true\n        //console.log(visited)\n        let neighbours = adacencyList.get(node)\n        let found = false\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            if (visited.has(neighbour) ) {\n                let length = visited.size - new Array(...visited).indexOf(neighbour)\n                answer = Math.min(answer, length)\n                found  = true\n            }\n        })\n        if (found) return\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            let alreadyVisited = new Set(visited)\n            alreadyVisited.add(neighbour)\n            dfs(neighbour, node, alreadyVisited)\n        })\n    }\n    for (let i = 0; i < n; i++) {\n        if (adacencyList.has(i)) { \n            dfs(i, -1, visits, 0)\n        }\n    }\n    //console.log(memo)\n    if (answer === Infinity) return -1\n    return answer\n};\n\n"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "Can you share your code I\\'ll be much easier to figure out"
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can someone just clarify why we have to run bfs on all nodes inspite of only unvisited ones ?"
                    },
                    {
                        "username": "15o1",
                        "content": "Easiest hard problem"
                    },
                    {
                        "username": "15o1",
                        "content": "[@workcool](/workcool) my code works fine on this"
                    },
                    {
                        "username": "workcool",
                        "content": "Nah, I don\\'t think so, it is pretty trick for test cases such as [[0,3],[0,5],[3,4],[4,5],[1,9],[1,11],[9,10],[11,10],[2,6],[2,8],[6,7],[8,7],[0,1],[0,2],[1,2]]"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "I have written code for  the problem but it is applicable for some testcases. Can anyone help me to figure out what is wrong is this. my inline code..\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        HashSet<Integer>hash = new HashSet<>();\\n        for(int i= 0; i<edges.length; i++){\\n            hash.add(edges[i][0]);\\n            hash.add(edges[i][1]);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        boolean[] visited = new boolean[n];\\n        for (int i: hash) {\\n            if (!visited[i]) {\\n                int val = dfs(i, -1, graph, visited, 1);\\n                min = Math.min(val, min);\\n            }\\n        }\\n        return min;\\n    }\\n\\n    public int dfs(int curr, int par, List<List<Integer>> graph, boolean[] visited, int count) {\\n        visited[curr] = true;\\n        for (int neighbor : graph.get(curr)) {\\n            if (visited[neighbor] && neighbor != par) {\\n                return count;\\n            } else if (!visited[neighbor]) {\\n                int result = dfs(neighbor, curr, graph, visited, count + 1);\\n                if (result != -1) {\\n                    return result;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\nCant we solve it using DFS?\\nIt\\'s giving TLE with dfs , Here is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can this problem be solved using dfs topological sort ?"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "no that is only applicable for directed acyclic graph and this problem is undirected."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me to figure out why dfs cycle detecting algo along with time_stamps doesn\\'t work here. Is there any linear solution for this problem.\\nThanks in advance!"
                    }
                ]
            },
            {
                "id": 1850334,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "Example of why normal DFS is not working:\\n\\n![image.png](https://assets.leetcode.com/users/images/5df4d6a1-83b3-4ec9-9666-8893fade3478_1680376230.8115823.png)\\n\\nSuppose, we start from 0, and do DFS like\\n$0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4$\\nThe cycle detected will be of length 5, $0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4 \\\\to 0$\\nBut the answer is 4, with cycle of $0 \\\\to 4 \\\\to 3 \\\\to 5 \\\\to 0$\\nSo, in DFS, it is possible to take a long cyclic route back to start, while ignoring the shorter cycles."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah,the leetcode one is way too simple. I tried searching for question that needed a longest cycle and the directed graph had nodes with multiple outgoing edges but I couldn\\'t find such a question anywhere at all. Well guess if some  interviewer does decide to ask it,I can always try applying this algo first and then think from there or even the BFS method would work on directed graphs."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Indeed it was a great question. Yes I think it should work on directed as only change is that we don\\'t have to add both side edges while creating adjacency list from `edges`. And for longest cycle we can initialize depth array with -1, check for `depth[next] < depth[curr] + 1` for not visited or already visited via shorter d. I am not sure though where to confirm as LeetCode\\'s one has only one outgoing directed edge."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah I finally did this solution as well. Had to search a lot and do a lot of thinking. This was a really good question. Do you think this same logic could be used for finding the longest cycle as well?And do you think it will work in a similar way on Directed Graphs as well? Actually I was trying to think of a general way for such cycle length questions that would apply to any general graph be it directed or undirected with minor changes."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Thanks for pointing this, looks like LeetCode has added strong test cases. See this failed graph:\n![image.png](https://assets.leetcode.com/users/images/ede2ed33-829e-4f41-88ef-a4787e3171ef_1683659936.2227714.png)\nDFS does not guarantee that we will reach the shortest cycle first. And if we marked the nodes as visited while going through a longer cycle first, then we will never traverse the shorter cycle.\nSo, based on this I have updated the link in my previous comment. See this [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) solution.\nHere I am traversing one complete component at a time. Main logic lies within these two statements:\n1. `if (depth[next] > depth[curr] + 1)`: In this case we are doing normal DFS traversal with increased depth `d + 1`. The if condition will be true if `depth[next] = INT_MAX` ie., not visited, OR if `depth[next] != INT_MAX && depth[next] > depth[curr] + 1` ie., we have visited this `next` node before but through a larger depth and now we want to visited it with some smaller depth `d + 1` so it is still possible to find a shorter cycle along this path.\n2. `if (depth[next] < depth[curr])`: In this case the shortest cycle for the current node has been found. Because we want to visit `next` with depth `d + 1` but it has already been visited with some smaller depth `depth[next]`. So we decide not to go along that path again and just update cycle length."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) I saw your DFS solution,but I am having difficulty understanding it,could you explain it in brief?I also copy pasted the DFS code from the link you gave and it failed at test case 85\n9\n[[4,5],[1,6],[6,4],[5,3],[3,6],[0,2],[5,8],[0,6],[3,0],[6,8],[2,8],[1,2]]\nIn fact all the DFS solutions in the solution section is failing this test case\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) Thanks that was super helpful. What made the difference in the end was adding a variable for depth and stopping when depth was larger than answer (i.e. the shortest path I had already found)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Psriraj](/Psriraj) See this traversal:\\n\\n![image.png](https://assets.leetcode.com/users/images/95caf2b2-c75b-4f71-8666-38d47f7b3925_1680419448.1463418.png)\\n\\nTry to do iterations, refer to iteration numbers. Green are those which are doing next recursive call. Reds are the backtracks when cycle is found, to previous call, by marking visited of current false. Underlined are those where cycle was found.\\n\\nSee how many times it is traversing on the same cycle again. And think if there was one more node in same graph, like $0 - 5 - 2$, then how many times it would have gone to same nodes again."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) I also tried to do DFS in contest, but it was TLE. But actually DFS solution is possible. See these: [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) and [BFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926373494/)."
                    },
                    {
                        "username": "Psriraj",
                        "content": "This is case is actually Handled here, but im not sure why this is giving a TLE!!\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I do get that, that is a nice illustration though! So I was looking for all possible cycles and wanted to just return the shortest one. Somewhat obviously that gives TLE. So I  was looking to use some sort of visited Set, or memo to stop  a search if the node is already visited, that gives the wrong answer for me. Is there absolutely no way around this?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I am trying to do this with DFS, which gave me TLE, I tried adding memorization, but I run out of memory. Is it possible to do it with DFS, or should I just give up and switch to BFS?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Mister_CK](/Mister_CK) thank you bro so much ur a life saver, "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "thanks for the help! What solve TLE for me in the end was to keep track of current cycle length (depth) and stop any iteration if depth>answer. "
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\n\\n[@nikhil97agra](/nikhil97agra)  Same issue here,\\nIts giving TLE with dfs , Heres is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n\\n\\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "@Mister_CK you may check this out https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926060450/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhil97agra](/nikhil97agra) sure, this is the code incl. memo, which ran out of space, without memo it runs out of time:\nhttps://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926046807/\n\nvar findShortestCycle = function(n, edges) {\n    let adacencyList = new Map()\n    edges.forEach(edge => {\n        if (adacencyList.has(edge[0])) {\n            let neighbours = adacencyList.get(edge[0])\n            neighbours.push(edge[1])\n            adacencyList.set(edge[0], neighbours)\n        } else {\n            adacencyList.set(edge[0], [edge[1]])\n        }\n        if (adacencyList.has(edge[1])) {\n            let neighbours = adacencyList.get(edge[1])\n            neighbours.push(edge[0])\n            adacencyList.set(edge[1], neighbours)\n        } else {\n            adacencyList.set(edge[1], [edge[0]])\n        }\n    })\n    //console.log(adacencyList)\n    let answer = Infinity\n    let visits = new Set()\n    let memo = {}\n    const dfs = (node, prevNode, visited) => {\n        let key ='' + node.toString()\n        visited.forEach(el => key += el.toString())\n        if (key in memo) return\n        memo[key] = true\n        //console.log(visited)\n        let neighbours = adacencyList.get(node)\n        let found = false\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            if (visited.has(neighbour) ) {\n                let length = visited.size - new Array(...visited).indexOf(neighbour)\n                answer = Math.min(answer, length)\n                found  = true\n            }\n        })\n        if (found) return\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            let alreadyVisited = new Set(visited)\n            alreadyVisited.add(neighbour)\n            dfs(neighbour, node, alreadyVisited)\n        })\n    }\n    for (let i = 0; i < n; i++) {\n        if (adacencyList.has(i)) { \n            dfs(i, -1, visits, 0)\n        }\n    }\n    //console.log(memo)\n    if (answer === Infinity) return -1\n    return answer\n};\n\n"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "Can you share your code I\\'ll be much easier to figure out"
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can someone just clarify why we have to run bfs on all nodes inspite of only unvisited ones ?"
                    },
                    {
                        "username": "15o1",
                        "content": "Easiest hard problem"
                    },
                    {
                        "username": "15o1",
                        "content": "[@workcool](/workcool) my code works fine on this"
                    },
                    {
                        "username": "workcool",
                        "content": "Nah, I don\\'t think so, it is pretty trick for test cases such as [[0,3],[0,5],[3,4],[4,5],[1,9],[1,11],[9,10],[11,10],[2,6],[2,8],[6,7],[8,7],[0,1],[0,2],[1,2]]"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "I have written code for  the problem but it is applicable for some testcases. Can anyone help me to figure out what is wrong is this. my inline code..\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        HashSet<Integer>hash = new HashSet<>();\\n        for(int i= 0; i<edges.length; i++){\\n            hash.add(edges[i][0]);\\n            hash.add(edges[i][1]);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        boolean[] visited = new boolean[n];\\n        for (int i: hash) {\\n            if (!visited[i]) {\\n                int val = dfs(i, -1, graph, visited, 1);\\n                min = Math.min(val, min);\\n            }\\n        }\\n        return min;\\n    }\\n\\n    public int dfs(int curr, int par, List<List<Integer>> graph, boolean[] visited, int count) {\\n        visited[curr] = true;\\n        for (int neighbor : graph.get(curr)) {\\n            if (visited[neighbor] && neighbor != par) {\\n                return count;\\n            } else if (!visited[neighbor]) {\\n                int result = dfs(neighbor, curr, graph, visited, count + 1);\\n                if (result != -1) {\\n                    return result;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\nCant we solve it using DFS?\\nIt\\'s giving TLE with dfs , Here is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can this problem be solved using dfs topological sort ?"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "no that is only applicable for directed acyclic graph and this problem is undirected."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me to figure out why dfs cycle detecting algo along with time_stamps doesn\\'t work here. Is there any linear solution for this problem.\\nThanks in advance!"
                    }
                ]
            },
            {
                "id": 1978818,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "Example of why normal DFS is not working:\\n\\n![image.png](https://assets.leetcode.com/users/images/5df4d6a1-83b3-4ec9-9666-8893fade3478_1680376230.8115823.png)\\n\\nSuppose, we start from 0, and do DFS like\\n$0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4$\\nThe cycle detected will be of length 5, $0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4 \\\\to 0$\\nBut the answer is 4, with cycle of $0 \\\\to 4 \\\\to 3 \\\\to 5 \\\\to 0$\\nSo, in DFS, it is possible to take a long cyclic route back to start, while ignoring the shorter cycles."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah,the leetcode one is way too simple. I tried searching for question that needed a longest cycle and the directed graph had nodes with multiple outgoing edges but I couldn\\'t find such a question anywhere at all. Well guess if some  interviewer does decide to ask it,I can always try applying this algo first and then think from there or even the BFS method would work on directed graphs."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Indeed it was a great question. Yes I think it should work on directed as only change is that we don\\'t have to add both side edges while creating adjacency list from `edges`. And for longest cycle we can initialize depth array with -1, check for `depth[next] < depth[curr] + 1` for not visited or already visited via shorter d. I am not sure though where to confirm as LeetCode\\'s one has only one outgoing directed edge."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah I finally did this solution as well. Had to search a lot and do a lot of thinking. This was a really good question. Do you think this same logic could be used for finding the longest cycle as well?And do you think it will work in a similar way on Directed Graphs as well? Actually I was trying to think of a general way for such cycle length questions that would apply to any general graph be it directed or undirected with minor changes."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Thanks for pointing this, looks like LeetCode has added strong test cases. See this failed graph:\n![image.png](https://assets.leetcode.com/users/images/ede2ed33-829e-4f41-88ef-a4787e3171ef_1683659936.2227714.png)\nDFS does not guarantee that we will reach the shortest cycle first. And if we marked the nodes as visited while going through a longer cycle first, then we will never traverse the shorter cycle.\nSo, based on this I have updated the link in my previous comment. See this [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) solution.\nHere I am traversing one complete component at a time. Main logic lies within these two statements:\n1. `if (depth[next] > depth[curr] + 1)`: In this case we are doing normal DFS traversal with increased depth `d + 1`. The if condition will be true if `depth[next] = INT_MAX` ie., not visited, OR if `depth[next] != INT_MAX && depth[next] > depth[curr] + 1` ie., we have visited this `next` node before but through a larger depth and now we want to visited it with some smaller depth `d + 1` so it is still possible to find a shorter cycle along this path.\n2. `if (depth[next] < depth[curr])`: In this case the shortest cycle for the current node has been found. Because we want to visit `next` with depth `d + 1` but it has already been visited with some smaller depth `depth[next]`. So we decide not to go along that path again and just update cycle length."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) I saw your DFS solution,but I am having difficulty understanding it,could you explain it in brief?I also copy pasted the DFS code from the link you gave and it failed at test case 85\n9\n[[4,5],[1,6],[6,4],[5,3],[3,6],[0,2],[5,8],[0,6],[3,0],[6,8],[2,8],[1,2]]\nIn fact all the DFS solutions in the solution section is failing this test case\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) Thanks that was super helpful. What made the difference in the end was adding a variable for depth and stopping when depth was larger than answer (i.e. the shortest path I had already found)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Psriraj](/Psriraj) See this traversal:\\n\\n![image.png](https://assets.leetcode.com/users/images/95caf2b2-c75b-4f71-8666-38d47f7b3925_1680419448.1463418.png)\\n\\nTry to do iterations, refer to iteration numbers. Green are those which are doing next recursive call. Reds are the backtracks when cycle is found, to previous call, by marking visited of current false. Underlined are those where cycle was found.\\n\\nSee how many times it is traversing on the same cycle again. And think if there was one more node in same graph, like $0 - 5 - 2$, then how many times it would have gone to same nodes again."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) I also tried to do DFS in contest, but it was TLE. But actually DFS solution is possible. See these: [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) and [BFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926373494/)."
                    },
                    {
                        "username": "Psriraj",
                        "content": "This is case is actually Handled here, but im not sure why this is giving a TLE!!\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I do get that, that is a nice illustration though! So I was looking for all possible cycles and wanted to just return the shortest one. Somewhat obviously that gives TLE. So I  was looking to use some sort of visited Set, or memo to stop  a search if the node is already visited, that gives the wrong answer for me. Is there absolutely no way around this?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I am trying to do this with DFS, which gave me TLE, I tried adding memorization, but I run out of memory. Is it possible to do it with DFS, or should I just give up and switch to BFS?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Mister_CK](/Mister_CK) thank you bro so much ur a life saver, "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "thanks for the help! What solve TLE for me in the end was to keep track of current cycle length (depth) and stop any iteration if depth>answer. "
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\n\\n[@nikhil97agra](/nikhil97agra)  Same issue here,\\nIts giving TLE with dfs , Heres is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n\\n\\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "@Mister_CK you may check this out https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926060450/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhil97agra](/nikhil97agra) sure, this is the code incl. memo, which ran out of space, without memo it runs out of time:\nhttps://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926046807/\n\nvar findShortestCycle = function(n, edges) {\n    let adacencyList = new Map()\n    edges.forEach(edge => {\n        if (adacencyList.has(edge[0])) {\n            let neighbours = adacencyList.get(edge[0])\n            neighbours.push(edge[1])\n            adacencyList.set(edge[0], neighbours)\n        } else {\n            adacencyList.set(edge[0], [edge[1]])\n        }\n        if (adacencyList.has(edge[1])) {\n            let neighbours = adacencyList.get(edge[1])\n            neighbours.push(edge[0])\n            adacencyList.set(edge[1], neighbours)\n        } else {\n            adacencyList.set(edge[1], [edge[0]])\n        }\n    })\n    //console.log(adacencyList)\n    let answer = Infinity\n    let visits = new Set()\n    let memo = {}\n    const dfs = (node, prevNode, visited) => {\n        let key ='' + node.toString()\n        visited.forEach(el => key += el.toString())\n        if (key in memo) return\n        memo[key] = true\n        //console.log(visited)\n        let neighbours = adacencyList.get(node)\n        let found = false\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            if (visited.has(neighbour) ) {\n                let length = visited.size - new Array(...visited).indexOf(neighbour)\n                answer = Math.min(answer, length)\n                found  = true\n            }\n        })\n        if (found) return\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            let alreadyVisited = new Set(visited)\n            alreadyVisited.add(neighbour)\n            dfs(neighbour, node, alreadyVisited)\n        })\n    }\n    for (let i = 0; i < n; i++) {\n        if (adacencyList.has(i)) { \n            dfs(i, -1, visits, 0)\n        }\n    }\n    //console.log(memo)\n    if (answer === Infinity) return -1\n    return answer\n};\n\n"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "Can you share your code I\\'ll be much easier to figure out"
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can someone just clarify why we have to run bfs on all nodes inspite of only unvisited ones ?"
                    },
                    {
                        "username": "15o1",
                        "content": "Easiest hard problem"
                    },
                    {
                        "username": "15o1",
                        "content": "[@workcool](/workcool) my code works fine on this"
                    },
                    {
                        "username": "workcool",
                        "content": "Nah, I don\\'t think so, it is pretty trick for test cases such as [[0,3],[0,5],[3,4],[4,5],[1,9],[1,11],[9,10],[11,10],[2,6],[2,8],[6,7],[8,7],[0,1],[0,2],[1,2]]"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "I have written code for  the problem but it is applicable for some testcases. Can anyone help me to figure out what is wrong is this. my inline code..\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        HashSet<Integer>hash = new HashSet<>();\\n        for(int i= 0; i<edges.length; i++){\\n            hash.add(edges[i][0]);\\n            hash.add(edges[i][1]);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        boolean[] visited = new boolean[n];\\n        for (int i: hash) {\\n            if (!visited[i]) {\\n                int val = dfs(i, -1, graph, visited, 1);\\n                min = Math.min(val, min);\\n            }\\n        }\\n        return min;\\n    }\\n\\n    public int dfs(int curr, int par, List<List<Integer>> graph, boolean[] visited, int count) {\\n        visited[curr] = true;\\n        for (int neighbor : graph.get(curr)) {\\n            if (visited[neighbor] && neighbor != par) {\\n                return count;\\n            } else if (!visited[neighbor]) {\\n                int result = dfs(neighbor, curr, graph, visited, count + 1);\\n                if (result != -1) {\\n                    return result;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\nCant we solve it using DFS?\\nIt\\'s giving TLE with dfs , Here is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can this problem be solved using dfs topological sort ?"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "no that is only applicable for directed acyclic graph and this problem is undirected."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me to figure out why dfs cycle detecting algo along with time_stamps doesn\\'t work here. Is there any linear solution for this problem.\\nThanks in advance!"
                    }
                ]
            },
            {
                "id": 1850340,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "Example of why normal DFS is not working:\\n\\n![image.png](https://assets.leetcode.com/users/images/5df4d6a1-83b3-4ec9-9666-8893fade3478_1680376230.8115823.png)\\n\\nSuppose, we start from 0, and do DFS like\\n$0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4$\\nThe cycle detected will be of length 5, $0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4 \\\\to 0$\\nBut the answer is 4, with cycle of $0 \\\\to 4 \\\\to 3 \\\\to 5 \\\\to 0$\\nSo, in DFS, it is possible to take a long cyclic route back to start, while ignoring the shorter cycles."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah,the leetcode one is way too simple. I tried searching for question that needed a longest cycle and the directed graph had nodes with multiple outgoing edges but I couldn\\'t find such a question anywhere at all. Well guess if some  interviewer does decide to ask it,I can always try applying this algo first and then think from there or even the BFS method would work on directed graphs."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Indeed it was a great question. Yes I think it should work on directed as only change is that we don\\'t have to add both side edges while creating adjacency list from `edges`. And for longest cycle we can initialize depth array with -1, check for `depth[next] < depth[curr] + 1` for not visited or already visited via shorter d. I am not sure though where to confirm as LeetCode\\'s one has only one outgoing directed edge."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah I finally did this solution as well. Had to search a lot and do a lot of thinking. This was a really good question. Do you think this same logic could be used for finding the longest cycle as well?And do you think it will work in a similar way on Directed Graphs as well? Actually I was trying to think of a general way for such cycle length questions that would apply to any general graph be it directed or undirected with minor changes."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Thanks for pointing this, looks like LeetCode has added strong test cases. See this failed graph:\n![image.png](https://assets.leetcode.com/users/images/ede2ed33-829e-4f41-88ef-a4787e3171ef_1683659936.2227714.png)\nDFS does not guarantee that we will reach the shortest cycle first. And if we marked the nodes as visited while going through a longer cycle first, then we will never traverse the shorter cycle.\nSo, based on this I have updated the link in my previous comment. See this [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) solution.\nHere I am traversing one complete component at a time. Main logic lies within these two statements:\n1. `if (depth[next] > depth[curr] + 1)`: In this case we are doing normal DFS traversal with increased depth `d + 1`. The if condition will be true if `depth[next] = INT_MAX` ie., not visited, OR if `depth[next] != INT_MAX && depth[next] > depth[curr] + 1` ie., we have visited this `next` node before but through a larger depth and now we want to visited it with some smaller depth `d + 1` so it is still possible to find a shorter cycle along this path.\n2. `if (depth[next] < depth[curr])`: In this case the shortest cycle for the current node has been found. Because we want to visit `next` with depth `d + 1` but it has already been visited with some smaller depth `depth[next]`. So we decide not to go along that path again and just update cycle length."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) I saw your DFS solution,but I am having difficulty understanding it,could you explain it in brief?I also copy pasted the DFS code from the link you gave and it failed at test case 85\n9\n[[4,5],[1,6],[6,4],[5,3],[3,6],[0,2],[5,8],[0,6],[3,0],[6,8],[2,8],[1,2]]\nIn fact all the DFS solutions in the solution section is failing this test case\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) Thanks that was super helpful. What made the difference in the end was adding a variable for depth and stopping when depth was larger than answer (i.e. the shortest path I had already found)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Psriraj](/Psriraj) See this traversal:\\n\\n![image.png](https://assets.leetcode.com/users/images/95caf2b2-c75b-4f71-8666-38d47f7b3925_1680419448.1463418.png)\\n\\nTry to do iterations, refer to iteration numbers. Green are those which are doing next recursive call. Reds are the backtracks when cycle is found, to previous call, by marking visited of current false. Underlined are those where cycle was found.\\n\\nSee how many times it is traversing on the same cycle again. And think if there was one more node in same graph, like $0 - 5 - 2$, then how many times it would have gone to same nodes again."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) I also tried to do DFS in contest, but it was TLE. But actually DFS solution is possible. See these: [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) and [BFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926373494/)."
                    },
                    {
                        "username": "Psriraj",
                        "content": "This is case is actually Handled here, but im not sure why this is giving a TLE!!\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I do get that, that is a nice illustration though! So I was looking for all possible cycles and wanted to just return the shortest one. Somewhat obviously that gives TLE. So I  was looking to use some sort of visited Set, or memo to stop  a search if the node is already visited, that gives the wrong answer for me. Is there absolutely no way around this?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I am trying to do this with DFS, which gave me TLE, I tried adding memorization, but I run out of memory. Is it possible to do it with DFS, or should I just give up and switch to BFS?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Mister_CK](/Mister_CK) thank you bro so much ur a life saver, "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "thanks for the help! What solve TLE for me in the end was to keep track of current cycle length (depth) and stop any iteration if depth>answer. "
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\n\\n[@nikhil97agra](/nikhil97agra)  Same issue here,\\nIts giving TLE with dfs , Heres is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n\\n\\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "@Mister_CK you may check this out https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926060450/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhil97agra](/nikhil97agra) sure, this is the code incl. memo, which ran out of space, without memo it runs out of time:\nhttps://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926046807/\n\nvar findShortestCycle = function(n, edges) {\n    let adacencyList = new Map()\n    edges.forEach(edge => {\n        if (adacencyList.has(edge[0])) {\n            let neighbours = adacencyList.get(edge[0])\n            neighbours.push(edge[1])\n            adacencyList.set(edge[0], neighbours)\n        } else {\n            adacencyList.set(edge[0], [edge[1]])\n        }\n        if (adacencyList.has(edge[1])) {\n            let neighbours = adacencyList.get(edge[1])\n            neighbours.push(edge[0])\n            adacencyList.set(edge[1], neighbours)\n        } else {\n            adacencyList.set(edge[1], [edge[0]])\n        }\n    })\n    //console.log(adacencyList)\n    let answer = Infinity\n    let visits = new Set()\n    let memo = {}\n    const dfs = (node, prevNode, visited) => {\n        let key ='' + node.toString()\n        visited.forEach(el => key += el.toString())\n        if (key in memo) return\n        memo[key] = true\n        //console.log(visited)\n        let neighbours = adacencyList.get(node)\n        let found = false\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            if (visited.has(neighbour) ) {\n                let length = visited.size - new Array(...visited).indexOf(neighbour)\n                answer = Math.min(answer, length)\n                found  = true\n            }\n        })\n        if (found) return\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            let alreadyVisited = new Set(visited)\n            alreadyVisited.add(neighbour)\n            dfs(neighbour, node, alreadyVisited)\n        })\n    }\n    for (let i = 0; i < n; i++) {\n        if (adacencyList.has(i)) { \n            dfs(i, -1, visits, 0)\n        }\n    }\n    //console.log(memo)\n    if (answer === Infinity) return -1\n    return answer\n};\n\n"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "Can you share your code I\\'ll be much easier to figure out"
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can someone just clarify why we have to run bfs on all nodes inspite of only unvisited ones ?"
                    },
                    {
                        "username": "15o1",
                        "content": "Easiest hard problem"
                    },
                    {
                        "username": "15o1",
                        "content": "[@workcool](/workcool) my code works fine on this"
                    },
                    {
                        "username": "workcool",
                        "content": "Nah, I don\\'t think so, it is pretty trick for test cases such as [[0,3],[0,5],[3,4],[4,5],[1,9],[1,11],[9,10],[11,10],[2,6],[2,8],[6,7],[8,7],[0,1],[0,2],[1,2]]"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "I have written code for  the problem but it is applicable for some testcases. Can anyone help me to figure out what is wrong is this. my inline code..\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        HashSet<Integer>hash = new HashSet<>();\\n        for(int i= 0; i<edges.length; i++){\\n            hash.add(edges[i][0]);\\n            hash.add(edges[i][1]);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        boolean[] visited = new boolean[n];\\n        for (int i: hash) {\\n            if (!visited[i]) {\\n                int val = dfs(i, -1, graph, visited, 1);\\n                min = Math.min(val, min);\\n            }\\n        }\\n        return min;\\n    }\\n\\n    public int dfs(int curr, int par, List<List<Integer>> graph, boolean[] visited, int count) {\\n        visited[curr] = true;\\n        for (int neighbor : graph.get(curr)) {\\n            if (visited[neighbor] && neighbor != par) {\\n                return count;\\n            } else if (!visited[neighbor]) {\\n                int result = dfs(neighbor, curr, graph, visited, count + 1);\\n                if (result != -1) {\\n                    return result;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\nCant we solve it using DFS?\\nIt\\'s giving TLE with dfs , Here is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can this problem be solved using dfs topological sort ?"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "no that is only applicable for directed acyclic graph and this problem is undirected."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me to figure out why dfs cycle detecting algo along with time_stamps doesn\\'t work here. Is there any linear solution for this problem.\\nThanks in advance!"
                    }
                ]
            },
            {
                "id": 1918242,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "Example of why normal DFS is not working:\\n\\n![image.png](https://assets.leetcode.com/users/images/5df4d6a1-83b3-4ec9-9666-8893fade3478_1680376230.8115823.png)\\n\\nSuppose, we start from 0, and do DFS like\\n$0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4$\\nThe cycle detected will be of length 5, $0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4 \\\\to 0$\\nBut the answer is 4, with cycle of $0 \\\\to 4 \\\\to 3 \\\\to 5 \\\\to 0$\\nSo, in DFS, it is possible to take a long cyclic route back to start, while ignoring the shorter cycles."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah,the leetcode one is way too simple. I tried searching for question that needed a longest cycle and the directed graph had nodes with multiple outgoing edges but I couldn\\'t find such a question anywhere at all. Well guess if some  interviewer does decide to ask it,I can always try applying this algo first and then think from there or even the BFS method would work on directed graphs."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Indeed it was a great question. Yes I think it should work on directed as only change is that we don\\'t have to add both side edges while creating adjacency list from `edges`. And for longest cycle we can initialize depth array with -1, check for `depth[next] < depth[curr] + 1` for not visited or already visited via shorter d. I am not sure though where to confirm as LeetCode\\'s one has only one outgoing directed edge."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah I finally did this solution as well. Had to search a lot and do a lot of thinking. This was a really good question. Do you think this same logic could be used for finding the longest cycle as well?And do you think it will work in a similar way on Directed Graphs as well? Actually I was trying to think of a general way for such cycle length questions that would apply to any general graph be it directed or undirected with minor changes."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Thanks for pointing this, looks like LeetCode has added strong test cases. See this failed graph:\n![image.png](https://assets.leetcode.com/users/images/ede2ed33-829e-4f41-88ef-a4787e3171ef_1683659936.2227714.png)\nDFS does not guarantee that we will reach the shortest cycle first. And if we marked the nodes as visited while going through a longer cycle first, then we will never traverse the shorter cycle.\nSo, based on this I have updated the link in my previous comment. See this [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) solution.\nHere I am traversing one complete component at a time. Main logic lies within these two statements:\n1. `if (depth[next] > depth[curr] + 1)`: In this case we are doing normal DFS traversal with increased depth `d + 1`. The if condition will be true if `depth[next] = INT_MAX` ie., not visited, OR if `depth[next] != INT_MAX && depth[next] > depth[curr] + 1` ie., we have visited this `next` node before but through a larger depth and now we want to visited it with some smaller depth `d + 1` so it is still possible to find a shorter cycle along this path.\n2. `if (depth[next] < depth[curr])`: In this case the shortest cycle for the current node has been found. Because we want to visit `next` with depth `d + 1` but it has already been visited with some smaller depth `depth[next]`. So we decide not to go along that path again and just update cycle length."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) I saw your DFS solution,but I am having difficulty understanding it,could you explain it in brief?I also copy pasted the DFS code from the link you gave and it failed at test case 85\n9\n[[4,5],[1,6],[6,4],[5,3],[3,6],[0,2],[5,8],[0,6],[3,0],[6,8],[2,8],[1,2]]\nIn fact all the DFS solutions in the solution section is failing this test case\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) Thanks that was super helpful. What made the difference in the end was adding a variable for depth and stopping when depth was larger than answer (i.e. the shortest path I had already found)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Psriraj](/Psriraj) See this traversal:\\n\\n![image.png](https://assets.leetcode.com/users/images/95caf2b2-c75b-4f71-8666-38d47f7b3925_1680419448.1463418.png)\\n\\nTry to do iterations, refer to iteration numbers. Green are those which are doing next recursive call. Reds are the backtracks when cycle is found, to previous call, by marking visited of current false. Underlined are those where cycle was found.\\n\\nSee how many times it is traversing on the same cycle again. And think if there was one more node in same graph, like $0 - 5 - 2$, then how many times it would have gone to same nodes again."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) I also tried to do DFS in contest, but it was TLE. But actually DFS solution is possible. See these: [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) and [BFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926373494/)."
                    },
                    {
                        "username": "Psriraj",
                        "content": "This is case is actually Handled here, but im not sure why this is giving a TLE!!\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I do get that, that is a nice illustration though! So I was looking for all possible cycles and wanted to just return the shortest one. Somewhat obviously that gives TLE. So I  was looking to use some sort of visited Set, or memo to stop  a search if the node is already visited, that gives the wrong answer for me. Is there absolutely no way around this?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I am trying to do this with DFS, which gave me TLE, I tried adding memorization, but I run out of memory. Is it possible to do it with DFS, or should I just give up and switch to BFS?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Mister_CK](/Mister_CK) thank you bro so much ur a life saver, "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "thanks for the help! What solve TLE for me in the end was to keep track of current cycle length (depth) and stop any iteration if depth>answer. "
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\n\\n[@nikhil97agra](/nikhil97agra)  Same issue here,\\nIts giving TLE with dfs , Heres is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n\\n\\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "@Mister_CK you may check this out https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926060450/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhil97agra](/nikhil97agra) sure, this is the code incl. memo, which ran out of space, without memo it runs out of time:\nhttps://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926046807/\n\nvar findShortestCycle = function(n, edges) {\n    let adacencyList = new Map()\n    edges.forEach(edge => {\n        if (adacencyList.has(edge[0])) {\n            let neighbours = adacencyList.get(edge[0])\n            neighbours.push(edge[1])\n            adacencyList.set(edge[0], neighbours)\n        } else {\n            adacencyList.set(edge[0], [edge[1]])\n        }\n        if (adacencyList.has(edge[1])) {\n            let neighbours = adacencyList.get(edge[1])\n            neighbours.push(edge[0])\n            adacencyList.set(edge[1], neighbours)\n        } else {\n            adacencyList.set(edge[1], [edge[0]])\n        }\n    })\n    //console.log(adacencyList)\n    let answer = Infinity\n    let visits = new Set()\n    let memo = {}\n    const dfs = (node, prevNode, visited) => {\n        let key ='' + node.toString()\n        visited.forEach(el => key += el.toString())\n        if (key in memo) return\n        memo[key] = true\n        //console.log(visited)\n        let neighbours = adacencyList.get(node)\n        let found = false\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            if (visited.has(neighbour) ) {\n                let length = visited.size - new Array(...visited).indexOf(neighbour)\n                answer = Math.min(answer, length)\n                found  = true\n            }\n        })\n        if (found) return\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            let alreadyVisited = new Set(visited)\n            alreadyVisited.add(neighbour)\n            dfs(neighbour, node, alreadyVisited)\n        })\n    }\n    for (let i = 0; i < n; i++) {\n        if (adacencyList.has(i)) { \n            dfs(i, -1, visits, 0)\n        }\n    }\n    //console.log(memo)\n    if (answer === Infinity) return -1\n    return answer\n};\n\n"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "Can you share your code I\\'ll be much easier to figure out"
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can someone just clarify why we have to run bfs on all nodes inspite of only unvisited ones ?"
                    },
                    {
                        "username": "15o1",
                        "content": "Easiest hard problem"
                    },
                    {
                        "username": "15o1",
                        "content": "[@workcool](/workcool) my code works fine on this"
                    },
                    {
                        "username": "workcool",
                        "content": "Nah, I don\\'t think so, it is pretty trick for test cases such as [[0,3],[0,5],[3,4],[4,5],[1,9],[1,11],[9,10],[11,10],[2,6],[2,8],[6,7],[8,7],[0,1],[0,2],[1,2]]"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "I have written code for  the problem but it is applicable for some testcases. Can anyone help me to figure out what is wrong is this. my inline code..\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        HashSet<Integer>hash = new HashSet<>();\\n        for(int i= 0; i<edges.length; i++){\\n            hash.add(edges[i][0]);\\n            hash.add(edges[i][1]);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        boolean[] visited = new boolean[n];\\n        for (int i: hash) {\\n            if (!visited[i]) {\\n                int val = dfs(i, -1, graph, visited, 1);\\n                min = Math.min(val, min);\\n            }\\n        }\\n        return min;\\n    }\\n\\n    public int dfs(int curr, int par, List<List<Integer>> graph, boolean[] visited, int count) {\\n        visited[curr] = true;\\n        for (int neighbor : graph.get(curr)) {\\n            if (visited[neighbor] && neighbor != par) {\\n                return count;\\n            } else if (!visited[neighbor]) {\\n                int result = dfs(neighbor, curr, graph, visited, count + 1);\\n                if (result != -1) {\\n                    return result;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\nCant we solve it using DFS?\\nIt\\'s giving TLE with dfs , Here is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can this problem be solved using dfs topological sort ?"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "no that is only applicable for directed acyclic graph and this problem is undirected."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me to figure out why dfs cycle detecting algo along with time_stamps doesn\\'t work here. Is there any linear solution for this problem.\\nThanks in advance!"
                    }
                ]
            },
            {
                "id": 1850813,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "Example of why normal DFS is not working:\\n\\n![image.png](https://assets.leetcode.com/users/images/5df4d6a1-83b3-4ec9-9666-8893fade3478_1680376230.8115823.png)\\n\\nSuppose, we start from 0, and do DFS like\\n$0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4$\\nThe cycle detected will be of length 5, $0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4 \\\\to 0$\\nBut the answer is 4, with cycle of $0 \\\\to 4 \\\\to 3 \\\\to 5 \\\\to 0$\\nSo, in DFS, it is possible to take a long cyclic route back to start, while ignoring the shorter cycles."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah,the leetcode one is way too simple. I tried searching for question that needed a longest cycle and the directed graph had nodes with multiple outgoing edges but I couldn\\'t find such a question anywhere at all. Well guess if some  interviewer does decide to ask it,I can always try applying this algo first and then think from there or even the BFS method would work on directed graphs."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Indeed it was a great question. Yes I think it should work on directed as only change is that we don\\'t have to add both side edges while creating adjacency list from `edges`. And for longest cycle we can initialize depth array with -1, check for `depth[next] < depth[curr] + 1` for not visited or already visited via shorter d. I am not sure though where to confirm as LeetCode\\'s one has only one outgoing directed edge."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah I finally did this solution as well. Had to search a lot and do a lot of thinking. This was a really good question. Do you think this same logic could be used for finding the longest cycle as well?And do you think it will work in a similar way on Directed Graphs as well? Actually I was trying to think of a general way for such cycle length questions that would apply to any general graph be it directed or undirected with minor changes."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Thanks for pointing this, looks like LeetCode has added strong test cases. See this failed graph:\n![image.png](https://assets.leetcode.com/users/images/ede2ed33-829e-4f41-88ef-a4787e3171ef_1683659936.2227714.png)\nDFS does not guarantee that we will reach the shortest cycle first. And if we marked the nodes as visited while going through a longer cycle first, then we will never traverse the shorter cycle.\nSo, based on this I have updated the link in my previous comment. See this [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) solution.\nHere I am traversing one complete component at a time. Main logic lies within these two statements:\n1. `if (depth[next] > depth[curr] + 1)`: In this case we are doing normal DFS traversal with increased depth `d + 1`. The if condition will be true if `depth[next] = INT_MAX` ie., not visited, OR if `depth[next] != INT_MAX && depth[next] > depth[curr] + 1` ie., we have visited this `next` node before but through a larger depth and now we want to visited it with some smaller depth `d + 1` so it is still possible to find a shorter cycle along this path.\n2. `if (depth[next] < depth[curr])`: In this case the shortest cycle for the current node has been found. Because we want to visit `next` with depth `d + 1` but it has already been visited with some smaller depth `depth[next]`. So we decide not to go along that path again and just update cycle length."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) I saw your DFS solution,but I am having difficulty understanding it,could you explain it in brief?I also copy pasted the DFS code from the link you gave and it failed at test case 85\n9\n[[4,5],[1,6],[6,4],[5,3],[3,6],[0,2],[5,8],[0,6],[3,0],[6,8],[2,8],[1,2]]\nIn fact all the DFS solutions in the solution section is failing this test case\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) Thanks that was super helpful. What made the difference in the end was adding a variable for depth and stopping when depth was larger than answer (i.e. the shortest path I had already found)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Psriraj](/Psriraj) See this traversal:\\n\\n![image.png](https://assets.leetcode.com/users/images/95caf2b2-c75b-4f71-8666-38d47f7b3925_1680419448.1463418.png)\\n\\nTry to do iterations, refer to iteration numbers. Green are those which are doing next recursive call. Reds are the backtracks when cycle is found, to previous call, by marking visited of current false. Underlined are those where cycle was found.\\n\\nSee how many times it is traversing on the same cycle again. And think if there was one more node in same graph, like $0 - 5 - 2$, then how many times it would have gone to same nodes again."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) I also tried to do DFS in contest, but it was TLE. But actually DFS solution is possible. See these: [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) and [BFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926373494/)."
                    },
                    {
                        "username": "Psriraj",
                        "content": "This is case is actually Handled here, but im not sure why this is giving a TLE!!\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I do get that, that is a nice illustration though! So I was looking for all possible cycles and wanted to just return the shortest one. Somewhat obviously that gives TLE. So I  was looking to use some sort of visited Set, or memo to stop  a search if the node is already visited, that gives the wrong answer for me. Is there absolutely no way around this?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I am trying to do this with DFS, which gave me TLE, I tried adding memorization, but I run out of memory. Is it possible to do it with DFS, or should I just give up and switch to BFS?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Mister_CK](/Mister_CK) thank you bro so much ur a life saver, "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "thanks for the help! What solve TLE for me in the end was to keep track of current cycle length (depth) and stop any iteration if depth>answer. "
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\n\\n[@nikhil97agra](/nikhil97agra)  Same issue here,\\nIts giving TLE with dfs , Heres is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n\\n\\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "@Mister_CK you may check this out https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926060450/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhil97agra](/nikhil97agra) sure, this is the code incl. memo, which ran out of space, without memo it runs out of time:\nhttps://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926046807/\n\nvar findShortestCycle = function(n, edges) {\n    let adacencyList = new Map()\n    edges.forEach(edge => {\n        if (adacencyList.has(edge[0])) {\n            let neighbours = adacencyList.get(edge[0])\n            neighbours.push(edge[1])\n            adacencyList.set(edge[0], neighbours)\n        } else {\n            adacencyList.set(edge[0], [edge[1]])\n        }\n        if (adacencyList.has(edge[1])) {\n            let neighbours = adacencyList.get(edge[1])\n            neighbours.push(edge[0])\n            adacencyList.set(edge[1], neighbours)\n        } else {\n            adacencyList.set(edge[1], [edge[0]])\n        }\n    })\n    //console.log(adacencyList)\n    let answer = Infinity\n    let visits = new Set()\n    let memo = {}\n    const dfs = (node, prevNode, visited) => {\n        let key ='' + node.toString()\n        visited.forEach(el => key += el.toString())\n        if (key in memo) return\n        memo[key] = true\n        //console.log(visited)\n        let neighbours = adacencyList.get(node)\n        let found = false\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            if (visited.has(neighbour) ) {\n                let length = visited.size - new Array(...visited).indexOf(neighbour)\n                answer = Math.min(answer, length)\n                found  = true\n            }\n        })\n        if (found) return\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            let alreadyVisited = new Set(visited)\n            alreadyVisited.add(neighbour)\n            dfs(neighbour, node, alreadyVisited)\n        })\n    }\n    for (let i = 0; i < n; i++) {\n        if (adacencyList.has(i)) { \n            dfs(i, -1, visits, 0)\n        }\n    }\n    //console.log(memo)\n    if (answer === Infinity) return -1\n    return answer\n};\n\n"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "Can you share your code I\\'ll be much easier to figure out"
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can someone just clarify why we have to run bfs on all nodes inspite of only unvisited ones ?"
                    },
                    {
                        "username": "15o1",
                        "content": "Easiest hard problem"
                    },
                    {
                        "username": "15o1",
                        "content": "[@workcool](/workcool) my code works fine on this"
                    },
                    {
                        "username": "workcool",
                        "content": "Nah, I don\\'t think so, it is pretty trick for test cases such as [[0,3],[0,5],[3,4],[4,5],[1,9],[1,11],[9,10],[11,10],[2,6],[2,8],[6,7],[8,7],[0,1],[0,2],[1,2]]"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "I have written code for  the problem but it is applicable for some testcases. Can anyone help me to figure out what is wrong is this. my inline code..\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        HashSet<Integer>hash = new HashSet<>();\\n        for(int i= 0; i<edges.length; i++){\\n            hash.add(edges[i][0]);\\n            hash.add(edges[i][1]);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        boolean[] visited = new boolean[n];\\n        for (int i: hash) {\\n            if (!visited[i]) {\\n                int val = dfs(i, -1, graph, visited, 1);\\n                min = Math.min(val, min);\\n            }\\n        }\\n        return min;\\n    }\\n\\n    public int dfs(int curr, int par, List<List<Integer>> graph, boolean[] visited, int count) {\\n        visited[curr] = true;\\n        for (int neighbor : graph.get(curr)) {\\n            if (visited[neighbor] && neighbor != par) {\\n                return count;\\n            } else if (!visited[neighbor]) {\\n                int result = dfs(neighbor, curr, graph, visited, count + 1);\\n                if (result != -1) {\\n                    return result;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\nCant we solve it using DFS?\\nIt\\'s giving TLE with dfs , Here is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can this problem be solved using dfs topological sort ?"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "no that is only applicable for directed acyclic graph and this problem is undirected."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me to figure out why dfs cycle detecting algo along with time_stamps doesn\\'t work here. Is there any linear solution for this problem.\\nThanks in advance!"
                    }
                ]
            },
            {
                "id": 1850664,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "Example of why normal DFS is not working:\\n\\n![image.png](https://assets.leetcode.com/users/images/5df4d6a1-83b3-4ec9-9666-8893fade3478_1680376230.8115823.png)\\n\\nSuppose, we start from 0, and do DFS like\\n$0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4$\\nThe cycle detected will be of length 5, $0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4 \\\\to 0$\\nBut the answer is 4, with cycle of $0 \\\\to 4 \\\\to 3 \\\\to 5 \\\\to 0$\\nSo, in DFS, it is possible to take a long cyclic route back to start, while ignoring the shorter cycles."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah,the leetcode one is way too simple. I tried searching for question that needed a longest cycle and the directed graph had nodes with multiple outgoing edges but I couldn\\'t find such a question anywhere at all. Well guess if some  interviewer does decide to ask it,I can always try applying this algo first and then think from there or even the BFS method would work on directed graphs."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Indeed it was a great question. Yes I think it should work on directed as only change is that we don\\'t have to add both side edges while creating adjacency list from `edges`. And for longest cycle we can initialize depth array with -1, check for `depth[next] < depth[curr] + 1` for not visited or already visited via shorter d. I am not sure though where to confirm as LeetCode\\'s one has only one outgoing directed edge."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah I finally did this solution as well. Had to search a lot and do a lot of thinking. This was a really good question. Do you think this same logic could be used for finding the longest cycle as well?And do you think it will work in a similar way on Directed Graphs as well? Actually I was trying to think of a general way for such cycle length questions that would apply to any general graph be it directed or undirected with minor changes."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Thanks for pointing this, looks like LeetCode has added strong test cases. See this failed graph:\n![image.png](https://assets.leetcode.com/users/images/ede2ed33-829e-4f41-88ef-a4787e3171ef_1683659936.2227714.png)\nDFS does not guarantee that we will reach the shortest cycle first. And if we marked the nodes as visited while going through a longer cycle first, then we will never traverse the shorter cycle.\nSo, based on this I have updated the link in my previous comment. See this [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) solution.\nHere I am traversing one complete component at a time. Main logic lies within these two statements:\n1. `if (depth[next] > depth[curr] + 1)`: In this case we are doing normal DFS traversal with increased depth `d + 1`. The if condition will be true if `depth[next] = INT_MAX` ie., not visited, OR if `depth[next] != INT_MAX && depth[next] > depth[curr] + 1` ie., we have visited this `next` node before but through a larger depth and now we want to visited it with some smaller depth `d + 1` so it is still possible to find a shorter cycle along this path.\n2. `if (depth[next] < depth[curr])`: In this case the shortest cycle for the current node has been found. Because we want to visit `next` with depth `d + 1` but it has already been visited with some smaller depth `depth[next]`. So we decide not to go along that path again and just update cycle length."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) I saw your DFS solution,but I am having difficulty understanding it,could you explain it in brief?I also copy pasted the DFS code from the link you gave and it failed at test case 85\n9\n[[4,5],[1,6],[6,4],[5,3],[3,6],[0,2],[5,8],[0,6],[3,0],[6,8],[2,8],[1,2]]\nIn fact all the DFS solutions in the solution section is failing this test case\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) Thanks that was super helpful. What made the difference in the end was adding a variable for depth and stopping when depth was larger than answer (i.e. the shortest path I had already found)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Psriraj](/Psriraj) See this traversal:\\n\\n![image.png](https://assets.leetcode.com/users/images/95caf2b2-c75b-4f71-8666-38d47f7b3925_1680419448.1463418.png)\\n\\nTry to do iterations, refer to iteration numbers. Green are those which are doing next recursive call. Reds are the backtracks when cycle is found, to previous call, by marking visited of current false. Underlined are those where cycle was found.\\n\\nSee how many times it is traversing on the same cycle again. And think if there was one more node in same graph, like $0 - 5 - 2$, then how many times it would have gone to same nodes again."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) I also tried to do DFS in contest, but it was TLE. But actually DFS solution is possible. See these: [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) and [BFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926373494/)."
                    },
                    {
                        "username": "Psriraj",
                        "content": "This is case is actually Handled here, but im not sure why this is giving a TLE!!\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I do get that, that is a nice illustration though! So I was looking for all possible cycles and wanted to just return the shortest one. Somewhat obviously that gives TLE. So I  was looking to use some sort of visited Set, or memo to stop  a search if the node is already visited, that gives the wrong answer for me. Is there absolutely no way around this?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I am trying to do this with DFS, which gave me TLE, I tried adding memorization, but I run out of memory. Is it possible to do it with DFS, or should I just give up and switch to BFS?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Mister_CK](/Mister_CK) thank you bro so much ur a life saver, "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "thanks for the help! What solve TLE for me in the end was to keep track of current cycle length (depth) and stop any iteration if depth>answer. "
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\n\\n[@nikhil97agra](/nikhil97agra)  Same issue here,\\nIts giving TLE with dfs , Heres is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n\\n\\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "@Mister_CK you may check this out https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926060450/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhil97agra](/nikhil97agra) sure, this is the code incl. memo, which ran out of space, without memo it runs out of time:\nhttps://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926046807/\n\nvar findShortestCycle = function(n, edges) {\n    let adacencyList = new Map()\n    edges.forEach(edge => {\n        if (adacencyList.has(edge[0])) {\n            let neighbours = adacencyList.get(edge[0])\n            neighbours.push(edge[1])\n            adacencyList.set(edge[0], neighbours)\n        } else {\n            adacencyList.set(edge[0], [edge[1]])\n        }\n        if (adacencyList.has(edge[1])) {\n            let neighbours = adacencyList.get(edge[1])\n            neighbours.push(edge[0])\n            adacencyList.set(edge[1], neighbours)\n        } else {\n            adacencyList.set(edge[1], [edge[0]])\n        }\n    })\n    //console.log(adacencyList)\n    let answer = Infinity\n    let visits = new Set()\n    let memo = {}\n    const dfs = (node, prevNode, visited) => {\n        let key ='' + node.toString()\n        visited.forEach(el => key += el.toString())\n        if (key in memo) return\n        memo[key] = true\n        //console.log(visited)\n        let neighbours = adacencyList.get(node)\n        let found = false\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            if (visited.has(neighbour) ) {\n                let length = visited.size - new Array(...visited).indexOf(neighbour)\n                answer = Math.min(answer, length)\n                found  = true\n            }\n        })\n        if (found) return\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            let alreadyVisited = new Set(visited)\n            alreadyVisited.add(neighbour)\n            dfs(neighbour, node, alreadyVisited)\n        })\n    }\n    for (let i = 0; i < n; i++) {\n        if (adacencyList.has(i)) { \n            dfs(i, -1, visits, 0)\n        }\n    }\n    //console.log(memo)\n    if (answer === Infinity) return -1\n    return answer\n};\n\n"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "Can you share your code I\\'ll be much easier to figure out"
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can someone just clarify why we have to run bfs on all nodes inspite of only unvisited ones ?"
                    },
                    {
                        "username": "15o1",
                        "content": "Easiest hard problem"
                    },
                    {
                        "username": "15o1",
                        "content": "[@workcool](/workcool) my code works fine on this"
                    },
                    {
                        "username": "workcool",
                        "content": "Nah, I don\\'t think so, it is pretty trick for test cases such as [[0,3],[0,5],[3,4],[4,5],[1,9],[1,11],[9,10],[11,10],[2,6],[2,8],[6,7],[8,7],[0,1],[0,2],[1,2]]"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "I have written code for  the problem but it is applicable for some testcases. Can anyone help me to figure out what is wrong is this. my inline code..\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        HashSet<Integer>hash = new HashSet<>();\\n        for(int i= 0; i<edges.length; i++){\\n            hash.add(edges[i][0]);\\n            hash.add(edges[i][1]);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        boolean[] visited = new boolean[n];\\n        for (int i: hash) {\\n            if (!visited[i]) {\\n                int val = dfs(i, -1, graph, visited, 1);\\n                min = Math.min(val, min);\\n            }\\n        }\\n        return min;\\n    }\\n\\n    public int dfs(int curr, int par, List<List<Integer>> graph, boolean[] visited, int count) {\\n        visited[curr] = true;\\n        for (int neighbor : graph.get(curr)) {\\n            if (visited[neighbor] && neighbor != par) {\\n                return count;\\n            } else if (!visited[neighbor]) {\\n                int result = dfs(neighbor, curr, graph, visited, count + 1);\\n                if (result != -1) {\\n                    return result;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\nCant we solve it using DFS?\\nIt\\'s giving TLE with dfs , Here is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can this problem be solved using dfs topological sort ?"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "no that is only applicable for directed acyclic graph and this problem is undirected."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me to figure out why dfs cycle detecting algo along with time_stamps doesn\\'t work here. Is there any linear solution for this problem.\\nThanks in advance!"
                    }
                ]
            },
            {
                "id": 1850422,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "Example of why normal DFS is not working:\\n\\n![image.png](https://assets.leetcode.com/users/images/5df4d6a1-83b3-4ec9-9666-8893fade3478_1680376230.8115823.png)\\n\\nSuppose, we start from 0, and do DFS like\\n$0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4$\\nThe cycle detected will be of length 5, $0 \\\\to 1 \\\\to 2 \\\\to 3 \\\\to 4 \\\\to 0$\\nBut the answer is 4, with cycle of $0 \\\\to 4 \\\\to 3 \\\\to 5 \\\\to 0$\\nSo, in DFS, it is possible to take a long cyclic route back to start, while ignoring the shorter cycles."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah,the leetcode one is way too simple. I tried searching for question that needed a longest cycle and the directed graph had nodes with multiple outgoing edges but I couldn\\'t find such a question anywhere at all. Well guess if some  interviewer does decide to ask it,I can always try applying this algo first and then think from there or even the BFS method would work on directed graphs."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Indeed it was a great question. Yes I think it should work on directed as only change is that we don\\'t have to add both side edges while creating adjacency list from `edges`. And for longest cycle we can initialize depth array with -1, check for `depth[next] < depth[curr] + 1` for not visited or already visited via shorter d. I am not sure though where to confirm as LeetCode\\'s one has only one outgoing directed edge."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) yeah I finally did this solution as well. Had to search a lot and do a lot of thinking. This was a really good question. Do you think this same logic could be used for finding the longest cycle as well?And do you think it will work in a similar way on Directed Graphs as well? Actually I was trying to think of a general way for such cycle length questions that would apply to any general graph be it directed or undirected with minor changes."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Deathangel5677](/Deathangel5677) Thanks for pointing this, looks like LeetCode has added strong test cases. See this failed graph:\n![image.png](https://assets.leetcode.com/users/images/ede2ed33-829e-4f41-88ef-a4787e3171ef_1683659936.2227714.png)\nDFS does not guarantee that we will reach the shortest cycle first. And if we marked the nodes as visited while going through a longer cycle first, then we will never traverse the shorter cycle.\nSo, based on this I have updated the link in my previous comment. See this [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) solution.\nHere I am traversing one complete component at a time. Main logic lies within these two statements:\n1. `if (depth[next] > depth[curr] + 1)`: In this case we are doing normal DFS traversal with increased depth `d + 1`. The if condition will be true if `depth[next] = INT_MAX` ie., not visited, OR if `depth[next] != INT_MAX && depth[next] > depth[curr] + 1` ie., we have visited this `next` node before but through a larger depth and now we want to visited it with some smaller depth `d + 1` so it is still possible to find a shorter cycle along this path.\n2. `if (depth[next] < depth[curr])`: In this case the shortest cycle for the current node has been found. Because we want to visit `next` with depth `d + 1` but it has already been visited with some smaller depth `depth[next]`. So we decide not to go along that path again and just update cycle length."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) I saw your DFS solution,but I am having difficulty understanding it,could you explain it in brief?I also copy pasted the DFS code from the link you gave and it failed at test case 85\n9\n[[4,5],[1,6],[6,4],[5,3],[3,6],[0,2],[5,8],[0,6],[3,0],[6,8],[2,8],[1,2]]\nIn fact all the DFS solutions in the solution section is failing this test case\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@shivamaggarwal513](/shivamaggarwal513) Thanks that was super helpful. What made the difference in the end was adding a variable for depth and stopping when depth was larger than answer (i.e. the shortest path I had already found)"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Psriraj](/Psriraj) See this traversal:\\n\\n![image.png](https://assets.leetcode.com/users/images/95caf2b2-c75b-4f71-8666-38d47f7b3925_1680419448.1463418.png)\\n\\nTry to do iterations, refer to iteration numbers. Green are those which are doing next recursive call. Reds are the backtracks when cycle is found, to previous call, by marking visited of current false. Underlined are those where cycle was found.\\n\\nSee how many times it is traversing on the same cycle again. And think if there was one more node in same graph, like $0 - 5 - 2$, then how many times it would have gone to same nodes again."
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@Mister_CK](/Mister_CK) I also tried to do DFS in contest, but it was TLE. But actually DFS solution is possible. See these: [DFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/947407433/) and [BFS](https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926373494/)."
                    },
                    {
                        "username": "Psriraj",
                        "content": "This is case is actually Handled here, but im not sure why this is giving a TLE!!\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I do get that, that is a nice illustration though! So I was looking for all possible cycles and wanted to just return the shortest one. Somewhat obviously that gives TLE. So I  was looking to use some sort of visited Set, or memo to stop  a search if the node is already visited, that gives the wrong answer for me. Is there absolutely no way around this?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I am trying to do this with DFS, which gave me TLE, I tried adding memorization, but I run out of memory. Is it possible to do it with DFS, or should I just give up and switch to BFS?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "[@Mister_CK](/Mister_CK) thank you bro so much ur a life saver, "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "thanks for the help! What solve TLE for me in the end was to keep track of current cycle length (depth) and stop any iteration if depth>answer. "
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\n\\n[@nikhil97agra](/nikhil97agra)  Same issue here,\\nIts giving TLE with dfs , Heres is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n\\n\\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "@Mister_CK you may check this out https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926060450/"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@nikhil97agra](/nikhil97agra) sure, this is the code incl. memo, which ran out of space, without memo it runs out of time:\nhttps://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926046807/\n\nvar findShortestCycle = function(n, edges) {\n    let adacencyList = new Map()\n    edges.forEach(edge => {\n        if (adacencyList.has(edge[0])) {\n            let neighbours = adacencyList.get(edge[0])\n            neighbours.push(edge[1])\n            adacencyList.set(edge[0], neighbours)\n        } else {\n            adacencyList.set(edge[0], [edge[1]])\n        }\n        if (adacencyList.has(edge[1])) {\n            let neighbours = adacencyList.get(edge[1])\n            neighbours.push(edge[0])\n            adacencyList.set(edge[1], neighbours)\n        } else {\n            adacencyList.set(edge[1], [edge[0]])\n        }\n    })\n    //console.log(adacencyList)\n    let answer = Infinity\n    let visits = new Set()\n    let memo = {}\n    const dfs = (node, prevNode, visited) => {\n        let key ='' + node.toString()\n        visited.forEach(el => key += el.toString())\n        if (key in memo) return\n        memo[key] = true\n        //console.log(visited)\n        let neighbours = adacencyList.get(node)\n        let found = false\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            if (visited.has(neighbour) ) {\n                let length = visited.size - new Array(...visited).indexOf(neighbour)\n                answer = Math.min(answer, length)\n                found  = true\n            }\n        })\n        if (found) return\n        neighbours.forEach(neighbour => {\n            if (neighbour === prevNode) return\n            let alreadyVisited = new Set(visited)\n            alreadyVisited.add(neighbour)\n            dfs(neighbour, node, alreadyVisited)\n        })\n    }\n    for (let i = 0; i < n; i++) {\n        if (adacencyList.has(i)) { \n            dfs(i, -1, visits, 0)\n        }\n    }\n    //console.log(memo)\n    if (answer === Infinity) return -1\n    return answer\n};\n\n"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "Can you share your code I\\'ll be much easier to figure out"
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can someone just clarify why we have to run bfs on all nodes inspite of only unvisited ones ?"
                    },
                    {
                        "username": "15o1",
                        "content": "Easiest hard problem"
                    },
                    {
                        "username": "15o1",
                        "content": "[@workcool](/workcool) my code works fine on this"
                    },
                    {
                        "username": "workcool",
                        "content": "Nah, I don\\'t think so, it is pretty trick for test cases such as [[0,3],[0,5],[3,4],[4,5],[1,9],[1,11],[9,10],[11,10],[2,6],[2,8],[6,7],[8,7],[0,1],[0,2],[1,2]]"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "I have written code for  the problem but it is applicable for some testcases. Can anyone help me to figure out what is wrong is this. my inline code..\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public int findShortestCycle(int n, int[][] edges) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int[] edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        HashSet<Integer>hash = new HashSet<>();\\n        for(int i= 0; i<edges.length; i++){\\n            hash.add(edges[i][0]);\\n            hash.add(edges[i][1]);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        boolean[] visited = new boolean[n];\\n        for (int i: hash) {\\n            if (!visited[i]) {\\n                int val = dfs(i, -1, graph, visited, 1);\\n                min = Math.min(val, min);\\n            }\\n        }\\n        return min;\\n    }\\n\\n    public int dfs(int curr, int par, List<List<Integer>> graph, boolean[] visited, int count) {\\n        visited[curr] = true;\\n        for (int neighbor : graph.get(curr)) {\\n            if (visited[neighbor] && neighbor != par) {\\n                return count;\\n            } else if (!visited[neighbor]) {\\n                int result = dfs(neighbor, curr, graph, visited, count + 1);\\n                if (result != -1) {\\n                    return result;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Psriraj",
                        "content": "https://leetcode.com/problems/shortest-cycle-in-a-graph/submissions/926007896/\\n\\nCant we solve it using DFS?\\nIt\\'s giving TLE with dfs , Here is the solution :\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node,int parent,int num,unordered_map<int,vector<int>> &adj,vector<bool> &visited,vector<int> &rank,int &ans){\\n        \\n        visited[node] = true;\\n        rank[node] = num;\\n        \\n        for(auto nbr : adj[node]){\\n            if(nbr!=parent){\\n                if(visited[nbr] == true){\\n                    if(ans == -1) ans = num - rank[nbr] + 1;\\n                    else ans = min(ans,num - rank[nbr] + 1);\\n                }else{\\n                    dfs(nbr,node,num+1,adj,visited,rank,ans);\\n                }\\n            }\\n        }\\n        \\n        visited[node] = false;\\n        return ;\\n    }\\npublic:\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int,vector<int>> adj;\\n        for(auto edge : edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<bool> visited(n,false);\\n        vector<int> rank(n,-1);\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(rank[i] == -1){\\n                cout<<\"starting at \"<<i<<endl;\\n                dfs(i,-1,0,adj,visited,rank,ans);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```"
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can this problem be solved using dfs topological sort ?"
                    },
                    {
                        "username": "Devendra_jangir",
                        "content": "no that is only applicable for directed acyclic graph and this problem is undirected."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me to figure out why dfs cycle detecting algo along with time_stamps doesn\\'t work here. Is there any linear solution for this problem.\\nThanks in advance!"
                    }
                ]
            }
        ]
    }
]